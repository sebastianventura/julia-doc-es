<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Funciones · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li class="current"><a class="toctext" href="functions.html">Funciones</a><ul class="internal"><li><a class="toctext" href="#Comportamiento-del-Paso-de-Argumentos-1">Comportamiento del Paso de Argumentos</a></li><li><a class="toctext" href="#La-palabra-clave-return-1">La palabra clave <code>return</code></a></li><li><a class="toctext" href="#Operators-Are-Functions-1">Operators Are Functions</a></li><li><a class="toctext" href="#Operadores-con-Nombres-Especiales-1">Operadores con Nombres Especiales</a></li><li><a class="toctext" href="#man-anonymous-functions-1">Funciones Anónimas</a></li><li><a class="toctext" href="#Retorno-de-Múltiples-Valores-1">Retorno de Múltiples Valores</a></li><li><a class="toctext" href="#vararg-functions-1">Funciones con argumentos variables (varargs)</a></li><li><a class="toctext" href="#Argumentos-Opcionales-1">Argumentos Opcionales</a></li><li><a class="toctext" href="#Argumentos-*keyword*-1">Argumentos <em>keyword</em></a></li><li><a class="toctext" href="#Ámbito-de-evaluación-de-Valores-por-defecto-1">Ámbito de evaluación de Valores por defecto</a></li><li><a class="toctext" href="#Sintaxis-Bloque-Do-para-Argumentos-Function-1">Sintaxis Bloque Do para Argumentos Function</a></li><li><a class="toctext" href="#man-vectorized-1">Sintaxis Punto para funciones Vectorizadas</a></li><li><a class="toctext" href="#Otras-Lecturas-1">Otras Lecturas</a></li></ul></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="types.html">Tipos</a></li><li><a class="toctext" href="methods.html">Métodos</a></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión and Promoción</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="functions.html">Funciones</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Funciones</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="man-functions-1" href="#man-functions-1">Funciones</a></h1><p>En Julia, una función es un objeto que hace corresponde una tupla de valores argumentos en un valor de retorno. Las funciones de Julia no son funciones matemáticas puras, en el sentido  de que pueden alterar y ser afectadas por el estado global del programa. La sintaxis básica  a definir funciones en Julia es:</p><pre><code class="language-julia-repl">julia&gt; function f(x,y)
           x + y
       end
f (generic function with 1 method)</code></pre><p>Hay una segunda sintaxis, más concisa, para definir una función en Julia. La declaración de  función tradicional mostrada anteriormente es equivalente a la denominada &quot;forma de asignación&quot;.  Por ejemplo:</p><pre><code class="language-jldoctest">julia&gt; f(x,y) = x + y
f (generic function with 1 method)</code></pre><p>En esta segunda forma, el cuerpo de la función debe ser una sola expresión, aunque puede  tratarse de una expresión compuesta (see <a href="control-flow.html#man-compound-expressions-1">Expresiones Compuestas</a>).  Estas definiciones de función cortas y simples son comunes en Julia. La sintaxis de funciones cortas es, por tanto, bastante idiomática, reduciendo considerablemente tanto la escritura como  el ruido visual.</p><p>Para invocar una función se usa la sintaxis tradicional basada en el uso del paréntesis:</p><pre><code class="language-jldoctest">julia&gt; f(2,3)
5</code></pre><p>Sin usar paréntesis, la expresión <code>f</code> se refiere al objeto función, y puede ser tratada como cualquier otro valor:</p><pre><code class="language-jldoctest">julia&gt; g = f;

julia&gt; g(2,3)
5</code></pre><p>Y, como en el caso de las variables, podemos usar Unicode en el caso de los nombres de función:</p><pre><code class="language-julia-repl">julia&gt; ∑(x,y) = x + y
∑ (generic function with 1 method)

julia&gt; ∑(2, 3)
5</code></pre><h2><a class="nav-anchor" id="Comportamiento-del-Paso-de-Argumentos-1" href="#Comportamiento-del-Paso-de-Argumentos-1">Comportamiento del Paso de Argumentos</a></h2><p>Los argumentos de función en Julia siguen un convenio denominado a veces &quot;paso por compartición&quot;,  que significa que los valores no son copiados cuando se pasan a las funciones. Los argumentos de  las funciones actúan ellos mismos como nuevos enlaces a variable (nuevas localizaciones que pueden  referirse a valores) pero los valores a los que se refieren son idénticos a los valores pasados.  Las modificaciones a valores mutables (tales como los Arrays) hechos dentro de la función serán  visibles desde fuera de ésta. Este es el mismo comportamiento que presenta Scheme, la mayoría de  versiones de Lisp, Python, Ruby y Perl, entre otros lenguajes dinámicos.</p><h2><a class="nav-anchor" id="La-palabra-clave-return-1" href="#La-palabra-clave-return-1">La palabra clave <code>return</code></a></h2><p>El valor devuelto por una función es el valor de la última expresión evaluada, el cual, por  defecto, es la última expresión en el cuerpo de definición de la función. En la función <code>f</code>,  mostrada en la sección anterior, el valor devuelto sería la suma <code>x + y</code>. Como en C y la mayoría  de los demás lenguajes imperativos o funcionales, la palabra clave <code>return</code> causa que la función  retorne inmediatamente, proporcionando una función cuyo valor es devuelto:</p><pre><code class="language-julia">function g(x,y)
    return x * y
    x + y
end</code></pre><p>Como las definiciones a función pueden ser introducidas en una sesión interactiva, es muy sencillo comparar estas definiciones:</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = x + y
f (generic function with 1 method)

julia&gt; function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia&gt; f(2,3)
5

julia&gt; g(2,3)
6</code></pre><p>Por supuesto, en una función con cuerpo puramente lineal como <code>g</code>, el uso de <code>return</code> es irrelevante ya que la expresión <code>x+y</code> nunca va a ser evaluada, por lo que podríamos hacer que <code>x*y</code> fuese la última línea de la función y omitir el <code>return</code>. Sin embargo, cuando hacemos uso de esta instrucción junto con otras de control de flujo, el resultado puede ser muy interesante. Aquí, por ejemplo, hay una función que calcula la longitud de la hipotenusa de un triángulo equilátero correcto con catetos de longitudes <code>x</code> e <code>y</code>, evitando un desbordamiento:</p><pre><code class="language-julia-repl">julia&gt; function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x &gt; y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia&gt; hypot(3, 4)
5.0</code></pre><p>Hay tres posibles puntos de retorno en esta función, devolviendo los valores de tres expresiones diferentes, dependiendo de los valores de <code>x</code> e <code>y</code>. El <code>return</code> de la última línea podría ser omitido ya que es la última expresión.</p><h2><a class="nav-anchor" id="Operators-Are-Functions-1" href="#Operators-Are-Functions-1">Operators Are Functions</a></h2><p>En Julia, la mayoría de los operadores son funciones con soporte para una sintaxis especial (la excepción a esta regla son las operaciones con una semática de evaluación especial, tales como <code>&amp;&amp;</code> y <code>||</code>. Estos operadores no pueden ser funciones porque la <a href="control-flow.html#short-circuit-evaluation-1">Evaluación en Cortocircuito</a> requiere que sus operandos no sean evaluados antes de la evaluación del operador). De acuerdo con ésto, podemos usar listas de argumentos entre paréntesis, tal como en cualquier otra función:</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; +(1,2,3)
6</code></pre><p>La forma infija es equivalente a la forma de aplicación función. De hecho, la primera es transformada para producir la llamada a función internamente. Esto también significa que puedes asignar y pasar operadores tales como <a href="../stdlib/math.html#Base.:+"><code>+()</code></a> y <a href="../stdlib/strings.html#Base.:*-Tuple{AbstractString,Vararg{Any,N} where N}"><code>*()</code></a> , tal y como se hace con otros valores función:</p><pre><code class="language-julia-repl">julia&gt; f = +;

julia&gt; f(1,2,3)
6</code></pre><p>Sin embargo, cuando se usa el formato de función, como <code>f</code>, no se puede usar notación infija.</p><h2><a class="nav-anchor" id="Operadores-con-Nombres-Especiales-1" href="#Operadores-con-Nombres-Especiales-1">Operadores con Nombres Especiales</a></h2><p>Hay unas pocas operaciones especiales que corresponden a llamadas a funciones con nombres no obvios. Estas son las siguientes:</p><table><tr><th>Expresión       </th><th>Llamada              </th></tr><tr><td><code>[A B C ...]</code></td><td><a href="../stdlib/arrays.html#Base.hcat"><code>hcat()</code></a></td></tr><tr><td><code>[A; B; C; ...]</code></td><td><a href="../stdlib/arrays.html#Base.vcat"><code>vcat()</code></a></td></tr><tr><td><code>[A B; C D; ...]</code></td><td><a href="../stdlib/arrays.html#Base.hvcat"><code>hvcat()</code></a></td></tr><tr><td><code>A&#39;</code></td><td><a href="../stdlib/linalg.html#Base.ctranspose"><code>ctranspose()</code></a></td></tr><tr><td><code>A.&#39;</code></td><td><a href="../stdlib/linalg.html#Base.transpose"><code>transpose()</code></a></td></tr><tr><td><code>1:n</code></td><td><a href="../stdlib/math.html#Base.colon"><code>colon()</code></a></td></tr><tr><td><code>A[i]</code></td><td><a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex()</code></a></td></tr><tr><td><code>A[i]=x</code></td><td><a href="../stdlib/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}"><code>setindex!()</code></a></td></tr></table><p>Estasa funciones están incluidas en el módulo <code>Base.Operators</code> incluso aunque no tengan nombres como operadores.</p><h2><a class="nav-anchor" id="man-anonymous-functions-1" href="#man-anonymous-functions-1">Funciones Anónimas</a></h2><p>Las funciones en Julia son <a href="https://en.wikipedia.org/wiki/First-class_citizen">objetos de primera clase</a>: ellas pueden ser asignadas a variables y ser invocadas usando la sintaxis estándar de llamadas a función desde la variable a la que han sido asignadas. Ellas pueden ser usadas como argumentos y ser devueltas como valores. Ellas pueden también ser usadas de forma anónima sin dárseles un nombre, usando alguna de estas sintaxis:</p><pre><code class="language-julia-repl">julia&gt; x -&gt; x^2 + 2x - 1
(::#1) (generic function with 1 method)

julia&gt; function (x)
           x^2 + 2x - 1
       end
(::#3) (generic function with 1 method)</code></pre><p>Esto crea una función que toma un argumento <code>x</code> y devuelve el valor del polinomio <code>x^2 + 2x - 1</code>. Nótese que el resultado es una función genérica, pero con un nombre generado por el compilador basado en una numeración consecutiva.</p><p>El uso primario de las funciones anónimas es pasarlas a funciones que toman otras funciones como argumentos. Un ejemplo clásico es <a href="../stdlib/collections.html#Base.map"><code>map()</code></a>, , que aplica una función a cada valor de un array y devuelve un nuevo array que contienen los valores resultantes:</p><pre><code class="language-julia-repl">julia&gt; map(round, [1.2,3.5,1.7])
3-element Array{Float64,1}:
 1.0
 4.0
 2.0</code></pre><p>Esto está bien si ya exite una función que efectúa la transformación que uno desea para pasarla como primer argumento de <a href="../stdlib/collections.html#Base.map"><code>map()</code></a>. Sin embargo, no es frecuente que exista este tipo de función. En estas situaciones, el constructor de la función anónima permite una fácil creación de un objeto función de un solo uso sin necesidad de asignarle un nombre:</p><pre><code class="language-julia-repl">julia&gt; map(x -&gt; x^2 + 2x - 1, [1,3,-1])
3-element Array{Int64,1}:
  2
 14
 -2</code></pre><p>Para escribir funciones anónimas que aceptan múltiples argumentos puede utilizarse la sintaxis <code>(x,y,z) -&gt; 2x + y +z</code>. Una función anónima con cero argumentos se escribe como <code>() -&gt; 3</code>.  La idea de una función sin argumentos puede parecer extraña, pero es útil para demorar un cálculo. En este uso, un bloque de código es envuelto en una función con cero argumentos, el cual es después invocado mediante una llamada como <code>f()</code>.</p><h2><a class="nav-anchor" id="Retorno-de-Múltiples-Valores-1" href="#Retorno-de-Múltiples-Valores-1">Retorno de Múltiples Valores</a></h2><p>En Julia, uno devuelve una tupla para simular el retorno de múltiples valores. Sin embargo, como las tuplas puede salteadas y destruidas sin necesitar paréntesis, podemos proporcionar una ilusión de que se están devolviendo múltiples valores. Por ejemplo, la siguiente función devuelve un par de valores:</p><pre><code class="language-jldoctest">julia&gt; function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)</code></pre><p>Si invocamos esta función en una sesión interactiva sin asignar los valores en ningún sitio, comprobaremos que la función devuelve una tupla:</p><pre><code class="language-jldoctest">julia&gt; foo(2,3)
(5, 6)</code></pre><p>Un uso típico de tal par de valores devueltos es extraer cada valor en una variable. Julia soporta la &quot;desestructuración&quot; simple de una tupla que facilita esto:</p><pre><code class="language-jldoctest">julia&gt; x, y = foo(2,3)
(5, 6)

julia&gt; x
5

julia&gt; y
6</code></pre><p>Y también podemos devolver múltiples valores mediante el uso explícito de la palabra clave <code>return</code>:</p><pre><code class="language-julia">function foo(a,b)
    return a+b, a*b
end</code></pre><p>Esto tiene exactamente el mismo efecto que la definición anterior de <code>foo</code>.</p><h2><a class="nav-anchor" id="vararg-functions-1" href="#vararg-functions-1">Funciones con argumentos variables (varargs)</a></h2><p>Suele ser muy conveniente ser capaz de escribir funciones que toman un número arbitrario de argumentos. Estas funciones se conocen como <em>funciones vararg</em>. Podemos definir funciones de tal tipo poniendo puntos suspensivos <code>…</code> después del último argumento.</p><pre><code class="language-jldoctest">julia&gt; bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)</code></pre><p>Las variables <code>a</code> y <code>b</code> están asociadas a los dos primeros argumentos como es natural, y la variable <code>x</code> se asocia a una colección, iterable de cero o más valores pasados a la función <code>bar</code> después de estos dos argumentos:</p><pre><code class="language-jldoctest">julia&gt; bar(1,2)
(1, 2, ())

julia&gt; bar(1,2,3)
(1, 2, (3,))

julia&gt; bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))</code></pre><p>En todos los casos, <code>x</code> es asociada a una tupla con el resto de valores pasados a la función.</p><p>Es posible restringir el número de argumentos pasados como argumento variable. Esto se discutirá más adelante en la sección <a href="methods.html#parametrically-constrained-varargs-methods-1">métodos <em>vararg</em> restringidos paramétricamente</a>.</p><p>Como contraposición, es frecuente manejar la división de los valores contenidos en una colección iterable en una llamada a función como argumentos individuales. Para hacer eso, se utilizará la notación de puntos suspensivos, pero esta vez en la llamada a función.</p><pre><code class="language-jldoctest">julia&gt; x = (3, 4)
(3, 4)

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))</code></pre><p>En este caso hay una tupla que se divide en una llamada <em>vararg</em> precisamente donde está el número de argumentos variable. Esa necesidad no tiene por qué ser el caso:</p><pre><code class="language-jldoctest">julia&gt; x = (2, 3, 4)
(2, 3, 4)

julia&gt; bar(1,x...)
(1, 2, (3, 4))

julia&gt; x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><p>Además, el objeto iterable dividido durante la llamada a función no tiene que ser una tupla:</p><pre><code class="language-jldoctest">julia&gt; x = [3,4]
2-element Array{Int64,1}:
 3
 4

julia&gt; bar(1,2,x...)
(1, 2, (3, 4))

julia&gt; x = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; bar(x...)
(1, 2, (3, 4))</code></pre><p>También, la función cuyos argumentos son divididos no tiene por qué ser una función <em>vararg</em> (aunque frecuentemente lo sea):</p><pre><code class="language-julia-repl">julia&gt; baz(a,b) = a + b;

julia&gt; args = [1,2]
2-element Array{Int64,1}:
 1
 2

julia&gt; baz(args...)
3

julia&gt; args = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
  baz(::Any, ::Any) at none:1</code></pre><p>Como puede comprobarse, si el número de elementos que se van a sacar del contenedor es inapropiado  para pasar a la función como argumentos, se generará un error, igual que si hubiéramos realizado la llamada a función con un número de argumentos inapropiado.</p><h2><a class="nav-anchor" id="Argumentos-Opcionales-1" href="#Argumentos-Opcionales-1">Argumentos Opcionales</a></h2><p>En muchos casos, los argumentos de función tienen valores por defecto sensibles y, por tanto, puede no ser necesario que se pasen explícitamente en cada llamada. Por ejemplo, la función de librería <a href="../stdlib/numbers.html#Base.parse-Tuple{Type,Any,Any}"><code>parse(T, num, base)</code></a> interpreta una cadena como un número en cierta base. El argumento <code>base</code> tiene un valor por defecto de <code>10</code>. Este comportamiento puede expresarse de forma concisa como:</p><pre><code class="language-julia">function parse(T, num, base=10)
    ###
end</code></pre><p>Con esta definición, la función puede ser llamada con dos o tres argumentos y, cuando no se pase el tercer argumento, la función asignara el valor por defecto de <code>10</code> al parámetro <code>base</code>.</p><pre><code class="language-julia-repl">julia&gt; parse(Int,&quot;12&quot;,10)
12

julia&gt; parse(Int,&quot;12&quot;,3)
5

julia&gt; parse(Int,&quot;12&quot;)
12</code></pre><p>Los argumentos opcionales son una sintaxis conveniente para escribir múltiples definiciones de métodos con diferentes números de argumentos (ver <a href="methods.html#note-on-optional-and-keyword-arguments-1">Nota sobre Argumentos opcionales y <em>keyword</em></a>).</p><h2><a class="nav-anchor" id="Argumentos-*keyword*-1" href="#Argumentos-*keyword*-1">Argumentos <em>keyword</em></a></h2><p>Algunas funciones necesitan un número de argumentos grande o tienen un gran número de comportamientos. Recordar como llamar a tales funciones puede ser difícil. Los argumentos <em>keyword</em> pueden hacer que estas interfaces complejas sean más fáciles de usar y extender permitiendo que los argumentos sean identificados por su nombre en lugar del por su posición.</p><p>Por ejemplo, considere una función <code>plot</code> que traza una línea. Esta función puede tener muchas opciones para controlar el estilo de línea, su ancho, su color, etc. Si la función  aceptara argumentos <em>keyword</em>, una posible llamada al método seria <code>plot(x,y, width=2)</code>, donde hemos elegido especificar sólo el ancho de línea. Nótese que esto sirve a dos propósitos: La llamada es más sencillo leer, ya que podemos etiquetar un argumento con su significado. También se vuelve posible pasar cualquier subconjunto de un gran número de argumentos, en cualquier orden.</p><p>Las funciones con argumentos <em>keyword</em> se definen usando un punto y coma en la signatura:</p><pre><code class="language-julia">function plot(x, y; style=&quot;solid&quot;, width=1, color=&quot;black&quot;)
    ###
end</code></pre><p>Cuando la función es invocada, el punto y coma es opcional: uno puede hacer la llamada como <code>plot(x, y, width=2)</code>o como <code>plot(x, y; width=2)</code>, aunque el primero es más común. Se requiere un punto y coma explícito sólo en el caso de pasar <em>vargars</em> o palabras clave calculadas como se describe abajo.</p><p>Los valores por defecto de los argumentos <em>keyword</em> son evaluados sólo cuando sea necesario (cuando no se pasa el correspondiente argumento <em>keyword</em>) y en orden izquierda a derecha. Por tanto, las expresiones por defecto pueden referirse a argumentos <em>keyword</em> previos.</p><p>Los tipos de argumentos <em>keyword</em>  pueden hacerse explícitos de la siguiente forma:</p><pre><code class="language-julia">function f(;x::Int64=1)
    ###
end</code></pre><p>Los argumentos <em>keyword</em> extra pueden ser recolectados usando <code>...</code> como en las funciones <em>vararg</em>:</p><pre><code class="language-julia">function f(x; y=0, kwargs...)
    ###
end</code></pre><p>Dentro de <code>f</code>, <code>kwargs</code> será una colección de tuplas <code>(clave,valor)</code>, donde cada <code>clave</code> es un símbolo. Tales colecciones pueden ser pasadas como argumentos <em>keyword</em> usando un punto y coma en la llamada. Por ejemplo: <code>f(x, z=1; kwargs...)</code>. Los diccionarios pueden ser también usados para este propósito.</p><p>Uno puede también pasar tuplas <code>(clave, valor)</code> o cualquier expresión iterable (tal como un par <code>=&gt;</code>) que puede ser asignado a una tupla, explícitamente después de un punto y coma. Por ejemplo, <code>plot(x, y; (:width,2))</code> y <code>plot(x, y; :width =&gt; 2)</code> son equivalentes a <code>plot(x, y, width=2)</code>. Esto es útil en situaciones donde el nombre de la palabra clave se calcula en tiempo de ejecución.</p><p>La naturaleza de los argumentos <em>keyword</em>  le hace posible especificar el mismo argumento más de una vez. Por ejemplo, en la llamada <code>plot(x, y; options..., width=2)</code> es posible que la estructura <code>options</code> contenga también un valor para <code>width</code>. En tal caso la ocurrencia más a la derecha toma precedencia; en este ejemplo <code>width</code> tendrá el valor <code>2</code>.</p><h2><a class="nav-anchor" id="Ámbito-de-evaluación-de-Valores-por-defecto-1" href="#Ámbito-de-evaluación-de-Valores-por-defecto-1">Ámbito de evaluación de Valores por defecto</a></h2><p>Los argumentos opcionales y <em>keyword</em> difieren ligeramente en cómo sus valores son evaluados. Cuando se evalúan expresiones por defecto con valores opcionales, sólo están en el ámbito lo valores <em>previos</em>. En contraste, cuando se evalúan las expresiones por defecto con argumentos <em>keyword</em>, <em>todos</em> los argumentos están en el ámbito. Por ejemplo, dada esta definición:</p><pre><code class="language-julia">function f(x, a=b, b=1)
    ###
end</code></pre><p>la <code>b</code> en <code>a=b</code> se refiere a la <code>b</code> de un ámbito más externo, no el siguiente argumento <code>b</code>. Sin embargo, si <code>a</code> y <code>b</code> fueran argumentos <em>keyword</em> en lugar de opcionales, el <code>b</code> en <code>a=b</code> se referiría al argumento posterior <code>b</code> (ocultando a cualqiuer <code>b</code> de un ámbito ms externo), lo que resultaría en un error de variable indefinida (ya que las expresiones por defecto son evaluadas de izquierda a derecha, y <code>b</code> no ha sido aún asignada).</p><h2><a class="nav-anchor" id="Sintaxis-Bloque-Do-para-Argumentos-Function-1" href="#Sintaxis-Bloque-Do-para-Argumentos-Function-1">Sintaxis Bloque Do para Argumentos Function</a></h2><p>Pasar funciones como argumentos a otras funciones es una técnica muy potente, pero su sintaxis no es siempre conveniente. Estas llamadas son especialmente incómodas de escribir cuando la función argumento necesita varias líneas. Por ejemplo, consideremos llamar a  <a href="../stdlib/collections.html#Base.map"><code>map()</code></a> sobre una función con varios casos:</p><pre><code class="language-julia">map(x-&gt;begin
           if x &lt; 0 &amp;&amp; iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])</code></pre><p>Julia proporciona la palabra reservada <code>do</code> para reescribir este código de forma más clara:</p><pre><code class="language-julia">map([A, B, C]) do x
    if x &lt; 0 &amp;&amp; iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end</code></pre><p>La sintaxis <code>do x</code> crea una función anónima con argumento <code>x</code> y la pasa como primer argumento a <a href="../stdlib/collections.html#Base.map"><code>map()</code></a>. Similarmente, <code>do a,b</code> crearía una función anónima de dos argumentos, y un <code>do</code> solo sería una función anónima de la forma <code>() -&gt; ...</code>.</p><p>Cómo se inicializan estos argumentos depende de la función más externa; aquí <code>map()</code> fijará secuencialmente <code>x</code> a <code>A,B,C</code> llamando a la función anónima sobre cada uno de ellos, tal y como pasa en la sintaxis <code>map(func, [A,B,C])</code>.</p><p>Esta sintaxis hace más fácil usar funciones para extender el lenguaje de forma efectiva, ya que las llamadas tiene el aspecto de códigos de bloque normales. Hay muchos usos posibles diferentes al de <a href="../stdlib/collections.html#Base.map"><code>map()</code></a>, tal como la gestión del estado del sistema. Por ejemplo, hay una versión de  <a href="../stdlib/io-network.html#Base.open"><code>open()</code></a> que ejecuta código asegurando que el fichero abierto es cerrado eventualmente:</p><pre><code class="language-julia">open(&quot;outfile&quot;, &quot;w&quot;) do io
    write(io, data)
end</code></pre><p>Esto se consigue mediante la siguiente definición:</p><pre><code class="language-julia">function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end</code></pre><p>Aquí, <a href="../stdlib/io-network.html#Base.open"><code>open()</code></a> primero abre el fichero para escritura y luego pasa el flujo de salida resultante a la función anónima que se define en el bloque <code>do...end</code>.  Después de que la función exista, <a href="../stdlib/io-network.html#Base.open"><code>open()</code></a> asegurará que el flujo ha sido cerrado apropiadamente, sin preocuparse de si la función salió normalmente o lanzó una excepción (la construcción  <code>try/finally</code> será descrita en <a href="control-flow.html#control-flow-1">Control de Flujo</a>.)</p><p>Con la sintaxis de bloque <code>do</code> se ayuda a chequear la documentación o implementaciones para saber cómo se inicializan los argumentos de la función de usuario.</p><h2><a class="nav-anchor" id="man-vectorized-1" href="#man-vectorized-1">Sintaxis Punto para funciones Vectorizadas</a></h2><p>En los lenguajes de computación técnicos es común tener versiones &quot;vectorizadas&quot; de funciones, las cuales aplican una función dada <code>f(x)</code> a cada elemento de un array <code>A</code> para producir un nuevo array vía <code>f(A)</code>. Esta clase de sintaxis es conveniente para procesamiento de datos, pero en otros lenguajes la vectorización es también requerida en aras de mejorar el rendimiento:  si los bucles son lentos, la versión &quot;vectorizada&quot; de una función podría llamar al código de librería rápido en un lenguaje de bajo nivel. En Julia, las funciones actualizadas <em>no son requeridas por motivos de vencimiento</em>; de hecho, suele ser beneficioso que el usuario escriba sus propios bucles (ver <a href="performance-tips.html#man-performance-tips-1">Consejos de rendimiento</a>), a veces incluso conveniente. Por tanto <em>cualquier</em> función Julia <code>f</code> puede ser aplicada elemento a elemento a cualquier array (u otra colección) con la sintaxis <code>f.(A)</code>. Por ejemplo <code>sin</code> puede ser aplicado a todos los elementos del vector <code>A</code> de esta forma:</p><pre><code class="language-julia-repl">julia&gt; A = [1.0, 2.0, 3.0]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0

julia&gt; sin.(A)
3-element Array{Float64,1}:
 0.841471
 0.909297
 0.14112</code></pre><p>Por supuesto, uno puede omitir el punto si escribe un método especial para vectores de <code>f</code> por ejemplo, vía <code>f(A::AbstractArray) = map(f, A)</code> y esto es tan eficiente como <code>f.(A)</code>. Pero este enfoque necesitaría que decidas a priori qué funciones quieres vectorizar.</p><p>Más generalmente, <code>f.(args...)</code> es de hecho equivalente a <code>broadcast(f, args...)</code>, que te permite operar sobre múltiples arrays (incluso de formas distintas) o una mezcla de arrays y escalares (ver <a href="arrays.html#broadcasting-1">Broadcasting</a>). Por ejemplo, si tenemos <code>f(x,y) = 3x + 4y</code>, entonces <code>f.(pi,A)</code> devolverá un nuevo array consistente en <code>f(pi,a)</code>para cada <code>a</code> en <code>A</code>, y <code>f.(vector1,vector2)</code> devolverá un nuevo vector que consiste en <code>f(vector1[i],vector2[i])</code> para cada índice <code>i</code> (lanzando una excepción si los vectores tienen diferente longitud).</p><pre><code class="language-julia-repl">julia&gt; f(x,y) = 3x + 4y;

julia&gt; A = [1.0, 2.0, 3.0];

julia&gt; B = [4.0, 5.0, 6.0];

julia&gt; f.(pi, A)
3-element Array{Float64,1}:
 13.4248
 17.4248
 21.4248

julia&gt; f.(A, B)
3-element Array{Float64,1}:
 19.0
 26.0
 33.0</code></pre><p>Además, las llamadas anidadas <code>f.(args...)</code>se funden en un solo <code>broadcast</code>. Por ejemplo <code>sin.(cos.(X))</code> es equivalent a <code>broadcast(x-&gt;sin(cos(x)), X)</code>, lo cuál es similar a <code>[sin(cos(x)) for x in X]</code>. Hay un solo bucle sobre <code>X</code>, y se asigna un solo array para el resultado. En contraste, <code>sin(cos(X))</code> en un lenguaje vectorizado típio asignaría primero un array temporal <code>tmp = cos(X)</code> y luego calcularía <code>sin(tmp)</code> en un bucle separado, asignando un segundo array. Esta fusión de bucles no es una optimización del compilador que puede ocurrir o no, sino que es una <em>garantía sintáctica</em>  cuando se encuentran llamadas <code>f.(array...)</code> anidadas. Técnicamente, la fusión se para en cuanto se encuentr una función sin punto, por ejemplo, en <code>sin.(srt(cos.(X)))</code> los bucles de <code>sin</code> y <code>cos</code> no pueden mezclarse debido a la intervención de la función <code>sort</code>.</p><p>Finalmente, la eficiencia máxima suele conseguirse cuando el array de salida de una operación vectorizada es <em>pre-asignado</em>, por lo que las llamadas repetidas no asignarán nuevos arrays una y otra vez para los resultados (ver <a href="performance-tips.html#pre-allocating-outputs-1">Preasignando salidas</a>). Una sintaxis conveniente para esto es <code>X .= ...</code> que es equivalente a <code>broadcast!(identity, X, ...)</code> excepto que, como antes, el bucle <code>broadcast!</code> es fusionado con cualquier llamada con punto anidada. Por ejemplo, <code>X .= sin.(Y)</code> es equivalente a <code>broadcast!(sin, X, Y)</code>, sobreescribiendo <code>X</code> con <code>sin.(Y)</code> en su lugar. Si el miembro izquierdo de la expresión es una expresión de indexación de un array, como <code>X[2:end] .= sin.(Y)</code> entonces ella se traduce a <code>broadcast!</code> sobre una vista, por ejemplo <code>broadcast!(sin, view(X, 2:endof(X)), Y)</code>.</p><p>Como añadir puntos a muchas operaciones y llamadas a función puede resultar tedioso y conducir a código difícil de leer, se proporciona la macro <code>@.</code> para convertir cada llamada a función, operación y asignación en una expresion en su versión &quot;con puntos&quot;.</p><pre><code class="language-julia-repl">julia&gt; Y = [1.0, 2.0, 3.0, 4.0];

julia&gt; X = similar(Y); # pre-allocate output array

julia&gt; @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))
4-element Array{Float64,1}:
  0.514395
 -0.404239
 -0.836022
 -0.608083</code></pre><p>Los operadores binarios (o unarios) como <code>.+</code> se manejan con el mismo mecanismo: son equivalentes a llamadas retransmitidas (broadcast) y son fundidas con otras llamadas que tiene puntos. <code>X .+= Y etcetera</code> es equivalente a <code>X .= X .+ Y</code> y dan como resultado una asignación fusionada. Ver también <a href="mathematical-operations.html#man-dot-operators-1">dot operators</a>.</p><h2><a class="nav-anchor" id="Otras-Lecturas-1" href="#Otras-Lecturas-1">Otras Lecturas</a></h2><p>Deberíamos mencionar que esto está lejos de ser una visión completa de las definiciones de función. Julia tiene un sistema de tipos sofisticado y permite despacho múltiple sobre los tipos de argumento. Ninguno de los ejemplos dados aquí proporciona anotaciones de tipo sobre sus argmentos, lo que significa que son aplicables a cualquier tipo de argumento. El sistema de tipos es descrito en <a href="types.html#man-types-1">Tipos</a> definir una función en términos de métodos elegidos mediante despacho múltiple sobre los tpos de argumento en tiempo de ejecucoión se describe en el capítulo <a href="methods.html#methods-1">Methods</a>.</p><footer><hr/><a class="previous" href="strings.html"><span class="direction">Previous</span><span class="title">Strings</span></a><a class="next" href="control-flow.html"><span class="direction">Next</span><span class="title">Control Flow</span></a></footer></article></body></html>
