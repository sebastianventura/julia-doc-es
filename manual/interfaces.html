<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfaces · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Funciones</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="types.html">Tipos</a></li><li><a class="toctext" href="methods.html">Métodos</a></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión y Promoción</a></li><li class="current"><a class="toctext" href="interfaces.html">Interfaces</a><ul class="internal"><li><a class="toctext" href="#man-interface-iteration-1">Iteración</a></li><li><a class="toctext" href="#Indexación-1">Indexación</a></li><li><a class="toctext" href="#man-interface-array-1">Abstract Arrays</a></li></ul></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Comprobación de Límites</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="interfaces.html">Interfaces</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Interfaces</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="interfaces-1" href="#interfaces-1">Interfaces</a></h1><p>Un montón de la potencia y extensibilidad de Julia viene de una colección de interfaces informales. Extendiendo unos pocos métodos específicos para que trabajen para un tipo personalizado, los objetos de este tipo no sólo reciben estas funcionalidades, sino que son también capaces de ser usados en otros métodos que han sido escritos para ser construidos genéricamente sobre esos comportamientos.</p><h2><a class="nav-anchor" id="man-interface-iteration-1" href="#man-interface-iteration-1">Iteración</a></h2><table><tr><th>Métodos requeridos              </th><th>                     </th><th>Breve descripción                                                                    </th></tr><tr><td><code>start(iter)</code></td><td> </td><td>Devuelve el estado inicial de iteración</td></tr><tr><td><code>next(iter, state)</code></td><td> </td><td>Devuelve el ítem actual y pone <code>state</code> en el siguiente</td></tr><tr><td><code>done(iter, state)</code></td><td> </td><td>Comprueba si quedan más ítems</td></tr><tr><td><strong>Métodos opcionales importantes</strong></td><td><strong>Definiciones por defecto</strong></td><td><strong>Breve descripción</strong>                                                                </td></tr><tr><td><code>iteratorsize(IterType)</code></td><td><code>HasLength()</code></td><td>Uno de <code>HasLength()</code>,<code>HasShape()</code>,<code>IsInfinite()</code>, o <code>sizeUnknown()</code>, según convenga</td></tr><tr><td><code>iteratoreltype(IterType)</code></td><td><code>HasEltype()</code></td><td>Uno de <code>EltypeUnknown()</code> o <code>HasEltype()</code>, según convenga</td></tr><tr><td><code>eltype(IterType)</code></td><td><code>Any</code></td><td>El tipo de los ítems devueltos por <code>next()</code></td></tr><tr><td><code>length(iter)</code></td><td>(<em>indefinido</em>)</td><td>El número de ítems, si es conocido</td></tr><tr><td><code>size(iter, [dim...])</code></td><td>(<em>indefinido</em>)</td><td>El número de ítems en cada dimensión, si es conocido</td></tr></table><table><tr><th>Valor devuelto por <code>iteratorsize(IterType)</code></th><th>Métodos requeridos</th></tr><tr><td><code>HasLength()</code></td><td><code>length(iter)</code></td></tr><tr><td><code>HasShape()</code></td><td><code>length(iter)</code>  and <code>size(iter, [dim...])</code></td></tr><tr><td><code>IsInfinite()</code></td><td>(<em>ninguno</em>)</td></tr><tr><td><code>SizeUnknown()</code></td><td>(<em>ninguno</em>)</td></tr></table><table><tr><th>Valro devuelto por <code>iteratoreltype(IterType)</code></th><th>Métodos requeridos</th></tr><tr><td><code>HasEltype()</code></td><td><code>eltype(IterType)</code></td></tr><tr><td><code>EltypeUnknown()</code></td><td>(<em>ninguno</em>)</td></tr></table><p>La iteración secuencial es implementada mediante los métodos <a href="../stdlib/collections.html#Base.start"><code>start()</code></a>, <a href="../stdlib/collections.html#Base.done"><code>done()</code></a>, y <a href="../stdlib/collections.html#Base.next"><code>next()</code></a>. En lugar de mutar objetos cuando se itera sobre ellos, Julia proporciona estos tres métodos que llevaqn la traza del estado de la iteración externamente al objeto. El método <code>start(iter)</code> devuvelve el estado inicial para un objeto iterable <code>iterd</code>. Este estado se pasa a lo largo de <code>done(iter, state)</code> que chequea si quedan más elementos, y <code>next(iter, state)</code> que devuelve una tupla que contiene el elemento y el estado actuales. El objeto <code>state</code>puede ser cualquier cosa, y suele ser considerado un detalle de implementación privado al objeto iterable.</p><p>Cualquier objeto que defina estos tres métodos es iterable y puede ser usado en las <a href="../stdlib/collections.html#lib-collections-iteration-1">muchas funciones que se basan en la iteración</a>. También puede ser usado directamente en un bucle for ya que la sintaxis:</p><pre><code class="language-julia">for i in iter   # or  &quot;for i = iter&quot;
    # body
end</code></pre><p>es traducida por:</p><pre><code class="language-julia">state = start(iter)
while !done(iter, state)
    (i, state) = next(iter, state)
    # body
end</code></pre><p>Un ejemplo sencillo es una secuencia iterable de cuadrados de número con una longitud definida:</p><pre><code class="language-jldoctest">julia&gt; struct Squares
           count::Int
       end

julia&gt; Base.start(::Squares) = 1

julia&gt; Base.next(S::Squares, state) = (state*state, state+1)

julia&gt; Base.done(S::Squares, state) = state &gt; S.count

julia&gt; Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type

julia&gt; Base.length(S::Squares) = S.count</code></pre><p>Con sólo las definiciones de <a href="../stdlib/collections.html#Base.start"><code>start</code></a>, <a href="../stdlib/collections.html#Base.next"><code>next</code></a>, y <a href="../stdlib/collections.html#Base.done"><code>done</code></a>, el tipo <code>Squares</code> es ya muy poderoso. Podemos iterar sobre todos los elementos:</p><pre><code class="language-jldoctest">julia&gt; for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49</code></pre><p>Podemos usar muchos de los métodos predefinidos que trabajan con iterables, como <a href="../stdlib/collections.html#Base.in"><code>in()</code></a>, <a href="../stdlib/math.html#Base.mean"><code>mean()</code></a> y <a href="../stdlib/math.html#Base.std"><code>std()</code></a>:</p><pre><code class="language-jldoctest">julia&gt; 25 in Squares(10)
true

julia&gt; mean(Squares(100))
3383.5

julia&gt; std(Squares(100))
3024.355854282583</code></pre><p>Hay unos pocos más métodos que se pueden extender para dar a Julia más información sobre esta colección iterable. Se sabe que todos los elementos en una secuencia <code>Squares</code> serán <code>Int</code>. Extendiendo el método  <a href="../stdlib/collections.html#Base.eltype"><code>eltype()</code></a>, se puede proporcionar esta información a Julia y ayudarlo a hacer código más especializado en métodos más complicados. También se sabe el número de elementos de esa secuencia, por lo que también se pude extender <a href="../stdlib/arrays.html#Base.length-Tuple{AbstractArray}"><code>length()</code></a>.</p><p>Ahora, cuando pedimos a Julia que <a href="../stdlib/collections.html#Base.collect-Tuple{Any}"><code>collect()</code></a> todos los elementos en un array ella puede preasignar un <code>Vector{Int}</code> en la parte derecha de la expresión, en lugar de ir poniendo a ciegas mediante <a href="../stdlib/collections.html#Base.push!"><code>push!</code></a>ing cada elemento en un <code>Vector{Any}</code>.</p><pre><code class="language-jldoctest">julia&gt; collect(Squares(10))&#39; # transposed to save space
1×10 RowVector{Int64,Array{Int64,1}}:
 1  4  9  16  25  36  49  64  81  100</code></pre><p>Aunque podemos confiar en las implementaciones genéricas, podemos también extender métodos específicos donde sepamos que hay un algoritmo más simple. Por ejemplo, he aquí una fórmula para sobreescribir la versión iterativa para una solución más eficiente:</p><pre><code class="language-jldoctest">julia&gt; Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia&gt; sum(Squares(1803))
1955361914</code></pre><p>Este es un patrón muy común a través de la librería estándar de Julia: un pequeño conjunto de métodos requeridos definen una interfaz informal que permite muchos comportamientos muy atractivos. En algunos casos, los tipos que quieran especializar esos comportamientos extra cuando saben que existe un algoritmo más eficiente que podrán usar en su caso específico.</p><h2><a class="nav-anchor" id="Indexación-1" href="#Indexación-1">Indexación</a></h2><table><tr><th>Métodos a implementar</th><th>Breve descripción</th></tr><tr><td><code>getindex(X, i)</code></td><td><code>X[i]</code>, acceso indexado a elemento</td></tr><tr><td><code>setindex!(X, v, i)</code></td><td><code>X[i] = v</code>, asignación indexada</td></tr><tr><td><code>endof(X)</code></td><td>El último índice, usado en <code>X[end]</code></td></tr></table><p>Para el iterable <code>Squares</code> anterior, podemos calcular fácilmente el i-ésimo elemento de la secuencia elevándolo al cuadrado. Pordemos exponer esto como una expresión de indexación <code>S[i]</code>. Para optar a ese comportamiento, <code>Squares</code> sólo tieen que definir <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex()</code></a>:</p><pre><code class="language-jldoctest">julia&gt; function Base.getindex(S::Squares, i::Int)
           1 &lt;= i &lt;= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia&gt; Squares(100)[23]
529</code></pre><p>Adicionalmente, para soportar la sintaxis <code>S[end]</code>, debemos definir <a href="../stdlib/collections.html#Base.endof"><code>endof()</code></a> para especificar el último índice válido:</p><pre><code class="language-jldoctest">julia&gt; Base.endof(S::Squares) = length(S)

julia&gt; Squares(23)[end]
529</code></pre><p>Tenga en cuenta, sin embargo, que lo anterior <em>sólo</em> define <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex()</code></a> con un índice entero. Indexar con cualquier cosa que no sea un <code>Int</code> lanzará un  <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a> diciendo que no había ningún método coincidente. Para soportar la indexación con intervalos o vectores de <code>Int</code>s, se deben escribir métodos separados:</p><pre><code class="language-jldoctest">julia&gt; Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia&gt; Base.getindex(S::Squares, I) = [S[i] for i in I]

julia&gt; Squares(10)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25</code></pre><p>Aunque que esto está comenzando a soportar más de las <a href="arrays.html#man-array-indexing-1">operaciones de indexación soportadas por algunos de los tipos incorporados</a>, todavía hay un buen número de comportamientos ausentes. Esta secuencia <code>Squares</code> está empezando a parecer más y más como un vector, ya que hemos añadido comportamientos a la misma. En lugar de definir todos estos comportamientos nosotros mismos, podemos definirlos oficialmente como un subtipo de un <a href="../stdlib/arrays.html#Core.AbstractArray"><code>AbstractArray</code></a>.</p><h2><a class="nav-anchor" id="man-interface-array-1" href="#man-interface-array-1">Abstract Arrays</a></h2><table><tr><th>Metodos a implementar                          </th><th>                                       </th><th>Breve descripción                                                                 </th></tr><tr><td><code>size(A)</code></td><td> </td><td>Devuelve una tupla que contiene las dimensiones de <code>A</code></td></tr><tr><td><code>getindex(A, i::Int)</code></td><td> </td><td>(if <code>IndexLinear</code>) Linear scalar indexing</td></tr><tr><td><code>getindex(A, I::Vararg{Int, N})</code></td><td> </td><td>(if <code>IndexCartesian</code>, where <code>N = ndims(A)</code>) N-dimensional scalar indexing</td></tr><tr><td><code>setindex!(A, v, i::Int)</code></td><td> </td><td>(if <code>IndexLinear</code>) Scalar indexed assignment</td></tr><tr><td><code>setindex!(A, v, I::Vararg{Int, N})</code></td><td> </td><td>(if <code>IndexCartesian</code>, where <code>N = ndims(A)</code>) N-dimensional scalar indexed assignment</td></tr><tr><td><strong>Optional methods</strong></td><td><strong>Default definition</strong></td><td><strong>Brief description</strong></td></tr><tr><td><code>IndexStyle(::Type)</code></td><td><code>IndexCartesian()</code></td><td>Returns either <code>IndexLinear()</code> or <code>IndexCartesian()</code>. See the description below.</td></tr><tr><td><code>getindex(A, I...)</code></td><td>defined in terms of scalar <code>getindex()</code></td><td><a href="arrays.html#man-array-indexing-1">Multidimensional and nonscalar indexing</a></td></tr><tr><td><code>setindex!(A, I...)</code></td><td>defined in terms of scalar <code>setindex!()</code></td><td><a href="arrays.html#man-array-indexing-1">Multidimensional and nonscalar indexed assignment</a></td></tr><tr><td><code>start()</code>/<code>next()</code>/<code>done()</code></td><td>defined in terms of scalar <code>getindex()</code></td><td>Iteration</td></tr><tr><td><code>length(A)</code></td><td><code>prod(size(A))</code></td><td>Number of elements</td></tr><tr><td><code>similar(A)</code></td><td><code>similar(A, eltype(A), size(A))</code></td><td>Return a mutable array with the same shape and element type</td></tr><tr><td><code>similar(A, ::Type{S})</code></td><td><code>similar(A, S, size(A))</code></td><td>Return a mutable array with the same shape and the specified element type</td></tr><tr><td><code>similar(A, dims::NTuple{Int})</code></td><td><code>similar(A, eltype(A), dims)</code></td><td>Return a mutable array with the same element type and size <em>dims</em></td></tr><tr><td><code>similar(A, ::Type{S}, dims::NTuple{Int})</code></td><td><code>Array{S}(dims)</code></td><td>Return a mutable array with the specified element type and size</td></tr><tr><td><strong>Non-traditional indices</strong></td><td><strong>Default definition</strong></td><td><strong>Brief description</strong></td></tr><tr><td><code>indices(A)</code></td><td><code>map(OneTo, size(A))</code></td><td>Return the <code>AbstractUnitRange</code> of valid indices</td></tr><tr><td><code>Base.similar(A, ::Type{S}, inds::NTuple{Ind})</code></td><td><code>similar(A, S, Base.to_shape(inds))</code></td><td>Return a mutable array with the specified indices <code>inds</code> (see below)</td></tr><tr><td><code>Base.similar(T::Union{Type,Function}, inds)</code></td><td><code>T(Base.to_shape(inds))</code></td><td>Return an array similar to <code>T</code> with the specified indices <code>inds</code> (see below)</td></tr></table><p>Si un tipo se define como subtipo de <code>AbstractArray</code>, hereda un conjunto muy grande de comportamientos ricos, incluyendo la iteración y la indexación multidimensional construida sobre el acceso de un solo elemento. Consulte la <a href="arrays.html#man-multi-dim-arrays-1">página de manual sobre arrays</a> y la <a href="../stdlib/arrays.html#lib-arrays-1">sección de la biblioteca estándar</a> para más métodos soportados.</p><p>Una parte clave en la definición de un subtipo de <code>AbstractArray</code> es <a href="../stdlib/arrays.html#Base.IndexStyle"><code>IndexStyle</code></a>.Dado que la indexación es una parte tan importante de una matriz y que a menudo se produce en los bucles en caliente, es importante que tanto la indexación y la asignación indexada sean lo más eficientes posible. Las estructuras de datos array se suelen definir de dos maneras: o bien accede de forma más eficaz a sus elementos utilizando sólo un índice (indexación lineal) o  accede intrínsecamente a los elementos con índices especificados para cada dimensión. Estas dos modalidades son identificadas por Julia como <code>IndexLinear()</code> e <code>IndexCartesian()</code>. La conversión de un índice lineal en subíndices de indexación múltiples suele ser muy costosa, por lo que esto proporciona un mecanismo basado en tratos para permitir un código genérico eficiente para todos los tipos de matriz.</p><p>Esta distinción determina qué métodos de indexación escalar debe definir cada tipo. Los arrays <code>IndexLinear()</code> son sencillos: sólo definen <code>getindex(A::ArrayType, i::Int)</code>. Cuando el array se indexa posteriormmente con un conjunto multidimensional de índices, el método de respaldo <code>getindex(A::AbstractArray, I...)()</code> convierte eficientemente los indices en un indice lineal y luego llama al metodo anterior. Los arrays <code>IndexCartesian()</code>, por otra parte,  requieren que se definan métodos para cada dimensionalidad soportada con <code>ndims(A)</code> índices Int. Por ejemplo, el tipo <a href="../stdlib/arrays.html#Base.SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> incorporado sólo admite dos dimensiones, por lo que sólo define <code>getindex(A::SparseMatrixCSC, i::Int, j::Int)</code>. Lo mismo sucede para <code>setindex!()</code>.</p><p>Volviendo a la secuencia de cuadrados de arriba, podríamos definirla como un subtipo de un <code>AbstractArray{Int, 1}</code>:</p><pre><code class="language-jldoctest">julia&gt; struct SquaresVector &lt;: AbstractArray{Int, 1}
           count::Int
       end

julia&gt; Base.size(S::SquaresVector) = (S.count,)

julia&gt; Base.IndexStyle(::Type{&lt;:SquaresVector}) = IndexLinear()

julia&gt; Base.getindex(S::SquaresVector, i::Int) = i*i</code></pre><p>Note que es muy importante especificar los dos parámetros del <code>AbstractArray</code>; la primera define el tipo de elemento  <a href="../stdlib/collections.html#Base.eltype"><code>eltype()</code></a>, y la segunda el número de dimensiones <a href="../stdlib/arrays.html#Base.ndims"><code>ndims()</code></a>. Este supertipo y sus tres métodos son todo lo que hace falta para que <code>SquaresVector</code> sea un array iterable, indexable y completamente funcional:</p><pre><code class="language-jldoctest">julia&gt; s = SquaresVector(7)
7-element SquaresVector:
  1
  4
  9
 16
 25
 36
 49

julia&gt; s[s .&gt; 20]
3-element Array{Int64,1}:
 25
 36
 49

julia&gt; s \ [1 2; 3 4; 5 6; 7 8; 9 10; 11 12; 13 14]
1×2 Array{Float64,2}:
 0.305389  0.335329

julia&gt; s ⋅ s # dot(s, s)
4676</code></pre><p>Un ejemplo un poco más complicado, definamos nuestro propio tipo array <em>sparse</em> N-dimensional &quot;de juguete&quot;, construído encima de <a href="../stdlib/collections.html#Base.Dict"><code>Dict</code></a>:</p><pre><code class="language-jldoctest">julia&gt; struct SparseArray{T,N} &lt;: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia&gt; SparseArray{T}(::Type{T}, dims::Int...) = SparseArray(T, dims);

julia&gt; SparseArray{T,N}(::Type{T}, dims::NTuple{N,Int}) = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia&gt; Base.size(A::SparseArray) = A.dims

julia&gt; Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia&gt; Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia&gt; Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)</code></pre><p>Observe que se trata de un array  <code>IndexCartesian</code> array, por lo que debemos definir manualmente <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex()</code></a> y <a href="../stdlib/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}"><code>setindex!()</code></a> en la dimensionalidad de la matriz. En este caso, a diferencia de en <code>SquaresVector</code>, somos capaces de definir  <a href="../stdlib/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}"><code>setindex!()</code></a> y, en consecuencia, podemos mutar el array:</p><pre><code class="language-jldoctest">julia&gt; A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2)
3×3 SparseArray{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; A[:] = 1:length(A); A
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p>El resultado de la indexación de un <code>AbstractArray</code> puede ser en sí mismo un array (por ejemplo, al indexar por un rango). Los métodos de respaldo de <code>AbstractArray</code> utilizan <a href="../stdlib/arrays.html#Base.similar-Tuple{AbstractArray}"><code>similar()</code></a> para asignar un <code>Array</code> del tamaño y tipo de elemento apropiados, que se rellena usando el método de indexación básico descrito anteriormente. Sin embargo, al implementar un <em>wrapper</em> de array, a menudo deseamos que el resultado sea también un <em>wrapper</em>:</p><pre><code class="language-jldoctest">julia&gt; A[1:2,:]
2×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0</code></pre><p>En este ejemplo esto se logra mediante la definición de <code>Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)</code> para crear la matriz wrapped apropiada. (Tenga en cuenta que aunque <code>similar</code> soporta formas de 1 y 2 argumentos, en la mayoría de los casos sólo necesita especializar el formulario de 3 argumentos). Para que esto funcione es importante que <code>SparseArray</code> sea mutable (soporte <code>setindex!</code>). Definir <code>similar()</code>, <code>getindex()</code> y <code>setindex!()</code> para <code>SparseArray</code> también hace posible copiar el array mediante <a href="../stdlib/base.html#Base.copy"><code>copy()</code></a>:</p><pre><code class="language-jldoctest">julia&gt; copy(A)
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p>Además de todos los métodos iterables e indexables de arriba, estos tipos también pueden interactuar entre sí y utilizar todos los métodos definidos en la biblioteca estándar para <code>AbstractArrays</code>:</p><pre><code class="language-jldoctest">julia&gt; A[SquaresVector(3)]
3-element SparseArray{Float64,1}:
 1.0
 4.0
 9.0

julia&gt; dot(A[:,1],A[:,2])
32.0</code></pre><p>Si está definiendo un tipo de array que permite la indexación no tradicional (índices que comienzan en algo distinto de 1), debe especializar <code>indices</code>. También debe especializarse <a href="../stdlib/arrays.html#Base.similar-Tuple{AbstractArray}"><code>similar</code></a> para que el argumento <code>dims</code> (normalmente una tupla de tamaños <code>Dims</code>) pueda aceptar objetos <code>AbstractUnitRange</code>, tal vez rango-tipos <code>Ind</code> de su propio diseño. Para obtener más información, vea <a href="../devdocs/offset-arrays.html#offset-arrays-1">Arrays con índices personalizados</a>.</p><footer><hr/><a class="previous" href="conversion-and-promotion.html"><span class="direction">Previous</span><span class="title">Conversión y Promoción</span></a><a class="next" href="modules.html"><span class="direction">Next</span><span class="title">Módulos</span></a></footer></article></body></html>
