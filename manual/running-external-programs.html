<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ejecutando programas externos · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Funciones</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="types.html">Tipos</a></li><li><a class="toctext" href="methods.html">Métodos</a></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión and Promoción</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li class="current"><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a><ul class="internal"><li><a class="toctext" href="#command-interpolation-1">Interpolación</a></li><li><a class="toctext" href="#Entrecomillado-1">Entrecomillado</a></li><li><a class="toctext" href="#Tuberías-1">Tuberías</a></li></ul></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="running-external-programs.html">Ejecutando programas externos</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/running-external-programs.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Ejecutando programas externos</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="running-external-programs-1" href="#running-external-programs-1">Ejecutando programas externos</a></h1><p>Julia toma prestada la notación de tilde inversa para ejecutar mandatos de la shell y programas en Perl y en Ruby.  Sin embargo, en Julia, escribir</p><pre><code class="language-julia-repl">julia&gt; `echo hello`
`echo hello`</code></pre><p>difiere en algunos aspectos del comportamiento en varios shells, Perl y Ruby:</p><ul><li><p>En lugar de ejecutar el mandato inmediatamente, las tildes invertidas crean un objeto <code>Cmd</code> para representar el  mandato. Uno puede usar este objeto para conectar los mandatos a otros vía tuberías (<em>pipes</em>), ejecutarlo y leer  o escribir en él.</p></li><li><p>Cuando el mandato se está ejecutando, Julia no captura su salida a menos que uno lo organice específicamente. En  lugar de ello, la salida del mandato va por defecto a <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a> como si se estuviera realizando una llamada  al sistema con la <code>libc</code>.</p></li><li><p>El mandato nunca es ejecutado con un shell. En su lugar, Julia analiza directamente la sintaxis del mandato,  interpola variables adecuadametne y dividiendo en palabras como el shell lo haría, respetando su sintaxis.  El mandato se ejecuta como un proceso hijo inmediato de Julia, usando las llamadas <code>fork</code> y <code>exec</code>.</p></li></ul><p>He aquí un ejemplo sencillo de ejecución de un programa externo:</p><pre><code class="language-julia-repl">julia&gt; mycommand = `echo hello`
`echo hello`

julia&gt; typeof(mycommand)
Cmd

julia&gt; run(mycommand)
hello</code></pre><p>El mensaje <code>hello</code> es la salida de este mandato <code>echo</code>, enviado a <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a>. El mensaje <code>hello</code> es la salida de este mandato <code>echo</code>, enviado a <code>STDOUT</code>. El método ejecutado devuelve en si mismo <code>nothing</code>, y lanza una <a href="../stdlib/base.html#Core.ErrorException"><code>ErrorException</code></a> si el mandato externo falla en ejecutarse con éxito.</p><p>Si se desea leer la salida de un mandato externo puede usarse <code>readstring()</code>:  </p><pre><code class="language-julia-repl">julia&gt; a = readstring(`echo hello`)
&quot;hello\n&quot;

julia&gt; chomp(a) == &quot;hello&quot;
true</code></pre><p>Más generalmente, puedes usar <a href="../stdlib/io-network.html#Base.open"><code>open()</code></a> para leer desde o escribir hacia un mandato externo.</p><pre><code class="language-julia-repl">julia&gt; open(`less`, &quot;w&quot;, STDOUT) do io
           for i = 1:3
               println(io, i)
           end
       end
1
2
3</code></pre><h2><a class="nav-anchor" id="command-interpolation-1" href="#command-interpolation-1">Interpolación</a></h2><p>Supongamos que uno quiere algo un poco más complicado y usa el nombre de un fichero en la variable <code>file</code> como argumento a un mandato. Se puede usar <code>$</code> para interpolar tal como lo haríamos con un literal cadena (ver la sección <a href="../devdocs/ast.html#Strings-1">Strings</a>):</p><pre><code class="language-julia-repl">julia&gt; file = &quot;/etc/passwd&quot;
&quot;/etc/passwd&quot;

julia&gt; `sort $file`
`sort /etc/passwd`</code></pre><p>Un error común es que cuando se ejecutan programas externos a través de un shell es que si el nombre del fichero contiene caracteres que son especiales para el shell, ellos pueden causar un comportamiento indeseaddo. Por ejemplo, en lugar de <code>/etc/passwd</code> se desea ordenar los contenidos del fichero <code>/volumes/External HD/data.csv</code>. Intentémoslo:</p><pre><code class="language-julia-repl">julia&gt; file = &quot;/Volumes/External HD/data.csv&quot;
&quot;/Volumes/External HD/data.csv&quot;

julia&gt; `sort $file`
`sort &#39;/Volumes/External HD/data.csv&#39;`</code></pre><p>¿Cómo se entrecomilla el nombre de fichero? Julia sabe que <code>file</code> va a ser interpolado por un solo argumento, por lo que él entrecomilla la cadena. De hecho, esto no es bastante exacto: el valor de <code>file</code> no va a ser interpretado por el shell nunca, por lo que no hay necesidad de entrecomillar. Las comillas se insertan sólo para presentar al usuario. Eso funcionará incluso si uno interpola un valor como parte de una palabra del shell:</p><pre><code class="language-julia-repl">julia&gt; path = &quot;/Volumes/External HD&quot;
&quot;/Volumes/External HD&quot;

julia&gt; name = &quot;data&quot;
&quot;data&quot;

julia&gt; ext = &quot;csv&quot;
&quot;csv&quot;

julia&gt; `sort $path/$name.$ext`
`sort &#39;/Volumes/External HD/data.csv&#39;`</code></pre><p>Como puedes ver, el espacio en la variable <code>path</code> es apropiadamente &quot;escapado&quot;. Pero, ¿qué pasa si lo que uno desea es interpolar múltiples palabras? En este caso, se utilizará un array (u otro contenedor iterable):</p><pre><code class="language-julia-repl">julia&gt; files = [&quot;/etc/passwd&quot;,&quot;/Volumes/External HD/data.csv&quot;]
2-element Array{String,1}:
 &quot;/etc/passwd&quot;
 &quot;/Volumes/External HD/data.csv&quot;

julia&gt; `grep foo $files`
`grep foo /etc/passwd &#39;/Volumes/External HD/data.csv&#39;`</code></pre><p>Si interpolas un array como parte de una palabra de la shell, Julia emula la generación de argumentos de la shell <code>{a, b, c}</code>:</p><pre><code class="language-julia-repl">julia&gt; names = [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
3-element Array{String,1}:
 &quot;foo&quot;
 &quot;bar&quot;
 &quot;baz&quot;

julia&gt; `grep xylophone $names.txt`
`grep xylophone foo.txt bar.txt baz.txt`</code></pre><p>Además, si interpolas múltiples arrays en la misma palabra, se emula el comportamiento de generación del shell haciendo el producto cartesiano: </p><pre><code class="language-julia-repl">julia&gt; names = [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
3-element Array{String,1}:
 &quot;foo&quot;
 &quot;bar&quot;
 &quot;baz&quot;

julia&gt; exts = [&quot;aux&quot;,&quot;log&quot;]
2-element Array{String,1}:
 &quot;aux&quot;
 &quot;log&quot;

julia&gt; `rm -f $names.$exts`
`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`</code></pre><p>Como pudes interpolar arrays de literales, puedes usar esta funcionalidad generativa sin necesidad de crer objetos array temporales primero: </p><pre><code class="language-julia-repl">julia&gt; `rm -rf $[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;,&quot;qux&quot;].$[&quot;aux&quot;,&quot;log&quot;,&quot;pdf&quot;]`
`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`</code></pre><h2><a class="nav-anchor" id="Entrecomillado-1" href="#Entrecomillado-1">Entrecomillado</a></h2><p>Inevitablemente, uno quiere escribir mandatos que no sean tan simples, y se vueve necesario usar comillas. He aquí un ejemplo simple de un script Perl de una línea en el prompt del shell:</p><pre><code class="language-none">sh$ perl -le &#39;$|=1; for (0..3) { print }&#39;
0
1
2
3</code></pre><p>La expresión Perl necesita estar entre comillas sencillas por dos razones: para que los espacios no rompan la expresión en múltiples palabras en el shell, y para que el uso de variables de Perl, como <code>$|</code> no cause interpolación. En otras instancias, puedes querer usar dobles comillas para que la interpolación SI tenga lugar:</p><pre><code class="language-none">sh$ first=&quot;A&quot;
sh$ second=&quot;B&quot;
sh$ perl -le &#39;$|=1; print for @ARGV&#39; &quot;1: $first&quot; &quot;2: $second&quot;
1: A
2: B</code></pre><p>En general, la sintaxis de comillas invertidas de Julia está diseñada cuidadosamente para que puedas cortar y pegar comendos del shell, los pongas entre comillas y funcionen: los comportamientos del escape, las comillas y las interpolaciones son los mismos que los del shell. La única diferencia es que la interpolación está integrada y consciente de la noción de Julia de que es un valor de cadena simple, y qué es un contenedor para valores múltiples. Intentemos los dos ejemplos anteriores en Julia:</p><pre><code class="language-julia-repl">julia&gt; A = `perl -le &#39;$|=1; for (0..3) { print }&#39;`
`perl -le &#39;$|=1; for (0..3) { print }&#39;`

julia&gt; run(A)
0
1
2
3

julia&gt; first = &quot;A&quot;; second = &quot;B&quot;;

julia&gt; B = `perl -le &#39;print for @ARGV&#39; &quot;1: $first&quot; &quot;2: $second&quot;`
`perl -le &#39;print for @ARGV&#39; &#39;1: A&#39; &#39;2: B&#39;`

julia&gt; run(B)
1: A
2: B</code></pre><p>Los resultados son idénticos, y el comportamiento de interpolación de Julia imita el shell con algunas mejoras debido a que Julia soporta objetos iterables de primera clase mientras la mayoría de los shells usan división de cadenas mediante espacios para ésto, lo cuál introduce ambigüedades. Cuando intentamos portar mandatos del shell a Julia, intentemos cortar y pegar primero. Como Julia te muestra los mandatos antes de que los ejecutes, puedes examinar fácilmente y de forma segura su interpretación sin hacer ningún daño.</p><h2><a class="nav-anchor" id="Tuberías-1" href="#Tuberías-1">Tuberías</a></h2><p>Los metacaracteres del shell tales como <code>|</code>, <code>&amp;</code>, and <code>&gt;</code>, necesitan ser acotados o escapados dentro de las comillas invertidas de Julia:</p><pre><code class="language-julia-repl">julia&gt; run(`echo hello &#39;|&#39; sort`)
hello | sort

julia&gt; run(`echo hello \| sort`)
hello | sort</code></pre><p>Esta expresión invoca el mandato <code>echo</code> con tres palabras como argumentos, &quot;hello&quot;, &quot;|&quot; y &quot;sort&quot;. El resultados es que se imprime una sola línea &quot;hello | sort&quot;. Dentro de las comillas traseras, el símbolo &quot;|&quot; no tiene un significado especial. ¿Cómo entonces, podemos construir una tubería? En lugar de usar el símbolo &quot;|&quot; dentro de la tubería, utilizaremos la función <a href="../stdlib/base.html#Base.pipeline-Tuple{Any,Any,Any,Vararg{Any,N} where N}"><code>pipeline()</code></a>:</p><pre><code class="language-julia-repl">julia&gt; run(pipeline(`echo hello`, `sort`))
hello</code></pre><p>Esto entuba la salida del mandato <code>echo</code> al mandato <code>sort</code>. Por supuesto, esto no es terriblemente interesante ya que sólo hay una línea que ordenar, pero podemos cosas mucho más interesantes:</p><pre><code class="language-julia-repl">julia&gt; run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))
210
211
212
213
214</code></pre><p>Esto imprime los cinco identificadores de usuario mayores dentro de un sistema UNIX. Los mandatos <code>cut</code>, <code>sort</code> y <code>tail</code> son &quot;criados&quot; como hijos inmediatos del proceso <code>julia</code> actual, sin que intervenga el proceso shell. Julia en sí mismo hace el trabajo (normalmente hecho por el shell) de inicializar las tuberías y conectar los descriptores de fichero.  Como Julia hace este trabajo, retiene un mejor control y puede hacer algunas cosas que el shell no puede.</p><p>Julia puede ejecutar múltiples órdenes en paralelo:</p><pre><code class="language-julia-repl">julia&gt; run(`echo hello` &amp; `echo world`)
world
hello</code></pre><p>El orden de esta salida es no determinista debido a que los dos procesos <code>echo</code> se lanzan casi simultáneamente, y compiten para hacer la primera escritura al descriptor <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a> que ambas comparten con el proceso padre <code>julia</code>.  Julia te premite entubar la salida desde estos procesos a otro programa:</p><pre><code class="language-julia-repl">julia&gt; run(pipeline(`echo world` &amp; `echo hello`, `sort`))
hello
world</code></pre><p>En términos de fontanería UNIX, lo que está pasando aquí es que un único objeto tubería de UNIX se ha creado y es escrito por dos procesos <code>echo</code> y el otro extremo al final de la tubería es leído por la orden <code>sort</code>.</p><p>La redirección de la E/S puede conseguirse pasando los argumentos clave stdin, stdout y stderr a la función <code>pipeline</code>:</p><pre><code class="language-julia">pipeline(`do_work`, stdout=pipeline(`sort`, &quot;out.txt&quot;), stderr=&quot;errs.txt&quot;)</code></pre><h3><a class="nav-anchor" id="Evitar-interbloqueos-en-tuberías-1" href="#Evitar-interbloqueos-en-tuberías-1">Evitar interbloqueos en tuberías</a></h3><p>Cuando leemos y escribirmos en los dos extremos de una tubería desde un solo proceso, es importante evitar forzar el núcleo a almacenar todos los datos en el buffer.</p><p>Por ejemplo, cuando leemos toda la salida de un mandato, llamamos a <code>readstring(out)</code>, no <code>wait(process)</code>, ya que el primero consumirá activamente todos los datos exritos por el proceso, mientras que el último interntará almacenar los datos en los búferes del kernel mientras espera a que un lector esté conectado. </p><p>Otra solución común es separar el lector y el escritor de la tuberían en tareas separadas:</p><pre><code class="language-julia">writer = @async writeall(process, &quot;data&quot;)
reader = @async do_compute(readstring(process))
wait(process)
fetch(reader)</code></pre><h3><a class="nav-anchor" id="Ejemplo-complicado-1" href="#Ejemplo-complicado-1">Ejemplo complicado</a></h3><p>La combinación de un lenguaje de programación de alto nivel, una abstracción de mandatos de primera clase y la inicialización automática de tuberías entre procesos es muy poderos. Para dar algun sentido a las tuberías complejas que pueden ser creadas facilmente, he aquí algunos ejemplos más sofisticado, con nuestras disculpas por el excesito uso de scripts Perl con una sola línea:</p><pre><code class="language-julia-repl">julia&gt; prefixer(prefix, sleep) = `perl -nle &#39;$|=1; print &quot;&#39;$prefix&#39; &quot;, $_; sleep &#39;$sleep&#39;;&#39;`;

julia&gt; run(pipeline(`perl -le &#39;$|=1; for(0..9){ print; sleep 1 }&#39;`, prefixer(&quot;A&quot;,2) &amp; prefixer(&quot;B&quot;,2)))
A 0
B 1
A 2
B 3
A 4
B 5
A 6
B 7
A 8
B 9</code></pre><p>Este es el ejemplo típico de un solo productor que alimenta dos consumidores concurrentes: un proceso <code>perl</code> genera líneas con los número 0 a 9, el otro con la letra &quot;B&quot;. Qué consumidor llega el primero es no determinista, pero una vez que se ha ganado la carrera, las líneas son consumidas alternativamente primero por un proceso y después por el otro. (Fijas <code>$|=1</code> en Perl causa que cada instrucción de impresión vuelque al flujo <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a>, lo cuál es necesario para que este ejemplo funcione. En caso contrario toda la salida va a un buffer y sería impresa en la tubería de una vez, para ser leída por un solo proceso consumidor).</p><p>He aquí un ejemplo incluso más complicado de productor consumidor multi-etapa:</p><pre><code class="language-julia-repl">julia&gt; run(pipeline(`perl -le &#39;$|=1; for(0..9){ print; sleep 1 }&#39;`,
           prefixer(&quot;X&quot;,3) &amp; prefixer(&quot;Y&quot;,3) &amp; prefixer(&quot;Z&quot;,3),
           prefixer(&quot;A&quot;,2) &amp; prefixer(&quot;B&quot;,2)))
A X 0
B Y 1
A Z 2
B X 3
A Y 4
B Z 5
A X 6
B Y 7
A Z 8
B X 9</code></pre><p>Este ejemplo es similar al anterior, excepto en que hay dos etapas de consumidores y las estapas tiene diferente latencia por lo que usan un número de workers paralelos diferrentes, para mantener saturado el throughput .</p><p>Se recomienda intentar todos estos ejemplos y ver cómo funcionan.</p><footer><hr/><a class="previous" href="interacting-with-julia.html"><span class="direction">Previous</span><span class="title">Interactuando con Julia</span></a><a class="next" href="calling-c-and-fortran-code.html"><span class="direction">Next</span><span class="title">Llamando a código C y Fortran</span></a></footer></article></body></html>
