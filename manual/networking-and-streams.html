<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Redes y Flujos · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Funciones</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="types.html">Tipos</a></li><li><a class="toctext" href="methods.html">Métodos</a></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión y Promoción</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a></li><li class="current"><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a><ul class="internal"><li><a class="toctext" href="#Flujos-de-E/S-básico-1">Flujos de E/S básico</a></li><li><a class="toctext" href="#E/S-Texto-1">E/S Texto</a></li><li><a class="toctext" href="#Propiedades-contextuales-de-salida-IO-1">Propiedades contextuales de salida IO</a></li><li><a class="toctext" href="#Trabajando-con-Ficheros-1">Trabajando con Ficheros</a></li><li><a class="toctext" href="#Un-ejemplo-TCP-simple-1">Un ejemplo TCP simple</a></li><li><a class="toctext" href="#Resolviendo-Direcciones-IP-1">Resolviendo Direcciones IP</a></li></ul></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="networking-and-streams.html">Redes y Flujos</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/networking-and-streams.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Redes y Flujos</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="networking-and-streams-1" href="#networking-and-streams-1">Redes y Flujos</a></h1><p>Julia proporciona una interfaz rica para tratar objetos que representen un flujo contínuo de E/S como terminales, tuberías y sockets TCP. Esta interfaz, aunque asíncrona a nivel del sistema, se presenta de forma síncrona al programador y normalmente no es necesario pensar en la operación asincrónica subyacente. Esto se logra haciendo un uso intensivo de la funcionalidad de los hilos cooperativos en Julia (o <a href="control-flow.html#man-tasks-1">corrutinas</a>).</p><h2><a class="nav-anchor" id="Flujos-de-E/S-básico-1" href="#Flujos-de-E/S-básico-1">Flujos de E/S básico</a></h2><p>Todos los flujos en Julia exponen al menos un método <a href="../stdlib/io-network.html#Base.read"><code>read()</code></a> y un <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a>, tomando el flujo como su primer argumento, por ejemplo:</p><pre><code class="language-julia-repl">julia&gt; write(STDOUT,&quot;Hello World&quot;);  # suppress return value 11 with ;
Hello World
julia&gt; read(STDIN,Char)

&#39;\n&#39;: ASCII/Unicode U+000a (category Cc: Other, control)</code></pre><p>Tenga en cuenta que <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a> devuelve 11, el número de bytes (en <code>&quot;Hello World&quot;</code>) escrito en <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a>, pero este valor de retorno se suprime con <code>;</code>.</p><p>Aquí Enter fue presionado nuevamente para que Julia leyera la nueva línea. Ahora, como puede ver en este ejemplo, <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a> toma los datos para escribir como su segundo argumento, mientras que <a href="../stdlib/io-network.html#Base.read"><code>read()</code></a> toma el tipo de datos para ser leído como el segundo argumento.</p><p>Por ejemplo, para leer una matriz de bytes simple, podríamos hacer:</p><pre><code class="language-julia-repl">julia&gt; x = zeros(UInt8, 4)
4-element Array{UInt8,1}:
 0x00
 0x00
 0x00
 0x00

julia&gt; read!(STDIN, x)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64</code></pre><p>Sin embargo, dado que esto es un poco engorroso, se proporcionan varios métodos de conveniencia. Por ejemplo, podríamos haber escrito lo anterior como:</p><pre><code class="language-julia-repl">julia&gt; read(STDIN,4)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64</code></pre><p>o si hubiéramos querido leer toda la línea en su lugar:</p><pre><code class="language-julia-repl">julia&gt; readline(STDIN)
abcd
&quot;abcd&quot;</code></pre><p>Tenga en cuenta que, dependiendo de la configuración de su terminal, su TTY puede estar almacenado en línea y, por lo tanto, podría requerir una entrada adicional antes de enviar los datos a Julia.</p><p>Para leer cada línea desde <a href="../stdlib/io-network.html#Base.STDIN"><code>STDIN</code></a>, puede usar <a href="../stdlib/io-network.html#Base.eachline"><code>eachline()</code></a>:</p><pre><code class="language-julia">for line in eachline(STDIN)
    print(&quot;Found $line&quot;)
end</code></pre><p>o <a href="../stdlib/io-network.html#Base.read"><code>read()</code></a> si deseamos leer carácter a carácter en lugar de lo anterior:</p><pre><code class="language-julia">while !eof(STDIN)
    x = read(STDIN, Char)
    println(&quot;Found: $x&quot;)
end</code></pre><h2><a class="nav-anchor" id="E/S-Texto-1" href="#E/S-Texto-1">E/S Texto</a></h2><p>Note que el método <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a> mencionado arriba opera sobre flujos binarios. En particular, los valores no son convertidos a ninguna representación de texto canónica sino que son escritas tal cual:</p><pre><code class="language-julia-repl">julia&gt; write(STDOUT,0x61);  # suppress return value 1 with ;
a</code></pre><p>Note que <code>a</code> es escrito a <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a> por la función <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a> y que el valor devuelto es <code>1</code> (ya que <code>0x61</code> es un byte).</p><p>Para E/S texto, use los métodos <a href="../stdlib/io-network.html#Base.print"><code>print()</code></a> o <a href="../stdlib/io-network.html#Base.show-Tuple{Any}"><code>show()</code></a> methods, dependiendo de sus necesidades (ver la referencia de la librería estándar para una discusin detallada de la diferencia entre las dos):</p><pre><code class="language-julia-repl">julia&gt; print(STDOUT, 0x61)
97</code></pre><h2><a class="nav-anchor" id="Propiedades-contextuales-de-salida-IO-1" href="#Propiedades-contextuales-de-salida-IO-1">Propiedades contextuales de salida IO</a></h2><p>En ocasiones, la salida de IO puede beneficiarse de la capacidad de pasar información contextual a los métodos de muestra. El objeto <a href="../stdlib/io-network.html#Base.IOContext"><code>IOContext</code></a> proporciona este marco para asociar metadatos arbitrarios con un objeto IO. Por ejemplo, <a href="../stdlib/io-network.html#Base.showcompact"><code>showcompact</code></a> agrega un parámetro de alusión al objeto IO para que el método del espectáculo invocado imprima un resultado más corto (si corresponde).</p><h2><a class="nav-anchor" id="Trabajando-con-Ficheros-1" href="#Trabajando-con-Ficheros-1">Trabajando con Ficheros</a></h2><p>Al igual que muchos otros entornos, Julia tiene una función <a href="../stdlib/io-network.html#Base.open"><code>open()</code></a>, que toma un nombre de archivo y devuelve un objeto <code>IOStream</code> que puede usar para leer y escribir cosas del archivo. Por ejemplo, si tenemos un archivo, <code>hello.txt</code>, cuyo contenido es <code>Hello, World!</code>:</p><pre><code class="language-julia-repl">julia&gt; f = open(&quot;hello.txt&quot;)
IOStream(&lt;file hello.txt&gt;)

julia&gt; readlines(f)
1-element Array{String,1}:
 &quot;Hello, World!&quot;</code></pre><p>Si desea escribir a un fichero, puede abrirlo con el flag de escritura (<code>&quot;w&quot;</code>):</p><pre><code class="language-julia-repl">julia&gt; f = open(&quot;hello.txt&quot;,&quot;w&quot;)
IOStream(&lt;file hello.txt&gt;)

julia&gt; write(f,&quot;Hello again.&quot;)
12</code></pre><p>Si examina el contenido de <code>hello.txt</code> en este punto, notará que está vacío; no se ha escrito nada en el disco todavía. Esto se debe a que el <code>IOStream</code> debe cerrarse antes de que la escritura realmente se vacíe en el disco:</p><pre><code class="language-julia-repl">julia&gt; close(f)</code></pre><p>Examinando <code>hello.txt</code> nuevamente mostrará que su contenido ha sido cambiado.</p><p>Abrir un archivo, hacer algo con su contenido y volver a cerrarlo es un patrón muy común. Para hacerlo más fácil, existe otra invocación de <a href="../stdlib/io-network.html#Base.open"><code>open()</code></a> que toma una función como su primer argumento y nombre de archivo como su segundo, abre el archivo, llama a la función con el archivo como argumento, y luego lo cierra de nuevo. Por ejemplo, dada una función:</p><pre><code class="language-julia">function read_and_capitalize(f::IOStream)
    return uppercase(readstring(f))
end</code></pre><p>Uno puede llamar a:</p><pre><code class="language-julia-repl">julia&gt; open(read_and_capitalize, &quot;hello.txt&quot;)
&quot;HELLO AGAIN.&quot;</code></pre><p>para abrir <code>hello.txt</code>, llamar <code>read_and_capitalize on it</code>, cerrar <code>hello.txt</code> y devolver los contenidos capitalizados.</p><p>Para incluso evitar tener que definir una función nombrada, puede usarse la sintaxis <code>do</code>, que crea una función anónima sobre la marcha:</p><pre><code class="language-julia-repl">julia&gt; open(&quot;hello.txt&quot;) do f
           uppercase(readstring(f))
       end
&quot;HELLO AGAIN.&quot;</code></pre><h2><a class="nav-anchor" id="Un-ejemplo-TCP-simple-1" href="#Un-ejemplo-TCP-simple-1">Un ejemplo TCP simple</a></h2><p>Saltemos directamente con un ejemplo simple que involucra sockets TCP. Primero creemos un servidor simple:</p><pre><code class="language-julia-repl">julia&gt; @async begin
           server = listen(2000)
           while true
               sock = accept(server)
               println(&quot;Hello World\n&quot;)
           end
       end
Task (runnable) @0x00007fd31dc11ae0</code></pre><p>Para quienes estén familiarizados con la API de socket de Unix, los nombres de los métodos se sentirán familiares, aunque su uso es algo más simple que la API de socket Raw de Unix. La primera llamada a <a href="../stdlib/io-network.html#Base.listen-Tuple{Any}"><code>listen()</code></a> creará un servidor en espera de conexiones entrantes en el puerto especificado (2000) en este caso. La misma función también se puede usar para crear otros tipos de servidores:</p><pre><code class="language-julia-repl">julia&gt; listen(2000) # Listens on localhost:2000 (IPv4)
TCPServer(active)

julia&gt; listen(ip&quot;127.0.0.1&quot;,2000) # Equivalent to the first
TCPServer(active)

julia&gt; listen(ip&quot;::1&quot;,2000) # Listens on localhost:2000 (IPv6)
TCPServer(active)

julia&gt; listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces
TCPServer(active)

julia&gt; listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces
TCPServer(active)

julia&gt; listen(&quot;testsocket&quot;) # Listens on a UNIX domain socket/named pipe
PipeServer(active)</code></pre><p>Tengase en cuenta que el tipo de retorno de la última invocación es diferente. Esto se debe a que este servidor no escucha en TCP, sino sobre una tubería nombrada (Windows) o socket de dominio UNIX. La diferencia es sutil y tiene que ver con los métodos <a href="../stdlib/io-network.html#Base.accept"><code>accept()</code></a> y <a href="../stdlib/io-network.html#Base.connect-Tuple{TCPSocket,Integer}"><code>connect()</code></a>. El método <a href="../stdlib/io-network.html#Base.accept"><code>accept()</code></a> recupera una conexión con el cliente que se está conectando en el servidor que acabamos de crear, mientras que la función <a href="../stdlib/io-network.html#Base.connect-Tuple{TCPSocket,Integer}"><code>connect()</code></a> se conecta a un servidor usando el método especificado. La función <a href="../stdlib/io-network.html#Base.connect-Tuple{TCPSocket,Integer}"><code>connect()</code></a> toma los mismos argumentos que <a href="../stdlib/io-network.html#Base.listen-Tuple{Any}"><code>listen()</code></a>, por lo tanto, suponiendo que el entorno (es decir, host, cwd, etc.) es el mismo uno debería capaz de pasar los mismos argumentos a <a href="../stdlib/io-network.html#Base.connect-Tuple{TCPSocket,Integer}"><code>connect()</code></a> como lo se hizo para escuchar en el establecimiento de la conexión. Así que vamos a intentarlo (después de haber creado el servidor anterior):</p><pre><code class="language-julia-repl">julia&gt; connect(2000)
TCPSocket(open, 0 bytes waiting)

julia&gt; Hello World</code></pre><p>Como era de esperar, vimos &quot;Hello World&quot; impreso. Entonces, analicemos realmente lo que sucedió detrás de escena. Cuando llamamos a <a href="../stdlib/io-network.html#Base.connect-Tuple{TCPSocket,Integer}"><code>connect()</code></a>, nos conectamos al servidor que acabamos de crear. Mientras tanto, la función <code>accept</code> devuelve una conexión del lado del servidor al socket recién creado e imprime &quot;Hello World&quot; para indicar que la conexión fue exitosa.</p><p>Una gran fortaleza de Julia es que, dado que la API se expone sincrónicamente a pesar de que la E/S realmente está sucediendo de forma asíncrona, no tuvimos que preocuparnos de las devoluciones de llamadas ni siquiera de asegurarnos de que el servidor se ejecute. Cuando llamamos a <a href="../stdlib/io-network.html#Base.connect-Tuple{TCPSocket,Integer}"><code>connect()</code></a> la tarea actual esperó a que se estableciera la conexión y solo continuó ejecutándose después de que se hizo. En esta pausa, la tarea del servidor reanudó la ejecución (porque una solicitud de conexión ya estaba disponible), aceptó la conexión, imprimió el mensaje y esperó al próximo cliente. Leer y escribir funciona de la misma manera. Para ver esto, considere el siguiente servidor de eco simple:</p><pre><code class="language-julia-repl">julia&gt; @async begin
           server = listen(2001)
           while true
               sock = accept(server)
               @async while isopen(sock)
                   write(sock,readline(sock))
               end
           end
       end
Task (runnable) @0x00007fd31dc12e60

julia&gt; clientside = connect(2001)
TCPSocket(RawFD(28) open, 0 bytes waiting)

julia&gt; @async while true
           write(STDOUT,readline(clientside))
       end
Task (runnable) @0x00007fd31dc11870

julia&gt; println(clientside,&quot;Hello World from the Echo Server&quot;)
Hello World from the Echo Server</code></pre><p>Como con otros flujos, use <a href="../stdlib/io-network.html#Base.close"><code>close()</code></a> para desconectar el socket:</p><pre><code class="language-julia-repl">julia&gt; close(clientside)</code></pre><h2><a class="nav-anchor" id="Resolviendo-Direcciones-IP-1" href="#Resolviendo-Direcciones-IP-1">Resolviendo Direcciones IP</a></h2><p>Uno de los métodos <a href="../stdlib/io-network.html#Base.connect-Tuple{TCPSocket,Integer}"><code>connect()</code></a> que no sigue los métodos <a href="../stdlib/io-network.html#Base.listen-Tuple{Any}"><code>listen()</code></a> es <code>connect(host::String, port)</code>, que intentará conectarse al host dado por el parámetro <code>host</code> en el puerto dado por el parámetro port. Te permite hacer cosas como:</p><pre><code class="language-julia-repl">julia&gt; connect(&quot;google.com&quot;,80)
TCPSocket(RawFD(30) open, 0 bytes waiting)</code></pre><p>En la base de esta funcionalidad está <a href="../stdlib/io-network.html#Base.getaddrinfo"><code>getaddrinfo()</code></a>, que hará la resolución de dirección apropiada:</p><pre><code class="language-julia-repl">julia&gt; getaddrinfo(&quot;google.com&quot;)
ip&quot;74.125.226.225&quot;</code></pre><footer><hr/><a class="previous" href="linear-algebra.html"><span class="direction">Previous</span><span class="title">Álgebra Lineal</span></a><a class="next" href="parallel-computing.html"><span class="direction">Next</span><span class="title">Computación Paralela</span></a></footer></article></body></html>
