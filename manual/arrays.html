<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Arrays Multi-dimensionales · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Funciones</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="types.html">Tipos</a></li><li><a class="toctext" href="methods.html">Métodos</a></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión y Promoción</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li class="current"><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a><ul class="internal"><li><a class="toctext" href="#Arrays-1">Arrays</a></li><li><a class="toctext" href="#Vectores-y-Matrices-*Sparse*-1">Vectores y Matrices <em>Sparse</em></a></li></ul></li><li><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Comprobación de Límites</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="arrays.html">Arrays Multi-dimensionales</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Arrays Multi-dimensionales</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="man-multi-dim-arrays-1" href="#man-multi-dim-arrays-1">Arrays Multi-dimensionales</a></h1><p>Julia, como la mayoría de los lenguajes informáticos técnicos, proporciona una implementación de los arrays de primera clase. La mayoría de los lenguajes informáticos técnicos prestan mucha atención a su implementación de arrays a expensas de otros contenedores. Julia no trata los arrays de manera especial. La biblioteca de arrays se ha implementado casi completamente en el propio lenguaje Julia, y deriva su rendimiento del compilador, al igual que cualquier otro código escrito en Julia. Como tal, es también posible definir tipos de arrays personalizados heredando de <code>AbstractArray</code>. Consulte la <a href="interfaces.html#man-interface-array-1">sección de manual en la interfaz AbstractArray</a> para ms detalles sobre implementar un tipo array personalizado.</p><p>Un array es una colección de objetos almacenados en una cuadrícula multidimensional. En el caso más general, un array puede contener objetos de tipo <code>Any</code>. Para la mayoría de los propósitos computacionales, los arrays deben contener objetos de un tipo más específico, como  <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a> o <a href="../stdlib/numbers.html#Core.Int32"><code>Int32</code></a>.</p><p>En general, a diferencia de muchos otros lenguajes informáticos técnicos, Julia no espera que los programas se escriban en un estilo vectorizado para el rendimiento. El compilador de Julia utiliza la inferencia de tipos y genera código optimizado para la indexación escalar de arrays, permitiendo que los programas se escriban en un estilo que sea conveniente y legible, sin sacrificar el rendimiento y utilizando menos memoria a veces.</p><p>En Julia, todos los argumentos a las funciones se pasan por referencia. Algunos lenguajes informáticos técnicos pasan los arrays por valor, y esto es conveniente en muchos casos. En Julia, las modificaciones hechas a los arrays de entrada dentro de una función serán visibles en la función principal. Toda la biblioteca de arrays de Julia garantiza que las entradas no sean modificadas por las funciones de biblioteca. El código de usuario, si necesita mostrar un comportamiento similar, debe tener cuidado de crear una copia de las entradas que puede modificar.</p><h2><a class="nav-anchor" id="Arrays-1" href="#Arrays-1">Arrays</a></h2><h3><a class="nav-anchor" id="Funciones-Básicas-1" href="#Funciones-Básicas-1">Funciones Básicas</a></h3><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="../stdlib/collections.html#Base.eltype"><code>eltype(A)</code></a></td><td>Tipo de los elementos contenidos en <code>A</code></td></tr><tr><td><a href="../stdlib/collections.html#Base.length-Tuple{Any}"><code>length(A)</code></a></td><td>Número de elementos en <code>A</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.ndims"><code>ndims(A)</code></a></td><td>Número de dimensiones de <code>A</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.size"><code>size(A)</code></a></td><td>Una tupla que contien las dimensiones de <code>A</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.size"><code>size(A,n)</code></a></td><td>El tamaño de <code>A</code> a lo largo de una dimensión particular <code>n</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.indices-Tuple{Any}"><code>indices(A)</code></a></td><td>Una tupla que contiene los índices válidos de <code>A</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.indices-Tuple{Any}"><code>indices(A,n)</code></a></td><td>Un rango expresando los úndices válidos a lo largo de la dimensión <code>n</code>          </td></tr><tr><td><a href="../stdlib/arrays.html#Base.eachindex"><code>eachindex(A)</code></a></td><td>Un iterador eficiente para visitar cada posición en <code>A</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.stride"><code>stride(A,k)</code></a></td><td>La zancada (<em>stride</em>, distancia de índice lineal entre elementos adyacentes) a lo largo de la dimensión <code>k</code>.</td></tr><tr><td><a href="../stdlib/arrays.html#Base.strides"><code>strides(A)</code></a></td><td>Una tupla de las zancadas en cada dimensión</td></tr></table><h3><a class="nav-anchor" id="Construcción-e-Inicialización-1" href="#Construcción-e-Inicialización-1">Construcción e Inicialización</a></h3><p>Existen muchas funciones para construir e inicializar matrices. En la siguiente lista de tales funciones, las llamadas con un argumento <code>dims...</code> pueden tomar una sola tupla de tamaños de dimensión o una serie de tamaños de dimensión pasados como un número variable de argumentos. Muchas de estas funciones también aceptan un primea entrada <code>T</code>, que es el tipo de los elementos del array. Si este tipo es omitido se asumirá como tipo por defecto por defecto <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>.</p><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="../stdlib/arrays.html#Core.Array"><code>Array{T}(dims...)</code></a></td><td>an uninitialized dense <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a></td></tr><tr><td><a href="../stdlib/arrays.html#Base.zeros"><code>zeros(T, dims...)</code></a></td><td>an <code>Array</code> of all zeros</td></tr><tr><td><a href="../stdlib/arrays.html#Base.zeros"><code>zeros(A)</code></a></td><td>an array of all zeros with the same type, element type and shape as <code>A</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.ones"><code>ones(T, dims...)</code></a></td><td>an <code>Array</code> of all ones</td></tr><tr><td><a href="../stdlib/arrays.html#Base.ones"><code>ones(A)</code></a></td><td>an array of all ones with the same type, element type and shape as <code>A</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.trues"><code>trues(dims...)</code></a></td><td>a <a href="../stdlib/arrays.html#Base.BitArray"><code>BitArray</code></a> with all values <code>true</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.trues"><code>trues(A)</code></a></td><td>a <code>BitArray</code> with all values <code>true</code> and the same shape as <code>A</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.falses"><code>falses(dims...)</code></a></td><td>a <code>BitArray</code> with all values <code>false</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.falses"><code>falses(A)</code></a></td><td>a <code>BitArray</code> with all values <code>false</code> and the same shape as <code>A</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.reshape"><code>reshape(A, dims...)</code></a></td><td>an array containing the same data as <code>A</code>, but with different dimensions</td></tr><tr><td><a href="../stdlib/base.html#Base.copy"><code>copy(A)</code></a></td><td>copy <code>A</code></td></tr><tr><td><a href="../stdlib/base.html#Base.deepcopy"><code>deepcopy(A)</code></a></td><td>copy <code>A</code>, recursively copying its elements</td></tr><tr><td><a href="../stdlib/arrays.html#Base.similar-Tuple{AbstractArray}"><code>similar(A, T, dims...)</code></a></td><td>an uninitialized array of the same type as <code>A</code> (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of <code>A</code> if omitted.</td></tr><tr><td><a href="../stdlib/arrays.html#Base.reinterpret"><code>reinterpret(T, A)</code></a></td><td>an array with the same binary data as <code>A</code>, but with element type <code>T</code></td></tr><tr><td><a href="../stdlib/numbers.html#Base.Random.rand"><code>rand(T, dims...)</code></a></td><td>an <code>Array</code> with random, iid <a href="#footnote-1">[1]</a> and uniformly distributed values in the half-open interval <span>$[0, 1)$</span></td></tr><tr><td><a href="../stdlib/numbers.html#Base.Random.randn"><code>randn(T, dims...)</code></a></td><td>an <code>Array</code> with random, iid and standard normally distributed values</td></tr><tr><td><a href="../stdlib/arrays.html#Base.eye"><code>eye(T, n)</code></a></td><td><code>n</code>-by-<code>n</code> identity matrix</td></tr><tr><td><a href="../stdlib/arrays.html#Base.eye"><code>eye(T, m, n)</code></a></td><td><code>m</code>-by-<code>n</code> identity matrix</td></tr><tr><td><a href="../stdlib/arrays.html#Base.linspace"><code>linspace(start, stop, n)</code></a></td><td>range of <code>n</code> linearly spaced elements from <code>start</code> to <code>stop</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.fill!"><code>fill!(A, x)</code></a></td><td>fill the array <code>A</code> with the value <code>x</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.fill"><code>fill(x, dims...)</code></a></td><td>an <code>Array</code> filled with the value <code>x</code></td></tr></table><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p><em>iid</em>, independently and identically distributed.</p></div><p>La sintaxis <code>[A, B, C, ...]</code> construye un array 1-dimensional (vector) a partir de sus argumentos. Si todos los argumentos tienen un <a href="conversion-and-promotion.html#conversion-and-promotion-1">tipo de promocion</a> comun entonces ellos son convertidos a este tipo usando <code>convert()</code>.</p><h3><a class="nav-anchor" id="Concatenación-1" href="#Concatenación-1">Concatenación</a></h3><p>Los arrays pueden ser construídos y también concatenados usando las siguientes funciones:</p><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="../stdlib/arrays.html#Base.cat"><code>cat(k, A...)</code></a></td><td>concatena n-d arrays a lo largo de la dimensión <code>k</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.vcat"><code>vcat(A...)</code></a></td><td>abreviatura para <code>cat(1, A...)</code></td></tr><tr><td><a href="../stdlib/arrays.html#Base.hcat"><code>hcat(A...)</code></a></td><td>abreviatura para <code>cat(2, A...)</code></td></tr></table><p>Los valores escalares pasados a estas funciones son tratados como arrays de 1 elemento.</p><p>Las funciones de concatenación se usan tan frecuentemente que tiene una sintaxis especial:</p><table><tr><th>Expression</th><th>Calls</th></tr><tr><td><code>[A; B; C; ...]</code></td><td><a href="../stdlib/arrays.html#Base.vcat"><code>vcat()</code></a></td></tr><tr><td><code>[A B C ...]</code></td><td><a href="../stdlib/arrays.html#Base.hcat"><code>hcat()</code></a></td></tr><tr><td><code>[A B; C D; ...]</code></td><td><a href="../stdlib/arrays.html#Base.hvcat"><code>hvcat()</code></a></td></tr></table><p><a href="../stdlib/arrays.html#Base.hvcat"><code>hvcat()</code></a> concatena tanto en la dimensión 1 (con puntos y coma) como en la dos (con espacios).</p><h3><a class="nav-anchor" id="Inicializadores-de-Array-Tipados-1" href="#Inicializadores-de-Array-Tipados-1">Inicializadores de Array Tipados</a></h3><p>Se puede construir una matriz con un tipo de elemento específico utilizando la sintaxis <code>T[A, B, C, ...]</code>. Esto construirá un array 1-d con el tipo de elemento <code>T</code>, inicializado para contener los elementos <code>A</code>, <code>B</code>, <code>C</code>, etc. Por ejemplo, <code>Any [x, y, z]</code> construye un array heterogéneo que puede contener cualquier valor.</p><p>La sintaxis de concatenación puede ser prefijada de forma similar con un tipo para especificar el tipo de elemento del resultado.</p><pre><code class="language-julia-repl">julia&gt; [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4</code></pre><h3><a class="nav-anchor" id="comprehensions-1" href="#comprehensions-1">Comprensiones</a></h3><p>Las comprensiones proporcionan una forma general y potente de construir arrays. Su sintaxis es similar a la notación de construcción de conjuntos en matemáticas:</p><pre><code class="language-none">A = [ F(x,y,...) for x=rx, y=ry, ... ]</code></pre><p>El significado de esta forma es que <code>F(x, y, ...)</code> es evaluado para las variables x, y, etc. tomando cada valor de la lista de valores proporcionada. Los valores se pueden especificar mediante cualquier objeto iterable, pero comúnmente serán rangos como <code>1:n</code> o <code>2:(n-1)</code>, o arrays de valores explícitos como <code>[1.2, 3.4, 5.7]</code>. El resultado es una matriz N-d densa con dimensiones que son la concatenación de las dimensiones de los rangos de las variables <code>rx</code>, <code>ry</code>, etc. y donde cada evaluación <code>F(x, y, ...)</code> devuelve un escalar.</p><p>El siguiente ejemplo calcula la media ponderada del elemento actual y su vecino izquierdo y derecho a lo largo de una rejilla unidimensional:</p><pre><code class="language-julia-repl">julia&gt; x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia&gt; [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511</code></pre><p>El tipo del array resultante depende de los tipos de los elementos calculados. Para controlar el tipo explícitamente, un tipo puede ser precedido a la comprensión. Por ejemplo, podríamos haber solicitado el resultado en precisión simple escribiendo:</p><pre><code class="language-julia">Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]</code></pre><h3><a class="nav-anchor" id="Expresiones-Generador-1" href="#Expresiones-Generador-1">Expresiones Generador</a></h3><p>Las comprensiones también se pueden escribir sin los corchetes que las encierran, produciendo un objeto conocido como <strong>generador</strong>. Este objeto puede ser iterado para producir valores bajo demanda, en lugar de reservar espacio para un array y almacenarlos en él de antemano (véase <a href="interfaces.html#man-interface-iteration-1">Iteración</a>). Por ejemplo, la siguiente expresión suma una serie sin asignar memoria:</p><pre><code class="language-julia-repl">julia&gt; sum(1/n^2 for n=1:1000)
1.6439345666815615</code></pre><p>Cuando se escribe una expresión generador con múltiples dimensiones dentro de una lista de argumentos, se necesitan paréntesis para separar el generador de argumentos posteriores:</p><pre><code class="language-julia-repl">julia&gt; map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification</code></pre><p>Todas las expresiones separadas por comas después del <code>for</code> se interpretan como rangos. Añadir paréntesis permite añadir un tercer argumento a <code>map</code>:</p><pre><code class="language-julia-repl">julia&gt; map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)</code></pre><p>Los rangos en generadores y comprensiones pueden depender de rangos anteriores escribiendo varias palabras clave <code>for</code>:</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)</code></pre><p>En tales casos, el resultado es siempre unidimensional.</p><p>Los valores generados se pueden filtrar usando la palabra clave <code>if</code>:</p><pre><code class="language-julia-repl">julia&gt; [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)</code></pre><h3><a class="nav-anchor" id="man-array-indexing-1" href="#man-array-indexing-1">Indexación</a></h3><p>La sintaxis general para indexar en un array n-dimensional <code>A</code> es:</p><pre><code class="language-none">X = A[I_1, I_2, ..., I_n]</code></pre><p>donde cada <code>I_k</code> puede ser un entero escalar, un array de enteros o cualquier otro <a href="arrays.html#man-supported-index-types-1">índice soportado</a>. Esto incluye <a href="../stdlib/arrays.html#Base.Colon"><code>Colon</code></a> (<code>:</code>) para seleccionar todos los índices dentro de la dimensión completa, rangos de la forma <code>a:c</code> o <code>a:b:c</code> para seleccionar subsecciones contiguas o con salto, y arrays de booleans para seleccionar elementos en sus índices <code>true</code>.</p><p>Si todos los índices son escalares, entonces el resultado <code>X</code> es un solo elemento del array <code>A</code>. De lo contrario, <code>X</code> es un array con el mismo número de dimensiones que la suma de las dimensionalidades de todos los índices.</p><p>Si todos los índices son vectores, por ejemplo, entonces la forma de <code>X</code> sería <code>(length(I_1), length(I_2), ..., length(I_n))</code>, donde las ubicaciones <code>(i_1, i_2, ..., i_n)</code> de <code>X</code> contienen el valor <code>A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]</code>. Si <code>I_1</code> se cambia por un array bidimensional, entonces <code>X</code> se vuelve un <code>n+1</code>-dimensional array de forma <code>(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))</code>. La matriz añade una dimensión. La ubicación <code>(i_1, i_2, i_3, ..., i_{n+1})</code> contiene el valor en <code>A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]</code>. Todas las dimensiones indexadas con escalares se eliminan. Por ejemplo, el resultado de <code>A[2, I, 3]</code> es un array de tamaño <code>size(I)</code>. Su i-ésimo elemento es poblado por <code>A[2, I[i], 3]</code>.</p><p>Como parte especial de esta sintaxis, se puede usar la palabra clave <code>end</code> para representar el último índice de cada dimensión dentro de los corchetes de indexación, según lo determinado por el tamaño del array más interno indexado. La sintaxis de indexación sin la palabra <code>end</code> es equivalente a una llamada a <code>getindex</code>:</p><pre><code class="language-none">X = getindex(A, I_1, I_2, ..., I_n)</code></pre><p>Ejemplo:</p><pre><code class="language-julia-repl">julia&gt; x = reshape(1:16, 4, 4)
4×4 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia&gt; x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1</code></pre><p>Los rangos vacío de la forma <code>n:n-1</code> se suelen usar para indicar la localización inter-index entre <code>n-1</code> y <code>n</code>. Por ejemplo, la función <a href="../stdlib/sort.html#Base.Sort.searchsorted"><code>searchsorted()</code></a> usa esta convención para indicar el punto de inserción de un valor no encontrados en un array ordenado:</p><pre><code class="language-julia-repl">julia&gt; a = [1,2,5,6,7];

julia&gt; searchsorted(a, 3)
3:2</code></pre><h3><a class="nav-anchor" id="Asignación-1" href="#Asignación-1">Asignación</a></h3><p>La sintaxis general para asignar valores en un array n-dimensional <code>A</code> es:</p><pre><code class="language-none">A[I_1, I_2, ..., I_n] = X</code></pre><p>donde cada <code>I_k</code> puede ser un índice escalar, un array de enteros o cualquier otro <a href="arrays.html#man-supported-index-types-1">índice soportado</a>. Esto incluye <a href="../stdlib/arrays.html#Base.Colon"><code>Colon</code></a> (<code>:</code>) para seleccionar todos los índices dentro de la dimensión completa, rangos de la forma <code>a:c</code> o <code>a:b:c</code> para seleccionar subsecciones contiguas o con salto, y arrays de booleans para seleccionar elementos en sus índices <code>true</code>.</p><p>Si <code>X</code> es un array, debe tener el mismo número de elementos que el producto de las longitudes de los índices <code>prod(length(I_1), length(I_2), ..., length(I_n))</code>. El valor en la localización <code>I_1[i_1], I_2[i_2], ..., I_n[i_n]</code>de <code>A</code> es sobreescrito con el valor <code>X[i_1, i_2, ..., i_n]</code>. Si <code>X</code> no es un array, su valor es escrito a todas las localizaciones referenciadas de <code>A</code>.</p><p>Justo como en <a href="arrays.html#man-array-indexing-1">Indexación</a>, la palabra clave <code>end</code> puede utilizarse para representar el último índice de cada dimensión dentro de los corchetes de los índices, como queda determinado por el tamaño del array en el que se está siendo asignado. La sintaxis de la asignación indexada sin la palabra clave <code>end</code> es equivalente a llamar a la función <a href="../stdlib/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}"><code>setindex!()</code></a>:</p><pre><code class="language-none">setindex!(A, X, I_1, I_2, ..., I_n)</code></pre><p>Ejemplo:</p><pre><code class="language-julia-repl">julia&gt; x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; x[1:2, 2:3] = -1
-1

julia&gt; x
3×3 Array{Int64,2}:
 1  -1  -1
 2  -1  -1
 3   6   9</code></pre><h3><a class="nav-anchor" id="man-supported-index-types-1" href="#man-supported-index-types-1">Tipos de Índices Soportados</a></h3><p>En la expresión <code>A[I_1, I_2, ..., I_n]</code>, cada <code>I_k</code> puede ser un índice escalar, un array de índices escalares o un objeto que repreenta un array de índices escalares y puede ser convertido a tal mediante <a href="../stdlib/arrays.html#Base.to_indices"><code>to_indices</code></a>:</p><ol><li><p>Un índice escalar. Por defecto esto incluye:</p><ul><li><p>Enteros no booleanos</p></li><li><p><code>CartesianIndex{N}</code>s, que se comportan como una <code>N</code>-tupla de enteros abarcando múltiples dimensiones (ver abajo para ms detalles)</p></li></ul></li><li><p>Un array de índices escalares. Esto incluye:</p><ul><li><p>Vectores y arrays multidimensionales de enteros</p></li><li><p>Arrays vacíos como <code>[]</code>, que no selecciona elementos</p></li><li><p><code>Range</code>s de la forma <code>a:c</code> o <code>a:b:c</code>, que seleccionan subsecciones contiguas o con salto desde <code>a</code> hasta <code>c</code> (inclusive)</p></li><li><p>Cualquier array de índices escalares que sea un subtipo de <code>AbstractArray</code></p></li><li><p>Arrays de <code>CartesianIndex{N}</code> (ver abajo para ms detalles)</p></li></ul></li><li><p>Un objeto que representa un array de índice escalares y puede ser convertido a tal mediante <a href="../stdlib/arrays.html#Base.to_indices"><code>to_indices</code></a>. Por defecto esto incluye:</p><ul><li><p><a href="../stdlib/arrays.html#Base.Colon"><code>Colon()</code></a> (<code>:</code>), que representa todos los índices dentro de una dimensión entera o a través del array completo</p></li><li><p>Arrays de booleans, que seleccionan los elementos en los que sus índices son <code>true</code> indices (ver abajo para más detalles)</p></li></ul></li></ol><h4><a class="nav-anchor" id="Índices-Cartesianos-1" href="#Índices-Cartesianos-1">Índices Cartesianos</a></h4><p>El objeto especial <code>CartesianIndex{N}</code> representa un índice escalar que se comporta como una <code>N</code>-tupla de enteros que abarcan multiples dimensioneas. Por ejemplo:</p><pre><code class="language-jldoctest">julia&gt; A = reshape(1:32, 4, 4, 2);

julia&gt; A[3, 2, 1]
7

julia&gt; A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true</code></pre><p>Considerado solo, esto puede parecer relativamente trivial; <code>CartesianIndex</code> simplemente reúne múltiples enteros juntos en un objeto que representa un único índice multidimensional. Sin embargo, cuando se combina con otras formas de indexación e iteradores que producen <code>CartesianIndex</code>es, esto puede conducir directamente a un código muy elegante y eficiente. Ver <a href="interfaces.html#man-interface-iteration-1">Iteración</a> a continuación, y para algunos ejemplos más avanzados, ver <a href="https://julialang.org/blog/2016/02/iteration">esta publicación en el blog sobre algoritmos multidimensionales e iteración</a>.</p><p>Los <em>arrays</em> de <code>CartesianIndex{N}</code> también sestán soportados. Representan una colección de índices escalares que abarcan   <code>N</code> dimensiones cada uno, lo que permite una forma de indexación que a veces se denomina <em>indexación puntual</em>. Por ejemplo, permite acceder a los elementos diagonales desde la primera &quot;página&quot; de &#39;A&#39; desde arriba:</p><pre><code class="language-jldoctest">julia&gt; page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16</code></pre><p>Esto se puede expresar mucho más simplemente con <a href="functions.html#man-vectorized-1"><em>dot broadcasting</em></a> y combinándolo con un índice entero normal (en lugar de extraer la primera página de<code>A</code> como un paso separado). Incluso se puede combinar con <code>:</code> para extraer ambas diagonales de las dos páginas al mismo tiempo:</p><pre><code class="language-jldoctest">julia&gt; A[CartesianIndex.(indices(A, 1), indices(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia&gt; A[CartesianIndex.(indices(A, 1), indices(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>CartesianIndex</code> y los arrays de <code>CartesianIndex</code> no son compatibles con la palabra clave <code>end</code> que representa el último índice de una dimensión. No usaremos <code>end</code> cuando se indexen expresiones que puedan contener <code>CartesianIndex</code> or arrays de ellos.</p></div></div><h4><a class="nav-anchor" id="Indexación-Lógica-1" href="#Indexación-Lógica-1">Indexación Lógica</a></h4><p>A menudo denominada indexación lógica o indexación con una máscara lógica, la indexación mediante  una matriz booleana selecciona elementos en los índices cuyos valores son <code>verdaderos</code>. La indexación por un vector booleano <code>B</code> es efectivamente igual a la indexación por el vector de enteros que es devuelto por <code>find(B)</code>. De forma similar, la indexación por una matriz booleana <code>N</code>-dimensional es efectivamente igual a la indexación por el vector de <code>CartesianIndex{N}</code>s donde sus valores son <code>true</code>. Un índice lógico debe ser un vector de la misma longitud que la dimensión en la que indexa, o debe ser el único índice proporcionado y debe coincidir con el tamaño y la dimensionalidad de la matriz en la que se indexa. En general, es más eficiente usar matrices booleanas como índices directamente en lugar de llamar primero a <a href="../stdlib/arrays.html#Base.find-Tuple{Any}"><code>find()</code></a>.</p><pre><code class="language-julia-repl">julia&gt; x = reshape(1:16, 4, 4)
4×4 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia&gt; mask = map(ispow2, x)
4×4 Array{Bool,2}:
  true  false  false  false
  true  false  false  false
 false  false  false  false
  true   true  false   true

julia&gt; x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16</code></pre><h3><a class="nav-anchor" id="Iteración-1" href="#Iteración-1">Iteración</a></h3><p>Las formas recomendadas de iterar sobre un array completo son:</p><pre><code class="language-julia">for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end</code></pre><p>La primera construcción se usa cuando necesitamos el valor, pero no los índices, de cada elemento. En la segunda construcción, <code>i</code> será un <code>Int</code> si <code>A</code> es un tipo array con indexación lineal rápida; en caso contrario será un <code>CartesianIndex</code>:</p><pre><code class="language-julia-repl">julia&gt; A = rand(4,3);

julia&gt; B = view(A, 1:3, 2:3);

julia&gt; for i in eachindex(B)
           @show i
       end
i = CartesianIndex{2}((1, 1))
i = CartesianIndex{2}((2, 1))
i = CartesianIndex{2}((3, 1))
i = CartesianIndex{2}((1, 2))
i = CartesianIndex{2}((2, 2))
i = CartesianIndex{2}((3, 2))</code></pre><p>En contraste con <code>for i = 1:length(A)</code>, iterar con <code>eachindex</code> proporciona una forma eficiente de iterar sobre cualquier tipo de array.</p><h3><a class="nav-anchor" id="Rasgos-de-Array-1" href="#Rasgos-de-Array-1">Rasgos de  Array</a></h3><p>Si uno escribe un tipo <a href="../stdlib/arrays.html#Core.AbstractArray"><code>AbstractArray</code></a> personalizado, uno puede especificar que el tipo tiene indexación lineal rápida usando:</p><pre><code class="language-julia">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p>Esta configuración hará que la iteración <code>eachindex</code> sobre un objeto <code>MyArray</code> use enteros. Si no especifica este rasgo, se usa el valor predeterminado <code>IndexCartesian()</code>.</p><h3><a class="nav-anchor" id="Arrays,-Funciones-y-Operadores-Vectorizados-1" href="#Arrays,-Funciones-y-Operadores-Vectorizados-1">Arrays, Funciones y Operadores Vectorizados</a></h3><p>Los siguientes operadores están soportados para arrays:</p><ol><li><p>Aritmética unaria – <code>-</code>, <code>+</code></p></li><li><p>Aritmética binaria – <code>-</code>, <code>+</code>, <code>*</code>, <code>/</code>, <code>\</code>, <code>^</code></p></li><li><p>Comparación – <code>==</code>, <code>!=</code>, <code>≈</code> (<a href="../stdlib/math.html#Base.isapprox"><code>isapprox</code></a>), <code>≉</code></p></li></ol><p>La mayoría de los operadores aritméticos binarios enumerados anteriormente también funcionan elemento a elemento cuando un argumento es escalar: <code>-</code>, <code>+</code>, y <code>*</code>cuando cualquiera de los argumentos es escalar, y <code>/</code> y <code>\</code> cuando el denominador es escalar. Por ejemplo, <code>[1, 2] + 3 == [4, 5]</code> y <code>[6, 4] / 2 == [3, 2]</code>.</p><p>Además, para permitir una conveniente vectorización de operaciones matemáticas y de otro tipo, Julia <a href="functions.html#man-vectorized-1">proporciona la sintaxis punto</a> <code>f.(args ...)</code>, por ejemplo, <code>sin.(x)</code> o <code>min.(x, y)</code>, para operaciones con elementos sobre arrays o mezclas de matrices y escalares (una <a href="arrays.html#broadcasting-1">Retransmisión (<em>broadcasting</em>)</a>); estos tienen la ventaja adicional de &quot;fusión&quot; en un solo bucle cuando se combina con otras llamadas de puntos, por ejemplo, <code>sin.(cos.(x))</code></p><p>También, <em>cada</em> operador binario admite una <a href="mathematical-operations.html#man-dot-operators-1">versión de punto</a> que se puede aplicar a matrices (y combinaciones de matrices y escalares) en tales <a href="functions.html#man-vectorized-1">operaciones de retransmisión fusionadas</a>, por ejemplo, <code>z .== sin.(x. * y)</code>.</p><p>Tenga en cuenta que las comparaciones como <code>==</code> operan en arrays completos, dando un solo booleano como respuesta. Use operadores de punto como <code>.==</code> para comparaciones elemento a elemento. (Para operaciones de comparación como <code>&lt;</code>, <em>solo</em> la versión de elementos <code>.&lt;</code> es aplicable a las matrices).</p><p>También note la diferencia entre <code>max.(a, b)</code>, que retransmitir <a href="../stdlib/math.html#Base.max"><code>max()</code></a> elemento a elemento sobre <code>a</code> y<code>b</code>, y <code>maximum(a)</code>, que encuentra el mayor valor dentro de <code>a</code>. La misma relación se cumple para <code>min.(A, b)</code> y <code>minimum(a)</code>.</p><h3><a class="nav-anchor" id="broadcasting-1" href="#broadcasting-1">Retransmisión</a></h3><p>A veces es útil realizar operaciones binarias elemento por elemento en matrices de diferentes tamaños, como agregar un vector a cada columna de una matriz. Una forma ineficiente de hacer esto sería replicar el vector al tamaño de la matriz:</p><pre><code class="language-julia-repl">julia&gt; a = rand(2,1); A = rand(2,3);

julia&gt; repmat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846</code></pre><p>Esto es un desperdicio cuando las dimensiones son grandes, por lo que Julia ofrece <code>broadcast()</code>, que expande las dimensiones <em>singleton</em> en los argumentos array para hacer coincidir la dimensión correspondiente en el otro array sin usar memoria extra, y aplicar la función dada elemento a elemento:</p><pre><code class="language-julia-repl">julia&gt; broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia&gt; b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia&gt; broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631</code></pre><p><a href="mathematical-operations.html#man-dot-operators-1">Los operadores con punto</a> tales como <code>.+</code> y <code>.*</code> son equivalentes a llamadas a <code>broadcast</code> (excepto que se funden, como se describe a continuación). También hay una función <code>broadcast!()</code> para especificar un destino explícito (al que también se puede acceder por fusión mediante asignación <code>.=</code>), y funciones <a href="../stdlib/arrays.html#Base.Broadcast.broadcast_getindex"><code>broadcast_getindex()</code></a> y <code>broadcast_setindex!()</code> que retransmiten los índices antes de indexar. Además, <code>f. (Args ...)</code> es equivalente a <code>broadcast(f, args ...)</code>, proporcionando una sintaxis conveniente para retransmitir cualquier función (<a href="functions.html#man-vectorized-1">sintaxis punto</a>). &quot;Llamadas punto&quot; anidadas <code>f.(...)</code> (incluidas las llamadas a <code>.+</code> Etcétera) <a href="mathematical-operations.html#man-dot-operators-1">fusibles automáticamente</a> en una sola llamada <code>broadcast</code>.</p><p>Además, <code>broadcast()</code> no está limitado a los array (ver la documentación de la función), también maneja tuplas y trata cualquier argumento que no sea un array, tupla o <code>Ref</code> (excepto para<code>Ptr</code> ) como un &quot;escalar&quot;.</p><pre><code class="language-julia-repl">julia&gt; convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia&gt; ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia&gt; string.(1:3, &quot;. &quot;, [&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;])
3-element Array{String,1}:
 &quot;1. First&quot;
 &quot;2. Second&quot;
 &quot;3. Third&quot;</code></pre><h3><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h3><p>El tipo de matriz base en Julia es el tipo abstracto <code>AbstractArray {T, N}</code>. Este tipo está parametrizado por el número de dimensiones <code>N</code> y el tipo de elementos <code>T</code>. <code>AbstractVector</code> y <code>AbstractMatrix</code> son aliases para los casos 1-d y 2-d. Las operaciones en los objetos <code>AbstractArray</code> se definen usando operadores y funciones de alto nivel, de  manera que es independiente del almacenamiento subyacente. Estas operaciones generalmente funcionan correctamente como una alternativa para cualquier implementación de matriz específica.</p><p>El tipo <code>AbstractArray</code> incluye algo vagamente parecido a un array, y las implementaciones de este podrían ser bastante diferentes de los arrays convencionales. Por ejemplo, los elementos se pueden calcular a petición en lugar de ser almacenados. Sin embargo, cualquier tipo concreto de <code>AbstractArray{T, N}</code> debería implementar al menos <a href="../stdlib/arrays.html#Base.size"><code>size(A)</code></a> (que devolvería una tupla <code>Int</code>), <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex(A,i)</code></a> y <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex(A, i1, ..., iN)</code></a>; Los arrays mutables también deberían implementar <a href="../stdlib/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}"><code>setindex!()</code></a>. Se recomienda que estas operaciones tengan complejidad temporal casi constante, o técnicamente complejidad de orden 1 (Õ(1)), ya que de lo contrario algunas funciones podrían ser inesperadamente lentas. Los tipos concretos también deberían proporcionar un método <a href="../stdlib/arrays.html#Base.similar-Tuple{AbstractArray}"><code>similar(A,T=eltype(A),dims=size(A))</code></a>, que se utiliza para asignar un conjunto similar para <a href="../stdlib/base.html#Base.copy"><code>copy()</code></a> y otras operaciones de actualización. No importa cómo se represente internamente un <code>AbstractArray {T, N}</code>, <code>T</code> es el tipo de objeto devuelto por la indización entera (<code>A [1, ..., 1]</code>, cuando <code>A</code> no está vacío) y<code>N</code> debe ser la longitud de la tupla devuelta por <a href="../stdlib/arrays.html#Base.size"><code>size()</code></a>.</p><p><code>DenseArray</code> es un subtipo abstracto de<code>AbstractArray</code> que pretende incluir todos los arrays que están establecidos en bloques regulares de memoria y que, por tanto, se puede pasar a funciones externas C y Fortran que esperan este diseño de memoria. Los subtipos deberían proporcionar un método <a href="../stdlib/arrays.html#Base.stride"><code>stride(A,k)</code></a> que devuelve el &quot;paso&quot; de la dimensión <code>k</code>; incrementar el índice de dimensión <code>k</code> en <code>1</code> debería incremental el índice <code>i</code> de <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex(A,i)</code></a> en <a href="../stdlib/arrays.html#Base.stride"><code>stride(A,k)</code></a>. Si se proporciona un método de conversión de puntero <a href="../stdlib/c.html#Base.unsafe_convert"><code>Base.unsafe_convert(Ptr{T}, A)</code></a>, el diseño de la memoria debe corresponder de la misma manera a estos pasos.</p><p>El tipo <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a> es una instancia específica de <code>DenseArray</code> donde los elementos se almacenan en orden de columnas principales (consulte notas adicionales en <a href="performance-tips.html#man-performance-tips-1">Sugerencias de rendimiento</a>). <code>Vector</code> y <code>Matrix</code> son alias para los casos 1-d y 2-d. Las operaciones específicas como la indexación escalar, la asignación y algunas otras operaciones básicas específicas del almacenamiento son todas las que tienen que estar implementadas en  <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a>, de modo que el resto de la biblioteca de arrays puede implementarse de forma genérica.</p><p><code>SubArray</code> es una especialización de <code>AbstractArray</code> que realiza indexación por referencia en lugar de por copia. Un <code>SubArray</code> se crea con la función <a href="../stdlib/arrays.html#Base.view"><code>view()</code></a>, que es llamada de la misma manera que <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex()</code></a> (con una matriz y una serie de argumentos de índice) . El resultado de <a href="../stdlib/arrays.html#Base.view"><code>view()</code></a> se ve igual que el resultado de <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex()</code></a>, excepto que los datos se dejan en su lugar. <a href="../stdlib/arrays.html#Base.view"><code>view()</code></a> almacena los vectores de índice de entrada en un objeto <code>SubArray</code>, que luego puede usarse para indexar la matriz original de forma indirecta. Al colocar la macro <a href="../stdlib/arrays.html#Base.@views"><code>@views</code></a> delante de una expresión o bloque de código, cualquier segmento <code>array[...]</code> en esa expresión se convertirá para crear una vista <code>SubArray</code> en su lugar.</p><p><code>StridedVector</code> y<code>StridedMatrix</code> son alias convenientes definidos para que Julia pueda llamar a un rango más amplio de funciones BLAS y LAPACK pasándoles objetos <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a> o <code>SubArray</code>, y ahorrando así ineficiencias de asignación de memoria y copia.</p><p>El siguiente ejemplo calcula la descomposición QR de una pequeña sección de una matriz más grande, sin crear ningún array temporal, y llamando a la función LAPACK apropiada con los parámetros de tamaño de dimensión y salto correctos.</p><pre><code class="language-julia-repl">julia&gt; a = rand(10,10)
10×10 Array{Float64,2}:
 0.561255   0.226678   0.203391  0.308912   …  0.750307  0.235023   0.217964
 0.718915   0.537192   0.556946  0.996234      0.666232  0.509423   0.660788
 0.493501   0.0565622  0.118392  0.493498      0.262048  0.940693   0.252965
 0.0470779  0.736979   0.264822  0.228787      0.161441  0.897023   0.567641
 0.343935   0.32327    0.795673  0.452242      0.468819  0.628507   0.511528
 0.935597   0.991511   0.571297  0.74485    …  0.84589   0.178834   0.284413
 0.160706   0.672252   0.133158  0.65554       0.371826  0.770628   0.0531208
 0.306617   0.836126   0.301198  0.0224702     0.39344   0.0370205  0.536062
 0.890947   0.168877   0.32002   0.486136      0.096078  0.172048   0.77672
 0.507762   0.573567   0.220124  0.165816      0.211049  0.433277   0.539476

julia&gt; b = view(a, 2:2:8,2:2:4)
4×2 SubArray{Float64,2,Array{Float64,2},Tuple{StepRange{Int64,Int64},StepRange{Int64,Int64}},false}:
 0.537192  0.996234
 0.736979  0.228787
 0.991511  0.74485
 0.836126  0.0224702

julia&gt; (q,r) = qr(b);

julia&gt; q
4×2 Array{Float64,2}:
 -0.338809   0.78934
 -0.464815  -0.230274
 -0.625349   0.194538
 -0.527347  -0.534856

julia&gt; r
2×2 Array{Float64,2}:
 -1.58553  -0.921517
  0.0       0.866567</code></pre><h2><a class="nav-anchor" id="Vectores-y-Matrices-*Sparse*-1" href="#Vectores-y-Matrices-*Sparse*-1">Vectores y Matrices <em>Sparse</em></a></h2><p>Julia tiene soporte integrado para vectores y <a href="https://en.wikipedia.org/wiki/Sparse_matrix">matrices dispersas (<em>sparse</em>)</a>. Las matrices <em>sparse</em> son matrices que contienen suficientes ceros para almacenarlos en una estructura de datos especial que ahorra espacio y tiempo de ejecución, en comparación con las matrices densas.</p><h3><a class="nav-anchor" id="man-csc-1" href="#man-csc-1">Columna Comprimida <em>Sparse</em> (CSC) Para Almacenamiento de Matrices <em>Sparse</em></a></h3><p>En Julia, las matrices dispersas se almacenan en el formato <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29">Compressed Sparse Column (CSC)</a>. Las matrices <em>sparse</em> de Julia tienen el tipo <a href="../stdlib/arrays.html#Base.SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC{Tv,Ti}</code></a>, donde <code>Tv</code> es el tipo de los valores almacenados, y<code>Ti</code> es el tipo entero para almacenar punteros de columnas e índices de filas. La representación interna de <code>SparseMatrixCSC</code> es la siguiente:</p><pre><code class="language-julia">struct SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrix{Tv,Ti}
    m::Int                  # Number of rows
    n::Int                  # Number of columns
    colptr::Vector{Ti}      # Column i is in colptr[i]:(colptr[i+1]-1)
    rowval::Vector{Ti}      # Row indices of stored values
    nzval::Vector{Tv}       # Stored values, typically nonzeros
end</code></pre><p>El almacenamiento de columnas dispersas y comprimidas (CSC) facilita y agiliza el acceso a los elementos en la columna de una matriz <em>sparse</em>, mientras que el acceso a la matriz <em>sparse</em> por filas es considerablemente más lento. Las operaciones como la inserción de entradas previamente no almacenadas de una en una en la estructura de CSC tienden a ser lentas. Esto se debe a que todos los elementos de la matriz <em>sparse</em> que están más allá del punto de inserción deben moverse un lugar más.</p><p>Todas las operaciones en matrices <em>sparse</em> se implementan cuidadosamente para aprovechar la estructura de datos CSC para el rendimiento y para evitar operaciones costosas.</p><p>Si tiene datos en formato CSC desde una aplicación o biblioteca diferente, y desea importarlos a Julia, asegúrese de utilizar la indexación basada en 1. Los índices de fila en cada columna deben estar ordenados. Si su objeto <code>SparseMatrixCSC</code> contiene índices de filas sin ordenar, una forma rápida de ordenarlos es hacer una doble transposición.</p><p>En algunas aplicaciones, es conveniente almacenar valores cero explícitos en una <code>SparseMatrixCSC</code>. Estas <em>son</em> aceptadas por funciones en <code>Base</code> (pero no hay garantía de que se conservarán en las operaciones de mutación). Tales ceros explícitamente almacenados son tratados como no estructurales por muchas rutinas. La función <a href="../stdlib/arrays.html#Base.SparseArrays.nnz"><code>nnz()</code></a> devuelve la cantidad de elementos almacenados explícitamente en la estructura de datos dispersos, incluidos los no-ceros estructurales. Para contar el número exacto de nozeros numéricos, use <a href="../stdlib/arrays.html#Base.countnz"><code>countnz()</code></a>, que inspecciona todos los elementos almacenados en un a matriz <em>sparse</em>. <a href="../stdlib/arrays.html#Base.SparseArrays.dropzeros-Tuple{SparseMatrixCSC,Bool}"><code>dropzeros()</code></a>, y <a href="../stdlib/arrays.html#Base.SparseArrays.dropzeros!-Tuple{SparseMatrixCSC,Bool}"><code>dropzeros!()</code></a>, se puede usar para eliminar ceros almacenados de la matriz dispersa.</p><pre><code class="language-julia-repl">julia&gt; A = sparse([1, 2, 3], [1, 2, 3], [0, 2, 0])
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  0
  [2, 2]  =  2
  [3, 3]  =  0

julia&gt; dropzeros(A)
3×3 SparseMatrixCSC{Int64,Int64} with 1 stored entry:
  [2, 2]  =  2</code></pre><h3><a class="nav-anchor" id="Almacenamiento-de-Vectores-*Sparse*-1" href="#Almacenamiento-de-Vectores-*Sparse*-1">Almacenamiento de Vectores <em>Sparse</em></a></h3><p>Los vectores <em>sparse</em> se almacenan en un formato de columna análogo al que se usa en las matrices <em>sparse</em>. En Julia, los vectores <em>sparse</em> tienen el tipo <a href="../stdlib/arrays.html#Base.SparseArrays.SparseVector"><code>SparseVector{Tv,Ti}</code></a> donde <code>Tv</code> es el tipo de los valores almacenados y<code>Ti</code> el tipo entero para los índices. La representación interna es la siguiente:</p><pre><code class="language-julia">struct SparseVector{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}
    n::Int              # Length of the sparse vector
    nzind::Vector{Ti}   # Indices of stored values
    nzval::Vector{Tv}   # Stored values, typically nonzeros
end</code></pre><p>En cuanto a <a href="../stdlib/arrays.html#Base.SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>, el tipo <code>SparseVector</code> también puede contener ceros almacenados explícitamente. (Consulte <a href="arrays.html#man-csc-1">Almacenamiento de matriz <em>sparse</em></a>.).</p><h3><a class="nav-anchor" id="Constructores-de-Vectores-y-Matrices-*Sparse*-1" href="#Constructores-de-Vectores-y-Matrices-*Sparse*-1">Constructores de Vectores y Matrices <em>Sparse</em></a></h3><p>La forma más sencilla de crear matrices <em>sparse</em> es usar funciones equivalentes a las funciones <a href="../stdlib/arrays.html#Base.zeros"><code>zeros()</code></a> y <a href="../stdlib/arrays.html#Base.eye"><code>eye()</code></a> que proporciona Julia para trabajar con matrices densas. Para producir matrices <em>sparse</em> en su lugar, puede usar los mismos nombres con el prefijo <code>sp</code>:</p><pre><code class="language-julia-repl">julia&gt; spzeros(3)
3-element SparseVector{Float64,Int64} with 0 stored entries

julia&gt; speye(3,5)
3×5 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0</code></pre><p>La función <a href="../stdlib/arrays.html#Base.SparseArrays.sparse"><code>sparse()</code></a> suele ser una forma útil de construir arrays <em>sparse</em>. Por ejemplo, para construir una matriz <em>sparse</em>, podemos ingresar un vector <code>I</code> de índices de fila, un vector<code>J</code> de índices de columna, y un vector <code>V</code> de valores almacenados (esto también se conoce como <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">formato COO (coordenada)</a>). <code>sparse (I,J,V)</code> construye una matriz <em>sparse</em> tal que <code>S[I[k], J[k]] = V[k]</code>. El constructor de vector <em>sparse</em> equivalente es <a href="../stdlib/arrays.html#Base.SparseArrays.sparsevec"><code>sparsevec</code></a>, que toma el vector de índices (fila) <code>I</code> y el vector <code>V</code> con los valores almacenados y construye un vector <em>sparse</em> <code>R</code> tal que <code>R[I[k]] = V[k]</code>.</p><pre><code class="language-jldoctest">julia&gt; I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia&gt; S = sparse(I,J,V)
5×18 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1 ,  4]  =  1
  [4 ,  7]  =  2
  [5 ,  9]  =  3
  [3 , 18]  =  -5

julia&gt; R = sparsevec(I,V)
5-element SparseVector{Int64,Int64} with 4 stored entries:
  [1]  =  1
  [3]  =  -5
  [4]  =  2
  [5]  =  3</code></pre><p>La inversa de las funciones <a href="../stdlib/arrays.html#Base.SparseArrays.sparse"><code>sparse()</code></a> y <a href="../stdlib/arrays.html#Base.SparseArrays.sparsevec"><code>sparsevec</code></a> es <a href="../stdlib/arrays.html#Base.findnz"><code>findnz()</code></a>, que recupera las entradas utilizadas para crear el array <em>sparse</em>. También hay una función <a href="../stdlib/arrays.html#Base.findn"><code>findn</code></a> que solo devuelve los vectores índice.</p><pre><code class="language-jldoctest">julia&gt; findnz(S)
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia&gt; findn(S)
([1, 4, 5, 3], [4, 7, 9, 18])

julia&gt; findnz(R)
([1, 3, 4, 5], [1, -5, 2, 3])

julia&gt; findn(R)
4-element Array{Int64,1}:
 1
 3
 4
 5</code></pre><p>Otra forma de crear un array <em>sparse</em> es convertir un array denso en un array <em>sparse</em> usando la función <a href="../stdlib/arrays.html#Base.SparseArrays.sparse"><code>sparse()</code></a>:</p><pre><code class="language-julia-repl">julia&gt; sparse(eye(5))
5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  1.0
  [5, 5]  =  1.0

julia&gt; sparse([1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0</code></pre><p>Puede ir en la otra dirección usando el constructor <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a>. La función <a href="../stdlib/arrays.html#Base.SparseArrays.issparse"><code>issparse()</code></a> se puede usar para consultar si una matriz es o no <em>sparse</em>.</p><pre><code class="language-julia-repl">julia&gt; issparse(speye(5))
true</code></pre><h3><a class="nav-anchor" id="Operaciones-con-matrices-*sparse*-1" href="#Operaciones-con-matrices-*sparse*-1">Operaciones con matrices <em>sparse</em></a></h3><p>Las operaciones aritméticas en matrices <em>sparse</em> también funcionan como lo hacen en matrices densas. La indexación de, la asignación en y la concatenación de matrices <em>sparse</em> funcionan de la misma manera que las matrices densas. Las operaciones de indexación, especialmente la asignación, son costosas, cuando se llevan a cabo un elemento cada vez. En muchos casos, puede ser mejor convertir la matriz dispersa en formato <code>(I,J,V)</code> usando <a href="../stdlib/arrays.html#Base.findnz"><code>findnz()</code></a>, manipular los valores o la estructura en los vectores densos <code>(I,J,V)</code>, y luego reconstruir la matriz <em>sparse</em>.</p><h3><a class="nav-anchor" id="Correspondence-of-dense-and-sparse-methods-1" href="#Correspondence-of-dense-and-sparse-methods-1">Correspondence of dense and sparse methods</a></h3><p>La siguiente tabla proporciona una correspondencia entre los métodos incorporados en matrices <em>sparse</em> y sus métodos correspondientes en tipos de matrices densas. En general, los métodos que generan matrices <em>sparse</em> difieren de sus contrapartes densas en que la matriz resultante sigue el mismo patrón de dispersión que una matriz <em>sparse</em> dada <code>S</code>, o que la matriz <em>sparse</em> resultante tiene densidad <code>d</code>, es decir, cada elemento de matriz tiene una probabilidad <code>d</code> de ser diferente de cero.</p><p>Los detalles se pueden encontrar en la sección <a href="../stdlib/arrays.html#stdlib-sparse-arrays-1">Vectores y Matrices <em>Sparse</em></a> de la referencia de biblioteca estándar.</p><table><tr><th>Sparse</th><th>Dense</th><th>Description</th></tr><tr><td><a href="../stdlib/arrays.html#Base.SparseArrays.spzeros"><code>spzeros(m,n)</code></a></td><td><a href="../stdlib/arrays.html#Base.zeros"><code>zeros(m,n)</code></a></td><td>Creates a <em>m</em>-by-<em>n</em> matrix of zeros. (<a href="../stdlib/arrays.html#Base.SparseArrays.spzeros"><code>spzeros(m,n)</code></a> is empty.)</td></tr><tr><td><a href="../stdlib/arrays.html#Base.SparseArrays.spones"><code>spones(S)</code></a></td><td><a href="../stdlib/arrays.html#Base.ones"><code>ones(m,n)</code></a></td><td>Creates a matrix filled with ones. Unlike the dense version, <a href="../stdlib/arrays.html#Base.SparseArrays.spones"><code>spones()</code></a> has the same sparsity pattern as <em>S</em>.</td></tr><tr><td><a href="../stdlib/arrays.html#Base.SparseArrays.speye-Tuple{Type,Integer,Integer}"><code>speye(n)</code></a></td><td><a href="../stdlib/arrays.html#Base.eye"><code>eye(n)</code></a></td><td>Creates a <em>n</em>-by-<em>n</em> identity matrix.</td></tr><tr><td><a href="../stdlib/arrays.html#Base.full"><code>full(S)</code></a></td><td><a href="../stdlib/arrays.html#Base.SparseArrays.sparse"><code>sparse(A)</code></a></td><td>Interconverts between dense and sparse formats.</td></tr><tr><td><a href="../stdlib/arrays.html#Base.SparseArrays.sprand"><code>sprand(m,n,d)</code></a></td><td><a href="../stdlib/numbers.html#Base.Random.rand"><code>rand(m,n)</code></a></td><td>Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed uniformly on the half-open interval <span>$[0, 1)$</span>.</td></tr><tr><td><a href="../stdlib/arrays.html#Base.SparseArrays.sprandn"><code>sprandn(m,n,d)</code></a></td><td><a href="../stdlib/numbers.html#Base.Random.randn"><code>randn(m,n)</code></a></td><td>Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.</td></tr><tr><td><a href="../stdlib/arrays.html#Base.SparseArrays.sprandn"><code>sprandn(m,n,d,X)</code></a></td><td><a href="../stdlib/numbers.html#Base.Random.randn"><code>randn(m,n,X)</code></a></td><td>Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed according to the <em>X</em> distribution. (Requires the <code>Distributions</code> package.)</td></tr></table><footer><hr/><a class="previous" href="metaprogramming.html"><span class="direction">Previous</span><span class="title">Metaprogramación</span></a><a class="next" href="linear-algebra.html"><span class="direction">Next</span><span class="title">Álgebra Lineal</span></a></footer></article></body></html>
