<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Métodos · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Funciones</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="types.html">Tipos</a></li><li class="current"><a class="toctext" href="methods.html">Métodos</a><ul class="internal"><li><a class="toctext" href="#Definiendo-Métodos-1">Definiendo Métodos</a></li><li><a class="toctext" href="#man-ambiguities-1">Ambigüedades de Métodos</a></li><li><a class="toctext" href="#Métodos-paramétricos-1">Métodos paramétricos</a></li><li><a class="toctext" href="#Redefiniendo-Métodos-1">Redefiniendo Métodos</a></li><li><a class="toctext" href="#parametrically-constrained-varargs-methods-1">Parametrically-constrained Varargs methods</a></li><li><a class="toctext" href="#note-on-optional-and-keyword-arguments-1">Note on Optional and keyword Arguments</a></li><li><a class="toctext" href="#Funciones-como-objetos-1">Funciones como objetos</a></li><li><a class="toctext" href="#Funciones-Genéricas-Vacías-1">Funciones Genéricas Vacías</a></li><li><a class="toctext" href="#man-method-design-ambiguities-1">Diseño de métodos y evitación de ambigüedades</a></li></ul></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión y Promoción</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Comprobación de Límites</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="methods.html">Métodos</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/methods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Métodos</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="methods-1" href="#methods-1">Métodos</a></h1><p>Recordemos de la sección <a href="functions.html#man-functions-1">Funciones</a> que una función es un objeto que establece una correspondencia entre una tupla de argumentos y un valor de retorno o lanza una excepción si no puede devolverse el valor apropiado. Para la misma función conceptual es común soy implementada de una forma muy diferente para tipos de argumentos diferentes: sumar dos enteros es distinto de sumar dos valores en punto flotante y ambos son distintos de sumar un entero y 1 punto flotante. A pesar de las diferencias de implementación, éstas operaciones caen todas bajo el concepto general de &quot;suma&quot;. En consecuencia, en Julia, estos comportamientos pertenecen todos a un solo objeto: la función <code>+</code>.</p><p>Para facilitar el uso de muchas implementaciones distintas del mismo concepto suavemente, las funciones necesitan no ser definidas de una vez, sino poder ser definidas a trozos proporcionando comportamientos distintos para ciertas combinaciones de tipos de argumentos y cuentas. Llamamos <em>método</em> a la definición de un posible comportamiento para una función. Hasta ahora sólo se han presentado ejemplos de funciones definidas como sólo método, aplicables a todo tipo de argumentos. Sin embargo, las asignaturas de las definiciones de los métodos pueden anotarse para indicar los tipos de los argumentos además de su número, y puede proporcionarse más de una sola definición de método. Cuando una función se aplica a una dupla de argumentos particular, se aplica el método más específico y aplicable a esos argumentos. Por tanto, el comportamiento global de una función es un collage de los comportamientos de sus distintas definiciones de métodos. Si el collage está bien diseñado, incluso aunque las implementaciones de los métodos puedan ser bastante diferentes, el comportamiento exterior de la función pareciera contínuo y consistente.</p><p>La elección de qué método ejecutar cuando se aplica una función se llama <em>despacho</em>. Julia permite al proceso de despacho elegir qué método de una función llamar basándose en el número de argumentos y en los tipos de todos los argumentos dados a la función. Este mecanismo es diferente al que ocurre en los lenguajes orientados al objeto tradicionales, donde el despacho  se basa solo en el primer argumento, que frecuentemente tiene una sintaxis especial, y que es muchas veces implicado el lugar de ser escrito explícitamente como argumento. <a href="#footnote-1">[1]</a> Usar todos los argumentos de la función para elegir qué método debería ser invocado es conocido como <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">despacho múltiple</a>. El despacho múltiple es  particularmente útil para código matemático, donde  tiene poco sentido considerar que las operaciones pertenecen a un argumento más que los demás. Más allá de las operaciones matemáticas, sin embargo, el despacho múltiple ha resultado ser un paradigma potente y conveniente para estructurar y organizar los programas.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>En C++ o Java, por ejemplo, en una llamada a un método como <code>obj.meth(arg1,arg2)</code>, el objeto obj &quot;recibe&quot; la llamada al método y es pasado implícitamente vía la palabra clave <code>this</code>, en lugar de con un argumento de método explícito. Cuando el objeto <code>this</code> actual es el receptor de una llamada a método él puede ser omitido, escribiendo justo <code>meth(arg1,arg2)</code>, con <code>this</code> implícito como objeto receptor.</p></div><h2><a class="nav-anchor" id="Definiendo-Métodos-1" href="#Definiendo-Métodos-1">Definiendo Métodos</a></h2><p>En los ejemplos estudiados hasta ahora, sólo se han definido funciones con un único método que tienen argumentos con los tipos no restringidos. Estas funciones se comporta como las que hay en lenguajes con tipos dinámicos tradicionales. Sin embargo, también se han usado despacho múltiple y métodos sin ser consciente de ello: todas las funciones estándar y operadores de Julia, tal como función <code>+</code>, tiene muchos métodos que definen su comportamiento sobre varias combinaciones posibles número y tipo de argumentos.</p><p>Cuando se define una función, uno puede opcionalmente restringir los tipos de los parámetros sobre los que se aplica usando el operador de la selección de tipos <code>::</code>, introducido en la sección <a href="types.html#composite-types-1">Tipos compuestos</a>:</p><pre><code class="language-jldoctest">julia&gt; f(x::Float64, y::Float64) = 2x + y
f (generic function with 1 method)</code></pre><p>Esta definición de función se aplica sólo a llamadas en las que <code>x</code> e <code>y</code> sean ambos valores del tipo <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>:</p><pre><code class="language-jldoctest">julia&gt; f(2.0, 3.0)
7.0</code></pre><p>Aplicar esta definición a otros tipos de argumentos dará como resultado un <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a>:</p><pre><code class="language-jldoctest">julia&gt; f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia&gt; f(Float32(2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
Closest candidates are:
  f(!Matched::Float64, ::Float64) at none:1

julia&gt; f(2.0, &quot;3.0&quot;)
ERROR: MethodError: no method matching f(::Float64, ::String)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia&gt; f(&quot;2.0&quot;, &quot;3.0&quot;)
ERROR: MethodError: no method matching f(::String, ::String)</code></pre><p>Como puede comprobarse, los argumentos tienen que ser exactamente del tipo <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>. Otros tipos numéricos tales como <code>Float32</code> o <code>Int</code> no serán convertidos automáticamente en <code>Float64</code>. Algo parecido sucede con los datos <code>String</code>. Como el tipo <code>Float64</code> es un tipo concreto y los tipos concretos no pueden tener subclases en Julia, esta definición sólo puede aplicarse a argumentos que sean exactamente del tipo <code>Float64</code>. Esto puede ser útil en ocasiones, sin embargo, para escribir métodos más generales se hace uso de parámetros cuyos tipos sean abstractos:</p><pre><code class="language-jldoctest">julia&gt; f(x::Number, y::Number) = 2x - y
f (generic function with 2 methods)

julia&gt; f(2.0, 3)
1.0</code></pre><p>Esta definición de método se aplica a cualquier par de argumentos que sean instancias de  <a href="../stdlib/numbers.html#Core.Number"><code>Number</code></a>. Ellas no tienen que ser del mismo tipo, mientras que ambas sean valores numéricos. El problema de manejar tipos numéricos dispares se delega a las operaciones aritméticas en la expresión <code>2x - y</code>.</p><p>Para definir una función con múltiples métodos, uno simplemente define la función varías veces, con diferentes números de argumentos y tipos. La primera definición de método para la función crea el objeto función y las definiciones de métodos subsecuentes añaden nuevos métodos al objeto función existente. La definición de método más específica que case con el número los tipos de argumentos será la ejecutada cuando se aplique la función. Por tanto, las dos definiciones de métodos anteriores, considerados juntas, define el comportamiento de la función <code>f</code> sobre todos los padres de instancias del tipo abstracto <code>Number</code> (pero con un comportamiento específico para pares de valores <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>. Si uno de los argumentos es un valor en punto flotante de 64 bits, pero el otro no lo es, entonces el método <code>f(Float64,Float64)</code> no puede ser invocado y se utilizará el método más general <code>f(Number,Number)</code>:</p><pre><code class="language-jldoctest">julia&gt; f(2.0, 3.0)
7.0

julia&gt; f(2, 3.0)
1.0

julia&gt; f(2.0, 3)
1.0

julia&gt; f(2, 3)
1</code></pre><p>La definición <code>2x+y</code> sólo se usa en el primer caso, mientras que la definición <code>2x-y</code> se usa en los demás. Nunca se realiza conversión automática en los otros: todas las conversiones son no mágicas y completamente exlícitas. En la sección <a href="conversion-and-promotion.html#conversion-and-promotion-1">Conversión y promoción</a>, sin embargo, se muestra cómo las aplicaciones inteligentes de tecnología suficientemente avanzada pueden ser indistinguibles de la magia. <a href="#footnote-Clarke61">[Clarke61]</a></p><p>Para valores no numéricos, ,y para menores de dos argumentos, la función <code>f</code> permanece indefinida, y aplicándola se obtendrá como resultado un <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a>:</p><pre><code class="language-jldoctest">julia&gt; f(&quot;foo&quot;, 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
Closest candidates are:
  f(!Matched::Number, ::Number) at none:1

julia&gt; f()
ERROR: MethodError: no method matching f()
Closest candidates are:
  f(!Matched::Float64, !Matched::Float64) at none:1
  f(!Matched::Number, !Matched::Number) at none:1</code></pre><p>Puedes ver fácilmente que métodos existen para una función entrando el propio nombre del objeto en una sesión interactiva:</p><pre><code class="language-jldoctest">julia&gt; f
f (generic function with 2 methods)</code></pre><p>La salida nos dice que <code>f</code> es un objeto función con dos métodos. Para encontrar cuáles son las signaturas de esos métodos, utilizaremos la función <a href="../stdlib/base.html#Base.methods"><code>methods()</code></a>:</p><pre><code class="language-julia-repl">julia&gt; methods(f)
# 2 methods for generic function &quot;f&quot;:
f(x::Float64, y::Float64) in Main at none:1
f(x::Number, y::Number) in Main at none:1</code></pre><p>que muestra que <code>f</code> tiene dos métodos: uno que toma dos argumentos <code>Float64</code> y una que toma dos argumentos de tipo <code>Number</code>. También indica el fichero y el número de línea donde los métodos fueron definidos aunque, si los métodos fueron definidos en el REPL, se obtendrá <code>none:1</code>.</p><p>En ausencia de una declaración de tipo con  <code>::</code> el tipo de un parámetro de un método es <code>Any</code> por defecto, lo que significa que está sin restricciones ya que todos los valores en Julia son instancias del tipo abstracto <code>Any</code>. Por tanto, podemos definir un método atrapatodo para <code>f</code> tal como:</p><pre><code class="language-jldoctest">julia&gt; f(x,y) = println(&quot;Whoa there, Nelly.&quot;)
f (generic function with 3 methods)

julia&gt; f(&quot;foo&quot;, 1)
Whoa there, Nelly.</code></pre><p>Este atrapatodo es menos específico que cualquier otra posible definición de método para un par de valores de parámetros, por lo que sólo será llamada sobre pares de argumentos a los cuales no pueda aplicarse otra definición de método.</p><p>Aunque parece un concepto simple, el despacho múltiple sobre los tipos de valores es quizás la característica más potente y central del lenguaje Julia. Las operaciones del núcleo tienen típicamente docenas de metodos:</p><pre><code class="language-julia-repl">julia&gt; methods(+)
# 180 methods for generic function &quot;+&quot;:
+(x::Bool, z::Complex{Bool}) in Base at complex.jl:224
+(x::Bool, y::Bool) in Base at bool.jl:89
+(x::Bool) in Base at bool.jl:86
+(x::Bool, y::T) where T&lt;:AbstractFloat in Base at bool.jl:96
+(x::Bool, z::Complex) in Base at complex.jl:231
+(a::Float16, b::Float16) in Base at float.jl:372
+(x::Float32, y::Float32) in Base at float.jl:374
+(x::Float64, y::Float64) in Base at float.jl:375
+(z::Complex{Bool}, x::Bool) in Base at complex.jl:225
+(z::Complex{Bool}, x::Real) in Base at complex.jl:239
+(x::Char, y::Integer) in Base at char.jl:40
+(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:303
+(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:303
+(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:296
+(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:290
+(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:258
+(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:315
...
+(a, b, c, xs...) at operators.jl:119</code></pre><p>El despacho múltiple junto con el sistema de tipos paramétrico flexible dan a Julia su capacidad para expresar de forma abstract algoritmos de alto nivel desacoplados de los detalles de implementación, generando aún código eficiente y especializado para manejar cada caso en tiempo de ejecución.</p><h2><a class="nav-anchor" id="man-ambiguities-1" href="#man-ambiguities-1">Ambigüedades de Métodos</a></h2><p>Es posible definir un conjunto de métodos de función tales que no haya un método único más específico aplicable a alguna combinación de argumentos:</p><pre><code class="language-jldoctest">julia&gt; g(x::Float64, y) = 2x + y
g (generic function with 1 method)

julia&gt; g(x, y::Float64) = x + 2y
g (generic function with 2 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous.
[...]</code></pre><p>Aquí, la llamada <code>g(2.0, 3.0)</code> podría ser manejada por los métodos <code>g(Float64, Any)</code> o <code>g(Any, Float64)</code> y ninguno es más específico que el otro. En tales casos, Julia lanza un <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a> en lugar de elegir uno de los métodos arbitrariamente. Podemos obviar las ambigüedades de los métodos especificando un método apropiado para el caso intersección:</p><pre><code class="language-jldoctest">julia&gt; g(x::Float64, y::Float64) = 2x + 2y
g (generic function with 3 methods)

julia&gt; g(2.0, 3)
7.0

julia&gt; g(2, 3.0)
8.0

julia&gt; g(2.0, 3.0)
10.0</code></pre><p>Se recomienda que el método que suprime la ambigüedad sea definido primero, ya que en caso contrario la ambigüedad existe, transitoriamente, hasta que el método más especifico sea definido.</p><p>En casos ms complejos, resolver ambigüedades de métodos implica un cierto elemento de diseño; este tema se explorará <a href="methods.html#man-method-design-ambiguities-1">posteriormente</a>.</p><h2><a class="nav-anchor" id="Métodos-paramétricos-1" href="#Métodos-paramétricos-1">Métodos paramétricos</a></h2><p>Las definiciones de métodos pueden tener, opcionalmente, parámetros de tipo cualificando la signatura:</p><pre><code class="language-jldoctest">julia&gt; same_type(x::T, y::T) where {T} = true
same_type (generic function with 1 method)

julia&gt; same_type(x,y) = false
same_type (generic function with 2 methods)</code></pre><p>El primer método se aplica cuando ambos argumentos son del mismo tipo concreto, independientemente del tipo que sea, mientras que el segundo actúa como un atrapatodo, cubriendo todos los demás casos. Por tanto, en conjunto, esto define una función booleana que comprueba si dos argumentos son del mismo tipo:</p><pre><code class="language-jldoctest">julia&gt; same_type(1, 2)
true

julia&gt; same_type(1, 2.0)
false

julia&gt; same_type(1.0, 2.0)
true

julia&gt; same_type(&quot;foo&quot;, 2.0)
false

julia&gt; same_type(&quot;foo&quot;, &quot;bar&quot;)
true

julia&gt; same_type(Int32(1), Int64(2))
false</code></pre><p>Tales definiciones corresponden a métodos cuyas signaturas de tipo son tipos <code>UnionAll</code> (ver <a href="types.html#unionall-types-1">tipos UnionAll</a>).</p><p>Esta clase de definición del comportamiento de una función mediante despacho es bastante común (incluso idiomático) en Julia. Los métodos con parámetros de tipo no están restringidos a ser usados como los tipos de los parámetros: ellos pueden ser usados en cualquier parte donde un palo estaría en la signatura de la función o cuerpo de la función. He aquí un eemplo donde el parámetro de tipo del método <code>T</code> se sa como el parámetro de tipo al tipo paramétrico <code>Vector{T}</code> en la signatura del método:</p><pre><code class="language-julia-repl">julia&gt; myappend(v::Vector{T}, x::T) where {T} = [v..., x]
myappend (generic function with 1 method)

julia&gt; myappend([1,2,3],4)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1

julia&gt; myappend([1.0,2.0,3.0],4.0)
4-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0

julia&gt; myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1</code></pre><p>Como puedes ver, el tipo del elemento añadido tiene que corresponderse con el tipo de elemento del vector al que se está añadiendo, o se lanzará un <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a>.  En el siguiente ejemplo, el parámetro de tipo del método <code>T</code> se usa como valor de retorno:</p><pre><code class="language-julia-repl">julia&gt; mytypeof(x::T) where {T} = T
mytypeof (generic function with 1 method)

julia&gt; mytypeof(1)
Int64

julia&gt; mytypeof(1.0)
Float64</code></pre><p>Así como puedes poner restricciones de subtipo para los parámetros de tipo en declaraciones de tipo (ver <a href="types.html#parametric-types-1">Tipos Paramétricos</a>) también puedes restringir los parámetros de tipo de los métodos:</p><pre><code class="language-julia-repl">julia&gt; same_type_numeric(x::T, y::T) where {T&lt;:Number} = true
same_type_numeric (generic function with 1 method)

julia&gt; same_type_numeric(x::Number, y::Number) = false
same_type_numeric (generic function with 2 methods)

julia&gt; same_type_numeric(1, 2)
true

julia&gt; same_type_numeric(1, 2.0)
false

julia&gt; same_type_numeric(1.0, 2.0)
true

julia&gt; same_type_numeric(&quot;foo&quot;, 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
Closest candidates are:
  same_type_numeric(!Matched::T&lt;:Number, ::T&lt;:Number) where T&lt;:Number at none:1
  same_type_numeric(!Matched::Number, ::Number) at none:1

julia&gt; same_type_numeric(&quot;foo&quot;, &quot;bar&quot;)
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)

julia&gt; same_type_numeric(Int32(1), Int64(2))
false</code></pre><p>La función <code>same_type_numeric</code> se comporta como la función <code>same_type</code> descrita antes, pero sólo está definida para pares de números.</p><p>Los métodos paramétricos permiten la misma sintaxis que las expresiones <code>where</code> usadas para escribir tipos (ver <a href="types.html#unionall-types-1">tipos UnionAll</a>). </p><p>Si hay un único parámetro, las llaves que lo encierran (en <code>where {T}</code>) pueden ser omitidas, aunque suele ser preferible mantenerlas por claridad.</p><p>Los parámetros múltiples pueden ser separados con comas, por ejemplo <code>where {T, S&lt;:Real}</code>, o escritos usando <code>where</code> anidados, por ejemplo, <code>where S&lt;:Real where T</code>.</p><h2><a class="nav-anchor" id="Redefiniendo-Métodos-1" href="#Redefiniendo-Métodos-1">Redefiniendo Métodos</a></h2><p>Cuando se redefine un método o se añaden nuevos métodos, es importante comprender que estos cambios no tienen efecto inmediatamente. Esto es clave para la capacidad de Julia para inferir estáticamente y compilar código para ejecutar rápido, sin los trucos de JIT y sobrecargas usuales. De hecho, cualquier nueva definición de método no será visible al entorno de ejecución actual, incluyendo tareas e hilos (y cualquier otra función definida con <code>@generated</code>). Comencemos con un ejemplo para ver qué significa esto:</p><pre><code class="language-julia-repl">julia&gt; function tryeval()
           @eval newfun() = 1
           newfun()
       end
tryeval (generic function with 1 method)

julia&gt; tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.
Closest candidates are:
  newfun() at none:1 (method too new to be called from this world context.)
 in tryeval() at none:1
 ...

julia&gt; newfun()
1</code></pre><p>En este ejemplo, observe que la nueva definición para <code>newfun</code> ha sido creada, pero no puede ser llamada inmediatamente. El nuevo global es inmediatamente visible para la función <code>tryeval</code>, para que pueda escribir <code>return newfun</code> (sin paréntesis). ¡Pero ni usted ni ninguna de las personas que llama, ni las funciones a las que llama, etc. puede llamar a esta nueva definición de método!</p><p>Pero hay una excepción: las llamadas futuras a <code>newfun</code> <em>del REPL</em> funcionan como se esperaba, pudiendo tanto ver como invocar la nueva definición de<code>newfun</code>. Sin embargo, las futuras llamadas a <code>tryeval</code> continuarán viendo la definición de<code>newfun</code> tal como era <em>en la instrucción anterior en REPL</em>, y por lo tanto antes de esa llamada a <code>tryeval</code>.</p><p>Es posible que desee probar esto para ver cómo funciona.</p><p>La implementación de este comportamiento es un &quot;contador de edad mundial&quot;. Este valor monótonamente creciente rastrea cada operación de definición de método. Esto permite describir &quot;el conjunto de definiciones de métodos visibles para un entorno de tiempo de ejecución dado&quot; como un solo número, o &quot;edad mundial&quot;. También permite comparar los métodos disponibles en dos mundos simplemente comparando su valor ordinal. En el ejemplo anterior, vemos que el &quot;mundo actual&quot; (en el que existe el método <code>newfun()</code>) es uno mayor que el &quot;mundo de tiempo de ejecución&quot; local de la tarea que se corrigió cuando se inició la ejecución de <code>tryeval</code>.</p><p>A veces es necesario evitar esto (por ejemplo, si está implementando el REPL anterior). Afortunadamente, hay una solución fácil: llamar a la función usando <a href="../stdlib/base.html#Base.invokelatest"><code>Base.invokelatest</code></a>:</p><pre><code class="language-julia-repl">julia&gt; function tryeval2()
           @eval newfun2() = 2
           Base.invokelatest(newfun2)
       end
tryeval2 (generic function with 1 method)

julia&gt; tryeval2()
2</code></pre><p>Por último, echemos un vistazo a algunos ejemplos más complejos donde esta regla se pone en funcionamiento. Definamos una función <code>f(x)</code>, que inicialmente tiene un método:</p><pre><code class="language-jldoctest">julia&gt; f(x) = &quot;original definition&quot;
f (generic function with 1 method)</code></pre><p>Iniciamos algunas operaciones que usan <code>f(x)</code>:</p><pre><code class="language-jldoctest">julia&gt; g(x) = f(x)
g (generic function with 1 method)

julia&gt; t = @async f(wait()); yield();</code></pre><p>Ahora añadimos algunos métodos nuevos a <code>f(x)</code>:</p><pre><code class="language-jldoctest">julia&gt; f(x::Int) = &quot;definition for Int&quot;
f (generic function with 2 methods)

julia&gt; f(x::Type{Int}) = &quot;definition for Type{Int}&quot;
f (generic function with 3 methods)</code></pre><p>Compare cómo difieren estos resultados:</p><pre><code class="language-jldoctest">julia&gt; f(1)
&quot;definition for Int&quot;

julia&gt; g(1)
&quot;definition for Int&quot;

julia&gt; wait(schedule(t, 1))
&quot;original definition&quot;

julia&gt; t = @async f(wait()); yield();

julia&gt; wait(schedule(t, 1))
&quot;definition for Int&quot;</code></pre><h2><a class="nav-anchor" id="parametrically-constrained-varargs-methods-1" href="#parametrically-constrained-varargs-methods-1">Parametrically-constrained Varargs methods</a></h2><p>Los parámetros de función pueden también ser usados para restringir el número de argumentos que pueden ser proporcionados a una función &quot;varags&quot; (ver <a href="functions.html#vararg-functions-1">Funciones Vararg</a>).  La notación <code>Vararg{T,N}</code> se usa para indicar tal restricción. Por ejemplo:</p><pre><code class="language-julia-repl">julia&gt; bar(a,b,x::Vararg{Any,2}) = (a,b,x)
bar (generic function with 1 method)

julia&gt; bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1

julia&gt; bar(1,2,3,4)
(1, 2, (3, 4))

julia&gt; bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, ::Any) at none:1</code></pre><p>Más útilmente, es posible restringir métodos varargs mediante un parámetro. Por ejemplo:</p><pre><code class="language-julia">function getindex(A::AbstractArray{T,N}, indexes::Vararg{Number,N}) where {T,N}</code></pre><p>sería llamado sólo cuando el número de <code>indexes</code> se correspondiera con la dimensionalidad del array.</p><h2><a class="nav-anchor" id="note-on-optional-and-keyword-arguments-1" href="#note-on-optional-and-keyword-arguments-1">Note on Optional and keyword Arguments</a></h2><p>Como se menciona brevemente en <a href="functions.html#man-functions-1">Funciones</a>, los argumentos opcionales se implementan como sintaxis para múltiples definiciones de métodos. Por ejemplo, esta definición:</p><pre><code class="language-julia">f(a=1,b=2) = a+2b</code></pre><p>se traduce a los siguientes tres métodos:</p><pre><code class="language-julia">f(a,b) = a+2b
f(a) = f(a,2)
f() = f(1,2)</code></pre><p>Esto significa que llamar a <code>f()</code> es equivalente a llamar a <code>f(1,2)</code>. En este caso, el resultado es <code>5</code>, porque <code>f(1,2)</code> invoca el primer método de <code>f</code> anterior. Sin embargo, este no siempre es el caso. Si define un cuarto método que es más especializado para enteros:</p><pre><code class="language-julia">f(a::Int,b::Int) = a-2b</code></pre><p>entonces el resultado de ambos <code>f()</code> y <code>f(1,2)</code> es <code>-3</code>. En otras palabras, los argumentos opcionales están vinculados a una función, no a ningún método específico de esa función. Depende de los tipos de argumentos opcionales qué método se invoca. Cuando los argumentos opcionales se definen en términos de una variable global, el tipo de argumento opcional puede incluso cambiar en tiempo de ejecución.</p><p>Los argumentos de palabra clave se comportan de manera bastante diferente de los argumentos posicionales ordinarios. En particular, no participan en el envío del método. Los métodos se envían basados <em>únicamente en argumentos posicionales, con argumentos de palabra clave procesados</em> después de que se identifica el método de coincidencia.</p><h2><a class="nav-anchor" id="Funciones-como-objetos-1" href="#Funciones-como-objetos-1">Funciones como objetos</a></h2><p>Los métodos están asociados con tipos, por lo que es posible hacer algún objeto Julia arbitrario &quot;invocable&quot; añadiendo métoos a este tipo (tales objetos &quot;invocables&quot; son denominados en ocasiones &quot;functores&quot;). </p><p>Por ejemplo, podemos definir un tipo que almacena los coeficientes de un polinomio, pero que se comporta como una función que evalúa el polinomio:</p><pre><code class="language-jldoctest">julia&gt; struct Polynomial{R}
           coeffs::Vector{R}
       end

julia&gt; function (p::Polynomial)(x)
           v = p.coeffs[end]
           for i = (length(p.coeffs)-1):-1:1
               v = v*x + p.coeffs[i]
           end
           return v
       end</code></pre><p>Note que la función es especificada por el tipo en lugar de por el nombre. En el cuerpo de la función, <code>p</code> se referira´al objeto que fue llamado. Un <code>Polynomial</code> puede ser usado como sigue:</p><pre><code class="language-jldoctest">julia&gt; p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])

julia&gt; p(3)
931</code></pre><p>Este mecanismo es también la clave de cómo los constructores de tipo y cierres (funciones internas que se refieren al entorno que las rodea) funcionan en Julia, lo cual se discute <a href="constructors.html#constructors-and-conversion-1">después en el manual</a>.</p><h2><a class="nav-anchor" id="Funciones-Genéricas-Vacías-1" href="#Funciones-Genéricas-Vacías-1">Funciones Genéricas Vacías</a></h2><p>Ocasionalmente, es útil introducir una función genérica sin agregar métodos. Esto se puede usar para separar las definiciones de interfaz de las implementaciones. También se puede hacer con el fin de la documentación o la legibilidad del código. La sintaxis para esto es un bloque de <code>function</code> vacío sin una tupla de argumentos:</p><pre><code class="language-julia">function emptyfunc
end</code></pre><h2><a class="nav-anchor" id="man-method-design-ambiguities-1" href="#man-method-design-ambiguities-1">Diseño de métodos y evitación de ambigüedades</a></h2><p>El polimorfismo de los métodos de Julia es una de sus características más poderosas, pero explotar este poder puede plantear desafíos de diseño. En particular, en jerarquías de métodos más complejos no es raro que surjan <a href="methods.html#man-ambiguities-1">ambigüedades</a>.</p><p>Arriba se indicó que uno puede resolver ambigüedades como</p><pre><code class="language-julia">f(x, y::Int) = 1
f(x::Int, y) = 2</code></pre><p>definiendo un método</p><pre><code class="language-julia">f(x::Int, y::Int) = 3</code></pre><p>Ésta es a menudo la estrategia correcta; sin embargo, hay circunstancias en las que seguir este consejo a ciegas puede ser contraproducente. En particular, cuantos más métodos tenga una función genérica, más posibilidades habrá de ambigüedades. Cuando sus jerarquías de métodos se vuelven más complicadas que este simple ejemplo, puede valer la pena pensar cuidadosamente sobre estrategias alternativas.</p><p>A continuación, discutimos los desafíos particulares y algunas formas alternativas de resolver dichos problemas.</p><h3><a class="nav-anchor" id="Tuple-and-NTuple-arguments-1" href="#Tuple-and-NTuple-arguments-1">Tuple and NTuple arguments</a></h3><p>Los argumentos <code>Tuple</code> (y <code>NTuple</code>) presentan retos especiales. Por ejemplo,</p><pre><code class="language-julia">f(x::NTuple{N,Int}) where {N} = 1
f(x::NTuple{N,Float64}) where {N} = 2</code></pre><p>son ambiguos debido a la posibilidad de que <code>N == 0</code>: no hay elementos para determinar si se debe invocar a la variante<code>Int</code> o <code>Float64</code>. Para resolver la ambigüedad, un enfoque es definir un método para la tupla vacía:</p><pre><code class="language-julia">f(x::Tuple{}) = 3</code></pre><p>Alternativamente, para todos los métodos excepto uno podemos insistir en que hay al menos un elemento en la tupla:</p><pre><code class="language-julia">f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback
f(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64</code></pre><h3><a class="nav-anchor" id="man-methods-orthogonalize-1" href="#man-methods-orthogonalize-1">Orthogonalice su diseño</a></h3><p>Cuando tenga la tentación de despachar en dos o más argumentos, considere si una función de &quot;envoltura&quot; podría hacer un diseño más simple. Por ejemplo, en lugar de escribir múltiples variantes:</p><pre><code class="language-julia">f(x::A, y::A) = ...
f(x::A, y::B) = ...
f(x::B, y::A) = ...
f(x::B, y::B) = ...</code></pre><p>podría considerar definir</p><pre><code class="language-julia">f(x::A, y::A) = ...
f(x, y) = f(g(x), g(y))</code></pre><p>donde <code>g</code> convierte el argumento para escribir <code>A</code>. Esto es un ejemplo muy específico del principio más general de <a href="https://en.wikipedia.org/wiki/Orthogonality_(programming)">diseño ortogonal</a>, en el que los conceptos separados se alinean a métodos separados. Aquí, <code>g</code> muy probablemente necesitará una definición de repliegue</p><pre><code class="language-julia">g(x::A) = x</code></pre><p>Una estrategia relacionada explota <code>promote</code> para llevar <code>x</code> y <code>y</code> a un tipo común:</p><pre><code class="language-julia">f(x::T, y::T) where {T} = ...
f(x, y) = f(promote(x, y)...)</code></pre><p>Un riesgo de este diseño es la posibilidad de que si no hay un método de promoción adecuado para convertir <code>x</code> y <code>y</code> al mismo tipo, el segundo método se repetirá en sí mismo infinitamente y desencadenará un desbordamiento de la pila. La función no exportada <code>Base.promote_noncircular</code> se puede usar como alternativa; cuando la promoción falla, aún arrojará un error, pero uno que falla más rápido con un mensaje de error más específico.</p><h3><a class="nav-anchor" id="Despacho-en-un-argumento-a-la-vez-1" href="#Despacho-en-un-argumento-a-la-vez-1">Despacho en un argumento a la vez</a></h3><p>Si necesita despachar en múltiples argumentos, y hay muchos retrocesos con demasiadas combinaciones para que sea práctico definir todas las variantes posibles, entonces considere introducir una &quot;cascada de nombres&quot; donde (por ejemplo) despache en el primer argumento y luego llame un método interno:</p><pre><code class="language-julia">f(x::A, y) = _fA(x, y)
f(x::B, y) = _fB(x, y)</code></pre><p>Entonces los métodos internos <code>_fA</code> y <code>_fB</code> pueden enviarse en <code>y</code> sin preocuparse por las ambigüedades entre sí con respecto a <code>x</code>.</p><p>Tenga en cuenta que esta estrategia tiene al menos una desventaja importante: en muchos casos, no es posible para los usuarios personalizar aún más el comportamiento de <code>f</code> definiendo más especializaciones de su función <code>f</code> exportada. En su lugar, tienen que definir especializaciones para sus métodos internos <code>_fA</code> y <code>_fB</code>, y esto borra las líneas entre los métodos exportados e internos.</p><h3><a class="nav-anchor" id="Contenedores-abstractos-y-tipos-de-elementos-1" href="#Contenedores-abstractos-y-tipos-de-elementos-1">Contenedores abstractos y tipos de elementos</a></h3><p>Donde sea posible, trate de evitar definir los métodos que se despachan en tipos de elementos específicos de contenedores abstractos. Por ejemplo,</p><pre><code class="language-julia">-(A::AbstractArray{T}, b::Date) where {T&lt;:Date}</code></pre><p>genera ambigüedades para cualquiera que defina un método</p><pre><code class="language-julia">-(A::MyArrayType{T}, b::T) where {T}</code></pre><p>El mejor enfoque es evitar definir <em>cualquiera</em> de estos métodos: en su lugar, confíe en un método genérico <code>-(A::AbstractArray, b)</code> y haga Asegúrese de que este método se implemente con llamadas genéricas (como <code>similar</code> y <code>-</code>) que hacen lo correcto para cada tipo de contenedor y tipo de elemento <em>por separado</em>. Esta es solo una variante más compleja de los consejos para <a href="methods.html#man-methods-orthogonalize-1">ortogonalize</a> sus métodos.</p><p>Cuando este enfoque no es posible, puede valer la pena comenzar un discusión con otros desarrolladores sobre la resolución de la ambigüedad; sólo porque un método se definió primero no necesariamente significa que no puede ser modificado o eliminado Como último recurso, un desarrollador puede definir el método &quot;tirita&quot;</p><pre><code class="language-julia">-(A::MyArrayType{T}, b::Date) where {T&lt;:Date} = ...</code></pre><p>eso resuelve la ambigüedad por la fuerza bruta.</p><h3><a class="nav-anchor" id="Método-complejo-&quot;cascadas&quot;-con-argumentos-predeterminados-1" href="#Método-complejo-&quot;cascadas&quot;-con-argumentos-predeterminados-1">Método complejo &quot;cascadas&quot; con argumentos predeterminados</a></h3><p>Si está definiendo un método &quot;cascada&quot; que suministra valores predeterminados, sea cuidado al eliminar cualquier argumento que corresponda al potencial por defecto. Por ejemplo, supongamos que estás escribiendo un filtro digital algoritmo y usted tiene un método que maneja los bordes de la señal mediante la aplicación de relleno:</p><pre><code class="language-julia">function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel)  # now perform the &quot;real&quot; computation
end</code></pre><p>Esto entrará en conflicto con un método que proporciona relleno predeterminado:</p><pre><code class="language-julia">myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default</code></pre><p>Juntos, estos dos métodos generan una recursión infinita con &#39;A&#39; creciendo cada vez más.</p><p>El mejor diseño sería definir su jerarquía de llamadas de esta manera:</p><pre><code class="language-julia">struct NoPad end  # indicate that no padding is desired, or that it&#39;s already applied

myfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions

function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions
end

# other padding methods go here

function myfilter(A, kernel, ::NoPad)
    # Here&#39;s the &quot;real&quot; implementation of the core computation
end</code></pre><p><code>NoPad</code> se proporciona en la misma posición de argumento que cualquier otro tipo de relleno, por lo que mantiene la jerarquía de despacho bien organizada y con menor probabilidad de ambigüedades. Además, amplía lo &quot;público&quot;interfaz <code>myfilter</code>: un usuario que quiere controlar el relleno explícitamente puede llamar a la variante <code>NoPad</code> directamente.</p><div class="footnote" id="footnote-Clarke61"><a href="#footnote-Clarke61"><strong>[Clarke61]</strong></a><p>Arthur C. Clarke, <em>Profiles of the Future</em> (1961): Clarke&#39;s Third Law.</p></div><footer><hr/><a class="previous" href="types.html"><span class="direction">Previous</span><span class="title">Tipos</span></a><a class="next" href="constructors.html"><span class="direction">Next</span><span class="title">Constructores</span></a></footer></article></body></html>
