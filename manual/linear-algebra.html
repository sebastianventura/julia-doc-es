<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Álgebra Lineal · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Funciones</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="types.html">Tipos</a></li><li><a class="toctext" href="methods.html">Métodos</a></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión y Promoción</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li class="current"><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a><ul class="internal"><li><a class="toctext" href="#Matrices-Especiales-1">Matrices Especiales</a></li><li><a class="toctext" href="#man-linalg-factorizations-1">Factorizaciones de matrices</a></li></ul></li><li><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Comprobación de Límites</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="linear-algebra.html">Álgebra Lineal</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/linear-algebra.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Álgebra Lineal</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="linear-algebra-1" href="#linear-algebra-1">Álgebra Lineal</a></h1><p>Además de (y como parte de) su soporte a los arrays multidimensionales, Julia proporciona implementaciones nativas de muchas operaciones de álgebra lineal comunes y útiles. Las operaciones básicas tales como la traza (<a href="../stdlib/linalg.html#Base.LinAlg.trace"><code>trace</code></a>), el determinante (<a href="../stdlib/linalg.html#Base.LinAlg.det"><code>det</code></a>) y la inversa (<a href="../stdlib/linalg.html#Base.inv"><code>inv</code></a>) están todas soportadas:</p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 4 1 6; 7 8 1]
3×3 Array{Int64,2}:
 1  2  3
 4  1  6
 7  8  1

julia&gt; trace(A)
3

julia&gt; det(A)
104.0

julia&gt; inv(A)
3×3 Array{Float64,2}:
 -0.451923   0.211538    0.0865385
  0.365385  -0.192308    0.0576923
  0.240385   0.0576923  -0.0673077</code></pre><p>Así como otras operaciones útiles, como buscar autovalores o autovectores:</p><pre><code class="language-julia-repl">julia&gt; A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia&gt; eigvals(A)
3-element Array{Complex{Float64},1}:
  9.31908+0.0im
 -2.40954+2.72095im
 -2.40954-2.72095im

julia&gt; eigvecs(A)
3×3 Array{Complex{Float64},2}:
 -0.488645+0.0im  0.182546-0.39813im   0.182546+0.39813im
 -0.540358+0.0im  0.692926+0.0im       0.692926-0.0im
   0.68501+0.0im  0.254058-0.513301im  0.254058+0.513301im</code></pre><p>Además, Julia proporciona muchas <a href="linear-algebra.html#man-linalg-factorizations-1">factorizaciones</a> que pueden usarse para acelerar problemas como la resolución lineal o la exponenciación de matrices mediante la pre-factorización de una matriz en una forma más adecuada (por razones de rendimiento o memoria) ) al problema. Consulte la documentación en <a href="../stdlib/linalg.html#Base.LinAlg.factorize"><code>factorize</code></a> para obtener más información. Como ejemplo:</p><pre><code class="language-julia-repl">julia&gt; A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia&gt; factorize(A)
Base.LinAlg.LU{Float64,Array{Float64,2}} with factors L and U:
[1.0 0.0 0.0; -0.15 1.0 0.0; -0.3 -0.132196 1.0]
[-10.0 2.3 4.0; 0.0 2.345 -3.4; 0.0 0.0 -5.24947]</code></pre><p>Como <code>A</code> no es hermítica, simétrica, triangular o bidiagonal, una factorización LU puede ser lo mejor que podemos hacer. Compara con:</p><pre><code class="language-julia-repl">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; factorize(B)
Base.LinAlg.BunchKaufman{Float64,Array{Float64,2}}([-1.64286 0.142857 -0.8; 2.0 -2.8 -0.6; -4.0 -3.0 5.0], [1, 2, 3], &#39;U&#39;, true, false, 0)</code></pre><p>Aquí, Julia fue capaz de detectar que <code>B</code> es de hecho simetrica, y usa una factorizacíon más apropiada. Frecuentemente es posible escribir código ms eficiente para una matriz de la que se conocen ciertas propiedades como que sea simétrica o diagonal. Julia proporciona algunos tipos especiales para que uno pueda &quot;etiquetar&quot; las matrices que tengan estas propiedades. Por ejemplo:</p><pre><code class="language-julia-repl">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0</code></pre><p><code>sB</code> ha sido etiquetada como una matriz que es simétrica (real) por lo que para algunas operacioneas que podríamos hacer sobre ella, tal como la autofactorización o calbular productos matriz-vector, pueden encontrarse eficiencias sólo referenciando la mitad de ella. Por ejemplo:</p><pre><code class="language-julia-repl">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; x = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; sB\x
3-element Array{Float64,1}:
 -1.73913
 -1.1087
 -1.45652</code></pre><p>La operación <code>\</code> realiza aquí la resolución de la ecuación lineal. El analizador sintáctico de Julia proporciona un despacho conveniente para métodos especializados para la <em>transpuesta</em> de una matriz o una matriz dividida por la izquierda por un vector, o para las distintas combinaciones u operacioneas de transposición en soluciones matriz-matriz. Muchas de ellas son incluso más especializadas para ciertos tipos especiales de matrices. Por ejemplo, <code>A\B</code> acabará llamando a <a href="../stdlib/linalg.html#Base.LinAlg.A_ldiv_B!"><code>Base.LinAlg.A_ldiv_B!</code></a> mientras que <code>A&#39;\B</code> acabará llamando a <a href="../stdlib/linalg.html#Base.Ac_ldiv_B"><code>Base.LinAlg.Ac_ldiv_B</code></a>, incluso aunque usáramos el mismo operador de división por la izquierda. Esto funcionea también para matrices: <code>A.&#39;\B.&#39;</code> invocará a <a href="../stdlib/linalg.html#Base.At_ldiv_Bt"><code>Base.LinAlg.At_ldiv_Bt</code></a>. El operador de división por la izquierda es muy potente y es fácil escribir código compacto y bastante legible para resolver todo tipo de sistemas de ecuaciones lineales.</p><h2><a class="nav-anchor" id="Matrices-Especiales-1" href="#Matrices-Especiales-1">Matrices Especiales</a></h2><p><a href="http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=3274">Las matrices con simetrías y estructuras especiales</a> surgen a menudo en el álgebra lineal y frecuentemente se asocian con varias factorizaciones matriciales. Julia presenta una rica colección de tipos de matrices especiales, que permiten un cálculo rápido con rutinas especializadas que están especialmente desarrolladas para estos tipos particuales de matrices.</p><p>Las siguientes tablas resumen los tipos de matrices especiales que se han implementado en Julia, así como si están disponibles ganchos para varios métodos optimizados para ellos en LAPACK.</p><table><tr><th>Type</th><th>Description</th></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Hermitian"><code>Hermitian</code></a>      </td><td><a href="https://en.wikipedia.org/wiki/Hermitian_matrix">Matriz hermítica</a>              </td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.UpperTriangular"><code>UpperTriangular</code></a></td><td><a href="https://en.wikipedia.org/wiki/Triangular_matrix">Matriz triangular</a> superior</td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.LowerTriangular"><code>LowerTriangular</code></a></td><td><a href="https://en.wikipedia.org/wiki/Triangular_matrix">Matriz triangular</a> inferior</td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Tridiagonal"><code>Tridiagonal</code></a></td><td><a href="https://en.wikipedia.org/wiki/Tridiagonal_matrix">Matriz tridiagonal</a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.SymTridiagonal"><code>SymTridiagonal</code></a></td><td>Matriz tridiagonal simétrica                                                    </td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Bidiagonal"><code>Bidiagonal</code></a></td><td><a href="https://en.wikipedia.org/wiki/Bidiagonal_matrix">Matriz bidiagonal</a> superior/inferior</td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Diagonal"><code>Diagonal</code></a></td><td><a href="https://en.wikipedia.org/wiki/Diagonal_matrix">Matriz diagonal</a></td></tr><tr><td><code>UniformScaling</code></td><td><a href="https://en.wikipedia.org/wiki/Uniform_scaling">Operador escalado uniforme</a></td></tr></table><h3><a class="nav-anchor" id="Operaciones-elementales-1" href="#Operaciones-elementales-1">Operaciones elementales</a></h3><table><tr><th>Tipo de matriz          </th><th><code>+</code></th><th><code>-</code></th><th><code>*</code></th><th><code>\</code></th><th>Otras funciones con métodos optimizados                            </th></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Hermitian"><code>Hermitian</code></a></td><td> </td><td> </td><td> </td><td>MV</td><td><a href="../stdlib/linalg.html#Base.inv"><code>inv()</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.sqrtm"><code>sqrtm()</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.expm"><code>expm()</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.UpperTriangular"><code>UpperTriangular</code></a></td><td> </td><td> </td><td>MV</td><td>MV</td><td><a href="../stdlib/linalg.html#Base.inv"><code>inv()</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.det"><code>det()</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.LowerTriangular"><code>LowerTriangular</code></a></td><td> </td><td> </td><td>MV</td><td>MV</td><td><a href="../stdlib/linalg.html#Base.inv"><code>inv()</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.det"><code>det()</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.SymTridiagonal"><code>SymTridiagonal</code></a></td><td>M</td><td>M</td><td>MS</td><td>MV</td><td><a href="../stdlib/linalg.html#Base.LinAlg.eigmax"><code>eigmax()</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.eigmin"><code>eigmin()</code></a></td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Tridiagonal"><code>Tridiagonal</code></a></td><td>M</td><td>M</td><td>MS</td><td>MV</td><td> </td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Bidiagonal"><code>Bidiagonal</code></a></td><td>M</td><td>M</td><td>MS</td><td>MV</td><td> </td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Diagonal"><code>Diagonal</code></a></td><td>M</td><td>M</td><td>MV</td><td>MV</td><td><a href="../stdlib/linalg.html#Base.inv"><code>inv()</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.det"><code>det()</code></a>, <a href="../stdlib/linalg.html#Base.LinAlg.logdet"><code>logdet()</code></a>, <a href="../stdlib/math.html#Base.:/"><code>/()</code></a></td></tr><tr><td><code>UniformScaling</code></td><td>M</td><td>M</td><td>MVS</td><td>MVS</td><td><a href="../stdlib/math.html#Base.:/"><code>/()</code></a></td></tr></table><p>Legend:</p><table><tr><th>Clave    </th><th>Descripción                                                  </th></tr><tr><td>M (matrix)</td><td>An optimized method for matrix-matrix operations is available</td></tr><tr><td>V (vector)</td><td>An optimized method for matrix-vector operations is available</td></tr><tr><td>S (scalar)</td><td>An optimized method for matrix-scalar operations is available</td></tr></table><h3><a class="nav-anchor" id="Factorizaciones-de-matrices-1" href="#Factorizaciones-de-matrices-1">Factorizaciones de matrices</a></h3><table><tr><th>Matrix type</th><th>LAPACK</th><th><a href="../stdlib/linalg.html#Base.LinAlg.eig"><code>eig()</code></a></th><th><a href="../stdlib/linalg.html#Base.LinAlg.eigvals"><code>eigvals()</code></a></th><th><a href="../stdlib/linalg.html#Base.LinAlg.eigvecs"><code>eigvecs()</code></a></th><th><a href="../stdlib/linalg.html#Base.LinAlg.svd"><code>svd()</code></a></th><th><a href="../stdlib/linalg.html#Base.LinAlg.svdvals"><code>svdvals()</code></a></th></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Hermitian"><code>Hermitian</code></a></td><td>HE</td><td> </td><td>ARI</td><td> </td><td> </td><td> </td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.UpperTriangular"><code>UpperTriangular</code></a></td><td>TR</td><td>A</td><td>A</td><td>A</td><td> </td><td> </td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.LowerTriangular"><code>LowerTriangular</code></a></td><td>TR</td><td>A</td><td>A</td><td>A</td><td> </td><td> </td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.SymTridiagonal"><code>SymTridiagonal</code></a></td><td>ST</td><td>A</td><td>ARI</td><td>AV</td><td> </td><td> </td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Tridiagonal"><code>Tridiagonal</code></a></td><td>GT</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Bidiagonal"><code>Bidiagonal</code></a></td><td>BD</td><td> </td><td> </td><td> </td><td>A</td><td>A</td></tr><tr><td><a href="../stdlib/linalg.html#Base.LinAlg.Diagonal"><code>Diagonal</code></a></td><td>DI</td><td> </td><td>A</td><td> </td><td> </td><td> </td></tr></table><p>Legend:</p><table><tr><th>Key</th><th>Description</th><th>Example</th></tr><tr><td>A (all)</td><td>An optimized method to find all the characteristic values and/or vectors is available</td><td>e.g. <code>eigvals(M)</code></td></tr><tr><td>R (range)</td><td>An optimized method to find the <code>il</code>th through the <code>ih</code>th characteristic values are available</td><td><code>eigvals(M, il, ih)</code></td></tr><tr><td>I (interval)</td><td>An optimized method to find the characteristic values in the interval [<code>vl</code>, <code>vh</code>] is available</td><td><code>eigvals(M, vl, vh)</code></td></tr><tr><td>V (vectors)</td><td>An optimized method to find the characteristic vectors corresponding to the characteristic values <code>x=[x1, x2,...]</code> is available</td><td><code>eigvecs(M, x)</code></td></tr></table><h3><a class="nav-anchor" id="El-operador-de-escalado-uniforme-1" href="#El-operador-de-escalado-uniforme-1">El operador de escalado uniforme</a></h3><p>Un operador <code>UniformScaling</code> representa un escalar multiplicado por el operador de identidad, <code>λ*I</code>. El operador de identidad <code>I</code> se define como una constante y es una instancia de <code>UniformScaling</code>. El tamaño de estos operadores es genérico y coincide con la otra matriz en las operaciones binarias <a href="../stdlib/math.html#Base.:+"><code>+</code></a>, <a href="../stdlib/math.html#Base.:--Tuple{Any}"><code>-</code></a>, <a href="../stdlib/strings.html#Base.:*-Tuple{AbstractString,Vararg{Any,N} where N}"><code>*</code></a> y <a href="../stdlib/linalg.html#Base.:\\-Tuple{AbstractArray,Any}"><code>\</code></a>. Para <code>A+I</code> y<code>A-I</code> esto significa que <code>A</code> debe ser cuadrado. La multiplicación con el operador de identidad <code>I</code> es un <em>noop</em> (excepto para comprobar que el factor de escala es uno) y, por lo tanto, casi sin sobrecarga.</p><h2><a class="nav-anchor" id="man-linalg-factorizations-1" href="#man-linalg-factorizations-1">Factorizaciones de matrices</a></h2><p><a href="https://en.wikipedia.org/wiki/Matrix_decomposition">las factorizaciones de matrices (a.k.a. descomposiciones de matrices)</a> calculan la factorizacin de una matriz en un producto de matrices, y son uno de los conceptos centrales del álgebra lineal.</p><p>La siguiente tabla resume los tipos de factorizaciones de matrices que han sido implementados en Julia. En la sección <a href="../stdlib/linalg.html#lib-linear-algebra-1">Linear Algebra</a> de la documentación de la librería estándar pueden encontrarse más detalles de los métodos asociados.</p><table><tr><th>Type</th><th>Description</th></tr><tr><td><code>Cholesky</code></td><td><a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky factorization</a></td></tr><tr><td><code>CholeskyPivoted</code></td><td><a href="https://en.wikipedia.org/wiki/Pivot_element">Pivoted</a> Cholesky factorization</td></tr><tr><td><code>LU</code></td><td><a href="https://en.wikipedia.org/wiki/LU_decomposition">LU factorization</a></td></tr><tr><td><code>LUTridiagonal</code></td><td>LU factorization for <a href="../stdlib/linalg.html#Base.LinAlg.Tridiagonal"><code>Tridiagonal</code></a> matrices</td></tr><tr><td><code>UmfpackLU</code></td><td>LU factorization for sparse matrices (computed by UMFPack)</td></tr><tr><td><code>QR</code></td><td><a href="https://en.wikipedia.org/wiki/QR_decomposition">QR factorization</a></td></tr><tr><td><code>QRCompactWY</code></td><td>Compact WY form of the QR factorization</td></tr><tr><td><code>QRPivoted</code></td><td>Pivoted <a href="https://en.wikipedia.org/wiki/QR_decomposition">QR factorization</a></td></tr><tr><td><code>Hessenberg</code></td><td><a href="http://mathworld.wolfram.com/HessenbergDecomposition.html">Hessenberg decomposition</a></td></tr><tr><td><code>Eigen</code></td><td><a href="https://en.wikipedia.org/wiki/Eigendecomposition_(matrix)">Spectral decomposition</a></td></tr><tr><td><code>SVD</code></td><td><a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">Singular value decomposition</a></td></tr><tr><td><code>GeneralizedSVD</code></td><td><a href="https://en.wikipedia.org/wiki/Generalized_singular_value_decomposition#Higher_order_version">Generalized SVD</a></td></tr></table><footer><hr/><a class="previous" href="arrays.html"><span class="direction">Previous</span><span class="title">Arrays Multi-dimensionales</span></a><a class="next" href="networking-and-streams.html"><span class="direction">Next</span><span class="title">Redes y Flujos</span></a></footer></article></body></html>
