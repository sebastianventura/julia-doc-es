<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guía de Estilo · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Funciones</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="types.html">Tipos</a></li><li><a class="toctext" href="methods.html">Métodos</a></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión y Promoción</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li class="current"><a class="toctext" href="style-guide.html">Guía de Estilo</a><ul class="internal"><li><a class="toctext" href="#Escribe-funciones,-no-sólo-*scripts*-1">Escribe funciones, no sólo <em>scripts</em></a></li><li><a class="toctext" href="#Evita-escribir-tipos-demasiado-específicos-1">Evita escribir tipos demasiado específicos</a></li><li><a class="toctext" href="#Manejar-el-exceso-de-diversidad-de-argumentos-en-el-&quot;código-llamador&quot;-1">Manejar el exceso de diversidad de argumentos en el &quot;código llamador&quot;</a></li><li><a class="toctext" href="#Añadir-!-para-los-nombres-de-funciones-que-modifican-sus-argumentos-1">Añadir <code>!</code> para los nombres de funciones que modifican sus argumentos</a></li><li><a class="toctext" href="#Evitar-tipos-Union-extraños-1">Evitar tipos <code>Union</code> extraños</a></li><li><a class="toctext" href="#Evitar-las-Uniones-de-tipos-en-campos-1">Evitar las Uniones de tipos en campos</a></li><li><a class="toctext" href="#Evitar-elaborar-tipos-contenedor-1">Evitar elaborar tipos contenedor</a></li><li><a class="toctext" href="#Usar-convenciones-de-nombrado-consistentes-con-el-paquete-base/-de-Julia-1">Usar convenciones de nombrado consistentes con el paquete <code>base/</code> de Julia</a></li><li><a class="toctext" href="#No-usar-demasiado-try-catch-1">No usar demasiado try-catch</a></li><li><a class="toctext" href="#No-meter-entre-paréntesis-las-condiciones-1">No meter entre paréntesis las condiciones</a></li><li><a class="toctext" href="#No-usar-demasiado-...-1">No usar demasiado <code>...</code></a></li><li><a class="toctext" href="#No-usar-parámetros-estáticos-innecesarios-1">No usar parámetros estáticos innecesarios</a></li><li><a class="toctext" href="#Evitar-la-confusion-sobre-si-algo-es-una-instancia-o-un-tipo-1">Evitar la confusion sobre si algo es una instancia o un tipo</a></li><li><a class="toctext" href="#No-abusar-de-las-macros-1">No abusar de las macros</a></li><li><a class="toctext" href="#No-exponer-operaciones-inseguras-al-nivel-de-interfaz-1">No exponer operaciones inseguras al nivel de interfaz</a></li><li><a class="toctext" href="#No-sobrecargar-métodos-de-tipos-de-contenedores-base-1">No sobrecargar métodos de tipos de contenedores base</a></li><li><a class="toctext" href="#Evitar-la-piratería-de-tipos-1">Evitar la piratería de tipos</a></li><li><a class="toctext" href="#Ser-cuidadoso-con-la-igualdad-de-tipos-1">Ser cuidadoso con la igualdad de tipos</a></li><li><a class="toctext" href="#No-escribir-x-f(x)-1">No escribir <code>x-&gt;f(x)</code></a></li><li><a class="toctext" href="#Evitar-usar-floats-para-literales-numericos-en-codigo-generico-cuando-sea-posible-1">Evitar usar floats para literales numericos en codigo generico cuando sea posible</a></li></ul></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="style-guide.html">Guía de Estilo</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/style-guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Guía de Estilo</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="style-guide-1" href="#style-guide-1">Guía de Estilo</a></h1><p>Las siguientes secciones explican unos cuantos aspectos del estilo de codificación idiomático de Julia. Ninguna de estas reglas son absolutas; sólo son sugerencias para ayudar a familiarizarte con el lenguaje y ayudarte a elegir entre diseños alternativos.</p><h2><a class="nav-anchor" id="Escribe-funciones,-no-sólo-*scripts*-1" href="#Escribe-funciones,-no-sólo-*scripts*-1">Escribe funciones, no sólo <em>scripts</em></a></h2><p>Escribir código como una serie de pasos a nivel superior Es una forma rápida de empezar a  resolver un problema, pero uno debería intentar dividir un programa en funciones tan pronto como  sea posible. La función son más reusabes y testables, y clarifican qué pasos se están dando y  cuáles son sus entradas y sus salidas. Además, el código dentro de las funciones tiende a ejecutar  mucho más rápido que el código de nivel superior debido a cómo funciona el compilador de Julia.</p><p>También merece la pena señalar que las funciones deberían tomar argumentos, en lugar de operar directamente sobre las variables globales (aparte de constantes como <a href="../stdlib/numbers.html#Base.pi"><code>pi</code></a>).</p><h2><a class="nav-anchor" id="Evita-escribir-tipos-demasiado-específicos-1" href="#Evita-escribir-tipos-demasiado-específicos-1">Evita escribir tipos demasiado específicos</a></h2><p>El código debería ser tan genérico como sea posible. En lugar de escribir:</p><pre><code class="language-julia">convert(Complex{Float64}, x)</code></pre><p>es mejor usar funciones genéricas disponibles:</p><pre><code class="language-julia">complex(float(x))</code></pre><p>La segunda versión convertirá <code>x</code> a un tipo apropiado, en lugrar de siempre al mismo tipo. </p><p>Este punto de estilo es especialmente relevante para los argumentos de función. Por ejemplo, no declare que un argumento sea de tipo <code>Int</code> o <a href="../stdlib/numbers.html#Core.Int32"><code>Int32</code></a> si realmente pudiera ser cualquier número entero, expresado con el tipo abstracto <a href="../stdlib/numbers.html#Core.Integer"><code>Integer</code></a>. De hecho, en muchos casos puede omitir el tipo de argumento por completo, a menos que sea necesario para eliminar la ambigüedad de otras definiciones de método, ya que se lanzará <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a> de todos modos si se pasa un tipo que no admite ninguna de las operaciones requeridas. (Esto se conoce como <a href="https://en.wikipedia.org/wiki/Duck_typing"><em>duck typing</em></a>.)</p><p>Por ejemplo, considere las siguientes definiciones de una función <code>addone</code> que devuelve uno más su argumento:</p><pre><code class="language-julia">addone(x::Int) = x + 1                 # works only for Int
addone(x::Integer) = x + oneunit(x)    # any integer type
addone(x::Number) = x + oneunit(x)     # any numeric type
addone(x) = x + oneunit(x)             # any type supporting + and oneunit</code></pre><p>La última definición de <code>addone</code> maneja cualquier tipo que soporte <a href="../stdlib/numbers.html#Base.oneunit"><code>oneunit</code></a> (que devuelve 1 en el mismo tipo que <code>x</code>, lo que evita la promoción de tipos no deseados) y  la función <a href="../stdlib/math.html#Base.:+"><code>+</code></a> con esos argumentos. La clave para darse cuenta es que no hay <em>ninguna penalización de rendimiento</em> para definir <em>solo</em> el general <code>addone (x) = x + oneunit (x)</code>, porque Julia compilará automáticamente versiones especializadas según sea necesario. Por ejemplo, la primera vez que llame a <code>addone(12)</code>, Julia compilará automáticamente una función especializada <code>addone</code> para argumentos <code>x :: Int</code>, reemplazando la llamada a <code>oneunit</code> por su valor<code>1</code>. Por lo tanto, las primeras tres definiciones de &#39;addone&#39; anteriores son completamente redundantes con la cuarta definición.</p><h2><a class="nav-anchor" id="Manejar-el-exceso-de-diversidad-de-argumentos-en-el-&quot;código-llamador&quot;-1" href="#Manejar-el-exceso-de-diversidad-de-argumentos-en-el-&quot;código-llamador&quot;-1">Manejar el exceso de diversidad de argumentos en el &quot;código llamador&quot;</a></h2><p>En lugar de:</p><pre><code class="language-julia">function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)</code></pre><p>use:</p><pre><code class="language-julia">function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))</code></pre><p>Este es mucho mejor estilo debido a que <code>foo</code> no acepta realmente números de todos los tipos, sino que necesita <code>Int</code> s.</p><p>Un problema aquí es que si una función requiere números enteros intrínsecamente, podría ser mejor forzar al autor de la llamada a decidir cómo deberían convertirse los no enteros (por ejemplo, redondeando por abajo o por arriba). Otro problema es que la declaración de tipos más específicos deja más &quot;espacio&quot; para las futuras definiciones de métodos.</p><h2><a class="nav-anchor" id="Añadir-!-para-los-nombres-de-funciones-que-modifican-sus-argumentos-1" href="#Añadir-!-para-los-nombres-de-funciones-que-modifican-sus-argumentos-1">Añadir <code>!</code> para los nombres de funciones que modifican sus argumentos</a></h2><p>En lugar de:</p><pre><code class="language-julia">function double(a::AbstractArray{&lt;:Number})
    for i = 1:endof(a)
        a[i] *= 2
    end
    return a
end</code></pre><p>use:</p><pre><code class="language-julia">function double!(a::AbstractArray{&lt;:Number})
    for i = 1:endof(a)
        a[i] *= 2
    end
    return a
end</code></pre><p>La biblioteca estándar de Julia usa esta convención y contiene ejemplos de funciones con formas tanto de copiado como de modificación (por ejemplo, <a href="../stdlib/sort.html#Base.sort"><code>sort()</code></a> y <a href="../stdlib/sort.html#Base.sort!"><code>sort!()</code></a>), y otras que simplemente están modificando (por ejemplo, <a href="../stdlib/collections.html#Base.push!"><code>push!()</code></a>, <a href="../stdlib/collections.html#Base.pop!-Tuple{Any,Any,Any}"><code>pop!()</code></a>, <a href="../stdlib/collections.html#Base.splice!"><code>splice!()</code></a>). Es típico para tales funciones devolver también la matriz modificada por conveniencia.</p><h2><a class="nav-anchor" id="Evitar-tipos-Union-extraños-1" href="#Evitar-tipos-Union-extraños-1">Evitar tipos <code>Union</code> extraños</a></h2><p>Tipos tales como <code>Union{Function,AbstractString}</code> son frecuentemente un signo de que hay que limpiar algo en el diseño.</p><h2><a class="nav-anchor" id="Evitar-las-Uniones-de-tipos-en-campos-1" href="#Evitar-las-Uniones-de-tipos-en-campos-1">Evitar las Uniones de tipos en campos</a></h2><p>Cuando se crea un tipo tal como :</p><pre><code class="language-julia">mutable struct MyType
    ...
    x::Union{Void,T}
end</code></pre><p>pregunte si la opción de <code>x</code> para ser <code>nada</code> (de tipo <code>Void</code>) es realmente necesaria. Aquí hay algunas alternativas a considerar:</p><ul><li><p>Encuentre un valor predeterminado seguro con el que inicializar <code>x</code></p></li><li><p>Introduce otro tipo del que carece <code>x</code></p></li><li><p>Si hay muchos campos como <code>x</code>, guárdelos en un diccionario</p></li><li><p>Determine si hay una regla simple para cuando <code>x</code> es<code>nada</code>. Por ejemplo, a menudo el campo comenzará  como <code>nada</code> pero se inicializará en algún punto bien definido. En ese caso, considere dejarlo indefinido  al principio.</p></li><li><p>Si <code>x</code> realmente no necesita contener ningún valor en algún momento, defínalo como <code>::Nullable{T}</code> en  su lugar, ya que esto garantiza estabilidad de tipo en el código que accede a este campo  (ver <a href="types.html#man-nullable-types-1">TiposNullable</a>).</p></li></ul><h2><a class="nav-anchor" id="Evitar-elaborar-tipos-contenedor-1" href="#Evitar-elaborar-tipos-contenedor-1">Evitar elaborar tipos contenedor</a></h2><p>Usualmente no es de mucha ayuda construir arrays como los siguientes:</p><pre><code class="language-julia">a = Array{Union{Int,AbstractString,Tuple,Array}}(n)</code></pre><p>En este caso <code>Array{Any}(n)</code> es mejor. Es también de más ayuda para el compilador anotar usos específicos (por ejemplo  <code>a[i]::Int</code>) que intentar empaquetar muchas alternativas en un tipo.</p><h2><a class="nav-anchor" id="Usar-convenciones-de-nombrado-consistentes-con-el-paquete-base/-de-Julia-1" href="#Usar-convenciones-de-nombrado-consistentes-con-el-paquete-base/-de-Julia-1">Usar convenciones de nombrado consistentes con el paquete <code>base/</code> de Julia</a></h2><ul><li><p>Los nombres de los módulos y tipos usan mayúsculas y <em>came case</em>: <code>module SparseArrays</code>, <code>struct UnitRange</code>.</p></li><li><p>Las funciones van en minúscula (<a href="../stdlib/collections.html#Base.maximum-Tuple{Any}"><code>maximum()</code></a>, <a href="../stdlib/base.html#Base.convert"><code>convert()</code></a>) y, cuando es legible, con múltiples palabras pegadas juntas (<a href="../stdlib/base.html#Base.isequal-Tuple{Any,Any}"><code>isequal()</code></a>, <a href="../stdlib/collections.html#Base.haskey"><code>haskey()</code></a>). Cuando sea necesario, use guiones bajos como separadores de palabra. Los guiones bajos también se usan para indicar una combinacin de conceptos (<a href="../stdlib/parallel.html#Base.Distributed.remotecall_fetch-Tuple{Any,Integer,Vararg{Any,N} where N}"><code>remotecall_fetch()</code></a> como una implementación más eficiente de <code>fetch(remotecall(...))</code>) o como modificadores (<a href="../stdlib/arrays.html#Base.sum_kbn"><code>sum_kbn()</code></a>).</p></li><li><p>Se valora la concisión, pero debe evitarse la abreviatura (<a href="../stdlib/collections.html#Base.indexin"><code>indexin()</code></a> en lugar de <code>indxin()</code>) ya que se vuelve difícil recordar si se abrevian palabras particulares y cómo se han abreviado.</p></li></ul><p>Si el nombre de una función requiere varias palabras, considere si podría representar más de un concepto y podría dividirse mejor en partes.</p><h2><a class="nav-anchor" id="No-usar-demasiado-try-catch-1" href="#No-usar-demasiado-try-catch-1">No usar demasiado try-catch</a></h2><p>Es mejor evitar errores que basarse en atraparlos.</p><h2><a class="nav-anchor" id="No-meter-entre-paréntesis-las-condiciones-1" href="#No-meter-entre-paréntesis-las-condiciones-1">No meter entre paréntesis las condiciones</a></h2><p>Julia no necesita que se rodeen entre paréntesis las condiciones en <code>if</code> and <code>while</code>. Escriba:</p><pre><code class="language-julia">if a == b</code></pre><p>en lugar de:</p><pre><code class="language-julia">if (a == b)</code></pre><h2><a class="nav-anchor" id="No-usar-demasiado-...-1" href="#No-usar-demasiado-...-1">No usar demasiado <code>...</code></a></h2><p>El uso de <code>...</code> en los argumentos de función puede ser adictivo. En lugar de <code>[a..., b...]</code>, use <code>[a; b]</code>, que ya concatena arrays. <a href="../stdlib/collections.html#Base.collect-Tuple{Any}"><code>collect(a)</code></a> es mejor que <code>[a...]</code>, pero como <code>a</code> ya es iterable suele ser incluso mejor dejarlo solo, y no convertirlo en array.</p><h2><a class="nav-anchor" id="No-usar-parámetros-estáticos-innecesarios-1" href="#No-usar-parámetros-estáticos-innecesarios-1">No usar parámetros estáticos innecesarios</a></h2><p>Una signatura de función:</p><pre><code class="language-julia">foo(x::T) where {T&lt;:Real} = ...</code></pre><p>debería ser escrita como</p><pre><code class="language-julia">foo(x::Real) = ...</code></pre><p>especialmente si <code>T</code> no se usa en el cuerpo de la función. Incluso si se usa <code>T</code>, se puede reemplazar con <a href="../stdlib/base.html#Core.typeof"><code>typeof(x)</code></a> si es conveniente. No hay diferencia de rendimiento. Tenga en cuenta que esto no es una precaución general contra los parámetros estáticos, solo contra uso donde no son necesarios.</p><p>Tenga en cuenta también que los tipos de contenedores, específicamente pueden necesitar parámetros de tipo en las llamadas a función. Consulte las Preguntas frecuentes <a href="performance-tips.html#avoid-fields-with-abstract-containers-1">Evitar campos con contenedores abstractos</a> para obtener más información.</p><h2><a class="nav-anchor" id="Evitar-la-confusion-sobre-si-algo-es-una-instancia-o-un-tipo-1" href="#Evitar-la-confusion-sobre-si-algo-es-una-instancia-o-un-tipo-1">Evitar la confusion sobre si algo es una instancia o un tipo</a></h2><p>Conjuntos de definiciones como las siguientes son confusas:</p><pre><code class="language-julia">foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)</code></pre><p>Decida si el concepto en cuestión se escribirá como <code>MyType</code> o <code>MyType()</code>, y sígalo.</p><p>El estilo preferido es usar instancias por defecto, y solo agregue métodos que incluyan <code>Type{MyType}</code> más tarde si se vuelven necesarios para resolver algún problema.</p><p>Si un tipo es efectivamente una enumeración, debe definirse como un tipo único (idealmente, <code>immutable struct</code> o primitivo), con los valores de enumeración como instancias de este. Los constructores y las conversiones pueden verificar si los valores son válidos. Este diseño es preferible a hacer que la enumeración sea un tipo abstracto, con los &quot;valores&quot; como subtipos.</p><h2><a class="nav-anchor" id="No-abusar-de-las-macros-1" href="#No-abusar-de-las-macros-1">No abusar de las macros</a></h2><p>Tenga en cuenta cuando una macro realmente podría ser una función en su lugar.</p><p>Llamar a <a href="../stdlib/base.html#Core.eval"><code>eval()</code></a> dentro de una macro es un signo de advertencia particularmente peligroso; significa que la macro solo funcionará cuando se llame al nivel superior. Si tal macro se escribe como una función en su lugar, naturalmente tendrá acceso a los valores en tiempo de ejecución que necesita.</p><h2><a class="nav-anchor" id="No-exponer-operaciones-inseguras-al-nivel-de-interfaz-1" href="#No-exponer-operaciones-inseguras-al-nivel-de-interfaz-1">No exponer operaciones inseguras al nivel de interfaz</a></h2><p>Si se tiene un tipo que use un puntero nativo:</p><pre><code class="language-julia">mutable struct NativeType
    p::Ptr{UInt8}
    ...
end</code></pre><p>no escriba definiciones como la siguiente:</p><pre><code class="language-julia">getindex(x::NativeType, i) = unsafe_load(x.p, i)</code></pre><p>El problema es que los usuarios de este tipo pueden escribir <code>x[i]</code> sin darse cuenta de que la operación no es segura y, luego, ser susceptibles a errores de memoria.</p><p>Dicha función debería verificar la operación para asegurarse de que sea segura, o incluir <code>unsafe</code> en alguna parte de su nombre para alertar a las personas que la invocan.</p><h2><a class="nav-anchor" id="No-sobrecargar-métodos-de-tipos-de-contenedores-base-1" href="#No-sobrecargar-métodos-de-tipos-de-contenedores-base-1">No sobrecargar métodos de tipos de contenedores base</a></h2><p>Es posible escribir definiciones como la siguiente:</p><pre><code class="language-julia">show(io::IO, v::Vector{MyType}) = ...</code></pre><p>Esto proporcionaría una muestra personalizada de vectores con un nuevo tipo de elemento específico. Aunque es tentador, es algo que debe evitarse. El problema es que los usuarios esperarán que un tipo conocido como <code>Vector()</code> se comporte de cierta manera, y la personalización excesiva de su comportamiento puede dificultar el trabajo.</p><h2><a class="nav-anchor" id="Evitar-la-piratería-de-tipos-1" href="#Evitar-la-piratería-de-tipos-1">Evitar la piratería de tipos</a></h2><p>La &quot;Piratería de Tipos&quot; se refiere a la práctica de extender o redefinir métodos en Base u otros paquetes en tipos que no han definido. En algunos casos, puede la piratería de tipo va a tener un efecto poco negativo. Sin embargo, en casos extremos, incluso puede bloquear Julia (por ejemplo, si la extensión o redefinición de su método hace que se pase una entrada inválida a <code>ccall</code>). La piratería de tipos puede complicar el razonamiento sobre el código y puede introducir incompatibilidades que son difíciles de predecir y diagnosticar.</p><p>Como ejemplo, suponga que quiere definir la multiplicación en símbolos en un módulo: </p><pre><code class="language-julia">module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end</code></pre><p>El problema es que ahora cualquier otro módulo que use <code>Base.*</code> También verá esta definición. Dado que <code>Symbol</code> se define en Base y es utilizado por otros módulos, esto puede cambiar el comportamiento del código no relacionado de forma inesperada. Aquí hay varias alternativas, incluido el uso de un nombre de función diferente o el ajuste de <code>Symbol</code>s en otro tipo que defina.</p><p>Algunas veces, los paquetes acoplados pueden involucrarse en la piratería de tipos para separar las características de las definiciones, especialmente cuando los paquetes fueron diseñados por autores colaboradores, y cuando las definiciones son reutilizables. Por ejemplo, un paquete puede proporcionar algunos tipos útiles para trabajar con colores; otro paquete podría definir métodos para aquellos tipos que permiten conversiones entre espacios de color. Otro ejemplo podría ser un paquete que actúa como un envoltorio delgado para algún código C, que otro paquete podría piratear para implementar una API de nivel superior compatible con Julia.</p><h2><a class="nav-anchor" id="Ser-cuidadoso-con-la-igualdad-de-tipos-1" href="#Ser-cuidadoso-con-la-igualdad-de-tipos-1">Ser cuidadoso con la igualdad de tipos</a></h2><p>Por lo general, uno desea utilizar <a href="../stdlib/base.html#Core.isa"><code>isa()</code></a> y <a href="../stdlib/base.html#Base.:&lt;:"><code>&lt;:</code></a> para los tipos de prueba, no <code>==</code>. La comprobación de los tipos para la igualdad exacta normalmente solo tiene sentido cuando se compara con un tipo concreto conocido (por ejemplo, <code>T == Float64</code>), o si <em>realmente</em> uno sabe lo que está haciendo.</p><h2><a class="nav-anchor" id="No-escribir-x-f(x)-1" href="#No-escribir-x-f(x)-1">No escribir <code>x-&gt;f(x)</code></a></h2><p>Como las funciones de orden superior a menudo se llaman con funciones anónimas, es fácil concluir que esto es deseable o incluso necesario. Pero cualquier función se puede pasar directamente, sin estar &quot;envuelta&quot; en una función anónima. En lugar de escribir <code>map (x-&gt; f(x), a)</code>, escriba <a href="../stdlib/collections.html#Base.map"><code>map(f, a)</code></a>.</p><h2><a class="nav-anchor" id="Evitar-usar-floats-para-literales-numericos-en-codigo-generico-cuando-sea-posible-1" href="#Evitar-usar-floats-para-literales-numericos-en-codigo-generico-cuando-sea-posible-1">Evitar usar floats para literales numericos en codigo generico cuando sea posible</a></h2><p>Si escribe código genérico que maneja números, y que se puede esperar que se ejecute con muchos tipos de argumentos numéricos diferentes, intente utilizar literales de un tipo numérico que afectarán los argumentos lo menos posible mediante la promoción.</p><p>Por ejemplo,</p><pre><code class="language-julia-repl">julia&gt; f(x) = 2.0 * x
f (generic function with 1 method)

julia&gt; f(1//2)
1.0

julia&gt; f(1/2)
1.0

julia&gt; f(1)
2.0</code></pre><p>mientras que</p><pre><code class="language-julia-repl">julia&gt; g(x) = 2 * x
g (generic function with 1 method)

julia&gt; g(1//2)
1//1

julia&gt; g(1/2)
1.0

julia&gt; g(1)
2</code></pre><p>Como puede ver, la segunda versión, donde usamos un literal <code>Int</code>, conserva el tipo de argumento de entrada, mientras que la primera no. Esto se debe a, por ejemplo, <code>promote_type(Int, Float64) == Float64</code>, y la promoción ocurre con la multiplicación. De manera similar, los literales <a href="../stdlib/numbers.html#Base.Rational"><code>Rational</code></a> son menos disruptivos que los literales <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>, pero son más perjudiciales que los <code>Int</code>s:</p><pre><code class="language-julia-repl">julia&gt; h(x) = 2//1 * x
h (generic function with 1 method)

julia&gt; h(1//2)
1//1

julia&gt; h(1/2)
1.0

julia&gt; h(1)
2//1</code></pre><p>Por tanto, use literales <code>Int</code> cuando sea posible, con <code>Rational{Int}</code> para literales numéricos no enteros, en orden a hacer nuestro código ms fácil de usar.</p><footer><hr/><a class="previous" href="workflow-tips.html"><span class="direction">Previous</span><span class="title">Workflow Tips</span></a><a class="next" href="faq.html"><span class="direction">Next</span><span class="title">Frequently Asked Questions</span></a></footer></article></body></html>
