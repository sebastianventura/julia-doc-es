<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ámbito de las variables · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Funciones</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li class="current"><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a><ul class="internal"><li><a class="toctext" href="#Ámbito-Global-1">Ámbito Global</a></li><li><a class="toctext" href="#Ámbito-Local-1">Ámbito Local</a></li><li><a class="toctext" href="#Constantes-1">Constantes</a></li></ul></li><li><a class="toctext" href="types.html">Tipos</a></li><li><a class="toctext" href="methods.html">Métodos</a></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión y Promoción</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="variables-and-scoping.html">Ámbito de las variables</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/variables-and-scoping.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Ámbito de las variables</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="scope-of-variables-1" href="#scope-of-variables-1">Ámbito de las variables</a></h1><p>El <em>ámbito</em> de una variable es la región de código donde dicha variable es visible. El ámbito de las variables ayuda a evitar conflictos de nombrado de variables. El concepto es intuitivo: dos funciones pueden tener argumentos denominados <code>x</code> sin que las dos <code>x</code> se refieran a la misma cosa. De forma similar, hay muchos otros casos donde diferentes bloques de código pueden usar el mismo nombre sin referirse a la misma cosa. Las reglas para cuando el mismo nombre de variable se refiere o no a la  misma cosa se llaman <em>reglas de ámbito</em>. Em este tema se analizan en detalle. </p><p>Ciertas construcciones en el lenguaje introducen <em>bloques de ámbitos</em>, que son regiones de código que son elegibles para estar en el ámbito de algún conjunto de variables. El ámbito de una variable no puede ser un conjunto arbitrario de líneas de código; en lugar de ello, siempre se alinea con uno de esos bloques. Hay dos tipos principales de ámbitos en Julia: <em>globales</em> y <em>locales</em>, pudiendo los últimos estar anidados. Las construcciones que introducen estos bloques de ámbito son:</p><table><tr><th>Nombre de ámbito</th><th>Bloque/construcción que introduce este tipo de ámbito</th></tr><tr><td>Ámbito Global</td><td><code>module</code>, <code>baremodule</code> y prompt interactivo (REPL)</td></tr><tr><td>Ámbito Local  </td><td><a href="variables-and-scoping.html#Ámbito-local-blando-1">Ámbito local blando</a>: <code>for</code>, <code>while</code> comprensiones, bloques <code>try-catch-finally</code>, <code>let</code></td></tr><tr><td>Ámbito Local  </td><td><a href="variables-and-scoping.html#Ámbito-local-duro-1">Ámbito local duro</a>: funciones (cualquier sintaxis, anónima y bloques do), <code>struct</code>, <code>macro</code></td></tr></table><p>Dos notables ausencias en esta tabla son los <a href="control-flow.html#man-compound-expressions-1">bloques begin</a> y los <a href="control-flow.html#man-conditional-evaluation-1">bloques if</a>, que no introducen nuevos bloques de ámbito. Los tres tipos de bloques siguen reglas un poco diferentes que serán explicadas más adelante, así como algunas reglas extra para ciertos bloques.</p><p>Julia usa un <a href="https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping">ámbito léxico</a>, lo que significa que el ámbito de una función no hereda del ámbito que lo invocó, pero si del ámbito en que la función fue definida. Por ejemplo, en el siguiente código, <code>x</code> deontro de <code>foo</code> se refiere a la <code>x</code> que hay en el ámbito local de su módulo <code>Bar</code>:</p><pre><code class="language-jldoctest">julia&gt; module Bar
           x = 1
           foo() = x
       end;</code></pre><p>y no a la <code>x</code> en el ámbito en que se ha usado <code>foo</code>:</p><pre><code class="language-jldoctest">julia&gt; import .Bar

julia&gt; x = -1;

julia&gt; Bar.foo()
1</code></pre><p>Por tanto, <em>ámbito léxico</em> significa que el ámbito de las variables puede ser inferido del código fuente sin más. </p><h2><a class="nav-anchor" id="Ámbito-Global-1" href="#Ámbito-Global-1">Ámbito Global</a></h2><p><em>Cada módulo introduce un nuevo espacio global</em>, separado del ámbito global de todos los otros módulos; no existen ámbitos globales compartidos por todos. Los módulos pueden introducir variables de otros módulos o en su ámbito a través del uso de las instrucciones <a href="modules.html#modules-1"><code>using</code></a> o <a href="modules.html#modules-1"><code>import</code></a> o a través de acceso cualificado usando la notación punto. En consecuencia, cada módulo es un espacio de nombres. Notese que los enlaces de nombres pueden sólo ser cambiados  dentro de su ámbito global y no desde un módulo exterior.</p><pre><code class="language-julia-repl">julia&gt; module A
           a = 1 # a global in A&#39;s scope
       end;

julia&gt; module B
           module C
               c = 2
           end
           b = C.c    # can access the namespace of a nested global scope
                      # through a qualified access
           import ..A # makes module A available
           d = A.a
       end;

julia&gt; module D
           b = a # errors as D&#39;s global scope is separate from A&#39;s
       end;
ERROR: UndefVarError: a not defined

julia&gt; module E
           import ..A # make module A available
           A.a = 2    # throws below error
       end;
ERROR: cannot assign variables in other modules</code></pre><p>Nótese que el prompt interactivo (REPL) está en el ámbito global del módulo <code>Main</code>.</p><h2><a class="nav-anchor" id="Ámbito-Local-1" href="#Ámbito-Local-1">Ámbito Local</a></h2><p>La mayoría de los bloques de código introducen un nuevo ámbito local. Los ámbitos locales suelen heredar todas las variables de su ámbito padre, tanto para lectura como para escritura. Hay dos subtipos de ámbitos locales, denominados <em>duros</em> y <em>blandos</em>, con reglas ligeramente distintas en relación a qué variables son heredadas. A diferencia de los ámbitos globales, los ámbitos locales no son espacios de nombres, por lo que las variables de un ámbito más interno no pueden ser recuperadas de uno más externo a través de alguna clase de acceso cualificado.</p><p>Las siguientes reglas y ejemplos pertenecen tanto a los ámbitos locales como globales. Una variable introducida de nuevo en un ámbito local no se retroprogada a su ámbito padre. Por ejemplo, la <code>z</code> no se introduce en el ámbito de nivel superior:</p><pre><code class="language-julia-repl">julia&gt; for i = 1:10
           z = i
       end

julia&gt; z
ERROR: UndefVarError: z not defined</code></pre><p>(Nótese que En este ejemplo y los siguientes se supone que el ámbito de nivel superior es un ámbito global con un espacio de trabajo limpio, por ejemplo un REPL arrancado de nuevo.)</p><p>Dentro de un ámbito local una variable puede ser forzada a ser una variables local usando la palabra clave <code>local</code>.</p><pre><code class="language-julia-repl">julia&gt; x = 0;

julia&gt; for i = 1:10
           local x
           x = i + 1
       end

julia&gt; x
0</code></pre><p>Dentro de un ámbito local puede definirse una nueva variable global usando la palabra clave <code>global</code>:</p><pre><code class="language-julia-repl">julia&gt; for i = 1:10
           global z
           z = i
       end

julia&gt; z
10</code></pre><p>La localización de las palabras clave <code>local</code> y  <code>global</code> dentro del bloque del ámbito es irrelevante. El siguiente código es totalmente equivalente al ejemplo anterior (aunque estilísticamente es peor): </p><pre><code class="language-julia-repl">julia&gt; for i = 1:10
           z = i
           global z
       end

julia&gt; z
10</code></pre><h3><a class="nav-anchor" id="Ámbito-local-blando-1" href="#Ámbito-local-blando-1">Ámbito local blando</a></h3><blockquote><p>En un ámbito local blando, todas las variables son heredadas de su ámbito padre a menos que una  variable haya sido marcada específicamente con la palabra <code>local</code>.</p></blockquote><p>Los ámbitos locales blandos se introducen en los bucles <code>for</code>, bucles <code>while</code>, comprensiones, bloques <code>try-catch-finally</code> y bloques <code>let</code>. Hay algunas reglas extra para los <a href="variables-and-scoping.html#let-blocks-1">bloques <code>let</code></a> y para los <a href="variables-and-scoping.html#for-loops-and-comprehensions-1">bucles <code>for</code> y comprensiones</a>.</p><p>En el siguiente ejemplo, <code>x</code> e <code>y</code> se refieren siempre a la misma variable dado que el ámbito local blando heredan ambas variables de lectura y escritura:</p><pre><code class="language-julia-repl">julia&gt; x, y = 0, 1;

julia&gt; for i = 1:10
           x = i + y + 1
       end

julia&gt; x
12</code></pre><p>Dentro de los ámbitos blandos, la palabra clave <em>global</em> no es nunca necesaria, aunque está permitida. El único caso donde podría cambiar la semántica es (actualmente) un error sintáctico:</p><pre><code class="language-julia-repl">julia&gt; let
           local j = 2
           let
               global j = 3
           end
       end
ERROR: syntax: `global j`: j is local variable in the enclosing scope</code></pre><h3><a class="nav-anchor" id="Ámbito-local-duro-1" href="#Ámbito-local-duro-1">Ámbito local duro</a></h3><p>Los ámbitos locales duros se introducen mediante las definiciones de función (en todas sus formas) bloques de tipos e inmutables y definiciones de macros.</p><blockquote><p>En el ámbito local duro, todas las variables son heredades de su ámbito padre a menos que:</p><ul><li><p>Una asignación daría como resultado una variable <code>global</code></p></li><li><p>Una variable sea marcada específicamente con la palabra clave <code>local</code>.</p></li></ul></blockquote><p>Por tanto, las variables globales son sólo heredadas para lectura pero no para escritura:</p><pre><code class="language-julia-repl">julia&gt; x, y = 1, 2;

julia&gt; function foo()
           x = 2        # assignment introduces a new local
           return x + y # y refers to the global
       end;

julia&gt; foo()
4

julia&gt; x
1</code></pre><p>Se necesita un <code>global</code> explícito para asignar a una variable global:</p><pre><code class="language-julia-repl">julia&gt; x = 1;

julia&gt; function foobar()
           global x = 2
       end;

julia&gt; foobar();

julia&gt; x
2</code></pre><p>Note que las <em>funciones anidadas</em> pueden comportarse diferentemente de las funciones definidas en el ámbito global como si ellas pudieran variar las variables locales del ámbito padre.</p><pre><code class="language-julia-repl">julia&gt; x, y = 1, 2;

julia&gt; function baz()
           x = 2 # introduces a new local
           function bar()
               x = 10       # modifies the parent&#39;s x
               return x + y # y is global
           end
           return bar() + x # 12 + 10 (x is modified in call of bar())
       end;

julia&gt; baz()
22

julia&gt; x, y
(1, 2)</code></pre><p>La distinción entre heredar variables locales y globales para asignación puede llevar a ligeras diferencias entre funciones definidas en ámbitos locales y/o globales. Considere la modificación del último ejemplo moviendo <code>bar</code> al ámbito global:</p><pre><code class="language-julia-repl">julia&gt; x, y = 1, 2;

julia&gt; function bar()
           x = 10 # local
           return x + y
       end;

julia&gt; function quz()
           x = 2 # local
           return bar() + x # 12 + 2 (x is not modified)
       end;

julia&gt; quz()
14

julia&gt; x, y
(1, 2)</code></pre><p>Notemos que lo anterior sutilmente no pertenece a las definiciones de tipo y de macro, por lo que ellas sólo pueden aparecer en el ámbito global. Hay reglas de ámbito especiales relacionadas con la evaluación de argumentos de función por defecto y palabra clave que se describen en la sección de <a href="functions.html#man-functions-1">Funciones</a>.</p><p>Una asignación que introduce una variable usada dentro de una definicíon de función, tipo o macro no necesita ir antes de su uso interno: </p><pre><code class="language-julia-repl">julia&gt; f = y -&gt; y + a
(::#1) (generic function with 1 method)

julia&gt; f(3)
ERROR: UndefVarError: a not defined
Stacktrace:
 [1] (::##1#2)(::Int64) at ./none:1

julia&gt; a = 1
1

julia&gt; f(3)
4</code></pre><p>Este comportamiento puede parecer un poco raro para una variable normal, pero está permitido para que las funciones nombradas sean usadas antes de ser definidas (las funciones nombradas son exactamente variables normales que almacenan objetos función). Esto permite a las funciones ser definidas en cualquier orden que sea intuitivo y conveniente en lugar de forzar un  ordenamiento de abajo a arriba o requerir declaraciones hacia delante, mientras que ellas sean definidas en el momento que sean usadas. Por ejemplo, he aquí una forma ineficiente, mutuamente recursiva de comprobar si un entero positivo es par o impar:</p><pre><code class="language-julia-repl">julia&gt; even(n) = n == 0 ? true : odd(n-1);

julia&gt; odd(n) = n == 0 ? false : even(n-1);

julia&gt; even(3)
false

julia&gt; odd(3)
true</code></pre><p>Julia proporciona funciones eficientes y predefinidas para comprobar la paridad o imparidad, llamadas <a href="../stdlib/numbers.html#Base.iseven"><code>iseven()</code></a> e <a href="../stdlib/numbers.html#Base.isodd"><code>isodd()</code></a>. Por tanto, las definiciones anteriores deberían ser sólo tomadas como ejemplos.</p><h3><a class="nav-anchor" id="Ámbitos-locales-duro-vs.-blando-1" href="#Ámbitos-locales-duro-vs.-blando-1">Ámbitos locales duro vs. blando</a></h3><p>Los bloques que introducen un ámbito local blando, como los bucles, se suelen usar para manipular las variables en su ámbito padre. Por tanto, su defecto es acceder completamente a todas las variables de su ámbito padre.</p><p>A la inversa, el código dentro de los bloques que introduce un ámbito local duro (definiciones de función, tipo o macro) pueden ser ejecutados en cualquier parte del programa. Cambiar remotamente el estado de variables locales en otros módulos debería ser realizado con cuidado y por tanto esta es una característica de optimización que requiere la palabra clave <code>global</code>.</p><p>La razón para permitir <em>modificar local</em> variables de ámbitos padres en funciones anidadas es permitir la construcción de <a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29">cierres</a> que tienen un estado privado, por ejemplo la variable <code>state</code> del siguiente ejemplo:</p><pre><code class="language-julia-repl">julia&gt; let
           state = 0
           global counter
           counter() = state += 1
       end;

julia&gt; counter()
1

julia&gt; counter()
2</code></pre><p>Ver también los cierres en los ejemplos de las dos siguientes secciones.</p><h3><a class="nav-anchor" id="let-blocks-1" href="#let-blocks-1">Bloques Let</a></h3><p>A diferencia de las asignaciones a variables locales, las instrucciones <code>let</code> asignan nuevas asociaciones de variables cada vez que se ejecutan. Una asignación modifica el valor de una localización existente, y <code>let</code> crea nuevas localizaciones. Esta diferencia no suele ser importante, y es sólo detectable en el caso de variables que sobreviven a sus ámbitos vía cierres. La sintaxis de <code>let</code> acepta una serie de asignaciones y nombres de variables separados por comas:</p><pre><code class="language-julia-repl">julia&gt; x, y, z = -1, -1, -1;

julia&gt; let x = 1, z
           println(&quot;x: $x, y: $y&quot;) # x is local variable, y the global
           println(&quot;z: $z&quot;) # errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: z not defined</code></pre><p>Las asignaciones se evalúan en orden, con cada término derecho evaluado en el ámbito antes de que se introduzca la nueva variable a través del término izquierdo. Por tanto, tiene sentido escribir algo como <code>let x = x</code> ya que las dos variables son distintas y tienen almacenamiento separado. Este es un ejemplo de dónde se necesita el comportamiento de <code>let</code>: </p><pre><code class="language-julia-repl">julia&gt; Fs = Array{Any}(2); i = 1;

julia&gt; while i &lt;= 2
           Fs[i] = ()-&gt;i
           i += 1
       end

julia&gt; Fs[1]()
3

julia&gt; Fs[2]()
3</code></pre><p>Aquí creamos y almacenamos dos cierres que devuelven la variable <code>i</code>. Sin embargo, es siempre la misma variable <code>i</code>, por lo que los dos cierres se comportan de forma idéntica. Podemos usar <code>let</code> para crear una nueva correspondencia para <code>i</code>:</p><pre><code class="language-julia-repl">julia&gt; Fs = Array{Any}(2); i = 1;

julia&gt; while i &lt;= 2
           let i = i
               Fs[i] = ()-&gt;i
           end
           i += 1
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</code></pre><p>Como la construcción <code>begin</code> no construye un nuevo ámbito, puede ser útil usar un <code>let</code> con cero argumentos para introducir un nuevo bloque de ámbito sin crear ninguna nueva correspondencia:</p><pre><code class="language-julia-repl">julia&gt; let
           local x = 1
           let
               local x = 2
           end
           x
       end
1</code></pre><p>Como <code>let</code> introduce un nuevo bloque de ámbito, la variable local interna <code>x</code> es diferente de la externa local <code>x</code>.</p><h3><a class="nav-anchor" id="for-loops-and-comprehensions-1" href="#for-loops-and-comprehensions-1">Bucles for y comprensiones</a></h3><p>Los bucles <code>for</code> y las <a href="arrays.html#comprehensions-1">comprensiones</a> tiene el siguiente comportamiento: cualquier nueva variable introducida en sus ámbitos se reservan de nuevo para cada nueva iteración del bucle. Esto contrasta con los bucles <code>while</code> que reservan las variables para todas las iteraciones. Por tanto, estas construcciones son similares a bucles <code>while</code> con bloques <code>let</code> dentro de ellos:</p><pre><code class="language-julia-repl">julia&gt; Fs = Array{Any}(2);

julia&gt; for j = 1:2
           Fs[j] = ()-&gt;j
       end

julia&gt; Fs[1]()
1

julia&gt; Fs[2]()
2</code></pre><p>Los bucles <code>for</code> reusarán las variables existentes para su variable iteración:</p><pre><code class="language-julia-repl">julia&gt; i = 0;

julia&gt; for i = 1:3
       end

julia&gt; i
3</code></pre><p>Sin embargo, las comprensiones no hacen esto, y siempre asignan de nuevo sus variables de iteración:</p><pre><code class="language-julia-repl">julia&gt; x = 0;

julia&gt; [ x for x = 1:3 ];

julia&gt; x
0</code></pre><h2><a class="nav-anchor" id="Constantes-1" href="#Constantes-1">Constantes</a></h2><p>Un uso común de las variables es darle nombres de valores específicos, no cambiantes. Tales variables sólo se asignan una vez. Esta intención puede ser transportada al compilador usando la palabra clave <code>const</code>:</p><pre><code class="language-julia-repl">julia&gt; const e  = 2.71828182845904523536;

julia&gt; const pi = 3.14159265358979323846;</code></pre><p>La declaración <code>const</code> es permitida sobre variables globales y locales, pero es especialmente útil para las globales. Es difícil para el compilador optimizar´código en el que están implicadas las variables globales, ya que sus valores (o incluso sus tipos) podrían cambiar en cualquier momento. Si una variable global no va a cambiar, añadir una declaración <code>const</code>  resolverá este problema de rendimiento.</p><p>Las constantes locales son bastante diferentes. El compilador es capaz de determinar cuando una variable local es constante, por lo que las declaraciones de constante local no son necesarias para mejorar el rendimiento.</p><p>Las asignaciones especiales de nivel superior, tales como las realizadas por las palabras clave <code>function</code> y <code>type</code> son constantes por defecto. </p><p>Nótese que <code>const</code> sólo afecta a la asociación de variables:  la variable puede ser asociada a un objeto mutable (tal com un array) y el objeto puede aún ser modificado.</p><footer><hr/><a class="previous" href="control-flow.html"><span class="direction">Previous</span><span class="title">Control Flow</span></a><a class="next" href="types.html"><span class="direction">Next</span><span class="title">Tipos</span></a></footer></article></body></html>
