<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical Operations and Elementary Functions · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li class="current"><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a><ul class="internal"><li><a class="toctext" href="#arithmetic-operators-1">Operadores Aritméticos</a></li><li><a class="toctext" href="#bitwise-operators-1">Operadores bit a bit</a></li><li><a class="toctext" href="#Operaciones-de-actualización-1">Operaciones de actualización</a></li><li><a class="toctext" href="#man-dot-operators-1">Operadores vectorizados con &quot;punto&quot;</a></li><li><a class="toctext" href="#numeric-comparisons-1">Comparaciones Numéricas</a></li><li><a class="toctext" href="#operator-precedence-1">Precedencia de Operadores</a></li><li><a class="toctext" href="#numerical-conversions-1">Conversiones Numéricas</a></li></ul></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/mathematical-operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Mathematical Operations and Elementary Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="mathematical-operations-1" href="#mathematical-operations-1">Mathematical Operations and Elementary Functions</a></h1><p>Julia proporciona una colección completa de operadores aritméticos básicos y de operadores de bits para todos sus tipos numéricos primitivos, así como implementaciones portables y eficientes de una colección comprensiva de funciones matemática estándar.</p><h2><a class="nav-anchor" id="arithmetic-operators-1" href="#arithmetic-operators-1">Operadores Aritméticos</a></h2><p>Los siguientes <a href="https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations">operadores aritméticos</a> están soportados sobre todos los tipos primitivos:</p><table><tr><th>Expression</th><th>Name</th><th>Description</th></tr><tr><td><code>+x</code>      </td><td>más unario      </td><td>Operación identidad                   </td></tr><tr><td><code>-x</code>      </td><td>menos unario    </td><td>Inverso matemático de un número</td></tr><tr><td><code>x + y</code></td><td>suma binaria</td><td>suma</td></tr><tr><td><code>x - y</code></td><td>menos binario</td><td>resta</td></tr><tr><td><code>x * y</code>  </td><td>producto        </td><td>multiplicación              </td></tr><tr><td><code>x / y</code>  </td><td>división        </td><td>división                    </td></tr><tr><td><code>x \ y</code>  </td><td>división inversa</td><td>Equivalente a <code>y / x</code>                </td></tr><tr><td><code>x ^ y</code>  </td><td>potencia        </td><td>eleva <code>x</code> a la <code>y</code>-ésima potencia</td></tr><tr><td><code>x % y</code></td><td>resto</td><td>Equivalente a <code>rem(x,y)</code></td></tr></table><p>así como la negación sobre tipos <a href="../stdlib/numbers.html#Core.Bool"><code>Bool</code></a>:</p><table><tr><th>Expression</th><th>Name</th><th>Description</th></tr><tr><td><code>!x</code>      </td><td>negación</td><td>Cambia <code>true</code> a <code>false</code> y viceversa</td></tr></table><p>El sistema de promoción de Julia hace que las operaciones aritméticas sobre mezclas de tipos de argumentos funcione de forma natural y automáticamente. Ver <a href="conversion-and-promotion.html#conversion-and-promotion-1">Conversión y Promoción</a> para los detalles del sistema de promoción.</p><p>He aquí algunos ejemplos simples de usar operadores aritméticos:</p><pre><code class="language-julia-repl">julia&gt; 1 + 2 + 3
6

julia&gt; 1 - 2
-1

julia&gt; 3*2/12
0.5</code></pre><p>(Por convención, tendemos a separar con menos distancia los operadores cuando se aplican antes de otros operadores cercanos. Por ejemplo, generalmente escribimos <code>-x + 2</code> para reflejar que <code>x</code> primero se niega y, a continuación, <code>2</code> se agrega a ese resultado.)</p><h2><a class="nav-anchor" id="bitwise-operators-1" href="#bitwise-operators-1">Operadores bit a bit</a></h2><p>Los siguientes <a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators">operadores bit a bit</a> son soportados sobre todos los tipos enteros primitivos:</p><table><tr><th>Expression</th><th>Name</th></tr><tr><td><code>~x</code>      </td><td>Negación bit a bit                                                    </td></tr><tr><td><code>x &amp; y</code>  </td><td>Conjunción (<em>and</em>) bit a bit                                          </td></tr><tr><td><code>x | y</code>  </td><td>Disyunción (<em>or</em>) bit a bit                                             </td></tr><tr><td><code>x ⊻ y</code></td><td><em>Or</em> exclusivo bit a bit (<em>xor</em>)</td></tr><tr><td><code>x &gt;&gt;&gt; y</code></td><td><a href="https://en.wikipedia.org/wiki/Logical_shift">Desplazamiento lógico</a> hacia la derecha      </td></tr><tr><td><code>x &gt;&gt; y</code>  </td><td><a href="https://en.wikipedia.org/wiki/Arithmetic_shift">Desplazamiento aritmético</a> hacia la derecha</td></tr><tr><td><code>x &lt;&lt; y</code>  </td><td>Desplazamiento hacia la izquierda lógico/aritmético                                        </td></tr></table><p>He aquí algunos ejemplos de uso de operadores bit a bit:</p><pre><code class="language-julia-repl">julia&gt; ~123
-124

julia&gt; 123 &amp; 234
106

julia&gt; 123 | 234
251

julia&gt; 123 ⊻ 234
145

julia&gt; xor(123, 234)
145

julia&gt; ~UInt32(123)
0xffffff84

julia&gt; ~UInt8(123)
0x84</code></pre><h2><a class="nav-anchor" id="Operaciones-de-actualización-1" href="#Operaciones-de-actualización-1">Operaciones de actualización</a></h2><p>Cada operador binario aritmético y bit a bit también tiene una versión de actualización que asigna el resultado de la operación de nuevo a su operando izquierdo. La versión de actualización del operador binario se forma colocando a = inmediatamente después del operador. Por ejemplo, escribir <code>x += 3</code> es equivalente a escribir <code>x = x + 3</code>:</p><pre><code class="language-julia-repl">julia&gt; x = 1
1

julia&gt; x += 3
4

julia&gt; x
4</code></pre><p>Las versiones de actualización de todos los operadores binarios, aritméticos de bits son:</p><pre><code class="language-none">+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Un operador de actualización reasigna la variable sobre la parte izquierda de la ecuación. Como  resultado, el tipo de la variable puede cambiar:</p><pre><code class="language-julia-repl">julia&gt; x = 0x01; typeof(x)
UInt8

julia&gt; x *= 2 # Same as x = x * 2
2

julia&gt; typeof(x)
Int64</code></pre></div></div><h2><a class="nav-anchor" id="man-dot-operators-1" href="#man-dot-operators-1">Operadores vectorizados con &quot;punto&quot;</a></h2><p>Para cada operación binaria como <code>^</code> hay su correspondiente operación &quot;con punto&quot; <code>.^</code> que se define <em>automáticamente</em> para realizar la operación <code>^</code> elemento a elemento sobre arrays. Por ejemplo, la operación <code>[1, 2, 3]^3</code> no está definidia, porque no hay un significado matemático estándar para calcular el cubo de un array, pero <code>[1, 2, 3].^3</code> si lo está como el cálculo de la operación cubo elemento a elemento (o vectorizada) <code>[1^3, 2^3, 3^3]</code>. Lo mismo puede decirse para operadores unarios tales como <code>!</code> o <code>√</code>, que existe el correspondiente operador vectorizado <code>.√</code> que aplica el operador elemento a elemento.</p><pre><code class="language-julia-repl">julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27</code></pre><p>Más específicamente, <code>a .^ b</code> es analizado como la <a href="functions.html#man-vectorized-1">llamada punto</a> <code>(^).(a,b)</code>, que realiza una operación de <a href="arrays.html#broadcasting-1">retransmisión (<em>broadcast</em>)</a>: ella puede combinar arrays y escalares, arrays del mismo tamaño (realizando la operación elemento a elemento), o incluso arrays de diferentes formas (por ejemplo, combinar vectores fila y columna para producir una matriz). Además, como todas las &quot;llamadas punto&quot;, estos &quot;operadores punto&quot; están <em>fusionados</em>. Por ejemplo, si calculamos <code>2 .* A.^2 .+ sin.(A)</code> (o, equivalentemente <code>@. 2A^2 + sin(A)</code>, usando la macro <a href="../stdlib/arrays.html#Base.Broadcast.@__dot__"><code>@.</code></a>) para un array <code>A</code>, se realiza un <em>único</em> bucle sobre <code>A</code>, computando <code>2a^2 + sin(a)</code> para cada elemento de <code>A</code>. En particular, las llamadas vectorizadas anidadas como <code>f.(g.(x))</code> están <em>fusionadas</em>, y los operadores binarios adyacentes como <code>x .+ 3 .* x.^2</code> son equivalentes a llamadas vectorizadas anidadas <code>(+).(x, (*).(3, (^).(x, 2)))</code>.</p><p>Además, los operadores de actualización &quot;vectorizados&quot; como <code>a .+= b</code> (o <code>@. a += b</code>) son transformados en <code>a .= a .+ b</code>, donde <code>.=</code> es un operador de asignación <em>fusionado</em> <em>in-place</em> (ver la <a href="functions.html#man-vectorized-1">documentación de la sintaxis vectorizada</a>).</p><p>Nótese que la sintaxis de punto es también aplicable a operadores definidos por el usuario. Por ejemplo, si definimos el operador <code>⊗(A,B) = kron(A,B)</code> para dar una sintaxis infija <code>A ⊗ B</code> al producto de Kronecker (<a href="../stdlib/linalg.html#Base.kron"><code>kron</code></a>), entonces <code>[A,B] .⊗ [C,D]</code> calculará  <code>[A⊗C, B⊗D]</code> sin ninguna codificación adicional.</p><h2><a class="nav-anchor" id="numeric-comparisons-1" href="#numeric-comparisons-1">Comparaciones Numéricas</a></h2><p>Los operadores de comparación estándar están definidos para todos los tipos numéricos primitivos:</p><table><tr><th>Operador</th><th>Nombre</th></tr><tr><td><a href="../stdlib/math.html#Base.:=="><code>==</code></a></td><td>Igualdad</td></tr><tr><td><a href="../stdlib/math.html#Base.:!="><code>!=</code></a>, <a href="../stdlib/math.html#Base.:!="><code>≠</code></a></td><td>Desigualdad</td></tr><tr><td><a href="../stdlib/math.html#Base.:&lt;"><code>&lt;</code></a></td><td>Menor que</td></tr><tr><td><a href="../stdlib/math.html#Base.:&lt;="><code>&lt;=</code></a>, <a href="../stdlib/math.html#Base.:&lt;="><code>≤</code></a></td><td>Menor o igual que</td></tr><tr><td><a href="../stdlib/math.html#Base.:&gt;"><code>&gt;</code></a></td><td>Mayor que</td></tr><tr><td><a href="../stdlib/math.html#Base.:&gt;="><code>&gt;=</code></a>, <a href="../stdlib/math.html#Base.:&gt;="><code>≥</code></a></td><td>Mayor o igual que</td></tr></table><p>He aquí algunos ejemplos:</p><pre><code class="language-julia-repl">julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 2
true

julia&gt; 1 == 1.0
true

julia&gt; 1 &lt; 2
true

julia&gt; 1.0 &gt; 3
false

julia&gt; 1 &gt;= 1.0
true

julia&gt; -1 &lt;= 1
true

julia&gt; -1 &lt;= -1
true

julia&gt; -1 &lt;= -2
false

julia&gt; 3 &lt; -0.5
false</code></pre><p>Los enteros se comparan de un modo estándar, mediante comparación de bits. Los números de punto flotante se comparan de acuerdo al <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">estándar IEEE 754</a>:</p><ul><li><p>Los números finitos son ordenados del modo habitual.</p></li><li><p>El cero positivo es igual pero no mayor que el cero negativo.</p></li><li><p><code>Inf</code> es igual a si mismo y mayor que todo excepto <code>NaN</code></p></li><li><p><code>-Inf</code> es igual a si mismo y menor que todo excepto <code>NaN</code></p></li><li><p><code>NaN</code> no es igual, mayor o menor a nadie, excepto a sí mismo.</p></li></ul><p>Este último punto es potencialmente sorprendente y, por tanto, vale la pena señalar que:</p><pre><code class="language-julia-repl">julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false</code></pre><p>y puede causar dolores de cabeza especiales con <a href="arrays.html#Arrays-1">Arrays</a>:</p><pre><code class="language-julia-repl">julia&gt; [1 NaN] == [1 NaN]
false</code></pre><p>Julia proporciona funciones adicionales para comprobar números para valores especiales, lo cuál pueden ser útil en situaciones como las comparaciones de claves hash:</p><table><tr><th>Function</th><th>Tests if</th></tr><tr><td><a href="../stdlib/base.html#Base.isequal-Tuple{Any,Any}"><code>isequal(x, y)</code></a></td><td><code>x</code> e <code>y</code> son idénticos</td></tr><tr><td><a href="../stdlib/numbers.html#Base.isfinite"><code>isfinite(x)</code></a>  </td><td><code>x</code> es un número finito</td></tr><tr><td><a href="../stdlib/numbers.html#Base.isinf"><code>isinf(x)</code></a></td><td><code>x</code> es infinito</td></tr><tr><td><a href="../stdlib/numbers.html#Base.isnan"><code>isnan(x)</code></a>    </td><td><code>x</code> no es un número</td></tr></table><p><a href="../stdlib/base.html#Base.isequal-Tuple{Any,Any}"><code>isequal()</code></a> considera los <code>NaN</code>s iguales entre sí:</p><pre><code class="language-julia-repl">julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true</code></pre><p><code>isequal()</code> también puede usarse para distinguir los ceros con signo:</p><pre><code class="language-julia-repl">julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false</code></pre><p>Las comparaciones de tipos mezclados entre enteros con signo, enteros sin signo y valores en punto flotante pueden ser complicadas. Se ha tomado mucho cuidado para asegurarse de que Julia las realiza correctamente.</p><p>Para otros tipos, <code>isequal()</code> llama por defecto a <a href="../stdlib/math.html#Base.:=="><code>==()</code></a>, así que si uno quiere definir la igualdad para sus propios tipos, solo tiene que agregar un método <a href="../stdlib/math.html#Base.:=="><code>==()</code></a>.  Si uno define suu propia función de igualdad, probablemente deba definir un método <a href="../stdlib/base.html#Base.hash"><code>hash()</code></a> correspondiente para asegurar de que <code>isequal(x,y)</code> implica <code>hash(x) == hash(y)</code>.</p><h3><a class="nav-anchor" id="chaining-comparisons-1" href="#chaining-comparisons-1">Comparaciones Encadenadas</a></h3><p>A diferencia de la mayoría de los idiomas, <a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Comparison_operators">con la notable excepción de Python</a>, las comparaciones pueden encadenarse arbitrariamente:</p><pre><code class="language-julia-repl">julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true</code></pre><p>El encadenamiento de comparaciones suele ser bastante conveniente en el código numérico. Las comparaciones encadenadas utilizan el operador <code>&amp;&amp;</code> para comparaciones escalares y el operador <a href="../stdlib/math.html#Base.:&amp;"><code>&amp;</code></a> para comparaciones elemento a elemento, lo que les permite trabajar sobre arrays. Por ejemplo, <code>0 .&lt; A .&lt; 1</code> da un array booleano cuyas entradas son <code>true</code> en posiciones en las que los elementos correspondientes de A están entre 0 y 1.</p><p>Nótese el comportamiento de evaluación de las comparaciones encadenadas:</p><pre><code class="language-julia-repl">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; v(1) &lt; v(2) &lt;= v(3)
2
1
3
true

julia&gt; v(1) &gt; v(2) &lt;= v(3)
2
1
false</code></pre><p>La expresión del medio sólo se evalúa una vez, en lugar de dos veces como lo sería si la expresión se escribiera como <code>v(1) &lt; v(2) &amp;&amp; v(2) &lt;= v(3)</code>. Sin embargo, el orden de las evaluaciones en una comparación encadenada no está definido. Se recomienda encarecidamente no utilizar expresiones que puedan tener efectos secundarios (como la impresión) en comparaciones encadenadas. Si se requieren efectos secundarios, se debe utilizar explícitamente el operador de cortocircuito <code>&amp;&amp;</code> (ver <a href="control-flow.html#short-circuit-evaluation-1">Evaluación en cortocircuito</a>).</p><h3><a class="nav-anchor" id="elementary-functions-1" href="#elementary-functions-1">Funciones Elementales</a></h3><p>Julia proporciona una colección completa de funciones matemáticas y operadores. Estas operaciones matemáticas se definen sobre una clase de valores numéricos suficientemente amplia como para permitir definiciones apropiadas para enteros, números de punto flotante, racionales y complejos, dondequiera que tales definiciones tengan sentido.</p><p>Además, estas funciones (como cualquier función de Julia) se pueden aplicar de manera &quot;vectorizada&quot; a matrices y otras colecciones con la <a href="functions.html#man-vectorized-1">sintaxis vectorizada</a> <code>f.(A)</code>, por ejemplo, sin.(A) calculará el seno de cada elemento de una matriz <code>A</code>. </p><h2><a class="nav-anchor" id="operator-precedence-1" href="#operator-precedence-1">Precedencia de Operadores</a></h2><p>Julia applies the following order of operations, from highest precedence to lowest:</p><table><tr><th>Categorí      </th><th>Operadores                                                                                       </th></tr><tr><td>Syntax</td><td><code>.</code> seguido por <code>::</code></td></tr><tr><td>Exponentiation</td><td><code>^</code></td></tr><tr><td>Fractions</td><td><code>//</code></td></tr><tr><td>Multiplication</td><td><code>* / % &amp; \</code></td></tr><tr><td>Bitshifts</td><td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td></tr><tr><td>Addition</td><td><code>+ - | ⊻</code></td></tr><tr><td>Syntax</td><td><code>: ..</code> seguido por <code>|&gt;</code></td></tr><tr><td>Comparisons</td><td><code>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</code></td></tr><tr><td>Control flow</td><td><code>&amp;&amp;</code> seguido por <code>||</code> seguido por <code>?</code></td></tr><tr><td>Assignments</td><td><code>= += -= *= /= //= \= ^= ÷= %= |= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></td></tr></table><p>Para una lista completa de cada una de las precedencias de operadores de Julia, consultar el fichero <a href="https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm"><code>src/julia-parser.scm</code></a></p><p>También puede encontrarse la precedencia numérica pra cualquier operación dada mediante la función intrínseca <code>Base.operator_precedence</code> donde el número mayor corresponde a la operación con mayor precedencia.</p><pre><code class="language-julia-repl">julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(9, 11, 15)

julia&gt; Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(1, 1)</code></pre><h2><a class="nav-anchor" id="numerical-conversions-1" href="#numerical-conversions-1">Conversiones Numéricas</a></h2><p>Julia soporta tres formas de conversión numérica, que difieren en su manejo de las conversiones inexactas.</p><ul><li><p>La notación <code>T(x)</code> o <code>convert(T,x)</code> convierte <code>x</code> a un valor de tipo <code>T</code>.</p><ul><li><p>Si <code>T</code> es un tipo en punto flotante, el resultado es el valor más cercano representable, que podría ser infinito positivo o negativo.</p></li><li><p>Si <code>T</code> es un tipo entero, se lanzará un <code>InexactError</code> si <code>x</code>no es representable por <code>T</code>.</p></li></ul></li><li><p><code>x % T</code>convierte un entero <code>x</code> a un valor de un tipo entero <code>T</code> congruente a <code>x</code> modulo <code>2^n</code>, donde <code>n</code> es el número de bits en <code>T</code>. En otras palabras, la representación binaria es truncada para ajustarse.</p></li><li><p>Las <a href="mathematical-operations.html#rounding-functions-1">Funciones de Redondeo</a> toman un tipo <code>T</code> como argumento opcional. Por ejemplo, <code>round(Int,x)</code> es una abreviatura de <code>Int(round(x))</code>.</p></li></ul><p>Los siguientes ejemplos muestran las siguientes formas:</p><pre><code class="language-julia-repl">julia&gt; Int8(127)
127

julia&gt; Int8(128)
ERROR: InexactError()
Stacktrace:
 [1] Int8(::Int64) at ./sysimg.jl:77

julia&gt; Int8(127.0)
127

julia&gt; Int8(3.14)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int8}, ::Float64) at ./float.jl:658
 [2] Int8(::Float64) at ./sysimg.jl:77

julia&gt; Int8(128.0)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int8}, ::Float64) at ./float.jl:658
 [2] Int8(::Float64) at ./sysimg.jl:77

julia&gt; 127 % Int8
127

julia&gt; 128 % Int8
-128

julia&gt; round(Int8,127.4)
127

julia&gt; round(Int8,127.6)
ERROR: InexactError()
Stacktrace:
 [1] trunc(::Type{Int8}, ::Float64) at ./float.jl:651
 [2] round(::Type{Int8}, ::Float64) at ./float.jl:337</code></pre><p>Ver <a href="conversion-and-promotion.html#conversion-and-promotion-1">Conversión y Promoción</a> para ver cómo definir tus propias conversiones y promociones.</p><h3><a class="nav-anchor" id="rounding-functions-1" href="#rounding-functions-1">Funciones de Redondeo</a></h3><table><tr><th>Función             </th><th>Descripción                      </th><th>Tipo devuelto</th></tr><tr><td><a href="../stdlib/dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round(x)</code></a></td><td>Redondea <code>x</code> al entero más cercano</td><td><code>typeof(x)</code></td></tr><tr><td><a href="../stdlib/dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}"><code>round(T, x)</code></a></td><td>Redondea <code>x</code> al entero más cercano</td><td><code>T</code></td></tr><tr><td><a href="../stdlib/dates.html#Base.floor-Tuple{Base.Dates.TimeType,Base.Dates.Period}"><code>floor(x)</code></a></td><td>Redondea <code>x</code> hacia <code>-Inf</code></td><td><code>typeof(x)</code></td></tr><tr><td><a href="../stdlib/dates.html#Base.floor-Tuple{Base.Dates.TimeType,Base.Dates.Period}"><code>floor(T, x)</code></a></td><td>Redondea <code>x</code> hacia <code>-Inf</code></td><td><code>T</code></td></tr><tr><td><a href="../stdlib/dates.html#Base.ceil-Tuple{Base.Dates.TimeType,Base.Dates.Period}"><code>ceil(x)</code></a></td><td>Redondea <code>x</code> hacia <code>+Inf</code></td><td><code>typeof(x)</code></td></tr><tr><td><a href="../stdlib/dates.html#Base.ceil-Tuple{Base.Dates.TimeType,Base.Dates.Period}"><code>ceil(T, x)</code></a></td><td>Redondea <code>x</code> hacia <code>+Inf</code></td><td><code>T</code></td></tr><tr><td><a href="../stdlib/dates.html#Base.trunc-Tuple{Base.Dates.TimeType,Type{Base.Dates.Period}}"><code>trunc(x)</code></a></td><td>Redondea <code>x</code> hacia cero</td><td><code>typeof(x)</code></td></tr><tr><td><a href="../stdlib/dates.html#Base.trunc-Tuple{Base.Dates.TimeType,Type{Base.Dates.Period}}"><code>trunc(T, x)</code></a></td><td>Redondea <code>x</code> hacia cero</td><td><code>T</code></td></tr></table><h3><a class="nav-anchor" id="division-functions-1" href="#division-functions-1">Funciones de División</a></h3><table><tr><th>Función             </th><th>Descripción                                                                                       </th></tr><tr><td><a href="../stdlib/math.html#Base.div"><code>div(x,y)</code></a></td><td>División truncada; cociente redondeado hacia cero</td></tr><tr><td><a href="../stdlib/math.html#Base.fld"><code>fld(x,y)</code></a></td><td>División <em>floored</em>; cociente redondeado hacia <code>-Inf</code></td></tr><tr><td><a href="../stdlib/math.html#Base.cld"><code>cld(x,y)</code></a></td><td>División <em>ceiling</em>; cociente redondeado hacia <code>+Inf</code></td></tr><tr><td><a href="../stdlib/math.html#Base.rem"><code>rem(x,y)</code></a>  </td><td>Resto; satisface <code>x == div(x,y)*y + rem(x,y)</code>; el signo se corresponde con el de <code>x</code>              </td></tr><tr><td><a href="../stdlib/math.html#Base.mod"><code>mod(x,y)</code></a></td><td>Módulo; satisface <code>x == fld(x,y)*y + mod(x,y)</code>; el signo se corresponde con el de <code>y</code></td></tr><tr><td><a href="../stdlib/math.html#Base.mod1"><code>mod1(x,y)</code></a></td><td>Módulo con un desplazamiento de 1; devuelve <code>r∈(0,y]</code> para <code>y&gt;0</code> o <code>r∈[y,0)</code> para <code>y&lt;0</code>, donde <code>mod(r, y) == mod(x, y)</code></td></tr><tr><td><a href="../stdlib/math.html#Base.Math.mod2pi"><code>mod2pi(x)</code></a></td><td>Módulo con respecto a 2pi; <code>0 &lt;= mod2pi(x)  &lt; 2pi</code></td></tr><tr><td><a href="../stdlib/math.html#Base.divrem"><code>divrem(x,y)</code></a></td><td>Devuelve <code>(div(x,y),rem(x,y))</code></td></tr><tr><td><a href="../stdlib/math.html#Base.fldmod"><code>fldmod(x,y)</code></a></td><td>Devuelve <code>(fld(x,y),mod(x,y))</code></td></tr><tr><td><a href="../stdlib/math.html#Base.gcd"><code>gcd(x,y...)</code></a></td><td>Máximo común divisor positivo de <code>x</code>, <code>y</code>,...</td></tr><tr><td><a href="../stdlib/math.html#Base.lcm"><code>lcm(x,y...)</code></a></td><td>Mínimo común múltiplo positivo de <code>x</code>, <code>y</code>,...</td></tr></table><h3><a class="nav-anchor" id="sign-and-absolute-value-functions-1" href="#sign-and-absolute-value-functions-1">Funciones de signo y valor absoluto</a></h3><table><tr><th>Función               </th><th>Descripción                                              </th></tr><tr><td><a href="../stdlib/math.html#Base.abs"><code>abs(x)</code></a></td><td>Un valor positivo con la magnitud de <code>x</code></td></tr><tr><td><a href="../stdlib/math.html#Base.abs2"><code>abs2(x)</code></a></td><td>El cuadrado de la magnitud de <code>x</code></td></tr><tr><td><a href="../stdlib/math.html#Base.sign"><code>sign(x)</code></a></td><td>Indica el signo de <code>x</code>, devolviendo -1, 0, o +1</td></tr><tr><td><a href="../stdlib/math.html#Base.signbit"><code>signbit(x)</code></a></td><td>Indica que si el bit de signo está en <strong>on</strong> (<code>true</code>) o en <strong>off</strong> (<code>false</code>)</td></tr><tr><td><a href="../stdlib/math.html#Base.copysign"><code>copysign(x,y)</code></a></td><td>Indica un valor con la magnitud de <code>x</code> y el signo de <code>y</code>  </td></tr><tr><td><a href="../stdlib/math.html#Base.flipsign"><code>flipsign(x,y)</code></a></td><td>Indica un valor con la magnitud de <code>x</code> y el signo de <code>x*y</code></td></tr></table><h3><a class="nav-anchor" id="powers-logs-and-roots-1" href="#powers-logs-and-roots-1">Potencias, logaritmos y raíces</a></h3><table><tr><th>Función</th><th>Descripción</th></tr><tr><td><a href="../stdlib/math.html#Base.sqrt"><code>sqrt(x)</code></a>, <code>√x</code></td><td>Raíz cuadrada de <code>x</code>                                                     </td></tr><tr><td><a href="../stdlib/math.html#Base.Math.cbrt"><code>cbrt(x)</code></a>, <code>∛x</code></td><td>Raíz cúbica de <code>x</code>                                                        </td></tr><tr><td><a href="../stdlib/math.html#Base.Math.hypot"><code>hypot(x,y)</code></a></td><td>Hipotenusa del triángulo rectángulo cuyos catetos son de longitudes <code>x</code> e <code>y</code></td></tr><tr><td><a href="../stdlib/math.html#Base.exp"><code>exp(x)</code></a>        </td><td>Función exponencial natural sobre <code>x</code>                                    </td></tr><tr><td><a href="../stdlib/math.html#Base.expm1"><code>expm1(x)</code></a></td><td>Valor exacto de <code>exp(x)-1</code> para  <code>x</code> cercano a zero</td></tr><tr><td><a href="../stdlib/math.html#Base.Math.ldexp"><code>ldexp(x,n)</code></a></td><td><code>x*2^n</code> calculado eficientemente para valores enteros de <code>n</code></td></tr><tr><td><a href="../stdlib/math.html#Base.log-Tuple{Any}"><code>log(x)</code></a></td><td>Logaritmo neperiano de <code>x</code></td></tr><tr><td><a href="../stdlib/math.html#Base.log-Tuple{Any}"><code>log(b,x)</code></a></td><td>Logaritmo en base <code>b</code> de <code>x</code></td></tr><tr><td><a href="../stdlib/math.html#Base.log2"><code>log2(x)</code></a></td><td>Logaritmo en base 2 de <code>x</code></td></tr><tr><td><a href="../stdlib/math.html#Base.log10"><code>log10(x)</code></a></td><td>Logaritmo decimal de <code>x</code></td></tr><tr><td><a href="../stdlib/math.html#Base.log1p"><code>log1p(x)</code></a></td><td>Valor exacto de <code>log(1+x)</code> para <code>x</code> cercano a cero</td></tr><tr><td><a href="../stdlib/numbers.html#Base.Math.exponent"><code>exponent(x)</code></a></td><td>Exponente binario de  <code>x</code></td></tr><tr><td><a href="../stdlib/numbers.html#Base.Math.significand"><code>significand(x)</code></a></td><td>Significando binario (alias <em>mantisa</em>) de un número en punto flotante <code>x</code></td></tr></table><p>Para una explicación de por qué son necesarias funciones como <a href="../stdlib/math.html#Base.Math.hypot"><code>hypot()</code></a>, <a href="../stdlib/math.html#Base.expm1"><code>expm1()</code></a>, and <a href="../stdlib/math.html#Base.log1p"><code>log1p()</code></a>, véase el excelente par de artículos en el blog de John D. Cook&#39;s sobre el tema: <a href="https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/">expm1, log1p, erfc</a>, e <a href="https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/">hypot</a>.</p><h3><a class="nav-anchor" id="trigonometric-and-hyperbolic-functions-1" href="#trigonometric-and-hyperbolic-functions-1">Funciones Trigonométricas e Hiperbólicas</a></h3><p>Todas las funciones trigonométricas e hiperbólicas estándar están también definidas:</p><pre><code class="language-none">sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc   atan2</code></pre><p>Son todas funciones de un solo argumento, con la excepción de  <a href="https://en.wikipedia.org/wiki/Atan2">atan2</a>, que da el ángulo en <a href="https://en.wikipedia.org/wiki/Radian">radians</a> entre el eje <em>x</em> y el punto especificado por sus argumentos, interpretado como sus coordenadas <em>x</em> e <em>y</em>.</p><p>Adicionalmente, se proporcionan <a href="../stdlib/math.html#Base.Math.sinpi"><code>sinpi(x)</code></a> e <a href="../stdlib/math.html#Base.Math.cospi"><code>cospi(x)</code></a> para cálculos más exactos de <a href="../stdlib/math.html#Base.sin"><code>sin(pi*x)</code></a> y <a href="../stdlib/math.html#Base.cos"><code>cos(pi*x)</code></a> respectivamente.</p><p>Para computar funciones trigonométricas con grados en lugar de con rdianes, añada al nombre de la función el sufijo <code>d</code>. Por ejemplo, <a href="../stdlib/math.html#Base.Math.sind"><code>sind(x)</code></a> calcula el seno de <code>x</code>, donde <code>x</code> se especifica en grados. La lista completa de funciones trigonométricas con variantes grados es:</p><pre><code class="language-none">sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd</code></pre><h3><a class="nav-anchor" id="special-functions-1" href="#special-functions-1">Funciones Especiales</a></h3><table><tr><th>Función              </th><th>Descripción</th></tr><tr><td><a href="../stdlib/math.html#Base.Math.gamma"><code>gamma(x)</code></a>  </td><td><a href="https://en.wikipedia.org/wiki/Gamma_function">Función gamma</a> en <code>x</code></td></tr><tr><td><a href="../stdlib/math.html#Base.Math.lgamma"><code>lgamma(x)</code></a></td><td>Valor exacto de <code>log(gamma(x))</code> para valores grandes de <code>x</code></td></tr><tr><td><a href="../stdlib/math.html#Base.Math.lfact"><code>lfact(x)</code></a></td><td>Valor exacto de  <code>log(factorial(x))</code> para valores grandes de  <code>x</code>; igual que <code>lgamma(x+1)</code> para <code>x &gt; 1</code>, cero en otros caso</td></tr><tr><td><a href="../stdlib/math.html#Base.Math.beta"><code>beta(x,y)</code></a>  </td><td><a href="https://en.wikipedia.org/wiki/Beta_function">Función beta</a> en <code>x,y</code></td></tr><tr><td><a href="../stdlib/math.html#Base.Math.lbeta"><code>lbeta(x,y)</code></a></td><td>Valor exacto de  <code>log(beta(x,y))</code> para valores grandes de <code>x</code> o <code>y</code></td></tr></table><footer><hr/><a class="previous" href="integers-and-floating-point-numbers.html"><span class="direction">Previous</span><span class="title">Números enteros y en punto flotante</span></a><a class="next" href="complex-and-rational-numbers.html"><span class="direction">Next</span><span class="title">Números Racionales y Complejos</span></a></footer></article></body></html>
