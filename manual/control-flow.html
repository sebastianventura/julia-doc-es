<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Control Flow · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">Introducción</a></li><li><a class="toctext" href="getting-started.html">Empezando</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="functions.html">Funciones</a></li><li class="current"><a class="toctext" href="control-flow.html">Control Flow</a><ul class="internal"><li><a class="toctext" href="#man-compound-expressions-1">Expresiones Compuestas</a></li><li><a class="toctext" href="#man-conditional-evaluation-1">Evaluación Condicional</a></li><li><a class="toctext" href="#short-circuit-evaluation-1">Evaluación en Cortocircuito</a></li><li><a class="toctext" href="#man-loops-1">Evaluación Repetida: Bucles</a></li><li><a class="toctext" href="#Manejo-de-Excepciones-1">Manejo de Excepciones</a></li><li><a class="toctext" href="#man-tasks-1">Tareas (aka Corutinas)</a></li></ul></li><li><a class="toctext" href="variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="types.html">Tipos</a></li><li><a class="toctext" href="methods.html">Métodos</a></li><li><a class="toctext" href="constructors.html">Constructores</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversión and Promoción</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="modules.html">Módulos</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Paquetes</a></li><li><a class="toctext" href="profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="control-flow.html">Control Flow</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/control-flow.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Control Flow</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="control-flow-1" href="#control-flow-1">Control Flow</a></h1><p>Julia proporciona una variedad de construcciones para control de flujo:</p><ul><li><p><a href="control-flow.html#man-compound-expressions-1">Expresiones Compuestas</a>: <code>begin</code> and <code>(;)</code>.</p></li><li><p><a href="control-flow.html#man-conditional-evaluation-1">Evaluación Condicional</a>: <code>if</code>-<code>elseif</code>-<code>else</code> and <code>?:</code> (ternary operator).</p></li><li><p><a href="control-flow.html#short-circuit-evaluation-1">Evaluación en Cortocircuito</a>: <code>&amp;&amp;</code>, <code>||</code> and chained comparisons. </p></li><li><p><a href="control-flow.html#man-loops-1">Evaluación Repetida: Bucles</a>: <code>while</code> and <code>for</code>.</p></li><li><p><a href="control-flow.html#Manejo-de-Excepciones-1">Manejo de Excepciones</a>: <code>try</code>-<code>catch</code>, <a href="../stdlib/base.html#Base.error"><code>error()</code></a> and <a href="../stdlib/base.html#Core.throw"><code>throw()</code></a>.</p></li><li><p><a href="control-flow.html#man-tasks-1">Tareas (también denominadas Coroutinas)</a>: <a href="../stdlib/parallel.html#Base.yieldto"><code>yieldto()</code></a>.</p></li></ul><p>Los cinco primeros mecanismos de control de flujo son estándar en los lenguajes de programación de alto nivel. Las <a href="../stdlib/parallel.html#tasks-1">tareas</a> no son un mecanismo tan estándar: ellas proporcionan control de flujo no local, haciendo posible conmutar entre cálculos suspendidos temporalmente. Esta es una construcción potente: tanto el manejo de excepciones como la multitarea cooperativa se implementan en Julia usando tareas. La programación diaria no suele requerir el uso de tareas, pero ciertos problemas se resuelve de forma mucho más sencilla usando este mecanismo.</p><h2><a class="nav-anchor" id="man-compound-expressions-1" href="#man-compound-expressions-1">Expresiones Compuestas</a></h2><p>Algunas veces es conveniente tener una sola expresión que lleva nueve varias subexpresiones en orden, devolviendo el valor de la última subexpresión como su valor. Hay dos construcciones en Julia que llevan a cabo este trabajo: los bloques <code>begin</code> y las cadenas <code>;</code> El valor de ambas expresiones compuestas es el de la última subexpresión. He aquí un ejemplo del bloque <code>begin</code>:</p><pre><code class="language-julia-repl">julia&gt; z = begin
           x = 1
           y = 2
           x + y
       end
3</code></pre><p>Como estas expresiones son bastante pequeñas, podrían ponerse con facilidad en una sola línea, que es donde la sintaxis encadenada <code>(;)</code> es más útil:</p><pre><code class="language-julia-repl">julia&gt; z = (x = 1; y = 2; x + y)
3</code></pre><p>Esta sintaxis es particularmente útil con la definición de función de una línea que introdujimos en <a href="faq.html#functions-1">Funciones</a>. Aunque es típico, no hay obligación de que los bloques <code>begin</code> sean multilínea o de que las cadenas de punto y coma (<code>;</code>) tengan una única línea.</p><pre><code class="language-julia-repl">julia&gt; begin x = 1; y = 2; x + y end
3

julia&gt; (x = 1;
        y = 2;
        x + y)
3</code></pre><h2><a class="nav-anchor" id="man-conditional-evaluation-1" href="#man-conditional-evaluation-1">Evaluación Condicional</a></h2><p>La evaluación condicional permite que porciones de código sean evaluadas o no evaluadas dependiendo del valor de una expresión booleana. Esta es la anatomía de la estructura de  <code>if</code>-<code>elseif</code>-<code>else</code>:</p><pre><code class="language-julia">if x &lt; y
    println(&quot;x is less than y&quot;)
elseif x &gt; y
    println(&quot;x is greater than y&quot;)
else
    println(&quot;x is equal to y&quot;)
end</code></pre><p>En el ejemplo anterior, si la condición <code>x&lt;y</code> es verdadera, entonces se evaluará el bloque correspondiente. En caso contrario se evaluará la expresión <code>x&gt;y</code>, y si esta es verdadera, se ejecutará el bloque correspondiente. Si la expresión también es falsa, se ejecutaría el bloque correspondiente al <code>else</code>. Veámoslo en acción:</p><pre><code class="language-julia-repl">julia&gt; function test(x, y)
           if x &lt; y
               println(&quot;x is less than y&quot;)
           elseif x &gt; y
               println(&quot;x is greater than y&quot;)
           else
               println(&quot;x is equal to y&quot;)
           end
       end
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</code></pre><p>Los bloques <code>elsif</code> y <code>else</code> son opcionales, y además pueden usarse tantos <code>elsif</code> como se deseen. Las expresiones condicionales del <code>if-elsif-else</code> serán evaluadas hasta que una de ellas se evalúe a <code>true</code>, después de lo cuál se evaluará el blqoue asociado, y ya no se evaluarán más expresiones condicionales.</p><p>Los bloques <code>if</code> son &quot;permeables&quot;, es decir, no introducen un ámbito local. Eso significa que las variables que se definen dentro del bloque serán visibles fuera del mismo. Por tanto, podríamos haber definido la relación <code>test</code> de antes como...</p><pre><code class="language-julia-repl">julia&gt; function test(x,y)
           if x &lt; y
               relation = &quot;less than&quot;
           elseif x == y
               relation = &quot;equal to&quot;
           else
               relation = &quot;greater than&quot;
           end
           println(&quot;x is &quot;, relation, &quot; y.&quot;)
       end
test (generic function with 1 method)

julia&gt; test(2, 1)
x is greater than y.</code></pre><p>La variable <code>relation</code> se ha declarado dentro del bloque <code>if</code>,  pero se usa fuera. Sin embargo, cuando se hace uso de este tipo de variables, hay que asegurarse de que todos los caminos de código definen un valor para la variable. La siguiente función no lo tiene en cuenta y genera un error en tiempo de ejecución.</p><pre><code class="language-julia-repl">julia&gt; function test(x,y)
           if x &lt; y
               relation = &quot;less than&quot;
           elseif x == y
               relation = &quot;equal to&quot;
           end
           println(&quot;x is &quot;, relation, &quot; y.&quot;)
       end
test (generic function with 1 method)

julia&gt; test(1,2)
x is less than y.

julia&gt; test(2,1)
ERROR: UndefVarError: relation not defined
Stacktrace:
 [1] test(::Int64, ::Int64) at ./none:7</code></pre><p>Los bloques <code>if</code> también devuelven un valor, lo que puede no parecer intuitivo para quienes proceden de otros lenguajes de programación no funcionales. Este valor no es más que el devuelto por la última instrucción en la rama que fue elegida. Por tanto:</p><pre><code class="language-julia-repl">julia&gt; x = 3
3

julia&gt; if x &gt; 0
           &quot;positive!&quot;
       else
           &quot;negative...&quot;
       end
&quot;positive!&quot;</code></pre><p>Nótese que las instrucciones condicionales muy cortas (de una línea) se suelen expresar en Julia mediante evaluación en cortocircuito, como se verá en la siguiente sección.</p><p>A diferencia de C, MATLAB, Perl, Python y Ruby (pero como en Java y en otros lenguajes tipados, más estrictos) en Julia se produce un error si el valor de una expresión condicional es algo que no sea <code>true</code> o <code>false</code>.</p><pre><code class="language-julia-repl">julia&gt; if 1
           println(&quot;true&quot;)
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context</code></pre><p>Este error indica que el condicional era de un tipo incorrecto: <a href="../stdlib/numbers.html#Core.Int64"><code>Int64</code></a> en lugar del requerido <a href="../stdlib/numbers.html#Core.Bool"><code>Bool</code></a>.</p><p>El llamado <em>operador ternario</em> (<code>?</code>) está muy relacionado con la sintaxis de <code>if-elsif-else</code>, pero se usa donde hay que hacer una elección condicional entre expresiones sencillas, a diferencia de la ejecución condicional de grandes bloques de código. Su nombre se debe a que es el único operador que toma tres operandos en la mayoría de los lenguajes de programación:</p><pre><code class="language-julia">a ? b : c</code></pre><p>La expresión <code>a</code> delante del <code>?</code> es una expresión condicional, y la operación ternaria evalúa la expresión <code>b</code> (la que está delante del símbolo <code>:</code>)  si la condición <code>a</code> es <code>true</code> o la expresión <code>c</code> si la condición <code>a</code> es <code>false</code>. Nótese que los espacios alrededor de <code>?</code> y <code>:</code> son obligatorios: una expresión como <code>a?b:c</code> no es una expresin ternaria válida (aunque se pueden utilizar saltos de línea entre los símbolos <code>?</code> y <code>:</code>).</p><p>La forma más fácil de comprender este comportamiento es ver un ejemplo. En el ejemplo anterior, la llamada a <code>println</code> es compartida por las tres ramas: la única elección real es qué cadena literal imprimir. Esto podría haberse escrito de forma más concisa usando el operador ternario. En aras de la claridad, intentemos primero la versión con dos caminos:</p><pre><code class="language-julia-repl">julia&gt; x = 1; y = 2;

julia&gt; println(x &lt; y ? &quot;less than&quot; : &quot;not less than&quot;)
less than

julia&gt; x = 1; y = 0;

julia&gt; println(x &lt; y ? &quot;less than&quot; : &quot;not less than&quot;)
not less than</code></pre><p>En los ejemplos anteriores, si <code>x &lt; y</code> es <code>true</code> se devolverá la cadena <code>&quot;less than&quot;</code> y, en caso contrario, se devolverá la cadena <code>&quot;not less than&quot;</code>. El ejemplo original, que tiene tres opciones, requeriría el uso encadenado del operador <code>?</code>:</p><pre><code class="language-julia-repl">julia&gt; test(x, y) = println(x &lt; y ? &quot;x is less than y&quot;    :
                            x &gt; y ? &quot;x is greater than y&quot; : &quot;x is equal to y&quot;)
test (generic function with 1 method)

julia&gt; test(1, 2)
x is less than y

julia&gt; test(2, 1)
x is greater than y

julia&gt; test(1, 1)
x is equal to y</code></pre><p>Para facilitar el encadenamiento, el operador <code>?</code> asocia de derecha a izquierda.</p><p>Es también significativo que, como en la construcción <code>if-elsif-else</code> las expresiones anterior y posterior al símbolo <code>:</code> sólo se evalúan si la expresión condicional es evaluada a <code>true</code> o <code>false</code>, respectivamente.</p><pre><code class="language-julia-repl">julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)

julia&gt; 1 &lt; 2 ? v(&quot;yes&quot;) : v(&quot;no&quot;)
yes
&quot;yes&quot;

julia&gt; 1 &gt; 2 ? v(&quot;yes&quot;) : v(&quot;no&quot;)
no
&quot;no&quot;</code></pre><h2><a class="nav-anchor" id="short-circuit-evaluation-1" href="#short-circuit-evaluation-1">Evaluación en Cortocircuito</a></h2><p>La evaluación en cortocircuito es bastante similar a la evaluación condicional. Este comportamiento aparece en la mayoría de los lenguajes de programación imperativos que tiene los operadores booleanos <code>&amp;&amp;</code> y <code>||</code>.  En una serie de expresiones booleanas conectadas por estos operadores, sólo se evalúa el número mínimo de expresiones necesarios para determinar el valor booleano final de la cadena completa. Explícitamente, esto significa que:</p><ul><li><p>En la expresión <code>a &amp;&amp; b</code> la subexpresión <code>b</code> sólo se evalúa si la subexpresión <code>a</code> es evaluada a <code>true</code>.</p></li><li><p>En la expresión <code>a || b</code> la subexpresión <code>b</code> sólo se evalúa si la subexpresión <code>a</code> es evaluada a <code>false</code>.</p></li></ul><p>El razonamiento es que <code>a &amp;&amp; b</code> debe ser <code>false</code> si <code>a</code> is <code>false</code>, independientemente del valor de <code>b</code> y, análogamente, el valor de <code>a || b</code> debe ser cierto si <code>a</code> es <code>true</code>, independientemente del valor de <code>b</code>. Tanto <code>&amp;&amp;</code> como <code>||</code> asocian a la derecha, pero <code>&amp;&amp;</code> tiene mayore precedencia que <code>||</code>. Es fácil experimentar con este comportamiento:</p><pre><code class="language-jldoctest">julia&gt; t(x) = (println(x); true)
t (generic function with 1 method)

julia&gt; f(x) = (println(x); false)
f (generic function with 1 method)

julia&gt; t(1) &amp;&amp; t(2)
1
2
true

julia&gt; t(1) &amp;&amp; f(2)
1
2
false

julia&gt; f(1) &amp;&amp; t(2)
1
false

julia&gt; f(1) &amp;&amp; f(2)
1
false

julia&gt; t(1) || t(2)
1
true

julia&gt; t(1) || f(2)
1
true

julia&gt; f(1) || t(2)
1
2
true

julia&gt; f(1) || f(2)
1
2
false</code></pre><p>Se puede experimentar de forma parecida con la asociatividad y la precedencia de varias combinaciones de operadores <code>&amp;&amp;</code> y <code>||</code>.</p><p>Este comportamiento se utiliza en Julia con frecuencia para formar una alternativa a instrucciones <code>if</code> muy cortas. En lugar de usar la construcción <code>if &lt;cond&gt; &amp;&amp; &lt;instrucción&gt;</code> uno puede escribir <code>&lt;cond&gt; &amp;&amp; &lt;instrucción&gt;</code> que puede leerse como <code>&lt;cond&gt;</code> y entonces <code>&lt;instrucción&gt;</code>. de forma similar, uno puede escribir <code>&lt;cond&gt; || &lt;instrucción&gt;</code>, que se leería como <code>&lt;cond&gt;</code> o sino <code>&lt;instrucción&gt;</code> en lugar de <code>if !&lt;cond&gt; || &lt;instrucción&gt;</code>.</p><p>Por ejemplo, una rutina recursiva para obtener un factorial podría ser definida como:</p><pre><code class="language-julia-repl">julia&gt; function fact(n::Int)
           n &gt;= 0 || error(&quot;n must be non-negative&quot;)
           n == 0 &amp;&amp; return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia&gt; fact(5)
120

julia&gt; fact(0)
1

julia&gt; fact(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] fact(::Int64) at ./none:2</code></pre><p>Las operaciones booleanas sin cortocircuito podrían llevarse a cabo con los operadores a nivel de bit introducidos en la sección <a href="mathematical-operations.html#mathematical-operations-1">Operaciones Matemáticas y Funciones Elementales</a>: <code>&amp;</code> y <code>|</code>. Estas son funciones normales, que suportan la sintaxis infija de los operadores, pero que siempre evalúan sus argumentos:</p><pre><code class="language-jldoctest">julia&gt; f(1) &amp; t(2)
1
2
false

julia&gt; t(1) | t(2)
1
2
true</code></pre><p>Como en el caso de las expresiones condicionales usadas en <code>if</code>, <code>elsif</code> o el operador ternario <code>?</code>, los operandos de <code>&amp;&amp;</code> y de <code>||</code> deben ser valores booleanos.  Usar un valor no booleanos en cualquier lugar distinto de la última entrada en una cadena condicional producirá un error.</p><pre><code class="language-julia-repl">julia&gt; 1 &amp;&amp; true
ERROR: TypeError: non-boolean (Int64) used in boolean context</code></pre><p>Por otra parte, cualquier tipo de expresión puede ser usada al final de una cadena condicional. Ella será evaluada y devuelta dependiendo de los condicionales precedentes:</p><pre><code class="language-julia-repl">julia&gt; true &amp;&amp; (x = (1, 2, 3))
(1, 2, 3)

julia&gt; false &amp;&amp; (x = (1, 2, 3))
false</code></pre><h2><a class="nav-anchor" id="man-loops-1" href="#man-loops-1">Evaluación Repetida: Bucles</a></h2><p>Hay dos construcciones que realizan la evaluación repetida de expresiones: el bucle <code>while</code> y el bucle <code>for</code>. He aquí un ejemplo del bucle <code>while</code>:</p><pre><code class="language-julia-repl">julia&gt; i = 1;

julia&gt; while i &lt;= 5
           println(i)
           i += 1
       end
1
2
3
4
5</code></pre><p>El bucle <code>while</code> evalúa la expresión condicional (en el ejemplo <code>i&lt;=5</code>) y, mientras que esta se evalúe a <code>true</code>, sigue evaluando el cuerpo del bucle <code>while</code>. Si la expresión se evalúa a <code>false</code> la primera vez en que se alcanza el bucle, su cuerpo nunca será evaluado.</p><p>El bucle <code>for</code> facilita la repetición. Dado que contar arriba y abajo (como en el ejemplo anterior del bucle <code>while</code>) es tan común, podemos expresar esto de una forma muy concisa con un bucle <code>for</code>:</p><pre><code class="language-julia-repl">julia&gt; for i = 1:5
           println(i)
       end
1
2
3
4
5</code></pre><p>En el ejemplo anterior, <code>1:5</code> es un objeto <code>Range</code> que representa una secuencia de números. El bucle <code>for</code> itera sobre estos valores, asignando cada uno de ellos por turno a la variable <code>i</code>.  Una distinción importante ente esta construcción (<code>for</code>) y la construcción anterior (<code>while</code>) es el ámbito durante el cuál la variable es visible. Si la variable <code>i</code> no ha sido introducida en otro ámbito, el bucle <code>for</code> la verá sólo en su interior y no posteriormente. Para demostrar esto necesitaremos una nueva sesión interactiva o usar un nombre de variable distinto:</p><pre><code class="language-julia-repl">julia&gt; for j = 1:5
           println(j)
       end
1
2
3
4
5

julia&gt; j
ERROR: UndefVarError: j not defined</code></pre><p>Ver <a href="variables-and-scoping.html#scope-of-variables-1">Ámbito de Variables</a> para una explicación detallada de los ámbitos de las variables y cómo funcionan en Julia.</p><p>En general, la construcción <code>for</code> puede iterar sobre cualquier contenedor. En estos casos, la palara clave alternativa (pero totalmente equivalente <code>in</code> o <code>∈</code> es usada en lugar de <code>=</code>, dado que hace que la lectura del código sea más clara.</p><pre><code class="language-julia-repl">julia&gt; for i in [1,4,0]
           println(i)
       end
1
4
0

julia&gt; for s ∈ [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]
           println(s)
       end
foo
bar
baz</code></pre><p>En otras secciones del manual se introducirán y discutirán varios tipos de contenedores iterables (ver, por ejemplo, <a href="arrays.html#man-multi-dim-arrays-1">Arrays Multi-dimensionales</a>).</p><p>Algunas veces es conveniente terminar la repetición de un <code>while</code> antes de chequear la condición de test o partar de iterar en un bucle <code>for</code> antes de que se alcance el final del objeto iterable. Esto puede conseguirse usando la palabra clave <code>break</code>:</p><pre><code class="language-julia-repl">julia&gt; i = 1;

julia&gt; while true
           println(i)
           if i &gt;= 5
               break
           end
           i += 1
       end
1
2
3
4
5

julia&gt; for i = 1:1000
           println(i)
           if i &gt;= 5
               break
           end
       end
1
2
3
4
5</code></pre><p>Si no existiera la palabra clave <code>break</code>, el bucle <code>while</code> anterior nunca finalizará por si mismo,  y el bucle <code>for</code> iteraría hasta 10000. Si hacemos uso de la instrucción <code>break</code> conseguiremos abandonar el bucle mucho antes.</p><p>En otras circunstancias es útil ser capaz de detener una iteración y moverse a la siguiente de forma inmediata. Para ello, se utiliza la palabra clave <code>continue</code>:</p><pre><code class="language-julia-repl">julia&gt; for i = 1:10
           if i % 3 != 0
               continue
           end
           println(i)
       end
3
6
9</code></pre><p>Este es un ejemplo un tanto artificial, ya que podríamos obtener el mismo comportamiento de forma mucho más clara negando las condiciones y colocando la llamada a <code>println</code> dentro del bloque <code>if</code>. En usos más reales hay más código que evaluar después del <code>continue</code>, y con frecuencia hay muchos puntos desde los que uno puede llamar a esta instrucción.</p><p>Podemos anidar múltiples bucles for en un solo bucle externo, formando el producto cartesiano de sus iterables:</p><pre><code class="language-julia-repl">julia&gt; for i = 1:2, j = 3:4
           println((i, j))
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)</code></pre><p>Una instrucción <code>break</code> dentro de tal bucle sale del anidamiento de bucles completo, no sólo  del más interior.</p><h2><a class="nav-anchor" id="Manejo-de-Excepciones-1" href="#Manejo-de-Excepciones-1">Manejo de Excepciones</a></h2><p>Cuando tiene lugar una condición inesperada, una funció puede ser incapaz de devolver un valor razonable al código que la invoca. En tales casos, puede ser mejor para la condición excepcional terminar el programa, imprimiendo un mensaje de error diagnóstico, o si el programador ha proporcionado código para manejar tales circunstancias excepcionales, permitiendo que el código tome la acción apropiada.</p><h3><a class="nav-anchor" id="Excepciones-predefinidas-1" href="#Excepciones-predefinidas-1">Excepciones predefinidas</a></h3><p>Las excepciones se lanzan cuando ocurre una condición inesperada. En la siguiente tabla se muestran todas la excepciones predefinidas, que interrumplen todas el flujo de control normal.</p><table><tr><th><code>Exception</code></th></tr><tr><td><a href="../stdlib/base.html#Base.ArgumentError"><code>ArgumentError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.BoundsError"><code>BoundsError</code></a></td></tr><tr><td><code>CompositeException</code></td></tr><tr><td><a href="../stdlib/base.html#Core.DivideError"><code>DivideError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.DomainError"><code>DomainError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Base.EOFError"><code>EOFError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.ErrorException"><code>ErrorException</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.InexactError"><code>InexactError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Base.InitError"><code>InitError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.InterruptException"><code>InterruptException</code></a></td></tr><tr><td><code>InvalidStateException</code></td></tr><tr><td><a href="../stdlib/base.html#Base.KeyError"><code>KeyError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Base.LoadError"><code>LoadError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.OutOfMemoryError"><code>OutOfMemoryError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.ReadOnlyMemoryError"><code>ReadOnlyMemoryError</code></a></td></tr><tr><td><a href="../stdlib/parallel.html#Base.Distributed.RemoteException"><code>RemoteException</code></a></td></tr><tr><td><a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.OverflowError"><code>OverflowError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Base.ParseError"><code>ParseError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Base.SystemError"><code>SystemError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.TypeError"><code>TypeError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.UndefRefError"><code>UndefRefError</code></a></td></tr><tr><td><a href="../stdlib/base.html#Core.UndefVarError"><code>UndefVarError</code></a></td></tr><tr><td><code>UnicodeError</code></td></tr></table><p>Por ejemplo, la función <a href="../stdlib/math.html#Base.sqrt"><code>sqrt()</code></a> lanza un <a href="../stdlib/base.html#Core.DomainError"><code>DomainError</code></a> si se aplica sobre un valor real negativo:</p><pre><code class="language-julia-repl">julia&gt; sqrt(-1)
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Int64) at ./math.jl:434</code></pre><p>Uno puede definir sus propias excepciones de la siguiente manera:</p><pre><code class="language-julia-repl">julia&gt; struct MyCustomException &lt;: Exception end</code></pre><h3><a class="nav-anchor" id="La-función-[throw()](@ref)-1" href="#La-función-[throw()](@ref)-1">La función <a href="../stdlib/base.html#Core.throw"><code>throw()</code></a></a></h3><p>Las excepciones pueden crearse explícitamente con  <a href="../stdlib/base.html#Core.throw"><code>throw()</code></a>. Por ejemplo, una función definida sólo para número no negativos podría escribirse para que lanzara un <a href="../stdlib/base.html#Core.DomainError"><code>DomainError</code></a> si el argumento es negativo:</p><pre><code class="language-julia-repl">julia&gt; f(x) = x&gt;=0 ? exp(-x) : throw(DomainError())
f (generic function with 1 method)

julia&gt; f(1)
0.36787944117144233

julia&gt; f(-1)
ERROR: DomainError:
Stacktrace:
 [1] f(::Int64) at ./none:1</code></pre><p>Notese que <a href="../stdlib/base.html#Core.DomainError"><code>DomainError</code></a> sin paréntesis no es una excepción, sino un tipo de excepción. Ella necesita ser invocada para obtener un objeto <code>Exception</code>:</p><pre><code class="language-julia-repl">julia&gt; typeof(DomainError()) &lt;: Exception
true

julia&gt; typeof(DomainError) &lt;: Exception
false</code></pre><p>Adicionalmente, algunos tipos de excepción toman uno o más argumentos que se utilizan para reportar errores.</p><pre><code class="language-julia-repl">julia&gt; throw(UndefVarError(:x))
ERROR: UndefVarError: x not defined</code></pre><p>Este mecanismo puede ser fácilmente implementado mediante los tipos de excepción personalizados que sigan la forma en que se escribe <a href="../stdlib/base.html#Core.UndefVarError"><code>UndefVarError</code></a>:</p><pre><code class="language-julia-repl">julia&gt; struct MyUndefVarError &lt;: Exception
           var::Symbol
       end

julia&gt; Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, &quot; not defined&quot;)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Cuando se escribe un mensaje de error, es preferible que la primera palabra sea minúscula. Por ejemplo,    </p><p><code>size(A) == size(B) || throw(DimensionMismatch(&quot;size of A not equal to size of B&quot;))</code></p></div></div><p>es preferible a</p><pre><code class="language-none">`size(A) == size(B) || throw(DimensionMismatch(&quot;Size of A not equal to size of B&quot;))`.</code></pre><p>Sin embargo, algunas veces tiene sentido mantener la primera letra en mayúscula, por     ejemplo, si un argumento a función es una letra mayúscula: </p><pre><code class="language-none">`size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))`.</code></pre><h3><a class="nav-anchor" id="Errores-1" href="#Errores-1">Errores</a></h3><p>La función <a href="../stdlib/base.html#Base.error"><code>error()</code></a> se usa para producir una <a href="../stdlib/base.html#Core.ErrorException"><code>ErrorException</code></a> que interrumpe el flujo de control normal.</p><p>Supóngase que deseamos detener la ejecución inmediatamente si se toma la raíz cuadrad de un número negativo. Para hacer ésto, podemos definir una versión &quot;quisquillosa&quot; de la función  <a href="../stdlib/math.html#Base.sqrt"><code>sqrt()</code></a> que lanza un error si recibe un número negativo:</p><pre><code class="language-jldoctest">julia&gt; fussy_sqrt(x) = x &gt;= 0 ? sqrt(x) : error(&quot;negative x not allowed&quot;)
fussy_sqrt (generic function with 1 method)

julia&gt; fussy_sqrt(2)
1.4142135623730951

julia&gt; fussy_sqrt(-1)
ERROR: negative x not allowed
Stacktrace:
 [1] fussy_sqrt(::Int64) at ./none:1</code></pre><p>Si <code>fussy_sqrt()</code> es invocada con un valor negativo desde otra función, en lugar de intentar continuar la ejecución de la función que la invocó, retorna inmediatamente, mostrando el mensaje de error en la sesión interactiva:</p><pre><code class="language-jldoctest">julia&gt; function verbose_fussy_sqrt(x)
           println(&quot;before fussy_sqrt&quot;)
           r = fussy_sqrt(x)
           println(&quot;after fussy_sqrt&quot;)
           return r
       end
verbose_fussy_sqrt (generic function with 1 method)

julia&gt; verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951

julia&gt; verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
Stacktrace:
 [1] fussy_sqrt at ./none:1 [inlined]
 [2] verbose_fussy_sqrt(::Int64) at ./none:3</code></pre><h3><a class="nav-anchor" id="Mensajes-de-aviso-y-de-información-1" href="#Mensajes-de-aviso-y-de-información-1">Mensajes de aviso y de información</a></h3><p>Julia también proporciona otras funciones que escriben mensajes a la salida de error estándar, pero no lanzan ninguna <code>Exception</code> y, por tanto, no interrumpen la ejecución:</p><pre><code class="language-julia-repl">julia&gt; info(&quot;Hi&quot;); 1+1
INFO: Hi
2

julia&gt; warn(&quot;Hi&quot;); 1+1
WARNING: Hi
2

julia&gt; error(&quot;Hi&quot;); 1+1
ERROR: Hi
Stacktrace:
 [1] error(::String) at ./error.jl:21</code></pre><h3><a class="nav-anchor" id="La-instrucción-try/catch-1" href="#La-instrucción-try/catch-1">La instrucción <code>try/catch</code></a></h3><p>La intrucción <code>try/ catch</code> permite comprobar a aparición de excepciones. Por ejemplo, puede escribirse una función personalizada para calcular la raíz cuadrada que invoque automáticamente al método de cálculo de la raíz de valores reales y/o complejos en función de la excepción:</p><pre><code class="language-julia-repl">julia&gt; f(x) = try
           sqrt(x)
       catch
           sqrt(complex(x, 0))
       end
f (generic function with 1 method)

julia&gt; f(1)
1.0

julia&gt; f(-1)
0.0 + 1.0im</code></pre><p>Es importante notar que en el código real que computa esta función, uno podría comparar <code>x</code> con vero en lugar de atrapar la excepción. De hcho, la opción de la excepción ees mucho más lenta de comparar y ramificar.</p><p>Las instrucciones <code>try / catch</code> también permiten salvar la excepción en una variable. En este ejemplo artificial, se calcula la raíz cuadrada del segundo elemento de <code>x</code>.  Si <code>x</code> es indexable, en caso contrario asume que <code>x</code> es un número real y devuelve su raíz cuadrada:</p><pre><code class="language-julia-repl">julia&gt; sqrt_second(x) = try
           sqrt(x[2])
       catch y
           if isa(y, DomainError)
               sqrt(complex(x[2], 0))
           elseif isa(y, BoundsError)
               sqrt(x)
           end
       end
sqrt_second (generic function with 1 method)

julia&gt; sqrt_second([1 4])
2.0

julia&gt; sqrt_second([1 -4])
0.0 + 2.0im

julia&gt; sqrt_second(9)
3.0

julia&gt; sqrt_second(-9)
ERROR: DomainError:
Stacktrace:
 [1] sqrt_second(::Int64) at ./none:7</code></pre><p>Note que el símbolo que sigue al <code>catch</code> siempre será interpretado como el nombre para la excepción, por lo que hay que tener cuidado cuando se escriben expresiones <code>try / catch</code> en una sola línea. El siguiente código no funcionará para devolver el valor de <code>x</code> en caso de error:</p><pre><code class="language-julia">try bad() catch x end</code></pre><p>En su lugar, es mejor usar un punto u coma o insertar un salto de línea después del <code>catch</code>:</p><pre><code class="language-julia">try bad() catch; x end

try bad()
catch
    x
end</code></pre><p>La cláusula <code>catch</code> no es estrictamente necesaria; cuando se omite el valor de retorno por defecto es <code>nothing</code></p><pre><code class="language-julia-repl">julia&gt; try error() end # Returns nothing</code></pre><p>La potencia de la construcción <code>try / catch</code> estriba  en la capacidad de desplegar inmediatamente un  cálculo profundamente anidado de hasta un nivel mucho más elevado en la pila de llamadas a función. Hay situacionces donde no ha ocurrido error, pero la capacidad de desplegar la pila y pasar un valor a un nivel superior es deseable. Julia proporciona las funciones   <a href="../stdlib/base.html#Base.rethrow"><code>rethrow()</code></a>, <a href="../stdlib/base.html#Base.backtrace"><code>backtrace()</code></a> and <a href="../stdlib/base.html#Base.catch_backtrace"><code>catch_backtrace()</code></a> para un manejo de errores más avanzado.</p><h3><a class="nav-anchor" id="Cláusulas-finally-1" href="#Cláusulas-finally-1">Cláusulas <code>finally</code></a></h3><p>En código que realiza cambios de estado o usa recursos como ficheros, hay típicamente un trabajo de limpieza (tal como cerrar ficheros) que necesita ser realizado cuando el código finaliza. Las excepciones complican potencialmente esta tarea, ya que pueden causar que un bloque de código salga antes de alcanzar su final normal. La palabra clave <code>finally</code> proporciona una forma de ejecutar código cuando existe un blqoue de código dado, sin preocuparse de cómo salga.</p><p>Por ejemplo, aquí podemos garantizar que un fichero abierto se cierra:</p><pre><code class="language-julia">f = open(&quot;file&quot;)
try
    # operate on file f
finally
    close(f)
end</code></pre><p>Cuando el contro deja el bloque <code>try</code> (por ejemplo, debido a un <code>return</code>, o finalizando normalmente) se ejecutará <code>close()</code>.  Si el bloque <code>try</code> saliera debido a una excepción, la excepción continuará propagándose. Un bloque <code>catch</code> puede ser combinada con <code>try</code> y <code>finally</code> también. En este caso el bloque <code>finally</code> ejecutará después de que <code>catch</code> haya manejado el error.</p><h2><a class="nav-anchor" id="man-tasks-1" href="#man-tasks-1">Tareas (aka Corutinas)</a></h2><p>Las tareas son una característica de control de flujo que permite que los cálculos sean suspendidos y continuados de una forma flexible. Esta característica es llamada algunas veces con otros nombres, tales como corrutinas simétricas, hilos de peso ligero, multitarea cooperativa o continuaciones de un disparo.</p><p>Cuando una pieza de trabajo de cómputo (en la práctica, ejecutar una función particular) es designada como tarea (<a href="../stdlib/parallel.html#Core.Task"><code>Task</code></a>), se hace posible interrumplirla intercambiándola por otra tarea. La tarea original puede ser continuada después, en el punto en que se encontraba justo cuando fue detenida. A primera vista, esto puede parecer similar a una llamada a función. Sin embargo, hay dos diferencias clave. Primero, conmutar tareas no usa ningún espacio, por lo que puede tener lugar cualquier número de intercambios de tarea sin que se consuma la pila de llamadas. Segundo, conmutar entre tareas puede ocurrir en cualquier orden, a diferencia de lo que pasa en las llamadas a función, donde la función invocada debe terminar la ejecución antes de que el control retorne a la función que la llamó.</p><p>Esta clase de flujo de control puede hacer mucho más fácil resolver ciertos problemas. En algunos problemas, las distintas piezas de trabajo requerido no están relacionadas naturalmente mediante llamadas a función: no hay un obvio llamador o llamado entre los trabajos que necesitan ser realizados. Un ejemplo es el problema del productor-consumidor, donde un procedimiento complejo está generando valores u otro procedimiento complejo los está consumiendo. El consumidor no puede simplemente llamar a la función productora para obtener un valor, debido a que el productor puede tener más valores que generar y, por tanto, podría no estar listo todavía para retornar. Con las tareas, el productor y el consumidor pueden ambos ejecutarse mientas que lo necesiten, pasando valores adelante y detrás cuando sea necesario.</p><p>Julia proporciona un mecanismo denominado &quot;canal&quot; (<a href="../stdlib/parallel.html#Base.Channel"><code>Channel</code></a> para resolver este problema. Un canal es una cola FIFO (primero en entrar, primero en salir) que puede tener múltiples tareas leyendo de y escribiendo en ella. </p><p>Definamos una tarea productor, que produce valores a través de una llamada <a href="../stdlib/parallel.html#Base.put!-Tuple{Channel,Any}"><code>put!</code></a>. Para consumir valores, necesitamos planificar un productor que ejecute una nueva tarea. Para ejecutar una tarea asociada a un canal utilizaremos un constructor especial <a href="../stdlib/parallel.html#Base.Channel"><code>Channel</code></a> que recibe como argumento una función de un argumento. Podemos entonce tomar valores repetidamente  del objeto canar mediante llamadas a <a href="../stdlib/io-network.html#Base.take!-Tuple{Base.AbstractIOBuffer}"><code>take!()</code></a>:</p><pre><code class="language-jldoctest">julia&gt; function producer(c::Channel)
           put!(c, &quot;start&quot;)
           for n=1:4
               put!(c, 2n)
           end
           put!(c, &quot;stop&quot;)
       end;

julia&gt; chnl = Channel(producer);

julia&gt; take!(chnl)
&quot;start&quot;

julia&gt; take!(chnl)
2

julia&gt; take!(chnl)
4

julia&gt; take!(chnl)
6

julia&gt; take!(chnl)
8

julia&gt; take!(chnl)
&quot;stop&quot;</code></pre><p>Una forma de pensar en este comportamiento es que el <code>producer</code> era capaz de retornar múltiples veces. Entre las llamadas a <a href="../stdlib/parallel.html#Base.put!-Tuple{Channel,Any}"><code>put!()</code></a>, la ejecución del productor se ha suspendido y el consumidor tiene el control.</p><p>El objeto <a href="../stdlib/parallel.html#Base.Channel"><code>Channel</code></a> devuelto puede ser usado como un objeto iterable dentro de un bucle <code>for</code> loop,  en cuyo caso las variable del bucle tomará todos los objetos producidos. El bucle será terminado cuando el canal se haya cerrado.</p><pre><code class="language-jldoctest">julia&gt; for x in Channel(producer)
           println(x)
       end
start
2
4
6
8
stop</code></pre><p>Note que nosotros no tuvimos que cerrar explícitamente el canal en el productor. Esto es debido a que el acto de enlazar un canal (<a href="../stdlib/parallel.html#Base.Channel"><code>Channel</code></a>) a una tarea (<a href="../stdlib/parallel.html#Core.Task"><code>Task()</code></a>) asocia el tiempo de vida abierto de un canal con el de la tarea asociada. El objeto canal se cierra automáticamente cuando la tarea termina. Podemos enlazar múltiplos canales a una tarea, y viceversa.</p><p>Aunque el constructor de <a href="../stdlib/parallel.html#Core.Task"><code>Task()</code></a> espere una función sin argumentos, el método <a href="../stdlib/parallel.html#Base.Channel"><code>Channel()</code></a> que crea un enlace entre un canal y una tarea espera una función que acepta un solo argumento de tipo <a href="../stdlib/parallel.html#Base.Channel"><code>Channel</code></a>. Un patrón común es que el productor esté parametrizado, en cuyo caso se neceesita una aplicación de función parcial para crear una <a href="functions.html#man-anonymous-functions-1">función anónima</a> con 1 ó 0 argumentos..</p><p>Para objetos <a href="../stdlib/parallel.html#Core.Task"><code>Task()</code></a> esto puede hacerse bien directamente o mediante el uso de una macro conveniente:</p><pre><code class="language-julia">function mytask(myarg)
    ...
end

taskHdl = Task(() -&gt; mytask(7))
# or, equivalently
taskHdl = @task mytask(7)</code></pre><p>Para orquestar patrones de distribucióin más avanzados, pueden usarse <a href="../stdlib/io-network.html#Base.bind"><code>bind()</code></a> y <a href="../stdlib/parallel.html#Base.schedule"><code>schedule()</code></a> en conjunción con los constructores de <a href="../stdlib/parallel.html#Core.Task"><code>Task()</code></a> y <a href="../stdlib/parallel.html#Base.Channel"><code>Channel()</code></a> para enlazar explícitamente un conjunto de canales con un conjunto de tareas productor/consumidor.</p><p>Note que en la actualidad las tareas Julia no son planificadas para que ejecuten sobre núcleos de CPU separados. Los verdaderos hilos del núcleo se discutirán en la sección <a href="parallel-computing.html#parallel-computing-1">Computación Paralela</a>.</p><h3><a class="nav-anchor" id="Operaciones-Básicas-de-Tareas-1" href="#Operaciones-Básicas-de-Tareas-1">Operaciones Básicas de Tareas</a></h3><p>Exploremos la construcción de bajo nivel  <a href="../stdlib/parallel.html#Base.yieldto"><code>yieldto()</code></a> para comprender cómo funciona la conmutación de tareas. <code>yieldto(task,value)</code> suspende la tarea actual, conmuta a la tarea especificada, y causa que la última llamada a  <a href="../stdlib/parallel.html#Base.yieldto"><code>yieldto()</code></a> devuelva el valor especificado <code>value</code>. Nótese que <a href="../stdlib/parallel.html#Base.yieldto"><code>yieldto()</code></a> para usar control de flujo estilo tarea: en lugar de llamar y retornar nos limitamos a conmutar entre las distintas tareas. Esta es la razón por la que esta característica es también llamada &quot;corrutinas simétricas&quot;. Cada tarea es conmutada usando el mismo mecanismo.</p><p><a href="../stdlib/parallel.html#Base.yieldto"><code>yieldto()</code></a> es potente, pero la mayoría de los usos de tareas no lo invocan directamente. Consideremos a qué se debe esto. Si tu conmutas desde la tarea actual, probablemente querrás volver a conmutar en otro puento, pero saber cuándo conmutar, y saber qué tarea tiene la responsabilidad de conmutar hacia atrás puede requerir una coordinación considerable. Por  ejemplo,  <a href="../stdlib/parallel.html#Base.put!-Tuple{Channel,Any}"><code>put!()</code></a> y <a href="../stdlib/io-network.html#Base.take!-Tuple{Base.AbstractIOBuffer}"><code>take!()</code></a> son operaciones bloqueantes, las cuales, cuando se usan en el contexto de los canales mantienen un estado para recordar quiénes son los consumidores.  No necesitar mantener manualmente la traza de la tarea es lo que hace que <a href="../stdlib/parallel.html#Base.put!-Tuple{Channel,Any}"><code>put!()</code></a> sea más sencilla de usar que la instrucción de bajo nivel <a href="../stdlib/parallel.html#Base.yieldto"><code>yieldto()</code></a>.</p><p>Ademas de <a href="../stdlib/parallel.html#Base.yieldto"><code>yieldto()</code></a>, se necesitan otras funciones básicas para usar las tareas de forma efectiva:</p><ul><li><p><a href="../stdlib/parallel.html#Base.current_task"><code>current_task()</code></a> devuelve una referencia a la tarea que se está ejecutando actualmente.</p></li><li><p><a href="../stdlib/parallel.html#Base.istaskdone"><code>istaskdone()</code></a> consulta para saber si una tarea ha salido.</p></li><li><p><a href="../stdlib/parallel.html#Base.istaskstarted"><code>istaskstarted()</code></a> consulta para saber si una tarea se ha iniciado ya.</p></li><li><p><a href="../stdlib/parallel.html#Base.task_local_storage-Tuple{Any}"><code>task_local_storage()</code></a> manipula un almacenamiento clave-valor específico a la tarea actual.</p></li></ul><h3><a class="nav-anchor" id="Tareas-y-Eventos-1" href="#Tareas-y-Eventos-1">Tareas y Eventos</a></h3><p>Muchos cambios de tarea ocurren como resultado de la espera de eventos tales como peticiones de E/S, y son realizados por un planificador incluido en la librería estándar. El planificador mantiene una cola de tareas ejecutables, y ejecuta un bucle de eventos que reinicia las tareas basándose en eventos externos tales como la llegada de un mensaje.</p><p>La función básica para esperar un evento es <a href="../stdlib/parallel.html#Base.wait"><code>wait()</code></a>. Hay varios objetos que implementan <a href="../stdlib/parallel.html#Base.wait"><code>wait()</code></a>; por ejemplo, dado un objeto <code>Process</code>, <a href="../stdlib/parallel.html#Base.wait"><code>wait()</code></a>  esperará a que este salga. <a href="../stdlib/parallel.html#Base.wait"><code>wait()</code></a> suele ser implícito; por ejemplo, una llamada a <a href="../stdlib/parallel.html#Base.wait"><code>wait()</code></a> puede tener lugar dentro de una llamada a  <a href="../stdlib/io-network.html#Base.read"><code>read()</code></a> para esperar a que haya datos disponibles.</p><p>En todos estos casos,  <a href="../stdlib/parallel.html#Base.wait"><code>wait()</code></a> opera últimamente sobre un objeto  <a href="../stdlib/parallel.html#Base.Condition"><code>Condition</code></a> que es responsable de encolar y reiniciar las tareas. Cuando una tarea llama a <a href="../stdlib/parallel.html#Base.wait"><code>wait()</code></a> sobre un objeto <a href="../stdlib/parallel.html#Base.Condition"><code>Condition</code></a>,la tarea es marcada como no ejecutable, añadida a la cola de esta condición y el control pasa al planificador. El planificador se ocupa entonces de preparar otra tarea para ejecución o se queda bloqueado esperando eventos externos. Si todo va bien, eventualmente un manejador de eventos llamará a  <a href="../stdlib/parallel.html#Base.notify"><code>notify()</code></a> sobre la condición, lo que causa que las tareas que estaban esperando esa condición se vuelvan ejecutables de nuevo.</p><p>Una tarea creada explícitamente llamado a  <a href="../stdlib/parallel.html#Core.Task"><code>Task</code></a> es inicialmente no conocida por el planificador. Esto nos permite gestionar las tareas manualmente usando  <a href="../stdlib/parallel.html#Base.yieldto"><code>yieldto()</code></a> si lo deseamos. Sin embargo, cuando tal tarea espera un evento, sigue siendo reiniciada cuando el evento tiene lugar, como podría esperarse. Es también posible hacer que el planificador ejecute una tarea siempre que pueda, sin esperar ningún evento necesariamente. Esto se hace llamando a <a href="../stdlib/parallel.html#Base.schedule"><code>schedule()</code></a>, o usando las macros <a href="../stdlib/parallel.html#Base.@schedule"><code>@schedule</code></a> o <a href="../stdlib/parallel.html#Base.@async"><code>@async</code></a> macros (ver <a href="parallel-computing.html#parallel-computing-1">Parallel Computing</a> para más detalles).</p><h3><a class="nav-anchor" id="Estados-de-una-Tarea-1" href="#Estados-de-una-Tarea-1">Estados de una Tarea</a></h3><p>La tareas tienen un campo <code>state</code> que describe su estado de ejecucoión. El estado de una tarea es  uno de los siguientes símbolos:</p><table><tr><th>Symbol</th><th>Meaning</th></tr><tr><td><code>:runnable</code></td><td>Ejecutando actualmente, o disponible para ser intercambiado</td></tr><tr><td><code>:waiting</code></td><td>Bloqueado esperando un evento específico</td></tr><tr><td><code>:queued</code></td><td>En la cola de ejecución del planiticador a punto de ser reiniciado</td></tr><tr><td><code>:done</code></td><td>Finalizada su ejecucción con éxito</td></tr><tr><td><code>:failed</code></td><td>Finalizado con alguna excepción no atrapada</td></tr></table><footer><hr/><a class="previous" href="functions.html"><span class="direction">Previous</span><span class="title">Funciones</span></a><a class="next" href="variables-and-scoping.html"><span class="direction">Next</span><span class="title">Ámbito de las variables</span></a></footer></article></body></html>
