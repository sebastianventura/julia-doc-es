var documenterSearchIndex = {"docs": [

{
    "location": "index.html#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": ""
},

{
    "location": "index.html#Julia-Documentation-1",
    "page": "Home",
    "title": "Julia Documentation",
    "category": "section",
    "text": ""
},

{
    "location": "index.html#Manual-1",
    "page": "Home",
    "title": "Manual",
    "category": "section",
    "text": "Introducción\nEmpezando\nVariables\nNúmeros Enteros y en Punto Flotante\nOperaciones Matemáticas y Funciones Elementales\nNúmeros Complejos y Racionales\nCadenas\nFunciones\nControl de Flujo\nÁmbito de las Variables\nTipos\nMétodos\nConstructores\nConversión y Promoción\nInterfaces\nMódulos\nDocumentación\nMetaprogramación\nArrays Multidimensionales\nÁlgebra Lineal\nRedes y Flujos\nComputación Paralela\nDate and DateTime\nEjecutando Programas Externos\nInvocando Código C y Fortran\nManejando Variaciones del Sistema Operativo\nVariables de Entorno\nInteractuando con Julia\nEmbebiendo Julia\nPaquetes\nCreando Perfiles\nTazas de Pila\nConsejos de Rendimiento\nConsejos relacionados con Workflow\nGuía de Estilo\nFrequently Asked Questions\nDiferencias Notables con Otros Lenguajes\nEntrada Unicode"
},

{
    "location": "index.html#Biblioteca-Estándar-1",
    "page": "Home",
    "title": "Biblioteca Estándar",
    "category": "section",
    "text": "Esenciales\nColecciones y Estructuras de Datos\nMatemáticas\nNúmeros\nCadenas\nArrays\nTareas y Computación Paralela\nÁlgebra Lineal\nConstantes\nSistema de Ficheros\nE/S y Redes\nPuntuación\nOrdenación y Funciones Relacionadas\nFunciones del Gestor de Paquetes\nFechas y Hora\nUtilidades de Iteración\nRealizando Pruebas Unitarias\nInterfaz C\nLibrería Estándar C\nEnlazador Dinámico\nRealización de Perfiles\nStackTraces\nSoporte SIMD"
},

{
    "location": "index.html#Documentación-para-Desarrolladores-1",
    "page": "Home",
    "title": "Documentación para Desarrolladores",
    "category": "section",
    "text": "Reflexión e Introspección\nDocumentación de los Interiores de Julia\nInitialization of the Julia runtime\nASTs de Julia\nMás sobre Tipos\nMemory layout of Julia Objects\nEvaluación de Código Julia\nConvenios de Llamada\nHigh-level Overview of the Native-Code Generation Process\nFunciones Julia\nBase.Cartesian\nHablando al Compilador (El Mecanismo :meta)\nSubArrays\nConstrucción de Imagen del Sistema\nTrabajando con LLVM\nprintf() and stdio in the Julia runtime\nComprobación de Límites\nProper maintenance and care of multi-threading locks\nArrays with custom indices\nBase.LibGit2\nModule loading\nDesarrollo/Depuración de Código C de Julia\nReporting and analyzing crashes (segfaults)\ngdb debugging tips\nUsing Valgrind with Julia\nSanitizer support"
},

{
    "location": "manual/introduction.html#",
    "page": "Introducción",
    "title": "Introducción",
    "category": "page",
    "text": ""
},

{
    "location": "manual/introduction.html#man-introduction-1",
    "page": "Introducción",
    "title": "Introducción",
    "category": "section",
    "text": "La computación científica ha requerido tradicionalmente el máximo rendimiento, aunque los expertos de los distintos dominios se hayan movido en gran parte a los lenguajes dinámicos, más lentos, para el trabajo diario. Creemos que hay muchas buenas razones para preferir lenguajes dinámicos para estas aplicaciones, y no esperamos que su uso disminuya. Afortunadamente, el diseño de lenguajes y las técnicas de compilación modernos permiten casi eliminar el compromiso del rendimiento y proporcionar un solo entorno suficientemente productivo para la creación de prototipos y suficientemente eficiente para implementar aplicaciones de alto rendimiento. El lenguaje de programación de Julia cumple este papel: es un lenguaje dinámico y flexible, apropiado para la computación científica y numérica, con un rendimiento comparable al de los lenguajes tradicionales de tipo estático.Debido a que el compilador de Julia es diferente de los intérpretes utilizados para lenguajes como Python o R, podría parecer al principio que el rendimiento de Julia no es intuitivo. Si encuentra que algo es lento, le recomendamos que lea la sección Consejos de Rendimiento antes de intentar otra cosa. Una vez que entienda cómo funciona Julia, será fácil escribir código casi tan rápido como el código C.Julia ofrece tipado opcional, despacho múltiple, y buen desempeño, logrado usando inferencia de tipos y compilación just-in-time (JIT), implementada usando LLVM. Es multi-paradigma, combinando características de programación imperativa, funcional y orientada a objetos. Julia proporciona facilidad y expresividad para la computación numérica de alto nivel, de la misma manera que idiomas como R, MATLAB y Python, pero también soporta la programación general. Para conseguirlo, Julia se basa en el linaje de los lenguajes de programación matemáticos, pero también toma prestado mucho de los lenguajes dinámicos populares, incluyendo Lisp, Perl, Python, Lua, y Ruby.Las diferencias más significativas de Julia de los lenguajes dinámicos típicos son:El lenguaje básico impone muy poco; La biblioteca estándar se ha escrito en el propio Julia, incluyendo operaciones primitivas como la aritmética entera.\nUn lenguaje enriquecido de tipos para construir y describir objetos, que también se puede utilizar opcionalmente para hacer declaraciones de tipo.\nLa capacidad de definir el comportamiento de la función a través de muchas combinaciones de tipos de argumentos mediante el despacho múltiple.\nGeneración automática de código eficiente y especializado para diferentes tipos de argumentos.\nBuen rendimiento, aproximándose al de los lenguajes compilados estáticamente como C.Aunque a veces se dice de los lenguajes dinámicos que son lenguajes \"sin tipo\", ésto no es cierto en absoluto: cada objeto, ya sea primitivo o definido por el usuario, tiene un tipo. La falta de declaraciones de tipos en la mayoría de los lenguajes dinámicos, sin embargo, significa que uno no puede instruir al compilador acerca de los tipos de valores y, a menudo, no puede hablar explícitamente de tipos en absoluto. En lenguajes estáticos, por otro lado, aunque uno puede -y normalmente debe- anotar tipos para el compilador, los tipos sólo existen en tiempo de compilación y no pueden ser manipulados o expresados en tiempo de ejecución. En Julia, los tipos son objetos en tiempo de ejecución y también se pueden utilizar para transmitir información al compilador.Aunque el programador casual no necesita usar explícitamente los tipos o el despacho múltiple, ellas son las características centrales unificadoras de Julia: las funciones se definen en diferentes combinaciones de tipos de argumentos y se aplican despachando a la definición concordante más específica. Este modelo se ajusta bien a la programación matemática, donde no es natural que el primer argumento \"posea\" una operación como en la programación orientada a objetos tradicional. Los operadores son sólo funciones con notación especial - para ampliar la adición a nuevos tipos de datos definidos por el usuario, se definen nuevos métodos para la función +. El código existente se aplica sin problemas a los nuevos tipos de datos.En parte debido a la inferencia de tipo en tiempo de ejecución (aumentada por anotaciones de tipos opcionales), y en parte debido a enfoque muy basado en el rendimiento desde el inicio del proyecto, la eficiencia computacional de Julia supera la de otros lenguajes dinámicos e incluso rivaliza con la de lenguajes de compilación estática. Para los problemas numéricos a gran escala, la velocidad siempre ha sido, continúa siendo, y probablemente siempre será crucial: la cantidad de datos procesados se ha mantenido fácilmente al ritmo de la Ley de Moore durante las últimas décadas.Julia tiene como objetivo crear una combinación sin precedentes de facilidad de uso, potencia y eficiencia en un solo lenguaje de programación. Además de lo anterior, algunas ventajas de Julia sobre sistemas comparables son:Libre y de código abierto (con licencia MIT)\nLos tipos definidos por el usuario son tan rápidos y compactos como los predefinidos.\nNo hay necesidad de vectorizar código para el rendimiento; el código devectorizado es rápido\nDiseñado para el paralelismo y la computación distribuida.\nHilos \"verdes\" de peso ligero (coroutinas).\nSistema de tipos discreto pero potente.\nConversiones y promociones elegantes y extensibles para números y otros tipos.\nSoporte eficiente para Unicode, incluyendo pero no limitado a UTF-8Llamada a las funciones C directamente (no se necesitan envolturas o API especiales).\nPoderosas capacidades tipo shell para administrar otros procesos.\nMacros similares a Lisp y otras instalaciones de metaprogramación."
},

{
    "location": "manual/getting-started.html#",
    "page": "Empezando",
    "title": "Empezando",
    "category": "page",
    "text": ""
},

{
    "location": "manual/getting-started.html#getting-started-1",
    "page": "Empezando",
    "title": "Empezando",
    "category": "section",
    "text": "La instalación de Julia es sencilla, ya sea utilizando binarios precompilados o compilando desde la fuente. Descargue e instale Julia siguiendo las instrucciones disponibles en https://julialang.org/downloads/.La forma más fácil de aprender y experimentar con Julia es iniciando una sesión interactiva (también conocida como read-eval-print loop o \"REPL\") haciendo doble clic en el ejecutable de Julia o ejecutando julia desde la línea de mandatos:$ julia\n               _\n   _       _ _(_)_     |  A fresh approach to technical computing\n  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org\n   _ _   _| |_  __ _   |  Type \"?help\" for help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 0.5.0-dev+2440 (2016-02-01 02:22 UTC)\n _/ |\\__'_|_|_|\\__'_|  |  Commit 2bb94d6 (11 days old master)\n|__/                   |  x86_64-apple-darwin13.1.0\n\njulia> 1 + 2\n3\n\njulia> ans\n3Para salir de la sesión interactiva, escriba ^D (la tecla de control junto con la tecla D) o escriba quit(). Cuando se ejecuta en modo interactivo, Julia muestra un banner y solicita al usuario la entrada.  Una vez que el usuario ha introducido una expresión completa, como 1 + 2, y pulsa Enter, la sesión  interactiva evalúa la expresión y muestra su valor. Si se introduce una expresión en una sesión interactiva  con un punto y coma al final, no se muestra su valor. La variable ans está enlazada al valor de la última  expresión evaluada, sea mostrada o no. La variable ans sólo está enlazada a las sesiones interactivas,  no cuando el código Julia se ejecuta de otras maneras.Para evaluar expresiones escritas en un archivo de origen file.jl, escriba include (\"file.jl\").Para ejecutar código en un archivo de forma no interactiva, puede darlo como el primer argumento al mandato Julia:$ julia script.jl arg1 arg2...Como indica el ejemplo, los siguientes argumentos de línea de mandatos de Julia se toman como argumentos de  línea de mandatos al programa script.jl del programa, pasados a través de la constante global ARGS. El  nombre del propio script se pasa como la variable global PROGRAM_FILE. Tenga en cuenta que ARGS  también se establece cuando se da el código de script usando la opción -e en la línea de órdenes (vea  la salida de ayuda de julia más abajo) pero PROGRAM_FILE estará vacío. Por ejemplo, para imprimir  los argumentos que se le dan a un script, puede hacer esto:$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar\n\nfoo\nbarO puede poner ese código en un script y ejecutarlo:$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl\n$ julia script.jl foo bar\nscript.jl\nfoo\nbarEl delimitador -- puede usarse para separar argumentos en línea de mandatos al fichero del  script a los argumentos de Julia:$ julia --color=yes -O -- foo.jl arg1 arg2..Julia se puede iniciar en modo paralelo con las opciones -p o --machinefile. -p n pondrá en marcha un n procesos worker adicionales, mientras que --machinefile archivo iniciará un worker para cada línea en el archivo de archivo. Las máquinas definidas en el archivo deben ser accesibles a través de un login ssh sin contraseña, con Julia instalado en la misma ubicación que el host actual. Cada definición de máquina toma la forma [count *] [user @] host [: port] [bind_addr [: port]]. El valor por defecto de user es el usuario actual, y el de port el puerto ssh estándar. Las variables opcionales bind_to bind_addr [: port] especifican la dirección IP y el puerto que otros workers deberían usar para conectarse a este worker.Si tiene código que desea ejecutar cada vez que Julia se inicia, puede ponerlo en ~/.juliarc.jl:$ echo 'println(\"Greetings! 你好! 안녕하세요?\")' > ~/.juliarc.jl\n$ julia\nGreetings! 你好! 안녕하세요?\n\n...Hay varias formas de ejecutar el código Julia y proporcionar opciones, similares a las disponibles para los programas perl y `ruby:julia [switches] -- [programfile] [args...]\n -v, --version             Display version information\n -h, --help                Print this message\n\n -J, --sysimage <file>     Start up with the given system image file\n --precompiled={yes|no}    Use precompiled code from system image if available\n --compilecache={yes|no}   Enable/disable incremental precompilation of modules\n -H, --home <dir>          Set location of `julia` executable\n --startup-file={yes|no}   Load ~/.juliarc.jl\n --handle-signals={yes|no} Enable or disable Julia's default signal handlers\n\n -e, --eval <expr>         Evaluate <expr>\n -E, --print <expr>        Evaluate and show <expr>\n -L, --load <file>         Load <file> immediately on all processors\n\n -p, --procs {N|auto}      Integer value N launches N additional local worker processes\n                           \"auto\" launches as many workers as the number of local cores\n --machinefile <file>      Run processes on hosts listed in <file>\n\n -i                        Interactive mode; REPL runs and isinteractive() is true\n -q, --quiet               Quiet startup (no banner)\n --color={yes|no}          Enable or disable color text\n --history-file={yes|no}   Load or save history\n\n --compile={yes|no|all|min}Enable or disable JIT compiler, or request exhaustive compilation\n -C, --cpu-target <target> Limit usage of cpu features up to <target>\n -O, --optimize={0,1,2,3}  Set the optimization level (default is 2 if unspecified or 3 if specified as -O)\n -g, -g <level>            Enable / Set the level of debug info generation (default is 1 if unspecified or 2 if specified as -g)\n --inline={yes|no}         Control whether inlining is permitted (overrides functions declared as @inline)\n --check-bounds={yes|no}   Emit bounds checks always or never (ignoring declarations)\n --math-mode={ieee,fast}   Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)\n\n --depwarn={yes|no|error}  Enable or disable syntax and method deprecation warnings (\"error\" turns warnings into errors)\n\n --output-o name           Generate an object file (including system image data)\n --output-ji name          Generate a system image data file (.ji)\n --output-bc name          Generate LLVM bitcode (.bc)\n --output-incremental=no   Generate an incremental output file (rather than complete)\n\n --code-coverage={none|user|all}, --code-coverage\n                           Count executions of source lines (omitting setting is equivalent to \"user\")\n --track-allocation={none|user|all}, --track-allocation\n                           Count bytes allocated by each source line"
},

{
    "location": "manual/getting-started.html#Resources-1",
    "page": "Empezando",
    "title": "Resources",
    "category": "section",
    "text": "Además de este manual, hay otros recursos que pueden ayudar a los usuarios nuevos cuanto empiezan con Julia:Julia and IJulia cheatsheet\nLearn Julia in a few minutes\nLearn Julia the Hard Way\nJulia by Example\nHands-on Julia\nTutorial for Homer Reid's numerical analysis class\nAn introductory presentation\nVideos from the Julia tutorial at MIT\nYouTube videos from the JuliaCons"
},

{
    "location": "manual/variables.html#",
    "page": "Variables",
    "title": "Variables",
    "category": "page",
    "text": ""
},

{
    "location": "manual/variables.html#variables-1",
    "page": "Variables",
    "title": "Variables",
    "category": "section",
    "text": "Una variable en Julia es un nombre asociado a un valor. Esto es útil cuando pretendemos almacenar un valor (como el que obtenemos después de un cálculo) para un uso posterior. Por ejemplo:# Assign the value 10 to the variable x\njulia> x = 10\n10\n\n# Doing math with x's value\njulia> x + 1\n11\n\n# Reassign x's value\njulia> x = 1 + 1\n2\n\n# You can assign values of other types, like strings of text\njulia> x = \"Hello World!\"\n\"Hello World!\"Julia proporciona un sistema muy flexible para nombrar las variables. Los nombres de variable son sensibles a las mayúsculas, y no tienen significado semántico (es decir, que el lenguaje no trata de modo distinto  a las variables basándose en sus nombres).julia> x = 1.0\n1.0\n\njulia> y = -3\n-3\n\njulia> Z = \"My string\"\n\"My string\"\n\njulia> customary_phrase = \"Hello world!\"\n\"Hello world!\"\n\njulia> UniversalDeclarationOfHumanRightsStart = \"人人生而自由，在尊严和权利上一律平等。\"\n\"人人生而自由，在尊严和权利上一律平等。\"Los nombres Unicode (usando codificación UTF-8) están permitidos:julia> δ = 0.00001\n1.0e-5\n\njulia> 안녕하세요 = \"Hello\"\n\"Hello\"En el REPL y otros entornos de edición Julia se pueden introducir símbolos matemáticos Unicode usando la notación de Latex precedido de backslash y seguido de un tabulador. Por ejemplo, podemos crear el nombre de variable δ tecleando \\delta-tab, o incluso el nombre α̂₂ tecleando \\alpha-tab-\\hat- tab-\\_2-tab. (Si encuentras un símbolo en algun sitio, como por ejemplo en el código de alguien, y no sabes como escribirlo, el REPL te ayudará: solamente teclea ? y luego pega el símbolo.)Julia también permite redefinir constantes predefinidas su fuera necesario:julia> pi\nπ = 3.1415926535897...\n\njulia> pi = 3\nWARNING: imported binding for pi overwritten in module Main\n3\n\njulia> pi\n3\n\njulia> sqrt(100)\n10.0\n\njulia> sqrt = 4\nWARNING: imported binding for sqrt overwritten in module Main\n4Sin embargo, esto no se recomienta para evitar una potencial confusión."
},

{
    "location": "manual/variables.html#Nombres-de-Variables-Permitidos-1",
    "page": "Variables",
    "title": "Nombres de Variables Permitidos",
    "category": "section",
    "text": "Los nombres de variable deben comenzar con una letra (A-Z o a-z), símblo de subrayado, o un subconjunto de puntos Unicode mayores que 00A0. En particular, se permiten las categorías de caracteres Unicode Lu/Ll/Lt/Lm/Lo/Nl (letras), Sc/So (monedas y otros símbolos), y otros pocos caracteres (por ejemplo, un subconjunto de los símbolos matemáticos Sm). Entre los caracteres subsecuentes se pueden también incluir ! y los dígitos (0-9 y otros caracteres en las categorías Nd/No), así como otros puntos de código Unicode: diacríticas y otras marcas de modificación (categorías Mn/Mc/Me/Sk), algunos conectores de puntuación (category Pc),  primos, y otros cuantos caracteres.Los operadores como + son también identificadores válidos, pero son analizados sintácticamente de un modo especial. En algunos contextos, los operadores pueden ser usados justo como variables; por ejemplo (+) se refiere a la función de suma, y (+) = f la reasignará. La mayoría de los operadores infijos Unicode (en la categoría Sm), tal como ⊕, son analizados como operadores infijos y están disponibles para métodos definidos por el usuario (por ejemplo, podemos usar const ⊗ = kron para definir ⊗ como un operador infijo producto de Kronecker).Los únicos nombres específicamente prohibidos para nombres de variables son los nombres de las instrucciones predefinidas:julia> else = false\nERROR: syntax: unexpected \"else\"\n\njulia> try = \"No\"\nERROR: syntax: unexpected \"=\"Algunos caracteres Unicode son considerados equivalentes en identificadores. Las distintas formas de introducir caracteres que combinan en Unicode (por ejemplo, acentos) son tratadas como equivalentes (específicamente los identificadores Julia son normalizados NFC). Los caracteres Unicode ɛ (U+025B: Latin small letter open e) y µ (U+00B5: micro sign) son tratados como las letras griegas correspondientes, debido que las primeras son más fácilmente accesibles via alguos métodos de entrada."
},

{
    "location": "manual/variables.html#Convenciones-de-Estilo-1",
    "page": "Variables",
    "title": "Convenciones de Estilo",
    "category": "section",
    "text": "Aunque Julia impone pocas restricciones a los nombres válidos, se ha vuelto útil adoptar las  siguientes convenciones:Los nombres de variable van en minúsculas.\nLa separación enre palabras puede indicarse mediante el símbolo de guión bajo, aunque se desaconseja  su uso a menos que los símbolos sean difíciles de leer.\nLos nombres de tipos y módulos comienzan con mayúscula y la separación entre palabras se representa  con el formato camel case.\nLos nombres de funciones y macros van en minúscula, sin símbolos de guión bajo.\nLas funciones que escriben en sus argumentos tienen nombres que finalizan con el símbolo de admiración !. Estas suelen ser llamadas funciones \"mutadoras\" o funciones \"in-place\" debido a que pretenden producir  cambios en sus argumentos después de que la función sea invocada, no solo devolver un valor.Para más información sobre convenciones de estilo, ver la Guía de Estilo."
},

{
    "location": "manual/integers-and-floating-point-numbers.html#",
    "page": "Números enteros y en punto flotante",
    "title": "Números enteros y en punto flotante",
    "category": "page",
    "text": ""
},

{
    "location": "manual/integers-and-floating-point-numbers.html#integers-and-floating-point-numbers-1",
    "page": "Números enteros y en punto flotante",
    "title": "Números enteros y en punto flotante",
    "category": "section",
    "text": "Los valores enteros y punto flotante son los bloques constructivos básicos de la aritmética y la computación. Las representaciones predefinidas para estos valores se denominan tipos primitivos, mientras que las reprentaciones de números enteros y en punto flotante como valores inmediatos en código se conocen como literales numéricos. Por ejemplo, 1 es un literal entero, mientras que 1.0 es un literal en punto flotante; sus representaciones binarias en memoria como objetos son los tipos primitivos.Julia proporciona un amplio rango de tipos primitivos numéricos, y un complemento complemento de operadores aritméticos y de bits así como funciones matemáticas estándar definidas sobre ellos. Los operadores establecen una correspondencia enre los tipos numéricos y las operaciones que son soportadas de forma nativa sobre los ordenadores modernos, permitiendo a Julia sacar plena ventaja de los recursos computacionales. Además, Julia proporciona soporte software para aritmética de precisión arbitraria que puede manejar operaciones sobre valores numéricos que no puede ser representada de forma efectiva en representaciones hardware nativas, pero al coste de un rendimiento relativamente menor.Los tipos primitivos de Julia son los siguientes:Tipos enteros:Tipo             Signo? Número de bits Valor más pequeño Valor más grande\nInt8 ✓ 8 -2^7 2^7 - 1\nUInt8   8 0 2^8 - 1\nInt16 ✓ 16 -2^15 2^15 - 1\nUInt16   16 0 2^16 - 1\nInt32 ✓ 32 -2^31 2^31 - 1\nUInt32   32 0 2^32 - 1\nInt64 ✓ 64 -2^63 2^63 - 1\nUInt64   64 0 2^64 - 1\nInt128 ✓ 128 -2^127 2^127 - 1\nUInt128   128 0 2^128 - 1\nBool N/A 8 false (0) true (1)Tipos en punto flotante:Tipo             Precisión                                                                       Número de bits\nFloat16 media 16\nFloat32 sencilla 32\nFloat64 doble 64Adicionalmente, se ha construído un soporte completo para Números Complejos y Racionales encima de estos tipos primitivos. Todos los tipos primitivos interoperan de forma natural sin tener que realizar conversiones específicas, gracias a un sistema de promoción de tipos flexible y extensible por el usuario."
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Enteros-1",
    "page": "Números enteros y en punto flotante",
    "title": "Enteros",
    "category": "section",
    "text": "Los literales enteros se representan del modo estándar:julia> 1\n1\n\njulia> 1234\n1234El tipo por defecto para un literal entero depende de si el sistema de trabajo tiene una aquitectura de 32 o de 64 bits:# 32-bit system:\njulia> typeof(1)\nInt32\n\n# 64-bit system:\njulia> typeof(1)\nInt64La variable interna de Julia Sys.WORD_SIZE indica si el sistema en el que trabajamos es de 32 bits o de 64 bits:# 32-bit system:\njulia> Sys.WORD_SIZE\n32\n\n# 64-bit system:\njulia> Sys.WORD_SIZE\n64Julia también define los tipos Int y UInt, que son aliases para los tipos enteros nativos del sistema con y sin signo:# 32-bit system:\njulia> Int\nInt32\njulia> UInt\nUInt32\n\n# 64-bit system:\njulia> Int\nInt64\njulia> UInt\nUInt64Los literales enteros mayores que no pueden ser representados usando sólo 32 bits pero pueden ser representados en 64 bits se crean como enteros de 64 bits, independientemente del tipo que tenga el sistema por defecto:# 32-bit or 64-bit system:\njulia> typeof(3000000000)\nInt64Los enteros sin signo se introducen y se muestran usando el prefijo 0x y los dígitos hexadecimales 0-9a-f (los dígitos capitalizados A-F también funcionan para la entrada). El tamaño de un valor sin signo está determinado por el número de dígitos hexadecimales usados:julia> 0x1\n0x01\n\njulia> typeof(ans)\nUInt8\n\njulia> 0x123\n0x0123\n\njulia> typeof(ans)\nUInt16\n\njulia> 0x1234567\n0x01234567\n\njulia> typeof(ans)\nUInt32\n\njulia> 0x123456789abcdef\n0x0123456789abcdef\n\njulia> typeof(ans)\nUInt64Este comportamiento está basado en la observación de que cuando uno usa literales hexadecimales sin signo para valores enteros, se los suele utilizar para representar una secuencia de bytes numéricos fijos en lugar de un valor entero.Recuerde que la variable ans contiene el valor de la última expresión evaluada en una sesión interactiva. Esto no ocurre cuando el código Julia se ejecuta de otra forma.Los literales binarios y octales también están soportados:julia> 0b10\n0x02\n\njulia> typeof(ans)\nUInt8\n\njulia> 0o10\n0x08\n\njulia> typeof(ans)\nUInt8Los valores máximo y mínimo de tipos primitivos numéricos representables como enteros vienen dados por las funciones  typemin() y typemax():julia> (typemin(Int32), typemax(Int32))\n(-2147483648, 2147483647)\n\njulia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]\n           println(\"$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]\")\n       end\n   Int8: [-128,127]\n  Int16: [-32768,32767]\n  Int32: [-2147483648,2147483647]\n  Int64: [-9223372036854775808,9223372036854775807]\n Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]\n  UInt8: [0,255]\n UInt16: [0,65535]\n UInt32: [0,4294967295]\n UInt64: [0,18446744073709551615]\nUInt128: [0,340282366920938463463374607431768211455]Los valores devueltos por typemin() y typemax() siempre son del tipo de argumento dado. (La expresión anterior utiliza varias características que todavía tenemos que introducir, incluyendo bucles for, Cadenas, e Interpolación, pero debería ser lo suficientemente fácil de entender para los usuarios con cierta experiencia en programación).)"
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Comportamiento-ante-el-Desbordamiento-1",
    "page": "Números enteros y en punto flotante",
    "title": "Comportamiento ante el Desbordamiento",
    "category": "section",
    "text": "En Julia, superar el valor máximo representable de un tipo dado da como resultado un comportamiento envolvente:julia> x = typemax(Int64)\n9223372036854775807\n\njulia> x + 1\n-9223372036854775808\n\njulia> x + 1 == typemin(Int64)\ntrueAsí, la aritmética con enteros de Julia es en realidad una forma de aritmética modular. Esto refleja las características de la aritmética subyacente de números enteros tal como se implementa en las computadoras modernas. En aplicaciones donde es posible el desbordamiento, es esencial comprobar explícitamente el envolvente producido por el desbordamiento. De lo contrario, se recomienda el tipo BigInt en Aritmética de Precisión Arbitraria."
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Errores-de-división-1",
    "page": "Números enteros y en punto flotante",
    "title": "Errores de división",
    "category": "section",
    "text": "La división entera (la función div) tiene dos casos excepcionales: división por cero, y dividir el número  negativo más bajo  (typemin()) por -1. Ambos casos lanzan un DivideError. El resto y las funciones de módulo (rem y mod) lanzan un  DivideError cuando su segundo argumento es cero."
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Números-en-Punto-Flotante-1",
    "page": "Números enteros y en punto flotante",
    "title": "Números en Punto Flotante",
    "category": "section",
    "text": "Los literales de números en punto flotante son representados en las formas estándar:julia> 1.0\n1.0\n\njulia> 1.\n1.0\n\njulia> 0.5\n0.5\n\njulia> .5\n0.5\n\njulia> -1.23\n-1.23\n\njulia> 1e10\n1.0e10\n\njulia> 2.5e-4\n0.00025Los resultados anteriores son todos valores Float64. Los valores literales Float32 pueden introducirse escribiendo f en lugar de e:julia> 0.5f0\n0.5f0\n\njulia> typeof(ans)\nFloat32\n\njulia> 2.5f-4\n0.00025f0Los valores pueden ser convertidos a Float32 fácilmente:julia> Float32(-1.5)\n-1.5f0\n\njulia> typeof(ans)\nFloat32También son válidos los literales de punto flotante en formato hexadecimal, pero sólo como valores Float64:julia> 0x1p0\n1.0\n\njulia> 0x1.8p3\n12.0\n\njulia> 0x.4p-1\n0.125\n\njulia> typeof(ans)\nFloat64También esta soportados los números en punto flotante de media precisión (Float16), pero ellos están implementados en software y usan Float32 para los cálculos.julia> sizeof(Float16(4.))\n2\n\njulia> 2*Float16(4.)\nFloat16(8.0)El guión bajo (underscore) puede usarse como separador de dígitos:julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010\n(10000, 5.0e-9, 0xdeadbeef, 0xb2)"
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Cero-en-punto-flotante-1",
    "page": "Números enteros y en punto flotante",
    "title": "Cero en punto flotante",
    "category": "section",
    "text": "Los números en punto flotante tienen dos ceros, positivo y negativo. Ellos son iguales entre sí, pero tienen distintas representaciones, como puede verse si usamos la función bits:julia> 0.0 == -0.0\ntrue\n\njulia> bits(0.0)\n\"0000000000000000000000000000000000000000000000000000000000000000\"\n\njulia> bits(-0.0)\n\"1000000000000000000000000000000000000000000000000000000000000000\""
},

{
    "location": "manual/integers-and-floating-point-numbers.html#special-floating-point-values-1",
    "page": "Números enteros y en punto flotante",
    "title": "Valores especiales en punto flotante",
    "category": "section",
    "text": "Hay tres valores especificados en el estándar de punto flotante para valores que no se corresponden  con ningún punto en la línea de números reales:Float16 Float32 Float64 Name Description\nInf16 Inf32 Inf Infinito positivo Un valor mayor que todos los valores finitos de punto flotante\n-Inf16 -Inf32 -Inf Infinito negativo Un valor menos que todos los valores finitos de punto flotante\nNaN16   NaN32   NaN     not a number   Un valor no == a otro valor en punto flotante (incluido el mismo)Para más información sobre cómo estos valores de punto flotante no finitos están ordenados entre sí y otros flotantes, vea Comparaciones Numéricas. Mediante el estándar IEEE 754, estos valores de punto flotante son el resultado de ciertas operaciones aritméticas:julia> 1/Inf\n0.0\n\njulia> 1/0\nInf\n\njulia> -5/0\n-Inf\n\njulia> 0.000001/0\nInf\n\njulia> 0/0\nNaN\n\njulia> 500 + Inf\nInf\n\njulia> 500 - Inf\n-Inf\n\njulia> Inf + Inf\nInf\n\njulia> Inf - Inf\nNaN\n\njulia> Inf * Inf\nInf\n\njulia> Inf / Inf\nNaN\n\njulia> 0 * Inf\nNaNLas funciones typemin() y typemax() también se aplican a los tipos en punto flotante:julia> (typemin(Float16),typemax(Float16))\n(-Inf16, Inf16)\n\njulia> (typemin(Float32),typemax(Float32))\n(-Inf32, Inf32)\n\njulia> (typemin(Float64),typemax(Float64))\n(-Inf, Inf)"
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Epsilon-de-máquina-1",
    "page": "Números enteros y en punto flotante",
    "title": "Epsilon de máquina",
    "category": "section",
    "text": "La mayoría de los números reales no pueden representarse exactamente con números de coma flotante, por lo que para muchos propósitos es importante conocer la distancia entre dos números de punto flotante representables adyacentes, lo que a menudo se conoce como epsilon de máquina.Julia proporciona eps(), que da la distancia entre 1,0 y el siguiente valor de punto flotante representable más grande:julia> eps(Float32)\n1.1920929f-7\n\njulia> eps(Float64)\n2.220446049250313e-16\n\njulia> eps() # same as eps(Float64)\n2.220446049250313e-16Estos valores son 2.0^-23 y 2.0^-52 como valores Float32 y Float64, respectivamente. La función eps() también puede tomar un valor de punto flotante como un argumento y da la diferencia absoluta entre ese valor y el siguiente valor de punto flotante representable. Es decir, eps(x) produce un valor del mismo tipo que x tal que x + eps(x) es el siguiente valor de punto flotante representable mayor que x:julia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(1000.)\n1.1368683772161603e-13\n\njulia> eps(1e-27)\n1.793662034335766e-43\n\njulia> eps(0.0)\n5.0e-324La distancia entre dos números de punto flotante representables adyacentes no es constante, pero es menor para valores más pequeños y mayor para valores mayores. En otras palabras, los números de punto flotante representables son más densos en la línea de números reales cerca de cero, y crecen exponencialmente dispersos a medida que uno se aleja de cero. Por definición, eps(1.0) es el mismo que eps(Float64) ya que 1.0 es un valor de coma flotante de 64 bits.Julia también proporciona las funciones nextfloat() y prevfloat() que devuelven el siguiente número de punto flotante representable más grande o más pequeño al argumento, respectivamente:julia> x = 1.25f0\n1.25f0\n\njulia> nextfloat(x)\n1.2500001f0\n\njulia> prevfloat(x)\n1.2499999f0\n\njulia> bits(prevfloat(x))\n\"00111111100111111111111111111111\"\n\njulia> bits(x)\n\"00111111101000000000000000000000\"\n\njulia> bits(nextfloat(x))\n\"00111111101000000000000000000001\"Este ejemplo resalta el principio general de que los números de punto flotante representables adyacentes también tienen representaciones binarias enteras adyacentes."
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Modos-de-Redondeo-1",
    "page": "Números enteros y en punto flotante",
    "title": "Modos de Redondeo",
    "category": "section",
    "text": "Si un número no tiene una representación de punto flotante exacta, debe redondearse a un valor representable apropiado. Sin embargo, si se desea, la forma en que se realiza este redondeo puede cambiarse de acuerdo con los modos de redondeo presentados en el estándar IEEE 754.julia> x = 1.1; y = 0.1;\n\njulia> x + y\n1.2000000000000002\n\njulia> setrounding(Float64,RoundDown) do\n           x + y\n       end\n1.2El modo predeterminado utilizado siempre es RoundNearest, , que redondea al valor representable  más cercano, con arcos redondeados hacia el valor más cercano con un bit menos significativo.warning: Warning\nEl redondeo generalmente sólo es correcto para las funciones aritméticas básicas (+(),  -(), *(), /() and sqrt()) y las operaciones de conversión  de tipos. Muchas otras funciones asumen que el modo por defecto RoundNearest está  establecido y pueden dar resultados erróneos al operar bajo otros modos de redondeo."
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Antecedentes-y-referencias-1",
    "page": "Números enteros y en punto flotante",
    "title": "Antecedentes y referencias",
    "category": "section",
    "text": "La aritmética de punto flotante supone muchas sutilezas que pueden sorprender a los usuarios que no  están familiarizados con los detalles de implementación de bajo nivel. Sin embargo, estas sutilezas  se describen en detalle en la mayoría de los libros sobre computación científica, y también en las  siguientes referencias:La guía definitiva para la aritmética de coma flotante es el estándar [IEEE 754-2008 (http://standards.ieee.org/findstds/standard/754-2008.html); Sin embargo, no está disponible en línea gratis.Para una presentación breve pero lúcida de cómo los números de punto flotante están  representados, vea el artículo de John D. Cook sobre el tema, así como su introducción a algunas de las cuestiones que surgen de cómo esta representación difiere en el comportamiento de la abstracción idealizada de números reales.También se recomienda la serie de publicaciones de Bruce Dawson sobre números en punto flotante.\nPara un excelente y profundo análisis de los números de punto flotante y los problemas de precisión numérica encontrados al calcular con ellos, vea el artículo de David Goldberg What Every Computer Scientist Should Know About Floating-Point Arithmetic.\nPara una documentación aún más extensa de la historia de, la razón y las cuestiones con los números de punto flotante, así como la discusión de muchos otros temas en la computación numérica, ver los escritos recolectados de William Kahan, comúnmente conocido como el \"padre de punto flotante\". De interés particular puede ser An Interview with the Old Man of Floating-Point."
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Aritmética-de-Precisión-Arbitraria-1",
    "page": "Números enteros y en punto flotante",
    "title": "Aritmética de Precisión Arbitraria",
    "category": "section",
    "text": "Para permitir cálculos con enteros y números de coma flotante de precisión arbitraria, Julia envuelve la Biblioteca Aritmética de Precisión Múltiple GNU (GMP) y la biblioteca GNU MPFR, respectivamente. Los tipos BigInt y BigFloat están disponibles en Julia para números enteros de precisión arbitraria y números de coma flotante, respectivamente.Existen constructores para crear estos tipos de tipos numéricos primitivos, y podemos también utilizar parse() para construirlos a partir de AbstractStrings.  Una vez creados, participan en la aritmética con todos los demás tipos numéricos gracias al mecanismo de promotion y conversion de tipos de Julia:julia> BigInt(typemax(Int64)) + 1\n9223372036854775808\n\njulia> parse(BigInt, \"123456789012345678901234567890\") + 1\n123456789012345678901234567891\n\njulia> parse(BigFloat, \"1.23456789012345678901\")\n1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n\njulia> BigFloat(2.0^66) / 3\n2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19\n\njulia> factorial(BigInt(40))\n815915283247897734345611269596115894272000000000Sin embargo, la promoción de tipos entre los tipos primitivos ya vistos y BigInt/BigFloat no es automática y debe ser establecida explícitamente: julia> x = typemin(Int64)\n-9223372036854775808\n\njulia> x = x - 1\n9223372036854775807\n\njulia> typeof(x)\nInt64\n\njulia> y = BigInt(typemin(Int64))\n-9223372036854775808\n\njulia> y = y - 1\n-9223372036854775809\n\njulia> typeof(y)\nBigIntLa precisión predeterminada (en número de bits del significado) y el modo de redondeo de las operaciones de BigFloat pueden cambiarse globalmente llamando setprecision() and setrounding(), y todos los cálculos adicionales tomarán en cuenta estos cambios. Alternativamente, la precisión o el redondeo se puede cambiar dentro sólo de la ejecución de un bloque particular de código utilizando las mismas funciones dentro de un bloque do:julia> setrounding(BigFloat, RoundUp) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.100000000000000000000000000000000000000000000000000000000000000000000000000003\n\njulia> setrounding(BigFloat, RoundDown) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.099999999999999999999999999999999999999999999999999999999999999999999999999986\n\njulia> setprecision(40) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.1000000000004"
},

{
    "location": "manual/integers-and-floating-point-numbers.html#man-numeric-literal-coefficients-1",
    "page": "Números enteros y en punto flotante",
    "title": "Coeficientes Literales Numéricos",
    "category": "section",
    "text": "Para hacer más claras fórmulas numéricas y expresiones, Julia permite que las variables sean precedidas inmediatamente por un literal numérico, implicando la multiplicación. Esto hace que la escritura de las expresiones polinómicas sea mucho más limpias:julia> x = 3\n3\n\njulia> 2x^2 - 3x + 1\n10\n\njulia> 1.5x^2 - .5x + 1\n13.0También hace que escribir funciones exponenciales sea más elegante:julia> 2^2x\n64La precedencia de los coeficientes literales numéricos es la misma que la de los operadores unarios como la negación. Así que 2^3x se analiza como 2^(3x), y 2x^3 se analiza como 2*(x ^ 3).Los literales numéricos también funcionan como coeficientes de las expresiones entre paréntesis:julia> 2(x-1)^2 - 3(x-1) + 1\n3note: Note\n   La precedencia de coeficientes literales numéricos usada para multiplicación      implícita es mayor que otros operadores binarios tales como la multiplicación     (*), y división (/, \\, and //).  Esto significa, por ejemplo, que      1 / 2im es igual a -0.5im y 6 // 2(2 + 1) es igual a 1 // 1.Además, las expresiones entre paréntesis se pueden utilizar como coeficientes a las variables, lo que implica la multiplicación de la expresión por la variable:julia> (x-1)x\n6Sin embargo, ni la yuxtaposición de dos expresiones entre paréntesis, ni la colocación de una variable antes de una expresión entre paréntesis puede ser usada para implicar multiplicación:julia> (x-1)(x+1)\nERROR: MethodError: objects of type Int64 are not callable\n\njulia> x(x+1)\nERROR: MethodError: objects of type Int64 are not callableAmbas expresiones se interpretan como la aplicación de una función: cualquier expresión que no sea un literal numérico, inmediatamente seguida de una entre paréntesis, se interpreta como una función aplicada a los valores entre paréntesis (ver Funciones para más información sobre las funciones). Por lo tanto, en ambos casos, se produce un error, ya que el valor de la izquierda no es una función.Las mejoras sintácticas anteriores reducen significativamente el ruido visual producido al escribir fórmulas matemáticas comunes. Obsérvese que ningún espacio en blanco puede encontrarse entre un coeficiente literal numérico y el identificador o la expresión entre paréntesis que multiplica."
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Conflictos-de-Sintaxis-1",
    "page": "Números enteros y en punto flotante",
    "title": "Conflictos de Sintaxis",
    "category": "section",
    "text": "La sintaxis de los coeficientes literales yuxtapuestos puede entrar en conflicto con dos sintaxis numéricas literales: literales enteros hexadecimales y notación ingenieril para literales de punto flotante. Aquí hay algunas situaciones donde surgen conflictos sintácticos:La expresión literal de enteros hexadecimales 0xff podría interpretarse como el literal numérico 0 multiplicado por la variable xff.\nLa expresión literal de punto flotante 1e10 podría interpretarse como el literal numérico 1 multiplicado por la variable e10, e igualmente con la forma E equivalenteEn ambos casos, resolvemos la ambigüedad a favor de la interpretación como literales numéricos:Las expresiones que comienzan con 0x siempre son literales hexadecimales.\nLas expresiones que empiezan con un literal numérico seguido por e o E siempre son literales de coma flotante."
},

{
    "location": "manual/integers-and-floating-point-numbers.html#Literales-cero-and-uno-1",
    "page": "Números enteros y en punto flotante",
    "title": "Literales cero and uno",
    "category": "section",
    "text": "Julia proporciona funciones que devuelven los literales 0 y 1 correspondientes a un tipo especificado o al tipo de una variable dada.Function Description\nzero(x) Literal cero del tipo x o del tipo de la variable x\none(x) Literal uno del tipo x o del tipo de la variable xEstas funciones son útiles en comparaciones numéricas para evitar la sobrecarga de una conversión de tipo innecesaria.Ejemplos:julia> zero(Float32)\n0.0f0\n\njulia> zero(1.0)\n0.0\n\njulia> one(Int32)\n1\n\njulia> one(BigFloat)\n1.000000000000000000000000000000000000000000000000000000000000000000000000000000"
},

{
    "location": "manual/mathematical-operations.html#",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Mathematical Operations and Elementary Functions",
    "category": "page",
    "text": ""
},

{
    "location": "manual/mathematical-operations.html#mathematical-operations-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Mathematical Operations and Elementary Functions",
    "category": "section",
    "text": "Julia proporciona una colección completa de operadores aritméticos básicos y de operadores de bits para todos sus tipos numéricos primitivos, así como implementaciones portables y eficientes de una colección comprensiva de funciones matemática estándar."
},

{
    "location": "manual/mathematical-operations.html#arithmetic-operators-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Operadores Aritméticos",
    "category": "section",
    "text": "Los siguientes operadores aritméticos están soportados sobre todos los tipos primitivos:Expression Name Description\n+x       más unario       Operación identidad                   \n-x       menos unario     Inverso matemático de un número\nx + y suma binaria suma\nx - y menos binario resta\nx * y   producto         multiplicación              \nx / y   división         división                    \nx \\ y   división inversa Equivalente a y / x                \nx ^ y   potencia         eleva x a la y-ésima potencia\nx % y resto Equivalente a rem(x,y)así como la negación sobre tipos Bool:Expression Name Description\n!x       negación Cambia true a false y viceversaEl sistema de promoción de Julia hace que las operaciones aritméticas sobre mezclas de tipos de argumentos funcione de forma natural y automáticamente. Ver Conversión y Promoción para los detalles del sistema de promoción.He aquí algunos ejemplos simples de usar operadores aritméticos:julia> 1 + 2 + 3\n6\n\njulia> 1 - 2\n-1\n\njulia> 3*2/12\n0.5(Por convención, tendemos a separar con menos distancia los operadores cuando se aplican antes de otros operadores cercanos. Por ejemplo, generalmente escribimos -x + 2 para reflejar que x primero se niega y, a continuación, 2 se agrega a ese resultado.)"
},

{
    "location": "manual/mathematical-operations.html#bitwise-operators-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Operadores bit a bit",
    "category": "section",
    "text": "Los siguientes operadores bit a bit son soportados sobre todos los tipos enteros primitivos:Expression Name\n~x       Negación bit a bit                                                    \nx & y   Conjunción (and) bit a bit                                          \nx | y   Disyunción (or) bit a bit                                             \nx ⊻ y Or exclusivo bit a bit (xor)\nx >>> y Desplazamiento lógico hacia la derecha      \nx >> y   Desplazamiento aritmético hacia la derecha\nx << y   Desplazamiento hacia la izquierda lógico/aritmético                                        He aquí algunos ejemplos de uso de operadores bit a bit:julia> ~123\n-124\n\njulia> 123 & 234\n106\n\njulia> 123 | 234\n251\n\njulia> 123 ⊻ 234\n145\n\njulia> xor(123, 234)\n145\n\njulia> ~UInt32(123)\n0xffffff84\n\njulia> ~UInt8(123)\n0x84"
},

{
    "location": "manual/mathematical-operations.html#Operaciones-de-actualización-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Operaciones de actualización",
    "category": "section",
    "text": "Cada operador binario aritmético y bit a bit también tiene una versión de actualización que asigna el resultado de la operación de nuevo a su operando izquierdo. La versión de actualización del operador binario se forma colocando a = inmediatamente después del operador. Por ejemplo, escribir x += 3 es equivalente a escribir x = x + 3:julia> x = 1\n1\n\njulia> x += 3\n4\n\njulia> x\n4Las versiones de actualización de todos los operadores binarios, aritméticos de bits son:+=  -=  *=  /=  \\=  ÷=  %=  ^=  &=  |=  ⊻=  >>>=  >>=  <<=note: Note\nUn operador de actualización reasigna la variable sobre la parte izquierda de la ecuación. Como  resultado, el tipo de la variable puede cambiar:julia> x = 0x01; typeof(x)\nUInt8\n\njulia> x *= 2 # Same as x = x * 2\n2\n\njulia> typeof(x)\nInt64"
},

{
    "location": "manual/mathematical-operations.html#man-dot-operators-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Operadores vectorizados con \"punto\"",
    "category": "section",
    "text": "Para cada operación binaria como ^ hay su correspondiente operación \"con punto\" .^ que se define automáticamente para realizar la operación ^ elemento a elemento sobre arrays. Por ejemplo, la operación [1, 2, 3]^3 no está definidia, porque no hay un significado matemático estándar para calcular el cubo de un array, pero [1, 2, 3].^3 si lo está como el cálculo de la operación cubo elemento a elemento (o vectorizada) [1^3, 2^3, 3^3]. Lo mismo puede decirse para operadores unarios tales como ! o √, que existe el correspondiente operador vectorizado .√ que aplica el operador elemento a elemento.julia> [1,2,3] .^ 3\n3-element Array{Int64,1}:\n  1\n  8\n 27Más específicamente, a .^ b es analizado como la llamada punto (^).(a,b), que realiza una operación de retransmisión (broadcast): ella puede combinar arrays y escalares, arrays del mismo tamaño (realizando la operación elemento a elemento), o incluso arrays de diferentes formas (por ejemplo, combinar vectores fila y columna para producir una matriz). Además, como todas las \"llamadas punto\", estos \"operadores punto\" están fusionados. Por ejemplo, si calculamos 2 .* A.^2 .+ sin.(A) (o, equivalentemente @. 2A^2 + sin(A), usando la macro @.) para un array A, se realiza un único bucle sobre A, computando 2a^2 + sin(a) para cada elemento de A. En particular, las llamadas vectorizadas anidadas como f.(g.(x)) están fusionadas, y los operadores binarios adyacentes como x .+ 3 .* x.^2 son equivalentes a llamadas vectorizadas anidadas (+).(x, (*).(3, (^).(x, 2))).Además, los operadores de actualización \"vectorizados\" como a .+= b (o @. a += b) son transformados en a .= a .+ b, donde .= es un operador de asignación fusionado in-place (ver la documentación de la sintaxis vectorizada).Nótese que la sintaxis de punto es también aplicable a operadores definidos por el usuario. Por ejemplo, si definimos el operador ⊗(A,B) = kron(A,B) para dar una sintaxis infija A ⊗ B al producto de Kronecker (kron), entonces [A,B] .⊗ [C,D] calculará  [A⊗C, B⊗D] sin ninguna codificación adicional."
},

{
    "location": "manual/mathematical-operations.html#numeric-comparisons-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Comparaciones Numéricas",
    "category": "section",
    "text": "Los operadores de comparación estándar están definidos para todos los tipos numéricos primitivos:Operador Nombre\n== Igualdad\n!=, ≠ Desigualdad\n< Menor que\n<=, ≤ Menor o igual que\n> Mayor que\n>=, ≥ Mayor o igual queHe aquí algunos ejemplos:julia> 1 == 1\ntrue\n\njulia> 1 == 2\nfalse\n\njulia> 1 != 2\ntrue\n\njulia> 1 == 1.0\ntrue\n\njulia> 1 < 2\ntrue\n\njulia> 1.0 > 3\nfalse\n\njulia> 1 >= 1.0\ntrue\n\njulia> -1 <= 1\ntrue\n\njulia> -1 <= -1\ntrue\n\njulia> -1 <= -2\nfalse\n\njulia> 3 < -0.5\nfalseLos enteros se comparan de un modo estándar, mediante comparación de bits. Los números de punto flotante se comparan de acuerdo al estándar IEEE 754:Los números finitos son ordenados del modo habitual.\nEl cero positivo es igual pero no mayor que el cero negativo.\nInf es igual a si mismo y mayor que todo excepto NaN\n-Inf es igual a si mismo y menor que todo excepto NaN\nNaN no es igual, mayor o menor a nadie, excepto a sí mismo.Este último punto es potencialmente sorprendente y, por tanto, vale la pena señalar que:julia> NaN == NaN\nfalse\n\njulia> NaN != NaN\ntrue\n\njulia> NaN < NaN\nfalse\n\njulia> NaN > NaN\nfalsey puede causar dolores de cabeza especiales con Arrays:julia> [1 NaN] == [1 NaN]\nfalseJulia proporciona funciones adicionales para comprobar números para valores especiales, lo cuál pueden ser útil en situaciones como las comparaciones de claves hash:Function Tests if\nisequal(x, y) x e y son idénticos\nisfinite(x)   x es un número finito\nisinf(x) x es infinito\nisnan(x)     x no es un númeroisequal() considera los NaNs iguales entre sí:julia> isequal(NaN, NaN)\ntrue\n\njulia> isequal([1 NaN], [1 NaN])\ntrue\n\njulia> isequal(NaN, NaN32)\ntrueisequal() también puede usarse para distinguir los ceros con signo:julia> -0.0 == 0.0\ntrue\n\njulia> isequal(-0.0, 0.0)\nfalseLas comparaciones de tipos mezclados entre enteros con signo, enteros sin signo y valores en punto flotante pueden ser complicadas. Se ha tomado mucho cuidado para asegurarse de que Julia las realiza correctamente.Para otros tipos, isequal() llama por defecto a ==(), así que si uno quiere definir la igualdad para sus propios tipos, solo tiene que agregar un método ==().  Si uno define suu propia función de igualdad, probablemente deba definir un método hash() correspondiente para asegurar de que isequal(x,y) implica hash(x) == hash(y)."
},

{
    "location": "manual/mathematical-operations.html#chaining-comparisons-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Comparaciones Encadenadas",
    "category": "section",
    "text": "A diferencia de la mayoría de los idiomas, con la notable excepción de Python, las comparaciones pueden encadenarse arbitrariamente:julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5\ntrueEl encadenamiento de comparaciones suele ser bastante conveniente en el código numérico. Las comparaciones encadenadas utilizan el operador && para comparaciones escalares y el operador & para comparaciones elemento a elemento, lo que les permite trabajar sobre arrays. Por ejemplo, 0 .< A .< 1 da un array booleano cuyas entradas son true en posiciones en las que los elementos correspondientes de A están entre 0 y 1.Nótese el comportamiento de evaluación de las comparaciones encadenadas:julia> v(x) = (println(x); x)\nv (generic function with 1 method)\n\njulia> v(1) < v(2) <= v(3)\n2\n1\n3\ntrue\n\njulia> v(1) > v(2) <= v(3)\n2\n1\nfalseLa expresión del medio sólo se evalúa una vez, en lugar de dos veces como lo sería si la expresión se escribiera como v(1) < v(2) && v(2) <= v(3). Sin embargo, el orden de las evaluaciones en una comparación encadenada no está definido. Se recomienda encarecidamente no utilizar expresiones que puedan tener efectos secundarios (como la impresión) en comparaciones encadenadas. Si se requieren efectos secundarios, se debe utilizar explícitamente el operador de cortocircuito && (ver Evaluación en cortocircuito)."
},

{
    "location": "manual/mathematical-operations.html#elementary-functions-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Funciones Elementales",
    "category": "section",
    "text": "Julia proporciona una colección completa de funciones matemáticas y operadores. Estas operaciones matemáticas se definen sobre una clase de valores numéricos suficientemente amplia como para permitir definiciones apropiadas para enteros, números de punto flotante, racionales y complejos, dondequiera que tales definiciones tengan sentido.Además, estas funciones (como cualquier función de Julia) se pueden aplicar de manera \"vectorizada\" a matrices y otras colecciones con la sintaxis vectorizada f.(A), por ejemplo, sin.(A) calculará el seno de cada elemento de una matriz A. "
},

{
    "location": "manual/mathematical-operations.html#operator-precedence-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Precedencia de Operadores",
    "category": "section",
    "text": "Julia applies the following order of operations, from highest precedence to lowest:Categorí       Operadores                                                                                       \nSyntax . seguido por ::\nExponentiation ^\nFractions //\nMultiplication * / % & \\\nBitshifts << >> >>>\nAddition + - | ⊻\nSyntax : .. seguido por |>\nComparisons > < >= <= == === != !== <:\nControl flow && seguido por || seguido por ?\nAssignments = += -= *= /= //= \\= ^= ÷= %= |= &= ⊻= <<= >>= >>>=Para una lista completa de cada una de las precedencias de operadores de Julia, consultar el fichero src/julia-parser.scmTambién puede encontrarse la precedencia numérica pra cualquier operación dada mediante la función intrínseca Base.operator_precedence donde el número mayor corresponde a la operación con mayor precedencia.julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)\n(9, 11, 15)\n\njulia> Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)\n(1, 1)"
},

{
    "location": "manual/mathematical-operations.html#numerical-conversions-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Conversiones Numéricas",
    "category": "section",
    "text": "Julia soporta tres formas de conversión numérica, que difieren en su manejo de las conversiones inexactas.La notación T(x) o convert(T,x) convierte x a un valor de tipo T.\nSi T es un tipo en punto flotante, el resultado es el valor más cercano representable, que podría ser infinito positivo o negativo.\nSi T es un tipo entero, se lanzará un InexactError si xno es representable por T.\nx % Tconvierte un entero x a un valor de un tipo entero T congruente a x modulo 2^n, donde n es el número de bits en T. En otras palabras, la representación binaria es truncada para ajustarse.\nLas Funciones de Redondeo toman un tipo T como argumento opcional. Por ejemplo, round(Int,x) es una abreviatura de Int(round(x)).Los siguientes ejemplos muestran las siguientes formas:julia> Int8(127)\n127\n\njulia> Int8(128)\nERROR: InexactError()\nStacktrace:\n [1] Int8(::Int64) at ./sysimg.jl:77\n\njulia> Int8(127.0)\n127\n\njulia> Int8(3.14)\nERROR: InexactError()\nStacktrace:\n [1] convert(::Type{Int8}, ::Float64) at ./float.jl:658\n [2] Int8(::Float64) at ./sysimg.jl:77\n\njulia> Int8(128.0)\nERROR: InexactError()\nStacktrace:\n [1] convert(::Type{Int8}, ::Float64) at ./float.jl:658\n [2] Int8(::Float64) at ./sysimg.jl:77\n\njulia> 127 % Int8\n127\n\njulia> 128 % Int8\n-128\n\njulia> round(Int8,127.4)\n127\n\njulia> round(Int8,127.6)\nERROR: InexactError()\nStacktrace:\n [1] trunc(::Type{Int8}, ::Float64) at ./float.jl:651\n [2] round(::Type{Int8}, ::Float64) at ./float.jl:337Ver Conversión y Promoción para ver cómo definir tus propias conversiones y promociones."
},

{
    "location": "manual/mathematical-operations.html#rounding-functions-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Funciones de Redondeo",
    "category": "section",
    "text": "Función              Descripción                       Tipo devuelto\nround(x) Redondea x al entero más cercano typeof(x)\nround(T, x) Redondea x al entero más cercano T\nfloor(x) Redondea x hacia -Inf typeof(x)\nfloor(T, x) Redondea x hacia -Inf T\nceil(x) Redondea x hacia +Inf typeof(x)\nceil(T, x) Redondea x hacia +Inf T\ntrunc(x) Redondea x hacia cero typeof(x)\ntrunc(T, x) Redondea x hacia cero T"
},

{
    "location": "manual/mathematical-operations.html#division-functions-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Funciones de División",
    "category": "section",
    "text": "Función              Descripción                                                                                       \ndiv(x,y) División truncada; cociente redondeado hacia cero\nfld(x,y) División floored; cociente redondeado hacia -Inf\ncld(x,y) División ceiling; cociente redondeado hacia +Inf\nrem(x,y)   Resto; satisface x == div(x,y)*y + rem(x,y); el signo se corresponde con el de x              \nmod(x,y) Módulo; satisface x == fld(x,y)*y + mod(x,y); el signo se corresponde con el de y\nmod1(x,y) Módulo con un desplazamiento de 1; devuelve r∈(0,y] para y>0 o r∈[y,0) para y<0, donde mod(r, y) == mod(x, y)\nmod2pi(x) Módulo con respecto a 2pi; 0 <= mod2pi(x)  < 2pi\ndivrem(x,y) Devuelve (div(x,y),rem(x,y))\nfldmod(x,y) Devuelve (fld(x,y),mod(x,y))\ngcd(x,y...) Máximo común divisor positivo de x, y,...\nlcm(x,y...) Mínimo común múltiplo positivo de x, y,..."
},

{
    "location": "manual/mathematical-operations.html#sign-and-absolute-value-functions-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Funciones de signo y valor absoluto",
    "category": "section",
    "text": "Función                Descripción                                              \nabs(x) Un valor positivo con la magnitud de x\nabs2(x) El cuadrado de la magnitud de x\nsign(x) Indica el signo de x, devolviendo -1, 0, o +1\nsignbit(x) Indica que si el bit de signo está en on (true) o en off (false)\ncopysign(x,y) Indica un valor con la magnitud de x y el signo de y  \nflipsign(x,y) Indica un valor con la magnitud de x y el signo de x*y"
},

{
    "location": "manual/mathematical-operations.html#powers-logs-and-roots-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Potencias, logaritmos y raíces",
    "category": "section",
    "text": "Función Descripción\nsqrt(x), √x Raíz cuadrada de x                                                     \ncbrt(x), ∛x Raíz cúbica de x                                                        \nhypot(x,y) Hipotenusa del triángulo rectángulo cuyos catetos son de longitudes x e y\nexp(x)         Función exponencial natural sobre x                                    \nexpm1(x) Valor exacto de exp(x)-1 para  x cercano a zero\nldexp(x,n) x*2^n calculado eficientemente para valores enteros de n\nlog(x) Logaritmo neperiano de x\nlog(b,x) Logaritmo en base b de x\nlog2(x) Logaritmo en base 2 de x\nlog10(x) Logaritmo decimal de x\nlog1p(x) Valor exacto de log(1+x) para x cercano a cero\nexponent(x) Exponente binario de  x\nsignificand(x) Significando binario (alias mantisa) de un número en punto flotante xPara una explicación de por qué son necesarias funciones como hypot(), expm1(), and log1p(), véase el excelente par de artículos en el blog de John D. Cook's sobre el tema: expm1, log1p, erfc, e hypot."
},

{
    "location": "manual/mathematical-operations.html#trigonometric-and-hyperbolic-functions-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Funciones Trigonométricas e Hiperbólicas",
    "category": "section",
    "text": "Todas las funciones trigonométricas e hiperbólicas estándar están también definidas:sin    cos    tan    cot    sec    csc\nsinh   cosh   tanh   coth   sech   csch\nasin   acos   atan   acot   asec   acsc\nasinh  acosh  atanh  acoth  asech  acsch\nsinc   cosc   atan2Son todas funciones de un solo argumento, con la excepción de  atan2, que da el ángulo en radians entre el eje x y el punto especificado por sus argumentos, interpretado como sus coordenadas x e y.Adicionalmente, se proporcionan sinpi(x) e cospi(x) para cálculos más exactos de sin(pi*x) y cos(pi*x) respectivamente.Para computar funciones trigonométricas con grados en lugar de con rdianes, añada al nombre de la función el sufijo d. Por ejemplo, sind(x) calcula el seno de x, donde x se especifica en grados. La lista completa de funciones trigonométricas con variantes grados es:sind   cosd   tand   cotd   secd   cscd\nasind  acosd  atand  acotd  asecd  acscd"
},

{
    "location": "manual/mathematical-operations.html#special-functions-1",
    "page": "Mathematical Operations and Elementary Functions",
    "title": "Funciones Especiales",
    "category": "section",
    "text": "Función               Descripción\ngamma(x)   Función gamma en x\nlgamma(x) Valor exacto de log(gamma(x)) para valores grandes de x\nlfact(x) Valor exacto de  log(factorial(x)) para valores grandes de  x; igual que lgamma(x+1) para x > 1, cero en otros caso\nbeta(x,y)   Función beta en x,y\nlbeta(x,y) Valor exacto de  log(beta(x,y)) para valores grandes de x o y"
},

{
    "location": "manual/complex-and-rational-numbers.html#",
    "page": "Números Racionales y Complejos",
    "title": "Números Racionales y Complejos",
    "category": "page",
    "text": ""
},

{
    "location": "manual/complex-and-rational-numbers.html#complex-and-rational-numbers-1",
    "page": "Números Racionales y Complejos",
    "title": "Números Racionales y Complejos",
    "category": "section",
    "text": "Julia se distribuye con tipos predefinidos que representan números complejos y racionales, y soporta todas las Operaciones Matemáticas y Funciones Elementales estándar sobre ellos. Se han definido conversiones y promociones de modo que las operaciones con cualquier combinación de tipos numéricos predefinidos, primitivos o compuestos, se comporten como se esperaba.como se esperaba."
},

{
    "location": "manual/complex-and-rational-numbers.html#complex-numbers-1",
    "page": "Números Racionales y Complejos",
    "title": "Números Complejos",
    "category": "section",
    "text": "La constante global im está ligada al número complejo i, que representa la raíz cuadrada principal de -1. Se consideró nocivo para co-optar el nombre i para una constante global, ya que es un nombre de variable de índice popular. Como Julia permite que los literales numéricos se yuxtapongan con identificadores como coeficientes, esta unión es suficiente para proporcionar sintaxis conveniente para números complejos, similar a la notación matemática tradicional:julia> 1 + 2im\n1 + 2imPodemos realizar todas las operaciones aritméticas estándar con los números complejos:julia> (1 + 2im)*(2 - 3im)\n8 + 1im\n\njulia> (1 + 2im)/(1 - 2im)\n-0.6 + 0.8im\n\njulia> (1 + 2im) + (1 - 2im)\n2 + 0im\n\njulia> (-3 + 2im) - (5 - 1im)\n-8 + 3im\n\njulia> (-1 + 2im)^2\n-3 - 4im\n\njulia> (-1 + 2im)^2.5\n2.7296244647840084 - 6.960664459571898im\n\njulia> (-1 + 2im)^(1 + 1im)\n-0.27910381075826657 + 0.08708053414102428im\n\njulia> 3(2 - 5im)\n6 - 15im\n\njulia> 3(2 - 5im)^2\n-63 - 60im\n\njulia> 3(2 - 5im)^-1.0\n0.20689655172413796 + 0.5172413793103449imEl mecanismo de promoción asegura qur las combinaciones de operandos de distintos tipos funcionarán:julia> 2(1 - 1im)\n2 - 2im\n\njulia> (2 + 3im) - 1\n1 + 3im\n\njulia> (1 + 2im) + 0.5\n1.5 + 2.0im\n\njulia> (2 + 3im) - 0.5im\n2.0 + 2.5im\n\njulia> 0.75(1 + 2im)\n0.75 + 1.5im\n\njulia> (2 + 3im) / 2\n1.0 + 1.5im\n\njulia> (1 - 3im) / (2 + 2im)\n-0.5 - 1.0im\n\njulia> 2im^2\n-2 + 0im\n\njulia> 1 + 3/4im\n1.0 - 0.75imNótese que 3/4im == 3/(4*im) == -(3/4*im), ya que un coeficiente literal se enlaza más fuerte que la división.También se proporcionan las funciones estándar para manipular valores complejos:julia> z = 1 + 2im\n1 + 2im\n\njulia> real(1 + 2im) # real part of z\n1\n\njulia> imag(1 + 2im) # imaginary part of z\n2\n\njulia> conj(1 + 2im) # complex conjugate of z\n1 - 2im\n\njulia> abs(1 + 2im) # absolute value of z\n2.23606797749979\n\njulia> abs2(1 + 2im) # squared absolute value\n5\n\njulia> angle(1 + 2im) # phase angle in radians\n1.1071487177940904Como de costumbre, el valor absoluto (abs()) de un número complejo es su distancia a cero. abs2() da el cuadrado del valor absoluto, y es de uso particular para los números complejos donde se evita tomar una raíz cuadrada. angle() devuelve el ángulo de fase en radianes (también conocido como argumento o función arg). La gama completa de otras funciones elementales está también definida para los números complejos:julia> sqrt(1im)\n0.7071067811865476 + 0.7071067811865475im\n\njulia> sqrt(1 + 2im)\n1.272019649514069 + 0.7861513777574233im\n\njulia> cos(1 + 2im)\n2.0327230070196656 - 3.0518977991518im\n\njulia> exp(1 + 2im)\n-1.1312043837568135 + 2.4717266720048188im\n\njulia> sinh(1 + 2im)\n-0.4890562590412937 + 1.4031192506220405imTenga en cuenta que las funciones matemáticas normalmente devuelven valores reales cuando se aplican a números reales y valores complejos cuando se aplican a números complejos. Por ejemplo, sqrt() se comporta de forma diferente cuando se aplica a -1 que cuanso se aplica sobre -1 + 0im, aunque -1 == -1 + 0im:julia> sqrt(-1)\nERROR: DomainError:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).\nStacktrace:\n [1] sqrt(::Int64) at ./math.jl:434\n\njulia> sqrt(-1 + 0im)\n0.0 + 1.0imLa notación de coeficiente numérico literal no funciona cuando se construye un número complejo a partir de variables. En su lugar, la multiplicación debe expresarse explícitamente:julia> a = 1; b = 2; a + b*im\n1 + 2imSin embargo, esto no es lo recomendable; En su lugar, utilice la función complex() para construir un valor complejo directamente de sus partes real e imaginaria:julia> a = 1; b = 2; complex(a, b)\n1 + 2imEsta construcción evita las operaciones de multiplicación y adición.Inf y NaN se propagan a través de números complejos en las partes real e imaginaria de un número complejo como se describe en la sección valores especiales en punto flotante section:julia> 1 + Inf*im\n1.0 + Inf*im\n\njulia> 1 + NaN*im\n1.0 + NaN*im"
},

{
    "location": "manual/complex-and-rational-numbers.html#rational-numbers-1",
    "page": "Números Racionales y Complejos",
    "title": "Números Racionales",
    "category": "section",
    "text": "Julia tiene un tipo numérico racional para representar razones exactas de enteros. Los racionales se construyen usando el operador //:julia> 2//3\n2//3Si el numerador y el denominador de un racional tienen factores comunes, ellos son reducidos a los términos mínimos tales que el denominador sea no negativo:julia> 6//9\n2//3\n\njulia> -4//8\n-1//2\n\njulia> 5//-15\n-1//3\n\njulia> -4//-12\n1//3Esta forma normalizada para una razón de enteros es única, por lo que la igualdad de valores racionales puede ser testada comprobando la igualdad del numerador y el denominador. El numerador estandarizado y el denominador de un valor racional pueden ser extraídos usando las funciones numerator() y denominator():julia> numerator(2//3)\n2\n\njulia> denominator(2//3)\n3La comparación directa de numerador y denominador no suele ser necesaria, ya que la aritmetica  estándar y las operaciones de comparación están definidas para los valores racionales:julia> 2//3 == 6//9\ntrue\n\njulia> 2//3 == 9//27\nfalse\n\njulia> 3//7 < 1//2\ntrue\n\njulia> 3//4 > 2//3\ntrue\n\njulia> 2//4 + 1//6\n2//3\n\njulia> 5//12 - 1//4\n1//6\n\njulia> 5//8 * 3//12\n5//32\n\njulia> 6//5 / 10//7\n21//25Los racionales pueden convertirse fácilmente en número en punto flotante:julia> float(3//4)\n0.75La conversión de racional a punto flotante respeta la siguiente identidad para dos valores enteros cualesquiera a y b, con las excepciones de los casos a == 0 and b == 0:julia> a = 1; b = 2;\n\njulia> isequal(float(a//b), a/b)\ntrueConstruir valores racionales infinitos es aceptable:julia> 5//0\n1//0\n\njulia> -3//0\n-1//0\n\njulia> typeof(ans)\nRational{Int64}Sin embargo, no lo es tratar de construir un valor NaN NaN racional:julia> 0//0\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\nStacktrace:\n [1] Rational{Int64}(::Int64, ::Int64) at ./rational.jl:13\n [2] //(::Int64, ::Int64) at ./rational.jl:40Como es natural, el sistema de promoción hace que las interacciones con otros tipos numéricos se hagan sin esfuerzo alguno:julia> 3//5 + 1\n8//5\n\njulia> 3//5 - 0.5\n0.09999999999999998\n\njulia> 2//7 * (1 + 2im)\n2//7 + 4//7*im\n\njulia> 2//7 * (1.5 + 2im)\n0.42857142857142855 + 0.5714285714285714im\n\njulia> 3//2 / (1 + 2im)\n3//10 - 3//5*im\n\njulia> 1//2 + 2im\n1//2 + 2//1*im\n\njulia> 1 + 2//3im\n1//1 - 2//3*im\n\njulia> 0.5 == 1//2\ntrue\n\njulia> 0.33 == 1//3\nfalse\n\njulia> 0.33 < 1//3\ntrue\n\njulia> 1//3 - 0.33\n0.0033333333333332993"
},

{
    "location": "manual/strings.html#",
    "page": "Strings",
    "title": "Strings",
    "category": "page",
    "text": ""
},

{
    "location": "manual/strings.html#man-strings-1",
    "page": "Strings",
    "title": "Strings",
    "category": "section",
    "text": "Las cadenas son secuencias finitas de caracteres. Por supuesto, el verdadero problema viene cuando uno se pregunta qué es un carácter. Los caracteres con los que están familiarizados con los hablantes de inglés son las letras A, B, C, etc., junto con los números y los símbolos de puntuación comunes. Estos caracteres se estandarizan junto con una correspondencia a valores enteros entre 0 y 127 a través del estándar ASCII. Hay, por supuesto, muchos otros caracteres utilizados en lenguas no  inglesas, incluyendo variantes de los caracteres ASCII con acentos y otras modificaciones, escrituras relacionadas como cirílico y griego, y escrituras no relacionadas en abosluto con ASCII o inglés, entre los que se incluyen árabe, chino, Hebreo, hindi, japonés y coreano. El estándar Unicode aborda las complejidades de lo que es exactamente un carácter, y es generalmente aceptado como el estándar definitivo que aborda este problema. Dependiendo de tus necesidades, puedes ignorar estas complejidades por completo y fingir que sólo existen caracteres ASCII, o puedes escribir código que pueda manejar cualquiera de los caracteres o codificaciones que se pueden encontrar al manejar texto no ASCII. Julia hace que el manejo de texto ASCII sencillo sea simple y eficiente, y el manejo de Unicode tan simple y eficiente como sea posible. En particular, puedes escribir código de cadenas con estilo C para procesar cadenas ASCII y funcionarán como se esperaba, tanto en términos de rendimiento como de semántica. Si dicho código encuentra texto no ASCII, fallará  graciosamente con un mensaje de error claro, en lugar de introducir en silencio resultados corruptos. Cuando esto sucede, modificar el código para manejar datos no ASCII es sencillo.Hay algunas características destacadas de alto nivel sobre las cadenas de caracteres en Julia:El tipo de concreto incorporado utilizado para cadenas (y literales de cadena) en Julia es String. Esto soporta el rango completo de caracteres  Unicode a través de  la codificación UTF-8. (se proporciona una función transcode()   para convertir a/desde otras codificaciones Unicode).\nTodos los tipos de cadenas son subtipos del tipo abstracto AbstractString y los paquetes  externos definen subtipos AbstractString adicionales (por ejemplo, para otras codificaciones).  Si define una función que espera un argumento de cadena, debe declarar el tipo como  AbstractString para aceptar cualquier tipo de cadena.\nComo C y Java, pero a diferencia de la mayoría de los lenguajes dinámicos, Julia tiene un tipo  de primera clase que representa un solo carácter, llamado Char. Esto es sólo un tipo especial  de bits de 32 bits cuyo valor numérico representa un punto de código Unicode.\nComo en Java, las cadenas son inmutables: el valor de un objeto AbstractString no se puede  cambiar. Para construir un valor de cadena diferente, se construye una nueva cadena de partes  de otras cadenas.\nConceptualmente, una cadena es una función parcial de índices a caracteres: para algunos  valores de índice, no se devuelve ningún valor de carácter y, en su lugar, se genera una  excepción. Esto permite una indexación eficiente en cadenas por el índice de bytes de una  representación codificada en lugar de por un índice de caracteres, que no se puede implementar  de manera eficiente y sencilla para encodificaciones de anchura variable de cadenas Unicode."
},

{
    "location": "manual/strings.html#man-characters-1",
    "page": "Strings",
    "title": "Caracteres",
    "category": "section",
    "text": "Un valor Char representa un solo carácter: es sólo un bitstype de 32 bits con una representación literal especial y comportamientos aritméticos apropiados, cuyo valor numérico se interpreta como un punto de código Unicode. Aquí se muestra cómo se introducen y se muestran los valores Char:julia> 'x'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> typeof(ans)\nCharPodemos convertir un Char a su valor entero (su punto de código) fácilmente:julia> Int('x')\n120\n\njulia> typeof(ans)\nInt64En arquitecturas de 32 bits,  typeof(ans) será Int32. Puede convertir un valor entero de nuevo a un Char fácilmente:julia> Char(120)\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)No todos los valores enteros son puntos de código Unicode válidos, pero por una cuestión de  rendimiento, la conversión Char() no comprueba que cada valor de carácter sea válido. Si desea comprobar que cada valor convertido es un punto de código válido, utilice la función isvalid():julia> Char(0x110000)\n'\\U110000': Unicode U+110000 (category Cn: Other, not assigned)\n\njulia> isvalid(Char, 0x110000)\nfalseA partir de este momento, los puntos de código Unicode válidos son U+00 a U+d7ff y U+e000 a U+10ffff. A estos no se les han asignado todavía significados inteligibles, ni son necesariamente interpretables por las aplicaciones, pero todos ellos se consideran caracteres Unicode válidos.Puede introducir cualquier carácter Unicode entre comillas simples utilizando \\u seguido de hasta cuatro dígitos hexadecimales o \\U seguido de hasta ocho dígitos hexadecimales (el valor válido más largo sólo requiere seis):julia> '\\u0'\n'\\0': ASCII/Unicode U+0000 (category Cc: Other, control)\n\njulia> '\\u78'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> '\\u2200'\n'∀': Unicode U+2200 (category Sm: Symbol, math)\n\njulia> '\\U10ffff'\n'\\U10ffff': Unicode U+10ffff (category Cn: Other, not assigned)Julia utiliza la configuración regional y de idioma de tu sistema para determinar qué caracteres se pueden imprimir tal cual y cuáles se deben imprimir utilizando las formas de entrada genéricas, escapadas con \\u o \\U. Además de estas formas de escape de Unicode, también se pueden usar todas las formas de entrada de escape tradicionales de C:julia> Int('\\0')\n0\n\njulia> Int('\\t')\n9\n\njulia> Int('\\n')\n10\n\njulia> Int('\\e')\n27\n\njulia> Int('\\x7f')\n127\n\njulia> Int('\\177')\n127\n\njulia> Int('\\xff')\n255Puedes hacer comparaciones y una cantidad limitada de aritmética con los valores Char:julia> 'A' < 'a'\ntrue\n\njulia> 'A' <= 'a' <= 'Z'\nfalse\n\njulia> 'A' <= 'X' <= 'Z'\ntrue\n\njulia> 'x' - 'a'\n23\n\njulia> 'A' + 1\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)"
},

{
    "location": "manual/strings.html#Fundamentos-de-Cadenas-1",
    "page": "Strings",
    "title": "Fundamentos de Cadenas",
    "category": "section",
    "text": "Los literales de cadenas están delimitados por comillas dobles o comillas dobles triples:julia> str = \"Hello, world.\\n\"\n\"Hello, world.\\n\"\n\njulia> \"\"\"Contains \"quote\" characters\"\"\"\n\"Contains \\\"quote\\\" characters\"Si desea extraer un carácter de una cadena, indéxelo:julia> str[1]\n'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n\njulia> str[6]\n',': ASCII/Unicode U+002c (category Po: Punctuation, other)\n\njulia> str[end]\n'\\n': ASCII/Unicode U+000a (category Cc: Other, control)Toda la indexación en Julia está basada en 1: el primer elemento de cualquier objeto indexado medidante enteros se encuentra en el índice 1, y el último elemento se encuentra en el índice n, cuando la cadena tiene una longitud de n.En cualquier expresión de indexación, puede usarse la palabra clave end como una abreviatura para el último índice (calculado mediante endof(str)). Puede realizar operaciones aritméticas y otras con end, como si de un valor normal se tratara:julia> str[end-1]\n'.': ASCII/Unicode U+002e (category Po: Punctuation, other)\n\njulia> str[end÷2]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)Usar un índice menor que 1 o mayor que end lanza un error:julia> str[0]\nERROR: BoundsError: attempt to access \"Hello, world.\\n\"\n  at index [0]\n[...]\n\njulia> str[end+1]\nERROR: BoundsError: attempt to access \"Hello, world.\\n\"\n  at index [15]\n[...]También puedes extraer una subcadena usando indexación mediante un rango:julia> str[4:9]\n\"lo, wo\"Nótese que las expresiones str[k] y str[k:k] no dan el mismo resultado:julia> str[6]\n',': ASCII/Unicode U+002c (category Po: Punctuation, other)\n\njulia> str[6:6]\n\",\"La primera es un valor carácter de tipo Char, mientras que la segunda es un valor cadena que tiene un único carácter. En Julia se trata de cosas muy diferentes."
},

{
    "location": "manual/strings.html#Unicode-y-UTF-8-1",
    "page": "Strings",
    "title": "Unicode y UTF-8",
    "category": "section",
    "text": "Julia soporta totalmente caracteres y cadenas Unicode. Como se ha comentado anteriormente, en literales de caracteres, los puntos de código Unicode se pueden representar usando las secuencias de escape Unicode \\u y \\U, así como todas las secuencias de escape C estándar. Éstos también se pueden utilizar para escribir literales de cadena:julia> s = \"\\u2200 x \\u2203 y\"\n\"∀ x ∃ y\"Si estos caracteres Unicode se muestran como escapes o se muestran como caracteres especiales depende de la configuración regional de tu terminal y su compatibilidad con Unicode. Los literales de cadena se codifican utilizando la codificación UTF-8. UTF-8 es una codificación de ancho variable, lo que significa que no todos los caracteres están codificados en el mismo número de bytes. En UTF-8, los caracteres ASCII -es decir, aquellos con puntos de código inferiores a 0x80 (128) - están codificados como lo están en ASCII, usando un solo byte, mientras que los puntos de código 0x80 y superiores se codifican utilizando múltiples bytes (hasta cuatro por carácter). Esto significa que no todos los índices de bytes en una cadena UTF-8 es necesariamente un índice válido para un carácter. Si indexas una cadena en un índice de bytes no válido, se genera un error:julia> s[1]\n'∀': Unicode U+2200 (category Sm: Symbol, math)\n\njulia> s[2]\nERROR: UnicodeError: invalid character index\n[...]\n\njulia> s[3]\nERROR: UnicodeError: invalid character index\n[...]\n\njulia> s[4]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)En este caso, el carácter ∀ es un carácter de tres bytes, por lo que los índices 2 y 3 no son válidos y el índice del siguiente carácter es 4; este siguiente índice válido puede ser calculado con nextind(s,1), y el siguiente índice después de éste con nextind(s,4) y así sucesivamente.Debido a las codificaciones de longitud variable, el número de caracteres de una cadena (dada por length(s)) no siempre lo mismo que el último índice. Si se itera a través de los índices 1 hasta endof(s) y se indexa en s, la secuencia de caracteres devueltos cuando no se lanzan errores es la secuencia de caracteres que contiene la cadena s. Por tanto, tenemos la identidad de que length(s) <= endof(s), ya que cada carácter en una cadena debe tener su propio índice. La siguiente es una forma ineficaz y verbosa de iterar a través de los caracteres de s:julia> for i = 1:endof(s)\n           try\n               println(s[i])\n           catch\n               # ignore the index error\n           end\n       end\n∀\n\nx\n\n∃\n\nyLas líneas en blanco en realidad tienen espacios en ellos. Afortunadamente, el idioma anterior incómodo es innecesario para iterar a través de los caracteres de una cadena, ya que se puede utilizar la cadena como un objeto iterable, sin que se requiera el manejo de excepciones:julia> for c in s\n           println(c)\n       end\n∀\n\nx\n\n∃\n\nyJulia utiliza la codificación UTF-8 de forma predeterminada y el soporte para nuevas codificaciones puede agregarse mediante paquetes. Por ejemplo, el paquete LegacyStrings.jl implementa los tipos UTF16String y UTF32String. Una mayor discusión sobre otras codificaciones y cómo implementar el soporte para ellas está más allá del alcance de este documento por el momento. Para más información sobre los problemas de codificación UTF-8, consulte la sección siguiente sobre literales byte array. La función transcode() se proporciona para convertir datos entre las distintas codificaciones UTF-xx, principalmente para trabajar con datos y bibliotecas externas."
},

{
    "location": "manual/strings.html#concatenation-1",
    "page": "Strings",
    "title": "Concatenación",
    "category": "section",
    "text": "Una de las operaciones de cadena más comunes y útiles es la concatenación:julia> greet = \"Hello\"\n\"Hello\"\n\njulia> whom = \"world\"\n\"world\"\n\njulia> string(greet, \", \", whom, \".\\n\")\n\"Hello, world.\\n\"Julia también proporciona el operador * para concatenar cadenas:julia> greet * \", \" * whom * \".\\n\"\n\"Hello, world.\\n\"Aunque * puede parecer una elección sorprendente a los usuarios de lenguajes que proporcionan + para concatenación de cadenas, este uso de *tiene precedentes en matemáticas, particularmente en álgebra abstracta.En matemáticas, + suele denotar una operación conmutativa, donde el orden de los operandos no importa. Un ejemplo de esto es la suma de matrices, donde A + B == B + A para dos matrices cualesquiera A y B que tengan la misma forma. En contraste, * suele denotar una operación no conmutativa, donde el orden de los operandos importa. Un ejemplo de esto es la multiplicación de matrices donde, en general, A * B != B * A. Como con la multiplicación de matrices, la concatenación es no conmutativa: greet * whom != whom * greet. Por tanto, * es una elección más natural para el operador infijo de concatenación, consistente con el uso matemático común.Más precisamente, el conjunto de todas las cadenas S de longitud finita junto con el operador de concatenación * forman un monoide libre (S, *). El elemento identidad de este conjunto es la cadena vacía \"\". Siempre que un monoide libre es no conmutativo, la operación suele ser representada por \\cdot, *, o un símbolo similar, en luga de con + que implica conmutatividad."
},

{
    "location": "manual/strings.html#string-interpolation-1",
    "page": "Strings",
    "title": "Interpolación",
    "category": "section",
    "text": "Construir cadenas mediante concatenación puede llegar a ser un poco engorroso, sin embargo. Para reducir la necesidad de estas llamadas verbosas a string() o multiplicaciones repetidas, Julia permite la interpolación en literales de cadena usando $, como en Perl:julia> \"$greet, $whom.\\n\"\n\"Hello, world.\\n\"Esto es más legible y conveniente, y equivalente a la concatenación de cadena anterior – el sistema rescribe este aparente literal de cadena única en una concatenación de literales de cadena con variables.La expresión completa más corta después de $ se toma como la expresión cuyo valor debe ser interpolado en la cadena. Por lo tanto, puede interpolar cualquier expresión en una cadena usando paréntesis:julia> \"1 + 2 = $(1 + 2)\"\n\"1 + 2 = 3\"Tanto la concatenación como la interpolación de cadena llaman a string() para convertir objetos al formato de cadena. La mayoría de los objetos que no son AbstractString se convierten en cadenas que se corresponden estrechamente con la forma en que se introducen como expresiones literales:julia> v = [1,2,3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> \"v: $v\"\n\"v: [1, 2, 3]\"string() es la identidad para los valores AbstractString y Char values, por lo que estos se interpolan en cadenas como ellos mismos, sin entrecomillar y sin escapar:julia> c = 'x'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> \"hi, $c\"\n\"hi, x\"Para incluir un literal $ en una cadena, lo escaparemos con un backslash:julia> print(\"I have \\$100 in my account.\\n\")\nI have $100 in my account."
},

{
    "location": "manual/strings.html#triple-quoted-string-literals-1",
    "page": "Strings",
    "title": "Literales cadena con triples comillas",
    "category": "section",
    "text": "Cuando las cadenas se crean utilizando comillas triples (\"\"\"...\"\"\") tienen un comportamiento especial que puede ser útil para crear bloques de texto más largos. En primer lugar, si la apertura \"\"\" es seguida por una nueva línea, la nueva línea se quita de la cadena resultante:\"\"\"hello\"\"\"es equivalente a\"\"\"\nhello\"\"\"pero\"\"\"\n\nhello\"\"\"contendrá un literal new line al principio. Los espacios en blanco no se modifican. Pueden contener símbolos \" sin escapar. Las cadenas de triple comilla también se dedican al nivel de la línea menos indentada. Esto es útil para definir cadenas dentro del código que está sangrado Por ejemplo:julia> str = \"\"\"\n           Hello,\n           world.\n         \"\"\"\n\"  Hello,\\n  world.\\n\"En este caso la línea final (vacía) antes del cierre \"\"\" establece el nivel de indentación.Tenga en cuenta que las saltos de línea en cadenas literales, sean de una sola o triple comilla, resultan en un carácter de línea nueva (LF) \\n en la cadena, incluso si su editor usa una combinación de retorno de carro (CR) o CRLF para finalizar líneas. Para incluir un CR en una cadena, utilice un escape explícito \\r; Por ejemplo, puede introducir la cadena literal \"una línea CRLF que termina \\r \\n\"."
},

{
    "location": "manual/strings.html#common-operations-1",
    "page": "Strings",
    "title": "Operaciones Comunes",
    "category": "section",
    "text": "Podemos comparar cadenas lexicográficamente usando los operadores de comparación estandard:julia> \"abracadabra\" < \"xylophone\"\ntrue\n\njulia> \"abracadabra\" == \"xylophone\"\nfalse\n\njulia> \"Hello, world.\" != \"Goodbye, world.\"\ntrue\n\njulia> \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\ntrueLa función search() permite buscar el índice de una carácter en una cadena:julia> search(\"xylophone\", 'x')\n1\n\njulia> search(\"xylophone\", 'p')\n5\n\njulia> search(\"xylophone\", 'z')\n0Y se puede arrancar la búsqueda de un carácter a partir de un desplazamiento proporcionado por un tercer argumento:julia> search(\"xylophone\", 'o')\n4\n\njulia> search(\"xylophone\", 'o', 5)\n7\n\njulia> search(\"xylophone\", 'o', 8)\n0La función contains() se usa para comprobar si una subcadena está contenida en una cadena:julia> contains(\"Hello, world.\", \"world\")\ntrue\n\njulia> contains(\"Xylophon\", \"o\")\ntrue\n\njulia> contains(\"Xylophon\", \"a\")\nfalse\n\njulia> contains(\"Xylophon\", 'o')\nERROR: MethodError: no method matching contains(::String, ::Char)\nClosest candidates are:\n  contains(!Matched::Function, ::Any, !Matched::Any) at reduce.jl:664\n  contains(::AbstractString, !Matched::AbstractString) at strings/search.jl:378Este último error es debido a que 'o'  es un literal carácter, y contains() es una función genérica que busca subsecuencias. Para buscar un elemento en una secuencia, debemos usar la función in() en lugra de la anterior.repeat() y join() son otras dos funciones de cadena muy útiles:julia> repeat(\".:Z:.\", 10)\n\".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n\njulia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n\"apples, bananas and pineapples\"Algunas otras funciones útiles son:endof(str) el índice máximo (byte) que se puede utilizar para indexar en str.\nlength(str) el número de caracteres en str.\ni = start(str) da el primer índice válido en el que se puede encontrar un carácter en `str (típicamente 1).\nc, j = next(str,i) devuelve el carácter siguiente en o después del índice i y el siguiente índice de carácter válido que sigue a éste. Con start() y endof(), se puede utilizar para iterar a través de los caracteres en str`.\nind2chr(str,i) da el número de caracteres en str hasta e incluyendo cualquiera en el índice i.\nchr2ind(str,j) da el índice en el cual ocurre el carácter j-ésimo en str."
},

{
    "location": "manual/strings.html#non-standard-string-literals-1",
    "page": "Strings",
    "title": "Literales cadena no estándar",
    "category": "section",
    "text": "Hay situaciones en las que se desea construir una cadena o utilizar semántica de cadenas, pero el comportamiento de la construcción de cadena estándar no es lo que se necesita. Para este tipo de situaciones, Julia proporciona literales cadena no estándar. Un literal de cadena no estándar es como una cadena literal normal de doble comilla, pero va inmediatamente precedido de un identificador y no se comporta como un literal de cadena normal. El convenio es que los literales no estándar con prefijos en mayúsculas producen objetos cadena reales, mientras que aquellos con prefijos en minúsculas producen objetos que no cadena, como arrays de bytes o expresiones regulares compiladas. Las expresiones regulares, literales arrays de bytes y literales de números de versión, como se describe a continuación, son algunos ejemplos de literales de cadena no estándar. Otros ejemplos se dan en la sección Metaprogramación."
},

{
    "location": "manual/strings.html#regular-expressions-1",
    "page": "Strings",
    "title": "Expresiones Regulares",
    "category": "section",
    "text": "Julia tiene expresiones regulares compatibles con Perl (expresiones regulares), tal y como las proporciona la biblioteca PCRE. Las expresiones regulares se relacionan con las cadenas de dos maneras: la conexión obvia es que las expresiones regulares se utilizan para encontrar patrones regulares en cadenas; La otra conexión es que las expresiones regulares se introducen ellas mismas como cadenas, que se analizan en una máquina de estado que puede utilizarse para buscar patrones en cadenas de forma eficiente. En Julia, las expresiones regulares se introducen usando literales de cadena no estándar prefijados con varios identificadores comenzando por r. El literal de expresión regular más básico sin ninguna opción activada sólo utiliza r\"...\":julia> r\"^\\s*(?:#|$)\"\nr\"^\\s*(?:#|$)\"\n\njulia> typeof(ans)\nRegexPara comprobar si una regex se corresponde con una cadena, se utiliza  ismatch():julia> ismatch(r\"^\\s*(?:#|$)\", \"not a comment\")\nfalse\n\njulia> ismatch(r\"^\\s*(?:#|$)\", \"# a comment\")\ntrueComo puede verse aquí, ismatch() simplemente devuelve true o false, indicando si la regex dada coincide o no con la cadena. Es común, sin embargo, que uno quiera saber no sólo si una cadena coincide, sino también cómo coincide. Para capturar esta información sobre una coincidencia, se utiliza la función match():julia> match(r\"^\\s*(?:#|$)\", \"not a comment\")\n\njulia> match(r\"^\\s*(?:#|$)\", \"# a comment\")\nRegexMatch(\"#\")Si la expresión regular no coincide con la cadena dada, match() devuelve nothing – un valor especial que no imprime nada en el indicador interactivo. Aparte de no imprimir, es un valor completamente normal, como podemos comprobar en el siguiente código:m = match(r\"^\\s*(?:#|$)\", line)\nif m === nothing\n    println(\"not a comment\")\nelse\n    println(\"blank or comment\")\nendSi la expresión regular coincide, el valor devuelto por match()  es un objeto RegexMatch. Estos objetos registran cómo coincide la expresión, incluyendo la subcadena que coincide con el patrón y cualquier subcadena capturada, si la hay. Este ejemplo sólo captura la parte de la subcadena que coincide, pero tal vez quisiéramos capturar cualquier texto no en blanco después del carácter de comentario. Podríamos hacer lo siguiente:julia> m = match(r\"^\\s*(?:#\\s*(.*?)\\s*$|$)\", \"# a comment \")\nRegexMatch(\"# a comment \", 1=\"a comment\")Al invocar a match(), tenemos la opción de especificar un índice en el que iniciar la búsqueda. Por ejemplo:julia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",1)\nRegexMatch(\"1\")\n\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",6)\nRegexMatch(\"2\")\n\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",11)\nRegexMatch(\"3\")Puede extraer la siguiente información de un objeto RegexMatch:La totalidad de la subcadena emparejada: m.match\nLas subcadenas capturadas como una matriz de cadenas: m.captures\nEl desplazamiento en el que comienza la coincidencia del patrón: m.offset\nLos desplazamientos de las subcadenas capturadas como un vector: m.offsetsPara cuando una captura no coincide, en lugar de una subcadena, m.captures no contiene nada en esa posición, y m.offsets tiene un desplazamiento de cero (recuerde que los índices en Julia son 1-based, por lo que un desplazamiento de cero en una cadena es inválido). Aquí hay un par de ejemplos algo artificiales:julia> m = match(r\"(a|b)(c)?(d)\", \"acd\")\nRegexMatch(\"acd\", 1=\"a\", 2=\"c\", 3=\"d\")\n\njulia> m.match\n\"acd\"\n\njulia> m.captures\n3-element Array{Union{SubString{String}, Void},1}:\n \"a\"\n \"c\"\n \"d\"\n\njulia> m.offset\n1\n\njulia> m.offsets\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> m = match(r\"(a|b)(c)?(d)\", \"ad\")\nRegexMatch(\"ad\", 1=\"a\", 2=nothing, 3=\"d\")\n\njulia> m.match\n\"ad\"\n\njulia> m.captures\n3-element Array{Union{SubString{String}, Void},1}:\n \"a\"\n nothing\n \"d\"\n\njulia> m.offset\n1\n\njulia> m.offsets\n3-element Array{Int64,1}:\n 1\n 0\n 2Es conveniente que las capturas sean retornadas como un array para que uno pueda usar la sintaxis de desestructurante para enlazarlas a variables locales: julia> first, second, third = m.captures; first\n\"a\"Las capturas también está accesibles indexando el objeto RegexMatch con el número o nombre del grupo captura:julia> m=match(r\"(?<hour>\\d+):(?<minute>\\d+)\",\"12:45\")\nRegexMatch(\"12:45\", hour=\"12\", minute=\"45\")\n\njulia> m[:minute]\n\"45\"\n\njulia> m[2]\n\"45\"Las capturas pueden referenciarse en una cadena de sustitución cuando se utiliza replace() utilizando \\n para referirse al grupo de captura n-ésimo y prefijando la cadena de subsitución con s. El grupo de captura 0 se refiere a todo el objeto de coincidencia. Los grupos de captura nombrados se pueden hacer referencia en la sustitución con g<groupname>. Por ejemplo:julia> replace(\"first second\", r\"(\\w+) (?<agroup>\\w+)\", s\"\\g<agroup> \\1\")\n\"second first\"Los grupos de captura numerados pueden también ser referenciados como \\g<n> para evitar ambigüedad, como en:julia> replace(\"a\", r\".\", s\"\\g<0>1\")\n\"a1\"Puedes modificar el comportamiento de las expresiones regulares mediante una combinación de los flags i, m, s y x después de la marca de comillas dobles de cierre. Estas banderas tienen el mismo significado que en Perl, tal y como se describe en este fragmento de la [página de manual del referencia de Perl(http://perldoc.perl.org/perlre.html#Modifiers):i   Do case-insensitive pattern matching.\n\n    If locale matching rules are in effect, the case map is taken\n    from the current locale for code points less than 255, and\n    from Unicode rules for larger code points. However, matches\n    that would cross the Unicode rules/non-Unicode rules boundary\n    (ords 255/256) will not succeed.\n\nm   Treat string as multiple lines.  That is, change \"^\" and \"$\"\n    from matching the start or end of the string to matching the\n    start or end of any line anywhere within the string.\n\ns   Treat string as single line.  That is, change \".\" to match any\n    character whatsoever, even a newline, which normally it would\n    not match.\n\n    Used together, as r\"\"ms, they let the \".\" match any character\n    whatsoever, while still allowing \"^\" and \"$\" to match,\n    respectively, just after and just before newlines within the\n    string.\n\nx   Tells the regular expression parser to ignore most whitespace\n    that is neither backslashed nor within a character class. You\n    can use this to break up your regular expression into\n    (slightly) more readable parts. The '#' character is also\n    treated as a metacharacter introducing a comment, just as in\n    ordinary code.Por ejemplo, la siguiente regex tiene activados los tres flags:julia> r\"a+.*b+.*?d$\"ism\nr\"a+.*b+.*?d$\"ims\n\njulia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\nRegexMatch(\"angry,\\nBad world\")Las cadenas regex con triples comillas, de la forma r\"\"\"...\"\"\" están también soportadas (y puede ser conveniente para expresiones regulares que contengan comillas o caracteres de salto de línea)."
},

{
    "location": "manual/strings.html#man-byte-array-literals-1",
    "page": "Strings",
    "title": "Byte Array Literals",
    "category": "section",
    "text": "Otro literal de cadena no estándar útil es el literal de cadena de bytes: b \"...\". Esta forma nos permite usar la notación de cadena para expresar arrays de bytes literales, es decir, arrays de valores UInt8. Las reglas para los literales de arrays de bytes son las siguientes:Los caracteres ASCII y los escapes ASCII producen un solo byte.\n\\x y las secuencias de escape octales producen el byte correspondiente al valor de escape.\nLas secuencias de escape Unicode producen una secuencia de bytes que codifican ese punto de código en UTF-8.Hay una cierta superposición entre estas reglas ya que el comportamiento de \\x y escapes octales menores de 0x80 (128) están cubiertos por las dos primeras reglas, pero aquí estas reglas están de acuerdo. Juntas, estas reglas permiten usar fácilmente caracteres ASCII, valores arbitrarios de bytes y secuencias UTF-8 para producir matrices de bytes. Aquí hay un ejemplo usando los tres:julia> b\"DATA\\xff\\u2200\"\n8-element Array{UInt8,1}:\n 0x44\n 0x41\n 0x54\n 0x41\n 0xff\n 0xe2\n 0x88\n 0x80La secuencia ASCII \"DATA\" corresponde a los bytes 68, 65, 84, 65. \\xff produce el byte simple 255. El escape Unicode \\u2200 está codificado en UTF-8 como los tres bytes 226, 136, 128. Nótese que la matriz de bytes resultante no corresponde a una cadena UTF-8 válida - si intenta utilizar esto como una cadena literal normal, obtendrá un error de sintaxis:julia> \"DATA\\xff\\u2200\"\nERROR: syntax: invalid UTF-8 sequenceObserve también la distinción significativa entre \\xff y \\uff: la secuencia de escape anterior codifica el byte 255, mientras que la última secuencia de escape representa el punto de código 255, que se codifica como dos bytes en UTF-8:julia> b\"\\xff\"\n1-element Array{UInt8,1}:\n 0xff\n\njulia> b\"\\uff\"\n2-element Array{UInt8,1}:\n 0xc3\n 0xbfEn los literales de caracteres, esta distinción se pasa por alto y \\xff está autorizado a  representar el punto de código 255, porque los caracteres siempre representan puntos de código. En las cadenas, sin embargo, los escapes \\x siempre representan bytes, no puntos de código, mientras que los escapes \\u y \\U siempre representan puntos de código, que están codificados en uno o más bytes. Para los puntos de código inferiores a \\u80, ocurre que la codificación UTF-8 de cada punto de código es sólo el byte producido por el escape \\x correspondiente, por lo que la distinción puede ignorarse con seguridad. Sin embargo, para los escapes \\x80 a \\xff en comparación con \\u80 a \\uff, existe una diferencia importante: el primero escapa a todos los bytes sencillos de codificación, los cuales -a menos que sean seguidos por bytes de continuación muy específicos- no forman UTF-8 válido, mientras que los últimos escapes representan puntos de código Unicode con codificaciones de dos bytes.Si todo esto es muy confuso, intente leer \"The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets\". Es una excelente introducción a Unicode y UTF-8, y puede ayudar a aliviar cierta confusión sobre el asunto."
},

{
    "location": "manual/strings.html#man-version-number-literals-1",
    "page": "Strings",
    "title": "Literales Número de Versión",
    "category": "section",
    "text": "Los números de versión se pueden expresar fácilmente con literales de cadena no estándar del forma v\"...\". Los literales de número de versión crean objetos VersionNumber que siguen las especificaciones del control de versiones semánticas y, por lo tanto, se componen de valores numéricos mayor, menor y de parche, seguidos de anotaciones alfanuméricas de pre-liberación y construcción. Por ejemplo, v \"0.2.1-rc1 + win64\" se divide en versión principal 0, versión secundaria 2, versión de revisión 1, rc1 de pre-lanzamiento y construcción win64. Al introducir una versión literal, todo excepto el número de versión principal es opcional, por ejemplo, v\"0.2\" es equivalente a v\"0.2.0\" (con anotaciones previas / de compilación vacías), v\"2\" equivale a v\"2.0.0\", y así sucesivamente.Los objetos VersionNumber son en su mayoría útiles para comparar fácilmente y correctamente dos (o más) versiones. Por ejemplo, la constante VERSION contiene el número de versión de Julia como un objeto VersionNumber y, por lo tanto, se puede definir algún comportamiento específico de la versión utilizando declaraciones simples como:if v\"0.2\" <= VERSION < v\"0.3-\"\n    # do something specific to 0.2 release series\nendObsérvese que en el ejemplo anterior se utiliza el número de versión no estándar v\"0.3-\", con un guión - en cola: esta notación es una extensión Julia del estándar, y se usa para indicar una versión que es más baja que cualquier versión 0.3, Incluyendo todas sus pre-lanzamientos. Por lo tanto, en el ejemplo anterior, el código sólo se ejecuta con versiones estable 0.2 y excluye las versiones v\"0.3.0-rc1\". Para permitir también versiones 0.2 inestables (es decir, pre-liberación), la verificación del límite inferior debería modificarse de la siguiente manera: v\"0.2-\" <= VERSION.Otra extensión de especificación de versión no estándar permite usar un + de cola para expresar un límite superior en las versiones de compilación, por ej. VERSIÓN> v \"0.2-rc1 +\" se puede utilizar para significar cualquier versión por encima de 0.2-rc1 y cualquiera de sus compilaciones: devolverá false para la versión v\"0.2-rc1+win64\" y true para v\"0.2-rc2\".Es una buena práctica utilizar estas versiones especiales en comparaciones (en particular, el valor -de cola siempre debe utilizarse en los límites superiores a menos que haya una buena razón para no hacerlo), pero no deben utilizarse como el número de versión real de nada, ya que son inválidos en el esquema de versiones semánticas.Además de ser utilizados por la constante VERSION, los objetos VersionNumber son ampliamente utilizados en el módulo Pkg, para especificar las versiones de paquetes y sus dependencias."
},

{
    "location": "manual/strings.html#man-raw-string-literals-1",
    "page": "Strings",
    "title": "Raw String Literals",
    "category": "section",
    "text": "Las cadenas en bruto (raw) sin interpolación o unescaping pueden ser expresadas con literales cadena no estándar de la forma raw\"...\". Los literales cadena en bruto crean objetos String ordinarios que contienen los contenidos encerrados exactamente como entrados sin interpolación ni separación. Esto es útil para cadenas que contiene código o marcado en otros idiomas que usan $ o \\ como caracteres especiales. La excepción son las comillas que aún deben ser escapadas, por ejemplo,  raw\" \\ \"\"es equivalente a\"\\\" \"."
},

{
    "location": "manual/functions.html#",
    "page": "Funciones",
    "title": "Funciones",
    "category": "page",
    "text": ""
},

{
    "location": "manual/functions.html#man-functions-1",
    "page": "Funciones",
    "title": "Funciones",
    "category": "section",
    "text": "En Julia, una función es un objeto que hace corresponde una tupla de valores argumentos en un valor de retorno. Las funciones de Julia no son funciones matemáticas puras, en el sentido  de que pueden alterar y ser afectadas por el estado global del programa. La sintaxis básica  a definir funciones en Julia es:julia> function f(x,y)\n           x + y\n       end\nf (generic function with 1 method)Hay una segunda sintaxis, más concisa, para definir una función en Julia. La declaración de  función tradicional mostrada anteriormente es equivalente a la denominada \"forma de asignación\".  Por ejemplo:julia> f(x,y) = x + y\nf (generic function with 1 method)En esta segunda forma, el cuerpo de la función debe ser una sola expresión, aunque puede  tratarse de una expresión compuesta (see Expresiones Compuestas).  Estas definiciones de función cortas y simples son comunes en Julia. La sintaxis de funciones cortas es, por tanto, bastante idiomática, reduciendo considerablemente tanto la escritura como  el ruido visual.Para invocar una función se usa la sintaxis tradicional basada en el uso del paréntesis:julia> f(2,3)\n5Sin usar paréntesis, la expresión f se refiere al objeto función, y puede ser tratada como cualquier otro valor:julia> g = f;\n\njulia> g(2,3)\n5Y, como en el caso de las variables, podemos usar Unicode en el caso de los nombres de función:julia> ∑(x,y) = x + y\n∑ (generic function with 1 method)\n\njulia> ∑(2, 3)\n5"
},

{
    "location": "manual/functions.html#Comportamiento-del-Paso-de-Argumentos-1",
    "page": "Funciones",
    "title": "Comportamiento del Paso de Argumentos",
    "category": "section",
    "text": "Los argumentos de función en Julia siguen un convenio denominado a veces \"paso por compartición\",  que significa que los valores no son copiados cuando se pasan a las funciones. Los argumentos de  las funciones actúan ellos mismos como nuevos enlaces a variable (nuevas localizaciones que pueden  referirse a valores) pero los valores a los que se refieren son idénticos a los valores pasados.  Las modificaciones a valores mutables (tales como los Arrays) hechos dentro de la función serán  visibles desde fuera de ésta. Este es el mismo comportamiento que presenta Scheme, la mayoría de  versiones de Lisp, Python, Ruby y Perl, entre otros lenguajes dinámicos."
},

{
    "location": "manual/functions.html#La-palabra-clave-return-1",
    "page": "Funciones",
    "title": "La palabra clave return",
    "category": "section",
    "text": "El valor devuelto por una función es el valor de la última expresión evaluada, el cual, por  defecto, es la última expresión en el cuerpo de definición de la función. En la función f,  mostrada en la sección anterior, el valor devuelto sería la suma x + y. Como en C y la mayoría  de los demás lenguajes imperativos o funcionales, la palabra clave return causa que la función  retorne inmediatamente, proporcionando una función cuyo valor es devuelto:function g(x,y)\n    return x * y\n    x + y\nendComo las definiciones a función pueden ser introducidas en una sesión interactiva, es muy sencillo comparar estas definiciones:julia> f(x,y) = x + y\nf (generic function with 1 method)\n\njulia> function g(x,y)\n           return x * y\n           x + y\n       end\ng (generic function with 1 method)\n\njulia> f(2,3)\n5\n\njulia> g(2,3)\n6Por supuesto, en una función con cuerpo puramente lineal como g, el uso de return es irrelevante ya que la expresión x+y nunca va a ser evaluada, por lo que podríamos hacer que x*y fuese la última línea de la función y omitir el return. Sin embargo, cuando hacemos uso de esta instrucción junto con otras de control de flujo, el resultado puede ser muy interesante. Aquí, por ejemplo, hay una función que calcula la longitud de la hipotenusa de un triángulo equilátero correcto con catetos de longitudes x e y, evitando un desbordamiento:julia> function hypot(x,y)\n           x = abs(x)\n           y = abs(y)\n           if x > y\n               r = y/x\n               return x*sqrt(1+r*r)\n           end\n           if y == 0\n               return zero(x)\n           end\n           r = x/y\n           return y*sqrt(1+r*r)\n       end\nhypot (generic function with 1 method)\n\njulia> hypot(3, 4)\n5.0Hay tres posibles puntos de retorno en esta función, devolviendo los valores de tres expresiones diferentes, dependiendo de los valores de x e y. El return de la última línea podría ser omitido ya que es la última expresión."
},

{
    "location": "manual/functions.html#Operators-Are-Functions-1",
    "page": "Funciones",
    "title": "Operators Are Functions",
    "category": "section",
    "text": "En Julia, la mayoría de los operadores son funciones con soporte para una sintaxis especial (la excepción a esta regla son las operaciones con una semática de evaluación especial, tales como && y ||. Estos operadores no pueden ser funciones porque la Evaluación en Cortocircuito requiere que sus operandos no sean evaluados antes de la evaluación del operador). De acuerdo con ésto, podemos usar listas de argumentos entre paréntesis, tal como en cualquier otra función:julia> 1 + 2 + 3\n6\n\njulia> +(1,2,3)\n6La forma infija es equivalente a la forma de aplicación función. De hecho, la primera es transformada para producir la llamada a función internamente. Esto también significa que puedes asignar y pasar operadores tales como +() y *() , tal y como se hace con otros valores función:julia> f = +;\n\njulia> f(1,2,3)\n6Sin embargo, cuando se usa el formato de función, como f, no se puede usar notación infija."
},

{
    "location": "manual/functions.html#Operadores-con-Nombres-Especiales-1",
    "page": "Funciones",
    "title": "Operadores con Nombres Especiales",
    "category": "section",
    "text": "Hay unas pocas operaciones especiales que corresponden a llamadas a funciones con nombres no obvios. Estas son las siguientes:Expresión        Llamada              \n[A B C ...] hcat()\n[A; B; C; ...] vcat()\n[A B; C D; ...] hvcat()\nA' ctranspose()\nA.' transpose()\n1:n colon()\nA[i] getindex()\nA[i]=x setindex!()Estasa funciones están incluidas en el módulo Base.Operators incluso aunque no tengan nombres como operadores."
},

{
    "location": "manual/functions.html#man-anonymous-functions-1",
    "page": "Funciones",
    "title": "Funciones Anónimas",
    "category": "section",
    "text": "Las funciones en Julia son objetos de primera clase: ellas pueden ser asignadas a variables y ser invocadas usando la sintaxis estándar de llamadas a función desde la variable a la que han sido asignadas. Ellas pueden ser usadas como argumentos y ser devueltas como valores. Ellas pueden también ser usadas de forma anónima sin dárseles un nombre, usando alguna de estas sintaxis:julia> x -> x^2 + 2x - 1\n(::#1) (generic function with 1 method)\n\njulia> function (x)\n           x^2 + 2x - 1\n       end\n(::#3) (generic function with 1 method)Esto crea una función que toma un argumento x y devuelve el valor del polinomio x^2 + 2x - 1. Nótese que el resultado es una función genérica, pero con un nombre generado por el compilador basado en una numeración consecutiva.El uso primario de las funciones anónimas es pasarlas a funciones que toman otras funciones como argumentos. Un ejemplo clásico es map(), , que aplica una función a cada valor de un array y devuelve un nuevo array que contienen los valores resultantes:julia> map(round, [1.2,3.5,1.7])\n3-element Array{Float64,1}:\n 1.0\n 4.0\n 2.0Esto está bien si ya exite una función que efectúa la transformación que uno desea para pasarla como primer argumento de map(). Sin embargo, no es frecuente que exista este tipo de función. En estas situaciones, el constructor de la función anónima permite una fácil creación de un objeto función de un solo uso sin necesidad de asignarle un nombre:julia> map(x -> x^2 + 2x - 1, [1,3,-1])\n3-element Array{Int64,1}:\n  2\n 14\n -2Para escribir funciones anónimas que aceptan múltiples argumentos puede utilizarse la sintaxis (x,y,z) -> 2x + y +z. Una función anónima con cero argumentos se escribe como () -> 3.  La idea de una función sin argumentos puede parecer extraña, pero es útil para demorar un cálculo. En este uso, un bloque de código es envuelto en una función con cero argumentos, el cual es después invocado mediante una llamada como f()."
},

{
    "location": "manual/functions.html#Retorno-de-Múltiples-Valores-1",
    "page": "Funciones",
    "title": "Retorno de Múltiples Valores",
    "category": "section",
    "text": "En Julia, uno devuelve una tupla para simular el retorno de múltiples valores. Sin embargo, como las tuplas puede salteadas y destruidas sin necesitar paréntesis, podemos proporcionar una ilusión de que se están devolviendo múltiples valores. Por ejemplo, la siguiente función devuelve un par de valores:julia> function foo(a,b)\n           a+b, a*b\n       end\nfoo (generic function with 1 method)Si invocamos esta función en una sesión interactiva sin asignar los valores en ningún sitio, comprobaremos que la función devuelve una tupla:julia> foo(2,3)\n(5, 6)Un uso típico de tal par de valores devueltos es extraer cada valor en una variable. Julia soporta la \"desestructuración\" simple de una tupla que facilita esto:julia> x, y = foo(2,3)\n(5, 6)\n\njulia> x\n5\n\njulia> y\n6Y también podemos devolver múltiples valores mediante el uso explícito de la palabra clave return:function foo(a,b)\n    return a+b, a*b\nendEsto tiene exactamente el mismo efecto que la definición anterior de foo."
},

{
    "location": "manual/functions.html#vararg-functions-1",
    "page": "Funciones",
    "title": "Funciones con argumentos variables (varargs)",
    "category": "section",
    "text": "Suele ser muy conveniente ser capaz de escribir funciones que toman un número arbitrario de argumentos. Estas funciones se conocen como funciones vararg. Podemos definir funciones de tal tipo poniendo puntos suspensivos … después del último argumento.julia> bar(a,b,x...) = (a,b,x)\nbar (generic function with 1 method)Las variables a y b están asociadas a los dos primeros argumentos como es natural, y la variable x se asocia a una colección, iterable de cero o más valores pasados a la función bar después de estos dos argumentos:julia> bar(1,2)\n(1, 2, ())\n\njulia> bar(1,2,3)\n(1, 2, (3,))\n\njulia> bar(1, 2, 3, 4)\n(1, 2, (3, 4))\n\njulia> bar(1,2,3,4,5,6)\n(1, 2, (3, 4, 5, 6))En todos los casos, x es asociada a una tupla con el resto de valores pasados a la función.Es posible restringir el número de argumentos pasados como argumento variable. Esto se discutirá más adelante en la sección métodos vararg restringidos paramétricamente.Como contraposición, es frecuente manejar la división de los valores contenidos en una colección iterable en una llamada a función como argumentos individuales. Para hacer eso, se utilizará la notación de puntos suspensivos, pero esta vez en la llamada a función.julia> x = (3, 4)\n(3, 4)\n\njulia> bar(1,2,x...)\n(1, 2, (3, 4))En este caso hay una tupla que se divide en una llamada vararg precisamente donde está el número de argumentos variable. Esa necesidad no tiene por qué ser el caso:julia> x = (2, 3, 4)\n(2, 3, 4)\n\njulia> bar(1,x...)\n(1, 2, (3, 4))\n\njulia> x = (1, 2, 3, 4)\n(1, 2, 3, 4)\n\njulia> bar(x...)\n(1, 2, (3, 4))Además, el objeto iterable dividido durante la llamada a función no tiene que ser una tupla:julia> x = [3,4]\n2-element Array{Int64,1}:\n 3\n 4\n\njulia> bar(1,2,x...)\n(1, 2, (3, 4))\n\njulia> x = [1,2,3,4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> bar(x...)\n(1, 2, (3, 4))También, la función cuyos argumentos son divididos no tiene por qué ser una función vararg (aunque frecuentemente lo sea):julia> baz(a,b) = a + b;\n\njulia> args = [1,2]\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> baz(args...)\n3\n\njulia> args = [1,2,3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> baz(args...)\nERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)\nClosest candidates are:\n  baz(::Any, ::Any) at none:1Como puede comprobarse, si el número de elementos que se van a sacar del contenedor es inapropiado  para pasar a la función como argumentos, se generará un error, igual que si hubiéramos realizado la llamada a función con un número de argumentos inapropiado."
},

{
    "location": "manual/functions.html#Argumentos-Opcionales-1",
    "page": "Funciones",
    "title": "Argumentos Opcionales",
    "category": "section",
    "text": "En muchos casos, los argumentos de función tienen valores por defecto sensibles y, por tanto, puede no ser necesario que se pasen explícitamente en cada llamada. Por ejemplo, la función de librería parse(T, num, base) interpreta una cadena como un número en cierta base. El argumento base tiene un valor por defecto de 10. Este comportamiento puede expresarse de forma concisa como:function parse(T, num, base=10)\n    ###\nendCon esta definición, la función puede ser llamada con dos o tres argumentos y, cuando no se pase el tercer argumento, la función asignara el valor por defecto de 10 al parámetro base.julia> parse(Int,\"12\",10)\n12\n\njulia> parse(Int,\"12\",3)\n5\n\njulia> parse(Int,\"12\")\n12Los argumentos opcionales son una sintaxis conveniente para escribir múltiples definiciones de métodos con diferentes números de argumentos (ver Nota sobre Argumentos opcionales y keyword)."
},

{
    "location": "manual/functions.html#Argumentos-*keyword*-1",
    "page": "Funciones",
    "title": "Argumentos keyword",
    "category": "section",
    "text": "Algunas funciones necesitan un número de argumentos grande o tienen un gran número de comportamientos. Recordar como llamar a tales funciones puede ser difícil. Los argumentos keyword pueden hacer que estas interfaces complejas sean más fáciles de usar y extender permitiendo que los argumentos sean identificados por su nombre en lugar del por su posición.Por ejemplo, considere una función plot que traza una línea. Esta función puede tener muchas opciones para controlar el estilo de línea, su ancho, su color, etc. Si la función  aceptara argumentos keyword, una posible llamada al método seria plot(x,y, width=2), donde hemos elegido especificar sólo el ancho de línea. Nótese que esto sirve a dos propósitos: La llamada es más sencillo leer, ya que podemos etiquetar un argumento con su significado. También se vuelve posible pasar cualquier subconjunto de un gran número de argumentos, en cualquier orden.Las funciones con argumentos keyword se definen usando un punto y coma en la signatura:function plot(x, y; style=\"solid\", width=1, color=\"black\")\n    ###\nendCuando la función es invocada, el punto y coma es opcional: uno puede hacer la llamada como plot(x, y, width=2)o como plot(x, y; width=2), aunque el primero es más común. Se requiere un punto y coma explícito sólo en el caso de pasar vargars o palabras clave calculadas como se describe abajo.Los valores por defecto de los argumentos keyword son evaluados sólo cuando sea necesario (cuando no se pasa el correspondiente argumento keyword) y en orden izquierda a derecha. Por tanto, las expresiones por defecto pueden referirse a argumentos keyword previos.Los tipos de argumentos keyword  pueden hacerse explícitos de la siguiente forma:function f(;x::Int64=1)\n    ###\nendLos argumentos keyword extra pueden ser recolectados usando ... como en las funciones vararg:function f(x; y=0, kwargs...)\n    ###\nendDentro de f, kwargs será una colección de tuplas (clave,valor), donde cada clave es un símbolo. Tales colecciones pueden ser pasadas como argumentos keyword usando un punto y coma en la llamada. Por ejemplo: f(x, z=1; kwargs...). Los diccionarios pueden ser también usados para este propósito.Uno puede también pasar tuplas (clave, valor) o cualquier expresión iterable (tal como un par =>) que puede ser asignado a una tupla, explícitamente después de un punto y coma. Por ejemplo, plot(x, y; (:width,2)) y plot(x, y; :width => 2) son equivalentes a plot(x, y, width=2). Esto es útil en situaciones donde el nombre de la palabra clave se calcula en tiempo de ejecución.La naturaleza de los argumentos keyword  le hace posible especificar el mismo argumento más de una vez. Por ejemplo, en la llamada plot(x, y; options..., width=2) es posible que la estructura options contenga también un valor para width. En tal caso la ocurrencia más a la derecha toma precedencia; en este ejemplo width tendrá el valor 2."
},

{
    "location": "manual/functions.html#Ámbito-de-evaluación-de-Valores-por-defecto-1",
    "page": "Funciones",
    "title": "Ámbito de evaluación de Valores por defecto",
    "category": "section",
    "text": "Los argumentos opcionales y keyword difieren ligeramente en cómo sus valores son evaluados. Cuando se evalúan expresiones por defecto con valores opcionales, sólo están en el ámbito lo valores previos. En contraste, cuando se evalúan las expresiones por defecto con argumentos keyword, todos los argumentos están en el ámbito. Por ejemplo, dada esta definición:function f(x, a=b, b=1)\n    ###\nendla b en a=b se refiere a la b de un ámbito más externo, no el siguiente argumento b. Sin embargo, si a y b fueran argumentos keyword en lugar de opcionales, el b en a=b se referiría al argumento posterior b (ocultando a cualqiuer b de un ámbito ms externo), lo que resultaría en un error de variable indefinida (ya que las expresiones por defecto son evaluadas de izquierda a derecha, y b no ha sido aún asignada)."
},

{
    "location": "manual/functions.html#Sintaxis-Bloque-Do-para-Argumentos-Function-1",
    "page": "Funciones",
    "title": "Sintaxis Bloque Do para Argumentos Function",
    "category": "section",
    "text": "Pasar funciones como argumentos a otras funciones es una técnica muy potente, pero su sintaxis no es siempre conveniente. Estas llamadas son especialmente incómodas de escribir cuando la función argumento necesita varias líneas. Por ejemplo, consideremos llamar a  map() sobre una función con varios casos:map(x->begin\n           if x < 0 && iseven(x)\n               return 0\n           elseif x == 0\n               return 1\n           else\n               return x\n           end\n       end,\n    [A, B, C])Julia proporciona la palabra reservada do para reescribir este código de forma más clara:map([A, B, C]) do x\n    if x < 0 && iseven(x)\n        return 0\n    elseif x == 0\n        return 1\n    else\n        return x\n    end\nendLa sintaxis do x crea una función anónima con argumento x y la pasa como primer argumento a map(). Similarmente, do a,b crearía una función anónima de dos argumentos, y un do solo sería una función anónima de la forma () -> ....Cómo se inicializan estos argumentos depende de la función más externa; aquí map() fijará secuencialmente x a A,B,C llamando a la función anónima sobre cada uno de ellos, tal y como pasa en la sintaxis map(func, [A,B,C]).Esta sintaxis hace más fácil usar funciones para extender el lenguaje de forma efectiva, ya que las llamadas tiene el aspecto de códigos de bloque normales. Hay muchos usos posibles diferentes al de map(), tal como la gestión del estado del sistema. Por ejemplo, hay una versión de  open() que ejecuta código asegurando que el fichero abierto es cerrado eventualmente:open(\"outfile\", \"w\") do io\n    write(io, data)\nendEsto se consigue mediante la siguiente definición:function open(f::Function, args...)\n    io = open(args...)\n    try\n        f(io)\n    finally\n        close(io)\n    end\nendAquí, open() primero abre el fichero para escritura y luego pasa el flujo de salida resultante a la función anónima que se define en el bloque do...end.  Después de que la función exista, open() asegurará que el flujo ha sido cerrado apropiadamente, sin preocuparse de si la función salió normalmente o lanzó una excepción (la construcción  try/finally será descrita en Control de Flujo.)Con la sintaxis de bloque do se ayuda a chequear la documentación o implementaciones para saber cómo se inicializan los argumentos de la función de usuario."
},

{
    "location": "manual/functions.html#man-vectorized-1",
    "page": "Funciones",
    "title": "Sintaxis Punto para funciones Vectorizadas",
    "category": "section",
    "text": "En los lenguajes de computación técnicos es común tener versiones \"vectorizadas\" de funciones, las cuales aplican una función dada f(x) a cada elemento de un array A para producir un nuevo array vía f(A). Esta clase de sintaxis es conveniente para procesamiento de datos, pero en otros lenguajes la vectorización es también requerida en aras de mejorar el rendimiento:  si los bucles son lentos, la versión \"vectorizada\" de una función podría llamar al código de librería rápido en un lenguaje de bajo nivel. En Julia, las funciones actualizadas no son requeridas por motivos de vencimiento; de hecho, suele ser beneficioso que el usuario escriba sus propios bucles (ver Consejos de rendimiento), a veces incluso conveniente. Por tanto cualquier función Julia f puede ser aplicada elemento a elemento a cualquier array (u otra colección) con la sintaxis f.(A). Por ejemplo sin puede ser aplicado a todos los elementos del vector A de esta forma:julia> A = [1.0, 2.0, 3.0]\n3-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n\njulia> sin.(A)\n3-element Array{Float64,1}:\n 0.841471\n 0.909297\n 0.14112Por supuesto, uno puede omitir el punto si escribe un método especial para vectores de f por ejemplo, vía f(A::AbstractArray) = map(f, A) y esto es tan eficiente como f.(A). Pero este enfoque necesitaría que decidas a priori qué funciones quieres vectorizar.Más generalmente, f.(args...) es de hecho equivalente a broadcast(f, args...), que te permite operar sobre múltiples arrays (incluso de formas distintas) o una mezcla de arrays y escalares (ver Broadcasting). Por ejemplo, si tenemos f(x,y) = 3x + 4y, entonces f.(pi,A) devolverá un nuevo array consistente en f(pi,a)para cada a en A, y f.(vector1,vector2) devolverá un nuevo vector que consiste en f(vector1[i],vector2[i]) para cada índice i (lanzando una excepción si los vectores tienen diferente longitud).julia> f(x,y) = 3x + 4y;\n\njulia> A = [1.0, 2.0, 3.0];\n\njulia> B = [4.0, 5.0, 6.0];\n\njulia> f.(pi, A)\n3-element Array{Float64,1}:\n 13.4248\n 17.4248\n 21.4248\n\njulia> f.(A, B)\n3-element Array{Float64,1}:\n 19.0\n 26.0\n 33.0Además, las llamadas anidadas f.(args...)se funden en un solo broadcast. Por ejemplo sin.(cos.(X)) es equivalent a broadcast(x->sin(cos(x)), X), lo cuál es similar a [sin(cos(x)) for x in X]. Hay un solo bucle sobre X, y se asigna un solo array para el resultado. En contraste, sin(cos(X)) en un lenguaje vectorizado típio asignaría primero un array temporal tmp = cos(X) y luego calcularía sin(tmp) en un bucle separado, asignando un segundo array. Esta fusión de bucles no es una optimización del compilador que puede ocurrir o no, sino que es una garantía sintáctica  cuando se encuentran llamadas f.(array...) anidadas. Técnicamente, la fusión se para en cuanto se encuentr una función sin punto, por ejemplo, en sin.(srt(cos.(X))) los bucles de sin y cos no pueden mezclarse debido a la intervención de la función sort.Finalmente, la eficiencia máxima suele conseguirse cuando el array de salida de una operación vectorizada es pre-asignado, por lo que las llamadas repetidas no asignarán nuevos arrays una y otra vez para los resultados (ver Preasignando salidas). Una sintaxis conveniente para esto es X .= ... que es equivalente a broadcast!(identity, X, ...) excepto que, como antes, el bucle broadcast! es fusionado con cualquier llamada con punto anidada. Por ejemplo, X .= sin.(Y) es equivalente a broadcast!(sin, X, Y), sobreescribiendo X con sin.(Y) en su lugar. Si el miembro izquierdo de la expresión es una expresión de indexación de un array, como X[2:end] .= sin.(Y) entonces ella se traduce a broadcast! sobre una vista, por ejemplo broadcast!(sin, view(X, 2:endof(X)), Y).Como añadir puntos a muchas operaciones y llamadas a función puede resultar tedioso y conducir a código difícil de leer, se proporciona la macro @. para convertir cada llamada a función, operación y asignación en una expresion en su versión \"con puntos\".julia> Y = [1.0, 2.0, 3.0, 4.0];\n\njulia> X = similar(Y); # pre-allocate output array\n\njulia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))\n4-element Array{Float64,1}:\n  0.514395\n -0.404239\n -0.836022\n -0.608083Los operadores binarios (o unarios) como .+ se manejan con el mismo mecanismo: son equivalentes a llamadas retransmitidas (broadcast) y son fundidas con otras llamadas que tiene puntos. X .+= Y etcetera es equivalente a X .= X .+ Y y dan como resultado una asignación fusionada. Ver también dot operators."
},

{
    "location": "manual/functions.html#Otras-Lecturas-1",
    "page": "Funciones",
    "title": "Otras Lecturas",
    "category": "section",
    "text": "Deberíamos mencionar que esto está lejos de ser una visión completa de las definiciones de función. Julia tiene un sistema de tipos sofisticado y permite despacho múltiple sobre los tipos de argumento. Ninguno de los ejemplos dados aquí proporciona anotaciones de tipo sobre sus argmentos, lo que significa que son aplicables a cualquier tipo de argumento. El sistema de tipos es descrito en Tipos definir una función en términos de métodos elegidos mediante despacho múltiple sobre los tpos de argumento en tiempo de ejecucoión se describe en el capítulo Methods."
},

{
    "location": "manual/control-flow.html#",
    "page": "Control Flow",
    "title": "Control Flow",
    "category": "page",
    "text": ""
},

{
    "location": "manual/control-flow.html#control-flow-1",
    "page": "Control Flow",
    "title": "Control Flow",
    "category": "section",
    "text": "Julia proporciona una variedad de construcciones para control de flujo:Expresiones Compuestas: begin and (;).\nEvaluación Condicional: if-elseif-else and ?: (ternary operator).\nEvaluación en Cortocircuito: &&, || and chained comparisons. \nEvaluación Repetida: Bucles: while and for.\nManejo de Excepciones: try-catch, error() and throw().\nTareas (también denominadas Coroutinas): yieldto().Los cinco primeros mecanismos de control de flujo son estándar en los lenguajes de programación de alto nivel. Las tareas no son un mecanismo tan estándar: ellas proporcionan control de flujo no local, haciendo posible conmutar entre cálculos suspendidos temporalmente. Esta es una construcción potente: tanto el manejo de excepciones como la multitarea cooperativa se implementan en Julia usando tareas. La programación diaria no suele requerir el uso de tareas, pero ciertos problemas se resuelve de forma mucho más sencilla usando este mecanismo."
},

{
    "location": "manual/control-flow.html#man-compound-expressions-1",
    "page": "Control Flow",
    "title": "Expresiones Compuestas",
    "category": "section",
    "text": "Algunas veces es conveniente tener una sola expresión que lleva nueve varias subexpresiones en orden, devolviendo el valor de la última subexpresión como su valor. Hay dos construcciones en Julia que llevan a cabo este trabajo: los bloques begin y las cadenas ; El valor de ambas expresiones compuestas es el de la última subexpresión. He aquí un ejemplo del bloque begin:julia> z = begin\n           x = 1\n           y = 2\n           x + y\n       end\n3Como estas expresiones son bastante pequeñas, podrían ponerse con facilidad en una sola línea, que es donde la sintaxis encadenada (;) es más útil:julia> z = (x = 1; y = 2; x + y)\n3Esta sintaxis es particularmente útil con la definición de función de una línea que introdujimos en Funciones. Aunque es típico, no hay obligación de que los bloques begin sean multilínea o de que las cadenas de punto y coma (;) tengan una única línea.julia> begin x = 1; y = 2; x + y end\n3\n\njulia> (x = 1;\n        y = 2;\n        x + y)\n3"
},

{
    "location": "manual/control-flow.html#man-conditional-evaluation-1",
    "page": "Control Flow",
    "title": "Evaluación Condicional",
    "category": "section",
    "text": "La evaluación condicional permite que porciones de código sean evaluadas o no evaluadas dependiendo del valor de una expresión booleana. Esta es la anatomía de la estructura de  if-elseif-else:if x < y\n    println(\"x is less than y\")\nelseif x > y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nendEn el ejemplo anterior, si la condición x<y es verdadera, entonces se evaluará el bloque correspondiente. En caso contrario se evaluará la expresión x>y, y si esta es verdadera, se ejecutará el bloque correspondiente. Si la expresión también es falsa, se ejecutaría el bloque correspondiente al else. Veámoslo en acción:julia> function test(x, y)\n           if x < y\n               println(\"x is less than y\")\n           elseif x > y\n               println(\"x is greater than y\")\n           else\n               println(\"x is equal to y\")\n           end\n       end\ntest (generic function with 1 method)\n\njulia> test(1, 2)\nx is less than y\n\njulia> test(2, 1)\nx is greater than y\n\njulia> test(1, 1)\nx is equal to yLos bloques elsif y else son opcionales, y además pueden usarse tantos elsif como se deseen. Las expresiones condicionales del if-elsif-else serán evaluadas hasta que una de ellas se evalúe a true, después de lo cuál se evaluará el blqoue asociado, y ya no se evaluarán más expresiones condicionales.Los bloques if son \"permeables\", es decir, no introducen un ámbito local. Eso significa que las variables que se definen dentro del bloque serán visibles fuera del mismo. Por tanto, podríamos haber definido la relación test de antes como...julia> function test(x,y)\n           if x < y\n               relation = \"less than\"\n           elseif x == y\n               relation = \"equal to\"\n           else\n               relation = \"greater than\"\n           end\n           println(\"x is \", relation, \" y.\")\n       end\ntest (generic function with 1 method)\n\njulia> test(2, 1)\nx is greater than y.La variable relation se ha declarado dentro del bloque if,  pero se usa fuera. Sin embargo, cuando se hace uso de este tipo de variables, hay que asegurarse de que todos los caminos de código definen un valor para la variable. La siguiente función no lo tiene en cuenta y genera un error en tiempo de ejecución.julia> function test(x,y)\n           if x < y\n               relation = \"less than\"\n           elseif x == y\n               relation = \"equal to\"\n           end\n           println(\"x is \", relation, \" y.\")\n       end\ntest (generic function with 1 method)\n\njulia> test(1,2)\nx is less than y.\n\njulia> test(2,1)\nERROR: UndefVarError: relation not defined\nStacktrace:\n [1] test(::Int64, ::Int64) at ./none:7Los bloques if también devuelven un valor, lo que puede no parecer intuitivo para quienes proceden de otros lenguajes de programación no funcionales. Este valor no es más que el devuelto por la última instrucción en la rama que fue elegida. Por tanto:julia> x = 3\n3\n\njulia> if x > 0\n           \"positive!\"\n       else\n           \"negative...\"\n       end\n\"positive!\"Nótese que las instrucciones condicionales muy cortas (de una línea) se suelen expresar en Julia mediante evaluación en cortocircuito, como se verá en la siguiente sección.A diferencia de C, MATLAB, Perl, Python y Ruby (pero como en Java y en otros lenguajes tipados, más estrictos) en Julia se produce un error si el valor de una expresión condicional es algo que no sea true o false.julia> if 1\n           println(\"true\")\n       end\nERROR: TypeError: non-boolean (Int64) used in boolean contextEste error indica que el condicional era de un tipo incorrecto: Int64 en lugar del requerido Bool.El llamado operador ternario (?) está muy relacionado con la sintaxis de if-elsif-else, pero se usa donde hay que hacer una elección condicional entre expresiones sencillas, a diferencia de la ejecución condicional de grandes bloques de código. Su nombre se debe a que es el único operador que toma tres operandos en la mayoría de los lenguajes de programación:a ? b : cLa expresión a delante del ? es una expresión condicional, y la operación ternaria evalúa la expresión b (la que está delante del símbolo :)  si la condición a es true o la expresión c si la condición a es false. Nótese que los espacios alrededor de ? y : son obligatorios: una expresión como a?b:c no es una expresin ternaria válida (aunque se pueden utilizar saltos de línea entre los símbolos ? y :).La forma más fácil de comprender este comportamiento es ver un ejemplo. En el ejemplo anterior, la llamada a println es compartida por las tres ramas: la única elección real es qué cadena literal imprimir. Esto podría haberse escrito de forma más concisa usando el operador ternario. En aras de la claridad, intentemos primero la versión con dos caminos:julia> x = 1; y = 2;\n\njulia> println(x < y ? \"less than\" : \"not less than\")\nless than\n\njulia> x = 1; y = 0;\n\njulia> println(x < y ? \"less than\" : \"not less than\")\nnot less thanEn los ejemplos anteriores, si x < y es true se devolverá la cadena \"less than\" y, en caso contrario, se devolverá la cadena \"not less than\". El ejemplo original, que tiene tres opciones, requeriría el uso encadenado del operador ?:julia> test(x, y) = println(x < y ? \"x is less than y\"    :\n                            x > y ? \"x is greater than y\" : \"x is equal to y\")\ntest (generic function with 1 method)\n\njulia> test(1, 2)\nx is less than y\n\njulia> test(2, 1)\nx is greater than y\n\njulia> test(1, 1)\nx is equal to yPara facilitar el encadenamiento, el operador ? asocia de derecha a izquierda.Es también significativo que, como en la construcción if-elsif-else las expresiones anterior y posterior al símbolo : sólo se evalúan si la expresión condicional es evaluada a true o false, respectivamente.julia> v(x) = (println(x); x)\nv (generic function with 1 method)\n\njulia> 1 < 2 ? v(\"yes\") : v(\"no\")\nyes\n\"yes\"\n\njulia> 1 > 2 ? v(\"yes\") : v(\"no\")\nno\n\"no\""
},

{
    "location": "manual/control-flow.html#short-circuit-evaluation-1",
    "page": "Control Flow",
    "title": "Evaluación en Cortocircuito",
    "category": "section",
    "text": "La evaluación en cortocircuito es bastante similar a la evaluación condicional. Este comportamiento aparece en la mayoría de los lenguajes de programación imperativos que tiene los operadores booleanos && y ||.  En una serie de expresiones booleanas conectadas por estos operadores, sólo se evalúa el número mínimo de expresiones necesarios para determinar el valor booleano final de la cadena completa. Explícitamente, esto significa que:En la expresión a && b la subexpresión b sólo se evalúa si la subexpresión a es evaluada a true.\nEn la expresión a || b la subexpresión b sólo se evalúa si la subexpresión a es evaluada a false.El razonamiento es que a && b debe ser false si a is false, independientemente del valor de b y, análogamente, el valor de a || b debe ser cierto si a es true, independientemente del valor de b. Tanto && como || asocian a la derecha, pero && tiene mayore precedencia que ||. Es fácil experimentar con este comportamiento:julia> t(x) = (println(x); true)\nt (generic function with 1 method)\n\njulia> f(x) = (println(x); false)\nf (generic function with 1 method)\n\njulia> t(1) && t(2)\n1\n2\ntrue\n\njulia> t(1) && f(2)\n1\n2\nfalse\n\njulia> f(1) && t(2)\n1\nfalse\n\njulia> f(1) && f(2)\n1\nfalse\n\njulia> t(1) || t(2)\n1\ntrue\n\njulia> t(1) || f(2)\n1\ntrue\n\njulia> f(1) || t(2)\n1\n2\ntrue\n\njulia> f(1) || f(2)\n1\n2\nfalseSe puede experimentar de forma parecida con la asociatividad y la precedencia de varias combinaciones de operadores && y ||.Este comportamiento se utiliza en Julia con frecuencia para formar una alternativa a instrucciones if muy cortas. En lugar de usar la construcción if <cond> && <instrucción> uno puede escribir <cond> && <instrucción> que puede leerse como <cond> y entonces <instrucción>. de forma similar, uno puede escribir <cond> || <instrucción>, que se leería como <cond> o sino <instrucción> en lugar de if !<cond> || <instrucción>.Por ejemplo, una rutina recursiva para obtener un factorial podría ser definida como:julia> function fact(n::Int)\n           n >= 0 || error(\"n must be non-negative\")\n           n == 0 && return 1\n           n * fact(n-1)\n       end\nfact (generic function with 1 method)\n\njulia> fact(5)\n120\n\njulia> fact(0)\n1\n\njulia> fact(-1)\nERROR: n must be non-negative\nStacktrace:\n [1] fact(::Int64) at ./none:2Las operaciones booleanas sin cortocircuito podrían llevarse a cabo con los operadores a nivel de bit introducidos en la sección Operaciones Matemáticas y Funciones Elementales: & y |. Estas son funciones normales, que suportan la sintaxis infija de los operadores, pero que siempre evalúan sus argumentos:julia> f(1) & t(2)\n1\n2\nfalse\n\njulia> t(1) | t(2)\n1\n2\ntrueComo en el caso de las expresiones condicionales usadas en if, elsif o el operador ternario ?, los operandos de && y de || deben ser valores booleanos.  Usar un valor no booleanos en cualquier lugar distinto de la última entrada en una cadena condicional producirá un error.julia> 1 && true\nERROR: TypeError: non-boolean (Int64) used in boolean contextPor otra parte, cualquier tipo de expresión puede ser usada al final de una cadena condicional. Ella será evaluada y devuelta dependiendo de los condicionales precedentes:julia> true && (x = (1, 2, 3))\n(1, 2, 3)\n\njulia> false && (x = (1, 2, 3))\nfalse"
},

{
    "location": "manual/control-flow.html#man-loops-1",
    "page": "Control Flow",
    "title": "Evaluación Repetida: Bucles",
    "category": "section",
    "text": "Hay dos construcciones que realizan la evaluación repetida de expresiones: el bucle while y el bucle for. He aquí un ejemplo del bucle while:julia> i = 1;\n\njulia> while i <= 5\n           println(i)\n           i += 1\n       end\n1\n2\n3\n4\n5El bucle while evalúa la expresión condicional (en el ejemplo i<=5) y, mientras que esta se evalúe a true, sigue evaluando el cuerpo del bucle while. Si la expresión se evalúa a false la primera vez en que se alcanza el bucle, su cuerpo nunca será evaluado.El bucle for facilita la repetición. Dado que contar arriba y abajo (como en el ejemplo anterior del bucle while) es tan común, podemos expresar esto de una forma muy concisa con un bucle for:julia> for i = 1:5\n           println(i)\n       end\n1\n2\n3\n4\n5En el ejemplo anterior, 1:5 es un objeto Range que representa una secuencia de números. El bucle for itera sobre estos valores, asignando cada uno de ellos por turno a la variable i.  Una distinción importante ente esta construcción (for) y la construcción anterior (while) es el ámbito durante el cuál la variable es visible. Si la variable i no ha sido introducida en otro ámbito, el bucle for la verá sólo en su interior y no posteriormente. Para demostrar esto necesitaremos una nueva sesión interactiva o usar un nombre de variable distinto:julia> for j = 1:5\n           println(j)\n       end\n1\n2\n3\n4\n5\n\njulia> j\nERROR: UndefVarError: j not definedVer Ámbito de Variables para una explicación detallada de los ámbitos de las variables y cómo funcionan en Julia.En general, la construcción for puede iterar sobre cualquier contenedor. En estos casos, la palara clave alternativa (pero totalmente equivalente in o ∈ es usada en lugar de =, dado que hace que la lectura del código sea más clara.julia> for i in [1,4,0]\n           println(i)\n       end\n1\n4\n0\n\njulia> for s ∈ [\"foo\",\"bar\",\"baz\"]\n           println(s)\n       end\nfoo\nbar\nbazEn otras secciones del manual se introducirán y discutirán varios tipos de contenedores iterables (ver, por ejemplo, Arrays Multi-dimensionales).Algunas veces es conveniente terminar la repetición de un while antes de chequear la condición de test o partar de iterar en un bucle for antes de que se alcance el final del objeto iterable. Esto puede conseguirse usando la palabra clave break:julia> i = 1;\n\njulia> while true\n           println(i)\n           if i >= 5\n               break\n           end\n           i += 1\n       end\n1\n2\n3\n4\n5\n\njulia> for i = 1:1000\n           println(i)\n           if i >= 5\n               break\n           end\n       end\n1\n2\n3\n4\n5Si no existiera la palabra clave break, el bucle while anterior nunca finalizará por si mismo,  y el bucle for iteraría hasta 10000. Si hacemos uso de la instrucción break conseguiremos abandonar el bucle mucho antes.En otras circunstancias es útil ser capaz de detener una iteración y moverse a la siguiente de forma inmediata. Para ello, se utiliza la palabra clave continue:julia> for i = 1:10\n           if i % 3 != 0\n               continue\n           end\n           println(i)\n       end\n3\n6\n9Este es un ejemplo un tanto artificial, ya que podríamos obtener el mismo comportamiento de forma mucho más clara negando las condiciones y colocando la llamada a println dentro del bloque if. En usos más reales hay más código que evaluar después del continue, y con frecuencia hay muchos puntos desde los que uno puede llamar a esta instrucción.Podemos anidar múltiples bucles for en un solo bucle externo, formando el producto cartesiano de sus iterables:julia> for i = 1:2, j = 3:4\n           println((i, j))\n       end\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)Una instrucción break dentro de tal bucle sale del anidamiento de bucles completo, no sólo  del más interior."
},

{
    "location": "manual/control-flow.html#Manejo-de-Excepciones-1",
    "page": "Control Flow",
    "title": "Manejo de Excepciones",
    "category": "section",
    "text": "Cuando tiene lugar una condición inesperada, una funció puede ser incapaz de devolver un valor razonable al código que la invoca. En tales casos, puede ser mejor para la condición excepcional terminar el programa, imprimiendo un mensaje de error diagnóstico, o si el programador ha proporcionado código para manejar tales circunstancias excepcionales, permitiendo que el código tome la acción apropiada."
},

{
    "location": "manual/control-flow.html#Excepciones-predefinidas-1",
    "page": "Control Flow",
    "title": "Excepciones predefinidas",
    "category": "section",
    "text": "Las excepciones se lanzan cuando ocurre una condición inesperada. En la siguiente tabla se muestran todas la excepciones predefinidas, que interrumplen todas el flujo de control normal.Exception\nArgumentError\nBoundsError\nCompositeException\nDivideError\nDomainError\nEOFError\nErrorException\nInexactError\nInitError\nInterruptException\nInvalidStateException\nKeyError\nLoadError\nOutOfMemoryError\nReadOnlyMemoryError\nRemoteException\nMethodError\nOverflowError\nParseError\nSystemError\nTypeError\nUndefRefError\nUndefVarError\nUnicodeErrorPor ejemplo, la función sqrt() lanza un DomainError si se aplica sobre un valor real negativo:julia> sqrt(-1)\nERROR: DomainError:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).\nStacktrace:\n [1] sqrt(::Int64) at ./math.jl:434Uno puede definir sus propias excepciones de la siguiente manera:julia> struct MyCustomException <: Exception end"
},

{
    "location": "manual/control-flow.html#La-función-[throw()](@ref)-1",
    "page": "Control Flow",
    "title": "La función throw()",
    "category": "section",
    "text": "Las excepciones pueden crearse explícitamente con  throw(). Por ejemplo, una función definida sólo para número no negativos podría escribirse para que lanzara un DomainError si el argumento es negativo:julia> f(x) = x>=0 ? exp(-x) : throw(DomainError())\nf (generic function with 1 method)\n\njulia> f(1)\n0.36787944117144233\n\njulia> f(-1)\nERROR: DomainError:\nStacktrace:\n [1] f(::Int64) at ./none:1Notese que DomainError sin paréntesis no es una excepción, sino un tipo de excepción. Ella necesita ser invocada para obtener un objeto Exception:julia> typeof(DomainError()) <: Exception\ntrue\n\njulia> typeof(DomainError) <: Exception\nfalseAdicionalmente, algunos tipos de excepción toman uno o más argumentos que se utilizan para reportar errores.julia> throw(UndefVarError(:x))\nERROR: UndefVarError: x not definedEste mecanismo puede ser fácilmente implementado mediante los tipos de excepción personalizados que sigan la forma en que se escribe UndefVarError:julia> struct MyUndefVarError <: Exception\n           var::Symbol\n       end\n\njulia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, \" not defined\")note: Note\nCuando se escribe un mensaje de error, es preferible que la primera palabra sea minúscula. Por ejemplo,    size(A) == size(B) || throw(DimensionMismatch(\"size of A not equal to size of B\"))es preferible a`size(A) == size(B) || throw(DimensionMismatch(\"Size of A not equal to size of B\"))`.Sin embargo, algunas veces tiene sentido mantener la primera letra en mayúscula, por     ejemplo, si un argumento a función es una letra mayúscula: `size(A,1) == size(B,2) || throw(DimensionMismatch(\"A has first dimension...\"))`."
},

{
    "location": "manual/control-flow.html#Errores-1",
    "page": "Control Flow",
    "title": "Errores",
    "category": "section",
    "text": "La función error() se usa para producir una ErrorException que interrumpe el flujo de control normal.Supóngase que deseamos detener la ejecución inmediatamente si se toma la raíz cuadrad de un número negativo. Para hacer ésto, podemos definir una versión \"quisquillosa\" de la función  sqrt() que lanza un error si recibe un número negativo:julia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error(\"negative x not allowed\")\nfussy_sqrt (generic function with 1 method)\n\njulia> fussy_sqrt(2)\n1.4142135623730951\n\njulia> fussy_sqrt(-1)\nERROR: negative x not allowed\nStacktrace:\n [1] fussy_sqrt(::Int64) at ./none:1Si fussy_sqrt() es invocada con un valor negativo desde otra función, en lugar de intentar continuar la ejecución de la función que la invocó, retorna inmediatamente, mostrando el mensaje de error en la sesión interactiva:julia> function verbose_fussy_sqrt(x)\n           println(\"before fussy_sqrt\")\n           r = fussy_sqrt(x)\n           println(\"after fussy_sqrt\")\n           return r\n       end\nverbose_fussy_sqrt (generic function with 1 method)\n\njulia> verbose_fussy_sqrt(2)\nbefore fussy_sqrt\nafter fussy_sqrt\n1.4142135623730951\n\njulia> verbose_fussy_sqrt(-1)\nbefore fussy_sqrt\nERROR: negative x not allowed\nStacktrace:\n [1] fussy_sqrt at ./none:1 [inlined]\n [2] verbose_fussy_sqrt(::Int64) at ./none:3"
},

{
    "location": "manual/control-flow.html#Mensajes-de-aviso-y-de-información-1",
    "page": "Control Flow",
    "title": "Mensajes de aviso y de información",
    "category": "section",
    "text": "Julia también proporciona otras funciones que escriben mensajes a la salida de error estándar, pero no lanzan ninguna Exception y, por tanto, no interrumpen la ejecución:julia> info(\"Hi\"); 1+1\nINFO: Hi\n2\n\njulia> warn(\"Hi\"); 1+1\nWARNING: Hi\n2\n\njulia> error(\"Hi\"); 1+1\nERROR: Hi\nStacktrace:\n [1] error(::String) at ./error.jl:21"
},

{
    "location": "manual/control-flow.html#La-instrucción-try/catch-1",
    "page": "Control Flow",
    "title": "La instrucción try/catch",
    "category": "section",
    "text": "La intrucción try/ catch permite comprobar a aparición de excepciones. Por ejemplo, puede escribirse una función personalizada para calcular la raíz cuadrada que invoque automáticamente al método de cálculo de la raíz de valores reales y/o complejos en función de la excepción:julia> f(x) = try\n           sqrt(x)\n       catch\n           sqrt(complex(x, 0))\n       end\nf (generic function with 1 method)\n\njulia> f(1)\n1.0\n\njulia> f(-1)\n0.0 + 1.0imEs importante notar que en el código real que computa esta función, uno podría comparar x con vero en lugar de atrapar la excepción. De hcho, la opción de la excepción ees mucho más lenta de comparar y ramificar.Las instrucciones try / catch también permiten salvar la excepción en una variable. En este ejemplo artificial, se calcula la raíz cuadrada del segundo elemento de x.  Si x es indexable, en caso contrario asume que x es un número real y devuelve su raíz cuadrada:julia> sqrt_second(x) = try\n           sqrt(x[2])\n       catch y\n           if isa(y, DomainError)\n               sqrt(complex(x[2], 0))\n           elseif isa(y, BoundsError)\n               sqrt(x)\n           end\n       end\nsqrt_second (generic function with 1 method)\n\njulia> sqrt_second([1 4])\n2.0\n\njulia> sqrt_second([1 -4])\n0.0 + 2.0im\n\njulia> sqrt_second(9)\n3.0\n\njulia> sqrt_second(-9)\nERROR: DomainError:\nStacktrace:\n [1] sqrt_second(::Int64) at ./none:7Note que el símbolo que sigue al catch siempre será interpretado como el nombre para la excepción, por lo que hay que tener cuidado cuando se escriben expresiones try / catch en una sola línea. El siguiente código no funcionará para devolver el valor de x en caso de error:try bad() catch x endEn su lugar, es mejor usar un punto u coma o insertar un salto de línea después del catch:try bad() catch; x end\n\ntry bad()\ncatch\n    x\nendLa cláusula catch no es estrictamente necesaria; cuando se omite el valor de retorno por defecto es nothingjulia> try error() end # Returns nothingLa potencia de la construcción try / catch estriba  en la capacidad de desplegar inmediatamente un  cálculo profundamente anidado de hasta un nivel mucho más elevado en la pila de llamadas a función. Hay situacionces donde no ha ocurrido error, pero la capacidad de desplegar la pila y pasar un valor a un nivel superior es deseable. Julia proporciona las funciones   rethrow(), backtrace() and catch_backtrace() para un manejo de errores más avanzado."
},

{
    "location": "manual/control-flow.html#Cláusulas-finally-1",
    "page": "Control Flow",
    "title": "Cláusulas finally",
    "category": "section",
    "text": "En código que realiza cambios de estado o usa recursos como ficheros, hay típicamente un trabajo de limpieza (tal como cerrar ficheros) que necesita ser realizado cuando el código finaliza. Las excepciones complican potencialmente esta tarea, ya que pueden causar que un bloque de código salga antes de alcanzar su final normal. La palabra clave finally proporciona una forma de ejecutar código cuando existe un blqoue de código dado, sin preocuparse de cómo salga.Por ejemplo, aquí podemos garantizar que un fichero abierto se cierra:f = open(\"file\")\ntry\n    # operate on file f\nfinally\n    close(f)\nendCuando el contro deja el bloque try (por ejemplo, debido a un return, o finalizando normalmente) se ejecutará close().  Si el bloque try saliera debido a una excepción, la excepción continuará propagándose. Un bloque catch puede ser combinada con try y finally también. En este caso el bloque finally ejecutará después de que catch haya manejado el error."
},

{
    "location": "manual/control-flow.html#man-tasks-1",
    "page": "Control Flow",
    "title": "Tareas (aka Corutinas)",
    "category": "section",
    "text": "Las tareas son una característica de control de flujo que permite que los cálculos sean suspendidos y continuados de una forma flexible. Esta característica es llamada algunas veces con otros nombres, tales como corrutinas simétricas, hilos de peso ligero, multitarea cooperativa o continuaciones de un disparo.Cuando una pieza de trabajo de cómputo (en la práctica, ejecutar una función particular) es designada como tarea (Task), se hace posible interrumplirla intercambiándola por otra tarea. La tarea original puede ser continuada después, en el punto en que se encontraba justo cuando fue detenida. A primera vista, esto puede parecer similar a una llamada a función. Sin embargo, hay dos diferencias clave. Primero, conmutar tareas no usa ningún espacio, por lo que puede tener lugar cualquier número de intercambios de tarea sin que se consuma la pila de llamadas. Segundo, conmutar entre tareas puede ocurrir en cualquier orden, a diferencia de lo que pasa en las llamadas a función, donde la función invocada debe terminar la ejecución antes de que el control retorne a la función que la llamó.Esta clase de flujo de control puede hacer mucho más fácil resolver ciertos problemas. En algunos problemas, las distintas piezas de trabajo requerido no están relacionadas naturalmente mediante llamadas a función: no hay un obvio llamador o llamado entre los trabajos que necesitan ser realizados. Un ejemplo es el problema del productor-consumidor, donde un procedimiento complejo está generando valores u otro procedimiento complejo los está consumiendo. El consumidor no puede simplemente llamar a la función productora para obtener un valor, debido a que el productor puede tener más valores que generar y, por tanto, podría no estar listo todavía para retornar. Con las tareas, el productor y el consumidor pueden ambos ejecutarse mientas que lo necesiten, pasando valores adelante y detrás cuando sea necesario.Julia proporciona un mecanismo denominado \"canal\" (Channel para resolver este problema. Un canal es una cola FIFO (primero en entrar, primero en salir) que puede tener múltiples tareas leyendo de y escribiendo en ella. Definamos una tarea productor, que produce valores a través de una llamada put!. Para consumir valores, necesitamos planificar un productor que ejecute una nueva tarea. Para ejecutar una tarea asociada a un canal utilizaremos un constructor especial Channel que recibe como argumento una función de un argumento. Podemos entonce tomar valores repetidamente  del objeto canar mediante llamadas a take!():julia> function producer(c::Channel)\n           put!(c, \"start\")\n           for n=1:4\n               put!(c, 2n)\n           end\n           put!(c, \"stop\")\n       end;\n\njulia> chnl = Channel(producer);\n\njulia> take!(chnl)\n\"start\"\n\njulia> take!(chnl)\n2\n\njulia> take!(chnl)\n4\n\njulia> take!(chnl)\n6\n\njulia> take!(chnl)\n8\n\njulia> take!(chnl)\n\"stop\"Una forma de pensar en este comportamiento es que el producer era capaz de retornar múltiples veces. Entre las llamadas a put!(), la ejecución del productor se ha suspendido y el consumidor tiene el control.El objeto Channel devuelto puede ser usado como un objeto iterable dentro de un bucle for loop,  en cuyo caso las variable del bucle tomará todos los objetos producidos. El bucle será terminado cuando el canal se haya cerrado.julia> for x in Channel(producer)\n           println(x)\n       end\nstart\n2\n4\n6\n8\nstopNote que nosotros no tuvimos que cerrar explícitamente el canal en el productor. Esto es debido a que el acto de enlazar un canal (Channel) a una tarea (Task()) asocia el tiempo de vida abierto de un canal con el de la tarea asociada. El objeto canal se cierra automáticamente cuando la tarea termina. Podemos enlazar múltiplos canales a una tarea, y viceversa.Aunque el constructor de Task() espere una función sin argumentos, el método Channel() que crea un enlace entre un canal y una tarea espera una función que acepta un solo argumento de tipo Channel. Un patrón común es que el productor esté parametrizado, en cuyo caso se neceesita una aplicación de función parcial para crear una función anónima con 1 ó 0 argumentos..Para objetos Task() esto puede hacerse bien directamente o mediante el uso de una macro conveniente:function mytask(myarg)\n    ...\nend\n\ntaskHdl = Task(() -> mytask(7))\n# or, equivalently\ntaskHdl = @task mytask(7)Para orquestar patrones de distribucióin más avanzados, pueden usarse bind() y schedule() en conjunción con los constructores de Task() y Channel() para enlazar explícitamente un conjunto de canales con un conjunto de tareas productor/consumidor.Note que en la actualidad las tareas Julia no son planificadas para que ejecuten sobre núcleos de CPU separados. Los verdaderos hilos del núcleo se discutirán en la sección Computación Paralela."
},

{
    "location": "manual/control-flow.html#Operaciones-Básicas-de-Tareas-1",
    "page": "Control Flow",
    "title": "Operaciones Básicas de Tareas",
    "category": "section",
    "text": "Exploremos la construcción de bajo nivel  yieldto() para comprender cómo funciona la conmutación de tareas. yieldto(task,value) suspende la tarea actual, conmuta a la tarea especificada, y causa que la última llamada a  yieldto() devuelva el valor especificado value. Nótese que yieldto() para usar control de flujo estilo tarea: en lugar de llamar y retornar nos limitamos a conmutar entre las distintas tareas. Esta es la razón por la que esta característica es también llamada \"corrutinas simétricas\". Cada tarea es conmutada usando el mismo mecanismo.yieldto() es potente, pero la mayoría de los usos de tareas no lo invocan directamente. Consideremos a qué se debe esto. Si tu conmutas desde la tarea actual, probablemente querrás volver a conmutar en otro puento, pero saber cuándo conmutar, y saber qué tarea tiene la responsabilidad de conmutar hacia atrás puede requerir una coordinación considerable. Por  ejemplo,  put!() y take!() son operaciones bloqueantes, las cuales, cuando se usan en el contexto de los canales mantienen un estado para recordar quiénes son los consumidores.  No necesitar mantener manualmente la traza de la tarea es lo que hace que put!() sea más sencilla de usar que la instrucción de bajo nivel yieldto().Ademas de yieldto(), se necesitan otras funciones básicas para usar las tareas de forma efectiva:current_task() devuelve una referencia a la tarea que se está ejecutando actualmente.\nistaskdone() consulta para saber si una tarea ha salido.\nistaskstarted() consulta para saber si una tarea se ha iniciado ya.\ntask_local_storage() manipula un almacenamiento clave-valor específico a la tarea actual."
},

{
    "location": "manual/control-flow.html#Tareas-y-Eventos-1",
    "page": "Control Flow",
    "title": "Tareas y Eventos",
    "category": "section",
    "text": "Muchos cambios de tarea ocurren como resultado de la espera de eventos tales como peticiones de E/S, y son realizados por un planificador incluido en la librería estándar. El planificador mantiene una cola de tareas ejecutables, y ejecuta un bucle de eventos que reinicia las tareas basándose en eventos externos tales como la llegada de un mensaje.La función básica para esperar un evento es wait(). Hay varios objetos que implementan wait(); por ejemplo, dado un objeto Process, wait()  esperará a que este salga. wait() suele ser implícito; por ejemplo, una llamada a wait() puede tener lugar dentro de una llamada a  read() para esperar a que haya datos disponibles.En todos estos casos,  wait() opera últimamente sobre un objeto  Condition que es responsable de encolar y reiniciar las tareas. Cuando una tarea llama a wait() sobre un objeto Condition,la tarea es marcada como no ejecutable, añadida a la cola de esta condición y el control pasa al planificador. El planificador se ocupa entonces de preparar otra tarea para ejecución o se queda bloqueado esperando eventos externos. Si todo va bien, eventualmente un manejador de eventos llamará a  notify() sobre la condición, lo que causa que las tareas que estaban esperando esa condición se vuelvan ejecutables de nuevo.Una tarea creada explícitamente llamado a  Task es inicialmente no conocida por el planificador. Esto nos permite gestionar las tareas manualmente usando  yieldto() si lo deseamos. Sin embargo, cuando tal tarea espera un evento, sigue siendo reiniciada cuando el evento tiene lugar, como podría esperarse. Es también posible hacer que el planificador ejecute una tarea siempre que pueda, sin esperar ningún evento necesariamente. Esto se hace llamando a schedule(), o usando las macros @schedule o @async macros (ver Parallel Computing para más detalles)."
},

{
    "location": "manual/control-flow.html#Estados-de-una-Tarea-1",
    "page": "Control Flow",
    "title": "Estados de una Tarea",
    "category": "section",
    "text": "La tareas tienen un campo state que describe su estado de ejecucoión. El estado de una tarea es  uno de los siguientes símbolos:Symbol Meaning\n:runnable Ejecutando actualmente, o disponible para ser intercambiado\n:waiting Bloqueado esperando un evento específico\n:queued En la cola de ejecución del planiticador a punto de ser reiniciado\n:done Finalizada su ejecucción con éxito\n:failed Finalizado con alguna excepción no atrapada"
},

{
    "location": "manual/variables-and-scoping.html#",
    "page": "Ámbito de las variables",
    "title": "Ámbito de las variables",
    "category": "page",
    "text": ""
},

{
    "location": "manual/variables-and-scoping.html#scope-of-variables-1",
    "page": "Ámbito de las variables",
    "title": "Ámbito de las variables",
    "category": "section",
    "text": "El ámbito de una variable es la región de código donde dicha variable es visible. El ámbito de las variables ayuda a evitar conflictos de nombrado de variables. El concepto es intuitivo: dos funciones pueden tener argumentos denominados x sin que las dos x se refieran a la misma cosa. De forma similar, hay muchos otros casos donde diferentes bloques de código pueden usar el mismo nombre sin referirse a la misma cosa. Las reglas para cuando el mismo nombre de variable se refiere o no a la  misma cosa se llaman reglas de ámbito. Em este tema se analizan en detalle. Ciertas construcciones en el lenguaje introducen bloques de ámbitos, que son regiones de código que son elegibles para estar en el ámbito de algún conjunto de variables. El ámbito de una variable no puede ser un conjunto arbitrario de líneas de código; en lugar de ello, siempre se alinea con uno de esos bloques. Hay dos tipos principales de ámbitos en Julia: globales y locales, pudiendo los últimos estar anidados. Las construcciones que introducen estos bloques de ámbito son:Nombre de ámbito Bloque/construcción que introduce este tipo de ámbito\nÁmbito Global module, baremodule y prompt interactivo (REPL)\nÁmbito Local   Ámbito local blando: for, while comprensiones, bloques try-catch-finally, let\nÁmbito Local   Ámbito local duro: funciones (cualquier sintaxis, anónima y bloques do), struct, macroDos notables ausencias en esta tabla son los bloques begin y los bloques if, que no introducen nuevos bloques de ámbito. Los tres tipos de bloques siguen reglas un poco diferentes que serán explicadas más adelante, así como algunas reglas extra para ciertos bloques.Julia usa un ámbito léxico, lo que significa que el ámbito de una función no hereda del ámbito que lo invocó, pero si del ámbito en que la función fue definida. Por ejemplo, en el siguiente código, x deontro de foo se refiere a la x que hay en el ámbito local de su módulo Bar:julia> module Bar\n           x = 1\n           foo() = x\n       end;y no a la x en el ámbito en que se ha usado foo:julia> import .Bar\n\njulia> x = -1;\n\njulia> Bar.foo()\n1Por tanto, ámbito léxico significa que el ámbito de las variables puede ser inferido del código fuente sin más. "
},

{
    "location": "manual/variables-and-scoping.html#Ámbito-Global-1",
    "page": "Ámbito de las variables",
    "title": "Ámbito Global",
    "category": "section",
    "text": "Cada módulo introduce un nuevo espacio global, separado del ámbito global de todos los otros módulos; no existen ámbitos globales compartidos por todos. Los módulos pueden introducir variables de otros módulos o en su ámbito a través del uso de las instrucciones using o import o a través de acceso cualificado usando la notación punto. En consecuencia, cada módulo es un espacio de nombres. Notese que los enlaces de nombres pueden sólo ser cambiados  dentro de su ámbito global y no desde un módulo exterior.julia> module A\n           a = 1 # a global in A's scope\n       end;\n\njulia> module B\n           module C\n               c = 2\n           end\n           b = C.c    # can access the namespace of a nested global scope\n                      # through a qualified access\n           import ..A # makes module A available\n           d = A.a\n       end;\n\njulia> module D\n           b = a # errors as D's global scope is separate from A's\n       end;\nERROR: UndefVarError: a not defined\n\njulia> module E\n           import ..A # make module A available\n           A.a = 2    # throws below error\n       end;\nERROR: cannot assign variables in other modulesNótese que el prompt interactivo (REPL) está en el ámbito global del módulo Main."
},

{
    "location": "manual/variables-and-scoping.html#Ámbito-Local-1",
    "page": "Ámbito de las variables",
    "title": "Ámbito Local",
    "category": "section",
    "text": "La mayoría de los bloques de código introducen un nuevo ámbito local. Los ámbitos locales suelen heredar todas las variables de su ámbito padre, tanto para lectura como para escritura. Hay dos subtipos de ámbitos locales, denominados duros y blandos, con reglas ligeramente distintas en relación a qué variables son heredadas. A diferencia de los ámbitos globales, los ámbitos locales no son espacios de nombres, por lo que las variables de un ámbito más interno no pueden ser recuperadas de uno más externo a través de alguna clase de acceso cualificado.Las siguientes reglas y ejemplos pertenecen tanto a los ámbitos locales como globales. Una variable introducida de nuevo en un ámbito local no se retroprogada a su ámbito padre. Por ejemplo, la z no se introduce en el ámbito de nivel superior:julia> for i = 1:10\n           z = i\n       end\n\njulia> z\nERROR: UndefVarError: z not defined(Nótese que En este ejemplo y los siguientes se supone que el ámbito de nivel superior es un ámbito global con un espacio de trabajo limpio, por ejemplo un REPL arrancado de nuevo.)Dentro de un ámbito local una variable puede ser forzada a ser una variables local usando la palabra clave local.julia> x = 0;\n\njulia> for i = 1:10\n           local x\n           x = i + 1\n       end\n\njulia> x\n0Dentro de un ámbito local puede definirse una nueva variable global usando la palabra clave global:julia> for i = 1:10\n           global z\n           z = i\n       end\n\njulia> z\n10La localización de las palabras clave local y  global dentro del bloque del ámbito es irrelevante. El siguiente código es totalmente equivalente al ejemplo anterior (aunque estilísticamente es peor): julia> for i = 1:10\n           z = i\n           global z\n       end\n\njulia> z\n10"
},

{
    "location": "manual/variables-and-scoping.html#Ámbito-local-blando-1",
    "page": "Ámbito de las variables",
    "title": "Ámbito local blando",
    "category": "section",
    "text": "En un ámbito local blando, todas las variables son heredadas de su ámbito padre a menos que una  variable haya sido marcada específicamente con la palabra local.Los ámbitos locales blandos se introducen en los bucles for, bucles while, comprensiones, bloques try-catch-finally y bloques let. Hay algunas reglas extra para los bloques let y para los bucles for y comprensiones.En el siguiente ejemplo, x e y se refieren siempre a la misma variable dado que el ámbito local blando heredan ambas variables de lectura y escritura:julia> x, y = 0, 1;\n\njulia> for i = 1:10\n           x = i + y + 1\n       end\n\njulia> x\n12Dentro de los ámbitos blandos, la palabra clave global no es nunca necesaria, aunque está permitida. El único caso donde podría cambiar la semántica es (actualmente) un error sintáctico:julia> let\n           local j = 2\n           let\n               global j = 3\n           end\n       end\nERROR: syntax: `global j`: j is local variable in the enclosing scope"
},

{
    "location": "manual/variables-and-scoping.html#Ámbito-local-duro-1",
    "page": "Ámbito de las variables",
    "title": "Ámbito local duro",
    "category": "section",
    "text": "Los ámbitos locales duros se introducen mediante las definiciones de función (en todas sus formas) bloques de tipos e inmutables y definiciones de macros.En el ámbito local duro, todas las variables son heredades de su ámbito padre a menos que:Una asignación daría como resultado una variable global\nUna variable sea marcada específicamente con la palabra clave local.Por tanto, las variables globales son sólo heredadas para lectura pero no para escritura:julia> x, y = 1, 2;\n\njulia> function foo()\n           x = 2        # assignment introduces a new local\n           return x + y # y refers to the global\n       end;\n\njulia> foo()\n4\n\njulia> x\n1Se necesita un global explícito para asignar a una variable global:julia> x = 1;\n\njulia> function foobar()\n           global x = 2\n       end;\n\njulia> foobar();\n\njulia> x\n2Note que las funciones anidadas pueden comportarse diferentemente de las funciones definidas en el ámbito global como si ellas pudieran variar las variables locales del ámbito padre.julia> x, y = 1, 2;\n\njulia> function baz()\n           x = 2 # introduces a new local\n           function bar()\n               x = 10       # modifies the parent's x\n               return x + y # y is global\n           end\n           return bar() + x # 12 + 10 (x is modified in call of bar())\n       end;\n\njulia> baz()\n22\n\njulia> x, y\n(1, 2)La distinción entre heredar variables locales y globales para asignación puede llevar a ligeras diferencias entre funciones definidas en ámbitos locales y/o globales. Considere la modificación del último ejemplo moviendo bar al ámbito global:julia> x, y = 1, 2;\n\njulia> function bar()\n           x = 10 # local\n           return x + y\n       end;\n\njulia> function quz()\n           x = 2 # local\n           return bar() + x # 12 + 2 (x is not modified)\n       end;\n\njulia> quz()\n14\n\njulia> x, y\n(1, 2)Notemos que lo anterior sutilmente no pertenece a las definiciones de tipo y de macro, por lo que ellas sólo pueden aparecer en el ámbito global. Hay reglas de ámbito especiales relacionadas con la evaluación de argumentos de función por defecto y palabra clave que se describen en la sección de Funciones.Una asignación que introduce una variable usada dentro de una definicíon de función, tipo o macro no necesita ir antes de su uso interno: julia> f = y -> y + a\n(::#1) (generic function with 1 method)\n\njulia> f(3)\nERROR: UndefVarError: a not defined\nStacktrace:\n [1] (::##1#2)(::Int64) at ./none:1\n\njulia> a = 1\n1\n\njulia> f(3)\n4Este comportamiento puede parecer un poco raro para una variable normal, pero está permitido para que las funciones nombradas sean usadas antes de ser definidas (las funciones nombradas son exactamente variables normales que almacenan objetos función). Esto permite a las funciones ser definidas en cualquier orden que sea intuitivo y conveniente en lugar de forzar un  ordenamiento de abajo a arriba o requerir declaraciones hacia delante, mientras que ellas sean definidas en el momento que sean usadas. Por ejemplo, he aquí una forma ineficiente, mutuamente recursiva de comprobar si un entero positivo es par o impar:julia> even(n) = n == 0 ? true : odd(n-1);\n\njulia> odd(n) = n == 0 ? false : even(n-1);\n\njulia> even(3)\nfalse\n\njulia> odd(3)\ntrueJulia proporciona funciones eficientes y predefinidas para comprobar la paridad o imparidad, llamadas iseven() e isodd(). Por tanto, las definiciones anteriores deberían ser sólo tomadas como ejemplos."
},

{
    "location": "manual/variables-and-scoping.html#Ámbitos-locales-duro-vs.-blando-1",
    "page": "Ámbito de las variables",
    "title": "Ámbitos locales duro vs. blando",
    "category": "section",
    "text": "Los bloques que introducen un ámbito local blando, como los bucles, se suelen usar para manipular las variables en su ámbito padre. Por tanto, su defecto es acceder completamente a todas las variables de su ámbito padre.A la inversa, el código dentro de los bloques que introduce un ámbito local duro (definiciones de función, tipo o macro) pueden ser ejecutados en cualquier parte del programa. Cambiar remotamente el estado de variables locales en otros módulos debería ser realizado con cuidado y por tanto esta es una característica de optimización que requiere la palabra clave global.La razón para permitir modificar local variables de ámbitos padres en funciones anidadas es permitir la construcción de cierres que tienen un estado privado, por ejemplo la variable state del siguiente ejemplo:julia> let\n           state = 0\n           global counter\n           counter() = state += 1\n       end;\n\njulia> counter()\n1\n\njulia> counter()\n2Ver también los cierres en los ejemplos de las dos siguientes secciones."
},

{
    "location": "manual/variables-and-scoping.html#let-blocks-1",
    "page": "Ámbito de las variables",
    "title": "Bloques Let",
    "category": "section",
    "text": "A diferencia de las asignaciones a variables locales, las instrucciones let asignan nuevas asociaciones de variables cada vez que se ejecutan. Una asignación modifica el valor de una localización existente, y let crea nuevas localizaciones. Esta diferencia no suele ser importante, y es sólo detectable en el caso de variables que sobreviven a sus ámbitos vía cierres. La sintaxis de let acepta una serie de asignaciones y nombres de variables separados por comas:julia> x, y, z = -1, -1, -1;\n\njulia> let x = 1, z\n           println(\"x: $x, y: $y\") # x is local variable, y the global\n           println(\"z: $z\") # errors as z has not been assigned yet but is local\n       end\nx: 1, y: -1\nERROR: UndefVarError: z not definedLas asignaciones se evalúan en orden, con cada término derecho evaluado en el ámbito antes de que se introduzca la nueva variable a través del término izquierdo. Por tanto, tiene sentido escribir algo como let x = x ya que las dos variables son distintas y tienen almacenamiento separado. Este es un ejemplo de dónde se necesita el comportamiento de let: julia> Fs = Array{Any}(2); i = 1;\n\njulia> while i <= 2\n           Fs[i] = ()->i\n           i += 1\n       end\n\njulia> Fs[1]()\n3\n\njulia> Fs[2]()\n3Aquí creamos y almacenamos dos cierres que devuelven la variable i. Sin embargo, es siempre la misma variable i, por lo que los dos cierres se comportan de forma idéntica. Podemos usar let para crear una nueva correspondencia para i:julia> Fs = Array{Any}(2); i = 1;\n\njulia> while i <= 2\n           let i = i\n               Fs[i] = ()->i\n           end\n           i += 1\n       end\n\njulia> Fs[1]()\n1\n\njulia> Fs[2]()\n2Como la construcción begin no construye un nuevo ámbito, puede ser útil usar un let con cero argumentos para introducir un nuevo bloque de ámbito sin crear ninguna nueva correspondencia:julia> let\n           local x = 1\n           let\n               local x = 2\n           end\n           x\n       end\n1Como let introduce un nuevo bloque de ámbito, la variable local interna x es diferente de la externa local x."
},

{
    "location": "manual/variables-and-scoping.html#for-loops-and-comprehensions-1",
    "page": "Ámbito de las variables",
    "title": "Bucles for y comprensiones",
    "category": "section",
    "text": "Los bucles for y las comprensiones tiene el siguiente comportamiento: cualquier nueva variable introducida en sus ámbitos se reservan de nuevo para cada nueva iteración del bucle. Esto contrasta con los bucles while que reservan las variables para todas las iteraciones. Por tanto, estas construcciones son similares a bucles while con bloques let dentro de ellos:julia> Fs = Array{Any}(2);\n\njulia> for j = 1:2\n           Fs[j] = ()->j\n       end\n\njulia> Fs[1]()\n1\n\njulia> Fs[2]()\n2Los bucles for reusarán las variables existentes para su variable iteración:julia> i = 0;\n\njulia> for i = 1:3\n       end\n\njulia> i\n3Sin embargo, las comprensiones no hacen esto, y siempre asignan de nuevo sus variables de iteración:julia> x = 0;\n\njulia> [ x for x = 1:3 ];\n\njulia> x\n0"
},

{
    "location": "manual/variables-and-scoping.html#Constantes-1",
    "page": "Ámbito de las variables",
    "title": "Constantes",
    "category": "section",
    "text": "Un uso común de las variables es darle nombres de valores específicos, no cambiantes. Tales variables sólo se asignan una vez. Esta intención puede ser transportada al compilador usando la palabra clave const:julia> const e  = 2.71828182845904523536;\n\njulia> const pi = 3.14159265358979323846;La declaración const es permitida sobre variables globales y locales, pero es especialmente útil para las globales. Es difícil para el compilador optimizar´código en el que están implicadas las variables globales, ya que sus valores (o incluso sus tipos) podrían cambiar en cualquier momento. Si una variable global no va a cambiar, añadir una declaración const  resolverá este problema de rendimiento.Las constantes locales son bastante diferentes. El compilador es capaz de determinar cuando una variable local es constante, por lo que las declaraciones de constante local no son necesarias para mejorar el rendimiento.Las asignaciones especiales de nivel superior, tales como las realizadas por las palabras clave function y type son constantes por defecto. Nótese que const sólo afecta a la asociación de variables:  la variable puede ser asociada a un objeto mutable (tal com un array) y el objeto puede aún ser modificado."
},

{
    "location": "manual/types.html#",
    "page": "Tipos",
    "title": "Tipos",
    "category": "page",
    "text": ""
},

{
    "location": "manual/types.html#man-types-1",
    "page": "Tipos",
    "title": "Tipos",
    "category": "section",
    "text": "Los sistemas de tipos han caído tradicionalmente en dos categorías muy diferentes: los sistemas de tipos estáticos, donde cada expresión del programa debe tener un tipo computable antes de la ejecución del programa, y los sistemas de tipos dinámicos, donde nada es sabido sobre los tipos hasta el momento de la ejecución, cuando los valores actuales manipulados por el programa están disponibles. La orientación a objetos permite una flexibilidad en los lenguajes tipados estáticamente dejando que el código sea escrito sin que se conozcan los tipos precisos de los valores en tiempo de compilación. La capacidad de escribir código que pueda operar sobre diferentes tipos se denomina polimorfismo. Todo el código en los lenguajes clásicos tipados dinámicamente es polimórfico: sólo mediante comprobación de equipos explícita o cuando los objetos fallan para soportar las operaciones en tiempo de ejecución, están los tipos de cualquier valor siempre restringidos.El sistema de tipos de Julia es dinámico, pero tiene algunas de las ventajas de los sistemas de tipos estáticos haciendo posible indicar que ciertos valores son de tipos específicos. Esto puede ser de gran ayuda en la generación de código eficiente, pero incluso más significativamente, permite que el despacho de métodos sobre los tipos de los argumentos a función este profundamente integrado con el lenguaje. El despacho de métodos se explorará en detalle en la sección Methods, pero está enraizado en el sistema de equipos presentado en este capítulo..El comportamiento por defecto en Julia cuando se omiten los tipos es permitir que los valores sean de cualquier tipo. Por tanto, uno puede escribir muchos programa Julia útiles sin siquiera usar explícitamente los tipos. Cuando se necesita una expresividad adicional, sin embargo, es fácil introducir gradualmente anotaciones de tipo explícitas en código previamente no tipado. Hacer eso suele incrementar el rendimiento y la robustez de estos sistemas, y quizás algo contra intuitivo: simplificarlos frecuentemente.Describir Julia en el lingo de los sistemas de tipos, es decir que es: dinámico, nominativo y paramétrico. Los tipos genéricos pueden ser parametrizados, y las relaciones jerárquicas entre tipos son declaradas explítamente, en lugar de ser implicadas mediante una estructura compatible. Una característica particularmente distintiva del sistema de tipos de Julia es que los tipos concretos no pueden tener subtipos. Todos los tiempos completos son finales y sólo pueden tener tipos abstractos como supertipos. Aunque esto puede parecer excesivamente restrictivo al principio, tiene muchas consecuencias beneficiosas con sorprendentemente pocos inconveniente. Resulta que ser capaz de heredar comportamientos es mucho más importante que seas capaz de heredar estructura, y heredar ambas cosas causa dificultades significativas en los lenguajes orientados a objetos tradicionales. Otros aspectos de alto nivel del sistema del tipo de Julia que Debería ser mencionados son:No hay división entre los valores objetos y no objetos. Todos los valores en Julia son verdaderos objetos que tienen un tipo que pertenece a un solo grafo de tipos totalmente conectado, todos los nodos del cual son de primera clase como tipos.\nNo hay un concepto significativo de tiempo en tiempo de compilación. El único tipo que tiene un valor es su tipo actual cuando el programa está corriendo. Esto se denomina tipo en tiempo de ejecución en los lenguajes orientados a objetos, donde la combinación de complicación estática con polimorfismo hace esta distinción significativa.\nSólo los valores, no las variables, tienen tipos. Las variables son siempre nombres enlazados a valores.\nTanto los tipos abstractos como concretos pueden ser paralizados por otros tipos. Ellos pueden ser parametrizados mediante símbolos, mediante valores de cualquier tipo para los cuáles isbits() devuelve true (esencialmente, cosas como números y booleanos que son almacenados como tipos C o estructuras sin punteros a otros objetos), y también mediante tuplas. Los parámetros de tipo pueden ser omitidos cuando no necesitan ser referenciados o restringidos.El sistema de tipos de Julia está diseñado para ser potente y expresivo, además de claro, intuitivo y no obstructivo. Muchos programadores Julia nunca sentirán la necesidad de escribir código que use los tipos explícitamente. Algunas clases de programación, sin embargo, se vuelven más claras, rápidas y robustas usando tipos declarados."
},

{
    "location": "manual/types.html#Declaraciones-de-tipo-1",
    "page": "Tipos",
    "title": "Declaraciones de tipo",
    "category": "section",
    "text": "El operador :: puede usarse para adjuntar declaraciones de tipo a expresiones y variables en los programas. Hay dos razones principales para esto:Como una aserción para ayudar a confirmar que nuestro programa funciona como se esperaba.\nPara proporcionar al compilador información extra sobre tipos, que puede mejorar el rendimiento en algunos casos.Cuando se añade a una expresión que calcula un valor, el operador ::se lee como \"es una instancia de\". Puede ser utilizado en cualquier parte para asertar que el valor de la expresión de la izquierda es una instancia del tipo de la derecha. Cuando el tipo de la derecha es concreto, el valor  sobre la izquierda debe tener ese tipo como su implementación (recuerde que todos los tipos concretos son finales, por lo que no hay implementaciones que sean subtipos de otros). Cuando el tipo es abstracto, basta que el valor sea implementado por un tipo concreto que sea un subtipo del tipo abstracto. Si la aserción de tipo no es true se lanza una excepción. En caso contrario, se devuelve el valor del lado izquierdo.julia> (1+2)::AbstractFloat\nERROR: TypeError: typeassert: expected AbstractFloat, got Int64\n\njulia> (1+2)::Int\n3Esto permite que la aserción de tipo sea adjuntada a cualquier expresión in situ.Cuando se añade a una variable sobre el lado izquierdo de una asignación, o como parte de una declaración local, el operador :: significa algo un poco diferente: declara que la variable siempre tendrá el tipo especificado, como una declaración de tipo de los lenguajes tipados estáticamente como C. Cada valor asignado a la variable será convertido al tipo declarado usando convert():julia> function foo()\n           x::Int8 = 100\n           x\n       end\nfoo (generic function with 1 method)\n\njulia> foo()\n100\n\njulia> typeof(ans)\nInt8Esta característica es útil para evitar las \"trampas\" de rendimiento que podrían tener lugar si una de las asignaciones a varible cambia su tipo inesperadamente. Este comportamiento \"declaración\" sólo ocurre en contextos específicos:local x::Int8  # in a local declaration\nx::Int8 = 10   # as the left-hand side of an assignmenty se aplica al ámbito actual completo, incluso antes de la declaración. Actualmente, las declaraciones de tipo no pueden ser usadas en un espacio global, como en el REPL, ya que Julia no tiene aún globales de tipo constante.Las declaraciones pueden también ser enlazadas a las definiciones de función:function sinc(x)::Float64\n    if x == 0\n        return 1\n    end\n    return sin(pi*x)/(pi*x)\nendRetornar de esta función se comporta justo como una asignación a una variable con un tipo declarado: el tipo será siempre convertido a Float64."
},

{
    "location": "manual/types.html#Tipos-Abstractos-1",
    "page": "Tipos",
    "title": "Tipos Abstractos",
    "category": "section",
    "text": "Los tipos abstractos no puede ser instanciados, y sólo sirven como nodos en el grafo de tipos, describiendo de este mundo conjuntos de tipos concretos relacionados: aquellos tipos concretos que son sus descendientes. Comenzamos con tipos abstractos incluso aunque no tienen instanciación debido a que ellos son la espina dorsal del sistema de tipos: ellos forman la jerarquí conceptual qu hace al sistema de tipos de Julia más que una colección de implementaciones de objetos. Recuerde que en Números Enteros y en Punto Flotante, introdujimos una variedad de tipos de valores numéricos concretos: Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Int128, UInt128, Float16, Float32, and Float64. Aunque todos ellos tienen diferentes tamaños en representación,  Int8, Int16, Int32, Int64 and Int128 tienen en común que son tipos enteros con signo. Del mismo modo, UInt8, UInt16, UInt32, UInt64 and UInt128 son enteros sin signo, mientras que Float16, Float32 and Float64 son tipos en punto flotante. Es común para una pieza de código que ésta tenga sentido, por ejemplo, sólo si sus argumentos son algún tipo de entero, pero no que dependa de un tipo de entero particular. Por ejemplo, el algoritmo del máximo común denominador funciona para todas las clases de enteros, pero no funcionará para los números en punto flotante. Los tipos abstractos permiten la construcción de una jerarquía de tipos, proporcionando un contexto en el cuál los tipos concretos pueden ajustarse. Esto te permite, por ejemplo, programar fácilmente a cualquier tipo que sea un entero, sin restringir el algoritmo a un tipo de entero específico.Los tipos abstractos se declaran usando la palabra clave abstract. Las sintaxis generales para declarar un tipo abstracto son:abstract type «name» end\nabstract type «name» <: «supertype» endLa palabra clave abstract type introduce un nuevo tipo abstracto, cuyo nombre viene dado por «name». Este nombre puede ir seguido opcionalmente de <: y un nombre de tipo ya existente, lo cuál indica que este tipo abstracto es un subtipo del ya existente..Cuando no se proporciona supertipo, el supertipo por defecto es Any (un tipo abstract predefinido del que todos los objetos son instancias y todos los tipos son subtipos). En teoría de tipos, Any suele ser denominado top porque es la cúspide del grafo de los tipos. Julia tiene también un tipo abstracto bottom, en el punto más bajo del grafo de tipos, que se escribe como Union{}. Es el opuesto exacto de Any: ningún objeto es instancia de Union{} y todos los tipos son sus supertipos.Consideremos algunos de los tipos abstractos que forman parte de la jerarquía numérica de Julia:abstract type Number end\nabstract type Real     <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer  <: Real end\nabstract type Signed   <: Integer end\nabstract type Unsigned <: Integer endEl tipo Number es un hijo directo de Any, y Real es su hijo. Real tiene dos hijos (tiene más, pero sólo mostraremos dos aquí): Integer y AbstractFloat, que dividen el mundo entre representaciones de números enteros y reales. Las representaciones de números reales incluyen, por supuesto, los tipos en punto flotante, pero también incluyen otros tipos como los racionales. Por tanto,  AbstractFloat es un subtipo apropiado de Real que incluye sólo representaciones en punto flotante de los números reales. Los enteros están también divididos en las variedades Signed y Unsigned.El operador <: significa, en general, \"es un subtipo de\" y, usado en declaraciones como esta, declara que el tipo de la parte derecha es un supertipo inmediato de tipo que acaba de crearse. También puede usarse en expresiones como un obperador de subtipo que devuelve true cuando el operando de su izquierda es un subtipo del operando de su derecha:julia> Integer <: Number\ntrue\n\njulia> Integer <: AbstractFloat\nfalseUn uso importante de los tipos abstractos es proporcionar una implementación por defecto para los tipos concretos. Para dar un ejemplo simple, considere:function myplus(x,y)\n    x+y\nendLa primera cosa que hay que notar es que las declaraciones de argumento anteriores son equivalentes a x::Any e y::Any.  Cuando se invoca a estas funciones, digamos con myplus(2,5), el despachador elige el método más específico cuyo nombres sea myplus y que se corresponda con los argumentos dados (ver Métodos para más informacíon sobre despacho múltiple).Asumiendo que no se encuentra método más específico que el anterior, a continuación Julia define y compila un método llamado myplus específicamente para dos argumentos Int basado en la función genérica dada anteriormente, es decir, implícitamente define y compila:function myplus(x::Int,y::Int)\n    x+y\nendy, finalmente invoca a este método específico.Por tanto, los tipos abstractos permiten a los programadores escribir funciones genéricas que puedan ser usadas después como el método por defecto mediante muchas combinaciones de tipos concretos. Gracias al despacho múltipel, el programador tiene control total sobre si se usa el método por defecto o uno más específico.Un punto importante que notar es que no hay pérdida en el rendimiento si el programador se basa en una función cuyos argumentos sean tipos abstractos, dado que ella es recompilada para cada tupla de argumentos de tipos concretos con la cuál sea invocada (sin embargo, puede haber un problema de rendimiento en el caso de argumentos función que sean contenedores de tipos abstractos; ver Consejos de Rendimiento.)"
},

{
    "location": "manual/types.html#Tipos-Primitivos-1",
    "page": "Tipos",
    "title": "Tipos Primitivos",
    "category": "section",
    "text": "Un tipo primitivo es aquél un tipo concreto cuyos datos consisten en bits normales y corrientes. Ejemplos clásicos de tipos bits son los valores enteros y punto flotante. A diferencia de muchos lenguajes, Julia nos permite declarar nuestros propios tipos bits, en lugar de proporcionar un conjunto fijo de tipos bits predefinidos. De hecho, los tupos bits estándar que están definidos en el propio lenguaje son:primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 endLas sintaxis generales para la declaración de un tipo primitivo son:primitive type «name» «bits» end\nprimitive type «name» <: «supertype» «bits» end«bits» indica cuánta memoria requiere el tipo y «name» indica el nombre del nuevo tipo. Un tipo primitivo puede ser declarado opcionalmente como un subtipo de algún supertipo. Si se omite el supertipo, se asigna como supertipo por defecto el tipo Any. Por tanto, la declaración de Bool significa que un valor booleano consume 8 bits de almacenamiento, y que Integer es su supertipo inmediato. Actualmente sólo se soportan tamaños que sea múltiplo de 8 bits. Por tanto, los valores booleanos, aunque sólo necesitan un bit, no puden ser declarados como menores de 8 bits.Los tipos Bool, Int8 y UInt8 tienen representaciones idénticas: se trata de bloques de memoria de 8 bits. Como el sistema de tipos de Julia es nominativo, sin embargo, ellos no son intercambiables aunque tengan estructura idéntica. Otra diferencia fundamental entre ellos es que ellos tienen supertipos diferentes: Integer es el supertipo directo de Bool, Signed es el de Int8, y Unsigned es el de  UInt8. Todas las demás diferencias entre  Bool, Int8, y UInt8 son cuestiones de comportamiento  (la forma en la que las funciones son definidas para actuar cuando se pasan como argumentos objetos de estos tipos). Esta es la razón por la que es necesario un sistema de tipos nominativo: si la estructura determinara el tipo, que a su vez dicta el comportamiento, sería imposible hacer que los valores  Bool se comportaran de forma diferente a los Int8 o los UInt8."
},

{
    "location": "manual/types.html#composite-types-1",
    "page": "Tipos",
    "title": "Tipos Compuestos",
    "category": "section",
    "text": "Los tipos compuestos se llaman registros, estructuras (structs) u objetos en distintos lenguajes. Un tipo compuesto es una colección de campos nombrados, una instancia de los cuales puede ser tratada como un único valor. En muchos lenguajes, los tiempos compuestos sos la única clase de tipos definidos por el usuario, y ellos son de lejos el tiempo definido por el usuario  que se usa mas comúnmente en el lenguaje Julia.En el mundo de los lenguajes orientados a objetos tales como C++, Java, Python o Ruby, los tipos compuestos también tienen funciones asociadas a ellos, y esa combinación se denomina \"objeto\". En los lenguajes orientados a objetos más puros, tales como Ruby o SmallTalk, todo los valores son objetos sean compuestos o no. En lenguajes orientados objetos menos puros incuyendo C++ y Java, algunos valores tales como los enteros no se consideran objetos, mientras que las instancias de los tipos compuestos definidos por el usuario son verdaderos objetos con métodos asociados. En Julia, todos los valores son objetos, pero no hay funciones a los objetos sobre los que se opera. Esto es necesario ya que Julia elige qué método de una función usar mediante despacho múltiple, lo que significa que cuando se selecciona un método se consideran los tipos de todos los argumentos de la función y no sólo el primero (ver la sección Métodos para más información). Por tanto, sería inapropiado para las funciones \"pertenecer\" sólo a su primer argumento (el objeto que la posee). Organizar métodos en objetos función en lugar de tener bolsas de métodos nombrados \"dentro\" de cada objeto termina por ser un aspecto muy beneficioso de diseño del lenguaje.Los tipos compuestos son introducidos por la palabra clave struct seguida por un bloque de nombres de campos, opcionalmente anotados con tipos usando el operador ::julia> struct Foo\n           bar\n           baz::Int\n           qux::Float64\n       endLos campos sin anotación de tipos tiene asignado Any como tipo por defecto, y pueden según esto almacenar cualquier tipo de valor.Para crear nuevos objetos del tipo compuesto Foo se crean aplicando el tipo objeto Foo como una función con valores para sus campos:julia> foo = Foo(\"Hello, world.\", 23, 1.5)\nFoo(\"Hello, world.\", 23, 1.5)\n\njulia> typeof(foo)\nFooCuando un tipo es aplicado como una función es llamado constructor. Hay dos constructores, denominados constructores por defecto que se generan automáticamente al crear el tipo. Uno acepta cualquier argumento y llama a convert() para convertirlos a los tipos de los campos, y el otro acepta argumentos que se corresponden exactamente a los tipos de los campos. La razón de que ambos métodos sean generados es que esto hace más sencillo añadir nuevas definiciones sin reemplazar inadvertidamente a un constructor por defecto.Como el campo bar no está restringido en tipo, cualquier valor es válido. Sin embargo, el valor para baz debe ser convertible a Int:julia> Foo((), 23.5, 1)\nERROR: InexactError()\nStacktrace:\n [1] convert(::Type{Int64}, ::Float64) at ./float.jl:679\n [2] Foo(::Tuple{}, ::Float64, ::Int64) at ./none:2La función fieldnames devuelve una lista de los nombres de campos de un objeto:julia> fieldnames(foo)\n3-element Array{Symbol,1}:\n :bar\n :baz\n :quxPara acceder a los valores de los campos de un objeto compuesto puede usarse la notación tradicional foo.bar:julia> foo.bar\n\"Hello, world.\"\n\njulia> foo.baz\n23\n\njulia> foo.qux\n1.5Los tipos compuestos declarados con struct son inmutables, es decir, no pueden ser modificados después de su construcción. Esto puede parecer raro al principio, pero tiene varias ventajas:Puede ser más eficiciente. Algunos struct pueden ser empquetados eficientemente dentro de los arrays, y  en algunos casos el compilador es capaz de evitar asignar objetos inmutables completamente.\nNo es posible violar las invariantes proporcionadas por los contructores de tipo.\nEl código con objetos inmutables puede ser más sencillo de interpretar.Un objeto inmutable puede contener objetos mutables, tales como arrays, como campos. Esos objetos contenidos permanecerán inmutables, sólo los cambos del objeto inmutable en sí no podrán ser cambiados para apuntar a objetos distintos. Cuando se requiera, los objetos compuestos mutables podrán ser declarados con la palabra clave mutable struct, lo que será discutido en la siguiente sección. Los tipos compuestos sin campos son singletons, es decir, sólo puede haber una instancia de tales tipos:julia> struct NoFields\n       end\n\njulia> NoFields() === NoFields()\ntrueLa función === confirma que las dos instancias construidas de NoFields son de hecho una y la misma. Los tipos singleton se describirán en más detalle posteriormente.Hay mucho más que decir sobre cómo se crean las instancias de los tipos compuestos, pero esta discusión depende de los Tipos Paramétricos y de los Métodos, y es suficientemente importante para ser tratada en su propia sección: Constructores."
},

{
    "location": "manual/types.html#mutable-composite-types-1",
    "page": "Tipos",
    "title": "Tipos Compuestos Mutables",
    "category": "section",
    "text": "Si un tipo compuesto es declarado como mutable struct en lugar de como struct, sus instancias pueden ser modificadas:julia> mutable struct Bar\n           baz\n           qux::Float64\n       end\n\njulia> bar = Bar(\"Hello\", 1.5);\n\njulia> bar.qux = 2.0\n2.0\n\njulia> bar.baz = 1//2\n1//2Para soportar la mutación, tales objetos se alojan generalmente en el montón y tienen direcciones de memoria estables. Un objeto mutable es como un pequeño contenedor que podría almacenar distintos valores en el tiempo, y por tanto sólo puede ser identificado de forma confiable con su dirección. En contraste, una instancia de un tipo inmutable está asociada con valores de campos específicos - los valores de campos solos te dicen todo sobre el objeto. En decidir si hacer un tipo mutable, pregúntat si dos instanciasa con los mismos valores de campos tendrían que ser consideradas idénticas, o si ellas podrían necesitar cambiar independientemente con el tiempo. Si ellas fueran consideradas idénticas, el tipo probablemente debería ser inmutable. Para recapitular, dos propiedades esenciales definen la inmutabilidad en Julia:Un objeto con un tipo inmutable es pasado (tanto en instrucciones de asignación como en llamadas a función) mediante copia, mientras que un tipo mutable es pasado mediante referencia.\nNo está permitido modificar los campos de un tipo compuesto inmutable.Es instructivo, particularmente para lectores cuyo background es C/C++, considerar por qué estas dos propiedades van juntas. Si fueran separadas, es decir, si los campos de los objetos pasados mediante copia pudieran ser modificados, entonces sería más difícil razonar sobre ciertas instancias de código genérico. Por ejemplo, supongamos que x es un argumento de función de un tipo abstracto, y supongamos que la función cambia un campo: x.isprocessed = true. Dependiendo de si xse pasa mediante copia o mediante referencia, esta instrucción puede alterar o no el argumento actual en la rutina que hace la llamada. Julia evita la posibilidad de crear funciones con efectos desconocidos en este escenario prohibiendo modificación de campos de objetos pasados mediante copia. "
},

{
    "location": "manual/types.html#Tipos-declarados-1",
    "page": "Tipos",
    "title": "Tipos declarados",
    "category": "section",
    "text": "Las tres clases de tipos discutidos en las tres secciones anteriores están muy relacionados. Ellos comparten las mismas propiedades clave:Ellos son declarados explícitamente.\nEllos tienen nombres.\nEllos tienen supertipos declarados explícitamente.\nEllos pueden tener parámeros.Debido a estas propiedades compartidas, estos tipos son representados internamene  como instancias del mismo concepto, DataType , que es el tipo de cualquiera de estos tipos:julia> typeof(Real)\nDataType\n\njulia> typeof(Int)\nDataTypeUn DataType puede ser abstracto o concreto. Si es concreto, tiene un tamaño, disposición de almacenamiento y (opcionalmente) nombres de campos especificados. Por tanto, un tipo bits es un DataType con tamaño no nulo, pero sin nombres de campos. Un tipo compuesto es un DataType que tiene nombres de campos o es acío (tamaño cero).Cada valor concreto en el sistema es una instancia de algún DataType."
},

{
    "location": "manual/types.html#Uniones-de-Tipos-1",
    "page": "Tipos",
    "title": "Uniones de Tipos",
    "category": "section",
    "text": "Una unión de tipos es un tipo abstracto especial que incluye como objetos todas las instancias de alguno de sus tipos argumentos, construidos usando la función especial Union:julia> IntOrString = Union{Int,AbstractString}\nUnion{AbstractString, Int64}\n\njulia> 1 :: IntOrString\n1\n\njulia> \"Hello!\" :: IntOrString\n\"Hello!\"\n\njulia> 1.0 :: IntOrString\nERROR: TypeError: typeassert: expected Union{AbstractString, Int64}, got Float64Los compiladores de muchos lenguajes tienen una construcción unión interna para razonar sobre los tipos; Julia simplemente la pone a disposición del programador."
},

{
    "location": "manual/types.html#parametric-types-1",
    "page": "Tipos",
    "title": "Tipos Paramétricos",
    "category": "section",
    "text": "Una característica importante y potente del sistema de tipos de Julia es que es paramétrico: los tipos pueden toomar parámetros, por lo que las declaraciones de tipo introducen de hecho un afamilia completa de nuevos tipos (uno por cada posible combinación de valores de parámetros). Hay muchos lenguajes que soportan alguna versión de la programación genérica, donde las estructuras de datos y algoritmos para manipularlos pueden ser especificadas sin especificar los tipos exactos implicados. Por ejemplo, existe alguna forma de programación genérica en ML, Haskell, Ada, Eiffel, C++, Java, C#, F# y Scala, por nombrar unos pocos. Algunos de estos lenguajes soportan un verdadero polimorfismo paramétrico (Por ej., ML, Haskell, Scala) mientras otros soportan estilos de programación genérica ad-hoc, basados en plantillas (Por eje., C++ y Java). Con tantas variedades diferentes de programación genérica y de tipos paramétricos en los distintos lenguajes, no queremos ni siquiera intentar comparar los tipos paramétricos de Julia a otros lenguajes, sino que nos centraremos en explicar el propio sistema de Julia. Notaremos, sin embargo, que como Julia es un lenguaje tipado dinámicamente y no necesita hacer todas las decisiones de tipos en tiempo de compilacíon, muchas dificultades tradicionales encontradas en los sistemas de tipos paramétricos estáticos pueden ser manejadas con relativa facilidad.Todos los tipos declarados (la variedad DataType)  pueden ser parametrizados, con la misma sintaxis en cada caso. Los discutiremos en el siguiente orden: primero tipos compuestos paramétricos, luego tipos abstractos paramétricos y por último tipos bits paramétricos."
},

{
    "location": "manual/types.html#Tipos-compuestos-paramétricos-1",
    "page": "Tipos",
    "title": "Tipos compuestos paramétricos",
    "category": "section",
    "text": "Los parámetros de tipo se introducen inmediatamente después del nombre de tipo, rodeado por llaves:julia> struct Point{T}\n           x::T\n           y::T\n       endEsta declaración define un nuevo tipo paramétrico, Point{T}, que almacena dos coordenadas de tipo T. Uno podría preguntarse, ¿qué es T? Bien, este es precisamente la clave de los tipos paramétricos: puede ser cualquier tipo (o un valor de cualquier tipo bits, aunque en esta ocasión usado como un tipo, claramente). Point{Float64} es un tipo concreto equivalente al tipo definido reemplazando T en la definición de Point con Float64. Por tanto, esta única  declaración declara un número de tipos ilimitado: Point{Float64}, Point{AbstractString}, Point{Int64}, etc. Cada uno de ellos es un tipo concreto usable: julia> Point{Float64}\nPoint{Float64}\n\njulia> Point{AbstractString}\nPoint{AbstractString}El tipo Point{Float64} es un punto cuyas coordenadas son valores en punto flotante de 64-bits, mientras que el tipo Point{AbstractString} es un “punto” cuyas “coordenadas” son objetos String (see Strings).Point es en si mismo un tipo objeto válido también, que contiene todas las instancias Point{Float64}, Point{AbstractString}, etc. como subtipos:julia> Point{Float64} <: Point\ntrue\n\njulia> Point{AbstractString} <: Point\ntrueOtros tipos, por supuesto, no son subtipos de él:julia> Float64 <: Point\nfalse\n\njulia> AbstractString <: Point\nfalseLos tipos Point concretos con valores diferentes de T no son nunca subtipos uno de otro:julia> Point{Float64} <: Point{Int64}\nfalse\n\njulia> Point{Float64} <: Point{Real}\nfalsewarning: Warning\nEste último punto es importante: Incluso aunque Float64 <: Real no es cierto que Point{Float64} <: Point{Real}. En otras palabras, en términos de teoría de tipos, los parámetros de tipo de Julia son invariantes, en lugar de ser covariantes (o incluso contravariantes). Esto es por razones prácticas: aunque alguna instancia de Point{Float64} puede ser conceptualmente como una instancia de Point{Real}, los dos tipos tienen representaciones diferentes en memoria:Una instancia de Point{Float64} puede ser representada compactamente y eficientemente como un par   de valores de 64 bits inmediatos\nUna instancia de Point{Real} debe ser capaz de alojar cualquier par de instancias de Real. Como los  objetos son instancias de Real pueden ser de tamaño y estructura arbitrarios, en la práctica una instancia de Point{Real} debe ser representada como un par de punteros a objetos Real asignados individualmente.La eficiencia ganada por ser capaz de almacenar objetos Point{Float64} con valores inmediatos es magnificada enormemente en el caso de arrays: un Array{Float64} puede almacenarse como un bloque contiguo de memoria de valores en punto flotante de 64 bits, mientras que un Array{Real} debe ser un array de punteros a objetos Real asignados individualmente (que puede ser valores en punto flotante de 64 bits envueltos (boxed), pero que también pueden ser objetos complejos, arbitrariamente grandes, que han sido declarados como implementaciones del tipo abstracto Real.Como Point{Float64} no es un subtipo de Point{Real},  el siguiente método no puede ser aplicado a argumentos de tipo Point{Float64}:function norm(p::Point{Real})\n    sqrt(p.x^2 + p.y^2)\nendUna forma correcta de definir un método que acepte todos los argumentos de tipo Point{T}, donde T es un subtipo de Real es:function norm(p::Point{<:Real})\n    sqrt(p.x^2 + p.y^2)\nend(Equivalentemente, uno podría definir function norm{T<:Real}(p::Point{T}) o function norm(p::Point{T} where T<:Real); ver tipos UnionAll.)Más ejemplos se discutirán después en Métodos.¿Cómo construye uno un objeto Point? Es posible definir constructores personalizados para tipos compuestos, que serán discutidos en detalle en el capítulo Constructores, pero en ausencia de ninguna declaración especial de constructor, hay dos formas por defecto de crear nuevos objetos compuestos, uno en el que se dan explícitamente los parámetros de tipo y otro en el que ellos son implicados por los argumentos al objeto constructor.Como el tipo Point{Float64} es un tipo concreto equivalente a Point declarado con Float64 en lugar de T, se puede aplicar como un constructor ede acuerdo a ésto:julia> Point{Float64}(1.0, 2.0)\nPoint{Float64}(1.0, 2.0)\n\njulia> typeof(ans)\nPoint{Float64}Para el constructor por defecto, debe proporcionarse exactamente un argumento por cada campo: julia> Point{Float64}(1.0)\nERROR: MethodError: Cannot `convert` an object of type Float64 to an object of type Point{Float64}\nThis may have arisen from a call to the constructor Point{Float64}(...),\nsince type constructors fall back to convert methods.\nStacktrace:\n [1] Point{Float64}(::Float64) at ./sysimg.jl:77\n\njulia> Point{Float64}(1.0,2.0,3.0)\nERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)Sólo se ha generado un constructor por defecto para tipos paramétricos, ya que sobreescribirlo no es posible. Este constructor acepta cualquier argumento y los convierte a los tipos de los campos.En muchos casos es redundante proporcionar el tipo del objeto Point que uno quiere construir, ya que los tipos de los argumentos en la llamada al constructor ya proporcionan la información de tipos de forma implícita. Por esta razón, también podemos aplicar el propio Point como un constructor, dado que el valor implícito del parámetro de tipo T no es ambiguo:julia> Point(1.0,2.0)\nPoint{Float64}(1.0, 2.0)\n\njulia> typeof(ans)\nPoint{Float64}\n\njulia> Point(1,2)\nPoint{Int64}(1, 2)\n\njulia> typeof(ans)\nPoint{Int64}En el caso de Point es implicado sin ambigüedad si y sólo si los dos argumentos a Point tienen el mismo tipo. Cuando este no es el caso, el constructor fallará con un MethodError:julia> Point(1,2.5)\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\nClosest candidates are:\n  Point(::T, !Matched::T) where T at none:2Los método constructores para manejar apropiadamente estos casos mixtos pueden ser definidos, pero esto no será discutido hasta después en Constructores."
},

{
    "location": "manual/types.html#Tipos-Abstractos-Paramétricos-1",
    "page": "Tipos",
    "title": "Tipos Abstractos Paramétricos",
    "category": "section",
    "text": "Las declaraciones de tipos abstractos paramétricos declaran una colección de tipos abstractos, de la misma forma:julia> abstract type Pointy{T} endCon esta declaración, Pointy{T} es un tipo abstracto distinto para cada tipo o valor entero de T. Como con los tipos compuestos paramétricos, cada una de tales instancias es un subtipo de Pointy:julia> Pointy{Int64} <: Pointy\ntrue\n\njulia> Pointy{1} <: Pointy\ntrueLos tipos abstractos paramétricos son invariantes, tal como los tipos compuestos paramétricos:julia> Pointy{Float64} <: Pointy{Real}\nfalse\n\njulia> Pointy{Real} <: Pointy{Float64}\nfalseLa notación Pointy{<:Real} puede usarse para expresar el análogo Julia de un tipo covariante, mientras que  Pointy{>:Int} es el análogo de un tipo contravariante, pero técnicamente estos representan conjuntos de tipos (ver tipos UnionAll).julia> Pointy{Float64} <: Pointy{<:Real}\ntrue\n\njulia> Pointy{Real} <: Pointy{>:Int}\ntrueDe la misma manera que los tipos abstractos antiguos sirven para crear una jerarquía útil de tipos sobre tipos concretos, los tipos abstractos paramétricos tienen el mismo propósito con respecto a los tipos compuestos paramétricos. Podríamos, por ejemplo, haber declarado Point {T} ser un subtipo de Pointy {T} de la siguiente manera:julia> struct Point{T} <: Pointy{T}\n           x::T\n           y::T\n       endDada tal declaración, para cada elección de T tenemos Point{T} como un subtipo de Pointy{T}:julia> Point{Float64} <: Pointy{Float64}\ntrue\n\njulia> Point{Real} <: Pointy{Real}\ntrue\n\njulia> Point{AbstractString} <: Pointy{AbstractString}\ntrueEsta relación es también invariante:julia> Point{Float64} <: Pointy{Real}\nfalse\n\njulia> Point{Float64} <: Pointy{<:Real}\ntrue¿A qué propósito sirven los tipos abstractos paramétricos como Pointy? Considere si creamos una implementación tipo punto que sólo necesita una coordenada debido a que el punto se encuentra en la diagonal del primer cuadrante (y = x):julia> struct DiagPoint{T} <: Pointy{T}\n           x::T\n       endAhora tanto Point{Float64} como DiagPoint{Float64} son implementaciones de la abstracción Pointy{Float64} y, similarmente, para cada otra posible elección del tipo T. Esto permite programar a un interfaz común compartido por todos los objetos Pointy, implementedo tanto por Pointcomo por DiagPoint. Esto no puede ser totalmente demostrado, sin embargo, hasta que no hayamos introducidos los métodos y el despacho en la siguiente sección, Methods.Hay situaciones donde puede no tener sentido para los parámetros de tipo varíen libremente sobre todos los tipos posibles. En tales situaciones, uno puede restringir el rango de T como aquí:julia> abstract type Pointy{T<:Real} endHay situaciones donde puede no tener sentido para los parámetros de tipo varíen libremente sobre todos los tipos posibles. En tales situaciones, uno puede restringir el rango de T como aquí:julia> Pointy{Float64}\nPointy{Float64}\n\njulia> Pointy{Real}\nPointy{Real}\n\njulia> Pointy{AbstractString}\nERROR: TypeError: Pointy: in T, expected T<:Real, got Type{AbstractString}\n\njulia> Pointy{1}\nERROR: TypeError: Pointy: in T, expected T<:Real, got Int64Los parámetros de tipo para tipos compuestos paramétricos pueden ser restringidos de la misma manera:struct Point{T<:Real} <: Pointy{T}\n    x::T\n    y::T\nendPara dar un ejemplo del mundo real de cómo toda esta maquinaria de tipos paramétricos puede ser útil, he aquí la definición actual del tipo inmutable Rational Rational de Julia (omitiendo el constructor por simplicidad), que representa una relacíon exacta de enteros:struct Rational{T<:Integer} <: Real\n    num::T\n    den::T\nendSólo tiene sentido tomar relaciones de valores enteros, por lo que el tipo parametrizado T está restringido a ser un subtipo de Integer, y una razón de enteros representa un valor sobre la línea de los números reales, por lo que cualquier Rational es una instancia de la abstracción Real."
},

{
    "location": "manual/types.html#Tipos-tupla-1",
    "page": "Tipos",
    "title": "Tipos tupla",
    "category": "section",
    "text": "Las tuplas son una abstracción de los argumentos de una función (sin la propia función). Los aspectos salientes de los argumentos de una funcíon son su orden y sus tipos. Por tanto, un tipo tupla es muy similar a un tipo inmutable parametrizado donde cada parámetro es el tupo de un campo. Por ejemplo, un tipo tupla de dos elementos se parece al siguiente tipo inmutable:struct Tuple2{A,B}\n    a::A\n    b::B\nendSin embargo, hay tres diferencias clave:Los tipos tupla pueden tener cualquier número de parámetros.\nLos tipos tupla son covariantes en sus parámetros: Tuple{Int} es un subtipo of Tuple{Any}. Por tanto Tuple{Any} es considerado un tipo abstracto, y los tipos tupla son solo concretos si sus parámetros lo son.\nLas tuplas no tienen nombres de campo; los campos son sólo accedidos mediante índices.Los valores tupla son escritos con paréntesis y comas. Cuando se construye una tupla, se genera un tipo tupla apropiado bajo demanda:julia> typeof((1,\"foo\",2.5))\nTuple{Int64,String,Float64}Note las implicaciones de  covarianza:julia> Tuple{Int,AbstractString} <: Tuple{Real,Any}\ntrue\n\njulia> Tuple{Int,AbstractString} <: Tuple{Real,Real}\nfalse\n\njulia> Tuple{Int,AbstractString} <: Tuple{Real,}\nfalseIntuitivamente, esto corresponde al tipo de los argumentos de una función, siendo un subtipo de la signatura de la función (cuando la signatura se corresponde)."
},

{
    "location": "manual/types.html#Tipos-Tupla-Vararg-1",
    "page": "Tipos",
    "title": "Tipos Tupla Vararg",
    "category": "section",
    "text": "El último parámetro de un tipo tupla puede ser el tipo especial Vararg, que denota cualquier número de elementos arrastrados:julia> mytupletype = Tuple{AbstractString,Vararg{Int}}\nTuple{AbstractString,Vararg{Int64,N} where N}\n\njulia> isa((\"1\",), mytupletype)\ntrue\n\njulia> isa((\"1\",1), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2,3.0), mytupletype)\nfalseNotese que Varags{T} corresponde a cero o más elementos del tipo T. Los tipos tupla vararg se usan para representar los argumentos aceptados por los métodos vararg (ver Funciones Vararg).El tipo Vararg{T,N} se corresponde a exactamente N elementos de tipo T. NTuple{N,T} es un alias conveniente para Tuple{Vararg{T,N}}, es decir, un tipo tupla conteniendo exactamente N elementos de tipo T."
},

{
    "location": "manual/types.html#man-singleton-types-1",
    "page": "Tipos",
    "title": "Tipos Singleton",
    "category": "section",
    "text": "Hay una clase especial de tipo paramétrico abstracto que hay que mencionar aquí: los tipos singleton. Para cada tipo T el tipo singleton Type{T} es un tipo abstracto cuya única instancia es el objeto T.  Como la definición es un poco difícil de analizar, echemos un vistazo a los siguientes ejemplos:julia> isa(Float64, Type{Float64})\ntrue\n\njulia> isa(Real, Type{Float64})\nfalse\n\njulia> isa(Real, Type{Real})\ntrue\n\njulia> isa(Float64, Type{Real})\nfalseEn otras palabras, isa(A,Type{B}) es true si y solo si A y B son el mismo objeto y este objeto es un tipo. Sin el parámetro, Type es simplemente un tipo abstracto que tiene como instancias todos los objetos tipo, incluyendo, por supuesto, los tipos singleton:julia> isa(Type{Float64}, Type)\ntrue\n\njulia> isa(Float64, Type)\ntrue\n\njulia> isa(Real, Type)\ntrueCualquier objeto que no es un tipo no es una instancia de Type:julia> isa(1, Type)\nfalse\n\njulia> isa(\"foo\", Type)\nfalseHasta que discutamos loa métodos paramétricos y las conversiones, , es difícil explicar la utilidad de la construcción tipo singleton, pero abreviando, permite a uno especializar el comportamiento de una función sobre valores de un tipo específico. Esto es útil para escribir métodos (especialmente paramétricos) cuy ocomportamiento dependa de un tipo que es dado como un argumento explícito en lugar de implicado por el tipo de un o de sus argumentos.Unos pocos lenguajes de programación tienen tipos singleton, incluyendo Haskell, Scala y Ruby. En uso general, el término \"tipo singleton\" se refiere a un tipo cuya única instancia es un solo valor. Este significado se aplicaa a los tipos singleton de Julia, pero con la advertencia de que sólo los objetos tipo tienen tipos singleton."
},

{
    "location": "manual/types.html#Tipos-primitivos-paramétricos-1",
    "page": "Tipos",
    "title": "Tipos primitivos paramétricos",
    "category": "section",
    "text": "Los tipos bits pueden ser declarados paramétricamente. Por ejemplo, los punteros son reprentados como tipos bits encajados que serían declarados en Julia de esta forma:# 32-bit system:\nprimitive type Ptr{T} 32 end\n\n# 64-bit system:\nprimitive type Ptr{T} 64 endLa característica ligeramente extraña de estas declaraciones comparadas con los tipos compuestos paramétricos típicos es que el parámetro de tipo T no se usa en la definición del propio tipo (es justo un tag abstracto, esencialmente definiendo una familia entera de tipos con idéntica estructura, diferenciada sólo por su parámetro de tipo. Por tanto Ptr{Float} y Ptr{Int64} son tipos distintos, incluso auntque ellos tengan representaciones idénticas. Y, por supuesto, todos los tipos puntero específicos son subtipo del tipo sombrilla Ptr:julia> Ptr{Float64} <: Ptr\ntrue\n\njulia> Ptr{Int64} <: Ptr\ntrue"
},

{
    "location": "manual/types.html#unionall-types-1",
    "page": "Tipos",
    "title": "Tipos UnionAll",
    "category": "section",
    "text": "Hemos dicho que un tipo paramétrico como Ptr actúa como un supertipo de todas sus instancias (Ptr{Int64} etc.). ¿Cómo funciona esto? Ptr en si mismo no puede ser un tipo normal, ya que sin saber el tipo de los datos referenciados el tipo claramente no puede ser usado para operaciones en memoria. La respuesta es que Ptr (u otros tipos paramétricos como Array) es una clase diferente de tipo llamado UnionAll. Tal tipo expresa la unión iterada de tipos para todos los valores de algún parámetro.Los tipos UnionAllsuelen ser escritos usando la palabra clave where. Por ejemplo, Ptr podría ser escrito de forma más exacta como Ptr{T} where T, lo que significa que todos los valores cuyo tipo es Ptr{T} para algún valor de T. En este contexto, el parámetro T suele llamarse también una \"variable tipo\", ya que es como una variable que se extiende sobre los tipos. Cada where introduce una sola variable tipo, por lo que estas expresiones están anidadas para tipos con múltiples parámetros, por ejemplo Array{T,N} where N where T.La sintaxis de la aplicación de tipo A{B, C} requiere que A sea un tipo UnionAll y primero sustituye B  por la variable de tipo más externa en A. Se espera que el resultado sea otro tipo UnionAll en el cuál C será sustituido. Por tanto, A{B,C} es equivalente a  A{B}{C}. Esto explica por qué es posible instanciar parcialmente un tipo, como en Array{Float64}: El primer valor de parámetro ha sido fijado, pero el segundo aún se extiende sobre todos os posibles valores. Usando explícitamente la sintaxis where, cualquier subconjunto de parámetros puede ser fijado. Por ejemplo, el tipo de todos los arrays unidimensionales puede ser escrito como Array{T,1} where T.Las variables de tipo pueden ser restringidas con relaciones de subtipos. Array{T} where T<:Integer se refiere a todos los arrays cuyo elemento de tipo es alguna clase de Integer. La sintaxis Array{<:Integer} es una abreviatura conveniente para Array{T} where T<:Integer. Las variables tipo pueden tener tanto límites superiores como inferiores. Array{T} where Int<:T<:Number se refiere a todos los arrays de Numbers que son capaces de contener Ints (dado que T debe ser al menos tan grande como Int). La sintaxis where T>:Int también funciona para especificar sólo el límite inferior de una variable de tipo, y Array{>:Int} es  equivalente a Array{T} where T>:Int.En el caso de expresiones where anidadas, los límites de la variable de tipo  pueden referirse a las variables de tipo más externas. Por ejemplo, Tuple{T,Array{S}} where S<:AbstractArray{T} where T<:Real se refiere a dos tuplas cuyo primer elemento es algo Real y cuyo segundo elemento es un Array de cualquier clase cuyo tipo de elemento contenga el tipo del primero elmento de la tupla.La palabra clave where en si misma puede ser anidada dentro de una declaración más compleja. Por ejemplo, considere los dos tipos creados por las siguientes declaraciones:julia> const T1 = Array{Array{T,1} where T, 1}\nArray{Array{T,1} where T,1}\n\njulia> const T2 = Array{Array{T,1}, 1} where T\nArray{Array{T,1},1} where TEl tipo T1 define un array unidimensional de arrays unidimensionales; cada uno de los arrays internos consta de objetos del mismo tipo, pero este tipo puede variar de un array interno al siguiente. Por otra parte, el tipo T2 define un array unidimensional de arrays unidimensionales de manera que los arrays internos tienen todos el mismo tipo. Notese que T2 es un tipo abstracto, es decir, Array{Array{Int,1},1} <: T2, mientras que T1 es un tipo concreto. Como consecuencia, T1 puede ser construido con un constructor de cero argumentos a=T1() pero T2 no puede.Hay una sintaxis conveniente para nombrar tales tipos, similar a la forma corta de la sintaxis de definición de función:Vector{T} = Array{T,1}Esto es equivalente a const Vector = Array{T,1} where T. Escribir Vector{Float64} es equivalente a escribir Array{Float64,1}, y el tipo paraguas Vector tiene como instancias todos los objetos Array donde el segundo parámetro (el número de dimensiones del array) es uno, sin importar cuál es el tipo del elemento. En lenguajes donde los tipos paramétricos deben siempre ser especificados por completo, esto no suele ser de ayuda, pero en Julia, esto permite a uno escribir justo Vector para el tipo abstract incluyendo arrays densos unidimensionales de cualquier tipo de elementos."
},

{
    "location": "manual/types.html#Aliases-de-Tipos-1",
    "page": "Tipos",
    "title": "Aliases de Tipos",
    "category": "section",
    "text": "Algunas veces es conveniente introducir un nuevo nombre para un tipo ya expresable. Para tales ocasiones, Julia proporciona el mecanismo typealias. Por ejemplo, UInt es un alias de UInt32 o UInt64 dependiendo de los punteros de tamaño del sistema:# 32-bit system:\njulia> UInt\nUInt32\n\n# 64-bit system:\njulia> UInt\nUInt64Esto se consigue via el siguiente código en base/boot.jl:if Int === Int64\n    const UInt = UInt64\nelse\n    const UInt = UInt32\nendPor supuesto, esto depende de a qué representa el alias Int si a Int32 o a Int64.(Note que, a diferencia de Int, Float no existe como un alias de tipo para un tamaño específico de AbstractFloat. A diferencia de con los registros enteros, los tamaños de los registros en punto flotante están especificados por el estándar IEEE-754 standard. Mientras que el tamaño de Int refleja el tamaño de un puntero nativo de esta máquina.)"
},

{
    "location": "manual/types.html#Operaciones-sobre-tipos-1",
    "page": "Tipos",
    "title": "Operaciones sobre tipos",
    "category": "section",
    "text": "Como los tipos en Julia son objetos en sí mismos, las funcoines ordinarias pueden operar sobre ellos. Algunas funciones que son particularmente útiles para trabajar con o explorar tipos han sido ya introducidas. Por ejemplo, el operador <: que indica si el operando a su izquierda es un subtipo del operando a su derecha.La función isa comprueba si un objeto es de un tipo dado y devuelve true o false:julia> isa(1, Int)\ntrue\n\njulia> isa(1, AbstractFloat)\nfalseLa función typeof() , ya usada a través del manual en ejemplos, devuelve el tupo de su argumento. Como, con se notó anteriormente, los tipos son objetos, ellos también tienen tipos, y podemos preguntar cuáles son sus tipos:julia> typeof(Rational{Int})\nDataType\n\njulia> typeof(Union{Real,Float64,Rational})\nDataType\n\njulia> typeof(Union{Real,String})\nUnion¿Qué pasa si repetimos el proceso? ¿Cuál es el tipo de un tipo de un tipo? Como sucede, los tipos son todos valores compuestos y por tanto todos tendrán un tipo de DataType:julia> typeof(DataType)\nDataType\n\njulia> typeof(Union)\nDataTypeDataType is its own type.Otra operación que se aplica a algunos tipos es  supertype(), que revela el supertipo de un tipo. Sólo los tipos declarados (DataType) tienen supertipos no ambiguos:julia> supertype(Float64)\nAbstractFloat\n\njulia> supertype(Number)\nAny\n\njulia> supertype(AbstractString)\nAny\n\njulia> supertype(Any)\nAnySi aplicamos supertype() a otros objetos tipo (u objetos no tipo) se lanzará un MethodError:julia> supertype(Union{Float64,Int64})\nERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})\nClosest candidates are:\n  supertype(!Matched::DataType) at operators.jl:41\n  supertype(!Matched::UnionAll) at operators.jl:46"
},

{
    "location": "manual/types.html#Custom-pretty-printing-1",
    "page": "Tipos",
    "title": "Custom pretty-printing",
    "category": "section",
    "text": "Frecuentemente, uno quiere personalizar cómo se mostrarán las instancias de un tipo. Esto se consigue sobrecargando la función show(). Por ejemplo, supongamos que definimos un tipo para representar número complejos en forma polar:julia> struct Polar{T<:Real} <: Number\n           r::T\n           Θ::T\n       end\n\njulia> Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)\nPolarAquí, hemos añadido una función constructor personalizado para que pueda tomar argumentos de distinto tipos Real y los promocione a un tipo común (ver Constructores y Conversión y Promoción). (Por supuesto, tendríamos que definir montones de otros métodos también, para hacer que actíe como un Number, por ejemplo, +, *, one, zero, reglas de promoción y otras cosas). Por defecto, las instancias de este tipo se muestran de forma bastante simple, con información sobre el nombre del tipo y los valores de los campos, como por ejemplo en  Polar{Float64}(3.0,4.0).Si en lugar de usar este modo de presentacin preferimos que su presentación sea 3.0 * exp(4.0im), hay que definir el siguiente método para que imprima el objeto a un objeto de salida iodado (que representa un fichero, terminal, buffer, etc.; ver Networking and Streams):julia> Base.show(io::IO, z::Polar) = print(io, z.r, \" * exp(\", z.Θ, \"im)\")Es posible un control de grano más fino sobre la visualizacin de los objetos Polar. En particular, algunas veces uno desea un formato de impresión detallado multilínea, utilizado para mostrar un solo objeto en REPL y otros entornos interactivos, y también un formato de línea única más compacto utilizado para [print ()] @ref) o para mostrar el objeto como parte de otro objeto (por ejemplo, en una matriz). Aunque de forma predeterminada se llama a la función show (io, z) en ambos casos, puede definir un formato multilínea diferente para mostrar un objeto sobrecargando una forma de tres argumentos de show que toma el tipo MIME text/plain como su segundo argumento (consulte E/S multimedia), por ejemplo:julia> Base.show{T}(io::IO, ::MIME\"text/plain\", z::Polar{T}) =\n           print(io, \"Polar{$T} complex number:\\n   \", z)(Note que print(..., z) aquí invocará al método con dos argumentos show(io, z)). Esto dará como resultado:julia> Polar(3, 4.0)\nPolar{Float64} complex number:\n   3.0 * exp(4.0im)\n\njulia> [Polar(3, 4.0), Polar(4.0,5.3)]\n2-element Array{Polar{Float64},1}:\n 3.0 * exp(4.0im)\n 4.0 * exp(5.3im)donde se sigue utilizando la forma de línea show(io, z) para un array de valores  Polar. Técnicamente, el REPL llama a  display(z) para mostrar el resultado de ejecutar una línea que por defecto es show (STDOUT, MIME (\" text / plain \"), z),  que a su vez por defecto es show (STDOUT, z), pero debe no definir nuevos métodos display() a menos que esté definiendo un nuevo controlador de pantalla multimedia (consulte E/S multimedia).Además, también puede definir métodos show para otros tipos MIME para permitir una visualización más rica (HTML, imágenes, etc.) de los objetos en entornos que lo admitan (por ejemplo, IJulia). Por ejemplo, podemos definir la visualización HTML formateada de objetos Polar, con superíndices y cursiva, a través de:julia> Base.show{T}(io::IO, ::MIME\"text/html\", z::Polar{T}) =\n           println(io, \"<code>Polar{$T}</code> complex number: \",\n                   z.r, \" <i>e</i><sup>\", z.Θ, \" <i>i</i></sup>\")Un objeto Polar se mostrará entonces automáticament usando HtML en un entorno que soporte pantallas HTML, pero podemos llamar a la función show manualmente para obtener una salida HTML si lo deseamos:julia> show(STDOUT, \"text/html\", Polar(3.0,4.0))\n<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup><p>An HTML renderer would display this as: <code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup></p>"
},

{
    "location": "manual/types.html#value-types-1",
    "page": "Tipos",
    "title": "\"Valores tipo\"",
    "category": "section",
    "text": "En Julia uno no puede despachar sobre un valor  tal como true o false. Sin embargo, se se puede despachar sobre tipos paramétricos, y Julia  permite incluir valores \"plain bits\" (tipos, símbolos, enteros, números en punto flotante, tuplas, etc.) como parámetros de tipo. Un ejemplo común es el parámetro de dimensionalidad en Array{T,N}, donde T es un tipo (por ejemplo,  Float64) pero N es un Int.Podemos crear nuestros propio tipos personalizados que tomen valores como parámetros, y usarlos para controlar el despacho de los tipos personalizados. A modo de ilustración de esta idea, introduzcamos un tipo paramétrico, Val{T} que sirve como una forma tradicional de explotar esta técnica para casos donde tu no necesitas una jerarquía más elaborada.Val es definida como:julia> struct Val{T}\n       endNo hay más implementaciones de Val que esta. Algunas funciones en la librería estándar de Julia aceptan los tipos Val como argumentos, y uno también puede usarlos para escribir sus propias funciones. Por ejemplo:julia> firstlast(::Type{Val{true}}) = \"First\"\nfirstlast (generic function with 1 method)\n\njulia> firstlast(::Type{Val{false}}) = \"Last\"\nfirstlast (generic function with 2 methods)\n\njulia> firstlast(Val{true})\n\"First\"\n\njulia> firstlast(Val{false})\n\"Last\"Por consistencia con Julia, el sitio de llamada debería siempre pasar un tipo Val en lugar de crear una instancia, por ejemplo, usar foo(Val{:bar}) en lugar de foo(Val{:bar}()).Vale la pena señalar que es extremadamente sencillo usar mal los tipos \"valor\" paramétricos, incluyendo Val; en caso desfavorables, tu puedes fácilmente acabar haciendo el rendimiento de tu código mucho peor. En particular, tu nunca tendrás que querer escribir código actual como ilustramos anteriormente. Para má información sobre el uso apropiado de Val consulte por fabor la discusión más extensa en los consejos de rendimiento."
},

{
    "location": "manual/types.html#man-nullable-types-1",
    "page": "Tipos",
    "title": "Tipos Nullable: representando valores perdidos",
    "category": "section",
    "text": "En muchas situaciones, uno necesita interactuar con un valor de tipo T que puede o no existir. Para manejar estas situaciones, Julia proporciona un tipo paramétrico denominado Nullable{T} que puede ser pensado como un tipo contenedor especializado que puede contener cero o un valores. Nullable{T} proporciona una interfaz mínima diseñada para asegurar qué interacciones con valores perdidos son seguras. En la actualidad, la interfaz consiste en varias posibles interacciones:Construir un objeto Nullable.\nComprobar si un objeto Nullable tiene un valor perdido.\nAcceder al valor de un objeto Nullable con la garantía de que se lanzará una NullException si el valor del objeto está perdido.\nAcceder al valor de un objeto Nullable con una garantía de que el valor por defecto del tipo T será devuelto  si el valor del objeto se pierde.\nRealizar una operación sobre el valor (si existe) de un objeto Nullable, obteniendo un resultadoNullable.  El resultado faltará si falta el valor original.\nRealizar una prueba sobre el valor (si existe) de un objeto Nullable, obteniendo un resultado que será perdido si faltaba elNullable o si la prueba falla.\nRealizar operaciones generales en objetos individuales Nullable, propagando los datos faltantes."
},

{
    "location": "manual/types.html#Construyendo-objetos-[Nullable](@ref)-1",
    "page": "Tipos",
    "title": "Construyendo objetos Nullable",
    "category": "section",
    "text": "Para construir un objeto representando un valor perdido de tipo T, use la siguiente función `Nullable{T}():julia> x1 = Nullable{Int64}()\nNullable{Int64}()\n\njulia> x2 = Nullable{Float64}()\nNullable{Float64}()\n\njulia> x3 = Nullable{Vector{Int64}}()\nNullable{Array{Int64,1}}()Para construir un objeto representando un valor no perdido de tipo T, use la función Nullable(x::T):julia> x1 = Nullable(1)\nNullable{Int64}(1)\n\njulia> x2 = Nullable(1.0)\nNullable{Float64}(1.0)\n\njulia> x3 = Nullable([1, 2, 3])\nNullable{Array{Int64,1}}([1, 2, 3])Note que la distinción clave entre estas dos formas de construir un objeto Nullable: en un estilo, tu proporcionas un tipo, T como un parámetro a función; en el otro estilo, tu proporcionas un solo valor de tipo T como argumento."
},

{
    "location": "manual/types.html#Comprobar-si-un-objeto-Nullable-tiene-un-valor-1",
    "page": "Tipos",
    "title": "Comprobar si un objeto Nullable tiene un valor",
    "category": "section",
    "text": "Puedes comprobbar si un objeto Nullable tiene algún valor usando isnull():julia> isnull(Nullable{Float64}())\ntrue\n\njulia> isnull(Nullable(0.0))\nfalse"
},

{
    "location": "manual/types.html#Acceder-de-forma-segura-al-valor-de-un-objeto-Nullable-1",
    "page": "Tipos",
    "title": "Acceder de forma segura al valor de un objeto Nullable",
    "category": "section",
    "text": "Puedes acceder al valor de un objeto Nullable usando  get():julia> get(Nullable{Float64}())\nERROR: NullException()\nStacktrace:\n [1] get(::Nullable{Float64}) at ./nullable.jl:92\n\njulia> get(Nullable(1.0))\n1.0Si el valor no está presente, como podría ser para un Nullable{Float64} se lanzará un error  NullException. La naturaleza del error lanzado de la función get() asegur aque cualquier intento de acceder al valor perdido falle inmediatamente.En los casos para los cuales existe un valor por defecto razonable que podría ser usando cuando el valor de los objetos Nullable se volviera perdido, uno puede proporcionar este valos por defecto como un segundo argumento a get():julia> get(Nullable{Float64}(), 0.0)\n0.0\n\njulia> get(Nullable(1.0), 0.0)\n1.0tip: Tip\n   Asegúrese de que el tipo de valor predeterminado pasado a get () y el del objeto Nullable coincidan para evitar      la inestabilidad de tipo, lo que podría perjudicar el rendimiento. Utilice convert() manualmente si      es necesario."
},

{
    "location": "manual/types.html#Realizando-operaciones-sobre-objetos-Nullable-1",
    "page": "Tipos",
    "title": "Realizando operaciones sobre objetos Nullable",
    "category": "section",
    "text": "Los objetos Nullable representan valores que están posiblemente perdidos, y es posible escribir todo el código usando estos objetos primero comprobando para ver si el valor está perdido con isnull(), y luego realizar la accin apropiada. Sin embargo, hay algunos casos de uso comunes donde el código podría ser ms conciso o claro usando una función de orden superior.La función map toma como argumentos una función f y un valor x de tipo Nullable. Ella produce un Nullable:Si x es un valor perdido, entonces produce un valor perdido;\nSi x tiene un valor, entonces produce un objeto Nullable que contiene f(get(x)) como valor.Esto es útil para realizar operaciones simples sobre valores que podrían estar perdidos si el comportamiento deseado es simplemente propagar hacia adelante los valores perdidos.La función filter toma como argumentos una función predicado p (es decir, una función que devuelve un boolean) y un valor x de tipo Nullable. Ella produce un Nullable:Si x es un valor perdido, entonces produce un valor perdido;\nSi p(get(x)) es true, entoces produce el valor original x;\nSi p(get(x)) es false, entonces produce un valor perdido.De esta forma, filter puede ser considerado como seleccionar sólo valores permisibles, y convertir valores no permisibles en valores perdidos.Mientras que map y filter son útiles para casos específicos, la función de orden superior más útil es, con diferencia, broadcast, que puede manejar una amplia variedad de casos, incluyendo hacer operaciones existentes funcionen y propaguen Nullables. El siguiente ejemplo motivará la necesidad de broadcast. Supongamos que tenemos una funcion que calcula la mayor de las dos raices reales de una ecuacion cuadratica, usando la formula cuadratica:julia> root(a::Real, b::Real, c::Real) = (-b + √(b^2 - 4a*c)) / 2a\nroot (generic function with 1 method)Podemos verificar que el resultado de root (1, -9, 20) es 5.0 como esperamos, ya que 5.0 es la mayor de dos raíces reales de la ecuación cuadrática.Supongamos ahora que queremos encontrar la mayor raíz real de una ecuación cuadrática donde los coeficientes pueden ser valores perdidos. Tener valores perdidos en los conjuntos de datos es una ocurrencia común en los datos del mundo real, por lo que es importante poder tratar con ellos. Pero no podemos encontrar las raíces de una ecuación si no conocemos todos los coeficientes. La mejor solución para esto dependerá del caso de uso particular; quizás deberíamos arrojar un error. Sin embargo, para este ejemplo, asumiremos que la mejor solución es propagar los valores perdidos; es decir, si falta alguna entrada, simplemente producimos una salida faltante.La función broadcast () facilita esta tarea; simplemente podemos pasar la función root que escribimos abroadcast:julia> broadcast(root, Nullable(1), Nullable(-9), Nullable(20))\nNullable{Float64}(5.0)\n\njulia> broadcast(root, Nullable(1), Nullable{Int}(), Nullable{Int}())\nNullable{Float64}()\n\njulia> broadcast(root, Nullable{Int}(), Nullable(-9), Nullable(20))\nNullable{Float64}()Si faltan una o más de las entradas, faltará la salida de broadcast ().Existe un convenio sintáctico especial para la función broadcast() usando la notación punto:julia> root.(Nullable(1), Nullable(-9), Nullable(20))\nNullable{Float64}(5.0)En particular, los operadores aritméticos regulares pueden ser broadcast () convenientemente usando operadores .-prefijo:julia> Nullable(2) ./ Nullable(3) .+ Nullable(1.0)\nNullable{Float64}(1.66667)"
},

{
    "location": "manual/methods.html#",
    "page": "Métodos",
    "title": "Métodos",
    "category": "page",
    "text": ""
},

{
    "location": "manual/methods.html#methods-1",
    "page": "Métodos",
    "title": "Métodos",
    "category": "section",
    "text": "Recordemos de la sección Funciones que una función es un objeto que establece una correspondencia entre una tupla de argumentos y un valor de retorno o lanza una excepción si no puede devolverse el valor apropiado. Para la misma función conceptual es común soy implementada de una forma muy diferente para tipos de argumentos diferentes: sumar dos enteros es distinto de sumar dos valores en punto flotante y ambos son distintos de sumar un entero y 1 punto flotante. A pesar de las diferencias de implementación, éstas operaciones caen todas bajo el concepto general de \"suma\". En consecuencia, en Julia, estos comportamientos pertenecen todos a un solo objeto: la función +.Para facilitar el uso de muchas implementaciones distintas del mismo concepto suavemente, las funciones necesitan no ser definidas de una vez, sino poder ser definidas a trozos proporcionando comportamientos distintos para ciertas combinaciones de tipos de argumentos y cuentas. Llamamos método a la definición de un posible comportamiento para una función. Hasta ahora sólo se han presentado ejemplos de funciones definidas como sólo método, aplicables a todo tipo de argumentos. Sin embargo, las asignaturas de las definiciones de los métodos pueden anotarse para indicar los tipos de los argumentos además de su número, y puede proporcionarse más de una sola definición de método. Cuando una función se aplica a una dupla de argumentos particular, se aplica el método más específico y aplicable a esos argumentos. Por tanto, el comportamiento global de una función es un collage de los comportamientos de sus distintas definiciones de métodos. Si el collage está bien diseñado, incluso aunque las implementaciones de los métodos puedan ser bastante diferentes, el comportamiento exterior de la función pareciera contínuo y consistente.La elección de qué método ejecutar cuando se aplica una función se llama despacho. Julia permite al proceso de despacho elegir qué método de una función llamar basándose en el número de argumentos y en los tipos de todos los argumentos dados a la función. Este mecanismo es diferente al que ocurre en los lenguajes orientados al objeto tradicionales, donde el despacho  se basa solo en el primer argumento, que frecuentemente tiene una sintaxis especial, y que es muchas veces implicado el lugar de ser escrito explícitamente como argumento. [1] Usar todos los argumentos de la función para elegir qué método debería ser invocado es conocido como despacho múltiple. El despacho múltiple es  particularmente útil para código matemático, donde  tiene poco sentido considerar que las operaciones pertenecen a un argumento más que los demás. Más allá de las operaciones matemáticas, sin embargo, el despacho múltiple ha resultado ser un paradigma potente y conveniente para estructurar y organizar los programas.[1]:    En C++ o Java, por ejemplo, en una llamada a un método como obj.meth(arg1,arg2), el objeto     obj \"recibe\" la llamada al método y es pasado implícitamente vía la palabra clave this,      en lugar de con un argumento de método explícito. Cuando el objeto this actual es el      receptor de una llamada a método él puede ser omitido, escribiendo justo meth(arg1,arg2),      con this implicito como objeto receptor."
},

{
    "location": "manual/methods.html#Definiendo-Métodos-1",
    "page": "Métodos",
    "title": "Definiendo Métodos",
    "category": "section",
    "text": "En los ejemplos estudiados hasta ahora, sólo se han definido funciones con un único método que tienen argumentos con los tipos no restringidos. Estas funciones se comporta como las que hay en lenguajes con tipos dinámicos tradicionales. Sin embargo, también se han usado despacho múltiple y métodos sin ser consciente de ello: todas las funciones estándar y operadores de Julia, tal como función +, tiene muchos métodos que definen su comportamiento sobre varias combinaciones posibles número y tipo de argumentos.Cuando se define una función, uno puede opcionalmente restringir los tipos de los parámetros sobre los que se aplica usando el operador de la selección de tipos ::, introducido en la sección Tipos compuestos:julia> f(x::Float64, y::Float64) = 2x + y\nf (generic function with 1 method)Esta definición de función se aplica sólo a llamadas en las que x e y sean ambos valores del tipo Float64:julia> f(2.0, 3.0)\n7.0Aplicar esta definición a otros tipos de argumentos dará como resultado un MethodError:julia> f(2.0, 3)\nERROR: MethodError: no method matching f(::Float64, ::Int64)\nClosest candidates are:\n  f(::Float64, !Matched::Float64) at none:1\n\njulia> f(Float32(2.0), 3.0)\nERROR: MethodError: no method matching f(::Float32, ::Float64)\nClosest candidates are:\n  f(!Matched::Float64, ::Float64) at none:1\n\njulia> f(2.0, \"3.0\")\nERROR: MethodError: no method matching f(::Float64, ::String)\nClosest candidates are:\n  f(::Float64, !Matched::Float64) at none:1\n\njulia> f(\"2.0\", \"3.0\")\nERROR: MethodError: no method matching f(::String, ::String)Como puede comprobarse, los argumentos tienen que ser exactamente del tipo Float64. Otros tipos numéricos tales como Float32 o Int no serán convertidos automáticamente en Float64. Algo parecido sucede con los datos String. Como el tipo Float64 es un tipo concreto y los tipos concretos no pueden tener subclases en Julia, esta definición sólo puede aplicarse a argumentos que sean exactamente del tipo Float64. Esto puede ser útil en ocasiones, sin embargo, para escribir métodos más generales se hace uso de parámetros cuyos tipos sean abstractos:julia> f(x::Number, y::Number) = 2x - y\nf (generic function with 2 methods)\n\njulia> f(2.0, 3)\n1.0Esta definición de método se aplica a cualquier par de argumentos que sean instancias de  Number. Ellas no tienen que ser del mismo tipo, mientras que ambas sean valores numéricos. El problema de manejar tipos numéricos dispares se delega a las operaciones aritméticas en la expresión 2x - y.Para definir una función con múltiples métodos, uno simplemente define la función varías veces, con diferentes números de argumentos y tipos. La primera definición de método para la función crea el objeto función y las definiciones de métodos subsecuentes añaden nuevos métodos al objeto función existente. La definición de método más específica que case con el número los tipos de argumentos será la ejecutada cuando se aplique la función. Por tanto, las dos definiciones de métodos anteriores, considerados juntas, define el comportamiento de la función f sobre todos los padres de instancias del tipo abstracto Number (pero con un comportamiento específico para pares de valores Float64. Si uno de los argumentos es un valor en punto flotante de 64 bits, pero el otro no lo es, entonces el método f(Float64,Float64) no puede ser invocado y se utilizará el método más general f(Number,Number):julia> f(2.0, 3.0)\n7.0\n\njulia> f(2, 3.0)\n1.0\n\njulia> f(2.0, 3)\n1.0\n\njulia> f(2, 3)\n1La definición 2x+y sólo se usa en el primer caso, mientras que la definición 2x-y se usa en los demás. Nunca se realiza conversión automática en los otros: todas las conversiones son no mágicas y completamente exlícitas. En la sección Conversión y promoción, sin embargo, se muestra cómo las aplicaciones inteligentes de tecnología suficientemente avanzada pueden ser indistinguibles de la magic [Clarke61]Para valores no numéricos, ,y para menores de dos argumentos, la función f permanece indefinida, y aplicándola se obtendrá como resultado un MethodError:julia> f(\"foo\", 3)\nERROR: MethodError: no method matching f(::String, ::Int64)\nClosest candidates are:\n  f(!Matched::Number, ::Number) at none:1\n\njulia> f()\nERROR: MethodError: no method matching f()\nClosest candidates are:\n  f(!Matched::Float64, !Matched::Float64) at none:1\n  f(!Matched::Number, !Matched::Number) at none:1Puedes ver fácilmente que métodos existen para una función entrando el propio nombre del objeto en una sesión interactiva:julia> f\nf (generic function with 2 methods)La salida nos dice que f es un objeto función con dos métodos. Para encontrar cuáles son las signaturas de esos métodos, utilizaremos la función methods():julia> methods(f)\n# 2 methods for generic function \"f\":\nf(x::Float64, y::Float64) in Main at none:1\nf(x::Number, y::Number) in Main at none:1que muestra que f tiene dos métodos: uno que toma dos argumentos Float64 y una que toma dos argumentos de tipo Number. También indica el fichero y el número de línea donde los métodos fueron definidos aunque, si los métodos fueron definidos en el REPL, se obtendrá none:1.En ausencia de una declaración de tipo con  :: el tipo de un parámetro de un método es Any por defecto, lo que significa que está sin restricciones ya que todos los valores en Julia son instancias del tipo abstracto Any. Por tanto, podemos definir un método atrapatodo para f tal como:julia> f(x,y) = println(\"Whoa there, Nelly.\")\nf (generic function with 3 methods)\n\njulia> f(\"foo\", 1)\nWhoa there, Nelly.Este atrapatodo es menos específico que cualquier otra posible definición de método para un par de valores de parámetros, por lo que sólo será llamada sobre pares de argumentos a los cuales no pueda aplicarse otra definición de método.Aunque parece un concepto simple, el despacho múltiple sobre los tipos de valores es quizás la característica más potente y central del lenguaje Julia. Las operaciones del núcleo tienen típicamente docenas de metodos:julia> methods(+)\n# 180 methods for generic function \"+\":\n+(x::Bool, z::Complex{Bool}) in Base at complex.jl:224\n+(x::Bool, y::Bool) in Base at bool.jl:89\n+(x::Bool) in Base at bool.jl:86\n+(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96\n+(x::Bool, z::Complex) in Base at complex.jl:231\n+(a::Float16, b::Float16) in Base at float.jl:372\n+(x::Float32, y::Float32) in Base at float.jl:374\n+(x::Float64, y::Float64) in Base at float.jl:375\n+(z::Complex{Bool}, x::Bool) in Base at complex.jl:225\n+(z::Complex{Bool}, x::Real) in Base at complex.jl:239\n+(x::Char, y::Integer) in Base at char.jl:40\n+(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:303\n+(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:303\n+(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:296\n+(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:290\n+(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:258\n+(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:315\n...\n+(a, b, c, xs...) at operators.jl:119El despacho múltiple junto con el sistema de tipos paramétrico flexible dan a Julia su capacidad para expresar de forma abstract algoritmos de alto nivel desacoplados de los detalles de implementación, generando aún código eficiente y especializado para manejar cada caso en tiempo de ejecución."
},

{
    "location": "manual/methods.html#man-ambiguities-1",
    "page": "Métodos",
    "title": "Ambigüedades de Métodos",
    "category": "section",
    "text": "Es posible definir un conjunto de métodos de función tales que no haya un método único más específico aplicable a alguna combinación de argumentos:julia> g(x::Float64, y) = 2x + y\ng (generic function with 1 method)\n\njulia> g(x, y::Float64) = x + 2y\ng (generic function with 2 methods)\n\njulia> g(2.0, 3)\n7.0\n\njulia> g(2, 3.0)\n8.0\n\njulia> g(2.0, 3.0)\nERROR: MethodError: g(::Float64, ::Float64) is ambiguous.\n[...]Aquí, la llamada g(2.0, 3.0) podría ser manejada por los métodos g(Float64, Any) o g(Any, Float64) y ninguno es más específico que el otro. En tales casos, Julia lanza un MethodError en lugar de elegir uno de los métodos arbitrariamente. Podemos obviar las ambigüedades de los métodos especificando un método apropiado para el caso intersección:julia> g(x::Float64, y::Float64) = 2x + 2y\ng (generic function with 3 methods)\n\njulia> g(2.0, 3)\n7.0\n\njulia> g(2, 3.0)\n8.0\n\njulia> g(2.0, 3.0)\n10.0Se recomienda que el método que suprime la ambigüedad sea definido primero, ya que en caso contrario la ambigüedad existe, transitoriamente, hasta que el método más especifico sea definido.En casos ms complejos, resolver ambigüedades de métodos implica un cierto elemento de diseño; este tema se explorará posteriormente."
},

{
    "location": "manual/methods.html#Métodos-paramétricos-1",
    "page": "Métodos",
    "title": "Métodos paramétricos",
    "category": "section",
    "text": "Las definiciones de métodos pueden tener, opcionalmente, parámetros de tipo cualificando la signatura:julia> same_type(x::T, y::T) where {T} = true\nsame_type (generic function with 1 method)\n\njulia> same_type(x,y) = false\nsame_type (generic function with 2 methods)El primer método se aplica cuando ambos argumentos son del mismo tipo concreto, independientemente del tipo que sea, mientras que el segundo actúa como un atrapatodo, cubriendo todos los demás casos. Por tanto, en conjunto, esto define una función booleana que comprueba si dos argumentos son del mismo tipo:julia> same_type(1, 2)\ntrue\n\njulia> same_type(1, 2.0)\nfalse\n\njulia> same_type(1.0, 2.0)\ntrue\n\njulia> same_type(\"foo\", 2.0)\nfalse\n\njulia> same_type(\"foo\", \"bar\")\ntrue\n\njulia> same_type(Int32(1), Int64(2))\nfalseTales definiciones corresponden a métodos cuyas signaturas de tipo son tipos UnionAll (ver tipos UnionAll.Esta clase de definición del comportamiento de una función mediante despacho es bastante común (incluso idiomático) en Julia. Los métodos con parámetros de tipo no están restringidos a ser usados como los tipos de los parámetros: ellos pueden ser usados en cualquier parte donde un palo estaría en la signatura de la función o cuerpo de la función. He aquí un eemplo donde el parámetro de tipo del método T se sa como el parámetro de tipo al tipo paramétrico Vector{T} en la signatura del método:julia> myappend(v::Vector{T}, x::T) where {T} = [v..., x]\nmyappend (generic function with 1 method)\n\njulia> myappend([1,2,3],4)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> myappend([1,2,3],2.5)\nERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)\nClosest candidates are:\n  myappend(::Array{T,1}, !Matched::T) where T at none:1\n\njulia> myappend([1.0,2.0,3.0],4.0)\n4-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n 4.0\n\njulia> myappend([1.0,2.0,3.0],4)\nERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)\nClosest candidates are:\n  myappend(::Array{T,1}, !Matched::T) where T at none:1Como puedes ver, el tipo del elemento añadido tiene que corresponderse con el tipo de elemento del vector al que se está añadiendo, o se lanzará un MethodError.  En el siguiente ejemplo, el parámetro de tipo del método T se usa como valor de retorno:julia> mytypeof(x::T) where {T} = T\nmytypeof (generic function with 1 method)\n\njulia> mytypeof(1)\nInt64\n\njulia> mytypeof(1.0)\nFloat64Así como puedes poner restricciones de subtipo para los parámetros de tipo en declaraciones de tipo (ver Tipos Paramétricos) también puedes restringir los parámetros de tipo de los métodos:julia> same_type_numeric(x::T, y::T) where {T<:Number} = true\nsame_type_numeric (generic function with 1 method)\n\njulia> same_type_numeric(x::Number, y::Number) = false\nsame_type_numeric (generic function with 2 methods)\n\njulia> same_type_numeric(1, 2)\ntrue\n\njulia> same_type_numeric(1, 2.0)\nfalse\n\njulia> same_type_numeric(1.0, 2.0)\ntrue\n\njulia> same_type_numeric(\"foo\", 2.0)\nERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)\nClosest candidates are:\n  same_type_numeric(!Matched::T<:Number, ::T<:Number) where T<:Number at none:1\n  same_type_numeric(!Matched::Number, ::Number) at none:1\n\njulia> same_type_numeric(\"foo\", \"bar\")\nERROR: MethodError: no method matching same_type_numeric(::String, ::String)\n\njulia> same_type_numeric(Int32(1), Int64(2))\nfalseLa función same_type_numeric se comporta como la función same_type descrita antes, pero sólo está definida para pares de números.Los métodos paramétricos permiten la misma sintaxis que las expresiones where usadas para escribir tipos (ver tipos UnionAll). Si hay un único parámetro, las llaves que lo encierran (en where {T}) pueden ser omitidas, aunque suele ser preferible mantenerlas por claridad.Los parámetros múltiples pueden ser separados con comas, por ejemplo where {T, S<:Real}, o escritos usando where anidados, por ejemplo, where S<:Real where T."
},

{
    "location": "manual/methods.html#Redefiniendo-Métodos-1",
    "page": "Métodos",
    "title": "Redefiniendo Métodos",
    "category": "section",
    "text": "Cuando se redefine un método o se añaden nuevos métodos, es importante comprender que estos cambios no tienen efecto inmediatamente. Esto es clave para la capacidad de Julia para inferir estáticamente y compilar código para ejecutar rápido, sin los trucos de JIT y sobrecargas usuales. De hecho, cualquier nueva definición de método no será visible al entorno de ejecución actual, incluyendo tareas e hilos (y cualquier otra función definida con @generated). Comencemos con un ejemplo para ver qué significa esto:julia> function tryeval()\n           @eval newfun() = 1\n           newfun()\n       end\ntryeval (generic function with 1 method)\n\njulia> tryeval()\nERROR: MethodError: no method matching newfun()\nThe applicable method may be too new: running in world age xxxx1, while current world is xxxx2.\nClosest candidates are:\n  newfun() at none:1 (method too new to be called from this world context.)\n in tryeval() at none:1\n ...\n\njulia> newfun()\n1En este ejemplo, observe que la nueva definición para newfun ha sido creada, pero no puede ser llamada inmediatamente. El nuevo global es inmediatamente visible para la función tryeval, para que pueda escribir return newfun (sin paréntesis). ¡Pero ni usted ni ninguna de las personas que llama, ni las funciones a las que llama, etc. puede llamar a esta nueva definición de método!Pero hay una excepción: las llamadas futuras a newfun del REPL funcionan como se esperaba, pudiendo tanto ver como invocar la nueva definición denewfun. Sin embargo, las futuras llamadas a tryeval continuarán viendo la definición denewfun tal como era en la instrucción anterior en REPL, y por lo tanto antes de esa llamada a tryeval.Es posible que desee probar esto para ver cómo funciona.La implementación de este comportamiento es un \"contador de edad mundial\". Este valor monótonamente creciente rastrea cada operación de definición de método. Esto permite describir \"el conjunto de definiciones de métodos visibles para un entorno de tiempo de ejecución dado\" como un solo número, o \"edad mundial\". También permite comparar los métodos disponibles en dos mundos simplemente comparando su valor ordinal. En el ejemplo anterior, vemos que el \"mundo actual\" (en el que existe el método newfun ()) es uno mayor que el \"mundo de tiempo de ejecución\" local de la tarea que se corrigió cuando se inició la ejecución de tryeval.A veces es necesario evitar esto (por ejemplo, si está implementando el REPL anterior). Afortunadamente, hay una solución fácil: llamar a la función usando Base.invokelatest:julia> function tryeval2()\n           @eval newfun2() = 2\n           Base.invokelatest(newfun2)\n       end\ntryeval2 (generic function with 1 method)\n\njulia> tryeval2()\n2Por último, echemos un vistazo a algunos ejemplos más complejos donde esta regñla se pone en funcionamiento. Definamos una función f(x), que inicialmente tiene un método:julia> f(x) = \"original definition\"\nf (generic function with 1 method)Iniciamos algunas operaciones que usan f(x):julia> g(x) = f(x)\ng (generic function with 1 method)\n\njulia> t = @async f(wait()); yield();Ahora añadimos algunos métodos nuevos a f(x):julia> f(x::Int) = \"definition for Int\"\nf (generic function with 2 methods)\n\njulia> f(x::Type{Int}) = \"definition for Type{Int}\"\nf (generic function with 3 methods)Compare cómo difieren estos resultados:julia> f(1)\n\"definition for Int\"\n\njulia> g(1)\n\"definition for Int\"\n\njulia> wait(schedule(t, 1))\n\"original definition\"\n\njulia> t = @async f(wait()); yield();\n\njulia> wait(schedule(t, 1))\n\"definition for Int\""
},

{
    "location": "manual/methods.html#parametrically-constrained-varargs-methods-1",
    "page": "Métodos",
    "title": "Parametrically-constrained Varargs methods",
    "category": "section",
    "text": "Los parámetros de función pueden también ser usados para restringir el número de argumentos que pueden ser proporcionados a una función \"varags\" (ver Funciones Vararg).  La notación Vararg{T,N} se usa para indicar tal restricción. Por ejemplo:julia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)\nbar (generic function with 1 method)\n\njulia> bar(1,2,3)\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)\nClosest candidates are:\n  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1\n\njulia> bar(1,2,3,4)\n(1, 2, (3, 4))\n\njulia> bar(1,2,3,4,5)\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\nClosest candidates are:\n  bar(::Any, ::Any, ::Any, ::Any) at none:1Más útilmente, es posible restringir métodos varargs mediante un parámetro. Por ejemplo:function getindex(A::AbstractArray{T,N}, indexes::Vararg{Number,N}) where {T,N}sería llamado sólo cuando el número de indexes se correspondiera con la dimensionalidad del array."
},

{
    "location": "manual/methods.html#note-on-optional-and-keyword-arguments-1",
    "page": "Métodos",
    "title": "Note on Optional and keyword Arguments",
    "category": "section",
    "text": "Como se menciona brevemente en Funciones, los argumentos opcionales se implementan como sintaxis para múltiples definiciones de métodos. Por ejemplo, esta definición:f(a=1,b=2) = a+2bse traduce a los siguientes tres métodos:f(a,b) = a+2b\nf(a) = f(a,2)\nf() = f(1,2)Esto significa que llamar a f() es equivalente a llamar a f(1,2). En este caso, el resultado es 5, porquef (1,2)invoca el primer método de f anterior. Sin embargo, este no siempre es el caso. Si define un cuarto método que es más especializado para enteros:f(a::Int,b::Int) = a-2bentonces el resultado de ambos f() y f(1,2) es -3. En otras palabras, los argumentos opcionales están vinculados a una función, no a ningún método específico de esa función. Depende de los tipos de argumentos opcionales qué método se invoca. Cuando los argumentos opcionales se definen en términos de una variable global, el tipo de argumento opcional puede incluso cambiar en tiempo de ejecución.Los argumentos de palabra clave se comportan de manera bastante diferente de los argumentos posicionales ordinarios. En particular, no participan en el envío del método. Los métodos se envían basados únicamente en argumentos posicionales, con argumentos de palabra clave procesados después de que se identifica el método de coincidencia."
},

{
    "location": "manual/methods.html#Funciones-como-objetos-1",
    "page": "Métodos",
    "title": "Funciones como objetos",
    "category": "section",
    "text": "Los métodos están asociados con tipos, por lo que es posible hacer algún objeto Julia arbitrario \"invocable\" añadiendo métoos a este tipo (tales objetos \"invocables\" son denominados en ocasiones \"functores\"). Por ejemplo, podemos definir un tipo que almacena los coeficientes de un polinomio, pero que se comporta como una función que evalúa el polinomio:julia> struct Polynomial{R}\n           coeffs::Vector{R}\n       end\n\njulia> function (p::Polynomial)(x)\n           v = p.coeffs[end]\n           for i = (length(p.coeffs)-1):-1:1\n               v = v*x + p.coeffs[i]\n           end\n           return v\n       endNote que la función es especificada por el tipo en lugar de por el nombre. En el cuerpo de la función, p se referira´al objeto que fue llamado. Un Polynomial puede ser usado como sigue:julia> p = Polynomial([1,10,100])\nPolynomial{Int64}([1, 10, 100])\n\njulia> p(3)\n931Este mecanismo es también la clave de cómo los constructores de tipo y cierres (funciones internas que se refieren al entorno que las rodea) funcionan en Julia, lo cual se discute después en el manual."
},

{
    "location": "manual/methods.html#Funciones-Genéricas-Vacías-1",
    "page": "Métodos",
    "title": "Funciones Genéricas Vacías",
    "category": "section",
    "text": "Ocasionalmente, es útil introducir una función genérica sin agregar métodos. Esto se puede usar para separar las definiciones de interfaz de las implementaciones. También se puede hacer con el fin de la documentación o la legibilidad del código. La sintaxis para esto es un bloque de function vacío sin una tupla de argumentos:function emptyfunc\nend"
},

{
    "location": "manual/methods.html#man-method-design-ambiguities-1",
    "page": "Métodos",
    "title": "Diseño de métodos y evitación de ambigüedades",
    "category": "section",
    "text": "El polimorfismo de los métodos de Julia es una de sus características más poderosas, pero explotar este poder puede plantear desafíos de diseño. En particular, en jerarquías de métodos más complejos no es raro que surjan ambigüedades.Arriba se indicó que uno puede resolver ambigüedades comof(x, y::Int) = 1\nf(x::Int, y) = 2definiendo un métodof(x::Int, y::Int) = 3Esta es a menudo la estrategia correcta; sin embargo, hay circunstancias en las que seguir este consejo a ciegas puede ser contraproducente. En particular, cuantos más métodos tenga una función genérica, más posibilidades habrá de ambigüedades. Cuando sus jerarquías de métodos se vuelven más complicadas que este simple ejemplo, puede valer la pena pensar cuidadosamente sobre estrategias alternativas.A continuación, discutimos los desafíos particulares y algunas formas alternativas de resolver dichos problemas."
},

{
    "location": "manual/methods.html#Tuple-and-NTuple-arguments-1",
    "page": "Métodos",
    "title": "Tuple and NTuple arguments",
    "category": "section",
    "text": "Los argumentos Tuple (y NTuple) presentan retos especiales. Por ejemplo,f(x::NTuple{N,Int}) where {N} = 1\nf(x::NTuple{N,Float64}) where {N} = 2son ambiguos debido a la posibilidad de que N == 0: no hay elementos para determinar si se debe invocar a la varianteInt o Float64. Para resolver la ambigüedad, un enfoque es definir un método para la tupla vacía:f(x::Tuple{}) = 3Alternativamente, para todos los métodos excepto uno podemos insistir en que hay al menos un elemento en la tupla:f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback\nf(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64"
},

{
    "location": "manual/methods.html#man-methods-orthogonalize-1",
    "page": "Métodos",
    "title": "Orthogonalice su diseño",
    "category": "section",
    "text": "Cuando tenga la tentación de despachar en dos o más argumentos, considere si una función de \"envoltura\" podría hacer un diseño más simple. Por ejemplo, en lugar de escribir múltiples variantes:f(x::A, y::A) = ...\nf(x::A, y::B) = ...\nf(x::B, y::A) = ...\nf(x::B, y::B) = ...podría considerar definirf(x::A, y::A) = ...\nf(x, y) = f(g(x), g(y))donde g convierte el argumento para escribir A. Esto es un ejemplo muy específico del principio más general de diseño ortogonal, en el que los conceptos separados se alinean a métodos separados. Aquí, g muy probablemente necesitará una definición de repliegueg(x::A) = xUna estrategia relacionada explota promote para llevarx y y a un tipo común:f(x::T, y::T) where {T} = ...\nf(x, y) = f(promote(x, y)...)Un riesgo de este diseño es la posibilidad de que si no hay un método de promoción adecuado para convertir x yy al mismo tipo, el segundo método se repetirá en sí mismo infinitamente y desencadenará un desbordamiento de la pila. La función no exportada Base.promote_noncircular se puede usar como alternativa; cuando la promoción falla, aún arrojará un error, pero uno que falla más rápido con un mensaje de error más específico."
},

{
    "location": "manual/methods.html#Despacho-en-un-argumento-a-la-vez-1",
    "page": "Métodos",
    "title": "Despacho en un argumento a la vez",
    "category": "section",
    "text": "Si necesita despachar en múltiples argumentos, y hay muchos retrocesos con demasiadas combinaciones para que sea práctico definir todas las variantes posibles, entonces considere introducir una \"cascada de nombres\" donde (por ejemplo) despache en el primer argumento y luego llame un método interno:f(x::A, y) = _fA(x, y)\nf(x::B, y) = _fB(x, y)Entonces los métodos internos _fA y_fB pueden enviarse en y sin preocuparse por las ambigüedades entre sí con respecto a x.Tenga en cuenta que esta estrategia tiene al menos una desventaja importante: en muchos casos, no es posible para los usuarios personalizar aún más el comportamiento de f definiendo más especializaciones de su funciónf exportada. En su lugar, tienen que definir especializaciones para sus métodos internos _fA y_fB, y esto borra las líneas entre los métodos exportados e internos."
},

{
    "location": "manual/methods.html#Contenedores-abstractos-y-tipos-de-elementos-1",
    "page": "Métodos",
    "title": "Contenedores abstractos y tipos de elementos",
    "category": "section",
    "text": "Donde sea posible, trate de evitar definir los métodos que se despachan en tipos de elementos específicos de contenedores abstractos. Por ejemplo,-(A::AbstractArray{T}, b::Date) where {T<:Date}genera ambigüedades para cualquiera que defina un método-(A::MyArrayType{T}, b::T) where {T}El mejor enfoque es evitar definir cualquiera de estos métodos: en su lugar, confíe en un método genérico -(A::AbstractArray, b) y haga Asegúrese de que este método se implemente con llamadas genéricas (como similar y -) que hacen lo correcto para cada tipo de contenedor y tipo de elemento por separado. Esta es solo una variante más compleja de los consejos para ortogonalize sus métodos.Cuando este enfoque no es posible, puede valer la pena comenzar un discusión con otros desarrolladores sobre la resolución de la ambigüedad; sólo porque un método se definió primero no necesariamente significa que no puede ser modificado o eliminado Como último recurso, un desarrollador puede definir el método \"tirita\"-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...eso resuelve la ambigüedad por la fuerza bruta."
},

{
    "location": "manual/methods.html#Método-complejo-\"cascadas\"-con-argumentos-predeterminados-1",
    "page": "Métodos",
    "title": "Método complejo \"cascadas\" con argumentos predeterminados",
    "category": "section",
    "text": "Si está definiendo un método \"cascada\" que suministra valores predeterminados, sea cuidado al eliminar cualquier argumento que corresponda al potencial por defecto. Por ejemplo, supongamos que estás escribiendo un filtro digital algoritmo y usted tiene un método que maneja los bordes de la señal mediante la aplicación de relleno:function myfilter(A, kernel, ::Replicate)\n    Apadded = replicate_edges(A, size(kernel))\n    myfilter(Apadded, kernel)  # now perform the \"real\" computation\nendEsto entrará en conflicto con un método que proporciona relleno predeterminado:myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by defaultJuntos, estos dos métodos generan una recursión infinita con 'A' creciendo cada vez más.El mejor diseño sería definir su jerarquía de llamadas de esta manera:struct NoPad end  # indicate that no padding is desired, or that it's already applied\n\nmyfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions\n\nfunction myfilter(A, kernel, ::Replicate)\n    Apadded = replicate_edges(A, size(kernel))\n    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions\nend\n\n# other padding methods go here\n\nfunction myfilter(A, kernel, ::NoPad)\n    # Here's the \"real\" implementation of the core computation\nendNoPad se proporciona en la misma posición de argumento que cualquier otro tipo de relleno, por lo que mantiene la jerarquía de despacho bien organizada y con menor probabilidad de ambigüedades. Además, amplía lo \"público\"interfaz myfilter: un usuario que quiere controlar el relleno explícitamente puede llamar a la variante NoPad directamente.[Clarke61]: Arthur C. Clarke, Profiles of the Future (1961): Clarke's Third Law."
},

{
    "location": "manual/constructors.html#",
    "page": "Constructores",
    "title": "Constructores",
    "category": "page",
    "text": ""
},

{
    "location": "manual/constructors.html#man-constructors-1",
    "page": "Constructores",
    "title": "Constructores",
    "category": "section",
    "text": "Los constructores [1] son funciones que crean nuevos objetos (específicamente instancias de tipos compuestos). En Julia, los objetos también sirven como funciones constructor: ellos crean instancias de sí mismos cuando se aplican a una dupla de argumentos como una función. Esto se mencionó brevemente cuando se habló de tipos compuestos. Por ejemplo:julia> struct Foo\n           bar\n           baz\n       end\n\njulia> foo = Foo(1, 2)\nFoo(1, 2)\n\njulia> foo.bar\n1\n\njulia> foo.baz\n2Para muchos tipos, formar nuevos objetos enlazando valores de campo juntos es todo se necesita para crear instancias. Hay, sin embargo, casos donde se requiere más funcionalidad cuando se crean objetos compuestos. Algunas invariantes deben ser forzadas, bien chequeando argumentos o transformándolos. Las estructuras de datos recursivas, especialmente aquellas que pueden ser auto referenciadas frecuentemente, no pueden construirse limpiamente sin que primero sean creadas e   n un estado incompleto y después sean alteradas programáticamente para ser completadas, como un paso separado de la creación del objeto. Algunas veces, es conveniente ser capaz de construir objetos con menos o diferentes tipos de parámetros que el número de campos que tiene. El sistema Julia para construcción de objetos cubre estos casos y más.[1]: Nomenclature: while the term \"constructor\" generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as \"constructors\". In such situations, it is generally clear from context that the term is used to mean \"constructor method\" rather than \"constructor function\", especially as it is often used in the sense of singling out a particular method of the constructor from all of the others."
},

{
    "location": "manual/constructors.html#Métodos-constructores-externos-1",
    "page": "Constructores",
    "title": "Métodos constructores externos",
    "category": "section",
    "text": "Un constructor es como cualquier otro función en Julia en que es su comportamiento global está definido por el comportamiento combinado de sus métodos. Según esto, se puede añadir funcionalidad a ún constructor simplemente definiendo nuevos métodos. Por ejemplo, supóngase que se desea añadir un método constructor para objetos Foo que tomar un argumento y usa el valor dado para los dos campos que presentan baz y bar. Esto es sencillo::julia> Foo(x) = Foo(x,x)\nFoo\n\njulia> Foo(1)\nFoo(1, 1)Podría también añadirse un constructor Foo sin argumentos que proporciona valores por defecto para los campos bar y baz:julia> Foo() = Foo(0)\nFoo\n\njulia> Foo()\nFoo(0, 0)Aquí, el método constructor sin argumentos llama al método constructor con un argumento, que a su vez llama al método constructor de dos argumentos proporcionado automáticamente. Por razones que se aclararán pronto, los metodos constructor adicionales declarados como métodos formales como éstos se denominan métodos constructores externos. Los métodos constructores externos sólo puede crear una nueva instancia llamando a otro método constructor, tal como los  proporcionados automáticamente por defecto."
},

{
    "location": "manual/constructors.html#Métodos-Constructores-Internos-1",
    "page": "Constructores",
    "title": "Métodos Constructores Internos",
    "category": "section",
    "text": "Aunque los constructores externos resuelven con éxito el problema de proporcionar métodos adicionales para construir objetos, ellos fallan en los otros dos casos de uso mencionados en la introducción este capítulo: forzar invariantes y permitir la construcción de objetos autorreferenciales. Para estos problemas, se necesitan los métodos constructores internos. Un método constructor interno es parecido a uno externo, con dos diferencias:Se declara dentro del bloque de la declaración del tipo, el lugar donde fuera como los métodos normales.\nTiene acceso a una función especial, existente totalmente, llamada new que crea objetos del tipo del bloque.Poner ejemplo, supóngase que uno quiere declarar un tipo que almacene un par de elementos reales, sujetos a la restricción de que el primer número no es mayor que el segundo. Uno podría declararlo así:julia> struct OrderedPair\n           x::Real\n           y::Real\n           OrderedPair(x,y) = x > y ? error(\"out of order\") : new(x,y)\n       end\nAhora sólo pueden construirse objetos OrderedPair tales que x <= y:julia> OrderedPair(1, 2)\nOrderedPair(1, 2)\n\njulia> OrderedPair(2,1)\nERROR: out of order\nStacktrace:\n [1] OrderedPair(::Int64, ::Int64) at ./none:4Si el tipo se declara mutable, se puede acceder y cambiar directamente los valores de campo para violar esta invariante, pero se considera deficiente la interacción con las partes internas de un objeto sin invitación. Usted (u otra persona) también puede proporcionar más métodos constructores externos en cualquier momento posterior, pero una vez que se declara un tipo, no hay forma de agregar más métodos internos de construcción. Como los métodos constructores externos solo pueden crear objetos llamando a otros métodos de construcción, en última instancia, se debe llamar a algún constructor interno para crear un objeto. Esto garantiza que todos los objetos del tipo declarado deben existir mediante una llamada a uno de los métodos de constructor internos proporcionados con el tipo, dando así cierto grado de cumplimiento de las invariantes de un tipo.Si se define cualquier método de constructor interno, no se proporciona ningún método constructor predeterminado: se supone que se ha provisto de todos los constructores internos que necesita. El constructor predeterminado es equivalente a escribir su propio método constructor interno que toma todos los campos del objeto como parámetros (restringidos para ser del tipo correcto, si el campo correspondiente tiene un tipo), y los pasa a new, devolviendo el objeto resultante: julia> struct Foo\n           bar\n           baz\n           Foo(bar,baz) = new(bar,baz)\n       end\nEsta declaración tiene el mismo efecto que la definición anterior del tipo Foo sin un método constructor interno específico. Los siguientes dos tipos son equivalentes (uno con un constructor por defecto y el otro con un constructor explícito):julia> struct T1\n           x::Int64\n       end\n\njulia> struct T2\n           x::Int64\n           T2(x) = new(x)\n       end\n\njulia> T1(1)\nT1(1)\n\njulia> T2(1)\nT2(1)\n\njulia> T1(1.0)\nT1(1)\n\njulia> T2(1.0)\nT2(1)Se considera una buena práctica proporcionar tan pocos constructores internos como sea posible: sólo aquellos que tomen todos los argumentos explícitamente y fuercen la comprobación de errores y las transformaciones esenciales. Los demás constructores proporcionados, que proporcionan valores por defecto o transformaciones auxiliares, deberían proporcionarse como constructores externos que llaman a los internos para hacer el trabajo pesado. Esta situación suele ser bastante natural."
},

{
    "location": "manual/constructors.html#Inicialización-incompleta-1",
    "page": "Constructores",
    "title": "Inicialización incompleta",
    "category": "section",
    "text": "El problema final que aún no se ha resuelto es la construcción de objetos autorreferenciales o, más generalmente, estructuras de datos recursivas. Como la dificultad fundamental puede no ser obvia de inmediato, se explicará brevemente. Considere la siguiente declararción de tipo recursivo:julia> mutable struct SelfReferential\n           obj::SelfReferential\n       end\nEste tipo puede parecer bastante inócuo a menos que uno considere cómo construir una instancia de él. Si a es una instancia de SelfReferential, entonces una segunda instancia b podría crearse mediante la llamada:julia> b = SelfReferential(a)¿Pero cómo se construye la primera instancia cuando no existe ninguna otra instancia para propocionar un valor válido para el campo obj? La única solución es permitir la creación de una instancia de SelfReferential que no esté inicializada por completo, con el campo obj no asignado, y usar esta instancia incompleta como un valor válido que se podcría asignar al campo obj de otra instancia, o incluso al de ella misma.Para permitir la creación de objetos inicializados de forma incompleta, Julia permite que la  función new sea llamada con menos argumentos del número de campos que el objeto tiene, devolviendo un objeto con los campos no especificados sin inicializar. El método constructor interno pues entonces usar el método incompleto, finalizando su inicialización antes de devolverlo. Aquí por ejemplo, se intenta definir el tipo SelfReferental con un constructor interno con cero argumentos que devuelve instancias con sus campos obj apuntando a ellos mismos:julia> mutable struct SelfReferential\n           obj::SelfReferential\n           SelfReferential() = (x = new(); x.obj = x)\n       end\nPodemos verificar que este constructor funciona y construye objetos que son, de hecho, autorreferenciados:julia> x = SelfReferential();\n\njulia> x === x\ntrue\n\njulia> x === x.obj\ntrue\n\njulia> x === x.obj.obj\ntrueAunque se permite crear objetos con campos no inicializados, cualquier objeto a una referencia no inicializada es un eror inmediato:julia> mutable struct Incomplete\n           xx\n           Incomplete() = new()\n       end\n\njulia> z = Incomplete();Aunque se permite crear objetos con campos no inicializados, cualquier objeto a una referencia no inicializada es un eror inmediato:julia> z.xx\nERROR: UndefRefError: access to undefined referenceEsto evita la necesidad de estar comprobando datos null continuamente. Sin embargo, no todos los campos de objetos son referencias. Julia considera algunos tipos Como \"datos planos\", Lo que significa que todos sus datos son auto contenidos y que no referencian otros objetos. Los tipos de datos planos son los tipos primitivos (es decir Int) y las estructuras inmutables de otros tipos de datos planos. Los contenidos iniciales de un tipo de datos planos son indefinidos:julia> struct HasPlain\n           n::Int\n           HasPlain() = new()\n       end\n\njulia> HasPlain()\nHasPlain(438103441441)Los arrays de tipos de datos planos exhiben el mismo comportamiento.Uno puede pasar objetos incompletos a otras funciones desde los constructores internos para  delegar su terminación:julia> mutable struct Lazy\n           xx\n           Lazy(v) = complete_me(new(), v)\n       endComo sucede con los objetos incompletos devueltos desde los constructores, si complete_me o alguno de los métodos que lo llaman intenta acceder al campo xx del objeto Lazy antes de que éste sea inicializado, se lanzará un error de inmediato."
},

{
    "location": "manual/constructors.html#Constructores-paramétricos-1",
    "page": "Constructores",
    "title": "Constructores paramétricos",
    "category": "section",
    "text": "Los tipos paramétricos añaden algunas complicaciones al tema de los constructores. Recuérdese la sección Tipos Paramétricos que por defecto pueden construirse instancias de estos tipos dando  explícitamente los parámetros de tipo o con parámetros de tipo implicados por los tipos de los argumentos dados al constructor. He aquí algunos ejemplos:julia> struct Point{T<:Real}\n           x::T\n           y::T\n       end\n\njulia> Point(1,2) ## implicit T ##\nPoint{Int64}(1, 2)\n\njulia> Point(1.0,2.5) ## implicit T ##\nPoint{Float64}(1.0, 2.5)\n\njulia> Point(1,2.5) ## implicit T ##\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\nClosest candidates are:\n  Point(::T<:Real, !Matched::T<:Real) where T<:Real at none:2\n\njulia> Point{Int64}(1, 2) ## explicit T ##\nPoint{Int64}(1, 2)\n\njulia> Point{Int64}(1.0,2.5) ## explicit T ##\nERROR: InexactError()\nStacktrace:\n [1] convert(::Type{Int64}, ::Float64) at ./float.jl:679\n [2] Point{Int64}(::Float64, ::Float64) at ./none:2\n\njulia> Point{Float64}(1.0, 2.5) ## explicit T ##\nPoint{Float64}(1.0, 2.5)\n\njulia> Point{Float64}(1,2) ## explicit T ##\nPoint{Float64}(1.0, 2.0)Como podemos ver, para las llamadas a constructor con parámetros de tipo explícito, los argumentos se convierten a los tipos implícitos de los campos: Point{Int64}(1,2) funciona, pero Point{Int64}(1.0,2.5) lanza un InexactError cuando 2.5 se convierte a Int64. Cuando el tipo es implicado por los argumentos de la llamada al constructor, como en Point(1,2), entonces los tipos de los argumentos deben concordar para que se pueda determinar T, pero da igual cuáles sean los tipos mientras ambos sean iguales y, además, subclases de Real.Lo que está pasando aquí realmente es que Point, Point{Float64} y Point{Int64} son funcioens constructores diferentes. De hecho, Point{T} es una función constructor distinto para cada tipo T. Sin ningún constructor interno propocionado explícitamente, la declaración del tipo compuesto Point{T<:Real} proporciona automáticamente un constructor interno Point{T} para cada posible ipo T<:Real que se comporta justo como lo hacen los constructores internos no paramétricos por defecto. Ella también proporciona un solo constructor general externo que toma pares de argumentos reales, que deben ser del mismo tipo. Esta provisión automática de constructores es equivalente a la siguiente declaración explícita:julia> struct Point{T<:Real}\n           x::T\n           y::T\n           Point{T}(x,y) where {T<:Real} = new(x,y)\n       end\n\njulia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);Observe que cada definición se parece a la forma de llamada de constructor que maneja. La llamada Point{Int64}(1,2) invocará la definición Point{T}(x, y) dentro del bloque type.La declaración de constructor externo, por otro lado, define un método para el constructor general de Point que sólo se aplica a pares de valores del mismo tipo real. Esta declaración hace que las llamadas al constructor sin parámetros de tipo explícitos, como Punto(1,2) y Punto(1.0,2.5), funcionen. Dado que la declaración del método restringe los argumentos para que sean del mismo tipo, las llamadas como Point(1,2.5), con argumentos de diferentes tipos, dan como resultado errores \"no method\".Supongamos que queremos hacer la llamada a constructor Point(1, 2.5) funcione promocionando el valor entero 1 a punto flotante 1.0. La forma más sencilla de conseguir eso es definir el siguiente método constructor adicional:julia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);Este método usa la función convert() para convertir explícitamente x a Float64 y entonces delegar la construcción al constructor general para el caso de que ambos argumentos sean Float64. Con esta definición de método, lo  que previamente producía un  MethodError ahora crea con éxito un punto de tipo Point{Float64}:julia> Point(1,2.5)\nPoint{Float64}(1.0, 2.5)\n\njulia> typeof(ans)\nPoint{Float64}Sin embargo, otras llamadas similares siguen sin funcionar:julia> Point(1.5,2)\nERROR: MethodError: no method matching Point(::Float64, ::Int64)\nClosest candidates are:\n  Point(::T<:Real, !Matched::T<:Real) where T<:Real at none:1Para una forma mucho más general de hacer que todas estas llamadas funcionen sensiblemente, ver Conversión y promoción. A riesgo de estropear el suspense, podemos revelar aquí que todo lo toma el siguiente método externo para hacer que todas las llamadas al constructor general Point trabajen como uno debería esperar:julia> Point(x::Real, y::Real) = Point(promote(x,y)...);La función promote convierte todos sus argumentos a un tipo común (en este caso, Float64). Con esta definición de método el constructor Point promociona sus argumentos de la misma forma que lo hacen los operadores aritméticos como + y funciona para todos los tipos de números reales:julia> Point(1.5,2)\nPoint{Float64}(1.5, 2.0)\n\njulia> Point(1,1//2)\nPoint{Rational{Int64}}(1//1, 1//2)\n\njulia> Point(1.0,1//2)\nPoint{Float64}(1.0, 0.5)Por tanto, mientras los constructores con parámetros de tipo implícitos proporcionados por defecto en Julia son muy estrictos, es posible hacer que se comporten de una forma más relajada pero sensible con bastante facilidad. Además, como los constructores pueden sacar ventaja de toda la potencia del sistema de tipos, métodos y despacho múltiple, definir comportamientos sofisticados suele ser bastante simple."
},

{
    "location": "manual/constructors.html#Case-Study:-Rational-1",
    "page": "Constructores",
    "title": "Case Study: Rational",
    "category": "section",
    "text": "Quizás la mejor forma de unir todas las piezas es presentar un ejemplo del mundo real de un tipo compuesto paramétrico y sus métodos constructores. Para este fin, he aquí una parte de  rational.jl, que implementa los Números Racionales en Julia:julia> struct OurRational{T<:Integer} <: Real\n           num::T\n           den::T\n           function OurRational{T}(num::T, den::T) where T<:Integer\n               if num == 0 && den == 0\n                    error(\"invalid rational: 0//0\")\n               end\n               g = gcd(den, num)\n               num = div(num, g)\n               den = div(den, g)\n               new(num, den)\n           end\n       end\n\njulia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)\nOurRational\n\njulia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)\nOurRational\n\njulia> OurRational(n::Integer) = OurRational(n,one(n))\nOurRational\n\njulia> //(n::Integer, d::Integer) = OurRational(n,d)\n// (generic function with 1 method)\n\njulia> //(x::OurRational, y::Integer) = x.num // (x.den*y)\n// (generic function with 2 methods)\n\njulia> //(x::Integer, y::OurRational) = (x*y.den) // y.num\n// (generic function with 3 methods)\n\njulia> //(x::Complex, y::Real) = complex(real(x)//y, imag(x)//y)\n// (generic function with 4 methods)\n\njulia> //(x::Real, y::Complex) = x*y'//real(y*y')\n// (generic function with 5 methods)\n\njulia> function //(x::Complex, y::Complex)\n           xy = x*y'\n           yy = real(y*y')\n           complex(real(xy)//yy, imag(xy)//yy)\n       end\n// (generic function with 6 methods)La primera línea – struct OurRational{T<:Integer} <: Real – declara que OurRational toma un parámetro de un subtipo de Integer, aunque él en si mismo es un tipo Real. Las declaraciones de campo num::T y den::T indican que los datos almacenados en un objeto OurRational{T} será un par de enteros de tipo T, uno que representará el numerador y otro el denominador. Ahora las cosas se ponen interesantes. OurRational tiene un solo constructor interno que comprueba que tanto num como den no son cero, y aegura que cada número racional se construye en sus términos mínimos con un denominador no negativo. Esto se consigue dividiendo los valores de numerador y denominador por su máximo común divisor, el cuál se calcula a través de la función gcd. Por último, y como gcd asigna el signo del primer argumento (en este caso den) se garantiza que el denominador ya no sea negativo. Como este es el único constructor interno de Rational, podemos estar seguros de que los objetos de este tipo siempre se construyen en forma normalizada.Rational también proporciona varios métodos constructores externos por conveniencia. El primero es el constructor general \"esándar\", que infiere el tupo del parámetro T a partir del tipo del numerado y denominador que tienen que ser del mismo tipo. El segundo se aplica cuando numerador y denominador tiene tipos distintos: los promociona a un tipo común y entonces delega la construcción al otro constructor externo con argumentos del mismo tipo. En tercer constructor externo convierte valores enteros en racionales proporcionando un denominador de valor 1.Siguiendo las definiciones de constructores externos, tenemos una serie de métodos para el operador // que proporcionan una sintaxis para escribir racionales. Antes de estas definiciones,  //es un operador completamente indefinido con sólo sintaxis y sin significado. Después, se comporta tal y com se describe en Números Racionales –  (su comportamiento completo está descrito en estas pocas líneas). La primera y más básica definición hace a//b construya un  OurRational aplicando el constructor de este tipo sobre a y b cuando ambos son enteros. Cuando uno de los operandos de  // ya es un número racional se construye un nuevo número racional para la razón resultante con una leve diferencia: este comportamiento es igual a la división de un racional entre un entero. Por último, aplicar // a valores complejos enteros crea una instancia de Complex{Rational}, que es un complejo cuyas partes real el imaginaria son racionales:julia> ans = (1 + 2im)//(1 - 2im);\n\njulia> typeof(ans)\nComplex{OurRational{Int64}}\n\njulia> ans <: Complex{OurRational}\nfalsePor tanto, aunque el operador // suela devolver una instancia de OurRational, si uno de sus rgumentos es un complejo entero, devolverá una instancia de Complex{OurRational}. El lector interesado debería considerar la lectura del resto de rational.jl: es corto, autocontenido e implmeenta un tipo básico de Julia al completo."
},

{
    "location": "manual/constructors.html#constructors-and-conversion-1",
    "page": "Constructores",
    "title": "Constructores and Conversión",
    "category": "section",
    "text": "Los constructores T(args) se implementan como otros objetos invocables: los métodos se añaden a sus tipos. El tipo de un tipo es Type por lo que los métodos constructores se almacenan en la tabla de métodos para el tipo Type. Esto significa que se pueden declarar constructores más flexibles, es decir, constructores para tipos abstractos, mediante la definición explícita de métodos para los tipos apropiados.Sin embargo, en algunos casos, uno debería considerar añadir métodos a Base.convert en ougar de definir un constructor, dado que Julia retrocede para llamar a convert() si no se encuentra un constructor que coincida. Por ejemplo, si no existe para constructor para T(args...) = se llamará a Base.convert(::Type{T}, args...)=...convert se usa extensivamente a través de Julia cuando un tipo tenga que ser convertido en otro (por ejemplo, en asignación, ccall, etcetera), y sólo debería ser definido (o exitoso) si la conversión se realiza sin pérdidas. Por ejemplo, convert(Int, 3.0) produce 3, pero convert(Int,3.2) lanza un InexactError. Si desea construirse un constructor para una conversión sin pérdidas de un tipo a otro, probablemente sería mejor definir un método convert.Por otra parte, si el constructro no representa una conversión sin pérdida, o no represnta ningua conversion es mejor dejarlo como constructor en lugar de como un método convert. Por ejemplo, el constructor Array{Int} crea un array cero-dimensional del tipo Int pero no es realmente una conversión de Int a Array."
},

{
    "location": "manual/constructors.html#Constructores-sólo-exteriores-1",
    "page": "Constructores",
    "title": "Constructores sólo exteriores",
    "category": "section",
    "text": "Como se ha visto, un tipo paramétrico típico tiene constructroes internos que son invocados cuano se conocen los tupos de los parámetros, por ejemplo, se aplican a Point{Int}paro no a Point. Opcionalmente, los constructores externos que determinan los parámetros de tipo  pueden ser añadidos automáticamente, por ejemplo, construir un Point{Int} a partir de la llamada Point(1,2). Los constructores externos llaman a los constructores internos para que hagan el trabajo básico de hacer una instancia.  Sin embargo, en algunos caos, uno podría en lugar de eso no proporcionar contructores internos para que los parámetros específicos no puedan ser solicitados manualmente. Por ejemplo, suponga que se define un tipo que almacena un vector con una representaciócn exacta de su suma:julia> struct SummedArray{T<:Number,S<:Number}\n           data::Vector{T}\n           sum::S\n       end\n\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\nSummedArray{Int32,Int32}(Int32[1, 2, 3], 6)El problema es que nosotros queremos que S sea un tipo más grande que T, por lo que podemos sumar muchos elementos con menos pérdida de información. Por ejemplo, cuando T es Int32, querríamos que S fiuera Int64. Por tano queremos evitar un interfaz que permita al usuario construir instanca del tipo SummedArray{Int32,Int32}. Una forma de hacer esto es proporcionar sólo un constructor más exterior para SummedArray.  Esto puede hacerse usando a definicíon de métdo por tipo pero dentro del bloque de definición type para suprimir la generación de bucles por defecto:julia> struct SummedArray{T<:Number,S<:Number}\n           data::Vector{T}\n           sum::S\n           function SummedArray(a::Vector{T}) where T\n               S = widen(T)\n               new{T,S}(a, sum(S, a))\n           end\n       end\n\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\nERROR: MethodError: no method matching SummedArray(::Array{Int32,1}, ::Int32)\nClosest candidates are:\n  SummedArray(::Array{T,1}) where T at none:5El construcror será invocado por la sintaxis SummedArray(a). La sintaxis new{T,S} permite especificar parámetrospara el tipo que se va a construir, es decir, esta llamada devolvera un SummedArray{T, s]. new{T,S} puede usarse en cualquier definicin de constructor, pero por conveniencia los parámtros a new{} se derivan automáticamente del tipo que se está construyendo cuando sea posible."
},

{
    "location": "manual/conversion-and-promotion.html#",
    "page": "Conversión and Promoción",
    "title": "Conversión and Promoción",
    "category": "page",
    "text": ""
},

{
    "location": "manual/conversion-and-promotion.html#conversion-and-promotion-1",
    "page": "Conversión and Promoción",
    "title": "Conversión and Promoción",
    "category": "section",
    "text": "Julia tiene un sistema para promocionar argumento de operaciones matemáticas a un tipo común, que ha sido mencionado en varias secciones, incluyendo números enteros y en punto flotante, operaciones matemáticas y funciones elmentales, Tipos, and Métodos.En esta sección, explicaremos cómo funciona este sistema de promociones, y también cómo extenderlo a nuevos tipos y aplicarlo a funciones junto a operadores matemáticos predefinidos. Tradicionalmente, los lenguajes de programación caen en dos categorías con respecto a la promoción de los argumentos aritméticos:Promoción automática para operadores y tipos artiméticos predefinidos. En la mayoría de los lenguajes, los tipos numéricos predefinidos, cuando se usan como operandos de operaciones aritméticas con una sintaxis infija, tal y  como +, -, *y /, son promocionados automáticamente a un tipo común para producir el resultado esperado. C,  Java, Perl y Pytho,, por nombrar unos pocos, calculan todos la suma 1 + 1.5 correctamente como el valor en punto flotante 2.5, incluso aunque uno de los operandos sea un entero. Estos sistemas son convenientes y diseñados cuidadosamente de forma que generalmente realizan esta labor de forma invisible al programador: a duras penas,  alguien consciente piensa que esta promoción está teniendo lugar cuando escribe una expresión, pero los  compiladores e intérpretes deben realizar la conversión antes de la adición debido a que los valores enteros y en  punto flotante no pueden sumarse tal cual. Por tanto, reglas complejas para tales conversiones automáticas son  una parte inevitable de la especificación e implementación de estos lenguajes.\nNo promoción automática Este campo incluy a Ada y ML (lenguajes tipados estáticamente y muy estrictos). En  estos lenguajes, cada conversión debe ser especificada por el programador de foma explícita. Por tanto, la expresión  de ejemplo 1 + 1.5 daría un error de compilación en ambos lenguajes. En lugar de esta expresión, uno debería  escribir real(1) + 1.5, convirtiendo explícitamente el 1 enteror a un valores en punto flotante antes de realizar la adición. La conversión explícita en todos sitios es tan inconveniente, sin embargo, que incluso Ada tiene algún grado  de conversión automática.: los literales enteros son promocionaods al tipo entero esperado automáticamente, y los literales en punto flotante son promocionados similarmente a los tipos apropiados en punto flotante.En cierto sentido, Julia cae en la categoría \"no promoción automática\": los operadores automáticos son funciones con sintaxis especial, y los argumentos de funciones no son nunca convertidos automáticamente. Sin embargo, uno puede observar que aplicar operaciones matermáticas a una amplia variedad de tipos de argumentos mixtos es justo un caso extremo del despacho múltiple polimórfico (algo que el despacho de Julia y los sistemas de tipos manejan bastante bien. La promoción \"automática\" de operandos matermáticos simplemente emerge como una aplicación especial: Julia viene un reglas de despacho \"atrapa-todo\" predefinidas para los operadores matemáticos, invocadas cuando no existen implementaciones específicas para alguna combinación de tipos de operandos. Estas reglas \"atrapa-todo\" primero promocionan todos los operandos a un tipo común usando reglas de promoción definibles por el usuario, y luego invoca a una implementación especializada del operador en cuestión para los valores resultantes, ahora del mismo tipo. Los tipos definidos por el usuario pueden participar fácilmente en este sistema de promoción definiendo métodos para la conversión hacia o desde otros tipos, y proporcionar un puñado de reglas de promoción que definan a qué tipos deberían ellos promocionarse cuando se mezclan con otros tipos."
},

{
    "location": "manual/conversion-and-promotion.html#Conversión-1",
    "page": "Conversión and Promoción",
    "title": "Conversión",
    "category": "section",
    "text": "La conversión de valores a varios tipos es llevada a cabo mediante la función convert. Esta función suele tomar dos argumentos: el primero es un objeto tipo mientras que el segundo es un valor que hay que convertir a ese tipo; el valor devuelto es el valor convertido a una instancia del tipo dado. La forma más simple de comprender esta función es verla en acción:julia> x = 12\n12\n\njulia> typeof(x)\nInt64\n\njulia> convert(UInt8, x)\n0x0c\n\njulia> typeof(ans)\nUInt8\n\njulia> convert(AbstractFloat, x)\n12.0\n\njulia> typeof(ans)\nFloat64\n\njulia> a = Any[1 2 3; 4 5 6]\n2×3 Array{Any,2}:\n 1  2  3\n 4  5  6\n\njulia> convert(Array{Float64}, a)\n2×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0La conversión no es siempre posible, en cuyo caso se lanza un error no método indicando que convert no sabe cómo realizar la conversión solicitada:julia> convert(AbstractFloat, \"foo\")\nERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat\nThis may have arisen from a call to the constructor AbstractFloat(...),\nsince type constructors fall back to convert methods.Algunos lenguajes consideran que el análisis sintáctico de cadenas como número o el formateo de números a cadenas es una conversión (muchos lengaujes dinámicos realizarán esta conversión por ti automáticamente). Sin embargo, Julia no lo hace. Incluso aunque algunas cadenas puedan ser analizadas como números, la mayoría de las cadenas no son representaciones válidas de números, y sólo un subconjunto muy limitado de ellas lo son. Por tanto, en Julia la función  dedicada parse() debe ser usada para realizar esta operación, haciéndolo más explícito."
},

{
    "location": "manual/conversion-and-promotion.html#Definiendo-nuevas-conversiones-1",
    "page": "Conversión and Promoción",
    "title": "Definiendo nuevas conversiones",
    "category": "section",
    "text": "Para definir nuevas conversiones, simpemente propocionaremos un nuevo método para convert(). Esto es realmente todo lo que hay que hacer. Por ejemplo, el método para convertir un número real a boolean es:convert(::Type{Bool}, x::Real) = x==0 ? false : x==1 ? true : throw(InexactError())El tipo del primer argumento de este método es un tipo singleton, Type{Bool}, , la única instancia del cuál es Bool. Por tanto, este método es sólo invocado cuando el primer argumento es el valor tipo Bool. Nótese la sintaxis usada pora el primer argumento: el nombre del argumento es omitido antes del símbolo :: y sólo se da el tipo. Esta es la sintaxis de Julia para un argumento a función cuyo tipo está especificado pero su valor nunca se utilizará en el cuerpo de la función. En este ejemplo, como el tipo es un singleton, nunca habría una razón para usar su valor dentro del cuerpo. Cuando se invoca el método determina si un valor numérico es verdadero o falso como un boolean, comparándolo con uno y con cero:julia> convert(Bool, 1)\ntrue\n\njulia> convert(Bool, 0)\nfalse\n\njulia> convert(Bool, 1im)\nERROR: InexactError()\nStacktrace:\n [1] convert(::Type{Bool}, ::Complex{Int64}) at ./complex.jl:31\n\njulia> convert(Bool, 0im)\nfalseLas signaturas de método para métodos de conversión están frecuentemente un poco más implicadas que este ejemplo, especialmente para tipos paramétricos. El ejemplo de antes está pensado para ser pedagógico, y no es el comportamiento actual de Julia. He aquí la implementación actual en Julia:convert(::Type{T}, z::Complex) where {T<:Real} =\n    (imag(z) == 0 ? convert(T, real(z)) : throw(InexactError()))"
},

{
    "location": "manual/conversion-and-promotion.html#man-rational-conversion-1",
    "page": "Conversión and Promoción",
    "title": "Caso de estudio: Conversiones de Rational",
    "category": "section",
    "text": "Para continuar con nuestro caso de estudio sobre el tipo Rational de Julia, he aquí las conversiones declaradas en rational.jl, después de la declaración del tipo y sus constructores:convert(::Type{Rational{T}}, x::Rational) where {T<:Integer} = Rational(convert(T,x.num),convert(T,x.den))\nconvert(::Type{Rational{T}}, x::Integer) where {T<:Integer} = Rational(convert(T,x), convert(T,1))\n\nfunction convert(::Type{Rational{T}}, x::AbstractFloat, tol::Real) where T<:Integer\n    if isnan(x); return zero(T)//zero(T); end\n    if isinf(x); return sign(x)//zero(T); end\n    y = x\n    a = d = one(T)\n    b = c = zero(T)\n    while true\n        f = convert(T,round(y)); y -= f\n        a, b, c, d = f*a+c, f*b+d, a, b\n        if y == 0 || abs(a/b-x) <= tol\n            return a//b\n        end\n        y = 1/y\n    end\nend\nconvert(rt::Type{Rational{T}}, x::AbstractFloat) where {T<:Integer} = convert(rt,x,eps(x))\n\nconvert(::Type{T}, x::Rational) where {T<:AbstractFloat} = convert(T,x.num)/convert(T,x.den)\nconvert(::Type{T}, x::Rational) where {T<:Integer} = div(convert(T,x.num),convert(T,x.den))Los cuatro primeros métodos convert proporcionan conversión a tipos racionales. El primer método converte el tipo de reacional a otro tipo de racional convirtiendo el nomerador y el denominador al tipo de entero apropiado. El segundo método hace la misma conversión para enteros tomando el denominado para que sea 1. El tercer método implementa un aalgoritmo estándar para aproximar un número de punto flotante por una razón de enteros dentro de un a tolerancia dada, y el cuarto método lo aplica, usando el epsilo de máquina como el valor dado para elumbral. En general, uno debería tener a//b == convert(Rational{Int64}, a/b).Los dos últimos métodos conversores proporcionan conversiones de tipos racionales a punto flotante y entero. Para convertir a punto flotante, uno simplemente convierte tanto numerador como denominador a punto flotante y luego divide. Para convertir a entero, uno usa el operador div para división entera truncada (redondeo hacia cero)."
},

{
    "location": "manual/conversion-and-promotion.html#Promoción-1",
    "page": "Conversión and Promoción",
    "title": "Promoción",
    "category": "section",
    "text": "La promoción se refiere a convetir valores de tipos mezclados a un solo tipo común. Aunque esto no es estrictamente necesario, se supone generalmente que el tipo común al cuál los valores son convertidos puede representar de forma fidedigna todos los valores. En este sentido, el término \"promoción\" es apropiado ya que los valores son convertidos a un tipo \"mayor\" (es decir, uno que pueda reprsentar todos los valores de entrada en un solo tipo común). Es importante, sin embargo, no confundir esto con los super-tipos orientados a objetos (estructurales), o l nocíon de super-tipos abstractos de Julia: la promoción no tiene nada que ver con la jerarquía de tipos, y todo que ver con convertir entre representaciones alternas. Por ejemplo, aunque cad valor Int32 puede también ser representado como un valor Float64, Int32 no es un subtipo de Float64.La promoción a un tipo mayor común es realizada por Julia mediante la función promote, que toma cualquier número de argumentos, y devuelve un atupla con el mismo número de valores, convertidos a un tipo común, o lanza una excepción si no es posible la promoción. El caso de uso más común para la promoción es convertir argumentos numéricos a un tipo común:julia> promote(1, 2.5)\n(1.0, 2.5)\n\njulia> promote(1, 2.5, 3)\n(1.0, 2.5, 3.0)\n\njulia> promote(2, 3//4)\n(2//1, 3//4)\n\njulia> promote(1, 2.5, 3, 3//4)\n(1.0, 2.5, 3.0, 0.75)\n\njulia> promote(1.5, im)\n(1.5 + 0.0im, 0.0 + 1.0im)\n\njulia> promote(1 + 2im, 3//4)\n(1//1 + 2//1*im, 3//4 + 0//1*im)Los valores en punto flotante son promocionados al mayor de los tipos de los argumento en punto flotante. Los valores enteros son promocionados al mayor de el tamaño de palabra de máquina nativo o dl mayor tipo dde argumento entero. Las mezclas de valores enteros y en punto flotante son promocionados a tipos en punto flotante bastent grandes como para almacenar todos los valores. Los enteros mezclados con racionales promocionan a racionales. Los racionales mezclados con valores en punto flotante son promocionados a valores en punto flotante. Los valores complejos mezclados con valores relaes se promocionan al tipo apropiado de valor complejo.Esto es realmente todo lo que es usar promociones. El resto es sólo cuestión de una aplicación inteligente, siendo la definición de métodos \"atrapa-todo\" para operaciones numéricas tales como las aritméticas +, -, * y / las más típicas aplicaciones inteligentes. He aquí algunas de las definiciones de métodos \"atrapa-todo\" dados en promotion.jl:+(x::Number, y::Number) = +(promote(x,y)...)\n-(x::Number, y::Number) = -(promote(x,y)...)\n*(x::Number, y::Number) = *(promote(x,y)...)\n/(x::Number, y::Number) = /(promote(x,y)...)Estas definiciones de métodos dicen que en la ausencia de reglas más específicas para sumar, restar, multiplicar y dividir pares de valores numéricos, promocionemos los valores a un tipo común y entonces intentemos de nuevo. Este es todo aquí: en ninguna otra parte hay que preocuparse por la promoción a un tipo numérico común para las operaciones aritméticas (ello sucede automáticamente). Hay definiciones de métodos de promoción \"atrapa-todo\" para un número de otras funciones arimtéticas y matemáticas en promotion.jl, pero más allá de eso, difícilmente encontremos ninguna llamada a promote necesaria en la librería estándar de Julia. Los usos más comunes de promote ocurren en los métodos de construcción externos, proporcionados por conveniencia, para permitir llamadas a constructor con tipos mezclados para delegar a un tipo interno con campos promocionados a un  tipo común aproximado. Por ejemplo, recordemos que rational.jl proporciona el siguiente método constructor externo:Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)This allows calls like the following to work:julia> Rational(Int8(15),Int32(-5))\n-3//1\n\njulia> typeof(ans)\nRational{Int32}Para la mayoría de los tipos definidos por usuario, es mejor práctica requerir que los programadores proporcionen los tipos esperados para las funciones constructor explícitamente, pero algunas veces, especialmente para problemas numéricos, puede ser conveniente realizar la conversión de forma automática."
},

{
    "location": "manual/conversion-and-promotion.html#Definiendo-reglas-de-promoción-1",
    "page": "Conversión and Promoción",
    "title": "Definiendo reglas de promoción",
    "category": "section",
    "text": "Aunque uno podría, en principio, definir métodos para la función promote directamente, esto requeriría muchas defniciones redundantes para todas las posibles permutaciones de tipos de argumentos. En lugar de ello, el comportamiento de promote es definido en términos de una función auxiliar denominada promote_rule, para la que uno puede proporcionar métodos. La funci´no promote_rule toma un par de objetos tipo y devuelve otro objeto tipo, tal que instancias de los tipos de argumentos sean promocionadas al tipo retornado. De este modo, definiendo la regla:promote_rule(::Type{Float64}, ::Type{Float32}) = Float64uno declara que cuando se promocionan juntos valores en punto flotante de 32 y de 64 bits, ellos deberían ser promocionados a punto flotante de 64 bits. El tipo de promoción no tiene que ser uno de los tipos de los argumentos. He aquí un par de ejemplos de reglas de promoción que aparecen en la librería estándar de Julia: promote_rule(::Type{UInt8}, ::Type{Int8}) = Int\npromote_rule(::Type{BigInt}, ::Type{Int8}) = BigIntEn el último caso, el tipo de resultado es  BigInt since BigInt ya que éste es el único tipo lo bastante grande como para alojar enteros para aritmética entera de precisión arbitraria. Nótese también que uno no necesita definir dos reglas simétricas promote_rule(::Type{A}, ::Type{B}) y promote_rule(::Type{B}, ::Type{A}) (esta simetría es supuesta por la forma en que promote_rule es utilizada en el proceso de promoción.La función promote_rule se usa com un bloque constructivo para definir una segunda función llamada promote_type la cuál, dado cualquier número de objetos tupo, devuelve el tipo común al cuál esos valores, como argumentos a promote deberían ser promocionados. Por tanto, si uno quiere saber, en ausencia de valores actuales, a qué tipo promocionaría una colección de valores de cierto tipo, uno podría usar promote_type:julia> promote_type(Int8, UInt16)\nInt64Internamente, promote_type se usa dentro de promote para determinar a qué valores argumento tipo deberían ser convertidos tras una promoción. Ell puede, sin embargo, ser útil en sí misma. el lector curioso puede leer el código en promotion.jl, , que define el mecanismo de promoción completo en aproximadamente 35 líneas."
},

{
    "location": "manual/conversion-and-promotion.html#Caso-de-estudio:-promociones-Rational-1",
    "page": "Conversión and Promoción",
    "title": "Caso de estudio: promociones Rational",
    "category": "section",
    "text": "Finalmente, finalizaremos nuestro caso de estudio el tipo de los números racionales en Julia, que hace un uso relativamente sofistidcado del mecanismo de promoción con las siguientes reglas de promoción:promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\npromote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\npromote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)La primera regla dice que promocionar un número racional con algún otro entero promociona a un tipo racional cuyo tipo numerados/denominador es el resultado de la promoción de sus tipos numerador/denoinador con el otro tipo entero. La segunda regla aplica la misma lógic a dos tipos diferentes de números racionales, dando como resultado un racional de la promoción de sus respectivos tipos numerador/denominador. Las reglas tercera y última dictan que promocionar un racional con un punto flotante da como resultado el mismo tipo que promocionar el tipo de numerador/denominador con el float.Este pequeño puñado de reglas de promoción, junto con los métodos de conversión discutidos antes, son suficiente para hacer que los números racionales interoperen completamente y de forma natural con todos los demás tipos numéricos de Julia (enteros, números en punto flotante y números complehjos). Proporcionando métodos de converión apropiadosy reglas de promoción en la misma manera, cualquier tipo numérico definido por el usuario puede interoperar así de naturalmente con los numéricos predefinidos en Julia."
},

{
    "location": "manual/interfaces.html#",
    "page": "Interfaces",
    "title": "Interfaces",
    "category": "page",
    "text": ""
},

{
    "location": "manual/interfaces.html#interfaces-1",
    "page": "Interfaces",
    "title": "Interfaces",
    "category": "section",
    "text": "Un montón de la potencia y extensibilidad de Julia viene de una colección de interfaces informales. Extendiendo unos pocos métodos específicos para que trabajen para un tipo personalizado, los objetos de este tipo no sólo reciben estas funcionalidades, sino que son también capaces de ser usados en otros métodos que han sido escritos para ser construidos genéricamente sobre esos comportamientos."
},

{
    "location": "manual/interfaces.html#man-interface-iteration-1",
    "page": "Interfaces",
    "title": "Iteración",
    "category": "section",
    "text": "Métodos requeridos                                     Breve descripción                                                                    \nstart(iter)   Devuelve el estado inicial de iteración\nnext(iter, state)   Devuelve el ítem actual y pone state en el siguiente\ndone(iter, state)   Comprueba si quedan más ítems\nMétodos opcionales importantes Definiciones por defecto Breve descripción                                                                \niteratorsize(IterType) HasLength() Uno de HasLength(),HasShape(),IsInfinite(), o sizeUnknown(), según convenga\niteratoreltype(IterType) HasEltype() Uno de EltypeUnknown() o HasEltype(), según convenga\neltype(IterType) Any El tipo de los ítems devueltos por next()\nlength(iter) (indefinido) El número de ítems, si es conocido\nsize(iter, [dim...]) (indefinido) El número de ítems en cada dimensión, si es conocidoValor devuelto por iteratorsize(IterType) Métodos requeridos\nHasLength() length(iter)\nHasShape() length(iter)  and size(iter, [dim...])\nIsInfinite() (ninguno)\nSizeUnknown() (ninguno)Valro devuelto por iteratoreltype(IterType) Métodos requeridos\nHasEltype() eltype(IterType)\nEltypeUnknown() (ninguno)La iteración secuencial es implementada mediante los métodos start(), done(), y next(). En lugar de mutar objetos cuando se itera sobre ellos, Julia proporciona estos tres métodos que llevaqn la traza del estado de la iteración externamente al objeto. El método start(iter) devuvelve el estado inicial para un objeto iterable iterd. Este estado se pasa a lo largo de done(iter, state) que chequea si quedan más elementos, y next(iter, state) que devuelve una tupla que contiene el elemento y el estado actuales. El objeto statepuede ser cualquier cosa, y suele ser considerado un detalle de implementación privado al objeto iterable.Cualquier objeto que defina estos tres métodos es iterable y puede ser usado en las muchas funciones que se basan en la iteración. También puede ser usado directamente en un bucle for ya que la sintaxis:for i in iter   # or  \"for i = iter\"\n    # body\nendes traducida por:state = start(iter)\nwhile !done(iter, state)\n    (i, state) = next(iter, state)\n    # body\nendUn ejemplo sencillo es una secuencia iterable de cuadrados de número con una longitd definida:julia> struct Squares\n           count::Int\n       end\n\njulia> Base.start(::Squares) = 1\n\njulia> Base.next(S::Squares, state) = (state*state, state+1)\n\njulia> Base.done(S::Squares, state) = state > S.count\n\njulia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type\n\njulia> Base.length(S::Squares) = S.countCon sólo las definiciones de start, next, y done, el tipo Squares es ya muy poderoso. Podemos iterar sobre todos los elementos:julia> for i in Squares(7)\n           println(i)\n       end\n1\n4\n9\n16\n25\n36\n49Podemos usar muchos de los métodos predefinidos que trabajan con iterables, como in(), mean() y std():julia> 25 in Squares(10)\ntrue\n\njulia> mean(Squares(100))\n3383.5\n\njulia> std(Squares(100))\n3024.355854282583Hay unos pocos más métodos que se pueden extender para dar a Julia más información sobre esta colección iterable. Se sabe que todos los elementos en una secuencia Squares serán Int. Extendiendo el método  eltype() method, se puede proporcionar esta información a Julia y ayudarlo a hacer código más especializado en métodos más complicados. También se sabe el número de elementos de esa secuencia, por loq ue también se pude extender length().Ahora, cuando pedimos a Julia que collect() todos los elementos en un array ella puede preasignar un Vector{Int} en la parte derecha de la expresión, en lugar de ir poniendo a ciegas mediante push!ing cada elemento en un Vector{Any}.julia> collect(Squares(10))' # transposed to save space\n1×10 RowVector{Int64,Array{Int64,1}}:\n 1  4  9  16  25  36  49  64  81  100Aunque podemos confiar en las implementaciones genéricas, podemos también extender métodos específicos donde sepamos que hay un algoritmo más simple. Por ejemplo, he aquí una fórmula para sobreescribir la versión iterativa para una solución más eficiente:julia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)\n\njulia> sum(Squares(1803))\n1955361914Este es un patrón muy común a través de la librería estándar de Julia: un pequeño conjunto de métodos requeridos definen una interfaz informal que permite muchos comportamientos muy atractivos. En algunos casos, los tipos que quieran especializar esos comportamientos extra cuando saben que existe un algoritmo más eficiente que podrán usar en su caso específico."
},

{
    "location": "manual/interfaces.html#Indexación-1",
    "page": "Interfaces",
    "title": "Indexación",
    "category": "section",
    "text": "Métodos a implementar Breve descripción\ngetindex(X, i) X[i], acceso indexado a elemento\nsetindex!(X, v, i) X[i] = v, asignación indexada\nendof(X) El último índice, usado en X[end]Para el iterable Squares anterior, podemos calcular fácilmente el i-ésimo elemento de la secuencia elevándolo al cuadrado. Pordemos exponer esto como una expresión de indexación S[i]. Para optar a ese comportamiento, Squares sólo tieen que definir getindex():julia> function Base.getindex(S::Squares, i::Int)\n           1 <= i <= S.count || throw(BoundsError(S, i))\n           return i*i\n       end\n\njulia> Squares(100)[23]\n529Adicionalmente, para soportar la sintaxis S[end], debemos definir endof() para especificar el último índice válido:julia> Base.endof(S::Squares) = length(S)\n\njulia> Squares(23)[end]\n529Tenga en cuenta, sin embargo, que lo anterior sólo define getindex() con un índice entero. Indexar con cualquier cosa que no sea un Int lanzará un  MethodError diciendo que no había ningún método coincidente. Para soportar la indexación con intervalos o vectores de Ints, se deben escribir métodos separados:julia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]\n\njulia> Base.getindex(S::Squares, I) = [S[i] for i in I]\n\njulia> Squares(10)[[3,4.,5]]\n3-element Array{Int64,1}:\n  9\n 16\n 25Aunque que esto está comenzando a soportar más de las operaciones de indexación soportadas por algunos de los tipos incorporados, todavía hay un buen número de comportamientos ausentes. Esta secuencia Squares está empezando a parecer más y más como un vector, ya que hemos añadido comportamientos a la misma. En lugar de definir todos estos comportamientos nosotros mismos, podemos definirlos oficialmente como un subtipo de un AbstractArray."
},

{
    "location": "manual/interfaces.html#man-interface-array-1",
    "page": "Interfaces",
    "title": "Abstract Arrays",
    "category": "section",
    "text": "Metodos a implementar                                                                   Breve descripción                                                                 \nsize(A)   Devuelve una tupla que contiene las dimensiones de A\ngetindex(A, i::Int)   (if IndexLinear) Linear scalar indexing\ngetindex(A, I::Vararg{Int, N})   (if IndexCartesian, where N = ndims(A)) N-dimensional scalar indexing\nsetindex!(A, v, i::Int)   (if IndexLinear) Scalar indexed assignment\nsetindex!(A, v, I::Vararg{Int, N})   (if IndexCartesian, where N = ndims(A)) N-dimensional scalar indexed assignment\nOptional methods Default definition Brief description\nIndexStyle(::Type) IndexCartesian() Returns either IndexLinear() or IndexCartesian(). See the description below.\ngetindex(A, I...) defined in terms of scalar getindex() Multidimensional and nonscalar indexing\nsetindex!(A, I...) defined in terms of scalar setindex!() Multidimensional and nonscalar indexed assignment\nstart()/next()/done() defined in terms of scalar getindex() Iteration\nlength(A) prod(size(A)) Number of elements\nsimilar(A) similar(A, eltype(A), size(A)) Return a mutable array with the same shape and element type\nsimilar(A, ::Type{S}) similar(A, S, size(A)) Return a mutable array with the same shape and the specified element type\nsimilar(A, dims::NTuple{Int}) similar(A, eltype(A), dims) Return a mutable array with the same element type and size dims\nsimilar(A, ::Type{S}, dims::NTuple{Int}) Array{S}(dims) Return a mutable array with the specified element type and size\nNon-traditional indices Default definition Brief description\nindices(A) map(OneTo, size(A)) Return the AbstractUnitRange of valid indices\nBase.similar(A, ::Type{S}, inds::NTuple{Ind}) similar(A, S, Base.to_shape(inds)) Return a mutable array with the specified indices inds (see below)\nBase.similar(T::Union{Type,Function}, inds) T(Base.to_shape(inds)) Return an array similar to T with the specified indices inds (see below)Si un tipo se define como subtipo de AbstractArray, hereda un conjunto muy grande de comportamientos ricos, incluyendo la iteración y la indexación multidimensional construida sobre el acceso de un solo elemento. Consulte la página de manual sobre arrays y la sección de la biblioteca estándar para más métodos soportados.Una parte clave en la definición de un subtipo de AbstractArray es IndexStyle.Dado que la indexación es una parte tan importante de una matriz y que a menudo se produce en los bucles en caliente, es importante que tanto la indexación y la asignación indexada sean lo más eficientes posible. Las estructuras de datos array se suelen definir de dos maneras: o bien accede de forma más eficaz a sus elementos utilizando sólo un índice (indexación lineal) o  accede intrínsecamente a los elementos con índices especificados para cada dimensión. Estas dos modalidades son identificadas por Julia como IndexLinear() e IndexCartesian(). La conversión de un índice lineal en subíndices de indexación múltiples suele ser muy costosa, por lo que esto proporciona un mecanismo basado en tratos para permitir un código genérico eficiente para todos los tipos de matriz.Esta distinción determina qué métodos de indexación escalar debe definir cada tipo. Los arrays IndexLinear() son sencillos: sólo definen getindex(A::ArrayType, i::Int). Cuando el array se indexa posteriormmente con un conjunto multidimensional de índices, el método de respaldo getindex(A::AbstractArray, I...)() convierte eficientemente los indices en un indice lineal y luego llama al metodo anterior. Los arrays IndexCartesian(), por otra parte,  requieren que se definan métodos para cada dimensionalidad soportada con ndims(A) índices Int. Por ejemplo, el tipo SparseMatrixCSC incorporado sólo admite dos dimensiones, por lo que sólo define getindex(A::SparseMatrixCSC, i::Int, j::Int). Lo mismo sucede para setindex!().Volviendo a la secuencia de cuadrados de arriba, podríamos definirla como un subtipo de un AbstractArray{Int, 1}:julia> struct SquaresVector <: AbstractArray{Int, 1}\n           count::Int\n       end\n\njulia> Base.size(S::SquaresVector) = (S.count,)\n\njulia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()\n\njulia> Base.getindex(S::SquaresVector, i::Int) = i*iNote que es muy importante especificar los dos parámetros del AbstractArray; la primera define el tipo de elemento  eltype(), y la segunda el número de dimensiones ndims(). Este supertipo y sus tres métodos son todo lo que hace falta para que SquaresVector sea un array iterable, indexable y completamente funcional:julia> s = SquaresVector(7)\n7-element SquaresVector:\n  1\n  4\n  9\n 16\n 25\n 36\n 49\n\njulia> s[s .> 20]\n3-element Array{Int64,1}:\n 25\n 36\n 49\n\njulia> s \\ [1 2; 3 4; 5 6; 7 8; 9 10; 11 12; 13 14]\n1×2 Array{Float64,2}:\n 0.305389  0.335329\n\njulia> s ⋅ s # dot(s, s)\n4676Un ejemplo un poco más complicado. definamos nuestro propio tipo array sparse N-dimensional \"de juguete\", construído encima de Dict:julia> struct SparseArray{T,N} <: AbstractArray{T,N}\n           data::Dict{NTuple{N,Int}, T}\n           dims::NTuple{N,Int}\n       end\n\njulia> SparseArray{T}(::Type{T}, dims::Int...) = SparseArray(T, dims);\n\njulia> SparseArray{T,N}(::Type{T}, dims::NTuple{N,Int}) = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);\n\njulia> Base.size(A::SparseArray) = A.dims\n\njulia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)\n\njulia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))\n\njulia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)Observe que se trata de un array  IndexCartesian array, , por lo que debemos definir manualmente getindex() y setindex!() en la dimensionalidad de la matriz. En este caso, a diferencia de en SquaresVector, somos capaces de definir  setindex!() y, en consecuencia, podemos mutar el array:julia> A = SparseArray(Float64, 3, 3)\n3×3 SparseArray{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> fill!(A, 2)\n3×3 SparseArray{Float64,2}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> A[:] = 1:length(A); A\n3×3 SparseArray{Float64,2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0El resultado de la indexación de un AbstractArray puede ser en sí mismo un array (por ejemplo, al indexar por un rango). Los métodos de respaldo de AbstractArray utilizan similar() para asignar un Array del tamaño y tipo de elemento apropiados, que se rellena usando el método de indexación básico descrito anteriormente. Sin embargo, al implementar un wrapper de array, a menudo deseamos que el resultado sea también un wrapper:julia> A[1:2,:]\n2×3 SparseArray{Float64,2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0En este ejemplo esto se logra mediante la definición de Base.similar{T}(A::SparseArray, :: Type{T}, dims::Dims) para crear la matriz wrapped apropiada. (Tenga en cuenta que aunque similar soporta formas de 1 y 2 argumentos, en la mayoría de los casos sólo necesita especializar el formulario de 3 argumentos). Para que esto funcione es importante que SparseArray sea mutable (soporte setindex!). Definir similar(), getindex() y setindex!() para SparseArray también hace posible copiar el array mediante copy():julia> copy(A)\n3×3 SparseArray{Float64,2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0Además de todos los métodos iterables e indexables de arriba, estos tipos también pueden interactuar entre sí y utilizar todos los métodos definidos en la biblioteca estándar para AbstractArrays:julia> A[SquaresVector(3)]\n3-element SparseArray{Float64,1}:\n 1.0\n 4.0\n 9.0\n\njulia> dot(A[:,1],A[:,2])\n32.0Si está definiendo un tipo de array que permite la indexación no tradicional (índices que comienzan en algo distinto de 1), debe especializar indices. También debe especializarse similar para que el argumento dims (normalmente una tupla de tamaños Dims) pueda aceptar objetos AbstractUnitRange, tal vez rango-tipos Ind de su propio diseño. Para obtener más información, vea Arrays con índices personalizados."
},

{
    "location": "manual/modules.html#",
    "page": "Módulos",
    "title": "Módulos",
    "category": "page",
    "text": ""
},

{
    "location": "manual/modules.html#modules-1",
    "page": "Módulos",
    "title": "Módulos",
    "category": "section",
    "text": "Los módulos en Julia son espacio de trabajo de variables separados, es decir, ellos introducen un nuevo ámbito global. Ellos están delimitados sintácticamente dentro de module Nombre ... end. Los módulos nos permiten crear definiciones de nivel superior (o  variables globales) sin preocuparnos sobre conflictos de nombres cuando estamos usando nuestro código con cualquier otro. Dentro de un módulo, podemos controlar qué nombres de otros módulos son visibles (vía importación) y especificar cúales de nuestros nombres queremos que sean públicos (vía exportación). El siguiente ejemplo muestra las principales características de los módulos. No está destinado para ser ejecutado, sino que se muestra para propósitos ilustrativos:module MyModule\nusing Lib\n\nusing BigLib: thing1, thing2\n\nimport Base.show\n\nimportall OtherLib\n\nexport MyType, foo\n\nstruct MyType\n    x\nend\n\nbar(x) = 2x\nfoo(a::MyType) = bar(a.x) + 1\n\nshow(io::IO, a::MyType) = print(io, \"MyType $(a.x)\")\nendNotese que el estilo es no indentar el cuerpo del módulo, ya que esto llevaría a que el fichero completo estuviera indentado.Este módulo define un tipo MyType y dos funciones. Las funciones foo y MyType son exportadas y, en consecuencia, estará disponibles para ser importadas en otros módulos. La función bar es privada a MyModule.La instrucción using Lib significa que un módulo llamado Lib estará disponible para resover nombres cuando se necesite. Cuando se encuentra que una variable no tiene definición en el módulo actual, el sistema la buscará entre las variables exportadas por Lib y la importará si la encuentra allí. Esto significa que todos los usos de esta global dentro del módulo actual resoverá a la definición de esta variable en Lib.La instrucción using BigLib: thing1, thing2 es una abreviación sintáctica de using BigLib.thing1, BigLib.thing2.La palabra clave import soporta la misma sintaxis que using, pero sólo opera sobre un solo nombre cada vez. Ella no añade módulos para ser buscados de la forma que lo hace using. También difiere de using en que las funciones deben ser importandas mediante import para ser extendidas con nuevos métodos.En el jemplo anterior MyModule deseamos añadir un método a la función estándar show, por lo que tenemos que escribir import Base.show. Las funciones cuyos nombres son sólo visibles via using no pueden ser extendidas.La palabra clave importall importa explícitamente todos los nombres exportados por el módulo especificado, con si se hubiera usado import individualmente sobre cada uno de ellos.Una vez que una variable se ha hecho visible vía using o import, un módulo puede no crear su propia variable con el mismo nombre. Las variables importadas son de solo lectura; asignar a una variable global siempre afecta a una variable propiedad del módulo actual, o si no causar un error."
},

{
    "location": "manual/modules.html#Resumen-de-uso-de-los-módulos-1",
    "page": "Módulos",
    "title": "Resumen de uso de los módulos",
    "category": "section",
    "text": "Para cargar un módulo, pueden usarse dos palabras clave principales: using e import. Para comprender sus diferencias, considérese el siguiente ejemplo:module MyModule\n\nexport x, y\n\nx() = \"x\"\ny() = \"y\"\np() = \"p\"\n\nendEn este módulo exportamos las funciones x e y (con la palabra clave export) y también tenemos la función no exportada p. Hay varias diferentes formas de cargar el mósulo y sus funciones internas en el espacio de trabajo actual:Mandato de importación Qué se introduce en el ámbito Disponible para extensión de método\nusing MyModule All exported names (x and y), MyModule.x, MyModule.y and MyModule.p MyModule.x, MyModule.y and MyModule.p\nusing MyModule.x, MyModule.p x and p  \nusing MyModule: x, p x and p  \nimport MyModule MyModule.x, MyModule.y and MyModule.p MyModule.x, MyModule.y and MyModule.p\nimport MyModule.x, MyModule.p x and p x and p\nimport MyModule: x, p x and p x and p\nimportall MyModule All exported names (x and y) x and y"
},

{
    "location": "manual/modules.html#Módulos-y-ficheros-1",
    "page": "Módulos",
    "title": "Módulos y ficheros",
    "category": "section",
    "text": "Los ficheros y los nombres de ficheros no están relacionados con los módulos. Los módulos están asociados sólo con las expresiones module. Uno puede tener múltiples ficheros por módulo, y múltiples módulos por fichero:module Foo\n\ninclude(\"file1.jl\")\ninclude(\"file2.jl\")\n\nendIncluir el mismo código en módulos diferentes porporciona un comportamiento similar a la mezcla. Uno podría usar esto para ejecutar el mismo código con diferentes definiciones base, por ejemplo, código de test ejecutando una versión \"segura\" de algunos operadores:module Normal\ninclude(\"mycode.jl\")\nend\n\nmodule Testing\ninclude(\"safe_operators.jl\")\ninclude(\"mycode.jl\")\nend"
},

{
    "location": "manual/modules.html#Módulos-estándar-1",
    "page": "Módulos",
    "title": "Módulos estándar",
    "category": "section",
    "text": "Hay tres módulos estándar importantes: Main, Core y Base.Main es el módulo de nivel superior, y Julia arranca con Main fijado como módulo actual. Las variables definidas en el prompt van a Main, y whos() lista las variables en Main. Core contiene todos los identificadores considerados predefinidos en el lenguaje, por ejemplo, parte del lenguaje y no librerías. Cada módulo especifica implícitamente using Core, ya que uno no puede hacer nada sin sus definiciones.Base es la librería estándar (los contenidos de base/). Todos los módulos contiene implícitamente using Base, ya que este se necesita en la gran mayoría de los casos."
},

{
    "location": "manual/modules.html#Definiciones-de-nivel-superior-por-defecto-y-módulos-esenciales-(*bare*)-1",
    "page": "Módulos",
    "title": "Definiciones de nivel superior por defecto y módulos esenciales (bare)",
    "category": "section",
    "text": "Además de a using Base, los módulos también contiene automáticamente una definició de la función eval, que evalúa expresiones dentro del contexto de este módulo.Si estas definiciones por defecto no son deseadas, los módulos pueden ser definidos usando la palabra clave baremodule(nota: Core sigue siendo importando, como antes). En términos de baremodule un módulo estándar tiene este aspecto.baremodule Mod\n\nusing Base\n\neval(x) = Core.eval(Mod, x)\neval(m,x) = Core.eval(m, x)\n\n...\n\nend"
},

{
    "location": "manual/modules.html#Caminos-absolutos-y-relativos-de-módulos-1",
    "page": "Módulos",
    "title": "Caminos absolutos y relativos de módulos",
    "category": "section",
    "text": "Dada la instrucción using Foo, el sistema buscará Foo dentro de Main. Si el módulo no existe, el sistema interará un require(\"Foo\") que típicamente da como resultado cargar código desde un paquete instalado. Sin embargo, algunos módulos contienen submódulos, lo que significa que tu algunas veces tienes que acceder a un módulo que no está directamente disponible en Main. Hay dos formas de hacer esto. La primera es usar un camino absoluto, por ejemplo using Base.Sort. El segundo es usar un camino relativo, que hace más fácil importar submódulos del módulo actual o alguno de sus módulos adjuntos:module Parent\n\nmodule Utils\n...\nend\n\nusing .Utils\n\n...\nendAquí, el módulo Parent contiene un submódulo Utils y el código en Parent quiere que el contenido de Utils esté visible. Este se consigue empezando la instrucción using con un punto. Ada punto adicional añadido se muevo hacia arriba niveles adicionales en la jerarquía de módulos. Por ejemplo, using ..Utils buscaría en el módulo que contiene a Parent, no en el propio Padre.Notese que los cualificadores de importación relativos son sólo válidos para las instrucciones uing e import."
},

{
    "location": "manual/modules.html#Caminos-de-ficheros-de-módulo-1",
    "page": "Módulos",
    "title": "Caminos de ficheros de módulo",
    "category": "section",
    "text": "La variable global LOAD_PATH contiene los directorios donde Julia busca módulos cada vez que se invoca require. Esto puede extenderse usandog push!:push!(LOAD_PATH, \"/Path/To/My/Module/\")Aquí, el módulo Parent contiene un submódulo Utils y el código en Parent quiere que el contenido de Utils esté visible. Este se consigue empezando la instrucción using con un punto. Ada punto adicional añadido se muevo hacia arriba niveles adicionales en la jerarquía de módulos. Por ejemplo, using ..Utils buscaría en el módulo que contiene a Parent, no en el propio Padre.Notese que los cualificadores de importación relativos son sólo válidos para las instrucciones uing e import."
},

{
    "location": "manual/modules.html#Caminos-de-ficheros-de-módulo-2",
    "page": "Módulos",
    "title": "Caminos de ficheros de módulo",
    "category": "section",
    "text": "La variable global LOAD_PATH contiene los directorios donde Julia busca módulos cada vez que se invoca require. Esto puede extenderse usandog push!:push!(LOAD_PATH, \"/Path/To/My/Module/\")Poniendo esta instrucción en el ficehro ~/.juliarc.jl extenderemos la variable LOAD_PATH on every Julia startup. en cada arranque de Julia. Alternativamente, el camino de carga de módulos puede ser extendido definiendo la variable de entorno JULIA_LOAD_PATH."
},

{
    "location": "manual/modules.html#Miscelánea-sobre-espacios-de-nombres-1",
    "page": "Módulos",
    "title": "Miscelánea sobre espacios de nombres",
    "category": "section",
    "text": "Si un nombre está cualificado (por ejemplo Base.sin) entonces puede ser accedido incluso aunque no esté exportado. Esto es bastante útil de cara a depuración.También puede haber métodos agregados al usar el nombre calificado como el nombre de la función. Sin embargo, debido a las ambigüedades sintácticas que surgen, si uno desea agregar métodos a una función en un módulo diferente cuyo nombre contiene solo símbolos, tal como un operador (por ejemplo, Base.+), debe usar la notación Base.:+ para referirse a él. Si el operador tiene más de un carácter de longitud, debe rodearlo entre paréntesis, por ejemplo: Base.:(==).Los nombres de macros se escriben con @ en las instrucciones de importación y exportación. Por ejemplo, import Mod.@mac. Las macros en otros módulos pueden ser invocadas como Mod.@mac or @Mod.mac.La sintaxis M.x=y no funciona para asignar una variable global en otro módulo: la asignación global es siempre local a un módulo.Una variable puede estar \"reservada\" por el módulo actual sin asignar a ella declarándola como global x en el nivel superior. Esto puede usarse para prevenir conflictos de nombreas para globales inicializadas después del tiempo de carga."
},

{
    "location": "manual/modules.html#module-initialization-and-precompilation-1",
    "page": "Módulos",
    "title": "Inicialización y precompilación de módulos",
    "category": "section",
    "text": "Los módulos grandes puede necesitar varios segundos para cargar, debido a que ejecutar todas las instrucciones en un módulo implica compilar una gran candidad de código. Julia proporciona la capacidad de crear versiones precompiladas de los módulos para reducir este timepo.Para crear un fichero de módulo precompilado incremental, añadimos __precompile--() al principio de nuestro fichero de módulo (antes de que empiece la palabra module). Esto causará que él sea compilado automáticamente la primera vez que se importe. Alternativamete, podemos llamar a Base.compilecache(modulename).  Los ficheros caché resultantes se almacenarán en Base.LOAD_CACHE_PATH[1]. Posteriormente, el módulo es recompilado automáticamente con import cada vez que alguna de sus dependencia cambia; las dependencias son módulos en imports, la construcción de Julia, los ficheros que incluye, o dependencias explícitas declaradas con include_dependency(path) en el fichero o ficheros de módulo.Para dependencias de fichero, un cambio se determina examinando si el momento de modificación (mtime) de cada fichero cargado por include o añadido explícitamente mediante include_dependency está sin cambios o igual al tiempo de modificaci´no truncado al segundo más cercano (para acomodar sistemas que no pueden copiar mtime con exactitud menor que el segundo). También se tiene en cuenta si el camino al fichero elegido por la lógica de búsqueda en require se corresponde con el camino que había creado el fichero precompilado.También se tiene en cuenta el conjunto de dependencias ya cargadas en el proceso actual y no recompilará esos módulos, incluso si sus ficheros cambian o desaparecen, para evitar crear incompatibilidades entre el sistema en ejecución y la caché precompilada. I queremos tener cambios en la fuente reflejados en el sistema en ejecución, deberíamos llamar a reload(\"Module\") sobre el módulo que hemos cambiado, y cualquier módulo que dependa de él en el cuál quieres ver reflejado el cambio.Precompilar un módulo también recursivamente precompila todo los módulos que son importados allí. Si sabemos que no es seguro precompilar nuestor módulo (por las razones descritas debajo) deberíamos poner __precompile__(false) en el fichero del módulo para causar que Base.compilecache lance un error (y por tanto evite que el módulo sea importado por cualquier otro módulo precompilado.__precompile NO debería ser usado en un módulo a menos que todas sus dependencias estén también usando __precompile__(). Un fallo en hacer esto puede dar como resultado un error en tiempo de ejecución cuando se carga el módulo.Para hacer que nuestro módulo funcione con la precompilación, sin embargo, necesitamos cambiar nuestro módulo para separar explícitamente cualquier paso de inicialización que deba ocurrir en tiempo de ejecución de pasos que pueden ocurrir en tiempo de compilación. Para este propósito, Julia te permite definir una función __init__() en tu módulo que ejecuta cualquier paso de  inicialización que deba tener lugar en tiempo de ejecución. Esta función no será llaada durante la compilación (--ouput-* o __precompile__()). Podemos, por supuesto, llamarla manualmente si es necesario, pero el comportamiento por defecto es asumir que esta función trata con el estado de computación para la máquina local, que no necesita ser (o incluso no debe ser) capturada en la imagen compilada. Ella puede ser llamada después de que el módulo sea cargado en un proceso, incluyendo si el está siendo cargado en una compilación incremental (--output-incremental=yes), pero no si está siendo cargado en un proceso de compilación completo. En particular, si defines un function __init__() en un módulo, entonces Julia llamará a __init__() inmediatamente después de que el módulo se cargue (es decir, mediante import, using o require) en tiempo de ejecución la primera vez (es decir, __init__ sólo es llamado una vez, y sólo después de que todas las instrucciones en el módulo se hayan ejecutado). Como el es llamado después de que el módulo sea importado por completo, los submódulos u otros módulos importandos tienen sus funciones __init__llamadas antes del __init__del módulo contenedor.Dos usos típicos de __init__ son llamar a funciones de inicialización en tiempo de ejecución de librerías externas en C e inicializar constantes globales que implican punteros devueltos por las librerías externas. Por ejemplo, supongamos que estamos llamado a una librería en C libfoo que requiere que llamemos a la función de inicialización foo_init() en tiempo de ejecución. Supongamos que también queremos definir una constante global foo_data_ptr que almacena el valor de retorno de una función void *foo_data() definida por libfoo (esta constante tiene que se inicializada en tiempo de ejecución - no de compilación- debido a que el puntero cambiará de una ejecución a otra). Podríamos conseguir esto definiendo la siguiente función __init__en nuestro módulo:const foo_data_ptr = Ref{Ptr{Void}}(0)\nfunction __init__()\n    ccall((:foo_init, :libfoo), Void, ())\n    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Void}, ())\nendNotese que es perfectamente posible definir un global dentro de la función como __init__; esta es una de las ventajas de usar un lenguaje dinámico. Pero haciéndolo una constante en un ámbito global, podemos asegurar que el tipo es conocido al compilador y le permite generar código mejor optimizado. Obviamente, otros globales de nuestro módulo que dependan de foo_data_ptr también tendrían que ser inicializados en __init__.Las constantes que implican a la mayoría de los objetos Julia que no son producidas por ccall no necesitan se colocadas en __init__: sus definiciones pueden ser precompiladas y cargadas desde la imagen cacheada del módulo. Esto incluye complicados objetos alojados en el montón (heap) como los arrays. Sin embargo, cualquier rutina que devuelva un calor de puntero crudo debe ser llamada en tiempo de ejecución para que la precompilación funcione (los objetos Ptr se convertirán en punteros nulos a menos que sean ocultados dentro de un objeto isbits). Esto incluye los valore de retorno de las funciones Julia cfunction y  pointer.Los tipos diccionario y conjunto, o en general cualquiera que dependa de la salida de un método hash(key), son un caso más difícil. En el caso común de que las claves sean números, cadenas, símbolos, rangos, Expr o composiciones de estos tipos (vía arraysm, tuplas, conjuntos, pares, etc.) son seguros de precompilar. Sin embargo, para otros tipos clave, tales como Function o DataType y tipos genéricos definidos por el usuario donde no se ha definido un método hash el método hash de apoyo depende de la dirección en memoria del objeto (vía su object_id) y por tanto puede cambiar de ejecución a ejecución. Si tienes uno de esos tipos como clave, o no estás seguro, puedes inicializar este diccionario desde dentro de tu función __init__ para mayor seguridad. Alternativamente, puedes usar el tipo diccionario ObjectIdDict, que es especialmente manejado por precompilación por lo que es seguro de inicializar en tiempo de compilación.Cuando se usa precompilación, es importante mantener un claro sentido de la distinción entre la fase de compilación y la de ejecución. En este modo, a menudo será mucho más evidente que Julia es un compilador que permite la ejecución de código arbitrario Julia, no un intérprete independiente que también genera código compilado.Otros escenarios de fallo potencial conocidos incluyen:Contadores globales (por ejemplo, para intentar identificar objetos únicamente). Considere el siguiente código:\nmutable struct UniquedById\n    myid::Int\n    let counter = 0\n        UniquedById() = new(counter += 1)\n    end\nend\nmientras que la intención de este código era dar a cada instancia un id único, el valor del contador es grabado al final de la compilación. Todos los usos posteriores de este módulo compilado incrementalmente empezarán desde el mismo valor de contador.Note que object_if (que trabaja haciendo hash en el puntero a memoria) tieen problemas similares (ver las notas sobre el uso de Dict abajo).One alternative is to store both current_module() and the current counter value, sin embargo, puede ser mejor rediseñar el código para no depender de este estado global.Las colecciones asociativas (tales como Dict y Set) necesitan ser re-hasheadas en __init__ (en el futuro,  puede proporcionarse un mecanismo para registrar un inicializador de función).\nDependiendo de los efectos secundarios de tiempo de compilación que persisten a través del tiempo de carga. El  ejemplo incluye: modificar arrays u otras variables en otros módulos de Julia; mantener manejadores para abrir  archivos o dispositivos; almacenar punteros a otros recursos del sistema (incluyendo memoria);\nCrear \"copias\" accidentales de estado global desde otro módulo, haciendo referencia directamente a él en vez de  a través de su ruta de búsqueda. Por ejemplo, (en el ámbito global).\n#mystdout = Base.STDOUT #= will not work correctly, since this will copy Base.STDOUT into this module =#\n# instead use accessor functions:\ngetstdout() = Base.STDOUT #= best option =#\n# or move the assignment into the runtime:\n__init__() = global mystdout = Base.STDOUT #= also works =#Varias restricciones adicionales se colocan sobre las operaciones que se pueden hacer mientras se precompila el código para ayudar al usuario a evitar otras situaciones de comportamiento incorrecto:Llamar eval para provocar un efecto secundario en otro módulo. Esto también provocará que se emita una advertencia cuando se establece el indicador de precompilación incremental.\nLas sentencias global consts del ámbito local después de __init __() se han iniciado (vea el problema #12010  para los planes de agregar un error para esto).\nReemplazar un módulo (o llamar workspace) es un error de tiempo de ejecución al realizar una  precompilación incremental.Algunos otros puntos a tener en cuenta:Ninguna recarga de código / invalidación de caché se realiza después de que se realizan cambios en los propios  archivos fuente (incluyendo Pkg.update) y no se realiza ninguna limpieza después de Pkg.rm.\nEl comportamiento de compartir la memoria de una matriz reestructurada es ignorado por la precompilación (cada  vista obtiene su propia copia).\nEsperar que el sistema de archivos no cambie entre tiempo de compilación y tiempo de ejecución, p.ej  @__FILE__ / source_path() para encontrar recursos en tiempo de ejecución, o la macro  BinDeps @checked_lib. A veces esto es inevitable. Sin embargo, cuando sea posible, puede ser una buena práctica  copiar recursos en el módulo en tiempo de compilación para que no sea necesario encontrarlos en tiempo de ejecución.\nLos objetos WeakRef y los finalizadores no son manejados correctamente por el serializador (esto se arreglará  en una próxima versión).\nPor lo general, es mejor evitar la captura de referencias a instancias de objetos de metadatos internos como  Method, MethodInstance, MethodTable, TypeMapLevel, TypeMapEntry y campos de esos objetos, ya que esto  puede confundir al serializador y puede no conducir al resultado deseado. No es necesariamente un error hacer esto,  pero sólo tiene que estar preparado para que el sistema intente copiar algunos de ellos y crear una única instancia  única de otros.A veces es útil durante el desarrollo del módulo para desactivar la precompilación incremental. El indicador de línea de comandos --compilecache = {yes | no} le permite activar y desactivar la precompilación del módulo. Cuando se inicia Julia con --compilecache = no se ignoran los módulos serializados en el caché de compilación al cargar módulos y dependencias de módulo. Base.compilecache() todavía se puede llamar manualmente y respetará las directivas __precompile__() para el módulo. El estado de este indicador de línea de comandos se pasa a Pkg.build() para deshabilitar el desencadenamiento automático de precompilación al instalar, actualizar y crear explícitamente paquetes. updating, and explicitly building packages."
},

{
    "location": "manual/documentation.html#",
    "page": "Documentation",
    "title": "Documentation",
    "category": "page",
    "text": ""
},

{
    "location": "manual/documentation.html#documentation-1",
    "page": "Documentation",
    "title": "Documentation",
    "category": "section",
    "text": "Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.The basic syntax is very simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called docstrings). Here is a very simple example:\"Tell whether there are too foo items in the array.\"\nfoo(xs::Array) = ...Documentation is interpreted as Markdown, so you can use indentation and code fences to delimit code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one can construct other string macros and pass them to the @doc macro just as well.Here is a more complex example, still using Markdown:\"\"\"\n    bar(x[, y])\n\nCompute the Bar index between `x` and `y`. If `y` is missing, compute\nthe Bar index between all pairs of columns of `x`.\n\n# Examples\n```julia-repl\njulia> bar([1, 2], [1, 2])\n1\n```\n\"\"\"\nfunction bar(x, y) ...As in the example above, we recommend following some simple conventions when writing documentation:Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.\nThis can be identical to the signature present in the Julia code (like mean(x::AbstractArray)), or a simplified form. Optional arguments should be represented with their default values (i.e. f(x, y=1)) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. f(x[, y]) and f(x[, y[, z]])). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a <keyword arguments> placeholder in the signature (i.e. f(x; <keyword arguments>)), and give the complete list under an # Arguments section (see point 4 below).\nInclude a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.\nThe one-line sentence should use the imperative form (\"Do this\", \"Return that\") instead of the third person (do not write \"Returns the length...\") when documenting functions. It should end with a period. If the meaning of a function cannot be summarized easily, splitting it into separate composable parts could be beneficial (this should not be taken as an absolute requirement for every single case though).\nDo not repeat yourself.\nSince the function name is given by the signature, there is no need to start the documentation with \"The function bar...\": go straight to the point. Similarly, if the signature specifies the types of the arguments, mentioning them in the description is redundant.\nOnly provide an argument list when really necessary.\nFor simple functions, it is often clearer to mention the role of the arguments directly in the description of the function's purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an # Arguments header, with one - bullet for each argument. The list should mention the types and default values (if any) of the arguments:\n\"\"\"\n...\n# Arguments\n- `n::Integer`: the number of elements to compute.\n- `dim::Integer=1`: the dimensions along which to perform the computation.\n...\n\"\"\"\nInclude any code examples in an # Examples section.\nExamples should, whenever possible, be written as doctests. A doctest is a fenced code block (see Code blocks) starting with ```jldoctest and contains any number of julia> prompts together with inputs and expected outputs that mimic the Julia REPL.\nFor example in the following docstring a variable a is defined and the expected result, as printed in a Julia REPL, appears afterwards:\n\"\"\"\nSome nice documentation here.\n\n# Examples\n\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n```\n\"\"\"\nwarning: Warning\nCalling rand and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions.Operating system word size (Int32 or Int64) as well as path separator differences (/ or \\) will also affect the reproducibility of some doctests.Note that whitespace in your doctest is significant! The doctest will fail if you misalign the output of pretty-printing an array, for example.\nYou can then run make -C doc doctest to run all the doctests in the Julia Manual, which will ensure that your example works.\nExamples that are untestable should be written within fenced code blocks starting with ```julia so that they are highlighted correctly in the generated documentation.\ntip: Tip\nWherever possible examples should be self-contained and runnable so that readers are able to try them out without having to include any dependencies.\nUse backticks to identify code and equations.\nJulia identifiers and code excerpts should always appear between backticks ` to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks ``. Use Unicode characters rather than their LaTeX escape sequence, i.e. ``α = 1`` rather than ``\\\\alpha = 1``.\nPlace the starting and ending \"\"\" characters on lines by themselves.\nThat is, write:\n\"\"\"\n...\n\n...\n\"\"\"\nf(x, y) = ...\nrather than:\n\"\"\"...\n\n...\"\"\"\nf(x, y) = ...\nThis makes it more clear where docstrings start and end.\nRespect the line length limit used in the surrounding code.\nDocstrings are edited using the same tools as code. Therefore, the same conventions should apply. It it advised to add line breaks after 92 characters."
},

{
    "location": "manual/documentation.html#Accessing-Documentation-1",
    "page": "Documentation",
    "title": "Accessing Documentation",
    "category": "section",
    "text": "Documentation can be accessed at the REPL or in IJulia by typing ? followed by the name of a function or macro, and pressing Enter. For example,?fft\n?@time\n?r\"\"will bring up docs for the relevant function, macro or string macro respectively. In Juno using Ctrl-J, Ctrl-D will bring up documentation for the object under the cursor."
},

{
    "location": "manual/documentation.html#Functions-and-Methods-1",
    "page": "Documentation",
    "title": "Functions & Methods",
    "category": "section",
    "text": "Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by function bar end). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:\"\"\"\n    *(x, y, z...)\n\nMultiplication operator. `x * y * z *...` calls this function with multiple\narguments, i.e. `*(x, y, z...)`.\n\"\"\"\nfunction *(x, y, z...)\n    # ... [implementation sold separately] ...\nend\n\n\"\"\"\n    *(x::AbstractString, y::AbstractString, z::AbstractString...)\n\nWhen applied to strings, concatenates them.\n\"\"\"\nfunction *(x::AbstractString, y::AbstractString, z::AbstractString...)\n    # ... [insert secret sauce here] ...\nend\n\nhelp?> *\nsearch: * .*\n\n  *(x, y, z...)\n\n  Multiplication operator. x * y * z *... calls this function with multiple\n  arguments, i.e. *(x,y,z...).\n\n  *(x::AbstractString, y::AbstractString, z::AbstractString...)\n\n  When applied to strings, concatenates them.When retrieving documentation for a generic function, the metadata for each method is concatenated with the catdoc function, which can of course be overridden for custom types."
},

{
    "location": "manual/documentation.html#Advanced-Usage-1",
    "page": "Documentation",
    "title": "Advanced Usage",
    "category": "section",
    "text": "The @doc macro associates its first argument with its second in a per-module dictionary called META. By default, documentation is expected to be written in Markdown, and the doc\"\" string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.When used for retrieving documentation, the @doc macro (or equally, the doc function) will search all META dictionaries for metadata relevant to the given object and return it. The returned object (some Markdown content, for example) will by default display itself intelligently. This design also makes it easy to use the doc system in a programmatic way; for example, to re-use documentation between different versions of a function:@doc \"...\" foo!\n@doc (@doc foo!) fooOr for use with Julia's metaprogramming functionality:for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))\n    @eval begin\n        $f(a,b) = $op(a,b)\n    end\nend\n@doc \"`add(a,b)` adds `a` and `b` together\" add\n@doc \"`subtract(a,b)` subtracts `b` from `a`\" subtractDocumentation written in non-toplevel blocks, such as begin, if, for, and let, is added to the documentation system as blocks are evaluated. For example:if VERSION > v\"0.5\"\n    \"...\"\n    f(x) = x\nendwill add documentation to f(x) when the condition is true. Note that even if f(x) goes out of scope at the end of the block, its documentation will remain."
},

{
    "location": "manual/documentation.html#Dynamic-documentation-1",
    "page": "Documentation",
    "title": "Dynamic documentation",
    "category": "section",
    "text": "Sometimes the appropriate documentation for an instance of a type depends on the field values of that instance, rather than just on the type itself. In these cases, you can add a method to Docs.getdoc for your custom type that returns the documentation on a per-instance basis. For instance,struct MyType\n    value::String\nend\n\nDocs.getdoc(t::MyType) = \"Documentation for MyType with value $(t.value)\"\n\nx = MyType(\"x\")\ny = MyType(\"y\")?x will display \"Documentation for MyType with value x\" while ?y will display \"Documentation for MyType with value y\"."
},

{
    "location": "manual/documentation.html#Syntax-Guide-1",
    "page": "Documentation",
    "title": "Syntax Guide",
    "category": "section",
    "text": "A comprehensive overview of all documentable Julia syntax.In the following examples \"...\" is used to illustrate an arbitrary docstring which may be one of the follow four variants and contain arbitrary text:\"...\"\n\ndoc\"...\"\n\n\"\"\"\n...\n\"\"\"\n\ndoc\"\"\"\n...\n\"\"\"@doc_str should only be used when the docstring contains $ or \\ characters that should not be parsed by Julia such as LaTeX syntax or Julia source code examples containing interpolation."
},

{
    "location": "manual/documentation.html#Functions-and-Methods-2",
    "page": "Documentation",
    "title": "Functions and Methods",
    "category": "section",
    "text": "\"...\"\nfunction f end\n\n\"...\"\nfAdds docstring \"...\" to Functionf. The first version is the preferred syntax, however both are equivalent.\"...\"\nf(x) = x\n\n\"...\"\nfunction f(x)\n    x\nend\n\n\"...\"\nf(x)Adds docstring \"...\" to Methodf(::Any).\"...\"\nf(x, y = 1) = x + yAdds docstring \"...\" to two Methods, namely f(::Any) and f(::Any, ::Any)."
},

{
    "location": "manual/documentation.html#Macros-1",
    "page": "Documentation",
    "title": "Macros",
    "category": "section",
    "text": "\"...\"\nmacro m(x) endAdds docstring \"...\" to the @m(::Any) macro definition.\"...\"\n:(@m)Adds docstring \"...\" to the macro named @m."
},

{
    "location": "manual/documentation.html#Types-1",
    "page": "Documentation",
    "title": "Types",
    "category": "section",
    "text": "\"...\"\nabstract type T1 end\n\n\"...\"\nmutable struct T2\n    ...\nend\n\n\"...\"\nstruct T3\n    ...\nendAdds the docstring \"...\" to types T1, T2, and T3.\"...\"\nstruct T\n    \"x\"\n    x\n    \"y\"\n    y\nendAdds docstring \"...\" to type T, \"x\" to field T.x and \"y\" to field T.y. Also applicable to mutable struct types."
},

{
    "location": "manual/documentation.html#Modules-1",
    "page": "Documentation",
    "title": "Modules",
    "category": "section",
    "text": "\"...\"\nmodule M end\n\nmodule M\n\n\"...\"\nM\n\nendAdds docstring \"...\" to the ModuleM. Adding the docstring above the Module is the preferred syntax, however both are equivalent.\"...\"\nbaremodule M\n# ...\nend\n\nbaremodule M\n\nimport Base: @doc\n\n\"...\"\nf(x) = x\n\nendDocumenting a baremodule by placing a docstring above the expression automatically imports @doc into the module. These imports must be done manually when the module expression is not documented. Empty baremodules cannot be documented."
},

{
    "location": "manual/documentation.html#Global-Variables-1",
    "page": "Documentation",
    "title": "Global Variables",
    "category": "section",
    "text": "\"...\"\nconst a = 1\n\n\"...\"\nb = 2\n\n\"...\"\nglobal c = 3Adds docstring \"...\" to the Bindings a, b, and c.Bindings are used to store a reference to a particular Symbol in a Module without storing the referenced value itself.note: Note\nWhen a const definition is only used to define an alias of another definition, such as is the case with the function div and its alias ÷ in Base, do not document the alias and instead document the actual function.If the alias is documented and not the real definition then the docsystem (? mode) will not return the docstring attached to the alias when the real definition is searched for.For example you should write\"...\"\nf(x) = x + 1\nconst alias = frather thanf(x) = x + 1\n\"...\"\nconst alias = f\"...\"\nsymAdds docstring \"...\" to the value associated with sym. Users should prefer documenting sym at it's definition."
},

{
    "location": "manual/documentation.html#Multiple-Objects-1",
    "page": "Documentation",
    "title": "Multiple Objects",
    "category": "section",
    "text": "\"...\"\na, bAdds docstring \"...\" to a and b each of which should be a documentable expression. This syntax is equivalent to\"...\"\na\n\n\"...\"\nbAny number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions f and f!."
},

{
    "location": "manual/documentation.html#Core.@__doc__",
    "page": "Documentation",
    "title": "Core.@__doc__",
    "category": "Macro",
    "text": "@__doc__(ex)\n\nLow-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.\n\nmacro example(f)\n    quote\n        $(f)() = 0\n        @__doc__ $(f)(x) = 1\n        $(f)(x, y) = 2\n    end |> esc\nend\n\n@__doc__ has no effect when a macro that uses it is not documented.\n\n\n\n"
},

{
    "location": "manual/documentation.html#Macro-generated-code-1",
    "page": "Documentation",
    "title": "Macro-generated code",
    "category": "section",
    "text": "\"...\"\n@m expressionAdds docstring \"...\" to expression generated by expanding @m expression. This allows for expressions decorated with @inline, @noinline, @generated, or any other macro to be documented in the same way as undecorated expressions.Macro authors should take note that only macros that generate a single expression will automatically support docstrings. If a macro returns a block containing multiple subexpressions then the subexpression that should be documented must be marked using the @__doc__ macro.The @enum macro makes use of @__doc__ to allow for documenting Enums. Examining it's definition should serve as an example of how to use @__doc__ correctly.Core.@__doc__"
},

{
    "location": "manual/documentation.html#Markdown-syntax-1",
    "page": "Documentation",
    "title": "Markdown syntax",
    "category": "section",
    "text": "The following markdown syntax is supported in Julia."
},

{
    "location": "manual/documentation.html#Inline-elements-1",
    "page": "Documentation",
    "title": "Inline elements",
    "category": "section",
    "text": "Here \"inline\" refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements."
},

{
    "location": "manual/documentation.html#Bold-1",
    "page": "Documentation",
    "title": "Bold",
    "category": "section",
    "text": "Surround words with two asterisks, **, to display the enclosed text in boldface.A paragraph containing a **bold** word."
},

{
    "location": "manual/documentation.html#Italics-1",
    "page": "Documentation",
    "title": "Italics",
    "category": "section",
    "text": "Surround words with one asterisk, *, to display the enclosed text in italics.A paragraph containing an *emphasised* word."
},

{
    "location": "manual/documentation.html#Literals-1",
    "page": "Documentation",
    "title": "Literals",
    "category": "section",
    "text": "Surround text that should be displayed exactly as written with single backticks, ` .A paragraph containing a `literal` word.Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.tip: Tip\nTo include a backtick character within literal text use three backticks rather than one to enclose the text.A paragraph containing a ``` `backtick` character ```.By extension any odd number of backticks may be used to enclose a lesser number of backticks."
},

{
    "location": "manual/documentation.html#\\LaTeX-1",
    "page": "Documentation",
    "title": "LaTeX",
    "category": "section",
    "text": "Surround text that should be displayed as mathematics using LaTeX syntax with double backticks, `` .A paragraph containing some ``\\LaTeX`` markup.tip: Tip\nAs with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within LaTeX markup then two enclosing backticks is sufficient."
},

{
    "location": "manual/documentation.html#Links-1",
    "page": "Documentation",
    "title": "Links",
    "category": "section",
    "text": "Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, [ ], is the name of the link and the text enclosed in parentheses, ( ), is the URL.A paragraph containing a link to [Julia](http://www.julialang.org).It's also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:\"\"\"\n    eigvals!(A,[irange,][vl,][vu]) -> values\n\nSame as [`eigvals`](@ref), but saves space by overwriting the input `A`, instead of creating a copy.\n\"\"\"This will create a link in the generated docs to the eigvals documentation (which has more information about what this function actually does). It's good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.note: Note\nThe above cross referencing is not a Markdown feature, and relies on Documenter.jl, which is used to build base Julia's documentation."
},

{
    "location": "manual/documentation.html#Footnote-references-1",
    "page": "Documentation",
    "title": "Footnote references",
    "category": "section",
    "text": "Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word containing no punctuation.A paragraph containing a numbered footnote [^1] and a named one [^named].note: Note\nThe text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the Footnotes section below."
},

{
    "location": "manual/documentation.html#Toplevel-elements-1",
    "page": "Documentation",
    "title": "Toplevel elements",
    "category": "section",
    "text": "The following elements can be written either at the \"toplevel\" of a document or within another \"toplevel\" element."
},

{
    "location": "manual/documentation.html#Paragraphs-1",
    "page": "Documentation",
    "title": "Paragraphs",
    "category": "section",
    "text": "A paragraph is a block of plain text, possibly containing any number of inline elements defined in the Inline elements section above, with one or more blank lines above and below it.This is a paragraph.\n\nAnd this is *another* one containing some emphasised text.\nA new line, but still part of the same paragraph."
},

{
    "location": "manual/documentation.html#Headers-1",
    "page": "Documentation",
    "title": "Headers",
    "category": "section",
    "text": "A document can be split up into different sections using headers. Headers use the following syntax:# Level One\n## Level Two\n### Level Three\n#### Level Four\n##### Level Five\n###### Level SixA header line can contain any inline syntax in the same way as a paragraph can.tip: Tip\nTry to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics."
},

{
    "location": "manual/documentation.html#Code-blocks-1",
    "page": "Documentation",
    "title": "Code blocks",
    "category": "section",
    "text": "Source code can be displayed as a literal block using an indent of four spaces as shown in the following example.This is a paragraph.\n\n    function func(x)\n        # ...\n    end\n\nAnother paragraph.Additionally, code blocks can be enclosed using triple backticks with an optional \"language\" to specify how a block of code should be highlighted.A code block without a \"language\":\n\n```\nfunction func(x)\n    # ...\nend\n```\n\nand another one with the \"language\" specified as `julia`:\n\n```julia\nfunction func(x)\n    # ...\nend\n```note: Note\n\"Fenced\" code blocks, as shown in the last example, should be prefered over indented code blocks since there is no way to specify what language an indented code block is written in."
},

{
    "location": "manual/documentation.html#Block-quotes-1",
    "page": "Documentation",
    "title": "Block quotes",
    "category": "section",
    "text": "Text from external sources, such as quotations from books or websites, can be quoted using > characters prepended to each line of the quote as follows.Here's a quote:\n\n> Julia is a high-level, high-performance dynamic programming language for\n> technical computing, with syntax that is familiar to users of other\n> technical computing environments.Note that a single space must appear after the > character on each line. Quoted blocks may themselves contain other toplevel or inline elements."
},

{
    "location": "manual/documentation.html#Images-1",
    "page": "Documentation",
    "title": "Images",
    "category": "section",
    "text": "The syntax for images is similar to the link syntax mentioned above. Prepending a ! character to a link will display an image from the specified URL rather than a link to it.![alternative text](link/to/image.png)"
},

{
    "location": "manual/documentation.html#Lists-1",
    "page": "Documentation",
    "title": "Lists",
    "category": "section",
    "text": "Unordered lists can be written by prepending each item in a list with either *, +, or -.A list of items:\n\n  * item one\n  * item two\n  * item threeNote the two spaces before each * and the single space after each one.Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.Another list:\n\n  * item one\n\n  * item two\n\n    ```\n    f(x) = x\n    ```\n\n  * And a sublist:\n\n      + sub-item one\n      + sub-item twonote: Note\nThe contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the i in item two.Ordered lists are written by replacing the \"bullet\" character, either *, +, or -, with a positive integer followed by either . or ).Two ordered lists:\n\n 1. item one\n 2. item two\n 3. item three\n\n 5) item five\n 6) item six\n 7) item sevenAn ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements."
},

{
    "location": "manual/documentation.html#Display-equations-1",
    "page": "Documentation",
    "title": "Display equations",
    "category": "section",
    "text": "Large LaTeX equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the \"language\" math as in the example below.```math\nf(a) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} (\\alpha+R\\cos(\\theta))d\\theta\n```"
},

{
    "location": "manual/documentation.html#Footnotes-1",
    "page": "Documentation",
    "title": "Footnotes",
    "category": "section",
    "text": "This syntax is paired with the inline syntax for Footnote references. Make sure to read that section as well.Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the : character that is appended to the footnote label.[^1]: Numbered footnote text.\n\n[^note]:\n\n    Named footnote text containing several toplevel elements.\n\n      * item one\n      * item two\n      * item three\n\n    ```julia\n    function func(x)\n        # ...\n    end\n    ```note: Note\nNo checks are done during parsing to make sure that all footnote references have matching footnotes."
},

{
    "location": "manual/documentation.html#Horizontal-rules-1",
    "page": "Documentation",
    "title": "Horizontal rules",
    "category": "section",
    "text": "The equivalent of an <hr> HTML tag can be written using the following syntax:Text above the line.\n\n---\n\nAnd text below the line."
},

{
    "location": "manual/documentation.html#Tables-1",
    "page": "Documentation",
    "title": "Tables",
    "category": "section",
    "text": "Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above – only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.| Column One | Column Two | Column Three |\n|:---------- | ---------- |:------------:|\n| Row `1`    | Column `2` |              |\n| *Row* 2    | **Row** 2  | Column ``3`` |note: Note\nAs illustrated in the above example each column of | characters must be aligned vertically.A : character on either end of a column's header separator (the row containing - characters) specifies whether the row is left-aligned, right-aligned, or (when : appears on both ends) center-aligned. Providing no : characters will default to right-aligning the column."
},

{
    "location": "manual/documentation.html#Admonitions-1",
    "page": "Documentation",
    "title": "Admonitions",
    "category": "section",
    "text": "Specially formatted blocks with titles such as \"Notes\", \"Warning\", or \"Tips\" are known as admonitions and are used when some part of a document needs special attention. They can be defined using the following !!! syntax:!!! note\n\n    This is the content of the note.\n\n!!! warning \"Beware!\"\n\n    And this is another one.\n\n    This warning admonition has a custom title: `\"Beware!\"`.Admonitions, like most other toplevel elements, can contain other toplevel elements. When no title text, specified after the admonition type in double quotes, is included then the title used will be the type of the block, i.e. \"Note\" in the case of the note admonition."
},

{
    "location": "manual/documentation.html#Markdown-Syntax-Extensions-1",
    "page": "Documentation",
    "title": "Markdown Syntax Extensions",
    "category": "section",
    "text": "Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual show methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary."
},

{
    "location": "manual/metaprogramming.html#",
    "page": "Metaprogramación",
    "title": "Metaprogramación",
    "category": "page",
    "text": ""
},

{
    "location": "manual/metaprogramming.html#metaprogramming-1",
    "page": "Metaprogramación",
    "title": "Metaprogramación",
    "category": "section",
    "text": "El legado más fuerte de Lisp en el lenguaje Julia es su soporte a la metaprogramación. Al igual que Lisp, Julia representa su propio código como una estructura de datos del propio lenguaje. Dado que el código está representado por objetos que pueden ser creados y manipulados desde dentro del lenguaje, es posible que un programa pueda transformar y generar su propio código. Esto permite una sofisticada generación de código sin pasos de construcción adicionales, y también permite las verdaderas macros de estilo Lisp que operan a nivel de los árboles sintácticos abstractos. En contraste, los sistemas de preprocesador \"macro\" como el de C y C++, realizan la manipulación y sustitución textual antes de que se realice cualquier análisis o interpretación real. Debido a que todos los tipos de datos y código en Julia están representados por las estructuras de datos Julia, hay disponibles poderosas capacidades de reflexión están disponibles para explorar las características internas de un programa y sus tipos al igual que cualquier otro dato."
},

{
    "location": "manual/metaprogramming.html#Representación-de-programas-1",
    "page": "Metaprogramación",
    "title": "Representación de programas",
    "category": "section",
    "text": "Cada programa en Julia comienza su vida como una cadena:julia> prog = \"1 + 1\"\n\"1 + 1\"¿Qué sucede después?El siguiente paso es analizar sintácticamente cada cadena en un objeto denominado una expresión, representado por el tipo Expr de Julia:julia> ex1 = parse(prog)\n:(1 + 1)\n\njulia> typeof(ex1)\nExprLos objetos Expr contienen trdoses partes:Un Symbol identificando la clase de expresión. Un símbolo es un identificador de cadena internado (más información a continuación).julia> ex1.head\n:callLos argumentos de expresión, que pueden ser símbolos, otras expresiones o valores literales:julia> ex1.args\n3-element Array{Any,1}:\n  :+\n 1\n 1Las expresiones pueden también ser construidas directamente en notación prefija:julia> ex2 = Expr(:call, :+, 1, 1)\n:(1 + 1)Las dos expresiones construidas antes (mediante análisis sintáctico y mediante construcción directa) son equivalentes:julia> ex1 == ex2\ntrueEl punto clave aquí es que el código Julia se representa internamente como una estructura de datos que es accesible desde el propio lenguaje.La función dump() proporciona una visualización indentada y anotada de objetos Expr:julia> dump(ex2)\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Int64 1\n    3: Int64 1\n  typ: AnyLos objetos Expr puede ser también anidados:julia> ex3 = parse(\"(4 + 4) / 2\")\n:((4 + 4) / 2)Otra forma de ver expresiones es con Meta.show_sexpr, que muestra la expresión-S de una Expr dada, que puede resultar muy familiar a los usuarios de Lisp. He aquí un ejemplo que visualiza una expresión (Expr) anidada:julia> Meta.show_sexpr(ex3)\n(:call, :/, (:call, :+, 4, 4), 2)"
},

{
    "location": "manual/metaprogramming.html#Simbolos-1",
    "page": "Metaprogramación",
    "title": "Simbolos",
    "category": "section",
    "text": "El carácter : tiene dos propósitos sintácticos en Julia. La primera forma crea un símbolo (Symbol), una cadena internada usada como un bloque constructivo de expresiones:julia> :foo\n:foo\n\njulia> typeof(ans)\nSymbolEl constructor Symbol toma cualquier número de argumentos y crea un símbolo concatenando sus representaciones de cadena juntas:julia> :foo == Symbol(\"foo\")\ntrue\n\njulia> Symbol(\"func\",10)\n:func10\n\njulia> Symbol(:var,'_',\"sym\")\n:var_symEn el contexto de una expresión, los símbolos se utilizan para indicar el acceso a variables; Cuando se evalúa una expresión, se sustituye un símbolo por el valor asociado a ese símbolo en el ámbito apropiado.A veces son necesarios paréntesis adicionales alrededor del argumento a: para evitar la ambigüedad en el análisis:julia> :(:)\n:(:)\n\njulia> :(::)\n:(::)"
},

{
    "location": "manual/metaprogramming.html#Expresiones-y-evaluación-1",
    "page": "Metaprogramación",
    "title": "Expresiones y evaluación",
    "category": "section",
    "text": ""
},

{
    "location": "manual/metaprogramming.html#Citación-1",
    "page": "Metaprogramación",
    "title": "Citación",
    "category": "section",
    "text": "El segundo propósito sintáctico del carácter : es crear objetos expresión sin utilizar el constructor Expr explícito. Esto se conoce como citación. El carácter :, seguido de pares de paréntesis alrededor de una sola declaración de código Julia, produce un objeto Expr basado en el código incluido. He aquí un ejemplo de la forma corta utilizada para citar una expresión aritmética:julia> ex = :(a+b*c+1)\n:(a + b * c + 1)\n\njulia> typeof(ex)\nExpr(para ver la estructura de esta expresión, podemos usar ex.head y ex.args o dump()como antes)Nótese que pueden construirse expresiones equivalentes usando parse() o la forma directa Expr:julia>      :(a + b*c + 1)  ==\n       parse(\"a + b*c + 1\") ==\n       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)\ntrueLas expresiones proporcionadas por el analizador sólo suelen tener símbolos, otras expresiones y valores literales como sus args, mientras que las expresiones construidas por el código Julia pueden tener valores de ejecución arbitrarios sin formas literales como args. En este ejemplo específico, + y a son símbolos, *(b,c) es una subexpresión, y 1 un entero literal de 64 bits.Hay una segunda forma sintáctica de citar para expresiones múltiples: bloques de código encerrados en quote ... end. Note que esta forma introduce elementos QuoteNode al árbol de expresión que deben considerarse cuando se manipule directamente un árbol de expresiones generado a partir de bloques quote. Para otros propósitos, los bloques :(...) y quote...end se tratan de forma idéntica.julia> ex = quote\n           x = 1\n           y = 2\n           x + y\n       end\nquote\n    #= none:2 =#\n    x = 1\n    #= none:3 =#\n    y = 2\n    #= none:4 =#\n    x + y\nend\n\njulia> typeof(ex)\nExpr"
},

{
    "location": "manual/metaprogramming.html#Interpolación-1",
    "page": "Metaprogramación",
    "title": "Interpolación",
    "category": "section",
    "text": "La construcción directa de objetos Expr con valores como argumentos es potente, pero los constructores objetos Expr pueden ser tediosos comparados con la sintaxis \"normal\" de Julia. Como alternativa, Julia permite \"empalme\" o interpolación de literales o expresiones en expresiones citadas. La interpolación se indica con el prefijo $.En este ejemplo el valor literal de a es interpolado:julia> a = 1;\n\njulia> ex = :($a + b)\n:(1 + b)Interpolar en una expresión no citada (quoted) no se admite y causará un error en tiempo de compilación: julia> $a + b\nERROR: unsupported or misplaced expression $\n ...En este ejemplo, la tupla (1,2,3) es interpolada como una expresión en un test condicional:julia> ex = :(a in $:((1,2,3)) )\n:(a in (1, 2, 3))Interpolar símbolos en una expresión anidada requiere encerrar cada símbolo en un bloque de cita que lo encierre:julia> :( :a in $( :(:a + :b) ) )\n                   ^^^^^^^^^^\n                   quoted inner expressionEl uso de $ para la interpolación de la expresión recuerda intencionalmente a la interpolación de cadenas y a la interpolación de mandatos. La interpolación de expresiones permite la construcción programática conveniente y legible de expresiones Julia complejas."
},

{
    "location": "manual/metaprogramming.html#[eval()](@ref)-and-efectos-1",
    "page": "Metaprogramación",
    "title": "eval() and efectos",
    "category": "section",
    "text": "Dado un objeto expresión, uno puede causar que Julia lo evalúe (ejecute) en un ámbito global usando eval():julia> :(1 + 2)\n:(1 + 2)\n\njulia> eval(ans)\n3\n\njulia> ex = :(a + b)\n:(a + b)\n\njulia> eval(ex)\nERROR: UndefVarError: b not defined\n[...]\n\njulia> a = 1; b = 2;\n\njulia> eval(ex)\n3Cada módulo tiene su propia función eval() que evalúa expresiones en su ámbito global. Las expresiones pasadas a eval() no están limitadas a valores de retorno (ellas también pueden tener efetos colaterales que alteren el estado del entorno del módulo que las encierra:julia> ex = :(x = 1)\n:(x = 1)\n\njulia> x\nERROR: UndefVarError: x not defined\n\njulia> eval(ex)\n1\n\njulia> x\n1Aquí, la evaluación de un objeto expresión causa que se asigne un valor a la variable global x.Como las expresiones no son más que objetos Expr que pueden ser construidos programáticamente y después evaluados, es posible generar dinámicamente código arbitrario que pueda ser ejecutado luego mediante eval(). He aquí Since expressions are just Expr objects which can be constructed programmatically and then evaluated, un ejemplo sencillo:julia> a = 1;\n\njulia> ex = Expr(:call, :+, a, :b)\n:(1 + b)\n\njulia> a = 0; b = 2;\n\njulia> eval(ex)\n3El valor de a se ha usado para construir la expresión ex que aplica la función + al valor 1 y a la variable b. Note la distinción importante entre la forma en que se usan las variables a y b:El valor de la variable a se utiliza como valor inmediato en la expresión en el tiempo de construcción de la  expresión. Por lo tanto, una vez que la expresión es evaluada, el valor de a ya no importa: el valor en la expresión  ya es 1, independientemente de lo que pueda ser ahora  el valor de a.\nPor otro lado, el símbolo :b se utiliza en la construcción de la expresión, por lo que el valor de la variable b  en ese momento es irrelevante - :b es sólo un símbolo y la variable b ni siquiera necesita ser definida. En el  momento de la evaluación de la expresión, sin embargo, el valor del símbolo :b se resuelve buscando el valor de  la variable b."
},

{
    "location": "manual/metaprogramming.html#Funcciones-sobre-Expresiones-1",
    "page": "Metaprogramación",
    "title": "Funcciones sobre Expresiones",
    "category": "section",
    "text": "Como se ha sugerido anteriormente, una característica muy útil de Julia es la capacidad de generar y manipular código Julia dentro del propio Julia. Ya hemos visto un ejemplo de una función que devuelve objetos Expr: la función parse(), que toma una cadena de código Julia y devuelve la Expr correspondiente. Una función también puede tomar uno o más objetos Expr como argumentos, y devolver otro Expr. Aquí hay un ejemplo simple y motivador:julia> function math_expr(op, op1, op2)\n           expr = Expr(:call, op, op1, op2)\n           return expr\n       end\nmath_expr (generic function with 1 method)\n\njulia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))\n:(1 + 4 * 5)\n\njulia> eval(ex)\n21Otro ejemplo puede ser esta función que dobla cualquier argumento numérico, pero deja las expresiones solas:julia> function make_expr2(op, opr1, opr2)\n           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))\n           retexpr = Expr(:call, op, opr1f, opr2f)\n           return retexpr\n       end\nmake_expr2 (generic function with 1 method)\n\njulia> make_expr2(:+, 1, 2)\n:(2 + 4)\n\njulia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))\n:(2 + 5 * 8)\n\njulia> eval(ex)\n42"
},

{
    "location": "manual/metaprogramming.html#man-macros-1",
    "page": "Metaprogramación",
    "title": "Macros",
    "category": "section",
    "text": "Las macros proporcionan un método para incluir el código generado en el cuerpo final de un programa. Una macro asigna una tupla de argumentos a una expresión devuelta, y la expresión resultante se compila directamente en lugar de requerir una llamada eval() de ejecución. Los argumentos de macro pueden incluir expresiones, valores literales y símbolos."
},

{
    "location": "manual/metaprogramming.html#Básico-1",
    "page": "Metaprogramación",
    "title": "Básico",
    "category": "section",
    "text": "He aquí una macro extraordinariamente simple:julia> macro sayhello()\n           return :( println(\"Hello, world!\") )\n       end\n@sayhello (macro with 1 method)Las macros tienen un carácter dedicado en la sintaxis de Julia: el @ (at-sign), seguido por el nombre único declarado en un bloque macro NAME ... end. En este ejemplo, el compilador reemplazará todas las instancias de @sayhello con::( println(\"Hello, world!\") )Cuando @sayhello se llama en el REPL, la expresión se ejecuta inmediatamente, por lo tanto solo vemos el resultado de la evaluación:   julia> @sayhello()\nHello, world!Ahora, considere una macro un poco más compleja:julia> macro sayhello(name)\n           return :( println(\"Hello, \", $name) )\n       end\n@sayhello (macro with 1 method)Esta macro toma un argumento: name. Cuando se encuentra @sayhello, la expresión citada se expande para interpolar el valor del argumento en la expresión final:julia> @sayhello(\"human\")\nHello, humanPodemos ver la expresión de retorno entre comillas usando la función macroexpand() (nota importante: esta es una herramienta extremadamente útil para depurar macros):julia> ex = macroexpand( :(@sayhello(\"human\")) )\n:((println)(\"Hello, \", \"human\"))\n\njulia> typeof(ex)\nExprWe can see that the \"human\" literal has been interpolated into the expression.También existe una macro @macroexpand que quizás sea un poco más conveniente que la función macroexpand:julia> @macroexpand @sayhello \"human\"\n:((println)(\"Hello, \", \"human\"))"
},

{
    "location": "manual/metaprogramming.html#Un-momento.-¿Por-qué-las-macros?-1",
    "page": "Metaprogramación",
    "title": "Un momento. ¿Por qué las macros?",
    "category": "section",
    "text": "Ya hemos visto una función f(:: Expr ...) -> Expr en una sección anterior. De hecho, macroexpand() es también una función. Entonces, ¿por qué existen macros?Las macros son necesarias porque se ejecutan cuando se analiza el código, por lo tanto, las macros permiten al programador generar e incluir fragmentos de código personalizado antes de ejecutar el programa completo. Para ilustrar la diferencia, considere el siguiente ejemplo:julia> macro twostep(arg)\n           println(\"I execute at parse time. The argument is: \", arg)\n           return :(println(\"I execute at runtime. The argument is: \", $arg))\n       end\n@twostep (macro with 1 method)\n\njulia> ex = macroexpand( :(@twostep :(1, 2, 3)) );\nI execute at parse time. The argument is: $(Expr(:quote, :((1, 2, 3))))La primera llamada a println() se ejecuta cuando se invoca macroexpand(). La expresión resultante contiene sólo el segundo println:julia> typeof(ex)\nExpr\n\njulia> ex\n:((println)(\"I execute at runtime. The argument is: \", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))\n\njulia> eval(ex)\nI execute at runtime. The argument is: (1, 2, 3)"
},

{
    "location": "manual/metaprogramming.html#Invocación-de-macros-1",
    "page": "Metaprogramación",
    "title": "Invocación de macros",
    "category": "section",
    "text": "Las macros son invocadas con la siguiente sintaxis general:``julia @name expr1 expr2 ... @name(expr1, expr2, ...)\nNote la `@` antes del nombre de macro y la falta de domas entre las expresiones de los argumentos en la primera forma, y la falta de espacios en balnco después de `@name` en la segunda forma. Los dos estilos no deberían mezclarse. Por ejemplo, la siguiente sintaxis es diferente que la de los ejemplos anteriores; ella pasa la tupla `(expr1, expr2, ...)` como argumento a la macro:\njulia @name (expr1, expr2, ...)\nEs importante enfatizar que las macros reciben sus argumentos como expresiones, literales o símbolos. Una forma de explorar los argumentos de las macros es llamar a la función `show()` dentro del cuerpo de la macro:\njldoctest julia> macro showarg(x)            show(x)            # ... remainder of macro, returning an expression        end @showarg (macro with 1 method)julia> @showarg(a) :ajulia> @showarg(1+1) :(1 + 1)julia> @showarg(println(\"Yo!\")) :(println(\"Yo!\"))\n### Construir una macro avanzada\n\nHe aquí una versión simplificada de la macro `@assert` de Julia:\njldoctest building julia> macro assert(ex)            return :( ex  nothing  throw(AssertionError((string(ex)))) )        end @assert (macro with 1 method)\nLa macro puede ser usada de esta forma:\njldoctest building julia> @assert 1 == 1.0julia> @assert 1 == 0 ERROR: AssertionError: 1 == 0\nEn lugar de la sintaxis escrita, la llamada a macro es expandida en tiempo de análisis para que devuelva un resutlado. Esto es equivalente a escribir:\njulia 1 == 1.0 ? nothing : throw(AssertionError(\"1 == 1.0\")) 1 == 0 ? nothing : throw(AssertionError(\"1 == 0\"))\nEs decir, en la primera llamada, la expresión `:(1 == 1.0)` se empalma en la ranura de condición de prueba, mientras que el valor de `string(:( 1 == 1.0))` se empalma en la ranura de mensaje de aserción. Toda la expresión, así construida, se coloca en el árbol de sintaxis donde se produce la llamada de macro `@assert`. Entonces, en el tiempo de ejecución, si la expresión de prueba se evalúa como verdadera, entonces se devuelve `nothing`, mientras que si la prueba es falsa, se genera un error indicando la expresión afirmada que es falsa. Observe que no sería posible escribir esto como una función, ya que sólo está disponible el valor de la condición y sería imposible mostrar la expresión que lo calculó en el mensaje de error.\n\nLa definición real de `@assert` en la biblioteca estándar es más complicada. Permite al usuario especificar opcionalmente su propio mensaje de error, en lugar de simplemente imprimir la expresión fallida. Al igual que en las funciones con un número variable de argumentos, esto se especifica con elipses después del último argumento:\njldoctest assert2 julia> macro assert(ex, msgs...)            msg_body = isempty(msgs) ? ex : msgs[1]            msg = string(msg_body)            return :(ex  nothing  throw(AssertionError(msg)))        end @assert (macro with 1 method)\nAhora `@assert` tiene dos modos de operación, dependiendo del número de argumentos que recibe! Si sólo hay un argumento, la tupla de expresiones capturadas por `msgs` estará vacía y se comportará igual que la definición más simple anterior. Ahora bien, si el usuario especifica un segundo argumento, se imprime en el cuerpo del mensaje en lugar de la expresión que falla. Puede examinar el resultado de una expansión de macro con la función [`macroexpand()`](@ref) correctamente denominada:\njldoctest assert2 julia> macroexpand(:(@assert a == b)) :(if a == b         nothing     else         (throw)((AssertionError)(\"a == b\"))     end)julia> macroexpand(:(@assert a==b \"a should equal b!\")) :(if a == b         nothing     else         (throw)((AssertionError)(\"a should equal b!\"))     end)\nHay otro caso que la versión real de `@assert` maneja: ¿qué pasa si, además de imprimir \"a should be equal b\", queremos imprimir sus valores? Uno podría ingenuamente intentar usar interpolación de cadena en el mensaje personalizado, por ejemplo, ` @assert a==b \"a ($a) should equal b ($b)!\"`, pero esto no funcionará como se esperaba con la macro anterior. ¿Puedes ver por qué? Recuerda de [string interpolation](@ref string-interpolation) que una cadena interpolada se reescribe a una llamada a [`string()`](@ref). Compare:\njldoctest julia> typeof(:(\"a should equal b\")) Stringjulia> typeof(:(\"a (a) should equal b (b)!\")) Exprjulia> dump(:(\"a (a) should equal b (b)!\")) Expr   head: Symbol string   args: Array{Any}((5,))     1: String \"a (\"     2: Symbol a     3: String \") should equal b (\"     4: Symbol b     5: String \")!\"   typ: Any\nAsí que ahora en lugar de obtener una cadena sencilla en `msg_body`, la macro está recibiendo una expresión completa que necesitará ser evaluada para mostrarse como se esperaba. Esto puede ser empalmado directamente en la expresión devuelta como un argumento a la llamada [`string()`](@ref); Vea [`error.jl`](https://github.com/JuliaLang/julia/blob/master/base/error.jl) para la implementación completa.\n\nLa macro `@assert` hace un gran uso del empalme en expresiones entre comillas para simplificar la manipulación de expresiones dentro del cuerpo de la macro.\n\n### Higiene\n\nUn problema que surge en las macros más complejas es el de la [higiene](https://en.wikipedia.org/wiki/Hygienic_macro).En resumen, las macros deben asegurarse de que las variables que introducen en sus expresiones devueltas no chocan accidentalmente con las variables existentes en el código circundante en el que se expanden. A la inversa, a menudo se espera que las expresiones que se pasan a una macro como argumentos evalúen en el contexto del código circundante, interactuando con y modificando las variables existentes. Otra preocupación surge del hecho de que una macro puede ser llamada en un módulo diferente desde donde se definió. En este caso, debemos asegurarnos de que todas las variables globales se resuelvan en el módulo correcto. Julia ya tiene una gran ventaja sobre los lenguajes con expansión de macro textual (como C) en que sólo necesita considerar la expresión devuelta. Todas las demás variables (como `msg` en `@assert` arriba) siguen el [comportamiento normal del bloque de ámbito](@ref scope-of-variables).\n\nPara demostrar estos problemas, consideremos la posibilidad de escribir una macro `@time` que toma una expresión como su argumento, registra el tiempo, evalúa la expresión, registra el tiempo de nuevo, imprime la diferencia entre los tiempos antes y después y luego tiene el valor de La expresión como su valor final. La macro podría tener este aspecto:\njulia macro time(ex)     return quote         local t0 = time()         local val = ex         local t1 = time()         println(\"elapsed time: \", t1-t0, \" seconds\")         val     end end\nAquí, queremos que `t0`, `t1` y `val` sean variables temporales privadas, y queremos que `time` se refiera a la función [`time()`](@ref) de la biblioteca estándar, no a cualquier variable de tiempo que el usuario pueda tener (lo mismo se aplica a `println`). Imagine los problemas que podrían ocurrir si la expresión de usuario `ex` también contuviera asignaciones a una variable denominada `t0`, o definiese su propia variable `time`. Podríamos obtener errores o comportamiento misteriosamente incorrecto.\n\n\nEl expansor de macro de Julia resuelve estos problemas de la siguiente manera. En primer lugar, las variables dentro de un resultado de macro se clasifican como locales o globales. Una variable se considera local si es asignada (y no se declara global), se declara local o se utiliza como un nombre de argumento de función. De lo contrario, se considera global. Las variables locales son renombradas como únicas (utilizando la función [`gensym()`](@ref), que genera nuevos símbolos), y las variables globales se resuelven dentro del entorno de definición de macro. Por lo tanto, ambas preocupaciones se manejan; Los locales de la macro no entrarán en conflicto con ninguna variable de usuario, y `time` y `println` se referirán a las definiciones de la biblioteca estándar.\n\nSin embargo, queda un problema. Considere el siguiente uso de esta macro:\njulia module MyModule import Base.@timetime() = ... # compute something@time time() end\nAquí la expresión de usuario `ex` es una llamada a `time`, pero no a la misma función `time` que usa la macro, sino que se refiere claramente a `MyModule.time`. Por tanto, debemos arreglar pora que el código en `ex` sea resuelto en el entorno de llamada de la macro. Esto se hace usando [`esc()`](@ref) para \"escapar\" la expresión:\njulia macro time(ex)     ...     local val = esc(ex)     ... end\nUna expresión envuelta de esta manera es dejada sola por el expansor de macros y simplemente pegada en la salida. Por tanto, será resuelta en el entorno de llamada de la macro.\n\nEl mecanismo de \"escapar\" puede ser usado para \"violar\" la higiene cuando sea necesario, para introducir o manipular variables de usuario. Por ejemplo, la siguiente macro fija `x` a cero en el entorno de llamada:\njldoctest julia> macro zerox()            return esc(:(x = 0))        end @zerox (macro with 1 method)julia> function foo()            x = 1            @zerox            return x # is zero        end foo (generic function with 1 method)julia> foo() 0\nEsta clase de manipulación de variables debería ser usada juiciosamente, pero es ocasionalmente bastante útil.\n\nObtener las normas de higiene correctas puede ser un desafío formidable. Antes de usar una macro, es posible que desee considerar si un cierre de función sería suficiente. Otra estrategia útil es diferir tanto trabajo como sea posible para el tiempo de ejecución. Por ejemplo, muchas macros simplemente envuelven sus argumentos en un QuoteNode u otro Expr similar. Algunos ejemplos de esto incluyen `@task body` que simplemente devuelve `schedule (Task(() -> $ body))`, y `@eval expr`, que simplemente devuelve `eval (QuoteNode (expr))`.\n\nObtener las normas de higiene correctas puede ser un desafío formidable. Antes de usar una macro, es posible que desee considerar si un cierre de función sería suficiente. Otra estrategia útil es diferir tanto trabajo como sea posible para el tiempo de ejecución. Por ejemplo, muchas macros simplemente envuelven sus argumentos en un QuoteNode u otro Expr similar. Algunos ejemplos de esto incluyen `@task body` que simplemente devuelve` schedule (Task (() -> $ body)) `, y` @eval expr`, que simplemente devuelve `eval (QuoteNode (expr))`.\n\nPara demostrarlo, podríamos reescribir el ejemplo `@time` anterior como:\njulia macro time(expr)     return :(timeit(() -> esc(expr))) end function timeit(f)     t0 = time()     val = f()     t1 = time()     println(\"elapsed time: \", t1-t0, \" seconds\")     return val end\nSin embargo, no hacemos esto por una buena razón: al envolver el `expr` en un nuevo bloque de alcance (la función anónima) también cambia ligeramente el significado de la expresión (el alcance de cualquier variable en él), mientras que queremos` @ time` para ser utilizable con un impacto mínimo en el código ajustado.\n\n## Generación de Código\n\nCuando se requiere una cantidad significativa de código repetitivo, es común generarlo programáticamente para evitar la redundancia. En la mayoría de los lenguajes, esto requiere un paso de construcción adicional y un programa separado para generar el código repetitivo. En Julia, la interpolación de expresión y [`eval()`](@ref) permiten que dicha generación de código tenga lugar en el curso normal de la ejecución del programa. Por ejemplo, el siguiente código define una serie de operadores en tres argumentos en términos de sus formas de 2 argumentos:\njulia for op = (:+, :*, :&, :|, :)     eval(quote         (op)(a,b,c) = (op)((op)(a,b),c)     end) end\nDe este modo, Julia actúa como su propio [preprocesador](https://en.wikipedia.org/wiki/Preprocessor), y permite la generación de código desde dentro del lenguaje. El código anterior debería ser escrito ligeramente más secamente usando la forma prefija de citación `:`\njulia for op = (:+, :*, :&, :|, :)     eval(((op)(a,b,c) = (op)((op)(a,b),c))) end\nEn este tipo de generación de código dentro del lenguaje utilizando el patrón `eval(quote(...))` es bastante común, sin embargo, que Julia venga con una macro para abreviar este patrón:\njulia for op = (:+, :*, :&, :|, :)     eval (op)(a,b,c) = (op)((op)(a,b),c) end\nLa macro [`@eval`](@ref) reescribe esta llamada para ser precisamente equivalente a las versiones largas anteriores. Para bloques de código generado más grandes, el argumento expresión dado a [`@eval`](@ref) puede ser un bloque:\njulia @eval begin     # multiple lines end\n## Literales de cadena no estándar\n\nRecuerde de [Strings](@ref non-standard-string-literals) que los literales de cadena prefijados por un identificador se llaman literales de cadena no estándar y pueden tener semántica distinta que los literales de cadena no prefijados. Por ejemplo:\n\n* `r\"^\\s*(?:#|$)\"` produces un objeto expresión regular en lugar de una cadena.\n* `b\"DATA\\xff\\u2200\"` es un literal array bytepara `[68,65,84,65,255,226,136,128]`.\n\nTal vez sorprendentemente, estos comportamientos no están codificados en el analizador de Julia o en el compilador. En su lugar, son comportamientos personalizados proporcionados por un mecanismo general que cualquiera puede utilizar: los literales de cadenas prefijados se analizan como llamadas a macros de nombre especial. Por ejemplo, la macro de expresiones regulares es sólo la siguiente:\njulia macro r_str(p)     Regex(p) end\nEso es todo. Esta macro dice que el contenido literal de la cadena literal `r\"^\\s*(?:#|$)\"` debe ser pasado a la macro `@r_str` y que el resultado de esa expansión debe colocarse en el árbol de sintaxis donde tiene lugar la cadena literal. En otras palabras, la expresión `r\"^\\s*(?:#|$)\"` equivale a colocar el siguiente objeto directamente en el árbol de sintaxis:\njulia Regex(\"^\\s*(?:#|$)\")\nNo sólo la forma literal de la cadena es más corta y mucho más conveniente, sino que también es más eficiente: puesto que la expresión regular se compila y el objeto Regex se crea realmente *cuando el código es compilado*, la compilación se produce sólo una vez, Se ejecuta el código. Considere si la expresión regular se produce en un bucle:\n\njulia for line = lines     m = match(r\"^\\s*(?:#|$)\", line)     if m === nothing         # non-comment     else         # comment     end end\nComo la expresión regular `r\"^\\s*(?:#|$)\"` Se compila e inserta en el árbol de sintaxis cuando se analiza este código, la expresión sólo se compila una vez en lugar de cada vez que se ejecuta el bucle. Para lograr esto sin macros, uno tendría que escribir este bucle así:\njulia re = Regex(\"^\\s*(?:#|$)\") for line = lines     m = match(re, line)     if m === nothing         # non-comment     else         # comment     end end\nPor otra parte, si el compilador no pudiera determinar que el objeto regex era constante en todos los bucles, ciertas optimizaciones podrían no ser posibles, haciendo esta versión aún menos eficiente que la forma literal más conveniente de arriba. Por supuesto, todavía hay situaciones en las que la forma no literal es más conveniente: si se necesita interpolar una variable en la expresión regular, se debe tomar este enfoque más detallado; En los casos en que el patrón de expresión regular mismo es dinámico, cambiando potencialmente en cada iteración del bucle, un nuevo objeto expresión regular debe ser construido en cada iteración. Sin embargo, en la gran mayoría de los casos de uso, las expresiones regulares no se construyen sobre la base de datos de tiempo de ejecución. En esta mayoría de casos, la capacidad de escribir expresiones regulares como valores en tiempo de compilación es valiosísima.\n\nAl igual que los literales de cadena no estándar, existen literales de comandos no estándar que usan una variante prefijada de la sintaxis literal del comando. El comando literal ```custom `literal` ``` se analiza como `@custom_cmd \"literal\"`. Julia por sí misma no contiene ningún literal de comando no estándar, pero los paquetes pueden hacer uso de esta sintaxis. Aparte de la sintaxis diferente y el sufijo `_cmd` en lugar del sufijo` _str`, los literales de comandos no estándar se comportan exactamente como los literales de cadena no estándar.\n\nEn el caso de que dos módulos proporcionen cadenas o literales de comando con el mismo nombre, es posible calificar la cadena o literal de comando con un nombre de módulo. Por ejemplo, si tanto `Foo` como` Bar` proporcionan literal de cadena no estándar `@x_str`, entonces uno puede escribir `Foo.x \"literal\"` o `Bar.x \"literal\" `para desambiguar entre los dos.\n\nEl mecanismo para literales de cadena definidos por el usuario es profundo, profundamente poderoso. No sólo son literales no estándar de Julia implementados usándolos, sino que también se implementa la sintaxis literal de comandos (``` `echo \"Hello, $person\"` ```) se implementa con la siguiente macro de aspecto inofensivo:\njulia macro cmd(str)     :(cmd_gen((shell_parse(str))[1])) end\nPor supuesto, una gran cantidad de complejidad se oculta en las funciones utilizadas en esta definición de macro, pero son sólo funciones, escritas íntegramente en Julia. Usted puede leer su fuente y ver exactamente lo que hacen -y todo lo que hacen es construir objetos de expresión para ser insertados en el árbol de sintaxis de su programa.\n\n## Funciones Generadas\n\nUna macro muy especial es `@generated`, que permite definir las llamadas *funciones generadas*. Éstas tienen la capacidad de generar código especializado dependiendo de los tipos de sus argumentos con más flexibilidad y/o menos código que lo que se puede lograr con el despacho múltiple. Mientras las macros trabajan con expresiones al momento de analizar y no pueden acceder a los tipos de sus entradas, una función generada se amplía en un momento en que se conocen los tipos de los argumentos, pero la función aún no se ha compilado.\n\nEn lugar de realizar algún cálculo o acción, una declaración de función generada devuelve una expresión entre comillas que luego forma el cuerpo para el método correspondiente a los tipos de los argumentos. Cuando se llama, la expresión del cuerpo se compila (o se extrae de una caché, en las llamadas posteriores) y sólo se evalúa la expresión devuelta, y no el código que lo generó. Así, las funciones generadas proporcionan un marco flexible para mover el trabajo desde el tiempo de ejecución hasta el tiempo de compilación.\n\nCuando se definen las funciones generadas, hay tres diferencias principales con las funciones ordinarias:\n\n1. Uno anota la declaración de función con la macro `@generated`. Esto agrega cierta información a la AST que permite al\n   compilador saber que se trata de una función generada.\n2. En el cuerpo de la función generada sólo tiene acceso a los *tipos* de los argumentos, no a sus valores – y cualquier\n   función que fuera definida *antes* de la definición de la función generada.\n3. En lugar de calcular algo o realizar alguna acción, devuelve una *expresión citada* que, cuando se evalúa, hace lo\n   que uno quiere.\n4. Las funciones generadas no deben *mutar* ni *observar* ningún estado global no constante (incluidos, por ejemplo, \n   IO, bloqueos, diccionarios no locales o que usen `method_exists`). Esto significa que solo pueden leer constantes \n   globales y no pueden tener ningún efecto secundario. En otras palabras, deben ser completamente puros. Debido a \n   una limitación de implementación, esto también significa que actualmente no pueden definir un cierre o un generador \n   sin tipo.\n\nEs más fácil ilustrar esto con un ejemplo. Podemos declarar una función generada `foo` como:\njldoctest generated julia> @generated function foo(x)            Core.println(x)            return :(x * x)        end foo (generic function with 1 method)\nTenga en cuenta que el cuerpo devuelve una expresión entre comillas, a saber `:(x * x)`, en lugar de sólo el valor de `x * x`.\n\nDesde la perspectiva del llamador, son muy similares a las funciones regulares; de hecho, no tienes que saber si estás llamando a una función regular o generada  -la sintaxis y el resultado de la llamada son iguales. Veamos cómo se comporta `foo`:\njldoctest generated julia> x = foo(2); # note: output is from println() statement in the body Int64julia> x           # now we print x 4julia> y = foo(\"bar\"); Stringjulia> y \"barbar\"\nAsí, vemos que en el cuerpo de la función generada, `x` es el tipo del argumento pasado, y el valor devuelto por la función generada es el resultado de la evaluación de la expresión citada que devolvimos de la definición, ahora con el *valor* de `x`.\n\n¿Qué pasa si evaluamos foo de nuevo con un tipo que ya hemos utilizado?\njldoctest generated julia> foo(4) 16\nTenga en cuenta que no hay ninguna impresión de [`Int64`](@ref). El cuerpo de la función generada sólo se ejecuta una vez (no es enteramente cierto, véase la nota a continuación) cuando se compila el método para ese conjunto específico de tipos de argumentos. Después de eso, la expresión devuelta de la función generada en la primera invocación se vuelve a utilizar como el cuerpo del método.\n\nLa cantidad de veces que se genera una función generada *podría* ser solo una vez, pero *podría* también ser más frecuente o no aparecer en absoluto. Como consecuencia, *nunca* debe escribir una función generada con efectos secundarios: cuándo y con qué frecuencia ocurren los efectos secundarios no está definida. (Esto también es válido para las macros, y al igual que para las macros, el uso de [`eval()`](@ref) en una función generada es una señal de que estás haciendo algo incorrecto.) Sin embargo, a diferencia de las macros , el sistema de tiempo de ejecución no puede manejar correctamente una llamada a [`eval()`](@ref), por lo que no se permite.\n\nTambién es importante ver cómo las funciones `@generated` interactúan con la redefinición del método. Siguiendo el principio de que una función correcta `@ generated` no debe observar ningún estado mutable ni causar ninguna mutación del estado global, vemos el siguiente comportamiento. Observe que la función generada *no puede* llamar a ningún método que no se haya definido antes de la * definición * de la función generada en sí.\n\nInicialmente `f (x)` tiene una definición:\njldoctest redefinition julia> f(x) = \"original definition\";\nDefine otras operaciones que usan `f(x)`:\njldoctest redefinition julia> g(x) = f(x);julia> @generated gen1(x) = f(x);julia> @generated gen2(x) = :(f(x));\nAhora añadimos algunas definiciones nuevas para `f(x)`:\njldoctest redefinition julia> f(x::Int) = \"definition for Int\";julia> f(x::Type{Int}) = \"definition for Type{Int}\";\ny comparamos cómo difieren estos resultados:\njldoctest redefinition julia> f(1) \"definition for Int\"julia> g(1) \"definition for Int\"julia> gen1(1) \"original definition\"julia> gen2(1) \"definition for Int\"\nCada método de una función generada tiene su propia visión de funciones definidas:\njldoctest redefinition julia> @generated gen1(x::Real) = f(x);julia> gen1(1) \"definition for Type{Int}\"La función de ejemplo `foo` anterior no hizo nada de lo que una función normal` foo(x) = x*x` no pudo hacer (excepto imprimir el tipo en la primera invocación y incurrir en una sobrecarga más alta). Sin embargo, el poder de una función generada radica en su capacidad para calcular diferentes expresiones entrecomilladas según los tipos que se le pasen:\njldoctest julia> @generated function bar(x)            if x <: Integer                return :(x ^ 2)            else                return :(x)            end        end bar (generic function with 1 method)julia> bar(4) 16julia> bar(\"baz\") \"baz\"\n(although por supuesto este ejemplo artificial se implementa facilmente usando despacho múltiple...\n\nPodemos, por supuesto, abusar de esto para producir algún comportamiento interesante:\njldoctest julia> @generated function baz(x)            if rand() < .9                return :(x^2)            else                return :(\"boo!\")            end        end baz (generic function with 1 method)\nado que el cuerpo de la función generada es no determinista, su comportamiento es indefinido.\n\n*¡No copie estos ejemplos!*\n\nEstos ejemplos sirven para ilustrar cómo funcionan las funciones generadas, tanto en el extremo de la definición como en el sitio de llamada; Sin embargo, no los copie, por las siguientes razones:\n\n  * La función `foo` tiene efectos secundarios (la llamada a `Core.println`) y no está definida exactamente cuándo, \n    con qué frecuencia o cuántas veces se producirán estos efectos secundarios\n  * La función `bar` resuelve un problema que se resuelve mejor con el despacho múltiple - definiendo `bar(x) = x` \n    y `bar(x :: Integer) = x ^ 2` hará la misma cosa, pero es más simple y más rápido.\n  * La función `baz` es patológicamente insana\n\nTenga en cuenta que el conjunto de operaciones que no se deben intentar en una función generada no tiene límites, y el sistema de tiempo de ejecución solo puede detectar actualmente un subconjunto de las operaciones no válidas. Hay muchas otras operaciones que simplemente corromperán el sistema de tiempo de ejecución sin notificación, por lo general de maneras sutiles que obviamente no están conectadas a la mala definición. Debido a que el generador de funciones se ejecuta durante la inferencia, debe respetar todas las limitaciones de ese código.\n\nAlgunas operaciones que no deberían intentarse incluyen:\n\n1. Almacenamiento en caché de punteros nativos.\n2. Interactuar de cualquier manera con los contenidos o métodos de Core.Inference.\n3. Observar cualquier estado mutable.\n\n     * La inferencia sobre la función generada se puede ejecutar en *cualquier* momento, incluso cuando el código intenta\n       observar o modificar este estado.\n\n4. Tomar cualquier bloqueo: código C que llame a puede utilizar bloqueos internos, (por ejemplo, no es problemático \n   para llamar `malloc`, a pesar de que la mayoría de las implementaciones requieren bloqueos internos), pero no \n   pretenden mantener o adquirir cualquier tiempo ejecutando el código de Julia.\n5. Llamar a cualquier función que esté definida después del cuerpo de la función generada. Esta condición se relaja \n   para los módulos precompilados de carga incremental para permitir llamar a cualquier función en el módulo.\n\nDe acuerdo, ahora que tenemos una mejor comprensión de cómo funcionan las funciones generadas, utilicémoslas para construir algunas funcionalidades más avanzadas (y válidas) ...\n\n### An advanced example\n\nLa biblioteca base de Julia tiene una función  [`sub2ind()`](@ref) para calcular un índice lineal en una matriz n-dimensional, basada en un conjunto de n índices multilineales - en otras palabras, para calcular el índice `i` que se puede usar para indexar en una matriz `A` usando `A[i]`, en lugar de `A[x, y, z, ...]`. Una posible implementación es la siguiente:\njldoctest sub2ind julia> function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N            ind = I[N] - 1            for i = N-1:-1:1                ind = I[i]-1 + dims[i]*ind            end            return ind + 1        end sub2ind_loop (generic function with 1 method)julia> sub2ind_loop((3, 5), 1, 2) 4\nLo mismo puede hacerse usando recursión:\njldoctest julia> sub2ind_rec(dims::Tuple{}) = 1;julia> sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =            i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =            i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);julia> sub2ind_rec((3, 5), 1, 2) 4\nAmbas implementaciones, aunque diferentes, hacen esencialmente lo mismo: un bucle de tiempo de ejecución sobre las dimensiones de la matriz, recogiendo el desplazamiento en cada dimensión en el índice final.\n\nSin embargo, toda la información que necesitamos para el bucle está incrustada en la información de tipo de los argumentos. Por lo tanto, podemos utilizar las funciones generadas para mover la iteración a tiempo de compilación; en la jerga del compilador, usamos las funciones generadas para desenrollar manualmente el bucle. El cuerpo se vuelve casi idéntico, pero en vez de calcular el índice lineal, construimos una *expresión* que calcula el índice:\njldoctest sub2ind_gen julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N            ex = :(I[N - 1)            for i = (N - 1)-11                ex = (Ii] - 1 + dims[i * ex)            end            return (ex + 1)        end sub2ind_gen (generic function with 1 method)julia> sub2ind_gen((3, 5), 1, 2) 4\n**¿Qué código generará esto?**\n\nUna forma sencilla de averiguarlo es extraer el cuerpo en otra función (regular):\njldoctest sub2ind_gen2 julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N            return sub2ind_gen_impl(dims, I...)        end sub2ind_gen (generic function with 1 method)julia> function sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N            length(I) == N || return :(error(\"partial indexing is unsupported\"))            ex = :(I[N - 1)            for i = (N - 1)-11                ex = (Ii] - 1 + dims[i * ex)            end            return (ex + 1)        end sub2ind_gen_impl (generic function with 1 method)\nAhora podemos ejecutar `sub2ind_gen_impl` y examinar la expresión que devuelve\njldoctest sub2ind_gen2 julia> sub2ind_gen_impl(Tuple{Int,Int}, Int, Int) :(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1) ```Por lo tanto, el cuerpo de método que se utilizará aquí no incluye un bucle en absoluto - sólo indexación en las dos tuplas, multiplicación y suma/resta. Todo el bucle se realiza en tiempo de compilación, y evitamos el bucle durante la ejecución por completo. Por lo tanto, sólo se realiza el bucle una vez por tipo, en este caso una vez por N (excepto en casos de borde donde la función se genera más de una vez - véase la exención de responsabilidad anterior)."
},

{
    "location": "manual/arrays.html#",
    "page": "Arrays Multi-dimensionales",
    "title": "Arrays Multi-dimensionales",
    "category": "page",
    "text": ""
},

{
    "location": "manual/arrays.html#man-multi-dim-arrays-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Arrays Multi-dimensionales",
    "category": "section",
    "text": "Julia, como la mayoría de los lenguajes informáticos técnicos, proporciona una implementación de los arrays de primera clase. La mayoría de los lenguajes informáticos técnicos prestan mucha atención a su implementación de arrays a expensas de otros contenedores. Julia no trata los arrays de manera especial. La biblioteca de arrays se ha implementado casi completamente en el propio lenguaje Julia, y deriva su rendimiento del compilador, al igual que cualquier otro código escrito en Julia. Como tal, es también posible definir tipos de arrays personalizados heredando de AbstractArray. Consulte la sección de manual en la interfaz AbstractArray para ms detalles sobre implementar un tipo array personalizado.Un array es una colección de objetos almacenados en una cuadrícula multidimensional. En el caso más general, un array puede contener objetos de tipo Any. Para la mayoría de los propósitos computacionales, los arrays deben contener objetos de un tipo más específico, como  Float64 o Int32.En general, a diferencia de muchos otros lenguajes informáticos técnicos, Julia no espera que los programas se escriban en un estilo vectorizado para el rendimiento. El compilador de Julia utiliza la inferencia de tipos y genera código optimizado para la indexación escalar de arrays, permitiendo que los programas se escriban en un estilo que sea conveniente y legible, sin sacrificar el rendimiento y utilizando menos memoria a veces.En Julia, todos los argumentos a las funciones se pasan por referencia. Algunos lenguajes informáticos técnicos pasan los arrays por valor, y esto es conveniente en muchos casos. En Julia, las modificaciones hechas a los arrays de entrada dentro de una función serán visibles en la función principal. Toda la biblioteca de arrays de Julia garantiza que las entradas no sean modificadas por las funciones de biblioteca. El código de usuario, si necesita mostrar un comportamiento similar, debe tener cuidado de crear una copia de las entradas que puede modificar."
},

{
    "location": "manual/arrays.html#Arrays-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Arrays",
    "category": "section",
    "text": ""
},

{
    "location": "manual/arrays.html#Funciones-Básicas-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Funciones Básicas",
    "category": "section",
    "text": "Function Description\neltype(A) Tipo de los elementos contenidos en A\nlength(A) Número de elementos en A\nndims(A) Número de dimensiones de A\nsize(A) Una tupla que contien las dimensiones de A\nsize(A,n) El tamaño de A a lo largo de una dimensión particular n\nindices(A) Una tupla que contiene los índices válidos de A\nindices(A,n) Un rango expresando los úndices válidos a lo largo de la dimensión n          \neachindex(A) Un iterador eficiente para visitar cada posición en A\nstride(A,k) La zancada (stride, distancia de índice lineal entre elementos adyacentes) a lo largo de la dimensión k.\nstrides(A) Una tupla de las zancadas en cada dimensión"
},

{
    "location": "manual/arrays.html#Construcción-e-Inicialización-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Construcción e Inicialización",
    "category": "section",
    "text": "Existen muchas funciones para construir e inicializar matrices. En la siguiente lista de tales funciones, las llamadas con un argumento dims... pueden tomar una sola tupla de tamaños de dimensión o una serie de tamaños de dimensión pasados como un número variable de argumentos. Muchas de estas funciones también aceptan un primea entrada T, que es el tipo de los elementos del array. Si este tipo es omitido se asumirá como tipo por defecto por defecto Float64.Function Description\nArray{T}(dims...) an uninitialized dense Array\nzeros(T, dims...) an Array of all zeros\nzeros(A) an array of all zeros with the same type, element type and shape as A\nones(T, dims...) an Array of all ones\nones(A) an array of all ones with the same type, element type and shape as A\ntrues(dims...) a BitArray with all values true\ntrues(A) a BitArray with all values true and the same shape as A\nfalses(dims...) a BitArray with all values false\nfalses(A) a BitArray with all values false and the same shape as A\nreshape(A, dims...) an array containing the same data as A, but with different dimensions\ncopy(A) copy A\ndeepcopy(A) copy A, recursively copying its elements\nsimilar(A, T, dims...) an uninitialized array of the same type as A (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of A if omitted.\nreinterpret(T, A) an array with the same binary data as A, but with element type T\nrand(T, dims...) an Array with random, iid [1] and uniformly distributed values in the half-open interval 0 1)\nrandn(T, dims...) an Array with random, iid and standard normally distributed values\neye(T, n) n-by-n identity matrix\neye(T, m, n) m-by-n identity matrix\nlinspace(start, stop, n) range of n linearly spaced elements from start to stop\nfill!(A, x) fill the array A with the value x\nfill(x, dims...) an Array filled with the value x[1]: iid, independently and identically distributed.La sintaxis [A, B, C, ...] construye un array 1-dimensional (vector) a partir de sus argumentos. Si todos los argumentos tienen un tipo de promocion comun entonces ellos son convertidos a este tipo usando convert()."
},

{
    "location": "manual/arrays.html#Concatenación-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Concatenación",
    "category": "section",
    "text": "Los arrays pueden ser construídos y también concatenados usando las siguientes funciones:Function Description\ncat(k, A...) concatena n-d arrays a lo largo de la dimensión k\nvcat(A...) abreviatura para cat(1, A...)\nhcat(A...) abreviatura para cat(2, A...)Los valores escalares pasados a estas funciones son tratados como arrays de 1 elemento.Las funciones de concatenación se usan tan frecuentemente que tiene una sintaxis especial:Expression Calls\n[A; B; C; ...] vcat()\n[A B C ...] hcat()\n[A B; C D; ...] hvcat()hvcat() concatena tanto en la dimensión 1 (con puntos y coma) como en la dos (con espacios)."
},

{
    "location": "manual/arrays.html#Inicializadores-de-Array-Tipados-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Inicializadores de Array Tipados",
    "category": "section",
    "text": "Se puede construir una matriz con un tipo de elemento específico utilizando la sintaxis T[A, B, C, ...]. Esto construirá un array 1-d con el tipo de elemento T, inicializado para contener los elementos A, B, C, etc. Por ejemplo, Any [x, y, z] construye un array heterogéneo que puede contener cualquier valor.La sintaxis de concatenación puede ser prefijada de forma similar con un tipo para especificar el tipo de elemento del resultado.julia> [[1 2] [3 4]]\n1×4 Array{Int64,2}:\n 1  2  3  4\n\njulia> Int8[[1 2] [3 4]]\n1×4 Array{Int8,2}:\n 1  2  3  4"
},

{
    "location": "manual/arrays.html#comprehensions-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Comprensiones",
    "category": "section",
    "text": "Las comprensiones proporcionan una forma general y potente de construir arrays. Su sintaxis es similar a la notación de construcción de conjuntos en matemáticas:A = [ F(x,y,...) for x=rx, y=ry, ... ]El significado de esta forma es que F(x, y, ...) es evaluado para las variables x, y, etc. tomando cada valor de la lista de valores proporcionada. Los valores se pueden especificar mediante cualquier objeto iterable, pero comúnmente serán rangos como 1:n o 2:(n-1), o arrays de valores explícitos como [1.2, 3.4, 5.7]. El resultado es una matriz N-d densa con dimensiones que son la concatenación de las dimensiones de los rangos de las variables rx, ry, etc. y donde cada evaluación F(x, y, ...) devuelve un escalar.El siguiente ejemplo calcula la media ponderada del elemento actual y su vecino izquierdo y derecho a lo largo de una rejilla unidimensional:julia> x = rand(8)\n8-element Array{Float64,1}:\n 0.843025\n 0.869052\n 0.365105\n 0.699456\n 0.977653\n 0.994953\n 0.41084\n 0.809411\n\njulia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\n6-element Array{Float64,1}:\n 0.736559\n 0.57468\n 0.685417\n 0.912429\n 0.8446\n 0.656511El tipo del array resultante depende de los tipos de los elementos calculados. Para controlar el tipo explícitamente, un tipo puede ser precedido a la comprensión. Por ejemplo, podríamos haber solicitado el resultado en precisión simple escribiendo:Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]"
},

{
    "location": "manual/arrays.html#Expresiones-Generador-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Expresiones Generador",
    "category": "section",
    "text": "Las comprensiones también se pueden escribir sin los corchetes que las encierran, produciendo un objeto conocido como generador. Este objeto puede ser iterado para producir valores bajo demanda, en lugar de reservar espacio para un array y almacenarlos en él de antemano (véase Iteración). Por ejemplo, la siguiente expresión suma una serie sin asignar memoria:julia> sum(1/n^2 for n=1:1000)\n1.6439345666815615Cuando se escribe una expresión generador con múltiples dimensiones dentro de una lista de argumentos, se necesitan paréntesis para separar el generador de argumentos posteriores:julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])\nERROR: syntax: invalid iteration specificationTodas las expresiones separadas por comas después del for se interpretan como rangos. Añadir paréntesis permite añadir un tercer argumento a map:julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])\n2×2 Array{Tuple{Float64,Int64},2}:\n (0.5, 1)       (0.333333, 3)\n (0.333333, 2)  (0.25, 4)Los rangos en generadores y comprensiones pueden depender de rangos anteriores escribiendo varias palabras clave for:julia> [(i,j) for i=1:3 for j=1:i]\n6-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (2, 1)\n (2, 2)\n (3, 1)\n (3, 2)\n (3, 3)En tales casos, el resultado es siempre unidimensional.Los valores generados se pueden filtrar usando la palabra clave if:julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]\n2-element Array{Tuple{Int64,Int64},1}:\n (2, 2)\n (3, 1)"
},

{
    "location": "manual/arrays.html#man-array-indexing-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Indexación",
    "category": "section",
    "text": "La sintaxis general para indexar en un array n-dimensional A es:X = A[I_1, I_2, ..., I_n]donde cada I_k puede ser un entero escalar, un array de enteros o cualquier otro índice soportado. Esto incluye Colon (:) para seleccionar todos los índices dentro de la dimensión completa, rangos de la forma a:c o a:b:c para seleccionar subsecciones contiguas o con salto, y arrays de booleans para seleccionar elementos en sus índices true.Si todos los índices son escalares, entonces el resultado X es un solo elemento del array A. De lo contrario, X es un array con el mismo número de dimensiones que la suma de las dimensionalidades de todos los índices.Si todos los índices son vectores, por ejemplo, entonces la forma de X sería (length(I_1), length(I_2), ..., length(I_n)), donde las ubicaciones (i_1, i_2, ..., i_n) de X contienen el valor A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]. Si I_1 se cambia por un array bidimensional, entonces X se vuelve un n+1-dimensional array de forma (size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n)). La matriz añade una dimensión. La ubicación (i_1, i_2, i_3, ..., i_{n+1}) contiene el valor en A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]. Todas las dimensiones indexadas con escalares se eliminan. Por ejemplo, el resultado de A[2, I, 3] es un array de tamaño size(I). Su i-ésimo elemento es poblado por A[2, I[i], 3].Como parte especial de esta sintaxis, se puede usar la palabra clave end para representar el último índice de cada dimensión dentro de los corchetes de indexación, según lo determinado por el tamaño del array más interno indexado. La sintaxis de indexación sin la palabra end es equivalente a una llamada a getindex:X = getindex(A, I_1, I_2, ..., I_n)Example:julia> x = reshape(1:16, 4, 4)\n4×4 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> x[2:3, 2:end-1]\n2×2 Array{Int64,2}:\n 6  10\n 7  11\n\njulia> x[1, [2 3; 4 1]]\n2×2 Array{Int64,2}:\n  5  9\n 13  1Los rangos vacío de la forma n:n-1 se suelen usar para indicar la localización inter-index entre n-1 y n. Por ejemplo, la función searchsorted() usa esta convención para indicar el punto de inserción de un valor no encontrados en un array ordenado:julia> a = [1,2,5,6,7];\n\njulia> searchsorted(a, 3)\n3:2"
},

{
    "location": "manual/arrays.html#Asignación-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Asignación",
    "category": "section",
    "text": "La sintaxis general para asignar valores en un array n-dimensional A es:A[I_1, I_2, ..., I_n] = Xdonde cada I_k puede ser un índice escalar, un array de enteros o cualquier otro índice soportado. Esto incluye Colon (:) para seleccionar todos los índices dentro de la dimensión completa, rangos de la forma a:c o a:b:c para seleccionar subsecciones contiguas o con salto, y arrays de booleans para seleccionar elementos en sus índices true.Si X es un array, debe tener el mismo número de elementos que el producto de las longitudes de los índices prod(length(I_1), length(I_2), ..., length(I_n)). El valor en la localización I_1[i_1], I_2[i_2], ..., I_n[i_n]de A es sobreescrito con el valor X[i_1, i_2, ..., i_n]. Si X no es un array, su valor es escrito a todas las localizaciones referenciadas de A.Justo como en Indexación, la palabra clave end puede utilizarse para representar el último índice de cada dimensión dentro de los corchetes de los índices, como queda determinado por el tamaño del array en el que se está siendo asignado. La sintaxis de la asignación indexada sin la palabra clave end es equivalente a llamar a la función setindex!():setindex!(A, X, I_1, I_2, ..., I_n)Ejemplo:julia> x = collect(reshape(1:9, 3, 3))\n3×3 Array{Int64,2}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> x[1:2, 2:3] = -1\n-1\n\njulia> x\n3×3 Array{Int64,2}:\n 1  -1  -1\n 2  -1  -1\n 3   6   9"
},

{
    "location": "manual/arrays.html#man-supported-index-types-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Tipos de Índices Soportados",
    "category": "section",
    "text": "En la expresión A[I_1, I_2, ..., I_n], cada I_k puede ser un índice escalar, un array de índices escalares o un objeto que repreenta un array de índices escalares y puede ser convertido a tal mediante to_indices:Un índice escalar. Por defecto esto incluye:\nEnteros no booleanos\nCartesianIndex{N}s, que se comportan como una N-tupla de enteros abarcando múltiples dimensiones (ver abajo para ms detalles)\nUn array de índices escalares. Esto incluye:\nVectores y arrays multidimensionales de enteros\nArrays vacíos como [], que no selecciona elementos\nRanges de la forma a:c o a:b:c, que seleccionan subsecciones contiguas o con salto desde a hasta c (inclusive)\nCualquier array de índices escalares que sea un subtipo de AbstractArray\nArrays de CartesianIndex{N} (ver abajo para ms detalles)\nUn objeto que representa un array de índice escalares y puede ser convertido a tal mediante to_indices. Por defecto esto incluye:\nColon() (:), que representa todos los índices dentro de una dimensión entera o a través del array completo\nArrays de booleans, que seleccionan los elementos en los que sus índices son true indices (ver abajo para más detalles)"
},

{
    "location": "manual/arrays.html#Índices-Cartesianos-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Índices Cartesianos",
    "category": "section",
    "text": "El objeto especial CartesianIndex{N} representa un índice escalar que se comporta como una N-tupla de enteros que abarcan multiples dimensioneas. Por ejemplo:julia> A = reshape(1:32, 4, 4, 2);\n\njulia> A[3, 2, 1]\n7\n\njulia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7\ntrueConsiderado solo, esto puede parecer relativamente trivial; CartesianIndex simplemente reúne múltiples enteros juntos en un objeto que representa un único índice multidimensional. Sin embargo, cuando se combina con otras formas de indexación e iteradores que producen CartesianIndexes, esto puede conducir directamente a un código muy elegante y eficiente. Ver Iteración a continuación, y para algunos ejemplos más avanzados, ver esta publicación en el blog sobre algoritmos multidimensionales e iteración.Los arrays de CartesianIndex{N} también sestán soportados. Representan una colección de índices escalares que abarcan   N dimensiones cada uno, lo que permite una forma de indexación que a veces se denomina indexación puntual. Por ejemplo, permite acceder a los elementos diagonales desde la primera \"página\" de 'A' desde arriba:julia> page = A[:,:,1]\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> page[[CartesianIndex(1,1),\n             CartesianIndex(2,2),\n             CartesianIndex(3,3),\n             CartesianIndex(4,4)]]\n4-element Array{Int64,1}:\n  1\n  6\n 11\n 16Esto se puede expresar mucho más simplemente con dot broadcasting y combinándolo con un índice entero normal (en lugar de extraer la primera página deA como un paso separado). Incluso se puede combinar con : para extraer ambas diagonales de las dos páginas al mismo tiempo:julia> A[CartesianIndex.(indices(A, 1), indices(A, 2)), 1]\n4-element Array{Int64,1}:\n  1\n  6\n 11\n 16\n\njulia> A[CartesianIndex.(indices(A, 1), indices(A, 2)), :]\n4×2 Array{Int64,2}:\n  1  17\n  6  22\n 11  27\n 16  32warning: Warning\nCartesianIndex y los arrays de CartesianIndex no son compatibles con la palabra   clave end que representa el último índice de una dimensión. No usaremos end     cuando se indexen expresiones que puedan contener CartesianIndex or arrays de ellos."
},

{
    "location": "manual/arrays.html#Indexación-Lógica-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Indexación Lógica",
    "category": "section",
    "text": "A menudo denominada indexación lógica o indexación con una máscara lógica, la indexación mediante  una matriz booleana selecciona elementos en los índices cuyos valores son verdaderos. La indexación por un vector booleano B es efectivamente igual a la indexación por el vector de enteros que es devuelto por find (B). De forma similar, la indexación por una matriz booleana N-dimensional es efectivamente igual a la indexación por el vector de CartesianIndex{N}s donde sus valores son true. Un índice lógico debe ser un vector de la misma longitud que la dimensión en la que indexa, o debe ser el único índice proporcionado y debe coincidir con el tamaño y la dimensionalidad de la matriz en la que se indexa. En general, es más eficiente usar matrices booleanas como índices directamente en lugar de llamar primero a find().julia> x = reshape(1:16, 4, 4)\n4×4 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> x[[false, true, true, false], :]\n2×4 Array{Int64,2}:\n 2  6  10  14\n 3  7  11  15\n\njulia> mask = map(ispow2, x)\n4×4 Array{Bool,2}:\n  true  false  false  false\n  true  false  false  false\n false  false  false  false\n  true   true  false   true\n\njulia> x[mask]\n5-element Array{Int64,1}:\n  1\n  2\n  4\n  8\n 16"
},

{
    "location": "manual/arrays.html#Iteración-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Iteración",
    "category": "section",
    "text": "Las formas recomendadas de iterar sobre un array completo son:for a in A\n    # Do something with the element a\nend\n\nfor i in eachindex(A)\n    # Do something with i and/or A[i]\nendLa primera construcción se usa cuando necesitamos el valor, pero no los índices, de cada elemento. En la segunda construcción, i será un Int si A es un tipo array con indexación lineal rápida; en caso contrario será un CartesianIndex:julia> A = rand(4,3);\n\njulia> B = view(A, 1:3, 2:3);\n\njulia> for i in eachindex(B)\n           @show i\n       end\ni = CartesianIndex{2}((1, 1))\ni = CartesianIndex{2}((2, 1))\ni = CartesianIndex{2}((3, 1))\ni = CartesianIndex{2}((1, 2))\ni = CartesianIndex{2}((2, 2))\ni = CartesianIndex{2}((3, 2))En contraste con for i = 1:length(A), iterar con eachindex proporciona una forma eficiente de iterar sobre cualquier tipo de array."
},

{
    "location": "manual/arrays.html#Rasgos-de-Array-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Rasgos de  Array",
    "category": "section",
    "text": "Si uno escribe un tipo AbstractArray personalizado, uno puede especificar que el tipo tiene indexación lineal rápida usando:Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()Esta configuración hará que la iteración eachindex sobre un objeto MyArray use enteros. Si no especifica este rasgo, se usa el valor predeterminado IndexCartesian()."
},

{
    "location": "manual/arrays.html#Arrays,-Funciones-y-Operadores-Vectorizados-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Arrays, Funciones y Operadores Vectorizados",
    "category": "section",
    "text": "Los siguientes operadores están soportados para arrays:Aritmética unaria – -, +\nAritmética binaria – -, +, *, /, \\, ^\nComparación – ==, !=, ≈ (isapprox), ≉La mayoría de los operadores aritméticos binarios enumerados anteriormente también funcionan elemento a elemento cuando un argumento es escalar: -, +, y *cuando cualquiera de los argumentos es escalar, y / y \\ cuando el denominador es escalar. Por ejemplo, [1, 2] + 3 == [4, 5] y [6, 4] / 2 == [3, 2].Además, para permitir una conveniente vectorización de operaciones matemáticas y de otro tipo, Julia proporciona la sintaxis punto f.(args ...), por ejemplo, sin.(x) o min.(x, y), para operaciones con elementos sobre arrays o mezclas de matrices y escalares (una Retransmisión (broadcasting)); estos tienen la ventaja adicional de \"fusión\" en un solo bucle cuando se combina con otras llamadas de puntos, por ejemplo, sin.(cos.(x))También, cada operador binario admite una versión de punto que se puede aplicar a matrices (y combinaciones de matrices y escalares) en tales operaciones de retransmisión fusionadas, por ejemplo, z .== sin.(x. * y).Tenga en cuenta que las comparaciones como == operan en arrays completos, dando un solo booleano como respuesta. Use operadores de punto como .== para comparaciones elemento a elemento. (Para operaciones de comparación como <, solo la versión de elementos .< es aplicable a las matrices).También note la diferencia entre max.(a, b), que retransmitir max() elemento a elemento sobre a yb, y maximum(a), que encuentra el mayor valor dentro de a. La misma relación se cumple para min.(A, b) y minimum(a)."
},

{
    "location": "manual/arrays.html#broadcasting-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Retransmisión",
    "category": "section",
    "text": "A veces es útil realizar operaciones binarias elemento por elemento en matrices de diferentes tamaños, como agregar un vector a cada columna de una matriz. Una forma ineficiente de hacer esto sería replicar el vector al tamaño de la matriz:julia> a = rand(2,1); A = rand(2,3);\n\njulia> repmat(a,1,3)+A\n2×3 Array{Float64,2}:\n 1.20813  1.82068  1.25387\n 1.56851  1.86401  1.67846Esto es un desperdicio cuando las dimensiones son grandes, por lo que Julia ofrece broadcast(), que expande las dimensiones singleton en los argumentos array para hacer coincidir la dimensión correspondiente en el otro array sin usar memoria extra, y aplicar la función dada elemento a elemento:julia> broadcast(+, a, A)\n2×3 Array{Float64,2}:\n 1.20813  1.82068  1.25387\n 1.56851  1.86401  1.67846\n\njulia> b = rand(1,2)\n1×2 Array{Float64,2}:\n 0.867535  0.00457906\n\njulia> broadcast(+, a, b)\n2×2 Array{Float64,2}:\n 1.71056  0.847604\n 1.73659  0.873631Los operadores con punto tales como .+ y .* son equivalentes a llamadas a broadcast (excepto que se funden, como se describe a continuación). También hay una función broadcast!() para especificar un destino explícito (al que también se puede acceder por fusión mediante asignación .=), y funciones broadcast_getindex() y broadcast_setindex! () que retransmiten los índices antes de indexar. Además, f. (Args ...) es equivalente a broadcast(f, args ...), proporcionando una sintaxis conveniente para retransmitir cualquier función (sintaxis punto). \"Llamadas punto\" anidadas f.(...) (incluidas las llamadas a .+ Etcétera) fusibles automáticamente en una sola llamada broadcast.Además, broadcast () no está limitado a los array (ver la documentación de la función), también maneja tuplas y trata cualquier argumento que no sea un array, tupla o Ref (excepto paraPtr ) como un \"escalar\".julia> convert.(Float32, [1, 2])\n2-element Array{Float32,1}:\n 1.0\n 2.0\n\njulia> ceil.((UInt8,), [1.2 3.4; 5.6 6.7])\n2×2 Array{UInt8,2}:\n 0x02  0x04\n 0x06  0x07\n\njulia> string.(1:3, \". \", [\"First\", \"Second\", \"Third\"])\n3-element Array{String,1}:\n \"1. First\"\n \"2. Second\"\n \"3. Third\""
},

{
    "location": "manual/arrays.html#Implementation-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Implementation",
    "category": "section",
    "text": "El tipo de matriz base en Julia es el tipo abstracto AbstractArray {T, N}. Este tipo está parametrizado por el número de dimensiones N y el tipo de elementos T. AbstractVector y AbstractMatrix son aliases para los casos 1-d y 2-d. Las operaciones en los objetos AbstractArray se definen usando operadores y funciones de alto nivel, de  manera que es independiente del almacenamiento subyacente. Estas operaciones generalmente funcionan correctamente como una alternativa para cualquier implementación de matriz específica.El tipo AbstractArray incluye algo vagamente parecido a un array, y las implementaciones de este podrían ser bastante diferentes de los arrays convencionales. Por ejemplo, los elementos se pueden calcular a petición en lugar de ser almacenados. Sin embargo, cualquier tipo concreto de AbstractArray{T, N} debería implementar al menos size(A) (que devolvería una tupla Int), getindex(A,i) y getindex(A, i1, ..., iN); Los arrays mutables también deberían implementar setindex!(). Se recomienda que estas operaciones tengan complejidad temporal casi constante, o técnicamente complejidad de orden 1 (Õ(1)), ya que de lo contrario algunas funciones podrían ser inesperadamente lentas. Los tipos concretos también deberían proporcionar un método similar(A,T=eltype(A),dims=size(A)), que se utiliza para asignar un conjunto similar para copy() y otras operaciones de actualización. No importa cómo se represente internamente un AbstractArray {T, N}, T es el tipo de objeto devuelto por la indización entera (A [1, ..., 1], cuando A no está vacío) yN debe ser la longitud de la tupla devuelta por size().DenseArray es un subtipo abstracto deAbstractArray que pretende incluir todos los arrays que están establecidos en bloques regulares de memoria y que, por tanto, se puede pasar a funciones externas C y Fortran que esperan este diseño de memoria. Los subtipos deberían proporcionar un método stride(A,k) que devuelve el \"paso\" de la dimensión k; incrementar el índice de dimensión k en 1 debería incremental el índice i de getindex(A,i) en stride(A,k). Si se proporciona un método de conversión de puntero Base.unsafe_convert(Ptr{T}, A), el diseño de la memoria debe corresponder de la misma manera a estos pasos.El tipo Array es una instancia específica de DenseArray donde los elementos se almacenan en orden de columnas principales (consulte notas adicionales en Sugerencias de rendimiento). Vector y Matrix son alias para los casos 1-d y 2-d. Las operaciones específicas como la indexación escalar, la asignación y algunas otras operaciones básicas específicas del almacenamiento son todas las que tienen que estar implementadas en  Array, de modo que el resto de la biblioteca de arrays puede implementarse de forma genérica.SubArray es una especialización de AbstractArray que realiza indexación por referencia en lugar de por copia. Un SubArray se crea con la función view(), que es llamada de la misma manera que getindex() (con una matriz y una serie de argumentos de índice) . El resultado de view() se ve igual que el resultado de getindex(), excepto que los datos se dejan en su lugar. view() almacena los vectores de índice de entrada en un objeto SubArray, que luego puede usarse para indexar la matriz original de forma indirecta. Al colocar la macro @views delante de una expresión o bloque de código, cualquier segmento array[...] en esa expresión se convertirá para crear una vista SubArray en su lugar.StridedVector yStridedMatrix son alias convenientes definidos para que Julia pueda llamar a un rango más amplio de funciones BLAS y LAPACK pasándoles objetos Array o SubArray, y ahorrando así ineficiencias de asignación de memoria y copia.El siguiente ejemplo calcula la descomposición QR de una pequeña sección de una matriz más grande, sin crear ningún array temporal, y llamando a la función LAPACK apropiada con los parámetros de tamaño de dimensión y salto correctos.julia> a = rand(10,10)\n10×10 Array{Float64,2}:\n 0.561255   0.226678   0.203391  0.308912   …  0.750307  0.235023   0.217964\n 0.718915   0.537192   0.556946  0.996234      0.666232  0.509423   0.660788\n 0.493501   0.0565622  0.118392  0.493498      0.262048  0.940693   0.252965\n 0.0470779  0.736979   0.264822  0.228787      0.161441  0.897023   0.567641\n 0.343935   0.32327    0.795673  0.452242      0.468819  0.628507   0.511528\n 0.935597   0.991511   0.571297  0.74485    …  0.84589   0.178834   0.284413\n 0.160706   0.672252   0.133158  0.65554       0.371826  0.770628   0.0531208\n 0.306617   0.836126   0.301198  0.0224702     0.39344   0.0370205  0.536062\n 0.890947   0.168877   0.32002   0.486136      0.096078  0.172048   0.77672\n 0.507762   0.573567   0.220124  0.165816      0.211049  0.433277   0.539476\n\njulia> b = view(a, 2:2:8,2:2:4)\n4×2 SubArray{Float64,2,Array{Float64,2},Tuple{StepRange{Int64,Int64},StepRange{Int64,Int64}},false}:\n 0.537192  0.996234\n 0.736979  0.228787\n 0.991511  0.74485\n 0.836126  0.0224702\n\njulia> (q,r) = qr(b);\n\njulia> q\n4×2 Array{Float64,2}:\n -0.338809   0.78934\n -0.464815  -0.230274\n -0.625349   0.194538\n -0.527347  -0.534856\n\njulia> r\n2×2 Array{Float64,2}:\n -1.58553  -0.921517\n  0.0       0.866567"
},

{
    "location": "manual/arrays.html#Vectores-y-Matrices-*Sparse*-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Vectores y Matrices Sparse",
    "category": "section",
    "text": "Julia tiene soporte integrado para vectores y matrices dispersas (sparse). Las matrices sparse son matrices que contienen suficientes ceros para almacenarlos en una estructura de datos especial que ahorra espacio y tiempo de ejecución, en comparación con las matrices densas."
},

{
    "location": "manual/arrays.html#man-csc-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Columna Comprimida Sparse (CSC) Para Almacenamiento de Matrices Sparse",
    "category": "section",
    "text": "En Julia, las matrices dispersas se almacenan en el formato Compressed Sparse Column (CSC). Las matrices sparse de Julia tienen el tipo SparseMatrixCSC{Tv,Ti}, donde Tv es el tipo de los valores almacenados, yTi es el tipo entero para almacenar punteros de columnas e índices de filas. La representación interna de SparseMatrixCSC es la siguiente:struct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}\n    m::Int                  # Number of rows\n    n::Int                  # Number of columns\n    colptr::Vector{Ti}      # Column i is in colptr[i]:(colptr[i+1]-1)\n    rowval::Vector{Ti}      # Row indices of stored values\n    nzval::Vector{Tv}       # Stored values, typically nonzeros\nendEl almacenamiento de columnas dispersas y comprimidas (CSC) facilita y agiliza el acceso a los elementos en la columna de una matriz sparse, mientras que el acceso a la matriz sparse por filas es considerablemente más lento. Las operaciones como la inserción de entradas previamente no almacenadas de una en una en la estructura de CSC tienden a ser lentas. Esto se debe a que todos los elementos de la matriz sparse que están más allá del punto de inserción deben moverse un lugar más.Todas las operaciones en matrices sparse se implementan cuidadosamente para aprovechar la estructura de datos CSC para el rendimiento y para evitar operaciones costosas.Si tiene datos en formato CSC desde una aplicación o biblioteca diferente, y desea importarlos a Julia, asegúrese de utilizar la indexación basada en 1. Los índices de fila en cada columna deben estar ordenados. Si su objeto SparseMatrixCSC contiene índices de filas sin ordenar, una forma rápida de ordenarlos es hacer una doble transposición.En algunas aplicaciones, es conveniente almacenar valores cero explícitos en una SparseMatrixCSC. Estas son aceptadas por funciones en Base (pero no hay garantía de que se conservarán en las operaciones de mutación). Tales ceros explícitamente almacenados son tratados como no estructurales por muchas rutinas. La función nnz() devuelve la cantidad de elementos almacenados explícitamente en la estructura de datos dispersos, incluidos los no-ceros estructurales. Para contar el número exacto de nozeros numéricos, use countnz(), que inspecciona todos los elementos almacenados en un a matriz sparse. dropzeros(), y dropzeros!(), se puede usar para eliminar ceros almacenados de la matriz dispersa.julia> A = sparse([1, 2, 3], [1, 2, 3], [0, 2, 0])\n3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [1, 1]  =  0\n  [2, 2]  =  2\n  [3, 3]  =  0\n\njulia> dropzeros(A)\n3×3 SparseMatrixCSC{Int64,Int64} with 1 stored entry:\n  [2, 2]  =  2"
},

{
    "location": "manual/arrays.html#Almacenamiento-de-Vectores-*Sparse*-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Almacenamiento de Vectores Sparse",
    "category": "section",
    "text": "Los vectores sparse se almacenan en un formato de columna análogo al que se usa en las matrices sparse. En Julia, los vectores sparse tienen el tipo SparseVector{Tv,Ti} donde Tv es el tipo de los valores almacenados yTi el tipo entero para los índices. La representación interna es la siguiente:struct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}\n    n::Int              # Length of the sparse vector\n    nzind::Vector{Ti}   # Indices of stored values\n    nzval::Vector{Tv}   # Stored values, typically nonzeros\nendEn cuanto a SparseMatrixCSC, el tipo SparseVector también puede contener ceros almacenados explícitamente. (Consulte Almacenamiento de matriz sparse.)."
},

{
    "location": "manual/arrays.html#Constructores-de-Vectores-y-Matrices-*Sparse*-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Constructores de Vectores y Matrices Sparse",
    "category": "section",
    "text": "La forma más sencilla de crear matrices sparse es usar funciones equivalentes a las funciones zeros() y eye() que proporciona Julia para trabajar con matrices densas. Para producir matrices sparse en su lugar, puede usar los mismos nombres con el prefijo sp:julia> spzeros(3)\n3-element SparseVector{Float64,Int64} with 0 stored entries\n\njulia> speye(3,5)\n3×5 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0La función sparse() suele ser una forma útil de construir arrays sparse. Por ejemplo, para construir una matriz sparse, podemos ingresar un vector I de índices de fila, un vectorJ de índices de columna, y un vector V de valores almacenados (esto también se conoce como formato COO (coordenada)). sparse (I,J,V) construye una matriz sparse tal que S[I[k], J[k]] = V[k]. El constructor de vector sparse equivalente es sparsevec, que toma el vector de índices (fila) I y el vector V con los valores almacenados y construye un vector sparse R tal que R[I[k]] = V[k].julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];\n\njulia> S = sparse(I,J,V)\n5×18 SparseMatrixCSC{Int64,Int64} with 4 stored entries:\n  [1 ,  4]  =  1\n  [4 ,  7]  =  2\n  [5 ,  9]  =  3\n  [3 , 18]  =  -5\n\njulia> R = sparsevec(I,V)\n5-element SparseVector{Int64,Int64} with 4 stored entries:\n  [1]  =  1\n  [3]  =  -5\n  [4]  =  2\n  [5]  =  3La inversa de las funciones sparse() y sparsevec es findnz(), que recupera las entradas utilizadas para crear el array sparse. También hay una función findn que solo devuelve los vectores índice.julia> findnz(S)\n([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])\n\njulia> findn(S)\n([1, 4, 5, 3], [4, 7, 9, 18])\n\njulia> findnz(R)\n([1, 3, 4, 5], [1, -5, 2, 3])\n\njulia> findn(R)\n4-element Array{Int64,1}:\n 1\n 3\n 4\n 5Otra forma de crear un array sparse es convertir un array denso en un array sparse usando la función sparse():julia> sparse(eye(5))\n5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n  [4, 4]  =  1.0\n  [5, 5]  =  1.0\n\njulia> sparse([1.0, 0.0, 1.0])\n3-element SparseVector{Float64,Int64} with 2 stored entries:\n  [1]  =  1.0\n  [3]  =  1.0Puede ir en la otra dirección usando el constructor Array. La función issparse() se puede usar para consultar si una matriz es o no sparse.julia> issparse(speye(5))\ntrue"
},

{
    "location": "manual/arrays.html#Operaciones-con-matrices-*sparse*-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Operaciones con matrices sparse",
    "category": "section",
    "text": "Las operaciones aritméticas en matrices sparse también funcionan como lo hacen en matrices densas. La indexación de, la asignación en y la concatenación de matrices sparse funcionan de la misma manera que las matrices densas. Las operaciones de indexación, especialmente la asignación, son costosas, cuando se llevan a cabo un elemento cada vez. En muchos casos, puede ser mejor convertir la matriz dispersa en formato (I,J,V) usando findnz(), manipular los valores o la estructura en los vectores densos (I,J,V), y luego reconstruir la matriz sparse."
},

{
    "location": "manual/arrays.html#Correspondence-of-dense-and-sparse-methods-1",
    "page": "Arrays Multi-dimensionales",
    "title": "Correspondence of dense and sparse methods",
    "category": "section",
    "text": "La siguiente tabla proporciona una correspondencia entre los métodos incorporados en matrices sparse y sus métodos correspondientes en tipos de matrices densas. En general, los métodos que generan matrices sparse difieren de sus contrapartes densas en que la matriz resultante sigue el mismo patrón de dispersión que una matriz sparse dada S, o que la matriz sparse resultante tiene densidad d, es decir, cada elemento de matriz tiene una probabilidad d de ser diferente de cero.Los detalles se pueden encontrar en la sección Vectores y Matrices Sparse de la referencia de biblioteca estándar.Sparse Dense Description\nspzeros(m,n) zeros(m,n) Creates a m-by-n matrix of zeros. (spzeros(m,n) is empty.)\nspones(S) ones(m,n) Creates a matrix filled with ones. Unlike the dense version, spones() has the same sparsity pattern as S.\nspeye(n) eye(n) Creates a n-by-n identity matrix.\nfull(S) sparse(A) Interconverts between dense and sparse formats.\nsprand(m,n,d) rand(m,n) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed uniformly on the half-open interval 0 1).\nsprandn(m,n,d) randn(m,n) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.\nsprandn(m,n,d,X) randn(m,n,X) Creates a m-by-n random matrix (of density d) with iid non-zero elements distributed according to the X distribution. (Requires the Distributions package.)"
},

{
    "location": "manual/linear-algebra.html#",
    "page": "Álgebra Lineal",
    "title": "Álgebra Lineal",
    "category": "page",
    "text": ""
},

{
    "location": "manual/linear-algebra.html#linear-algebra-1",
    "page": "Álgebra Lineal",
    "title": "Álgebra Lineal",
    "category": "section",
    "text": "Además de (y como parte de) su soporte a los arrays multidimensionales, Julia proporciona implementaciones nativas de muchas operaciones de álgebra lineal comunes y útiles. Las operaciones básicas tales como la traza (trace), el determinante (det) y la inversa (inv) están todas soportadas:julia> A = [1 2 3; 4 1 6; 7 8 1]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  1  6\n 7  8  1\n\njulia> trace(A)\n3\n\njulia> det(A)\n104.0\n\njulia> inv(A)\n3×3 Array{Float64,2}:\n -0.451923   0.211538    0.0865385\n  0.365385  -0.192308    0.0576923\n  0.240385   0.0576923  -0.0673077Así como otras operaciones útiles, como buscar autovalores o autovectores:julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]\n3×3 Array{Float64,2}:\n   1.5   2.0  -4.0\n   3.0  -1.0  -6.0\n -10.0   2.3   4.0\n\njulia> eigvals(A)\n3-element Array{Complex{Float64},1}:\n  9.31908+0.0im\n -2.40954+2.72095im\n -2.40954-2.72095im\n\njulia> eigvecs(A)\n3×3 Array{Complex{Float64},2}:\n -0.488645+0.0im  0.182546-0.39813im   0.182546+0.39813im\n -0.540358+0.0im  0.692926+0.0im       0.692926-0.0im\n   0.68501+0.0im  0.254058-0.513301im  0.254058+0.513301imAdemás, Julia proporciona muchas factorizaciones que pueden usarse para acelerar problemas como la resolución lineal o la exponenciación de matrices mediante la pre-factorización de una matriz en una forma más adecuada (por razones de rendimiento o memoria) ) al problema. Consulte la documentación en factorize para obtener más información. Como ejemplo:julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]\n3×3 Array{Float64,2}:\n   1.5   2.0  -4.0\n   3.0  -1.0  -6.0\n -10.0   2.3   4.0\n\njulia> factorize(A)\nBase.LinAlg.LU{Float64,Array{Float64,2}} with factors L and U:\n[1.0 0.0 0.0; -0.15 1.0 0.0; -0.3 -0.132196 1.0]\n[-10.0 2.3 4.0; 0.0 2.345 -3.4; 0.0 0.0 -5.24947]Como A no es hermítica, simétrica, triangular o bidiagonal, una factorización LU puede ser lo mejor que podemos hacer. Compara con:julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n3×3 Array{Float64,2}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> factorize(B)\nBase.LinAlg.BunchKaufman{Float64,Array{Float64,2}}([-1.64286 0.142857 -0.8; 2.0 -2.8 -0.6; -4.0 -3.0 5.0], [1, 2, 3], 'U', true, false, 0)Aquí, Julia fue capaz de detectar que B es de hecho simetrica, y usa una factorizacíon más apropiada. Frecuentemente es posible escribir código ms eficiente para una matriz de la que se conocen ciertas propiedades como que sea simétrica o diagonal. Julia proporciona algunos tipos especiales para que uno pueda \"etiquetar\" las matrices que tengan estas propiedades. Por ejemplo:julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n3×3 Array{Float64,2}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> sB = Symmetric(B)\n3×3 Symmetric{Float64,Array{Float64,2}}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0sB ha sido etiquetada como una matriz que es simétrica (real) por lo que para algunas operacioneas que podríamos hacer sobre ella, tal como la autofactorización o calbular productos matriz-vector, pueden encontrarse eficiencias sólo referenciando la mitad de ella. Por ejemplo:julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]\n3×3 Array{Float64,2}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> sB = Symmetric(B)\n3×3 Symmetric{Float64,Array{Float64,2}}:\n  1.5   2.0  -4.0\n  2.0  -1.0  -3.0\n -4.0  -3.0   5.0\n\njulia> x = [1; 2; 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> sB\\x\n3-element Array{Float64,1}:\n -1.73913\n -1.1087\n -1.45652La operación \\ realiza aquí la resolución de la ecuación lineal. El analizador sintáctico de Julia proporciona un despacho conveniente para métodos especializados para la transpuesta de una matriz o una matriz dividida por la izquierda por un vector, o para las distintas combinaciones u operacioneas de transposición en soluciones matriz-matriz. Muchas de ellas son incluso más especializadas para ciertos tipos especiales de matrices. Por ejemplo, A\\B acabará llamando a Base.LinAlg.A_ldiv_B! mientras que A'\\B acabará llamando a Base.LinAlg.Ac_ldiv_B, incluso aunque usáramos el mismo operador de división por la izquierda. Esto funcionea también para matrices: A.'\\B.' invocará a Base.LinAlg.At_ldiv_Bt. El operador de división por la izquierda es muy potente y es fácil escribir código compacto y bastante legible para resolver todo tipo de sistemas de ecuaciones lineales."
},

{
    "location": "manual/linear-algebra.html#Matrices-Especiales-1",
    "page": "Álgebra Lineal",
    "title": "Matrices Especiales",
    "category": "section",
    "text": "Las matrices con simetrías y estructuras especiales surgen a menudo en el álgebra lineal y frecuentemente se asocian con varias factorizaciones matriciales. Julia presenta una rica colección de tipos de matrices especiales, que permiten un cálculo rápido con rutinas especializadas que están especialmente desarrolladas para estos tipos particuales de matrices.Las siguientes tablas resumen los tipos de matrices especiales que se han implementado en Julia, así como si están disponibles ganchos para varios métodos optimizados para ellos en LAPACK.Type Description\nHermitian       Matriz hermítica              \nUpperTriangular Matriz triangular superior\nLowerTriangular Matriz triangular inferior\nTridiagonal Matriz tridiagonal\nSymTridiagonal Matriz tridiagonal simétrica                                                    \nBidiagonal Matriz bidiagonal superior/inferior\nDiagonal Matriz diagonal\nUniformScaling Operador escalado uniforme"
},

{
    "location": "manual/linear-algebra.html#Operaciones-elementales-1",
    "page": "Álgebra Lineal",
    "title": "Operaciones elementales",
    "category": "section",
    "text": "Tipo de matriz           + - * \\ Otras funciones con métodos optimizados                            \nHermitian       MV inv(), sqrtm(), expm()\nUpperTriangular     MV MV inv(), det()\nLowerTriangular     MV MV inv(), det()\nSymTridiagonal M M MS MV eigmax(), eigmin()\nTridiagonal M M MS MV  \nBidiagonal M M MS MV  \nDiagonal M M MV MV inv(), det(), logdet(), /()\nUniformScaling M M MVS MVS /()Legend:Clave     Descripción                                                  \nM (matrix) An optimized method for matrix-matrix operations is available\nV (vector) An optimized method for matrix-vector operations is available\nS (scalar) An optimized method for matrix-scalar operations is available"
},

{
    "location": "manual/linear-algebra.html#Factorizaciones-de-matrices-1",
    "page": "Álgebra Lineal",
    "title": "Factorizaciones de matrices",
    "category": "section",
    "text": "Matrix type LAPACK eig() eigvals() eigvecs() svd() svdvals()\nHermitian HE   ARI      \nUpperTriangular TR A A A    \nLowerTriangular TR A A A    \nSymTridiagonal ST A ARI AV    \nTridiagonal GT          \nBidiagonal BD       A A\nDiagonal DI   A      Legend:Key Description Example\nA (all) An optimized method to find all the characteristic values and/or vectors is available e.g. eigvals(M)\nR (range) An optimized method to find the ilth through the ihth characteristic values are available eigvals(M, il, ih)\nI (interval) An optimized method to find the characteristic values in the interval [vl, vh] is available eigvals(M, vl, vh)\nV (vectors) An optimized method to find the characteristic vectors corresponding to the characteristic values x=[x1, x2,...] is available eigvecs(M, x)"
},

{
    "location": "manual/linear-algebra.html#El-operador-de-escalado-uniforme-1",
    "page": "Álgebra Lineal",
    "title": "El operador de escalado uniforme",
    "category": "section",
    "text": "Un operador UniformScaling representa un escalar multiplicado por el operador de identidad, λ*I. El operador de identidad I se define como una constante y es una instancia de UniformScaling. El tamaño de estos operadores es genérico y coincide con la otra matriz en las operaciones binarias +, -, * y \\. Para A+I yA-I esto significa que A debe ser cuadrado. La multiplicación con el operador de identidad I es un noop (excepto para comprobar que el factor de escala es uno) y, por lo tanto, casi sin sobrecarga."
},

{
    "location": "manual/linear-algebra.html#man-linalg-factorizations-1",
    "page": "Álgebra Lineal",
    "title": "Factorizaciones de matrices",
    "category": "section",
    "text": "las factorizaciones de matrices (a.k.a. descomposiciones de matrices) calculan la factorizacin de una matriz en un producto de matrices, y son uno de los conceptos centrales del álgebra lineal.La siguiente tabla resume los tipos de factorizaciones de matrices que han sido implementados en Julia. En la sección Linear Algebra de la documentación de la librería estándar pueden encontrarse más detalles de los métodos asociados.Type Description\nCholesky Cholesky factorization\nCholeskyPivoted Pivoted Cholesky factorization\nLU LU factorization\nLUTridiagonal LU factorization for Tridiagonal matrices\nUmfpackLU LU factorization for sparse matrices (computed by UMFPack)\nQR QR factorization\nQRCompactWY Compact WY form of the QR factorization\nQRPivoted Pivoted QR factorization\nHessenberg Hessenberg decomposition\nEigen Spectral decomposition\nSVD Singular value decomposition\nGeneralizedSVD Generalized SVD"
},

{
    "location": "manual/networking-and-streams.html#",
    "page": "Redes y Flujos",
    "title": "Redes y Flujos",
    "category": "page",
    "text": ""
},

{
    "location": "manual/networking-and-streams.html#networking-and-streams-1",
    "page": "Redes y Flujos",
    "title": "Redes y Flujos",
    "category": "section",
    "text": "Julia proporciona una interfaz rica para tratar objetos que representen un flujo contínuo de E/S como terminales, tuberías y sockets TCP. Esta interfaz, aunque asíncrona a nivel del sistema, se presenta de forma síncrona al programador y normalmente no es necesario pensar en la operación asincrónica subyacente. Esto se logra haciendo un uso intensivo de la funcionalidad de los hilos cooperativos en Julia (o corrutinas)."
},

{
    "location": "manual/networking-and-streams.html#Flujos-de-E/S-básico-1",
    "page": "Redes y Flujos",
    "title": "Flujos de E/S básico",
    "category": "section",
    "text": "Todos los flujos en Julia exponen al menos un método read() y un write(), tomando el flujo como su primer argumento, por ejemplo:julia> write(STDOUT,\"Hello World\");  # suppress return value 11 with ;\nHello World\njulia> read(STDIN,Char)\n\n'\\n': ASCII/Unicode U+000a (category Cc: Other, control)Tenga en cuenta que write() devuelve 11, el número de bytes (en \"Hello World\") escrito en STDOUT, pero este valor de retorno se suprime con ;.Aquí Enter fue presionado nuevamente para que Julia leyera la nueva línea. Ahora, como puede ver en este ejemplo, write() toma los datos para escribir como su segundo argumento, mientras que read() toma el tipo de datos para ser leído como el segundo argumento.Por ejemplo, para leer una matriz de bytes simple, podríamos hacer:julia> x = zeros(UInt8, 4)\n4-element Array{UInt8,1}:\n 0x00\n 0x00\n 0x00\n 0x00\n\njulia> read!(STDIN, x)\nabcd\n4-element Array{UInt8,1}:\n 0x61\n 0x62\n 0x63\n 0x64Sin embargo, dado que esto es un poco engorroso, se proporcionan varios métodos de conveniencia. Por ejemplo, podríamos haber escrito lo anterior como:julia> read(STDIN,4)\nabcd\n4-element Array{UInt8,1}:\n 0x61\n 0x62\n 0x63\n 0x64o si hubiéramos querido leer toda la línea en su lugar:julia> readline(STDIN)\nabcd\n\"abcd\"Tenga en cuenta que, dependiendo de la configuración de su terminal, su TTY puede estar almacenado en línea y, por lo tanto, podría requerir una entrada adicional antes de enviar los datos a Julia.Para leer cada línea desde STDIN, puede usar eachline():for line in eachline(STDIN)\n    print(\"Found $line\")\nendo read() si deseamos leer carácter a carácter en lugar de lo anterior:while !eof(STDIN)\n    x = read(STDIN, Char)\n    println(\"Found: $x\")\nend"
},

{
    "location": "manual/networking-and-streams.html#E/S-Texto-1",
    "page": "Redes y Flujos",
    "title": "E/S Texto",
    "category": "section",
    "text": "Note que el método write() mencionado arriba opera sobre flujos binarios. En particular, los valores no son convertidos a ninguna representación de texto canónica sino que son escritas tal cual:julia> write(STDOUT,0x61);  # suppress return value 1 with ;\naNote que a es escrito a STDOUT por la función write() y que el valor devuelto es 1 (ya que 0x61 es un byte).Para E/S texto, use los métodos print() o show() methods, dependiendo de sus necesidades (ver la referencia de la librería estándar para una discusin detallada de la diferencia entre las dos):julia> print(STDOUT, 0x61)\n97"
},

{
    "location": "manual/networking-and-streams.html#Propiedades-contextuales-de-salida-IO-1",
    "page": "Redes y Flujos",
    "title": "Propiedades contextuales de salida IO",
    "category": "section",
    "text": "En ocasiones, la salida de IO puede beneficiarse de la capacidad de pasar información contextual a los métodos de muestra. El objeto IOContext proporciona este marco para asociar metadatos arbitrarios con un objeto IO. Por ejemplo, showcompact agrega un parámetro de alusión al objeto IO para que el método del espectáculo invocado imprima un resultado más corto (si corresponde)."
},

{
    "location": "manual/networking-and-streams.html#Trabajando-con-Ficheros-1",
    "page": "Redes y Flujos",
    "title": "Trabajando con Ficheros",
    "category": "section",
    "text": "Al igual que muchos otros entornos, Julia tiene una función open(), que toma un nombre de archivo y devuelve un objeto IOStream que puede usar para leer y escribir cosas del archivo. Por ejemplo, si tenemos un archivo, hello.txt, cuyo contenido es Hello, World!:julia> f = open(\"hello.txt\")\nIOStream(<file hello.txt>)\n\njulia> readlines(f)\n1-element Array{String,1}:\n \"Hello, World!\"Si desea escribir a un fichero, puede abrirlo con el flag de escritura (\"w\"):julia> f = open(\"hello.txt\",\"w\")\nIOStream(<file hello.txt>)\n\njulia> write(f,\"Hello again.\")\n12Si examina el contenido de hello.txt en este punto, notará que está vacío; no se ha escrito nada en el disco todavía. Esto se debe a que el IOStream debe cerrarse antes de que la escritura realmente se vacíe en el disco:julia> close(f)Examinando hello.txt nuevamente mostrará que su contenido ha sido cambiado.Abrir un archivo, hacer algo con su contenido y volver a cerrarlo es un patrón muy común. Para hacerlo más fácil, existe otra invocación de open() que toma una función como su primer argumento y nombre de archivo como su segundo, abre el archivo, llama a la función con el archivo como argumento, y luego lo cierra de nuevo. Por ejemplo, dada una función:function read_and_capitalize(f::IOStream)\n    return uppercase(readstring(f))\nendUno puede llamar a:julia> open(read_and_capitalize, \"hello.txt\")\n\"HELLO AGAIN.\"para abrir hello.txt, llamar read_and_capitalize on it, cerrar hello.txt y devolver los contenidos capitalizados.Para incluso evitar tener que definir una función nombrada, puede usarse la sintaxis do, que crea una función anónima sobre la marcha:julia> open(\"hello.txt\") do f\n           uppercase(readstring(f))\n       end\n\"HELLO AGAIN.\""
},

{
    "location": "manual/networking-and-streams.html#Un-ejemplo-TCP-simple-1",
    "page": "Redes y Flujos",
    "title": "Un ejemplo TCP simple",
    "category": "section",
    "text": "Saltemos directamente con un ejemplo simple que involucra sockets TCP. Primero creemos un servidor simple:julia> @async begin\n           server = listen(2000)\n           while true\n               sock = accept(server)\n               println(\"Hello World\\n\")\n           end\n       end\nTask (runnable) @0x00007fd31dc11ae0Para quienes estén familiarizados con la API de socket de Unix, los nombres de los métodos se sentirán familiares, aunque su uso es algo más simple que la API de socket Raw de Unix. La primera llamada a listen() creará un servidor en espera de conexiones entrantes en el puerto especificado (2000) en este caso. La misma función también se puede usar para crear otros tipos de servidores:julia> listen(2000) # Listens on localhost:2000 (IPv4)\nTCPServer(active)\n\njulia> listen(ip\"127.0.0.1\",2000) # Equivalent to the first\nTCPServer(active)\n\njulia> listen(ip\"::1\",2000) # Listens on localhost:2000 (IPv6)\nTCPServer(active)\n\njulia> listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces\nTCPServer(active)\n\njulia> listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces\nTCPServer(active)\n\njulia> listen(\"testsocket\") # Listens on a UNIX domain socket/named pipe\nPipeServer(active)Tengase en cuenta que el tipo de retorno de la última invocación es diferente. Esto se debe a que este servidor no escucha en TCP, sino sobre una tubería nombrada (Windows) o socket de dominio UNIX. La diferencia es sutil y tiene que ver con los métodos accept() y connect(). El método accept() recupera una conexión con el cliente que se está conectando en el servidor que acabamos de crear, mientras que la función connect() se conecta a un servidor usando el método especificado. La función connect() toma los mismos argumentos que listen(), por lo tanto, suponiendo que el entorno (es decir, host, cwd, etc.) es el mismo uno debería capaz de pasar los mismos argumentos a connect() como lo se hizo para escuchar en el establecimiento de la conexión. Así que vamos a intentarlo (después de haber creado el servidor anterior):julia> connect(2000)\nTCPSocket(open, 0 bytes waiting)\n\njulia> Hello WorldComo era de esperar, vimos \"Hello World\" impreso. Entonces, analicemos realmente lo que sucedió detrás de escena. Cuando llamamos a connect(), nos conectamos al servidor que acabamos de crear. Mientras tanto, la función accept devuelve una conexión del lado del servidor al socket recién creado e imprime \"Hello World\" para indicar que la conexión fue exitosa.Una gran fortaleza de Julia es que, dado que la API se expone sincrónicamente a pesar de que la E/S realmente está sucediendo de forma asíncrona, no tuvimos que preocuparnos de las devoluciones de llamadas ni siquiera de asegurarnos de que el servidor se ejecute. Cuando llamamos a connect() la tarea actual esperó a que se estableciera la conexión y solo continuó ejecutándose después de que se hizo. En esta pausa, la tarea del servidor reanudó la ejecución (porque una solicitud de conexión ya estaba disponible), aceptó la conexión, imprimió el mensaje y esperó al próximo cliente. Leer y escribir funciona de la misma manera. Para ver esto, considere el siguiente servidor de eco simple:julia> @async begin\n           server = listen(2001)\n           while true\n               sock = accept(server)\n               @async while isopen(sock)\n                   write(sock,readline(sock))\n               end\n           end\n       end\nTask (runnable) @0x00007fd31dc12e60\n\njulia> clientside = connect(2001)\nTCPSocket(RawFD(28) open, 0 bytes waiting)\n\njulia> @async while true\n           write(STDOUT,readline(clientside))\n       end\nTask (runnable) @0x00007fd31dc11870\n\njulia> println(clientside,\"Hello World from the Echo Server\")\nHello World from the Echo ServerComo con otros flujos, use close() para desconectar el socket:julia> close(clientside)"
},

{
    "location": "manual/networking-and-streams.html#Resolviendo-Direcciones-IP-1",
    "page": "Redes y Flujos",
    "title": "Resolviendo Direcciones IP",
    "category": "section",
    "text": "Uno de los métodos connect() que no sigue los métodos listen() es connect(host::String, port), que intentará conectarse al host dado por el parámetro host en el puerto dado por el parámetro port. Te permite hacer cosas como:julia> connect(\"google.com\",80)\nTCPSocket(RawFD(30) open, 0 bytes waiting)En la base de esta funcionalidad está getaddrinfo(), que hará la resolución de dirección apropiada:julia> getaddrinfo(\"google.com\")\nip\"74.125.226.225\""
},

{
    "location": "manual/parallel-computing.html#",
    "page": "Computación Paralela",
    "title": "Computación Paralela",
    "category": "page",
    "text": ""
},

{
    "location": "manual/parallel-computing.html#parallel-computing-1",
    "page": "Computación Paralela",
    "title": "Computación Paralela",
    "category": "section",
    "text": "La mayoría de las computadoras modernas poseen más de una CPU, y varias computadoras pueden combinarse en un cluster. Aprovechar la potencia de estas múltiples CPU permite que muchos cálculos se completen más rápidamente. Hay dos factores principales que influyen en el rendimiento: la velocidad de las propias CPUs y la velocidad de su acceso a la memoria. En un clúster, es bastante obvio que una CPU dada tendrá acceso más rápido a la RAM dentro de la misma computadora (nodo). Quizás más sorprendentemente, problemas similares son relevantes en un portátil multicore típico, debido a las diferencias en la velocidad de la memoria principal y la caché. En consecuencia, un buen entorno de multiprocesamiento debe permitir el control sobre la \"propiedad\" de un trozo de memoria por una CPU particular. Julia proporciona un entorno de multiprocesamiento basado en el paso de mensajes para permitir que los programas se ejecuten en múltiples procesos en distintos dominios de memoria a la vez.La implementación de Julia del paso del mensajes es diferente de otros entornos tales como MPI [1]. Comunicación en Julia es generalmente \"unilateral\", lo que significa que el programador necesita explícitamente administrar sólo un proceso en una operación de dos procesos. Además, estas operaciones típicamente no se parecen a \"envío de mensajes\" y \"recepción de mensajes\", sino más bien se asemejan a operaciones de nivel superior como llamadas a funciones de usuario.La programación paralela en Julia se basa en dos primitivas: referencias remotas y llamadas remotas. Una referencia remota es un objeto que puede utilizarse desde cualquier proceso para referirse a un objeto almacenado en un proceso determinado. Una llamada remota es una petición de un proceso para llamar a una determinada función en ciertos argumentos en otro proceso (posiblemente el mismo).Las referencias remotas vienen en dos variedades: Future y RemoteChannel.Una llamada remota devuelve un Future a su resultado. Las llamadas remotas retornan inmediatamente; el proceso que hizo que la llamada procede a su siguiente operación mientras la llamada remota sucede en otro lugar. Podemos esperar a que una llamada remota termine llamando a wait() en el Future devuelto, y puede obtener el valor completo del resultado usando fetch().Por otro lado, los objetos RemoteChannel son reescribibles. Por ejemplo, varios procesos pueden coordinar su procesamiento haciendo referencia al mismo canal (Channel) remoto.Cada proceso tiene un identificador asociado. El proceso que proporciona el prompt interactivo de Julia siempre tiene un id igual a 1. Los procesos utilizados por defecto para operaciones paralelas se conocen como \"workers\". Cuando solo hay un proceso, el proceso 1 se considera trabajador. De lo contrario, se considera que los trabajadores son todos procesos distintos del proceso 1.Vamos a probar esto. Comenzar con julia -p n proporciona n procesos workers en la máquina local. Generalmente tiene sentido igualar n al número de núcleos de la CPU en la máquina.$ ./julia -p 2\n\njulia> r = remotecall(rand, 2, 2, 2)\nFuture(2, 1, 4, Nullable{Any}())\n\njulia> s = @spawnat 2 1 .+ fetch(r)\nFuture(2, 1, 5, Nullable{Any}())\n\njulia> fetch(s)\n2×2 Array{Float64,2}:\n 1.18526  1.50912\n 1.16296  1.60607El primer argumento para remotecall() es la función para llamar. La mayoría de la programación paralela en Julia no hace referencia a procesos específicos ni a la cantidad de procesos disponibles, pero remotecall() se considera una interfaz de bajo nivel que proporciona un control más preciso. El segundo argumento para remotecall() es el id del proceso que hará el trabajo, y los argumentos restantes se pasarán a la función a la que se llama.Como puede ver, en la primera línea le pedimos al proceso 2 que construyera una matriz aleatoria de 2 por 2, y en la segunda línea le pedimos que agregara 1 a ella. El resultado de ambos cálculos está disponible en los dos futuros, r ys. La macro @ spawnat evalúa la expresión en el segundo argumento sobre el proceso especificado por el primer argumento.Ocasionalmente, es posible que desee un valor calculado de forma remota de inmediato. Esto suele ocurrir cuando lee desde un objeto remoto para obtener los datos que necesita la próxima operación local. La función remotecall_fetch() existe para este propósito. Es equivalente a fetch (remotecall(...)) pero es más eficientejulia> remotecall_fetch(getindex, 2, r, 1, 1)\n0.18526337335308085Recuerde que getindex(r,1,1) es equivalente a r[1,1], por lo que esta llamada capta el primer elemento del futuro r.La sintaxis de remotecall() no es especialmente conveniente. La macro @spawn hace las cosas más fáciles. Ella opera sobre una expresión en lugar de sobre una función, y elige dónde hacer la operación por ti:julia> r = @spawn rand(2,2)\nFuture(2, 1, 4, Nullable{Any}())\n\njulia> s = @spawn 1 .+ fetch(r)\nFuture(3, 1, 5, Nullable{Any}())\n\njulia> fetch(s)\n2×2 Array{Float64,2}:\n 1.38854  1.9098\n 1.20939  1.57158Note que usamos 1 .+ fetch(r) en lugar de 1 .+ r. Esto es debido a que no sabemos dónde se ejecutará el código, por lo que en general puede que se requiera unfetch() para mover r al proceso que esta realizando la suma. En este caso, @spawn es bastante inteligente como para realizar el computo sobre el proceso que posee r, por lo que la llamada fetch() será una no-op (no se realiza trabajo).(Hay que notar que @spawn no es una función predefinida sino que está definida en Julia como una macro. Es posible definir nuestras propias construcciones de ese tipo).Una importante cosa a recordar es que, una vez traída, un Future cacheará su valor localmente. Las llamadas adicionales a fetch() calls no implican un salto de red. Una vez que todos los Futures que referencian ha sido recuperados, el valor remoto almacenado es borrado."
},

{
    "location": "manual/parallel-computing.html#code-availability-and-loading-packages-1",
    "page": "Computación Paralela",
    "title": "Disponibiliad de Código y Carga de Paquetes",
    "category": "section",
    "text": "Nuestro código debe estar disponible sobre cualquir proceso que lo ejecuta. Por ejemplo, escriba esto en el prompt de Julia:julia> function rand2(dims...)\n           return 2*rand(dims...)\n       end\n\njulia> rand2(2,2)\n2×2 Array{Float64,2}:\n 0.153756  0.368514\n 1.15119   0.918912\n\njulia> fetch(@spawn rand2(2,2))\nERROR: RemoteException(2, CapturedException(UndefVarError(Symbol(\"#rand2\"))\n[...]El proceso 1 sabe dónde se encuentra la función rand2, pero el proceso 2 no.Ms comunmente uno estará cargando código desde ficheros o paquetes, y tendrá una considerable flexibilidad para controlar qué procesos cargan código. Considere un fichero DummyModule.jl, que contenga el siguiente código:module DummyModule\n\nexport MyType, f\n\nmutable struct MyType\n    a::Int\nend\n\nf(x) = x^2+1\n\nprintln(\"loaded\")\n\nendSi se arranca Julia con julia -p 2, se puede usar esto para verificar lo siguiente:include(\"DummyModule.jl\") carga elfichero sólo sobre un proceso (el que ejecuta la instrucción).\nusing DummyModule causa que el módulo sea cargado sobre todos los procesos; sin embargo, el módulo es llevado al ámbito sólo por el que ejecuta la instrucción.\nEn cuanto DummyModule sea cargado sobre el proceso 2, mandatos como\nrr = RemoteChannel(2)\nput!(rr, MyType(7))\npermiten almacenar un objeto de tipo MyType sobre el proceso 2 incluso aunque DummyModule no esté en  el ámbito del proceso 2.Uno puede forzar que un mandato se ejecute sobre todos los procesos usando la macro @everywhere. Por ejemplo, @everywhere puede también ser usado para definir directamente una función sobre todos los procesos:julia> @everywhere id = myid()\n\njulia> remotecall_fetch(()->id, 2)\n2Un fichero puede también ser precargado sobre múltiples procesos al inicio, y puede usarse un driver para llevar a cabo ese cómputo:julia -p <n> -L file1.jl -L file2.jl driver.jlEl proceso Julia que corre el programa driver del ejemplo anterior tiene un id igual a 1, justo como un proceso que proporciona un prompt interactivo.La instalación base de Julia tiene soporte intríseco para dos tipos de clusters:Un clúster local especificado con la opción -p, como se mostró anteriormente.\nUn clúster que abarca máquinas utilizando la opción --machinefile. Esto utiliza un inicio de  sesión ssh sin contraseña para iniciar los procesos de trabajo de Julia (desde la misma ruta  que el servidor actual) en las máquinas especificadas.Las funciones addprocs(), rmprocs(), workers(), y otras están disponibles como una forma programática de añadir, borrar y consultar los procesos en un cluster.Note que los workers no ejecutan un script .juliarc.jl de inicio, ni sincronizan su estado global (tal como variables globales, nuevas definiciones de métodos y módulos cargados) con cualquiera de los procesos que están ejecutando.Pueden soportarse otros tipos de clústers escribiendo nuestro propio ClusterManager, como se describe después en la sección ClusterManagers section."
},

{
    "location": "manual/parallel-computing.html#Movimiento-de-Datos-1",
    "page": "Computación Paralela",
    "title": "Movimiento de Datos",
    "category": "section",
    "text": "Enviar mensaje y mover datos constituye la mayor parte de la sobrecarga de un programa paralelo. Reducir el número de mensajes y la cantidad de datos enviados es crítico para conseguir rendimiento y escalabilidad. Para este fin, es importante comprender el movimiento de datos realizado por varias construcciones de programación paralela de Julia.fetch() puede considerarse una operación explícita de movimiento de datos, ya que directamente pide que un objeto sea movido a la máquina local. @spawn (y unas pocas construcciones relacionadas) también mueve datos, pero esto no es tan obvio, por lo tanto, puede denominarse una operación implícita de movimiento de datos. Considere estos dos enfoques para construir y cuadrar una matriz aleatoria:Method 1:julia> A = rand(1000,1000);\n\njulia> Bref = @spawn A^2;\n\n[...]\n\njulia> fetch(Bref);Method 2:julia> Bref = @spawn rand(1000,1000)^2;\n\n[...]\n\njulia> fetch(Bref);La diferencia parece trivial, pero de hecho es bastante significativa debido al comportamiento de @spawn. En el primer método, se construye localmente una matriz aleatoria, y después se manda a otro proceso que la eleva al cuadrado. En el segundo método, una matriz aleatoria es construida y elevada al cuadrado (ambas operaciones) sobre otro proceso. Por tanto, el segundo método envía muchos menos datos que el primero. En este ejemplo de juquete, los dos métodos son fáciles de distinguir y elegir. Sin embargo, en un programa real dieseñar movimiento de datos puede requerir ms reflexin y, probablemente, alguna medida. Por ejemplo, si el primero proceso necesita la matriz A, entonces el primer método sera mejor. O, si calcular A es costoso y sólo el proceso actual tiene que hacerlo, entonces mover la matriz al otro proceso puede ser inevitable. o, si el proceso actual tiene muy poco que hacer entre las instrucciones @spawn y fetch(Bref), podría ser mejor eliminar el paralelismo por completo. O imagine que rand(1000,1000) es reemplazado con un a operación más costosa. Entonces podría tener sentido añadir ora instrucción  @spawn sólo para este paso."
},

{
    "location": "manual/parallel-computing.html#Variables-Globales-1",
    "page": "Computación Paralela",
    "title": "Variables Globales",
    "category": "section",
    "text": "Las expresiones ejecutadas remotamente vía @spawn, o los cierres especificados para ejecucin remota usando remotecall pueden referirse a variables globales. Las vinculaciones globales en el módulo Main son tratadas de un modo un poco diferente comparados a las vinculaciones globales en otros módulos. Considere el siguiente trozo de código:A = rand(10,10)\nremotecall_fetch(()->foo(A), 2)Tenga en cuenta que A es una variable global definida en el espacio de trabajo local. El worker 2 no tiene una variable llamada A dentro de Main. Por tantom el acto de enviar el cierre () -> foo(A) al worker 2 da como resultado que Main.A se defina en 2. Main.A sigue existiendo en el worker 2 incluso después de que la llamada remotecall_fetch retorne. Las llamadas remotas con referencias globales integradas (solo bajo el módulo Main) administran los datos globales de la siguiente manera:Se crean nuevos enlaces globales en los trabajadores de destino si se hace referencia a ellos como parte de una llamada remota.\nLas constantes globales se declaran también como constantes en los nodos remotos.\nGlobales se reenvían a un worker de destino solo en el contexto de una llamada remota, y solo si su valor ha cambiado. Además, el clúster no sincroniza las asignaciones globales entre nodos. Por ejemplo:\nA = rand(10,10)\nremotecall_fetch(()->foo(A), 2) # worker 2\nA = rand(10,10)\nremotecall_fetch(()->foo(A), 3) # worker 3\nA = nothing\nEjecutar este trozo de código da como resultado que Main.A del worker 2 tenga un valor diferente del que tiene en  Main.A del worker 3, mientras que el valor de Main.A en el nodo 1 se fija a nothing.Como se habrá dado cuenta, aunque la memoria asociada con los globales se puede recopilar cuando se reasignan en el maestro, dicha acción no se toma en los workers ya que los enlaces siguen siendo válidos. clear! se puede usar para reasignar manualmente globales específicos en nodos remotos a nothing una vez que ya no sean necesarios. Esto liberará cualquier memoria asociada con ellos como parte de un ciclo de recolección de basura regular.Por lo tanto, los programas deben ser cuidadosos al hacer referencia a los globales en las llamadas remotas. De hecho, es preferible evitarlos por completo si es posible. Si hay que hacer referencia a globales, considere usar bloques let para localizar variables globales.For example:julia> A = rand(10,10);\n\njulia> remotecall_fetch(()->A, 2);\n\njulia> B = rand(10,10);\n\njulia> let B = B\n           remotecall_fetch(()->B, 2)\n       end;\n\njulia> @spawnat 2 whos();\n\njulia>  From worker 2:                               A    800 bytes  10×10 Array{Float64,2}\n        From worker 2:                            Base               Module\n        From worker 2:                            Core               Module\n        From worker 2:                            Main               ModuleComo puede verse, la variable global A es definidia en el worker 2, pero B es capturada como una variable local y por tanto no existe una asignacin para B en worker 2."
},

{
    "location": "manual/parallel-computing.html#Map-y-Bucles-Paralelos-1",
    "page": "Computación Paralela",
    "title": "Map y Bucles Paralelos",
    "category": "section",
    "text": "Afortunadamente, muchos cálculos paralelos no requieren movimiento de datos. Un ejemplo común es las simulaciones Monte Carlo, donde muchos procesos pueden manejar simultáneamente pruebas de simulación independientes. Podemos usar @spawn para lanzar monedas sobre dos procesos. Primero, se escribiría la siguiente función en count_heads.jl:function count_heads(n)\n    c::Int = 0\n    for i = 1:n\n        c += rand(Bool)\n    end\n    c\nendLa función count_heads simplemente añade juntos n bits aleatorios. He aqui cónmo pueden realizarse algunas pruebas sobre dos máquinas, y añadir juntos los resultados:julia> @everywhere include(\"count_heads.jl\")\n\njulia> a = @spawn count_heads(100000000)\nFuture(2, 1, 6, Nullable{Any}())\n\njulia> b = @spawn count_heads(100000000)\nFuture(3, 1, 7, Nullable{Any}())\n\njulia> fetch(a)+fetch(b)\n100001564Este ejemplo demuestra un patrón de programación paralela potente y frecuentemente usado. Muchas iteraciones se ejecutan independientemente sobre varios porocesos, y entonces sus resultados se combinan usando alguna función. El proceso de combinación se denomina reducción ya que suele ser la reduccin de rango de un tensor: un vector de números es reducido a un solo número o una matriz es reducida a una sola fila o columna, etc. En código esto suele tener el aspecto del patrón x = f(x,v[i]), donde x es el acumulador, f es la funcin de reducción, y los v[i] son los elementos que se reducirán. Es deseable que f sea asociativa, para que no importe el orden en el que se realizan las operaciones.Notese que nuestro uso de este patrón con count_heads puede ser generalizado. Se utilizaron dos instrucciones @spawn explícitas, que limitan el paralelismo a dos procesos. Para ejecutar sobre cualquier número de procesos, se puede usar el bucle for paralelo que puede escribirse en Julia usando la macro @parallel como en este ejemplo:nheads = @parallel (+) for i = 1:200000000\n    Int(rand(Bool))\nendEsta construcción implementa el patrón de asignar iteraciones a múltiples procesos, y combinarlos con una reducción especificada (en este caso (+)). El resultado de cada iteración es tomado como el valor de la última expresión dentro del bucle. La expresión total del bucle paralelo en sí misma se evalúa a la respuesta final.Debe notar que, aunque los bucles for paralelos tienen un aspecto muy parecido al de los bucles for seriales, su comportamiento es dramaticamente diferente. En particular, las iteraciones no tiene lugar en un orden especificado, y l escritura a variables o arrays no será globalmente visible ya que las iteraciones se ejecutan sobre procesos distintos. Cualquier variable usada dentro del bucle paralelo será copiada y retransmitida a cada proceso.Por ejemplo, el siguiente código no trabajará como se esperaba:a = zeros(100000)\n@parallel for i = 1:100000\n    a[i] = i\nendEste código no inicializará todo a, ya que cada proceso tendrá una copia separada de él. Los bucles for paralelos como éste deben ser evitados. Afortunadamente, podemos usar los arrays compartidos para sortear esta limitación:a = SharedArray{Float64}(10)\n@parallel for i = 1:10\n    a[i] = i\nendUsar variables \"forasteras\" en los bucles paralelos es perfectamente razonable si las variables son de sólo lectura:a = randn(1000)\n@parallel (+) for i = 1:100000\n    f(a[rand(1:end)])\nendEn este ejemplo, cada iteración aplica f a una muestra elegida aleatoriamente de un vector a compartido por todos los procesos.Como podía ver, el operador de reducción puede ser omitido si no se necesita En este caso, el bucle se ejecuta de forma asíncrona, es decir, engendra tareas independientes sobre todos los workers disponibles y devuelve un array de objetos Future inmediatamente sin esperar a su terminación. El código invocador puede esperar a la terminación de los Future en un punto posterior mediante una llamada a fetch() sobre ellos, o esperar la terminancin al final del bucle prefijándolo con @sync, como @sync @parallel for.En algunos casos no se necesita un operador de reducción, y simplemente deseamos aplicar una funcin a todos los enteros en algún rango (o, de forma más general, a todos los elementos de una colección). Esta es otra operación útil llamada parallel map, implementada en con la función pmap(). Por ejemplo, podríamos computar los valores singularees de varias matrices aleatorias en paralelo de la siguiente forma:julia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];\n\njulia> pmap(svd, M);La función pmap() de Julia está diseñada para el caso de que cada llamada a función realice una gran cantidad de trabajo. En contraste @parallel for puede manejar situaciones donde cada iteración es pequeña, quizás incluso sumar dos números. Tanto las funciones pmap() como @parallel for usan exclusivamente procesos worker para la computación paralela. En el caso de @parallel for, la reducción final se realiza sobre el proceso principal."
},

{
    "location": "manual/parallel-computing.html#Sincronización-con-Referencias-Remotas-1",
    "page": "Computación Paralela",
    "title": "Sincronización con Referencias Remotas",
    "category": "section",
    "text": ""
},

{
    "location": "manual/parallel-computing.html#Planificación-1",
    "page": "Computación Paralela",
    "title": "Planificación",
    "category": "section",
    "text": "La plataforma de programación paralela de Julia usa Tareas (también conocidas como Coroutinas) para alternar entre múltiples cálculos. Cada vez que el código realiza una operación de comunicación como fetch() o wait(), la tarea actual se suspende y un planificador elige otra tarea para ejecutar. Una tarea se reinicia cuando finaliza el evento que está esperando.Para muchos problemas, no es necesario pensar en las tareas directamente. Sin embargo, pueden usarse para esperar múltiples eventos al mismo tiempo, lo que proporciona una planificación dinámica. En la planificación dinámica, un programa decide qué calcular o dónde calcularlo en función de cuándo finalizan otros trabajos. Esto es necesario para cargas de trabajo impredecibles o desequilibradas, donde queremos asignar más trabajo a los procesos solo cuando finalizan sus tareas actuales.Como ejemplo, considere calcular los valores singulares de matrices de diferentes tamaños:julia> M = Matrix{Float64}[rand(800,800), rand(600,600), rand(800,800), rand(600,600)];\n\njulia> pmap(svd, M);Si un proceso maneja la dos matrices de 800 × 800 y otro maneja las dos matrices de 600 × 600, no obtendremos la mayor escalabilidad posible. La solución es hacer una tarea local para \"alimentar\" el trabajo a cada proceso cuando completa su tarea actual. Por ejemplo, considere una implementación simple pmap():function pmap(f, lst)\n    np = nprocs()  # determine the number of processes available\n    n = length(lst)\n    results = Vector{Any}(n)\n    i = 1\n    # function to produce the next work item from the queue.\n    # in this case it's just an index.\n    nextidx() = (idx=i; i+=1; idx)\n    @sync begin\n        for p=1:np\n            if p != myid() || np == 1\n                @async begin\n                    while true\n                        idx = nextidx()\n                        if idx > n\n                            break\n                        end\n                        results[idx] = remotecall_fetch(f, p, lst[idx])\n                    end\n                end\n            end\n        end\n    end\n    results\nend@async es similar a @spawn, pero solo ejecuta tareas en el proceso local. Lo usamos para crear una tarea   \"alimentador\" para cada proceso. Cada tarea selecciona el siguiente índice que debe calcularse, luego espera a que termine su proceso, y luego se repite hasta que nos quedemos sin índices. Tenga en cuenta que las tareas \"alimentadoras no\" comienzan a ejecutarse hasta que la tarea principal llega al final del bloque @sync, momento en el cual se somete al control y espera a que se completen todas las tareas locales antes de regresar de la función. Las tareas del \"alimentador\" pueden compartir el estado a través de nextidx() porque todas se ejecutan en el mismo proceso. No se requiere bloqueo, ya que los hilos están programados de forma cooperativa y no apropiativa. Esto significa que los cambios de contexto solo ocurren en puntos bien definidos: en este caso, cuando se llama a remotecall_fetch()."
},

{
    "location": "manual/parallel-computing.html#Canales-1",
    "page": "Computación Paralela",
    "title": "Canales",
    "category": "section",
    "text": "La sección sobre tareas (Task) en Control de flujo discutió la ejecución de múltiples funciones de forma cooperativa. Los canales (Channel) pueden ser bastante útiles para pasar datos entre tareas en ejecución, particularmente aquellas que involucran operaciones de E/S.Ejemplos de operaciones que implican E/S incluyen la lectura/escritura en archivos, acceso a servicios web, ejecución de programas externos, etc. En todos estos casos, el tiempo de ejecución general puede mejorarse si se pueden ejecutar otras tareas mientras se lee un archivo, o mientras se espera a que se complete un servicio o programa externo.Un canal se puede visualizar como un conducto, es decir, tiene un extremo de escritura y un extremo de lectura.Varios escritores en diferentes tareas pueden escribir en el mismo canal concurrentemente a través de llamadas put!().\nVarios lectores en diferentes tareas pueden leer datos simultáneamente a través de llamadas take!().\nComo ejemplo:    # Given Channels c1 and c2,\n    c1 = Channel(32)\n    c2 = Channel(32)\n\n    # and a function `foo()` which reads items from from c1, processes the item read\n    # and writes a result to c2,\n    function foo()\n        while true\n            data = take!(c1)\n            [...]               # process data\n            put!(c2, result)    # write out result\n        end\n    end\n\n    # we can schedule `n` instances of `foo()` to be active concurrently.\n    for _ in 1:n\n        @schedule foo()\n    end\n    ```\n \n   * Los canales se crean a través del constructor `Channel{T}(sz)`. El canal solo tendrá objetos de tipo `T`. Si no se especifica el tipo, el canal puede contener objetos de cualquier tipo. `sz` se refiere a la cantidad máxima de elementos que pueden mantenerse en el canal en cualquier momento. Por ejemplo, `Channel(32)` crea un canal que puede contener un máximo de 32 objetos de cualquier tipo. Un `Channel{MyType}(64)` puede contener hasta 64 objetos de `MyType` en cualquier momento.\n   * Si un [`Channel`](@ref) está vacío, los lectores (en una llamada [`take!()`](@ref)) se bloquearán hasta que los datos estén disponibles.\n   * Si un [`Channel`](@ref) está lleno, los escritores (en una llamada [`put!()`](@ref)) se bloquearán hasta que haya espacio disponible.\n   * [`isready()`](@ref) comprueba la presencia de cualquier objeto en el canal, mientras que [`wait()`](@ref) espera a que un objeto esté disponible.\n   * Un [`Channel`](@ref) está inicialmente en un estado abierto. Esto significa que puede leerse y escribirse libremente a través de llamadas [`take!()`](@ref) y [`put!()`](@ref). [`close()`](@ref) cierra un [`Channel`](@ref). En un [`Channel`](@ref) cerrado, la función [`put!()`](@ref) fallará. Por ejemplo:\n  julia-repl julia> c = Channel(2);julia> put!(c, 1) # put! on an open channel succeeds 1julia> close(c);julia> put!(c, 2) # put! on a closed channel throws an exception. ERROR: InvalidStateException(\"Channel is closed.\",:closed) [...]\n* [`take!()`](@ref) y [`fetch()`](@ref) (que recupera pero no elimina el valor) en un canal cerrado devuelve con éxito cualquier valor existente hasta que se vacíe. Continuando con el ejemplo anterior:\njulia-repl julia> fetch(c) # Any number of fetch calls succeed. 1julia> fetch(c) 1julia> take!(c) # The first take! removes the value. 1julia> take!(c) # No more data available on a closed channel. ERROR: InvalidStateException(\"Channel is closed.\",:closed) [...]\nUn canal se puede usar como un objeto iterable en un bucle `for`, en cuyo caso el bucle se ejecuta mientras el canal tenga datos o esté abierto. La variable del bucle toma todos los valores agregados al canal. El bucle `for` finaliza una vez que el canal se cierra y se vacía.\n\nPor ejemplo, lo siguiente haría que el bucle `for` esperara más datos:\njulia-repl julia> c = Channel{Int}(10);julia> foreach(i->put!(c, i), 1:3) # add a few entriesjulia> data = [i for i in c]\nmientras que esto retornará después de leer todos los datos:\njulia-repl julia> c = Channel{Int}(10);julia> foreach(i->put!(c, i), 1:3); # add a few entriesjulia> close(c);                    # for loops can exitjulia> data = [i for i in c] 3-element Array{Int64,1}:  1  2  3\nConsideremos un ejemplo simple utilizando canales para la comunicación entre tareas. Comenzamos 4 tareas para procesar los datos de un solo canal `jobs`. Los trabajos, identificados por un identificador (`job_id`), se escriben en el canal. Cada tarea en esta simulación lee un `job_id`, espera una cantidad aleatoria de tiempo y escribe una tupla de `job_id` y el tiempo simulado en el canal de resultados. Finalmente todos los `resultados` se imprimen.\njulia-repl julia> const jobs = Channel{Int}(32);julia> const results = Channel{Tuple}(32);julia> function do_work()            for job_id in jobs                exec_time = rand()                sleep(exec_time)                # simulates elapsed time doing actual work                                                # typically performed externally.                put!(results, (job_id, exec_time))            end        end;julia> function make_jobs(n)            for i in 1:n                put!(jobs, i)            end        end;julia> n = 12;julia> @schedule make_jobs(n); # feed the jobs channel with \"n\" jobsjulia> for i in 1:4 # start 4 tasks to process requests in parallel            @schedule do_work()        endjulia> @elapsed while n > 0 # print out results            job_id, exec_time = take!(results)            println(\"job_id finished in round(exec_time, 2) seconds\")            n = n - 1        end 4 finished in 0.22 seconds 3 finished in 0.45 seconds 1 finished in 0.5 seconds 7 finished in 0.14 seconds 2 finished in 0.78 seconds 5 finished in 0.9 seconds 9 finished in 0.36 seconds 6 finished in 0.87 seconds 8 finished in 0.79 seconds 10 finished in 0.64 seconds 12 finished in 0.5 seconds 11 finished in 0.97 seconds 0.029772311\nLa versión actual de Julia multiplexa todas las tareas en un solo hilo del sistema operativo. Por lo tanto, aunque las tareas que implican operaciones de E/S se benefician de la ejecución en paralelo, las tareas vinculadas a la computación se ejecutan efectivamente de forma secuencial en un solo hilo del sistema operativo. Las versiones futuras de Julia pueden soportar la planificación de tareas en múltiples subprocesos, en cuyo caso las tareas vínculadas al cálculo  también verán los beneficios de la ejecución en paralelo.\n\n## Referencias remotas y AbstractChannels\n\nLas referencias remotas siempre se refieren a una implementación de un `AbstractChannel`.\n\nSe requiere una implementación concreta de un `AbstractChannel` (como `Channel`) para implementar [`put!()`](@ref), [`take!()`](@ref), [`fetch()`](@ref), [`isready()`](@ref) y [`wait()`](@ref). El objeto remoto al que se hace referencia con un [`Future`](@ref) se almacena en `Channel{Any}(1) `, es decir, un` Channel` de tamaño 1 capaz de contener objetos del tipo `Any`.\n\n[`RemoteChannel`](@ref), que es reescribible, puede señalar cualquier tipo y tamaño de canales, o cualquier otra implementación de `AbstractChannel`.\n\nEl constructor `RemoteChannel(f::Function, pid)()` permite construir referencias a canales que contienen más de un valor de un tipo específico. `f()` es una función ejecutada en un `pid` y debe devolver un `AbstractChannel`.\n\nPor ejemplo, `RemoteChannel(()->Channel{Int}(10), pid)`, devolverá una referencia a un canal de tipo `Int` y tamaño 10. El canal existe sobre el *worker* `pid`.\n\nLos métodos [`put!()`](@ref), [`take!()`](@ref), [`fetch()`](@ref), [`isready()`](@ref) y [`wait()`](@ref) de un [`RemoteChannel`](@ref) son proxys en el backing store en el proceso remoto.\n\n[`RemoteChannel`](@ref) se puede usar para referirse a los objetos `AbstractChannel` implementados por el usuario. Un ejemplo simple de esto se proporciona en `examples/dictchannel.jl` que usa un diccionario como su almacén remoto.\n\n## `Channel`s y `RemoteChannel`s\n\n* Un objeto [`Channel`](@ref) es local a un proceso. El *worker* 2 no puede referirse directamente a un `Channel` sobre el *worker* 3 y viceversa. Un [`RemoteChannel`](@ref), sin embargo, puedo poner y tomar valores entre *worker*s.\n* Un [`RemoteChannel`](@ref) se puede considerar como un *manejador* para un `Channel`.\n* La identificación del proceso, `pid`, asociada con un [`RemoteChannel`](@ref) identifica el proceso donde el almacén de respaldo, es decir, el `Channel`  de respaldo existe.\n* Cualquier proceso con una referencia a [`RemoteChannel`](@ref) puede poner y tomar elementos del canal. Los datos se envían automáticamente a (o se recuperan de) el proceso al que está asociado [`RemoteChannel`](@ref).\n* Serializar un `Channel` también serializa cualquier dato presente en el canal. Deserializarlo, por lo tanto, efectivamente hace una copia del objeto original.\n* Por otro lado, serializar un [`RemoteChannel`](@ref) solo implica la serialización de un identificador que identifica la ubicación y la instancia del `Channel` al que hace referencia el manejador. Un objeto [`RemoteChannel`](@ref) deserializado  (en cualquier *worker*), por lo tanto, también apunta al mismo almacén de respaldo que el original.\n\nEl ejemplo de canales anterior puede modificarse para la comunicación entre procesos, como se muestra a continuación.\n\nComenzamos 4 trabajadores para procesar un solo canal remoto `jobs`. Los trabajos, identificados por una identificación (`job_id`), se escriben en el canal. Cada tarea de ejecución remota en esta simulación lee un `job_id`, espera una cantidad aleatoria de tiempo y escribe una tupla de` job_id`, tiempo tomado y su propio `pid` en el canal de resultados. Finalmente todos los `resultados` se imprimen en el proceso maestro.\njulia-repl julia> addprocs(4); # add worker processesjulia> const jobs = RemoteChannel(()->Channel{Int}(32));julia> const results = RemoteChannel(()->Channel{Tuple}(32));julia> @everywhere function do_work(jobs, results) # define work function everywhere            while true                job_id = take!(jobs)                exec_time = rand()                sleep(exec_time) # simulates elapsed time doing actual work                put!(results, (job_id, exec_time, myid()))            end        endjulia> function make_jobs(n)            for i in 1:n                put!(jobs, i)            end        end;julia> n = 12;julia> @schedule make_jobs(n); # feed the jobs channel with \"n\" jobsjulia> for p in workers() # start tasks on the workers to process requests in parallel            @async remote_do(do_work, p, jobs, results)        endjulia> @elapsed while n > 0 # print out results            job_id, exec_time, where = take!(results)            println(\"job_id finished in round(exec_time, 2) seconds on worker where\")            n = n - 1        end 1 finished in 0.18 seconds on worker 4 2 finished in 0.26 seconds on worker 5 6 finished in 0.12 seconds on worker 4 7 finished in 0.18 seconds on worker 4 5 finished in 0.35 seconds on worker 5 4 finished in 0.68 seconds on worker 2 3 finished in 0.73 seconds on worker 3 11 finished in 0.01 seconds on worker 3 12 finished in 0.02 seconds on worker 3 9 finished in 0.26 seconds on worker 5 8 finished in 0.57 seconds on worker 4 10 finished in 0.58 seconds on worker 2 0.055971741\n## Referencias Remotas y Recolección de Basura Distribuida\n\nLos objetos a los que se refieren las referencias remotas se pueden liberar solo cuando se eliminan *todas* las referencias retenidas en el clúster.\n\nEl nodo donde se almacena el valor realiza un seguimiento de cuáles de los trabajadores tienen una referencia. Cada vez que un [`RemoteChannel`](@ref) o un (unfetched) [`Future`](@ref) se serializa a un *worker*, se notifica el nodo al que apunta la referencia. Y cada vez que un [`RemoteChannel`](@ref) o un (unfetched) [`Future`](@ref) es sometido a recolección de basura localmente, el nodo que posee el valor es nuevamente notificado.\n\nLas notificaciones se realizan a través del envío de mensajes de \"seguimiento\": un mensaje de \"agregar referencia\" cuando una referencia se serializa a un proceso diferente y un mensaje de \"eliminación de referencia\" cuando una referencia se recolecta localmente.\n\nComo los [`Future`](@ref)s son de escritura única y se almacenan en caché localmete, el acto de [`fetch()`](@ref)ing un [`Future`](@ref) también actualiza la información de seguimiento de referencia en el nodo que posee el valor.\n\nEl nodo que posee el valor lo libera una vez que se borran todas las referencias a él.\n\nCon [`Future`](@ref)s, la serialización de un [`Future`](@ref) ya obtenido  a un nodo diferente también envía el valor ya que el almacén remoto original puede haber recolectado el valor en ese momento.\n\nEs importante tener en cuenta que *cuando* un objeto se recolecta basura localmente depende del tamaño del objeto y la presión de la memoria actual en el sistema.\n\nEn el caso de referencias remotas, el tamaño del objeto de referencia local es bastante pequeño, mientras que el valor almacenado en el nodo remoto puede ser bastante grande. Dado que el objeto local puede no receolectarse inmediatamente, es una buena práctica llamar explícitamente a [`finalize()`](@ref) en instancias locales de un [`RemoteChannel`](@ref), o en unfetched [`Future`](@ref)s. Como llamar a [`fetch()`](@ref) sobre un [`Future`](@ref) también elimina su referencia del almacén remoto, esto no es necesario en fetched [`Future`](@ref)s. Llamar explícitamente a [`finalize()`](@ref) da como resultado un mensaje inmediato enviado al nodo remoto para continuar y eliminar su referencia al valor.\n\nUna vez finalizado, una referencia deja de ser válida y no se puede usar en ninguna otra llamada.\n\n## [Arrays Compartidos](@id man-shared-arrays)\n\nLos arrays compartidos usan memoria compartida del sistema para hacer corresponder el mismo array a través de muchos procesos. Aunque hay algunas similaridades a un [`DArray`](https://github.com/JuliaParallel/DistributedArrays.jl), el comportamiento de un [`SharedArray`](@ref) es bastante diferente. En un [`SharedArray`](@ref), cada proceso tiene acceso local justo a un trozo de los datos, y do hay dos procesos que compartan el mismo trozo; en contraste, en un [`SharedArray`](@ref) cada proceso \"participante\" tiene acceso al array completo. Un [`SharedArray`](@ref) es una buena elección cuando uno quiere tener una gran cantidad de datos conjuntamente accesibles a dos o más procesos sobre la misma máquina.\n\nLa indexación de los [`SharedArray`](@ref)s funciona justo como con los arrays regulares, y es eficiente debido a que la memoria subyacente está disponible al proceso local. Por tanto, la mayoría de los algoritmos trabajan de forma natural sobre los [`SharedArray`](@ref)s, aunque en modo uniproceso. En casos donde un algoritmo insiste sobre una entrada [`Array`](@ref), el array subyacente se puede recuperar desde un [`SharedArray`](@ref) llamando a [`sdata()`](@ref). Para otros tipos de `AbstractArray`, [`sdata()`](@ref) simplemente devuelve el objeto, por lo que es seguro usar [`sdata()`](@ref) en cualquier objeto de tipo` Array`.\n\nEl constructor par aun array compartido es de la forma:\njulia SharedArray{T,N}(dims::NTuple; init=false, pids=Int[])\nque crea un array compartido `N`-dimensional de un tipo de bits `T` y `dims` de tamaño en los procesos especificados por `pids`. A diferencia de los arrays distribuidos, a un array compartido solo se puede acceder desde los *workers* participantes especificados por el argumento denominado `pids` (y el proceso de creación también, si está en el mismo host).\n\nSi se especifica una función `init`, con signatura `initfn(S::SharedArray)`, se llama a todos los trabajadores participantes. Puede especificar que cada trabajador ejecute la función `init` en una parte distinta de la matriz, paralelizando así la inicialización.\n\nHe aquí un breve ejemplo:\njulia-repl julia> addprocs(3) 3-element Array{Int64,1}:  2  3  4julia> S = SharedArray{Int,2}((3,4), init = S -> S[Base.localindexes(S)] = myid()) 3×4 SharedArray{Int64,2}:  2  2  3  4  2  3  3  4  2  3  4  4julia> S[3,2] = 7 7julia> S 3×4 SharedArray{Int64,2}:  2  2  3  4  2  3  3  4  2  7  4  4\n[`Base.localindexes()`](@ref) proporciona rangos unidimensionales disjuntos de índices, y a veces es conveniente para dividir tareas entre procesos. Uno puede, por supuesto, dividir el trabajo de la manera que desee:\njulia-repl julia> S = SharedArray{Int,2}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = myid()) 3×4 SharedArray{Int64,2}:  2  2  2  2  3  3  3  3  4  4  4  4\nComo todos los procesos tienen acceso a los datos subyacentes, uno tiene que tener cuidado de no generar conflictos. Por ejemplo:\njulia @sync begin     for p in procs(S)         @async begin             remotecall_wait(fill!, p, S, p)         end     end end\ndaría como resultado un comportamiento indefinido. Debido a que cada proceso llena la matriz *entera* con su propio `pid`, el proceso que sea el último en ejecutarse (para cualquier elemento en particular de` S`) tendrá su `pid` retenido.\n\nComo un ejemplo más extenso y complejo, considere ejecutar el siguiente \"kernel\" en paralelo:\njulia q[i,j,t+1] = q[i,j,t] + u[i,j,t]\nEn este caso, si tratamos de dividir el trabajo utilizando un índice unidimensional, es probable que tengamos problemas: si `q[i,j,t]` está cerca del final del bloque asignado a un *worker* y `q [i,j,t+1]` está cerca del comienzo del bloque asignado a otro, es muy probable que `q[i,j,t]` no esté listo en el momento en que se necesita para computar `q [i,j,t+1] `. En tales casos, es mejor dividir manualmente la matriz. Vamos a dividirnos a lo largo de la segunda dimensión. Defina una función que devuelve los índices `(irange, jrange)` asignados a este *worker*:\njulia-repl julia> @everywhere function myrange(q::SharedArray)            idx = indexpids(q)            if idx == 0 # This worker is not assigned a piece                return 1:0, 1:0            end            nchunks = length(procs(q))            splits = [round(Int, s) for s in linspace(0,size(q,2),nchunks+1)]            1:size(q,1), splits[idx]+1:splits[idx+1]        end\nA continuación, se define el kernel:\njulia-repl julia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)            @show (irange, jrange, trange)  # display so we can see what's happening            for t in trange, j in jrange, i in irange                q[i,j,t+1] = q[i,j,t] + u[i,j,t]            end            q        end\nPodemos también definir un *wrapper* de conveniencia para una implementación de `SharedArray` \njulia-repl julia> @everywhere advection_shared_chunk!(q, u) =            advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)\nAhora comparemos las tres versiones diferentes, una que ejecuta en un solo proceso:\njulia-repl julia> advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);\nuna que usa [`@parallel`](@ref):\njulia-repl julia> function advection_parallel!(q, u)            for t = 1:size(q,3)-1                @sync @parallel for j = 1:size(q,2)                    for i = 1:size(q,1)                        q[i,j,t+1]= q[i,j,t] + u[i,j,t]                    end                end            end            q        end;\ny una que delega en trozos:\njulia-repl julia> function advection_shared!(q, u)            @sync begin                for p in procs(q)                    @async remotecall_wait(advection_shared_chunk!, p, q, u)                end            end            q        end;\nSi creamos un `SharedArray`s y controlamos el tiempo de estas funciones, obtendremos sl siguiente resultado (con `julia -p 4`):\njulia-repl julia> q = SharedArray{Float64,3}((500,500,500));julia> u = SharedArray{Float64,3}((500,500,500));\nEjecutemos las funciones una vez para tenga lugar la compilación JIT y [`@time`](@ref), y pasemos después a una segunda ejecución:\njulia-repl julia> @time advection_serial!(q, u); (irange,jrange,trange) = (1:500,1:500,1:499)  830.220 milliseconds (216 allocations: 13820 bytes)julia> @time advection_parallel!(q, u);    2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)julia> @time advection_shared!(q,u);         From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)         From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)         From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)         From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)  238.119 milliseconds (2264 allocations: 169 KB)\nLa mayor ventaja de `advection_shared!` es que minimiza el tráfico entre los *workers* permitiendo que cada uno compute para un tiempo extendido sobre la pieiza asignada.\n\n## Arrays Compartidos y Recolección de Basura Distribuida\n\nAl igual que las referencias remotas, las matrices compartidas también dependen de la recolección de basura en el nodo de creación para liberar referencias de todos los *workers* participantes. El código que crea muchos arrays compartidas de vida corta se beneficiaría de finalizar explícitamente estos objetos tan pronto como sea posible. Esto da como resultado que tanto la memoria como los manejadores de archivos mapeen el segmento compartido que se libera antes.\n\n## [ClusterManagers](@id clustermanagers)\n\nEl lanzamiento, la administración y la comunicación en red de los procesos de Julia en un clúster lógico se realiza a través de los administradores del clúster. Un `ClusterManager` es responsable de\n\n  * Lanzar procesos *worker* en un entorno clúster\n  * gestión de eventos durante la vida de cada *worker*\n  * opcionalmente, proporcionar transporte de datos\n  \nUn clúster Julia tiene las siguientes características:\n\n  * El proceso inicial de Julia, también llamado `master`, es especial y tiene un` id` de 1.\n  * Solo el proceso `master` puede agregar o eliminar procesos de trabajo.\n  * Todos los procesos pueden comunicarse directamente entre ellos.\n\nLas conexiones entre los *workers* (utilizando el transporte integrado de TCP/IP) se establecen de la siguiente manera:\n\n  * [`addprocs()`](@ref) se invoca en el proceso maestro con un objeto `ClusterManager`.\n  * [`addprocs()`](@ref) llama al método apropiado [`launch()`](@ref) que engendra el número requerido de procesos de trabajo en las máquinas apropiadas.\n  * Cada *worker* comienza a escuchar en un puerto libre y escribe su información de host y puerto en [`STDOUT`](@ref).\n  * El administrador del clúster captura el [`STDOUT`](@ref) de cada *worker* y lo pone a disposición del proceso maestro.\n  * El proceso maestro analiza esta información y configura conexiones TCP/IP para cada *worker*.\n  * Todos los *workers* también reciben notificaciones de otros trabajadores en el clúster.\n  * Cada *worker* se conecta con todos los *worker* cuyo `id` es menor que su propio` id`.\n  * De esta forma se establece una red de malla, en la que cada *worker* está directamente conectado con cada\n    otro *worker*.\n    \nAunque la capa de transporte predeterminada usa el `TCPSocket` simple, es posible que un clúster Julia proporcione su propio transporte.\n\nJulia proporciona dos administradores de clúster integrados:\n\n  * `LocalManager`, usado cuando se llama a [`addprocs()`](@ref) o a [`addprocs(np::Integer)`](@ref)\n  * `SSHManager`, utilizado cuando se llama a [`addprocs(hostnames::Array)`](@ref con una lista de nombres de host\n  \n`LocalManager` se utiliza para iniciar *workers* adicionales en el mismo host, aprovechando de ese modo los núcleos múltiples\ny el hardware multiprocesador.\n\nPor lo tanto, un administrador de clúster mínimo necesitaría:\n\n  * ser un subtipo del resumen `ClusterManager`\n  * implementar [`launch()`](@ref), un método responsable del lanzamiento de nuevos *workers*\n  * implementar [`manage()`](@ref), que se invoca en varios eventos durante la vida de un *worker* (por ejemplo, enviando una señal de interrupción)\n\n[`addprocs(manager::FooManager)`](@ref addprocs) requiere `FooManager` para implementar:\njulia function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)     [...] endfunction manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)     [...] end\nComo ejemplo, veamos cómo se implementa el `LocalManager`, el administrador responsable de iniciar los *workers* en el mismo host:\njulia struct LocalManager <: ClusterManager     np::Integer endfunction launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)     [...] endfunction manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)     [...] end\nEl método [`launch()`](@ref) toma los siguientes argumentos:\n\n  * `manager::ClusterManager`: el administrador de clúster al que se llama con [`addprocs()`](@ref)\n  * `params::Dict`: todos los argumentos palabra clave pasados ​​a [`addprocs()`](@ref)\n  * `launched::Array`: el array al que agregar uno o más objetos `WorkerConfig`\n  * `c::Condition`:la variable de condición que se notificará cuando se inicien los trabajadores\n\nEl método [`launch()`](@ref) se llama asincrónicamente en una tarea separada. La finalización de esta tarea indica que se han lanzado todos los *workers* solicitados. Por lo tanto, la función [`launch()`](@ref) DEBE salir tan pronto como se hayan lanzado todos los *workers* solicitados.\n\nLos trabajadores recién lanzados están conectados entre sí y el proceso maestro de una manera integral. Al especificar el argumento de la línea de comando `--worker <cookie>` los procesos iniciados se inicializan a sí mismos como trabajadores y las conexiones se configuran a través de sockets TCP / IP. Optionally, `--bind-to bind_addr[:port]` may also be specified to enable other workers to connect to it at the specified `bind_addr` and `port`. Esto es útil para hosts multi-homed.\n\nComo ejemplo de transporte no TCP / IP, una implementación puede optar por utilizar MPI, en cuyo caso `-worker` NO se debe especificar. En cambio, los trabajadores recién lanzados deberían llamar `init_worker (cookie)` antes de usar cualquiera de las construcciones paralelas.\n\nPara cada trabajador puesto en marcha, el método [`launch ()`] (@ref) debe agregar un objeto `WorkerConfig` (con los campos apropiados inicializados) al `launched`\njulia mutable struct WorkerConfig     # Common fields relevant to all cluster managers     io::Nullable{IO}     host::Nullable{AbstractString}     port::Nullable{Integer}# Used when launching additional workers at a host\ncount::Nullable{Union{Int, Symbol}}\nexename::Nullable{AbstractString}\nexeflags::Nullable{Cmd}\n\n# External cluster managers can use this to store information at a per-worker level\n# Can be a dict if multiple fields need to be stored.\nuserdata::Nullable{Any}\n\n# SSHManager / SSH tunnel connections to workers\ntunnel::Nullable{Bool}\nbind_addr::Nullable{AbstractString}\nsshflags::Nullable{Cmd}\nmax_parallel::Nullable{Integer}\n\nconnect_at::Nullable{Any}\n\n[...]end\nLa mayoría de los campos en `WorkerConfig` son utilizados por los administradores incorporados. Gestores de cluster personalizados normalmente especificarían solo `io` o` host` / `port`:\n\n   * Si se especifica `io`, se usa para leer información de host / puerto. Un *worker* Julia imprime su dirección y puerto de enlace al inicio. Esto permite a los *workers* Julia escuchar en cualquier puerto libre disponible en lugar de requerir que los puertos de los trabajadores se configuren manualmente.\n   * Si `io` no está especificado,` host` y `port` se utilizan para conectarse.\n   * `count`,` exename` y `exeflags` son relevantes para el lanzamiento de trabajadores adicionales de un trabajador. Por ejemplo, un administrador de clúster puede iniciar un solo trabajador por nodo y usarlo para iniciar trabajadores adicionales.\n\n      * `count` con un valor entero` n` lanzará un total de `n` *workers*.\n      * `count` con un valor de`: auto` lanzará tantos trabajadores como la cantidad de núcleos en esa máquina.\n      * `exename` es el nombre del ejecutable` julia` que incluye la ruta completa.\n      * `exeflags` debe establecerse en los argumentos de línea de comando necesarios para los nuevos *workers*.\n   * `tunnel`,` bind_addr`, `sshflags` y` max_parallel` se usan cuando se requiere un túnel ssh para conectarse con los *workers* del proceso maestro.\n   * `userdata` se proporciona para que los administradores de clúster personalizados almacenen su propia información específica del *worker*.\n\n`manage (manager :: FooManager, id :: Integer, config :: WorkerConfig, op :: Symbol)` se llama en diferentes momentos durante la vida del trabajador con valores `op` apropiados:\n\n   * con `: register` /`: deregister` cuando un trabajador se agrega / elimina del grupo de *workers* de Julia.\n   * con `: interrupt` cuando se invoca `interrupt(workers)`. El `ClusterManager` debe señalar al *worker* apropiado con una señal de interrupción.\n   * con `: finalize` para fines de limpieza.\n\n## Administradores de Clúster con Transportes Personalizados\n\nReemplazar las conexiones por defecto de socket TCP/IP con una capa de transporte personalizada es un poco más complicado. Cada proceso de Julia tiene tantas tareas de comunicación como los *workers* a los que está conectado. Por ejemplo, considere un clúster de Julia de 32 procesos en una red de malla todos contra todos:\n\n  * Cada proceso de Julia tiene 31 tareas de comunicación.\n  * Cada tarea maneja todos los mensajes entrantes desde un solo *worker* remoto en un bucle de procesamiento de mensajes.\n  * El bucle de procesamiento de mensajes espera en un objeto `IO` (por ejemplo, un` TCPSocket` en la implementación predeterminada), lee un mensaje completo, lo procesa y espera el siguiente.\n  * El envío de mensajes a un proceso se realiza directamente desde cualquier tarea Julia, no solo tareas de comunicación, nuevamente, a través del objeto `IO` apropiado.\n\nReemplazar el transporte predeterminado requiere que la nueva implementación establezca conexiones con *workers* remotos y que proporcione los objetos `IO` apropiados para que los lazos de procesamiento de mensajes puedan esperar. Las devoluciones de llamada específicas del administrador que se implementarán son:\njulia connect(manager::FooManager, pid::Integer, config::WorkerConfig) kill(manager::FooManager, pid::Int, config::WorkerConfig)\nLa implementación por defecto (que usa sockets TCP/IP) se implementa como `connect (manager::ClusterManager, pid::Integer, config::WorkerConfig)`.\n\n`connect` debería devolver un par de objetos` IO`, uno para leer los datos enviados por el `pid` del *worker*, y el otro para escribir datos que deben ser enviados al `pid` del *worker*. Los administradores de clústeres personalizados pueden usar un `BufferStream` en memoria como la conexión de datos proxy entre el *worker* personalizado, posiblemente transporte no-`IO`y la infraestructura paralela incorporada de Julia.\n\nUn `BufferStream` es un `IOBuffer` en memoria que se comporta como un `IO` - es un flujo que puede manejarse de forma asíncrona.\n\nLa carpeta `examples/clustermanager/0MQ` contiene un ejemplo del uso de ZeroMQ para conectar *workers* Julia en una topología en estrella con un intermediario 0MQ en el medio. Nota: Los procesos de Julia todavía están todos *lógicamente* conectados entre sí: cualquier trabajador puede enviar mensajes a cualquier otro trabajador directamente sin que se tenga conocimiento de que se está usando 0MQ como capa de transporte.\n\nAl usar transportes personalizados:\n\n   * Los *workers* de Julia NO deben comenzar con `-worker`. Comenzar con `--worker` dará como resultado que los trabajadores recién lanzados adopten de forma predeterminada la implementación de transporte de socket TCP/IP.\n  * Para cada conexión lógica entrante con un *worker*, se deben llamar `Base.process_messages(rd::IO, wr::IO)()`. Esto inicia una nueva tarea que maneja la lectura y escritura de mensajes desde / hacia el trabajador representado por los objetos `IO`.\n  * `init_worker(cookie, manager::FooManager)` DEBE invocarse como parte de la inicialización del proceso de trabajo.\n  * El campo `connect_at::Any` en `WorkerConfig` puede ser configurado por el administrador del clúster cuando se invoca [`launch()`](@ref). El valor de este campo se transfiere en todas las devoluciones de llamada [`connect()`](@ref). Por lo general, transmite información sobre *cómo conectarse* a un *worker*. Por ejemplo, el transporte de socket TCP/IP utiliza este campo para especificar la tupla `(host, port)` en la que se conecta a un *worker*.\n\n`kill (manager, pid, config)` se llama para eliminar un *worker* del clúster. En el proceso maestro, los objetos `IO` correspondientes deben ser cerrados por la implementación para garantizar una limpieza adecuada. La implementación predeterminada simplemente ejecuta una llamada `exit()` en el *worker* remoto especificado.\n\n`examples/clustermanager/simple` es un ejemplo que muestra una implementación simple usando el dominio UNIX\nenchufes para la configuración del clúster.\n\n## Requisitos de Red para LocalManager y SSHManager\n\nLos clústeres de Julia están diseñados para ejecutarse en entornos ya protegidos en infraestructura, como laptops locales, clusters departamentales o incluso en la nube. Esta sección cubre los requisitos de seguridad de red para los `LocalManager` y `SSHManager` incorporados:\n\n  * El proceso maestro no escucha en ningún puerto. Solo se conecta con los *workers*.\n  * Each worker binds to only one of the local interfaces and listens on the first free port starting from `9009`.\n  * `LocalManager`, usado por `addprocs(N)`, por defecto se une solo a la interfaz *loopback*. Esto significa que los trabajadores que comenzaron más adelante en los hosts remotos (o por cualquier persona con intenciones maliciosas) no pueden conectarse al clúster. Un `addprocs(4)` seguido de un `addprocs([\"remote_host\"])` fallará. Algunos usuarios pueden necesitar crear un clúster que comprenda su sistema local y algunos sistemas remotos.     Esto se puede hacer solicitando explícitamente que `LocalManager` se vincule a una interfaz de red externa mediante el argumento de la palabra clave` restrict`: `addprocs (4; restrict = false)`.\n  * `SSHManager`, utilizado por` addprocs (list_of_remote_hosts) `, inicia trabajadores en hosts remotos a través de SSH.\n    Por defecto, SSH solo se usa para iniciar los trabajadores de Julia. Las conexiones subsiguientes de maestro-trabajador y trabajador-trabajador usan conectores TCP / IP sin cifrar. Los hosts remotos deben tener habilitado el inicio de sesión sin contraseña. Se pueden especificar indicadores o credenciales SSH adicionales a través del argumento de palabra clave `sshflags`.\n  * `addprocs (list_of_remote_hosts; tunnel = true, sshflags = <ssh keys y otros flags>)` es útil cuando deseamos usar conexiones SSH para el maestro trabajador también. Un escenario típico para esto es una computadora portátil local que ejecuta el REPL de Julia (es decir, el maestro) con el resto del clúster en la nube, por ejemplo en Amazon EC2. En este caso, solo se debe abrir el puerto 22 en el clúster remoto junto con el cliente SSH autenticado a través de la infraestructura de clave pública (PKI). Las credenciales de autenticación se pueden suministrar a través de `sshflags`, por ejemplo ```sshflags =`-e <keyfile>` ```.\n\nNote that worker-worker connections are still plain TCP and the local security policy on the remote cluster must allow for free connections between worker nodes, at least for ports 9009 and above.\n\n    Asegurar y encriptar todo el tráfico de trabajador-trabajador (a través de SSH) o encriptar mensajes individuales se puede hacer a través de un ClusterManager personalizado.\n    \n## Cluster Cookie\n\nTodos los procesos en un clúster comparten la misma cookie que, de forma predeterminada, es una cadena generada aleatoriamente en el proceso maestro:\n\n  * [`Base.cluster_cookie()`](@ref) devuelve la cookie, mientras `Base.cluster_cookie(cookie)()` lo configura y devuelve la nueva cookie.\n  * Todas las conexiones están autenticadas en ambos lados para garantizar que solo los *workers* iniciados por el maestro puedan conectarse entre sí.\n  * The cookie must be passed to the workers at startup via argument `--worker <cookie>`. Custom ClusterManagers can retrieve the cookie on the master by calling [`Base.cluster_cookie()`](@ref). Cluster managers not using the default TCP/IP transport (and hence not specifying `--worker`) must call `init_worker(cookie, manager)` with the same cookie as on the master.\n\nTenga en cuenta que los entornos que requieren mayores niveles de seguridad pueden implementar esto a través de un `ClusterManager` personalizado. Por ejemplo, las cookies se pueden compartir previamente y, por lo tanto, no se especifican como un argumento de inicio.\n\n## Specifying Network Topology (Experimental)\n\nEl argumento de palabra clave `topología` pasado a `addprocs` se usa para especificar cómo los trabajadores deben estar conectados entre sí:\n\n  * `: all_to_all`, el valor predeterminado: todos los trabajadores están conectados entre sí.\n  * `: master_slave`: solo el proceso del controlador, es decir,` pid` 1, tiene conexiones con los trabajadores.\n  * `: custom`: el método` launch` del administrador del clúster especifica la topología de conexión a través del\n    campos `ident` y` connect_idents` en `WorkerConfig`. Un trabajador con un cluster-manager-provided\n    identidad `ident` se conectará a todos los trabajadores especificados en `connect_idents`.\n\nActualmente, enviar un mensaje entre *workers* desconectados genera un error. Este comportamiento, al igual que la funcionalidad y la interfaz, debe considerarse de naturaleza experimental y puede cambiar en versiones futuras.\n\n\n## Multi-Threading (Experimental)\n\nAdemás de las tareas, llamadas remotas y referencias remotas, Julia desde la `v0.5` hacia delante admitirá de forma nativa soporte para multi-hilo. Tenga en cuenta que esta sección es experimental y las interfaces pueden cambiar en el futuro.\n\n### Setup\n\nPor defecto, Julia se inicia con un único hilo de ejecución. Esto se puede verificar utilizando el mandato [`Threads.nthreads ()`](@ref):\njulia-repl julia> Threads.nthreads() 1\nEl número de hilos con los que arranca Julia está controlado por una variable de entorno llamada `JULIA_NUM_THREADS`. Ahora, comencemos Julia con 4 hilos:\nbash export JULIA_NUM_THREADS=4\n(El mandato anterior funciona en shells de Bourne shells de Linux y OSX. Tenga en cuenta que si usa un C shell en estas plataformas, debe usar la palabra clave `set` en lugar de` export`. Si está en Windows, inicie la línea de órdenes en la ubicación de `julia.exe` y use `set` en lugar de `export`.)\n\nVerifiquemos que hay 4 hilos a nuestra disposición.\njulia-repl julia> Threads.nthreads() 4\nPero actualmente estamos en el hilo maestro. Para verificar, usamos el mandato [`Threads.threadid()`](@ref)\njulia-repl julia> Threads.threadid() 1\n### La Macro `@threads` \n\nVamos a trabajar un ejemplo simple usando nuestros hilos nativos. Creemos un array de ceros:\njldoctest julia> a = zeros(10) 10-element Array{Float64,1}:  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\nOperemos sobre este array de forma simultánea utilizando 4 hilos. Haremos que cada hilo escriba su ID de hilo en cada ubicación.\n\nJulia soporta bucles paralelos utilizando la macro [`Threads.@Threads`](@ref). Esta macro está fijada delante de un bucle `for` para indicar a Julia que el bucle es una región con múltiples subprocesos:\njulia-repl julia> Threads.@threads for i = 1:10            a[i] = Threads.threadid()        end\nEl espacio de iteración se divide entre los hilos, después de lo cual cada hilo escribe su ID de hilo a sus ubicaciones asignadas:\njulia-repl julia> a 10-element Array{Float64,1}:  1.0  1.0  1.0  2.0  2.0  2.0  3.0  3.0  4.0  4.0 ```Tenga en cuenta que Threads.@threads no tiene un parámetro de reducción opcional como @parallel."
},

{
    "location": "manual/parallel-computing.html#@threadcall-(Experimental)-1",
    "page": "Computación Paralela",
    "title": "@threadcall (Experimental)",
    "category": "section",
    "text": "Todas las tareas de E/S, temporizadores, comandos REPL, etc. se multiplexan en una sola cadena del sistema operativo mediante un bucle de eventos. Una versión parcheada de libuv (http://docs.libuv.org/en/v1.x/] proporciona esta funcionalidad. Los puntos de rendimiento proporcionan la planificación cooperativa de tareas múltiples en el mismo hilo del sistema operativo. Las tareas de E/S y los temporizadores se producen implícitamente mientras se espera que ocurra el evento. Llamar a yield() explícitamente permite planificar otras tareas.Por lo tanto, una tarea que ejecuta un ccall evita efectivamente que el planificador Julia ejecute otras tareas hasta que la llamada regrese. Esto es cierto para todas las llamadas a bibliotecas externas. Las excepciones son llamadas al código C personalizado que devuelve la llamada a Julia (que luego puede ceder) o al código C que llama a jl_yield() (C equivalente a yield()).Note that while Julia code runs on a single thread (by default), libraries used by Julia may launch their own internal threads. For example, the BLAS library may start as many threads as there are cores on a machine.La macro @ threadcall trata los escenarios donde no queremos que un ccall bloquee el ciclo principal de eventos de Julia. Planifica una función C para su ejecución en un hilo separado. Para esto, se usa un pool de hilos con un tamaño predeterminado de 4. El tamaño del pool de hilos se controla mediante la variable de entorno UV_THREADPOOL_SIZE. Mientras espera un hilo libre, y durante la ejecución de la función una vez que un hilo está disponible, la tarea solicitante (en el ciclo de eventos principal de Julia) cede a otras tareas. Tenga en cuenta que @threadcall no regresa hasta que se completa la ejecución. Desde el punto de vista del usuario, es por lo tanto una llamada de bloqueo como otras API de Julia.Es muy importante que la función llamada no vuelva a llamar a Julia.@threadcall puede ser eliminada / cambiada en futuras versiones de Julia.[1]: In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding RMA to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see http://mpi-forum.org/docs."
},

{
    "location": "manual/dates.html#",
    "page": "Date and DateTime",
    "title": "Date and DateTime",
    "category": "page",
    "text": ""
},

{
    "location": "manual/dates.html#dates-1",
    "page": "Date and DateTime",
    "title": "Date and DateTime",
    "category": "section",
    "text": "CurrentModule = Base.DatesThe Dates module provides two types for working with dates: Date and DateTime, representing day and millisecond precision, respectively; both are subtypes of the abstract TimeType. The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don't have to be dealt with. For example, since the Date type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.Both Date and DateTime are basically immutable Int64 wrappers. The single instant field of either type is actually a UTInstant{P} type, which represents a continuously increasing machine timeline based on the UT second [1]. The DateTime type is not aware of time zones (naive, in Python parlance), analogous to a LocalDateTime in Java 8. Additional time zone functionality can be added through the TimeZones.jl package, which compiles the IANA time zone database. Both Date and DateTime are based on the ISO 8601 standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so 0000-12-31 is the day before 0001-01-01, and year -0001 (yes, negative one for the year) is 2 BC/BCE, year -0002 is 3 BC/BCE, etc.[1]: The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a \"UT second\", as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that Date and DateTime are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called UT or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates."
},

{
    "location": "manual/dates.html#Constructors-1",
    "page": "Date and DateTime",
    "title": "Constructors",
    "category": "section",
    "text": "Date and DateTime types can be constructed by integer or Period types, by parsing, or through adjusters (more on those later):julia> DateTime(2013)\n2013-01-01T00:00:00\n\njulia> DateTime(2013,7)\n2013-07-01T00:00:00\n\njulia> DateTime(2013,7,1)\n2013-07-01T00:00:00\n\njulia> DateTime(2013,7,1,12)\n2013-07-01T12:00:00\n\njulia> DateTime(2013,7,1,12,30)\n2013-07-01T12:30:00\n\njulia> DateTime(2013,7,1,12,30,59)\n2013-07-01T12:30:59\n\njulia> DateTime(2013,7,1,12,30,59,1)\n2013-07-01T12:30:59.001\n\njulia> Date(2013)\n2013-01-01\n\njulia> Date(2013,7)\n2013-07-01\n\njulia> Date(2013,7,1)\n2013-07-01\n\njulia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))\n2013-07-01\n\njulia> Date(Dates.Month(7),Dates.Year(2013))\n2013-07-01Date or DateTime parsing is accomplished by the use of format strings. Format strings work by the notion of defining delimited or fixed-width \"slots\" that contain a period to parse and passing the text to parse and format string to a Date or DateTime constructor, of the form Date(\"2015-01-01\",\"y-m-d\") or DateTime(\"20150101\",\"yyyymmdd\").Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so \"y-m-d\" lets the parser know that between the first and second slots in a date string like \"2014-07-16\", it should find the - character. The y, m, and d characters let the parser know which periods to parse in each slot.Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So \"yyyymmdd\" would correspond to a date string like \"20140716\". The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition \"yyyymm\" from one period character to the next.Support for text-form month parsing is also supported through the u and U characters, for abbreviated and full-length month names, respectively. By default, only English month names are supported, so u corresponds to \"Jan\", \"Feb\", \"Mar\", etc. And U corresponds to \"January\", \"February\", \"March\", etc. Similar to other name=>value mapping functions dayname() and monthname(), custom locales can be loaded by passing in the locale=>Dict{String,Int} mapping to the MONTHTOVALUEABBR and MONTHTOVALUE dicts for abbreviated and full-name month names, respectively.One note on parsing performance: using the Date(date_string,format_string) function is fine if only called a few times. If there are many similarly formatted date strings to parse however, it is much more efficient to first create a Dates.DateFormat, and pass it instead of a raw format string.julia> df = DateFormat(\"y-m-d\");\n\njulia> dt = Date(\"2015-01-01\",df)\n2015-01-01\n\njulia> dt2 = Date(\"2015-01-02\",df)\n2015-01-02You can also use the dateformat\"\" string macro. This macro creates the DateFormat object once when the macro is expanded and uses the same DateFormat object even if a code snippet is run multiple times.julia> for i = 1:10^5\n           Date(\"2015-01-01\", dateformat\"y-m-d\")\n       endA full suite of parsing and formatting tests and examples is available in tests/dates/io.jl."
},

{
    "location": "manual/dates.html#Durations/Comparisons-1",
    "page": "Date and DateTime",
    "title": "Durations/Comparisons",
    "category": "section",
    "text": "Finding the length of time between two Date or DateTime is straightforward given their underlying representation as UTInstant{Day} and UTInstant{Millisecond}, respectively. The difference between Date is returned in the number of Day, and DateTime in the number of Millisecond. Similarly, comparing TimeType is a simple matter of comparing the underlying machine instants (which in turn compares the internal Int64 values).julia> dt = Date(2012,2,29)\n2012-02-29\n\njulia> dt2 = Date(2000,2,1)\n2000-02-01\n\njulia> dump(dt)\nDate\n  instant: Base.Dates.UTInstant{Base.Dates.Day}\n    periods: Base.Dates.Day\n      value: Int64 734562\n\njulia> dump(dt2)\nDate\n  instant: Base.Dates.UTInstant{Base.Dates.Day}\n    periods: Base.Dates.Day\n      value: Int64 730151\n\njulia> dt > dt2\ntrue\n\njulia> dt != dt2\ntrue\n\njulia> dt + dt2\nERROR: MethodError: no method matching +(::Date, ::Date)\n[...]\n\njulia> dt * dt2\nERROR: MethodError: no method matching *(::Date, ::Date)\n[...]\n\njulia> dt / dt2\nERROR: MethodError: no method matching /(::Date, ::Date)\n[...]\n\njulia> dt - dt2\n4411 days\n\njulia> dt2 - dt\n-4411 days\n\njulia> dt = DateTime(2012,2,29)\n2012-02-29T00:00:00\n\njulia> dt2 = DateTime(2000,2,1)\n2000-02-01T00:00:00\n\njulia> dt - dt2\n381110400000 milliseconds"
},

{
    "location": "manual/dates.html#Accessor-Functions-1",
    "page": "Date and DateTime",
    "title": "Accessor Functions",
    "category": "section",
    "text": "Because the Date and DateTime types are stored as single Int64 values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:julia> t = Date(2014, 1, 31)\n2014-01-31\n\njulia> Dates.year(t)\n2014\n\njulia> Dates.month(t)\n1\n\njulia> Dates.week(t)\n5\n\njulia> Dates.day(t)\n31While propercase return the same value in the corresponding Period type:julia> Dates.Year(t)\n2014 years\n\njulia> Dates.Day(t)\n31 daysCompound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:julia> Dates.yearmonth(t)\n(2014, 1)\n\njulia> Dates.monthday(t)\n(1, 31)\n\njulia> Dates.yearmonthday(t)\n(2014, 1, 31)One may also access the underlying UTInstant or integer value:julia> dump(t)\nDate\n  instant: Base.Dates.UTInstant{Base.Dates.Day}\n    periods: Base.Dates.Day\n      value: Int64 735264\n\njulia> t.instant\nBase.Dates.UTInstant{Base.Dates.Day}(735264 days)\n\njulia> Dates.value(t)\n735264"
},

{
    "location": "manual/dates.html#Query-Functions-1",
    "page": "Date and DateTime",
    "title": "Query Functions",
    "category": "section",
    "text": "Query functions provide calendrical information about a TimeType. They include information about the day of the week:julia> t = Date(2014, 1, 31)\n2014-01-31\n\njulia> Dates.dayofweek(t)\n5\n\njulia> Dates.dayname(t)\n\"Friday\"\n\njulia> Dates.dayofweekofmonth(t) # 5th Friday of January\n5Month of the year:julia> Dates.monthname(t)\n\"January\"\n\njulia> Dates.daysinmonth(t)\n31As well as information about the TimeType's year and quarter:julia> Dates.isleapyear(t)\nfalse\n\njulia> Dates.dayofyear(t)\n31\n\njulia> Dates.quarterofyear(t)\n1\n\njulia> Dates.dayofquarter(t)\n31The dayname() and monthname() methods can also take an optional locale keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely dayabbr() and monthabbr(). First the mapping is loaded into the LOCALES variable:julia> french_months = [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\",\n                        \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"];\n\njulia> french_monts_abbrev = [\"janv\",\"févr\",\"mars\",\"avril\",\"mai\",\"juin\",\n                              \"juil\",\"août\",\"sept\",\"oct\",\"nov\",\"déc\"];\n\njulia> french_days = [\"lundi\",\"mardi\",\"mercredi\",\"jeudi\",\"vendredi\",\"samedi\",\"dimanche\"];\n\njulia> Dates.LOCALES[\"french\"] = Dates.DateLocale(french_months, french_monts_abbrev, french_days, [\"\"]);The above mentioned functions can then be used to perform the queries:julia> Dates.dayname(t;locale=\"french\")\n\"vendredi\"\n\njulia> Dates.monthname(t;locale=\"french\")\n\"janvier\"\n\njulia> Dates.monthabbr(t;locale=\"french\")\n\"janv\"Since the abbreviated versions of the days are not loaded, trying to use the function dayabbr() will error.julia> Dates.dayabbr(t;locale=\"french\")\nERROR: BoundsError: attempt to access 1-element Array{String,1} at index [5]\nStacktrace:\n [1] #dayabbr#6(::String, ::Function, ::Int64) at ./dates/query.jl:114\n [2] (::Base.Dates.#kw##dayabbr)(::Array{Any,1}, ::Base.Dates.#dayabbr, ::Int64) at ./<missing>:0 (repeats 2 times)"
},

{
    "location": "manual/dates.html#TimeType-Period-Arithmetic-1",
    "page": "Date and DateTime",
    "title": "TimeType-Period Arithmetic",
    "category": "section",
    "text": "It's good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some tricky issues to deal with (though much less so for day-precision types).The Dates module approach tries to follow the simple principle of trying to change as little as possible when doing Period arithmetic. This approach is also often known as calendrical arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let's take a classic example: add 1 month to January 31st, 2014. What's the answer? Javascript will say March 3 (assumes 31 days). PHP says March 2 (assumes 30 days). The fact is, there is no right answer. In the Dates module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, 2014-02-28 + Month(1) == 2014-03-28. What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we're done because that's a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:julia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)\n2014-02-28\n\njulia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)\n2014-03-01What's going on there? In the first line, we're adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28. In the second example, we add 1 month first, where we get 2014-02-29, which adjusts down to 2014-02-28, and then add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods, the operations will be ordered by the Periods' types, not their value or positional order; this means Year will always be added first, then Month, then Week, etc. Hence the following does result in associativity and Just Works:julia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)\n2014-03-01\n\njulia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)\n2014-03-01Tricky? Perhaps. What is an innocent Dates user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that's pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the \"joys\" of dealing with daylight savings, leap seconds, etc.).As a bonus, all period arithmetic objects work directly with ranges:julia> dr = Date(2014,1,29):Date(2014,2,3)\n2014-01-29:1 day:2014-02-03\n\njulia> collect(dr)\n6-element Array{Date,1}:\n 2014-01-29\n 2014-01-30\n 2014-01-31\n 2014-02-01\n 2014-02-02\n 2014-02-03\n\njulia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)\n2014-01-29:1 month:2014-07-29\n\njulia> collect(dr)\n7-element Array{Date,1}:\n 2014-01-29\n 2014-02-28\n 2014-03-29\n 2014-04-29\n 2014-05-29\n 2014-06-29\n 2014-07-29"
},

{
    "location": "manual/dates.html#Adjuster-Functions-1",
    "page": "Date and DateTime",
    "title": "Adjuster Functions",
    "category": "section",
    "text": "As convenient as date-period arithmetics are, often the kinds of calculations needed on dates take on a calendrical or temporal nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as \"Memorial Day = Last Monday of May\", or \"Thanksgiving = 4th Thursday of November\". These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.The Dates module provides the adjuster API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single TimeType as input and return or adjust to the first or last of the desired period relative to the input.julia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input's week\n2014-07-14\n\njulia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input's month\n2014-07-31\n\njulia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input's quarter\n2014-09-30The next two higher-order methods, tonext(), and toprev(), generalize working with temporal expressions by taking a DateFunction as first argument, along with a starting TimeType. A DateFunction is just a function, usually anonymous, that takes a single TimeType as input and returns a Bool, true indicating a satisfied adjustment criterion. For example:julia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday # Returns true if the day of the week of x is Tuesday\n(::#1) (generic function with 1 method)\n\njulia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 is a Sunday\n2014-07-15\n\njulia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # Convenience method provided for day of the week adjustments\n2014-07-15This is useful with the do-block syntax for more complex temporal expressions:julia> Dates.tonext(Date(2014,7,13)) do x\n           # Return true on the 4th Thursday of November (Thanksgiving)\n           Dates.dayofweek(x) == Dates.Thursday &&\n           Dates.dayofweekofmonth(x) == 4 &&\n           Dates.month(x) == Dates.November\n       end\n2014-11-27The Base.filter() method can be used to obtain all valid dates/moments in a specified range:# Pittsburgh street cleaning; Every 2nd Tuesday from April to November\n# Date range from January 1st, 2014 to January 1st, 2015\njulia> dr = Dates.Date(2014):Dates.Date(2015);\n\njulia> filter(dr) do x\n           Dates.dayofweek(x) == Dates.Tue &&\n           Dates.April <= Dates.month(x) <= Dates.Nov &&\n           Dates.dayofweekofmonth(x) == 2\n       end\n8-element Array{Date,1}:\n 2014-04-08\n 2014-05-13\n 2014-06-10\n 2014-07-08\n 2014-08-12\n 2014-09-09\n 2014-10-14\n 2014-11-11Additional examples and tests are available in test/dates/adjusters.jl."
},

{
    "location": "manual/dates.html#Period-Types-1",
    "page": "Date and DateTime",
    "title": "Period Types",
    "category": "section",
    "text": "Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context. Or a year could represent 365 or 366 days in the case of a leap year. Period types are simple Int64 wrappers and are constructed by wrapping any Int64 convertible type, i.e. Year(1) or Month(3.0). Arithmetic between Period of the same type behave like integers, and limited Period-Real arithmetic is available.julia> y1 = Dates.Year(1)\n1 year\n\njulia> y2 = Dates.Year(2)\n2 years\n\njulia> y3 = Dates.Year(10)\n10 years\n\njulia> y1 + y2\n3 years\n\njulia> div(y3,y2)\n5\n\njulia> y3 - y2\n8 years\n\njulia> y3 % y2\n0 years\n\njulia> div(y3,3) # mirrors integer division\n3 years"
},

{
    "location": "manual/dates.html#Rounding-1",
    "page": "Date and DateTime",
    "title": "Rounding",
    "category": "section",
    "text": "Date and DateTime values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with floor(), ceil(), or round():julia> floor(Date(1985, 8, 16), Dates.Month)\n1985-08-01\n\njulia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n2013-02-13T00:45:00\n\njulia> round(DateTime(2016, 8, 6, 20, 15), Dates.Day)\n2016-08-07T00:00:00Unlike the numeric round() method, which breaks ties toward the even number by default, the TimeTyperound() method uses the RoundNearestTiesUp rounding mode. (It's difficult to guess what breaking ties to nearest \"even\" TimeType would entail.) Further details on the available RoundingMode s can be found in the API reference.Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is not obvious."
},

{
    "location": "manual/dates.html#Rounding-Epoch-1",
    "page": "Date and DateTime",
    "title": "Rounding Epoch",
    "category": "section",
    "text": "In many cases, the resolution specified for rounding (e.g., Dates.Second(30)) divides evenly into the next largest period (in this case, Dates.Minute(1)). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a DateTime to the nearest 10 hours?julia> round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))\n2016-07-17T12:00:00That may seem confusing, given that the hour (12) is not divisible by 10. The reason that 2016-07-17T12:00:00 was chosen is that it is 17,676,660 hours after 0000-01-01T00:00:00, and 17,676,660 is divisible by 10.As Julia Date and DateTime values are represented according to the ISO 8601 standard, 0000-01-01T00:00:00 was chosen as base (or \"rounding epoch\") from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia's internal representation of Date s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, 0000-01-01T00:00:00 was chosen as the rounding epoch instead of the 0000-12-31T00:00:00 used internally to minimize confusion.)The only exception to the use of 0000-01-01T00:00:00 as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use 0000-01-03T00:00:00 (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest P(2), where P is a Period type? In some cases (specifically, when P <: Dates.TimePeriod) the answer is clear:julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))\n2016-07-17T08:00:00\n\njulia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))\n2016-07-17T08:56:00This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))\n2016-07-01T00:00:00Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0).This means that rounding a DateTime to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a DateTime with an even value in that field, while rounding a DateTime to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.See the API reference for additional information on methods exported from the Dates module."
},

{
    "location": "manual/interacting-with-julia.html#",
    "page": "Interactuando con Julia",
    "title": "Interactuando con Julia",
    "category": "page",
    "text": ""
},

{
    "location": "manual/interacting-with-julia.html#interacting-with-julia-1",
    "page": "Interactuando con Julia",
    "title": "Interactuando con Julia",
    "category": "section",
    "text": "Julia viene con un REPL (read-eval-print loop) interactivo de línea de comando  integrado en el ejecutable julia. Además de permitir una evaluación rápida y fácil de las declaraciones de Julia, tiene un historial de búsqueda, finalización de pestañas, muchas combinaciones útiles de teclas, ayuda dedicada y modos de shell. El REPL se puede iniciar simplemente llamando a julia sin argumentos o haciendo doble clic en el ejecutable:$ julia\n               _\n   _       _ _(_)_     |  A fresh approach to technical computing\n  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org\n   _ _   _| |_  __ _   |  Type \"?help\" for help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 0.6.0-dev.2493 (2017-01-31 18:53 UTC)\n _/ |\\__'_|_|_|\\__'_|  |  Commit c99e12c* (0 days old master)\n|__/                   |  x86_64-linux-gnu\n\njulia>Para salir de la sesión interactiva, escriba ^D - la tecla de control junto con la tecla d en una línea en blanco - o escriba quit() seguido de la tecla return o enter. El REPL te saluda con un banner y un prompt julia>."
},

{
    "location": "manual/interacting-with-julia.html#Los-distintos-modos-de-prompt-1",
    "page": "Interactuando con Julia",
    "title": "Los distintos modos de prompt",
    "category": "section",
    "text": ""
},

{
    "location": "manual/interacting-with-julia.html#El-modo-Juliano-1",
    "page": "Interactuando con Julia",
    "title": "El modo Juliano",
    "category": "section",
    "text": "El REPL tiene cuatro modos principales de operación. El primero y más común es el prompt Juliano. Es el modo de operación predeterminado; cada nueva línea inicialmente comienza con julia>. Es aquí donde puede ingresar las expresiones de Julia. Pulsando return o enter después de haber ingresado una expresión completa, se evaluará la entrada y se mostrará el resultado de la última expresión.julia> string(1 + 2)\n\"3\"Hay varias funciones útiles únicas para el trabajo interactivo. Además de mostrar el resultado, el REPL también vincula el resultado a la variable ans. Un punto y coma final en la línea se puede utilizar como un indicador para suprimir mostrar el resultado.julia> string(3 * 4);\n\njulia> ans\n\"12\"En el modo Julia, el REPL es compatible con algo llamado pegado rápido. Esto se activa al pegar texto que comienza con julia> en REPL. En ese caso, solo las expresiones que comienzan con julia> se analizan, otras se eliminan. Esto hace que sea posible pegar un trozo de código que ha sido copiado de una sesión REPL sin tener que eliminar los prompts y las salidas. Esta característica está habilitada de forma predeterminada, pero se puede desactivar o habilitar a voluntad con Base.REPL.enable_promptpaste(:: Bool). Si está habilitado, puedes probar pegando el bloque de código arriba de este párrafo directamente en REPL. Esta función no funciona en el símbolo del sistema estándar de Windows debido a su limitación para detectar cuándo se produce un pegado."
},

{
    "location": "manual/interacting-with-julia.html#Modo-Ayuda-1",
    "page": "Interactuando con Julia",
    "title": "Modo Ayuda",
    "category": "section",
    "text": "Cuando el cursor está al principio de la línea, el aviso se puede cambiar a un modo de ayuda escribiendo ?. Julia intentará imprimir ayuda o documentación para todo lo ingresado en modo de ayuda:julia> ? # upon typing ?, the prompt changes (in place) to: help?>\n\nhelp?> string\nsearch: string String stringmime Cstring Cwstring RevString readstring randstring bytestring SubString\n\n  string(xs...)\n\n  Create a string from any values using the print function.Las macros, los tipos y las variables también se pueden consultar:help?> @time\n  @time\n\n  A macro to execute an expression, printing the time it took to execute, the number of allocations,\n  and the total number of bytes its execution caused to be allocated, before returning the value of the\n  expression.\n\n  See also @timev, @timed, @elapsed, and @allocated.\n\nhelp?> AbstractString\nsearch: AbstractString AbstractSparseMatrix AbstractSparseVector AbstractSet\n\n  No documentation found.\n\n  Summary:\n\n  abstract AbstractString <: Any\n\n  Subtypes:\n\n  Base.Test.GenericString\n  DirectIndexString\n  StringEl modo de ayuda puede salir presionando la tecla de retroceso al comienzo de la línea."
},

{
    "location": "manual/interacting-with-julia.html#man-shell-mode-1",
    "page": "Interactuando con Julia",
    "title": "Modo Shell",
    "category": "section",
    "text": "Del mismo modo que el modo de ayuda es útil para acceder rápidamente a la documentación, otra tarea común es utilizar el shell del sistema para ejecutar los comandos del sistema. Así como ? Ingresó al modo de ayuda cuando está al principio de la línea, un punto y coma (;) ingresará al modo shell. Y puede salir presionando el retroceso al comienzo de la línea.julia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> echo hello\nhello"
},

{
    "location": "manual/interacting-with-julia.html#Modos-de-búsqueda-1",
    "page": "Interactuando con Julia",
    "title": "Modos de búsqueda",
    "category": "section",
    "text": "En todos los modos anteriores, las líneas ejecutadas se guardan en un archivo de historial, que se puede buscar. Para iniciar una búsqueda incremental a través del historial anterior, escriba ^R - la tecla de control junto con la tecla r. El aviso cambiará a (reverse-i-search)` ':, y al escribir, la consulta de búsqueda aparecerá en las comillas. El resultado más reciente que coincida con la consulta se actualizará dinámicamente a la derecha de los dos puntos a medida que se escriba más. Para encontrar un resultado anterior usando la misma consulta, simplemente escriba ^R de nuevo.Del mismo modo que ^ R es una búsqueda inversa,^ S es una búsqueda directa, con el indicador (i-search)` ':. Los dos pueden usarse conjuntamente para avanzar entre los resultados de coincidencia anterior o siguiente, respectivamente."
},

{
    "location": "manual/interacting-with-julia.html#Asociaciones-de-teclas-1",
    "page": "Interactuando con Julia",
    "title": "Asociaciones de teclas",
    "category": "section",
    "text": "El REPL de Julia hace un gran uso de las asociaciones de teclas. Varias combinaciones de teclas de control ya se han introducido anteriormente (^D para salir,^R y ^S para buscar), pero hay muchas más. Además de la tecla de control, también hay enlaces de meta-clave. Estos varían según la plataforma, pero la mayoría de los terminales utilizan de forma predeterminada alt- u opción-, mantenida presionada con una tecla para enviar la meta-clave (o puede configurarse para hacerlo).Keybinding Description\nProgram control  \n^D Exit (when buffer is empty)\n^C Interrupt or cancel\n^L Clear console screen\nReturn/Enter, ^J New line, executing if it is complete\nmeta-Return/Enter Insert new line without executing it\n? or ; Enter help or shell mode (when at start of a line)\n^R, ^S Incremental history search, described above\nCursor movement  \nRight arrow, ^F Move right one character\nLeft arrow, ^B Move left one character\nHome, ^A Move to beginning of line\nEnd, ^E Move to end of line\n^P Change to the previous or next history entry\n^N Change to the next history entry\nUp arrow Move up one line (or to the previous history entry)\nDown arrow Move down one line (or to the next history entry)\nPage-up Change to the previous history entry that matches the text before the cursor\nPage-down Change to the next history entry that matches the text before the cursor\nmeta-F Move right one word\nmeta-B Move left one word\nEditing  \nBackspace, ^H Delete the previous character\nDelete, ^D Forward delete one character (when buffer has text)\nmeta-Backspace Delete the previous word\nmeta-D Forward delete the next word\n^W Delete previous text up to the nearest whitespace\n^K \"Kill\" to end of line, placing the text in a buffer\n^Y \"Yank\" insert the text from the kill buffer\n^T Transpose the characters about the cursor\n^Q Write a number in REPL and press ^Q to open editor at corresponding stackframe"
},

{
    "location": "manual/interacting-with-julia.html#Personalizando-asociaciones-de-teclas-1",
    "page": "Interactuando con Julia",
    "title": "Personalizando asociaciones de teclas",
    "category": "section",
    "text": "Las combinaciones de teclas en el REPL de Julia pueden personalizarse completamente según las preferencias de un usuario pasando un diccionario a REPL.setup_interface(). Las claves de este diccionario pueden ser caracteres o cadenas. La tecla '*' se refiere a la acción predeterminada. Las asociaciones de control y carácter x se indican con\"^x\". Meta plus x se puede escribir\"\\\\ Mx\". Los valores del mapa de teclas personalizado deben ser nothing (lo que indica que la entrada debe ignorarse) o las funciones que aceptan la firma (PromptState, AbstractREPL, Char). La función REPL.setup_interface() debe invocarse antes de que se inicialice REPL, registrando la operación con atreplinit(). Por ejemplo, para enlazar las teclas de flecha hacia arriba y hacia abajo para moverse a través del historial sin búsqueda de prefijos, uno podría poner el siguiente código en .juliarc.jl:import Base: LineEdit, REPL\n\nconst mykeys = Dict{Any,Any}(\n    # Up Arrow\n    \"\\e[A\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),\n    # Down Arrow\n    \"\\e[B\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))\n)\n\nfunction customize_keys(repl)\n    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)\nend\n\natreplinit(customize_keys)Los usuarios deberían consultar base/LineEdit.jl para descubrir las acciones disponibles sobre la entrada clave."
},

{
    "location": "manual/interacting-with-julia.html#Uso-de-Tab-para-completar-expresiones-1",
    "page": "Interactuando con Julia",
    "title": "Uso de Tab para completar expresiones",
    "category": "section",
    "text": "Tanto en los moddos Juliano como de ayuda del REPL, uno puede entrar los primeros caracteres de una función o tipo y luego pulsar la tecla del tabulador para obtener una lista de posibles coincidencias:julia> stri[TAB]\nstride     strides     string      stringmime  strip\n\njulia> Stri[TAB]\nStridedArray    StridedMatrix    StridedVecOrMat  StridedVector    StringLa tecla tabulador puede también usarse para sustituir los símbolos matemáticos de LaTeX con sus equivalentes Unicode, y obtener también una lista de coincidencias LaTeX:julia> \\pi[TAB]\njulia> π\nπ = 3.1415926535897...\n\njulia> e\\_1[TAB] = [1,0]\njulia> e₁ = [1,0]\n2-element Array{Int64,1}:\n 1\n 0\n\njulia> e\\^1[TAB] = [1 0]\njulia> e¹ = [1 0]\n1×2 Array{Int64,2}:\n 1  0\n\njulia> \\sqrt[TAB]2     # √ is equivalent to the sqrt() function\njulia> √2\n1.4142135623730951\n\njulia> \\hbar[TAB](h) = h / 2\\pi[TAB]\njulia> ħ(h) = h / 2π\nħ (generic function with 1 method)\n\njulia> \\h[TAB]\n\\hat              \\hermitconjmatrix  \\hkswarow          \\hrectangle\n\\hatapprox        \\hexagon           \\hookleftarrow     \\hrectangleblack\n\\hbar             \\hexagonblack      \\hookrightarrow    \\hslash\n\\heartsuit        \\hksearow          \\house             \\hspace\n\njulia> α=\"\\alpha[TAB]\"   # LaTeX completion also works in strings\njulia> α=\"α\"En la sección Entrada Unicode del manual puede encontrarse una lista completa de finalizaciones usando tabulador.En modo shell también puede usarse el tabulador para completar cadenas relativas a caminos de fichero:julia> path=\"/[TAB]\"\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/\nshell> /[TAB]\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/Esta funcionalidad puede ayudar con la investigación de los métodos disponibles que coinciden con los argumentos de entrada:julia> max([TAB] # All methods are displayed, not shown here due to size of the list\n\njulia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument\nmax(x, y) in Base at operators.jl:215\nmax(a, b, c, xs...) in Base at operators.jl:281\n\njulia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.\nmax(x, y) in Base at operators.jl:215\nmax(a, b, c, xs...) in Base at operators.jl:281Las palabras clave (keywords) son también mostradas en los métodos sugeridos, ver la segunda línea después de ; donde limit y keep son argumentos palabras clave:julia> split(\"1 1 1\", [TAB]\nsplit(str::AbstractString) in Base at strings/util.jl:278\nsplit{T<:AbstractString}(str::T, splitter; limit, keep) in Base at strings/util.jl:254La acción de completar los métodos usa inferencia de tipos y puede por tanto ver si los argumentos coinciden incluso si los argumentos son la salida de funcionees La función necesita se estable de tipos para que la acción de completar sea capaz de borrar los métodos no coincidentes.La acción de completar puede también ayudar a completar campos:julia> Pkg.a[TAB]\nadd       availableTambién pueden completarse los campos para la salida de funciones:julia> split(\"\",\"\")[1].[TAB]\nendof  offset  stringLa acción de completar campos para la salida de funciones usa inferencia de tipos, y sólo puede sugerir campos si la función es estable en los tipos."
},

{
    "location": "manual/interacting-with-julia.html#Personalizando-Colores-1",
    "page": "Interactuando con Julia",
    "title": "Personalizando Colores",
    "category": "section",
    "text": "Los colores utilizados por Julia y REPL se pueden personalizar también. Para cambiar el color del prompt de Julia, puede agregar algo como lo siguiente a su .juliarc.jl, que se debe colocar dentro del directorio de inicio:function customize_colors(repl)\n    repl.prompt_color = Base.text_colors[:cyan]\nend\n\natreplinit(customize_colors)Las teclas de color disponibles se pueden ver escribiendo Base.text_colors en el modo de ayuda de REPL. Además, los números enteros 0 a 255 se pueden usar como teclas de color para terminales con soporte de 256 colores.También puede cambiar los colores para la ayuda y las instrucciones del shell e ingresar y contestar el texto configurando el campo apropiado de repl en la función customize_colors arriba (respectivamente, help_color, shell_color, input_color, y answer_color). Para los dos últimos, asegúrese de que el campo envcolors también esté configurado a false.También es posible aplicar el formato en negrita mediante el uso de Base.text_colors[: bold] como color. Por ejemplo, para imprimir las respuestas en letra negrita, se puede usar lo siguiente como .juliarc.jl:function customize_colors(repl)\n    repl.envcolors = false\n    repl.answer_color = Base.text_colors[:bold]\nend\n\natreplinit(customize_colors)También puede personalizarse el color utilizado para presentar mensajes de advertencia e información estableciendo las variables de entorno apropiadas. Por ejemplo, para generar mensajes de error, de advertencia y de información respectivamente en magenta, amarillo y cian, puede agregar lo siguiente a su archivo .juliarc.jl:ENV[\"JULIA_ERROR_COLOR\"] = :magenta\nENV[\"JULIA_WARN_COLOR\"] = :yellow\nENV[\"JULIA_INFO_COLOR\"] = :cyan"
},

{
    "location": "manual/running-external-programs.html#",
    "page": "Ejecutando programas externos",
    "title": "Ejecutando programas externos",
    "category": "page",
    "text": ""
},

{
    "location": "manual/running-external-programs.html#running-external-programs-1",
    "page": "Ejecutando programas externos",
    "title": "Ejecutando programas externos",
    "category": "section",
    "text": "Julia toma prestada la notación de tilde inversa para ejecutar mandatos de la shell y programas en Perl y en Ruby.  Sin embargo, en Julia, escribirjulia> `echo hello`\n`echo hello`difiere en algunos aspectos del comportamiento en varios shells, Perl y Ruby:En lugar de ejecutar el mandato inmediatamente, las tildes invertidas crean un objeto Cmd para representar el  mandato. Uno puede usar este objeto para conectar los mandatos a otros vía tuberías (pipes), ejecutarlo y leer  o escribir en él.\nCuando el mandato se está ejecutando, Julia no captura su salida a menos que uno lo organice específicamente. En  lugar de ello, la salida del mandato va por defecto a STDOUT como si se estuviera realizando una llamada  al sistema con la libc.\nEl mandato nunca es ejecutado con un shell. En su lugar, Julia analiza directamente la sintaxis del mandato,  interpola variables adecuadametne y dividiendo en palabras como el shell lo haría, respetando su sintaxis.  El mandato se ejecuta como un proceso hijo inmediato de Julia, usando las llamadas fork y exec.He aquí un ejemplo sencillo de ejecución de un programa externo:julia> mycommand = `echo hello`\n`echo hello`\n\njulia> typeof(mycommand)\nCmd\n\njulia> run(mycommand)\nhelloEl mensaje hello es la salida de este mandato echo, enviado a STDOUT. El mensaje hello es la salida de este mandato echo, enviado a STDOUT. El método ejecutado devuelve en si mismo nothing, y lanza una ErrorException si el mandato externo falla en ejecutarse con éxito.Si se desea leer la salida de un mandato externo puede usarse readstring():  julia> a = readstring(`echo hello`)\n\"hello\\n\"\n\njulia> chomp(a) == \"hello\"\ntrueMás generalmente, puedes usar open() para leer desde o escribir hacia un mandato externo.julia> open(`less`, \"w\", STDOUT) do io\n           for i = 1:3\n               println(io, i)\n           end\n       end\n1\n2\n3"
},

{
    "location": "manual/running-external-programs.html#command-interpolation-1",
    "page": "Ejecutando programas externos",
    "title": "Interpolación",
    "category": "section",
    "text": "Supongamos que uno quiere algo un poco más complicado y usa el nombre de un fichero en la variable file como argumento a un mandato. Se puede usar $ para interpolar tal como lo haríamos con un literal cadena (ver la sección Strings):julia> file = \"/etc/passwd\"\n\"/etc/passwd\"\n\njulia> `sort $file`\n`sort /etc/passwd`Un error común es que cuando se ejecutan programas externos a través de un shell es que si el nombre del fichero contiene caracteres que son especiales para el shell, ellos pueden causar un comportamiento indeseaddo. Por ejemplo, en lugar de /etc/passwd se desea ordenar los contenidos del fichero /volumes/External HD/data.csv. Intentémoslo:julia> file = \"/Volumes/External HD/data.csv\"\n\"/Volumes/External HD/data.csv\"\n\njulia> `sort $file`\n`sort '/Volumes/External HD/data.csv'`¿Cómo se entrecomilla el nombre de fichero? Julia sabe que file va a ser interpolado por un solo argumento, por lo que él entrecomilla la cadena. De hecho, esto no es bastante exacto: el valor de file no va a ser interpretado por el shell nunca, por lo que no hay necesidad de entrecomillar. Las comillas se insertan sólo para presentar al usuario. Eso funcionará incluso si uno interpola un valor como parte de una palabra del shell:julia> path = \"/Volumes/External HD\"\n\"/Volumes/External HD\"\n\njulia> name = \"data\"\n\"data\"\n\njulia> ext = \"csv\"\n\"csv\"\n\njulia> `sort $path/$name.$ext`\n`sort '/Volumes/External HD/data.csv'`Como puedes ver, el espacio en la variable path es apropiadamente \"escapado\". Pero, ¿qué pasa si lo que uno desea es interpolar múltiples palabras? En este caso, se utilizará un array (u otro contenedor iterable):julia> files = [\"/etc/passwd\",\"/Volumes/External HD/data.csv\"]\n2-element Array{String,1}:\n \"/etc/passwd\"\n \"/Volumes/External HD/data.csv\"\n\njulia> `grep foo $files`\n`grep foo /etc/passwd '/Volumes/External HD/data.csv'`Si interpolas un array como parte de una palabra de la shell, Julia emula la generación de argumentos de la shell {a, b, c}:julia> names = [\"foo\",\"bar\",\"baz\"]\n3-element Array{String,1}:\n \"foo\"\n \"bar\"\n \"baz\"\n\njulia> `grep xylophone $names.txt`\n`grep xylophone foo.txt bar.txt baz.txt`Además, si interpolas múltiples arrays en la misma palabra, se emula el comportamiento de generación del shell haciendo el producto cartesiano: julia> names = [\"foo\",\"bar\",\"baz\"]\n3-element Array{String,1}:\n \"foo\"\n \"bar\"\n \"baz\"\n\njulia> exts = [\"aux\",\"log\"]\n2-element Array{String,1}:\n \"aux\"\n \"log\"\n\njulia> `rm -f $names.$exts`\n`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`Como pudes interpolar arrays de literales, puedes usar esta funcionalidad generativa sin necesidad de crer objetos array temporales primero: julia> `rm -rf $[\"foo\",\"bar\",\"baz\",\"qux\"].$[\"aux\",\"log\",\"pdf\"]`\n`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`"
},

{
    "location": "manual/running-external-programs.html#Entrecomillado-1",
    "page": "Ejecutando programas externos",
    "title": "Entrecomillado",
    "category": "section",
    "text": "Inevitablemente, uno quiere escribir mandatos que no sean tan simples, y se vueve necesario usar comillas. He aquí un ejemplo simple de un script Perl de una línea en el prompt del shell:sh$ perl -le '$|=1; for (0..3) { print }'\n0\n1\n2\n3La expresión Perl necesita estar entre comillas sencillas por dos razones: para que los espacios no rompan la expresión en múltiples palabras en el shell, y para que el uso de variables de Perl, como $| no cause interpolación. En otras instancias, puedes querer usar dobles comillas para que la interpolación SI tenga lugar:sh$ first=\"A\"\nsh$ second=\"B\"\nsh$ perl -le '$|=1; print for @ARGV' \"1: $first\" \"2: $second\"\n1: A\n2: BEn general, la sintaxis de comillas invertidas de Julia está diseñada cuidadosamente para que puedas cortar y pegar comendos del shell, los pongas entre comillas y funcionen: los comportamientos del escape, las comillas y las interpolaciones son los mismos que los del shell. La única diferencia es que la interpolación está integrada y consciente de la noción de Julia de que es un valor de cadena simple, y qué es un contenedor para valores múltiples. Intentemos los dos ejemplos anteriores en Julia:julia> A = `perl -le '$|=1; for (0..3) { print }'`\n`perl -le '$|=1; for (0..3) { print }'`\n\njulia> run(A)\n0\n1\n2\n3\n\njulia> first = \"A\"; second = \"B\";\n\njulia> B = `perl -le 'print for @ARGV' \"1: $first\" \"2: $second\"`\n`perl -le 'print for @ARGV' '1: A' '2: B'`\n\njulia> run(B)\n1: A\n2: BLos resultados son idénticos, y el comportamiento de interpolación de Julia imita el shell con algunas mejoras debido a que Julia soporta objetos iterables de primera clase mientras la mayoría de los shells usan división de cadenas mediante espacios para ésto, lo cuál introduce ambigüedades. Cuando intentamos portar mandatos del shell a Julia, intentemos cortar y pegar primero. Como Julia te muestra los mandatos antes de que los ejecutes, puedes examinar fácilmente y de forma segura su interpretación sin hacer ningún daño."
},

{
    "location": "manual/running-external-programs.html#Tuberías-1",
    "page": "Ejecutando programas externos",
    "title": "Tuberías",
    "category": "section",
    "text": "Los metacaracteres del shell tales como |, &, and >, necesitan ser acotados o escapados dentro de las comillas invertidas de Julia:julia> run(`echo hello '|' sort`)\nhello | sort\n\njulia> run(`echo hello \\| sort`)\nhello | sortEsta expresión invoca el mandato echo con tres palabras como argumentos, \"hello\", \"|\" y \"sort\". El resultados es que se imprime una sola línea \"hello | sort\". Dentro de las comillas traseras, el símbolo \"|\" no tiene un significado especial. ¿Cómo entonces, podemos construir una tubería? En lugar de usar el símbolo \"|\" dentro de la tubería, utilizaremos la función pipeline():julia> run(pipeline(`echo hello`, `sort`))\nhelloEsto entuba la salida del mandato echo al mandato sort. Por supuesto, esto no es terriblemente interesante ya que sólo hay una línea que ordenar, pero podemos cosas mucho más interesantes:julia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))\n210\n211\n212\n213\n214Esto imprime los cinco identificadores de usuario mayores dentro de un sistema UNIX. Los mandatos cut, sort y tail son \"criados\" como hijos inmediatos del proceso julia actual, sin que intervenga el proceso shell. Julia en sí mismo hace el trabajo (normalmente hecho por el shell) de inicializar las tuberías y conectar los descriptores de fichero.  Como Julia hace este trabajo, retiene un mejor control y puede hacer algunas cosas que el shell no puede.Julia puede ejecutar múltiples órdenes en paralelo:julia> run(`echo hello` & `echo world`)\nworld\nhelloEl orden de esta salida es no determinista debido a que los dos procesos echo se lanzan casi simultáneamente, y compiten para hacer la primera escritura al descriptor STDOUT que ambas comparten con el proceso padre julia.  Julia te premite entubar la salida desde estos procesos a otro programa:julia> run(pipeline(`echo world` & `echo hello`, `sort`))\nhello\nworldEn términos de fontanería UNIX, lo que está pasando aquí es que un único objeto tubería de UNIX se ha creado y es escrito por dos procesos echo y el otro extremo al final de la tubería es leído por la orden sort.La redirección de la E/S puede conseguirse pasando los argumentos clave stdin, stdout y stderr a la función pipeline:pipeline(`do_work`, stdout=pipeline(`sort`, \"out.txt\"), stderr=\"errs.txt\")"
},

{
    "location": "manual/running-external-programs.html#Evitar-interbloqueos-en-tuberías-1",
    "page": "Ejecutando programas externos",
    "title": "Evitar interbloqueos en tuberías",
    "category": "section",
    "text": "Cuando leemos y escribirmos en los dos extremos de una tubería desde un solo proceso, es importante evitar forzar el núcleo a almacenar todos los datos en el buffer.Por ejemplo, cuando leemos toda la salida de un mandato, llamamos a readstring(out), no wait(process), ya que el primero consumirá activamente todos los datos exritos por el proceso, mientras que el último interntará almacenar los datos en los búferes del kernel mientras espera a que un lector esté conectado. Otra solución común es separar el lector y el escritor de la tuberían en tareas separadas:writer = @async writeall(process, \"data\")\nreader = @async do_compute(readstring(process))\nwait(process)\nfetch(reader)"
},

{
    "location": "manual/running-external-programs.html#Ejemplo-complicado-1",
    "page": "Ejecutando programas externos",
    "title": "Ejemplo complicado",
    "category": "section",
    "text": "La combinación de un lenguaje de programación de alto nivel, una abstracción de mandatos de primera clase y la inicialización automática de tuberías entre procesos es muy poderos. Para dar algun sentido a las tuberías complejas que pueden ser creadas facilmente, he aquí algunos ejemplos más sofisticado, con nuestras disculpas por el excesito uso de scripts Perl con una sola línea:julia> prefixer(prefix, sleep) = `perl -nle '$|=1; print \"'$prefix' \", $_; sleep '$sleep';'`;\n\njulia> run(pipeline(`perl -le '$|=1; for(0..9){ print; sleep 1 }'`, prefixer(\"A\",2) & prefixer(\"B\",2)))\nA 0\nB 1\nA 2\nB 3\nA 4\nB 5\nA 6\nB 7\nA 8\nB 9Este es el ejemplo típico de un solo productor que alimenta dos consumidores concurrentes: un proceso perl genera líneas con los número 0 a 9, el otro con la letra \"B\". Qué consumidor llega el primero es no determinista, pero una vez que se ha ganado la carrera, las líneas son consumidas alternativamente primero por un proceso y después por el otro. (Fijas $|=1 en Perl causa que cada instrucción de impresión vuelque al flujo STDOUT, lo cuál es necesario para que este ejemplo funcione. En caso contrario toda la salida va a un buffer y sería impresa en la tubería de una vez, para ser leída por un solo proceso consumidor).He aquí un ejemplo incluso más complicado de productor consumidor multi-etapa:julia> run(pipeline(`perl -le '$|=1; for(0..9){ print; sleep 1 }'`,\n           prefixer(\"X\",3) & prefixer(\"Y\",3) & prefixer(\"Z\",3),\n           prefixer(\"A\",2) & prefixer(\"B\",2)))\nA X 0\nB Y 1\nA Z 2\nB X 3\nA Y 4\nB Z 5\nA X 6\nB Y 7\nA Z 8\nB X 9Este ejemplo es similar al anterior, excepto en que hay dos etapas de consumidores y las estapas tiene diferente latencia por lo que usan un número de workers paralelos diferrentes, para mantener saturado el throughput .Se recomienda intentar todos estos ejemplos y ver cómo funcionan."
},

{
    "location": "manual/calling-c-and-fortran-code.html#",
    "page": "Llamando a código C y Fortran",
    "title": "Llamando a código C y Fortran",
    "category": "page",
    "text": ""
},

{
    "location": "manual/calling-c-and-fortran-code.html#calling-c-and-fortran-code-1",
    "page": "Llamando a código C y Fortran",
    "title": "Llamando a código C y Fortran",
    "category": "section",
    "text": "Aunque la mayoría del código se puede escribir en Julia, hay muchas bibliotecas maduras de alta calidad para computación numérica ya escritas en C y Fortran. Para permitir el uso fácil de este código existente, Julia hace que sea sencillo y eficiente llamar a las funciones C y Fortran. Julia tiene una filosofía de \"no repetitivo\": las funciones se pueden llamar directamente desde Julia sin ningún código de \"pegamento\", generación de código o compilación, incluso desde el aviso interactivo. Esto se logra haciendo una llamada apropiada con la sintaxis ccall, que se parece a una llamada de función ordinaria.El código que se debe llamar debe estar disponible como una biblioteca compartida. La mayoría de las bibliotecas C y Fortran ya se han compilado como bibliotecas compartidas, pero si está compilando el código usted mismo usando GCC (o Clang), necesitará usar las opciones -shared y-fPIC. Las instrucciones de la máquina generadas por el JIT de Julia son las mismas que una llamada C nativa, por lo que la sobrecarga resultante es lo mismo que llamar a una función de biblioteca desde el código C. (Las llamadas a funciones que no son de la biblioteca en C y Julia pueden estar incluidas y, por lo tanto, pueden tener incluso menos gastos generales que las llamadas a funciones de biblioteca compartidas. Cuando LLVM genera bibliotecas y ejecutables, es posible realizar optimizaciones de todo el programa que incluso optimizar a través de este límite, pero Julia aún no lo admite. Sin embargo, en el futuro, puede hacerlo, produciendo ganancias de rendimiento incluso mayores).Las bibliotecas y funciones compartidas están referenciadas por una tupla de la forma (:función,\"biblioteca\") o (\"función\", \"biblioteca\") donde función es el nombre de función exportado por C. library se refiere al nombre de la biblioteca compartida: las bibliotecas compartidas disponibles en la ruta de carga (específica de la plataforma) se resolverán por nombre y, si es necesario, se puede especificar una ruta directa.El nombre de una función se puede usar solo en lugar de la tupla (solo :función o\"función\"). En este caso, el nombre se resuelve dentro del proceso actual. Este formulario se puede usar para llamar funciones de biblioteca C, funciones en el tiempo de ejecución de Julia o funciones en una aplicación vinculada a Julia.Por defecto, los compiladores Fortran generan nombres destrozados (por ejemplo, convirtiendo nombres de funciones a minúsculas o mayúsculas, a menudo añadiendo un guión bajo), y para llamar a una función Fortran a través de ccall debe pasar el identificador mutilado correspondiente a la regla seguida por su compilador Fortran . Además, cuando se llama a una función Fortran, todas las entradas se deben pasar por referencia.Por último, se puede usar ccall para generar de hecho una llamada a la función de librería. Los argumentos a  ccall son los siguientes:Una pareja (:función, \"librería\"), que debe ser escrita como una constante literal,\nO  un puntero a función (por ejemplo, de dlsym).Tipo de retorno (ver abajo para la correspondencia entre el tipo declarado en C y Julia)\nEste argumento será evaluado en tiempo de compilación, cuando se defina el método que lo contiene.\nUna tupla de tipos de entrada. Los tipos de entrada deben ser escritos como un literal tupla, no como una variable o expresión de valor tupla.\nEste argumento será evaluado en tiempo de compilación, cuando se defina el método que lo contiene.\nLos siguientes argumentos, si los hay, son los valores de los argumentos actuales pasados a la función.Como un ejemplo completo pero simple, el siguiente código llama a la función clock de la librería estándar C:julia> t = ccall((:clock, \"libc\"), Int32, ())\n2292761\n\njulia> t\n2292761\n\njulia> typeof(ans)\nInt32clock no toma argumentos y devuelve un Int32. Un problema común es que una 1-tupla debe escribirse con una coma al final. Por ejemplo, para llamar a la función getenv para obtener un puntero al valor de una variable de entorno, se realiza una llamada como esta:julia> path = ccall((:getenv, \"libc\"), Cstring, (Cstring,), \"SHELL\")\nCstring(@0x00007fff5fbffc45)\n\njulia> unsafe_string(path)\n\"/bin/bash\"Note que la tupla del tipo de argumento debe ser escrita como (Cstring,), en lugar de como (Cstring). Esto es debido a que (Cstring) es justo la expresión Cstring rodeada entre paréntesis, en lugar de una tupla que contiene a Cstring:julia> (Cstring)\nCstring\n\njulia> (Cstring,)\n(Cstring,)En la práctica, especialmente cuando se proporciona funcionalidad reutilizable, generalmente se envuelve el usp de  ccall en funciones de Julia que configuran argumentos y luego se comprueban los errores de cualquier forma que la función C o Fortran los indique, propagándose al código que llama desde Julia como excepciones. Esto es especialmente importante ya que las API de C y Fortran son notoriamente inconsistentes sobre cómo indican las condiciones de error. Por ejemplo, la función de biblioteca C getenv está envuelta en la siguiente función Julia, que es una versión simplificada de la definición real de env.jl:function getenv(var::AbstractString)\n    val = ccall((:getenv, \"libc\"),\n                Cstring, (Cstring,), var)\n    if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n    end\n    unsafe_string(val)\nendLa función C getenv indica un error al devolverNULL, pero otras funciones C estándar indican errores de varias maneras diferentes, incluyendo al devolver -1, 0, 1 y otros valores especiales. Este contenedor arroja una excepción que indica claramente el problema si la persona que llama intenta obtener una variable de entorno inexistente:julia> getenv(\"SHELL\")\n\"/bin/bash\"\n\njulia> getenv(\"FOOBAR\")\ngetenv: undefined variable: FOOBARAquí hay un ejemplo ligeramente ms complejo que descubre el nombre de host de la máquina local:function gethostname()\n    hostname = Vector{UInt8}(128)\n    ccall((:gethostname, \"libc\"), Int32,\n          (Ptr{UInt8}, Csize_t),\n          hostname, sizeof(hostname))\n    hostname[end] = 0; # ensure null-termination\n    return unsafe_string(pointer(hostname))\nendEste ejemplo primero asigna un array de bytes, luego llama a la función de biblioteca C gethostname para llenar el array con el nombre de host, toma un puntero al buffer de nombre de host, y convierte el puntero a una cadena Julia, asumiendo que es una cadena C terminada en NUL. Es común que las bibliotecas C usen este patrón de requerir al llamador que asigne memoria para que la pase al llamado y la complete. La asignación de la memoria de Julia se logra generalmente creando un array no inicializada y pasando un puntero a sus datos a la función C. Es por eso que no usamos el tipo Cstring aquí: como la matriz no está inicializada, podría contener bytes NUL. Convertir a Cstring como parte de ccall comprueba si hay bytes NUL contenidos y, por lo tanto, puede arrojar un error de conversión."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Creando-Punteros-a-Función-Julia-Compatibles-con-C-1",
    "page": "Llamando a código C y Fortran",
    "title": "Creando Punteros a Función Julia Compatibles con C",
    "category": "section",
    "text": "Es posible pasar funciones Julia a funciones C nativas que aceptan argumentos punteros a función. Por ejemplo, para emparejar prototipos C de la forma:typedef returntype (*functiontype)(argumenttype,...)La función cfunction() genera el puntero a función compatible con C para una llamadan a una función de biblioteca de Julia. Los argumentos a cfunction() son los siguientes:Una función Julia\nTipo de retorno\nUna tupla de tipos de entradaUn ejemplo clásico es la función estándar de biblioteca C qsort declarada como:void qsort(void *base, size_t nmemb, size_t size,\n           int(*compare)(const void *a, const void *b));The base argument is a pointer to an array of length nmemb, with elements of size bytes each. compare is a callback function which takes pointers to two elements a and b and returns an integer less/greater than zero if a should appear before/after b (or zero if any order is permitted). Now, suppose that we have a 1d array A of values in Julia that we want to sort using the qsort function (rather than Julia's built-in sort function). Before we worry about calling qsort and passing arguments, we need to write a comparison function that works for some arbitrary type T:julia> function mycompare(a::T, b::T) where T\n           return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint\n       end\nmycompare (generic function with 1 method)Notice that we have to be careful about the return type: qsort expects a function returning a C int, so we must be sure to return Cint via a call to convert and a typeassert.In order to pass this function to C, we obtain its address using the function cfunction:julia> const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));cfunction() accepts three arguments: the Julia function (mycompare), the return type (Cint), and a tuple of the argument types, in this case to sort an array of Cdouble (Float64) elements.The final call to qsort looks like this:julia> A = [1.3, -2.7, 4.4, 3.1]\n4-element Array{Float64,1}:\n  1.3\n -2.7\n  4.4\n  3.1\n\njulia> ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),\n             A, length(A), sizeof(eltype(A)), mycompare_c)\n\njulia> A\n4-element Array{Float64,1}:\n -2.7\n  1.3\n  3.1\n  4.4As can be seen, A is changed to the sorted array [-2.7, 1.3, 3.1, 4.4]. Note that Julia knows how to convert an array into a Ptr{Cdouble}, how to compute the size of a type in bytes (identical to C's sizeof operator), and so on. For fun, try inserting a println(\"mycompare($a,$b)\") line into mycompare, which will allow you to see the comparisons that qsort is performing (and to verify that it is really calling the Julia function that you passed to it)."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Mapping-C-Types-to-Julia-1",
    "page": "Llamando a código C y Fortran",
    "title": "Mapping C Types to Julia",
    "category": "section",
    "text": "It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The Clang package can be used to auto-generate Julia code from a C header file.)"
},

{
    "location": "manual/calling-c-and-fortran-code.html#Auto-conversion:-1",
    "page": "Llamando a código C y Fortran",
    "title": "Auto-conversion:",
    "category": "section",
    "text": "Julia automatically inserts calls to the Base.cconvert() function to convert each argument to the specified type. For example, the following call:ccall((:foo, \"libfoo\"), Void, (Int32, Float64), x, y)will behave as if the following were written:ccall((:foo, \"libfoo\"), Void, (Int32, Float64),\n      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),\n      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))Base.cconvert() normally just calls convert(), but can be defined to return an arbitrary new object more appropriate for passing to C. For example, this is used to convert an Array of objects (e.g. strings) to an array of pointers.Base.unsafe_convert() handles conversion to Ptr types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Type-Correspondences:-1",
    "page": "Llamando a código C y Fortran",
    "title": "Type Correspondences:",
    "category": "section",
    "text": "First, a review of some relevant Julia type terminology:Syntax / Keyword Example Description\nmutable struct String \"Leaf Type\" :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no TypeVars are allowed) in order for the instance to be constructed.\nabstract type Any, AbstractArray{T, N}, Complex{T} \"Super Type\" :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.\nT{A} Vector{Int} \"Type Parameter\" :: A specialization of a type (typically used for dispatch or storage optimization).\n  \"TypeVar\" :: The T in the type parameter declaration is referred to as a TypeVar (short for type variable).\nprimitive type Int, Float64 \"Primitive Type\" :: A type with no fields, but a size. It is stored and defined by-value.\nstruct Pair{Int, Int} \"Struct\" :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.\n Complex128 (isbits) \"Is-Bits\"   :: A primitive type, or a struct type where all fields are other isbits types. It is defined by-value, and is stored without a type-tag.\nstruct ...; end nothing \"Singleton\" :: a Leaf Type or Struct with no fields.\n(...) or tuple(...) (1, 2, 3) \"Tuple\" :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Bits-Types:-1",
    "page": "Llamando a código C y Fortran",
    "title": "Bits Types:",
    "category": "section",
    "text": "There are several special types to be aware of, as no other type can be defined to behave the same:Float32\nExactly corresponds to the float type in C (or REAL*4 in Fortran).\nFloat64\nExactly corresponds to the double type in C (or REAL*8 in Fortran).\nComplex64\nExactly corresponds to the complex float type in C (or COMPLEX*8 in Fortran).\nComplex128\nExactly corresponds to the complex double type in C (or COMPLEX*16 in Fortran).\nSigned\nExactly corresponds to the signed type annotation in C (or any INTEGER type in Fortran). Any Julia type that is not a subtype of Signed is assumed to be unsigned.Ref{T}\nBehaves like a Ptr{T} that can manage its memory via the Julia GC.Array{T,N}\nWhen an array is passed to C as a Ptr{T} argument, it is not reinterpret-cast: Julia requires that the element type of the array matches T, and the address of the first element is passed.\nTherefore, if an Array contains data in the wrong format, it will have to be explicitly converted using a call such as trunc(Int32, a).\nTo pass an array A as a pointer of a different type without converting the data beforehand (for example, to pass a Float64 array to a function that operates on uninterpreted bytes), you can declare the argument as Ptr{Void}.\nIf an array of eltype Ptr{T} is passed as a Ptr{Ptr{T}} argument, Base.cconvert() will attempt to first make a null-terminated copy of the array with each element replaced by its Base.cconvert() version. This allows, for example, passing an argv pointer array of type Vector{String} to an argument of type Ptr{Ptr{Cchar}}.On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an int in C is not the same as an Int in Julia).System Independent:C name Fortran name Standard Julia Alias Julia Base Type\nunsigned char CHARACTER Cuchar UInt8\nbool (only in C++)  Cuchar UInt8\nshort INTEGER*2, LOGICAL*2 Cshort Int16\nunsigned short   Cushort UInt16\nint, BOOL (C, typical) INTEGER*4, LOGICAL*4 Cint Int32\nunsigned int   Cuint UInt32\nlong long INTEGER*8, LOGICAL*8 Clonglong Int64\nunsigned long long   Culonglong UInt64\nintmax_t   Cintmax_t Int64\nuintmax_t   Cuintmax_t UInt64\nfloat REAL*4i Cfloat Float32\ndouble REAL*8 Cdouble Float64\ncomplex float COMPLEX*8 Complex64 Complex{Float32}\ncomplex double COMPLEX*16 Complex128 Complex{Float64}\nptrdiff_t   Cptrdiff_t Int\nssize_t   Cssize_t Int\nsize_t   Csize_t UInt\nvoid     Void\nvoid and [[noreturn]] or _Noreturn     Union{}\nvoid*     Ptr{Void}\nT* (where T represents an appropriately defined type)     Ref{T}\nchar* (or char[], e.g. a string) CHARACTER*N   Cstring if NUL-terminated, or Ptr{UInt8} if not\nchar** (or *char[])     Ptr{Ptr{UInt8}}\njl_value_t* (any Julia Type)     Any\njl_value_t** (a reference to a Julia Type)     Ref{Any}\nva_arg     Not supported\n... (variadic function specification)     T... (where T is one of the above types, variadic functions of different argument types are not supported)The Cstring type is essentially a synonym for Ptr{UInt8}, except the conversion to Cstring throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a char* to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use Ptr{UInt8} as the argument type. Cstring can also be used as the ccall return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.System-dependent:C name Standard Julia Alias Julia Base Type\nchar Cchar Int8 (x86, x86_64), UInt8 (powerpc, arm)\nlong Clong Int (UNIX), Int32 (Windows)\nunsigned long Culong UInt (UNIX), UInt32 (Windows)\nwchar_t Cwchar_t Int32 (UNIX), UInt16 (Windows)note: Note\nWhen calling a Fortran function, all inputs must be passed by reference, so all type correspondences above should contain an additional Ptr{..} or Ref{..} wrapper around their type specification.warning: Warning\nFor string arguments (char*) the Julia type should be Cstring (if NUL- terminated data is expected) or either Ptr{Cchar} or Ptr{UInt8} otherwise (these two pointer types have the same effect), as described above, not String. Similarly, for array arguments (T[] or T*), the Julia type should again be Ptr{T}, not Vector{T}.warning: Warning\nJulia's Char type is 32 bits, which is not the same as the wide character type (wchar_t or wint_t) on all platforms.warning: Warning\nA return type of Union{} means the function will not return i.e. C++11 [[noreturn]] or C11 _Noreturn (e.g. jl_throw or longjmp). Do not use this for functions that return no value (void) but do return, use Void instead.note: Note\nFor wchar_t* arguments, the Julia type should be Cwstring (if the C routine expects a NUL-terminated string) or Ptr{Cwchar_t} otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the Cwstring type will cause an error to be thrown if the string itself contains NUL characters).note: Note\nC functions that take an argument of the type char** can be called by using a Ptr{Ptr{UInt8}} type within Julia. For example, C functions of the form:int main(int argc, char **argv);can be called via the following Julia code:argv = [ \"a.out\", \"arg1\", \"arg2\" ]\nccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)note: Note\nA C function declared to return Void will return the value nothing in Julia."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Struct-Type-correspondences-1",
    "page": "Llamando a código C y Fortran",
    "title": "Struct Type correspondences",
    "category": "section",
    "text": "Composite types, aka struct in C or TYPE in Fortran90 (or STRUCTURE / RECORD in some variants of F77), can be mirrored in Julia by creating a struct definition with the same field layout.When used recursively, isbits types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an isbits struct type and use that instead. Unnamed structs are not possible in the translation to Julia.Packed structs and union declarations are not supported by Julia.You can get a near approximation of a union if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.Arrays of parameters can be expressed with NTuple:in C:\nstruct B {\n    int A[3];\n};\nb_a_2 = B.A[2];\n\nin Julia:\nstruct B\n    A::NTuple{3, CInt}\nend\nb_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)Arrays of unknown size (C99-compliant variable length structs specified by [] or [0]) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:struct String {\n    int strlen;\n    char data[];\n};In Julia, we can access the parts independently to make a copy of that string:str = from_c::Ptr{Void}\nlen = unsafe_load(Ptr{Cint}(str))\nunsafe_string(str + Core.sizeof(Cint), len)"
},

{
    "location": "manual/calling-c-and-fortran-code.html#Type-Parameters-1",
    "page": "Llamando a código C y Fortran",
    "title": "Type Parameters",
    "category": "section",
    "text": "The type arguments to ccall are evaluated statically, when the method containing the ccall is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.However, while the type layout must be known statically to compute the ccall ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the ccall signature, as long as they don't affect the layout of the type. For example, f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x) is valid, since Ptr is always a word-size primitive type. But, g(x::T) where {T} = ccall(:notvalid, T, (T,), x) is not valid, since the type layout of T is not known statically."
},

{
    "location": "manual/calling-c-and-fortran-code.html#SIMD-Values-1",
    "page": "Llamando a código C y Fortran",
    "title": "SIMD Values",
    "category": "section",
    "text": "Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of VecElement that naturally maps to the SIMD type.  Specifically:The tuple must be the same size as the SIMD type. For example, a tuple representing an __m128 on x86 must have a size of 16 bytes.\nThe element type of the tuple must be an instance of VecElement{T} where T is a primitive type that is 1, 2, 4 or 8 bytes.For instance, consider this C routine that uses AVX intrinsics:#include <immintrin.h>\n\n__m256 dist( __m256 a, __m256 b ) {\n    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                        _mm256_mul_ps(b, b)));\n}The following Julia code calls dist using ccall:const m256 = NTuple{8, VecElement{Float32}}\n\na = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))\nb = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))\n\nfunction call_dist(a::m256, b::m256)\n    ccall((:dist, \"libdist\"), m256, (m256, m256), a, b)\nend\n\nprintln(call_dist(a,b))The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Memory-Ownership-1",
    "page": "Llamando a código C y Fortran",
    "title": "Memory Ownership",
    "category": "section",
    "text": "malloc/freeMemory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with Libc.free in Julia, as this may result in the free function being called via the wrong libc library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid."
},

{
    "location": "manual/calling-c-and-fortran-code.html#When-to-use-T,-Ptr{T}-and-Ref{T}-1",
    "page": "Llamando a código C y Fortran",
    "title": "When to use T, Ptr{T} and Ref{T}",
    "category": "section",
    "text": "In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type T inside the ccall, as they are passed by value.  For C code accepting pointers, Ref{T} should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to Base.cconvert().  In contrast, pointers returned by the C function called should be declared to be of output type Ptr{T}, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type Ptr{T} within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type Ref{T}, as Fortran passes all variables by reference. The return type should either be Void for Fortran subroutines, or a T for Fortran functions returning the type T."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Mapping-C-Functions-to-Julia-1",
    "page": "Llamando a código C y Fortran",
    "title": "Mapping C Functions to Julia",
    "category": "section",
    "text": ""
},

{
    "location": "manual/calling-c-and-fortran-code.html#ccall/cfunction-argument-translation-guide-1",
    "page": "Llamando a código C y Fortran",
    "title": "ccall/cfunction argument translation guide",
    "category": "section",
    "text": "For translating a C argument list to Julia:T, where T is one of the primitive types: char, int, long, short, float, double, complex, enum or any of their typedef equivalents\nT, where T is an equivalent Julia Bits Type (per the table above)\nif T is an enum, the argument type should be equivalent to Cint or Cuint\nargument value will be copied (passed by value)\nstruct T (including typedef to a struct)\nT, where T is a Julia leaf type\nargument value will be copied (passed by value)\nvoid*\ndepends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list\nthis argument may be declared as Ptr{Void}, if it really is just an unknown pointer\njl_value_t*\nAny\nargument value must be a valid Julia object\ncurrently unsupported by cfunction()\njl_value_t**\nRef{Any}\nargument value must be a valid Julia object (or C_NULL)\ncurrently unsupported by cfunction()\nT*\nRef{T}, where T is the Julia type corresponding to T\nargument value will be copied if it is an isbits type otherwise, the value must be a valid Julia object\n(T*)(...) (e.g. a pointer to a function)\nPtr{Void} (you may need to use cfunction() explicitly to create this pointer)\n... (e.g. a vararg)\nT..., where T is the Julia type\nva_arg\nnot supported"
},

{
    "location": "manual/calling-c-and-fortran-code.html#ccall/cfunction-return-type-translation-guide-1",
    "page": "Llamando a código C y Fortran",
    "title": "ccall/cfunction return type translation guide",
    "category": "section",
    "text": "For translating a C return type to Julia:void\nVoid (this will return the singleton instance nothing::Void)\nT, where T is one of the primitive types: char, int, long, short, float, double, complex, enum or any of their typedef equivalents\nT, where T is an equivalent Julia Bits Type (per the table above)\nif T is an enum, the argument type should be equivalent to Cint or Cuint\nargument value will be copied (returned by-value)\nstruct T (including typedef to a struct)\nT, where T is a Julia Leaf Type\nargument value will be copied (returned by-value)\nvoid*\ndepends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list\nthis argument may be declared as Ptr{Void}, if it really is just an unknown pointer\njl_value_t*\nAny\nargument value must be a valid Julia object\njl_value_t**\nRef{Any}\nargument value must be a valid Julia object (or C_NULL)\nT*\nIf the memory is already owned by Julia, or is an isbits type, and is known to be non-null:\nRef{T}, where T is the Julia type corresponding to T\na return type of Ref{Any} is invalid, it should either be Any (corresponding to jl_value_t*) or Ptr{Any} (corresponding to Ptr{Any})\nC MUST NOT modify the memory returned via Ref{T} if T is an isbits type\nIf the memory is owned by C:\nPtr{T}, where T is the Julia type corresponding to T\n(T*)(...) (e.g. a pointer to a function)\nPtr{Void} (you may need to use cfunction() explicitly to create this pointer)"
},

{
    "location": "manual/calling-c-and-fortran-code.html#Passing-Pointers-for-Modifying-Inputs-1",
    "page": "Llamando a código C y Fortran",
    "title": "Passing Pointers for Modifying Inputs",
    "category": "section",
    "text": "Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a ccall, you need to first encapsulate the value inside an Ref{T} of the appropriate type. When you pass this Ref object as an argument, Julia will automatically pass a C pointer to the encapsulated data:width = Ref{Cint}(0)\nrange = Ref{Cfloat}(0)\nccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)Upon return, the contents of width and range can be retrieved (if they were changed by foo) by width[] and range[]; that is, they act like zero-dimensional arrays."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Special-Reference-Syntax-for-ccall-(deprecated):-1",
    "page": "Llamando a código C y Fortran",
    "title": "Special Reference Syntax for ccall (deprecated):",
    "category": "section",
    "text": "The & syntax is deprecated, use the Ref{T} argument type instead.A prefix & is used on an argument to ccall to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n    @assert length(DX) == length(DY)\n    n = length(DX)\n    incx = incy = 1\n    product = ccall((:ddot_, \"libLAPACK\"),\n                    Float64,\n                    (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),\n                    &n, DX, &incx, DY, &incy)\n    return product\nendThe meaning of prefix & is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via type). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, & may be used with any expression, such as &0 or &f(x).When a scalar value is passed with & as an argument of type Ptr{T}, the value will first be converted to type T."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Some-Examples-of-C-Wrappers-1",
    "page": "Llamando a código C y Fortran",
    "title": "Some Examples of C Wrappers",
    "category": "section",
    "text": "Here is a simple example of a C wrapper that returns a Ptr type:mutable struct gsl_permutation\nend\n\n# The corresponding C signature is\n#     gsl_permutation * gsl_permutation_alloc (size_t n);\nfunction permutation_alloc(n::Integer)\n    output_ptr = ccall(\n        (:gsl_permutation_alloc, :libgsl), # name of C function and library\n        Ptr{gsl_permutation},              # output type\n        (Csize_t,),                        # tuple of input types\n        n                                  # name of Julia variable to pass in\n    )\n    if output_ptr == C_NULL # Could not allocate memory\n        throw(OutOfMemoryError())\n    end\n    return output_ptr\nendThe GNU Scientific Library (here assumed to be accessible through :libgsl) defines an opaque pointer, gsl_permutation *, as the return type of the C function gsl_permutation_alloc(). As user code never has to look inside the gsl_permutation struct, the corresponding Julia wrapper simply needs a new type declaration, gsl_permutation, that has no internal fields and whose sole purpose is to be placed in the type parameter of a Ptr type.  The return type of the ccall is declared as Ptr{gsl_permutation}, since the memory allocated and pointed to by output_ptr is controlled by C (and not Julia).The input n is passed by value, and so the function's input signature is simply declared as (Csize_t,) without any Ref or Ptr necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be (Ref{Csize_t},), since Fortran variables are passed by reference.) Furthermore, n can be any type that is convertable to a Csize_t integer; the ccall implicitly calls Base.cconvert(Csize_t, n).Here is a second example wrapping the corresponding destructor:# The corresponding C signature is\n#     void gsl_permutation_free (gsl_permutation * p);\nfunction permutation_free(p::Ref{gsl_permutation})\n    ccall(\n        (:gsl_permutation_free, :libgsl), # name of C function and library\n        Void,                             # output type\n        (Ref{gsl_permutation},),          # tuple of input types\n        p                                 # name of Julia variable to pass in\n    )\nendHere, the input p is declared to be of type Ref{gsl_permutation}, meaning that the memory that p points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type Ptr{gsl_permutation}, but it is convertable using Base.cconvert() and therefore can be used in the same (covariant) context of the input argument to a ccall. A pointer to memory allocated by Julia must be of type Ref{gsl_permutation}, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the Ref{gsl_permutation} declaration allows pointers managed by C or Julia to be used.If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using p::Ptr{gsl_permutation} for the method signature of the wrapper and similarly in the ccall is also acceptable.Here is a third example passing Julia arrays:# The corresponding C signature is\n#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n#                                double result_array[])\nfunction sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n    if nmax < nmin\n        throw(DomainError())\n    end\n    result_array = Vector{Cdouble}(nmax - nmin + 1)\n    errorcode = ccall(\n        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library\n        Cint,                               # output type\n        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types\n        nmin, nmax, x, result_array         # names of Julia variables to pass in\n    )\n    if errorcode != 0\n        error(\"GSL error code $errorcode\")\n    end\n    return result_array\nendThe C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array result_array. This variable can only be used with corresponding input type declaration Ref{Cdouble}, since its memory is allocated and managed by Julia, not C. The implicit call to Base.cconvert(Ref{Cdouble}, result_array) unpacks the Julia pointer to a Julia array data structure into a form understandable by C.Note that for this code to work correctly, result_array must be declared to be of type Ref{Cdouble} and not Ptr{Cdouble}. The memory is managed by Julia and the Ref signature alerts Julia's garbage collector to keep managing the memory for result_array while the ccall executes. If Ptr{Cdouble} were used instead, the ccall may still work, but Julia's garbage collector would not be aware that the memory declared for result_array is being used by the external C function. As a result, the code may produce a memory leak if result_array never gets freed by the garbage collector, or if the garbage collector prematurely frees result_array, the C function may end up throwing an invalid memory access exception."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Garbage-Collection-Safety-1",
    "page": "Llamando a código C y Fortran",
    "title": "Garbage Collection Safety",
    "category": "section",
    "text": "When passing data to a ccall, it is best to avoid using the pointer() function. Instead define a convert method and pass the variables directly to the ccall. ccall automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the ccall returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global variable of type Array{Ref,1} to hold these values, until the C library notifies you that it is finished with them.Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many methods in Julia such as unsafe_load() and String() make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is unsafe_wrap() which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.The garbage collector does not guarantee any order of finalization. That is, if a contained a reference to b and both a and b are due for garbage collection, there is no guarantee that b would be finalized after a. If proper finalization of a depends on b being valid, it must be handled in other ways."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Non-constant-Function-Specifications-1",
    "page": "Llamando a código C y Fortran",
    "title": "Non-constant Function Specifications",
    "category": "section",
    "text": "A (name, library) function specification must be a constant expression. However, it is possible to use computed values as function names by staging through eval as follows:@eval ccall(($(string(\"a\", \"b\")), \"lib\"), ...This expression constructs a name using string, then substitutes this name into a new ccall expression, which is then evaluated. Keep in mind that eval only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with $). For this reason, eval is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions.If your usage is more dynamic, use indirect calls as described in the next section."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Indirect-Calls-1",
    "page": "Llamando a código C y Fortran",
    "title": "Indirect Calls",
    "category": "section",
    "text": "The first argument to ccall can also be an expression evaluated at run time. In this case, the expression must evaluate to a Ptr, which will be used as the address of the native function to call. This behavior occurs when the first ccall argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.For example, you might look up the function via dlsym, then cache it in a global variable for that session. For example:macro dlsym(func, lib)\n    z, zlocal = gensym(string(func)), gensym()\n    eval(current_module(), :(global $z = C_NULL))\n    z = esc(z)\n    quote\n        let $zlocal::Ptr{Void} = $z::Ptr{Void}\n            if $zlocal == C_NULL\n                $zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))\n                global $z = $zlocal\n            end\n            $zlocal\n        end\n    end\nend\n\nmylibvar = Libdl.dlopen(\"mylib\")\nccall(@dlsym(\"myfunc\", mylibvar), Void, ())"
},

{
    "location": "manual/calling-c-and-fortran-code.html#Calling-Convention-1",
    "page": "Llamando a código C y Fortran",
    "title": "Calling Convention",
    "category": "section",
    "text": "The second argument to ccall can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: stdcall, cdecl, fastcall, and thiscall. For example (from base/libc.jl) we see the same gethostnameccall as above, but with the correct signature for Windows:hn = Vector{UInt8}(256)\nerr = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))For more information, please see the LLVM Language Reference.There is one additional special calling convention llvmcall, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for CUDA, we need to be able to read the thread index:ccall(\"llvm.nvvm.read.ptx.sreg.tid.x\", llvmcall, Int32, ())As with any ccall, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by Core.Intrinsics."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Accessing-Global-Variables-1",
    "page": "Llamando a código C y Fortran",
    "title": "Accessing Global Variables",
    "category": "section",
    "text": "Global variables exported by native libraries can be accessed by name using the cglobal() function. The arguments to cglobal() are a symbol specification identical to that used by ccall, and a type describing the value stored in the variable:julia> cglobal((:errno, :libc), Int32)\nPtr{Int32} @0x00007f418d0816b8The result is a pointer giving the address of the value. The value can be manipulated through this pointer using unsafe_load() and unsafe_store!()."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Accessing-Data-through-a-Pointer-1",
    "page": "Llamando a código C y Fortran",
    "title": "Accessing Data through a Pointer",
    "category": "section",
    "text": "The following methods are described as \"unsafe\" because a bad pointer or type declaration can cause Julia to terminate abruptly.Given a Ptr{T}, the contents of type T can generally be copied from the referenced memory into a Julia object using unsafe_load(ptr, [index]). The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of getindex() and setindex!() (e.g. [] access syntax).The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.If T is Any, then the memory is assumed to contain a reference to a Julia object (a jl_value_t*), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector.  If the Ptr itself is actually a jl_value_t*, it can be converted back to a Julia object reference by unsafe_pointer_to_objref(ptr). (Julia values v can be converted to jl_value_t* pointers, as Ptr{Void}, by calling pointer_from_objref(v).)The reverse operation (writing data to a Ptr{T}), can be performed using unsafe_store!(ptr, value, [index]). Currently, this is only supported for primitive types or other pointer-free (isbits) immutable struct types.Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.If the pointer of interest is a plain-data array (primitive type or immutable struct), the function unsafe_wrap(Array, ptr,dims,[own]) may be more useful. The final parameter should be true if Julia should \"take ownership\" of the underlying buffer and call free(ptr) when the returned Array object is finalized.  If the own parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.Arithmetic on the Ptr type in Julia (e.g. using +) does not behave the same as C's pointer arithmetic. Adding an integer to a Ptr in Julia always moves the pointer by some number of bytes, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers."
},

{
    "location": "manual/calling-c-and-fortran-code.html#Thread-safety-1",
    "page": "Llamando a código C y Fortran",
    "title": "Thread-safety",
    "category": "section",
    "text": "Some C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe you'll need to take some extra precautions. In particular, you'll need to set up a two-layered system: the C callback should only schedule (via Julia's event loop) the execution of your \"real\" callback. To do this, create a AsyncCondition object and wait on it:cond = Base.AsyncCondition()\nwait(cond)The callback you pass to C should only execute a ccall to :uv_async_send, passing cond.handle as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.Note that events may be coalesced, so multiple calls to uv_async_send may result in a single wakeup notification to the condition."
},

{
    "location": "manual/calling-c-and-fortran-code.html#More-About-Callbacks-1",
    "page": "Llamando a código C y Fortran",
    "title": "More About Callbacks",
    "category": "section",
    "text": "For more details on how to pass callbacks to C libraries, see this blog post."
},

{
    "location": "manual/calling-c-and-fortran-code.html#C-1",
    "page": "Llamando a código C y Fortran",
    "title": "C++",
    "category": "section",
    "text": "For direct C++ interfacing, see the Cxx package. For tools to create C++ bindings, see the CxxWrap package."
},

{
    "location": "manual/handling-operating-system-variation.html#",
    "page": "Manejando variaciones en el Sistema Operativo",
    "title": "Manejando variaciones en el Sistema Operativo",
    "category": "page",
    "text": ""
},

{
    "location": "manual/handling-operating-system-variation.html#handling-operating-system-variation-1",
    "page": "Manejando variaciones en el Sistema Operativo",
    "title": "Manejando variaciones en el Sistema Operativo",
    "category": "section",
    "text": "Cuando se trata con librerías de plataforma, es frecuentemente necesario proporcionar casos especiales para distintas plataformas. La variable Sys.KERNEL puede utilizarse para escribir estos casos especiales. Hay varias funciones con intención de hacer esto más sencillo: is_unix, is_linux, is_apple, is_bsd e is_windows. Ellas pueden usarse de la siguiente forma:if is_windows()\n    some_complicated_thing(a)\nendNote que is_linuxe is_apple son subconjuntos mutuamente exclusivos de is_unix. Adicionalmente, existe una macro @static que hace posible usar estas funciones para ocultar código inválido condicionalmente, como demuestran los siguientes ejemplos:Bloques simples:ccall( (@static is_windows() ? :_fopen : :fopen), ...)Bloques complejos:@static if is_linux()\n    some_complicated_thing(a)\nelse\n    some_different_thing(a)\nendCuando se encadenan condicionales (incluyendo if/elsif/end) @static debe ser repetido por cada nivel (paréntesis opcional, pero recomendado por legibilidad):@static is_windows() ? :a : (@static is_apple() ? :b : :c)"
},

{
    "location": "manual/environment-variables.html#",
    "page": "Variables de Entorno",
    "title": "Variables de Entorno",
    "category": "page",
    "text": ""
},

{
    "location": "manual/environment-variables.html#environment-variables-1",
    "page": "Variables de Entorno",
    "title": "Variables de Entorno",
    "category": "section",
    "text": "Julia se puede configurar con varias variables de entorno, ya sea de la manera habitual del sistema operativo o de manera portátil desde Julia. Supongamos que quiere establecer la variable de entorno JULIA_EDITOR como vim, para ello escribirá ENV[\"JULIA_EDITOR\"] = \"vim\" en el REPL para llevar a cabo este cambio en la sesión actual, o agregará lo mismo en el archivo de configuración .juliarc.jl en el directorio de inicio del usuario para tener un efecto permanente. El valor actual de la misma variable de entorno se determina evaluando ENV [\"JULIA_EDITOR\"].Las variables de entorno que usa Julia generalmente comienzan con JULIA. Si Base.versioninfo se llama con verbose igual a true, la salida mostrará una lista de variables de entorno definidas relevantes para Julia, incluidas aquellas para las cualesJULIA aparece en el nombre."
},

{
    "location": "manual/environment-variables.html#Localizaciones-de-fichero-1",
    "page": "Variables de Entorno",
    "title": "Localizaciones de fichero",
    "category": "section",
    "text": ""
},

{
    "location": "manual/environment-variables.html#JULIA_HOME-1",
    "page": "Variables de Entorno",
    "title": "JULIA_HOME",
    "category": "section",
    "text": "La ruta absoluta del directorio que contiene el ejecutable de Julia, que establece la variable global Base.JULIA_HOME. Si $JULIA_HOME no está configurado, entonces Julia determina el valorBase.JULIA_HOME en el tiempo de ejecución.El ejecutable en sí es uno de$ JULIA_HOME/julia\n$ JULIA_HOME/julia-debugpor defecto.La variable global Base.DATAROOTDIR determina una ruta relativa de Base.JULIA_HOME al directorio de datos asociado con Julia. Entonces el camino$ JULIA_HOME / $ DATAROOTDIR / julia / basedetermina el directorio en el que Julia inicialmente busca los archivos fuente (a través de Base.find_source_file()).Del mismo modo, la variable global Base.SYSCONFDIR determina una ruta relativa al directorio del archivo de configuración. Entonces Julia busca un archivo juliarc.jl en JULIA_HOMESYSCONFDIRjuliajuliarcjl JULIA_HOMEetcjuliajuliarcjl `por defecto (a través de Base.load_juliarc()).Por ejemplo, una instalación de Linux con un ejecutable de Julia ubicado en /bin/julia, unDATAROOTDIR de ../ share, y unSYSCONFDIR de ../ etc tendrá JULIA_HOME establecido en /bin, una ruta de búsqueda de archivo fuente de/share/julia/basey una ruta de búsqueda de configuración global de/etc/julia/juliarc.jl"
},

{
    "location": "manual/environment-variables.html#JULIA_LOAD_PATH-1",
    "page": "Variables de Entorno",
    "title": "JULIA_LOAD_PATH",
    "category": "section",
    "text": "Una lista separada de rutas absolutas que se anexarán a la variable LOAD_PATH. (En sistemas tipo Unix, el separador de ruta es :; en sistemas Windows, el separador de ruta es ;.) La variable LOAD_PATH es donde Base.require y Base.load_in_path() busca el código; se predetermina a las rutas absolutas$JULIA_HOME/../local/share/julia/site/v$(VERSION.major).$(VERSION.minor)\n$JULIA_HOME/../share/julia/site/v$(VERSION.major).$(VERSION.minor)de modo que, por ejemplo, la versión 0.6 de Julia en un sistema Linux con un ejecutable de Julia en /bin/julia tendrá unLOAD_PATH predeterminado de/local/share/julia/site/v0.6\n/share/julia/site/v0.6"
},

{
    "location": "manual/environment-variables.html#JULIA_PKGDIR-1",
    "page": "Variables de Entorno",
    "title": "JULIA_PKGDIR",
    "category": "section",
    "text": "La ruta del directorio principal Pkg.Dir._pkgroot() para los repositorios de paquetes Julia específicos de la versión. Si la ruta es relativa, entonces se toma con respecto al directorio de trabajo. Si $JULIA_PKGDIR no está configurado, entoncesPkg.Dir._pkgroot()se establece por defecto en$HOME/.juliaEntonces la localizacíon del repositorio Pkg.dir para una versin dada de Julia es$JULIA_PKGDIR/v$(VERSION.major).$(VERSION.minor)Por ejemplo, para un usuario Linux cuyo directorio home ea /home/alice, el directorio que contiene los repositorios de paquetes por defecto sería/home/alice/.juliay el repositorio de paquetes paa la versión 0.6 de Julia sería/home/alice/.julia/v0.6"
},

{
    "location": "manual/environment-variables.html#JULIA_HISTORY-1",
    "page": "Variables de Entorno",
    "title": "JULIA_HISTORY",
    "category": "section",
    "text": "El camino absoluto Base.REPL.find_hist_file() del fichero de historia del REPL. Si $JULIA_HISTORY no está fijado, encontces Base.REPL.find_hist_file() tiene como valor por defecto$HOME/.julia_history"
},

{
    "location": "manual/environment-variables.html#JULIA_PKGRESOLVE_ACCURACY-1",
    "page": "Variables de Entorno",
    "title": "JULIA_PKGRESOLVE_ACCURACY",
    "category": "section",
    "text": "Un Int positivo que determina cuánto tiempo la subrutina de suma máximaMaxSum.maxsum ()del resolvedor de dependencia de paquetes Base.Pkg.resolve dedicará a intentar las restricciones satisfactorias antes de abandonar: este valor es por defecto 1, y los valores más grandes corresponden a mayores cantidades de tiempo.Supongamos que el valor de $ JULIA_PKGRESOLVE_ACCURACY es n. Entoncesel número de iteraciones de pre-decimación es 20*n,\nel número de iteraciones entre los pasos de aniquilación es 10*n, y\nen los pasos de aniquilación, como máximo se destruye uno de cada paquetes 20*n."
},

{
    "location": "manual/environment-variables.html#Aplicaciones-externas-1",
    "page": "Variables de Entorno",
    "title": "Aplicaciones externas",
    "category": "section",
    "text": ""
},

{
    "location": "manual/environment-variables.html#JULIA_SHELL-1",
    "page": "Variables de Entorno",
    "title": "JULIA_SHELL",
    "category": "section",
    "text": "La ruta absoluta del shell con el que Julia debe ejecutar comandos externos (a través de Base.repl_cmd ()). Se predetermina a la variable de entorno $SHELL, y vuelve a /bin/sh si $SHELL está desactivado.note: Note\nEn Windows, esta variable de entorno se ignora y los comandos externos se ejecutan directamente."
},

{
    "location": "manual/environment-variables.html#JULIA_EDITOR-1",
    "page": "Variables de Entorno",
    "title": "JULIA_EDITOR",
    "category": "section",
    "text": "El editor devuelto por Base.editor() y utilizado en, por ejemplo, Base.edit, refiriéndose al comando del editor preferido, por ejemplovim.$JULIA_EDITOR tiene prioridad sobre$VISUAL, que a su vez tiene prioridad sobre $EDITOR. Si no se establece ninguna de estas variables de entorno, entonces el editor se considera abierto en Windows y OS X, o/etc/alternatives/editor si existe, o emacs de lo contrario.note: Note\n$JULIA_EDITOR no se usa en la determinación del editor para Base.Pkg.edit: esta función verifica $VISUAL y$EDITOR solo."
},

{
    "location": "manual/environment-variables.html#Paralelización-1",
    "page": "Variables de Entorno",
    "title": "Paralelización",
    "category": "section",
    "text": ""
},

{
    "location": "manual/environment-variables.html#JULIA_CPU_CORES-1",
    "page": "Variables de Entorno",
    "title": "JULIA_CPU_CORES",
    "category": "section",
    "text": "Sobreescribe la variable global Base.Sys.CPU_CORES, el número de núcleos de CPU lógicos disponible."
},

{
    "location": "manual/environment-variables.html#JULIA_WORKER_TIMEOUT-1",
    "page": "Variables de Entorno",
    "title": "JULIA_WORKER_TIMEOUT",
    "category": "section",
    "text": "Un Float64 que establece el valor deBase.worker_timeout() (predeterminado:60.0). Esta función proporciona la cantidad de segundos que un proceso de trabajo esperará un proceso maestro para establecer una conexión antes de morir."
},

{
    "location": "manual/environment-variables.html#JULIA_NUM_THREADS-1",
    "page": "Variables de Entorno",
    "title": "JULIA_NUM_THREADS",
    "category": "section",
    "text": "Un entero sin signo de 64 bits (uint64_t) que establece el número máximo de subprocesos disponiblew para Julia. Si $JULIA_NUM_THREADS excede la cantidad disponiblede núcleos de CPU físicos, el número de subprocesos se establece en la cantidad de núcleos. Si $JULIA_NUM_THREADS no es positivo o no está configurado, o si el número de núcleos de CPU no se puede determinar a través de llamadas al sistema, entonces la cantidad de hilos es establecida en 1."
},

{
    "location": "manual/environment-variables.html#JULIA_THREAD_SLEEP_THRESHOLD-1",
    "page": "Variables de Entorno",
    "title": "JULIA_THREAD_SLEEP_THRESHOLD",
    "category": "section",
    "text": "Si se fija a una cadena que comienza con la subcadena insensible a mayúsculas y minúsculas \"infinite\", entonces los hilos vivos nunva duermen. En caso contrario, $JULIA_THREAD_SLEEP_THRESHOLD es interpretado como un entero sin signo de 64 bits (uint64_t) y da, en nanosegundos, la cantidad de tiempo después del cual los hilos deben dormir."
},

{
    "location": "manual/environment-variables.html#JULIA_EXCLUSIVE-1",
    "page": "Variables de Entorno",
    "title": "JULIA_EXCLUSIVE",
    "category": "section",
    "text": "Si se establece en algo además de 0, entonces la política de hilos de Julia es consistente con la ejecución en una máquina dedicada: el hilo maestro está en proc 0, y los hilos están affinitizados. De lo contrario, Julia deja que el sistema operativo maneje la política de hilos."
},

{
    "location": "manual/environment-variables.html#Formateo-del-REPL-1",
    "page": "Variables de Entorno",
    "title": "Formateo del REPL",
    "category": "section",
    "text": "Variables de entorno que determinan cómo debe formatearse la salida REPL en el terminal. En general, estas variables deben establecerse en seciencias de scape de terminal ANSI. Julia proporciona una interfaz de alto nivel con gran parte de la misma funcionalidad: ver la sección sobre Interacción con Julia."
},

{
    "location": "manual/environment-variables.html#JULIA_ERROR_COLOR-1",
    "page": "Variables de Entorno",
    "title": "JULIA_ERROR_COLOR",
    "category": "section",
    "text": "El formato Base.error_color() (predeterminado: rojo claro, \"\\033[91m \") que los errores deberían tener en la terminal."
},

{
    "location": "manual/environment-variables.html#JULIA_WARN_COLOR-1",
    "page": "Variables de Entorno",
    "title": "JULIA_WARN_COLOR",
    "category": "section",
    "text": "El formato Base.warn_color() (preeterminado: amarillo, \"\\033[93m\") que deberían tener las advertencias en el terminal."
},

{
    "location": "manual/environment-variables.html#JULIA_INFO_COLOR-1",
    "page": "Variables de Entorno",
    "title": "JULIA_INFO_COLOR",
    "category": "section",
    "text": "El formato Base.info_color() (predeterminado: cyan, \"\\033[36m\") que debería tener la info en el terminal. "
},

{
    "location": "manual/environment-variables.html#JULIA_INPUT_COLOR-1",
    "page": "Variables de Entorno",
    "title": "JULIA_INPUT_COLOR",
    "category": "section",
    "text": "El formato Base.input_color() (predeterminado: normal, \"\\033[0m\") que debería haber en el terminal."
},

{
    "location": "manual/environment-variables.html#JULIA_ANSWER_COLOR-1",
    "page": "Variables de Entorno",
    "title": "JULIA_ANSWER_COLOR",
    "category": "section",
    "text": "El formato Base.answer_color() (predeterminado:  normal, \"\\033[0m\") que debería haber en el terminal.."
},

{
    "location": "manual/environment-variables.html#JULIA_STACKFRAME_LINEINFO_COLOR-1",
    "page": "Variables de Entorno",
    "title": "JULIA_STACKFRAME_LINEINFO_COLOR",
    "category": "section",
    "text": "El formato Base.stackframe_lineinfo_color() (predeterminado:  bold, \"\\033[1m\") que la línea info debería tener durante una traza de la pila en el terminal."
},

{
    "location": "manual/environment-variables.html#JULIA_STACKFRAME_FUNCTION_COLOR-1",
    "page": "Variables de Entorno",
    "title": "JULIA_STACKFRAME_FUNCTION_COLOR",
    "category": "section",
    "text": "El formato Base.stackframe_function_color() (predeterminado:  bold, \"\\033[1m\") que las llamadas a funcin deberían tener durante una traza de la pila en el terminal."
},

{
    "location": "manual/environment-variables.html#Depuración-y-profiling-1",
    "page": "Variables de Entorno",
    "title": "Depuración y profiling",
    "category": "section",
    "text": ""
},

{
    "location": "manual/environment-variables.html#JULIA_GC_ALLOC_POOL,-JULIA_GC_ALLOC_OTHER,-JULIA_GC_ALLOC_PRINT-1",
    "page": "Variables de Entorno",
    "title": "JULIA_GC_ALLOC_POOL, JULIA_GC_ALLOC_OTHER, JULIA_GC_ALLOC_PRINT",
    "category": "section",
    "text": "Si se establecen, estas variables de entorno toman cadenas que opcionalmente comienzan con el carácter 'r', seguido por una interpolación de cadenas de una lista separada por dos puntos de tres enteros de 64 bits (int64_t). Este triplete de enteros a:b:c representa la secuencia aritmética a, a + b,a + 2*b, ... c.Si es la \"n\" vez que se ha llamado a jl_gc_pool_alloc (), y n pertenece a la secuencia aritmética  representada por$ JULIA_GC_ALLOC_POOL, entonces se forzará la recolección de elementos no utilizados.\nSi es la nth vez quemaybe_collect ()ha sido llamado, y n pertenece a la secuencia aritmética  representada por $JULIA_GC_ALLOC_OTHER, entonces se forzará la recolección de elementos no utilizados.\nSi es la n th vez quejl_gc_collect() ha sido llamado, y n pertenece a la secuencia aritmética  representada por $JULIA_GC_ALLOC_PRINT, entonces cuenta para el número de llamadas a jl_gc_pool_alloc() y maybe_collect() están impresos.Si el valor de la variable de entorno comienza con el carácter 'r', entonces el intervalo entre los eventos de recolección de basura es aleatorio.note: Note\nEstas variables de entorno solo tienen un efecto si Julia se compiló con la  depuración de la recolección de basura (es decir, si WITH_GC_DEBUG_ENV  se fija a 1 en la configuración de compilación)."
},

{
    "location": "manual/environment-variables.html#JULIA_GC_NO_GENERATIONAL-1",
    "page": "Variables de Entorno",
    "title": "JULIA_GC_NO_GENERATIONAL",
    "category": "section",
    "text": "Si se fija a algo por encima de 0, entonces el recolector de basura de Julia nunca realizará barridos rápidos de memoria.note: Note\nEsta variable de entorno solo tiene un efecto si Julia se compiló con depuración de recolección de elementos  no utilizados (es decir, si WITH_GC_DEBUG_ENV está establecido en1 en la configuración de compilación)."
},

{
    "location": "manual/environment-variables.html#JULIA_GC_WAIT_FOR_DEBUGGER-1",
    "page": "Variables de Entorno",
    "title": "JULIA_GC_WAIT_FOR_DEBUGGER",
    "category": "section",
    "text": "Si se fija a algo por encima de 0, entonces el recolector de basura esperará a que un depurador la enlace en lugar de abortar cuando haya un error crítico.note: Note\nEsta variable de entorno solo tiene un efecto si Julia se compiló con depuración de recolección de elementos  no utilizados (es decir, si WITH_GC_DEBUG_ENV está establecido en1 en la configuración de compilación)."
},

{
    "location": "manual/environment-variables.html#ENABLE_JITPROFILING-1",
    "page": "Variables de Entorno",
    "title": "ENABLE_JITPROFILING",
    "category": "section",
    "text": "Si se fija a un valor por encima de 0, entonces el compilador creará y registrará un detector de evaentos (event listener)  para for just-in-time (JIT) profiling.note: Note\nEsta variable de entorno sólo tiene efecto su Julia se compiló con soporte de JIT profiling usando VTune™ Amplifier de Intel   (USE_INTEL_JITEVENTS set to 1 in the build configuration), o bien\nOProfile (USE_OPROFILE_JITEVENTS set to 1   in the build configuration)."
},

{
    "location": "manual/environment-variables.html#JULIA_LLVM_ARGS-1",
    "page": "Variables de Entorno",
    "title": "JULIA_LLVM_ARGS",
    "category": "section",
    "text": "Arguments para pasar al backend de LLVM.note: Note\nEsta variable de entorno sólo tiene efecto su Julia se compiló con JL_DEBUG_BUILD fijado — en particular, el ejecutable julia-debug siempre es compilado con esta variable."
},

{
    "location": "manual/environment-variables.html#JULIA_DEBUG_LOADING-1",
    "page": "Variables de Entorno",
    "title": "JULIA_DEBUG_LOADING",
    "category": "section",
    "text": "Si se establece, entonces Julia imprime información detallada sobre la caché en el proceso de carga de Base.require."
},

{
    "location": "manual/embedding.html#",
    "page": "Embedding Julia",
    "title": "Embedding Julia",
    "category": "page",
    "text": ""
},

{
    "location": "manual/embedding.html#embedding-1",
    "page": "Embedding Julia",
    "title": "Embedding Julia",
    "category": "section",
    "text": "As we have seen in Calling C and Fortran Code, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#)."
},

{
    "location": "manual/embedding.html#High-Level-Embedding-1",
    "page": "Embedding Julia",
    "title": "High-Level Embedding",
    "category": "section",
    "text": "We start with a simple C program that initializes Julia and calls some Julia code:#include <julia.h>\n\nint main(int argc, char *argv[])\n{\n    /* required: setup the Julia context */\n    jl_init();\n\n    /* run Julia commands */\n    jl_eval_string(\"print(sqrt(2.0))\");\n\n    /* strongly recommended: notify Julia that the\n         program is about to terminate. this allows\n         Julia time to cleanup pending write requests\n         and run all finalizers\n    */\n    jl_atexit_hook(0);\n    return 0;\n}In order to build this program you have to put the path to the Julia header into the include path and link against libjulia. For instance, when Julia is installed to $JULIA_DIR, one can compile the above test program test.c with gcc using:gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib test.c -ljulia $JULIA_DIR/lib/julia/libstdc++.so.6Then if the environment variable JULIA_HOME is set to $JULIA_DIR/bin, the output test program can be executed.Alternatively, look at the embedding.c program in the Julia source tree in the examples/ folder. The file ui/repl.c program is another simple example of how to set jl_options options while linking against libjulia.The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling jl_init, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use jl_init_with_image instead.The second statement in the test program evaluates a Julia statement using a call to jl_eval_string.Before the program terminates, it is strongly recommended to call jl_atexit_hook.  The above example program calls this before returning from main.note: Note\nCurrently, dynamically linking with the libjulia shared library requires passing the RTLD_GLOBAL option. In Python, this looks like:>>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)\n>>> julia.jl_init.argtypes = []\n>>> julia.jl_init()\n250593296note: Note\nIf the julia program needs to access symbols from the main executable, it may be necessary to add -Wl,--export-dynamic linker flag at compile time on Linux in addition to the ones generated by julia-config.jl described below. This is not necessary when compiling a shared library."
},

{
    "location": "manual/embedding.html#Using-julia-config-to-automatically-determine-build-parameters-1",
    "page": "Embedding Julia",
    "title": "Using julia-config to automatically determine build parameters",
    "category": "section",
    "text": "The script julia-config.jl was created to aid in determining what build parameters are required by a program that uses embedded Julia.  This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution.  This script is located in the Julia shared data directory."
},

{
    "location": "manual/embedding.html#Example-1",
    "page": "Embedding Julia",
    "title": "Example",
    "category": "section",
    "text": "#include <julia.h>\n\nint main(int argc, char *argv[])\n{\n    jl_init();\n    (void)jl_eval_string(\"println(sqrt(2.0))\");\n    jl_atexit_hook(0);\n    return 0;\n}"
},

{
    "location": "manual/embedding.html#On-the-command-line-1",
    "page": "Embedding Julia",
    "title": "On the command line",
    "category": "section",
    "text": "A simple use of this script is from the command line.  Assuming that julia-config.jl is located in /usr/local/julia/share/julia, it can be invoked on the command line directly and takes any combination of 3 flags:/usr/local/julia/share/julia/julia-config.jl\nUsage: julia-config [--cflags|--ldflags|--ldlibs]If the above example source is saved in the file embed_example.c, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute clang for gcc.:/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c"
},

{
    "location": "manual/embedding.html#Use-in-Makefiles-1",
    "page": "Embedding Julia",
    "title": "Use in Makefiles",
    "category": "section",
    "text": "But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well – assuming GNU make because of the use of the shell macro expansions.  Additionally, though many times julia-config.jl may be found in the directory /usr/local, this is not necessarily the case, but Julia can be used to locate julia-config.jl too, and the makefile can be used to take advantage of that.  The above example is extended to use a Makefile:JL_SHARE = $(shell julia -e 'print(joinpath(JULIA_HOME,Base.DATAROOTDIR,\"julia\"))')\nCFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)\nCXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)\nLDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)\nLDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)\n\nall: embed_exampleNow the build command is simply make."
},

{
    "location": "manual/embedding.html#Converting-Types-1",
    "page": "Embedding Julia",
    "title": "Converting Types",
    "category": "section",
    "text": "Real applications will not just need to execute expressions, but also return their values to the host program. jl_eval_string returns a jl_value_t*, which is a pointer to a heap-allocated Julia object. Storing simple data types like Float64 in this way is called boxing, and extracting the stored primitive data is called unboxing. Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C looks as follows:jl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\n\nif (jl_typeis(ret, jl_float64_type)) {\n    double ret_unboxed = jl_unbox_float64(ret);\n    printf(\"sqrt(2.0) in C: %e \\n\", ret_unboxed);\n}\nelse {\n    printf(\"ERROR: unexpected return type from sqrt(::Float64)\\n\");\n}In order to check whether ret is of a specific Julia type, we can use the jl_isa, jl_typeis, or jl_is_... functions. By typing typeof(sqrt(2.0)) into the Julia shell we can see that the return type is Float64 (double in C). To convert the boxed Julia value into a C double the jl_unbox_float64 function is used in the above code snippet.Corresponding jl_box_... functions are used to convert the other way:jl_value_t *a = jl_box_float64(3.0);\njl_value_t *b = jl_box_float32(3.0f);\njl_value_t *c = jl_box_int32(3);As we will see next, boxing is required to call Julia functions with specific arguments."
},

{
    "location": "manual/embedding.html#Calling-Julia-Functions-1",
    "page": "Embedding Julia",
    "title": "Calling Julia Functions",
    "category": "section",
    "text": "While jl_eval_string allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using jl_call:jl_function_t *func = jl_get_function(jl_base_module, \"sqrt\");\njl_value_t *argument = jl_box_float64(2.0);\njl_value_t *ret = jl_call1(func, argument);In the first step, a handle to the Julia function sqrt is retrieved by calling jl_get_function. The first argument passed to jl_get_function is a pointer to the Base module in which sqrt is defined. Then, the double value is boxed using jl_box_float64. Finally, in the last step, the function is called using jl_call1. jl_call0, jl_call2, and jl_call3 functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use jl_call:jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)Its second argument args is an array of jl_value_t* arguments and nargs is the number of arguments."
},

{
    "location": "manual/embedding.html#Memory-Management-1",
    "page": "Embedding Julia",
    "title": "Memory Management",
    "category": "section",
    "text": "As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.The GC can only run when Julia objects are allocated. Calls like jl_box_float64 perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between jl_... calls. But in order to make sure that values can survive jl_... calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the JL_GC_PUSH macros:jl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\nJL_GC_PUSH1(&ret);\n// Do something with ret\nJL_GC_POP();The JL_GC_POP call releases the references established by the previous JL_GC_PUSH. Note that JL_GC_PUSH  is working on the stack, so it must be exactly paired with a JL_GC_POP before the stack frame is destroyed.Several Julia values can be pushed at once using the JL_GC_PUSH2 , JL_GC_PUSH3 , and JL_GC_PUSH4 macros. To push an array of Julia values one can use the  JL_GC_PUSHARGS macro, which can be used as follows:jl_value_t **args;\nJL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects\nargs[0] = some_value;\nargs[1] = some_other_value;\n// Do something with args (e.g. call jl_... functions)\nJL_GC_POP();The garbage collector also operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the jl_gc_wb (write barrier) function like so:jl_value_t *parent = some_old_value, *child = some_young_value;\n((some_specific_type*)parent)->field = child;\njl_gc_wb(parent, child);It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the parent object was just allocated and garbage collection was not run since then. Remember that most jl_... functions can sometimes invoke garbage collection.The write barrier is also necessary for arrays of pointers when updating their data directly. For example:jl_array_t *some_array = ...; // e.g. a Vector{Any}\nvoid **data = (void**)jl_array_data(some_array);\njl_value_t *some_value = ...;\ndata[0] = some_value;\njl_gc_wb(some_array, some_value);"
},

{
    "location": "manual/embedding.html#Manipulating-the-Garbage-Collector-1",
    "page": "Embedding Julia",
    "title": "Manipulating the Garbage Collector",
    "category": "section",
    "text": "There are some functions to control the GC. In normal use cases, these should not be necessary.Function Description\njl_gc_collect() Force a GC run\njl_gc_enable(0) Disable the GC, return previous state as int\njl_gc_enable(1) Enable the GC,  return previous state as int\njl_gc_is_enabled() Return current state as int"
},

{
    "location": "manual/embedding.html#Working-with-Arrays-1",
    "page": "Embedding Julia",
    "title": "Working with Arrays",
    "category": "section",
    "text": "Julia and C can share array data without copying. The next example will show how this works.Julia arrays are represented in C by the datatype jl_array_t*. Basically, jl_array_t is a struct that contains:Information about the datatype\nA pointer to the data block\nInformation about the sizes of the arrayTo keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:jl_value_t* array_type = jl_apply_array_type(jl_float64_type, 1);\njl_array_t* x          = jl_alloc_array_1d(array_type, 10);Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:double *existingArray = (double*)malloc(sizeof(double)*10);\njl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call free on the data pointer when the array is no longer referenced.In order to access the data of x, we can use jl_array_data:double *xData = (double*)jl_array_data(x);Now we can fill the array:for(size_t i=0; i<jl_array_len(x); i++)\n    xData[i] = i;Now let us call a Julia function that performs an in-place operation on x:jl_function_t *func = jl_get_function(jl_base_module, \"reverse!\");\njl_call1(func, (jl_value_t*)x);By printing the array, one can verify that the elements of x are now reversed."
},

{
    "location": "manual/embedding.html#Accessing-Returned-Arrays-1",
    "page": "Embedding Julia",
    "title": "Accessing Returned Arrays",
    "category": "section",
    "text": "If a Julia function returns an array, the return value of jl_eval_string and jl_call can be cast to a jl_array_t*:jl_function_t *func  = jl_get_function(jl_base_module, \"reverse\");\njl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);Now the content of y can be accessed as before using jl_array_data. As always, be sure to keep a reference to the array while it is in use."
},

{
    "location": "manual/embedding.html#Multidimensional-Arrays-1",
    "page": "Embedding Julia",
    "title": "Multidimensional Arrays",
    "category": "section",
    "text": "Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:// Create 2D array of float64 type\njl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);\njl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);\n\n// Get array pointer\ndouble *p = (double*)jl_array_data(x);\n// Get number of dimensions\nint ndims = jl_array_ndims(x);\n// Get the size of the i-th dim\nsize_t size0 = jl_array_dim(x,0);\nsize_t size1 = jl_array_dim(x,1);\n\n// Fill array with data\nfor(size_t i=0; i<size1; i++)\n    for(size_t j=0; j<size0; j++)\n        p[j + size0*i] = i + j;Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling jl_array_dim) in order to read as idiomatic C code."
},

{
    "location": "manual/embedding.html#Exceptions-1",
    "page": "Embedding Julia",
    "title": "Exceptions",
    "category": "section",
    "text": "Julia code can throw exceptions. For example, consider:jl_eval_string(\"this_function_does_not_exist()\");This call will appear to do nothing. However, it is possible to check whether an exception was thrown:if (jl_exception_occurred())\n    printf(\"%s \\n\", jl_typeof_str(jl_exception_occurred()));If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into libjulia with a function that checks whether an exception was thrown, and then rethrows the exception in the host language."
},

{
    "location": "manual/embedding.html#Throwing-Julia-Exceptions-1",
    "page": "Embedding Julia",
    "title": "Throwing Julia Exceptions",
    "category": "section",
    "text": "When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:if (!jl_typeis(val, jl_float64_type)) {\n    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);\n}General exceptions can be raised using the functions:void jl_error(const char *str);\nvoid jl_errorf(const char *fmt, ...);jl_error takes a C string, and jl_errorf is called like printf:jl_errorf(\"argument x = %d is too large\", x);where in this example x is assumed to be an integer."
},

{
    "location": "manual/packages.html#",
    "page": "Paquetes",
    "title": "Paquetes",
    "category": "page",
    "text": ""
},

{
    "location": "manual/packages.html#packages-1",
    "page": "Paquetes",
    "title": "Paquetes",
    "category": "section",
    "text": "Julia tiene un administrador de paquetes incorporado para instalar la funcionalidad añadida y escrita en Julia. También puede instalar bibliotecas externas utilizando el sistema estándar de su sistema operativo para hacerlo, o compilando desde los fuentes. La lista de paquetes Julia registrados se puede encontrar en http://pkg.julialang.org. Todos los mandatos del gestor de paquetes se encuentran en el módulo Pkg, incluido en la instalación Base de Julia.Primero revisaremos los mecanismos de la familia de mandatos de Pkg y luego brindaremos algunas pautas sobre cómo registrar sus paquetes. Asegúrese de leer la siguiente sección sobre las convenciones de nombres de paquetes, las versiones de etiquetado y la importancia de un archivo REQUIRE para cuando esté listo para agregar su código al repositorio de METADATA seleccionado."
},

{
    "location": "manual/packages.html#Estado-de-un-paquete-1",
    "page": "Paquetes",
    "title": "Estado de un paquete",
    "category": "section",
    "text": "La función Pkg.status() imprime un resumen del estado de los paquetes que uno ha instalado. Inicialmente uno no tendrá paquetes instalados:julia> Pkg.status()\nINFO: Initializing package repository /Users/stefan/.julia/v0.6\nINFO: Cloning METADATA from git://github.com/JuliaLang/METADATA.jl\nNo packages installed.El directorio de paquetes es inicializado automáticamente la primera vez que una ejecute un mandato Pkg que asume su existencia – que incluya Pkg.status(). He aquí un conjunto de ejemplo no trivial de paquetes requeridos y adicionales:julia> Pkg.status()\nRequired packages:\n - Distributions                 0.2.8\n - SHA                           0.3.2\nAdditional packages:\n - NumericExtensions             0.2.17\n - Stats                         0.2.6Estos paquetes están todos en versiones registradas, administradas por Pkg. Los paquetes pueden estar en estados más complicados, indicados por anotaciones a la derecha de la versión del paquete instalado; estos estados y anotaciones serán explicados a medida que los encontremos. Para el uso programático, Pkg.installed() devuelve un diccionario, donde se hacen corresponder los nombres de paquetes instalados con la versión instalada de ese paquete:julia> Pkg.installed()\nDict{String,VersionNumber} with 4 entries:\n\"Distributions\"     => v\"0.2.8\"\n\"Stats\"             => v\"0.2.6\"\n\"SHA\"               => v\"0.3.2\"\n\"NumericExtensions\" => v\"0.2.17\""
},

{
    "location": "manual/packages.html#Añadir-y-eliminar-paquetes-1",
    "page": "Paquetes",
    "title": "Añadir y eliminar paquetes",
    "category": "section",
    "text": "El administrador de paquetes de Julia es un poco inusual ya que es declarativo en lugar de imperativo. Esto significa que uno le dice lo que quiere y el gestor descubre qué versiones instalar (o eliminar) para satisfacer esos requisitos de manera óptima, - y mínimamente. Por tanto, en lugar de instalar un paquete, simplemente lo agrega a la lista de requisitos y luego \"resuelve\" lo que necesita instalar. En particular, esto significa que si algún paquete se ha instalado porque lo necesitaba una versión anterior de algo que usted quería, y una versión más nueva ya no tiene ese requisito, la actualización realmente eliminará ese paquete.Los requisitos de paquetes están en el archivo ~ /.julia/v0.6/REQUIRE. Este archivo puede ser editado a mano y luego llamarse a Pkg.resolve() para instalar, actualizar o eliminar paquetes para satisfacer de manera óptima los requisitos, o puede hacer Pkg.edit(), que abrirá 'REQUIRE' en su editor (configurado a través de las variables de entorno EDITOR oVISUAL), y luego llamará automáticamente a Pkg.resolve() después si es necesario. Si solo desea agregar o eliminar el requisito para un solo paquete, también puede usar los mandatos no interactivos Pkg.add() y Pkg.rm(), que agregan o eliminan un solo requisito a REQUIRE y luego llaman a Pkg.resolve().Puede agregarse un paquete a la lista de requisitos con la función Pkg.add(), y se instalará el paquete y todos los paquetes de los que depende.julia> Pkg.status()\nNo packages installed.\n\njulia> Pkg.add(\"Distributions\")\nINFO: Cloning cache of Distributions from git://github.com/JuliaStats/Distributions.jl.git\nINFO: Cloning cache of NumericExtensions from git://github.com/lindahua/NumericExtensions.jl.git\nINFO: Cloning cache of Stats from git://github.com/JuliaStats/Stats.jl.git\nINFO: Installing Distributions v0.2.7\nINFO: Installing NumericExtensions v0.2.17\nINFO: Installing Stats v0.2.6\nINFO: REQUIRE updated.\n\njulia> Pkg.status()\nRequired packages:\n - Distributions                 0.2.7\nAdditional packages:\n - NumericExtensions             0.2.17\n - Stats                         0.2.6Lo que está haciendo es primero agregar Distribuciones a su archivo ~/.julia/v0.6/REQUIRE:$ cat ~/.julia/v0.6/REQUIRE\nDistributionsA continuación, ejecuta Pkg.resolve() utilizando estos nuevos requisitos, lo que lleva a la conclusión de que el paquete Distributions debe instalarse ya que es obligatorio pero no está instalado. Como se dijo anteriormente, puede lograr lo mismo editando su archivo ~ /.julia/v0.6/REQUIRE a mano y luego ejecutando Pkg.resolve() usted mismo:$ echo SHA >> ~/.julia/v0.6/REQUIRE\n\njulia> Pkg.resolve()\nINFO: Cloning cache of SHA from git://github.com/staticfloat/SHA.jl.git\nINFO: Installing SHA v0.3.2\n\njulia> Pkg.status()\nRequired packages:\n - Distributions                 0.2.7\n - SHA                           0.3.2\nAdditional packages:\n - NumericExtensions             0.2.17\n - Stats                         0.2.6Esto es funcionalmente equivalente a llamar a Pkg.add(\"SHA\"), excepto que Pkg.add() no cambia REQUIRE hasta después de que la instalación haya finalizado, por lo que si hay problemas, REQUIRE quedará como estaba antes de llamar a Pkg.add(). El formato del archivo REQUIRE se describe en Especificación de requisitos; permite, entre otras cosas, requerir rangos específicos de versiones de paquetes.Cuando decida que no quiere tener un paquete más, puede usar Pkg.rm() para eliminar el requisito del archivo REQUIRE:julia> Pkg.rm(\"Distributions\")\nINFO: Removing Distributions v0.2.7\nINFO: Removing Stats v0.2.6\nINFO: Removing NumericExtensions v0.2.17\nINFO: REQUIRE updated.\n\njulia> Pkg.status()\nRequired packages:\n - SHA                           0.3.2\n\njulia> Pkg.rm(\"SHA\")\nINFO: Removing SHA v0.3.2\nINFO: REQUIRE updated.\n\njulia> Pkg.status()\nNo packages installed.Una vez más, esto es equivalente a editar el archivo REQUIRE para eliminar la línea con cada nombre de paquete y ejecutar Pkg.resolve() para actualizar el conjunto de paquetes instalados para que coincidan. Mientras que Pkg.add() y Pkg.rm() son convenientes para agregar y eliminar requisitos para un solo paquete, cuando desea agregar o eliminar paquetes múltiples, puede llamar a Pkg.edit() para cambiar manualmente el contenido de REQUIRE y luego actualizar sus paquetes en consecuencia. Pkg.edit() no retrotrae el contenido de REQUIRE si Pkg.resolve() falla, sino que debe ejecutar Pkg.edit() otra vez para corregir el contenido de los archivos uno mismo.Debido a que el administrador de paquetes usa libgit2 internamente para administrar los repositorios git del paquete, los usuarios pueden encontrarse con problemas de protocolo (por ejemplo, si están detrás de un firewall) al ejecutar Pkg.add(). Por defecto, se accederá a todos los paquetes alojados por GitHub a través de 'https'; este valor predeterminado se puede modificar llamando a Pkg.setprotocol!(). El siguiente comando se puede ejecutar desde la línea de comando para decirle a git que use 'https' en lugar del protocolo 'git' cuando clona todos los repositorios, dondequiera que estén alojados:git config --global url.\"https://\".insteadOf git://Sin embargo, este cambio será en todo el sistema y, por lo tanto, es preferible utilizar Pkg.setprotocol!().note: Note\nLas funciones del administrador de paquetes también aceptan el sufijo .jl sobre los nombres de paquetes, aunque el sufijo sea eliminado internamente. Por ejemplo:Pkg.add(\"Distributions.jl\")\nPkg.rm(\"Distributions.jl\")"
},

{
    "location": "manual/packages.html#Instalación-de-paquetes-fuera-de-línea-1",
    "page": "Paquetes",
    "title": "Instalación de paquetes fuera de línea",
    "category": "section",
    "text": "Para las máquinas sin conexión a Internet, los paquetes se pueden instalar copiando el directorio raíz del paquete (proporcionado por Pkg.dir()) desde una máquina con el mismo sistema operativo y entorno.Pkg.add() hace lo siguiente dentro del directorio raíz del paquete:Agrega el nombre del paquete a REQUIRE.\nDescarga el paquete en .cache, luego copia el paquete en el directorio raíz del paquete.\nRealiza recursivamente el paso 2 contra todos los paquetes enumerados en el archivo REQUIRE del paquete.\nEjecuta Pkg.build()warning: Warning\nCopiar paquetes instalados desde una máquina diferente es frágil para paquetes que requieren dependencias  externas binarias. Dichos paquetes pueden romperse debido a diferencias en las versiones del sistema  operativo, entornos de compilación y / o dependencias absolutas de rutas."
},

{
    "location": "manual/packages.html#Instalar-paquetes-no-registrados-1",
    "page": "Paquetes",
    "title": "Instalar paquetes no registrados",
    "category": "section",
    "text": "Los paquetes de Julia son simplemente repositorios git, clonables a través de cualquiera de los protocolos que admite git, y que contienen código Julia que sigue ciertas convenciones de diseño. Los paquetes oficiales de Julia están registrados en el repositorio METADATA.jl, disponible en una ubicación conocida [1]. Los mandatos Pkg.add() y Pkg.rm() de la sección anterior interactúan con los paquetes registrados, pero el administrador de paquetes también puede instalar y trabajar con paquetes no registrados. Para instalar un paquete no registrado, usaremos Pkg.clone(url), donde url es una URL de git desde la cual se puede clonar el paquete:julia> Pkg.clone(\"git://example.com/path/to/Package.jl.git\")\nINFO: Cloning Package from git://example.com/path/to/Package.jl.git\nCloning into 'Package'...\nremote: Counting objects: 22, done.\nremote: Compressing objects: 100% (10/10), done.\nremote: Total 22 (delta 8), reused 22 (delta 8)\nReceiving objects: 100% (22/22), 2.64 KiB, done.\nResolving deltas: 100% (8/8), done.Por convención, los nombres de los repositorios de Julia terminan con .jl (el .git adicional indica un repositorio \"vacío\" de git), lo que evita que colisionen con los repositorios de otros lenguajes, y también hace que los paquetes de Julia sean fáciles de encontrar en los motores de búsqueda. Sin embargo, cuando los paquetes están instalados en su directorio .julia/v0.6, la extensión es redundante, por lo que la dejamos fuera.Si los paquetes no registrados contienen un archivo REQUIRE en la parte superior de su árbol fuente, ese archivo se usará para determinar de qué paquetes registrados depende el paquete no registrado, y se instalarán automáticamente. Los paquetes no registrados participan en la misma lógica de resolución de versiones que los paquetes registrados, por lo que las versiones de paquetes instalados se ajustarán según sea necesario para satisfacer los requisitos de los paquetes registrados y no registrados.[1]: El conjunto oficial de paquetes está en  [https://github.com/JuliaLang/METADATA.jl(https://github.com/JuliaLang/METADATA.jl),  pero los individuos y las organizaciones pueden usar fácilmente un repositorio de  metadatos diferente. Esto permite controlar qué paquetes están disponibles para la i nstalación automática. Solo se pueden permitir versiones de paquete auditadas y aprobadas,  y hacer paquetes privados u horquillas disponibles. Ver Repositorio METADATA personalizado para más detalles."
},

{
    "location": "manual/packages.html#Actualizando-Paquetes-1",
    "page": "Paquetes",
    "title": "Actualizando Paquetes",
    "category": "section",
    "text": "Cuando los desarrolladores de paquetes publican nuevas versiones registradas de los paquetes que está utilizando, por supuesto, querrá las nuevas versiones brillantes. Para obtener las últimas y mejores versiones de todos sus paquetes, simplemente haga Pkg.update():When package developers publish new registered versions of packages that you're using, you will, of course, want the new shiny versions. To get the latest and greatest versions of all your packages, just do Pkg.update():julia> Pkg.update()\nINFO: Updating METADATA...\nINFO: Computing changes...\nINFO: Upgrading Distributions: v0.2.8 => v0.2.10\nINFO: Upgrading Stats: v0.2.7 => v0.2.8El primer paso para actualizar paquetes es generar nuevos cambios en ~/.julia/v0.6/ METADATA y ver si se ha publicado alguna nueva versión del paquete registrado. Después de esto, Pkg.update() intenta actualizar paquetes que están desprotegidos en una rama y no están sucios (es decir, no se han realizado cambios a los archivos rastreados por git) al extraer los cambios del repositorio en sentido ascendente del paquete. Los cambios en sentido ascendente solo se aplicarán si no es necesaria la fusión o rebase, es decir, si la rama puede ser \"fast-forwarded\". Si la rama no se puede reenviar rápidamente, se supone que está trabajando en ella y actualizará el repositorio usted mismo.Finalmente, el proceso de actualización vuelve a calcular un conjunto óptimo de versiones de paquetes a tener instalado para satisfacer sus requisitos de nivel superior y los requisitos de paquetes \"fijos\". Un paquete es considerado corregido si es uno de los siguientes:No registrado: el paquete no está en METADATA - uno lo instaló con Pkg.clone().\nRetirado: el repositorio del paquete está en una rama de desarrollo.\nSucio: se han realizado cambios a los archivos en el repositorio.Si cualquiera de estos es el caso, el administrador del paquete no puede cambiar libremente la versión instalada de el paquete, por lo que sus requisitos deben ser satisfechos por cualquier otra versión del paquete que elija. La combinación de requisitos de nivel superior en ~/.julia/v0.6/REQUIRE y el requisito de requisitos fijos los paquetes se usan para determinar qué se debe instalar.También puede actualizar solo un subconjunto de los paquetes instalados, proporcionando argumentos a la función Pkg.update. En ese caso, solo los paquetes proporcionados como argumentos y sus dependencias serán actualizados:julia> Pkg.update(\"Example\")\nINFO: Updating METADATA...\nINFO: Computing changes...\nINFO: Upgrading Example: v0.4.0 => 0.4.1Este proceso de actualización parcial todavía calcula el nuevo conjunto de versiones de paquetes de acuerdo con los requisitos de nivel superior y los paquetes \"fijos\", pero considera además todos los demás paquetes, excepto los explícitamente proporcionados, y sus dependencias, como corregidas."
},

{
    "location": "manual/packages.html#Pago,-Pin-y-Gratis-1",
    "page": "Paquetes",
    "title": "Pago, Pin y Gratis",
    "category": "section",
    "text": "Puede querer usar la versión maestra de un paquete en lugar de una de sus versiones registradas. Es posible que haya correcciones o funcionalidades que necesite y que aún no se hayan publicado en ninguna versión registrada, o puede que sea un desarrollador del paquetes y necesite realizar cambios en master o en alguna otra rama de desarrollo. En tales casos, puede hacer Pkg.checkout(pkg) para verificar la rama master depkg o Pkg.checkout(pkg, branch) para verificar alguna otra rama:julia> Pkg.add(\"Distributions\")\nINFO: Installing Distributions v0.2.9\nINFO: Installing NumericExtensions v0.2.17\nINFO: Installing Stats v0.2.7\nINFO: REQUIRE updated.\n\njulia> Pkg.status()\nRequired packages:\n - Distributions                 0.2.9\nAdditional packages:\n - NumericExtensions             0.2.17\n - Stats                         0.2.7\n\njulia> Pkg.checkout(\"Distributions\")\nINFO: Checking out Distributions master...\nINFO: No packages to install, update or remove.\n\njulia> Pkg.status()\nRequired packages:\n - Distributions                 0.2.9+             master\nAdditional packages:\n - NumericExtensions             0.2.17\n - Stats                         0.2.7Inmediatamente después de instalar Distributions con Pkg.add() está en la versión registrada más reciente actual - 0.2.9 en el momento de escribir esto. Luego, después de ejecutar Pkg.checkout(\"Distributions\"), puede ver en la salida de Pkg.status() que Distributions está en una versión no registrada mayor que 0.2.9, indicado por el número de \"pseudo-versión\" 0.2.9+.Cuando compra una versión no registrada de un paquete, la copia del archivo REQUIRE en el repositorio del paquete tiene prioridad sobre cualquier requisito registrado en METADATA, por lo que es importante que los desarrolladores mantengan este archivo exacto y actualizado, lo que refleja los requisitos reales de la versión actual del paquete. Si el archivo REQUIRE en el repositorio del paquete es incorrecto o falta, las dependencias se pueden eliminar cuando se desprotege el paquete. Este archivo también se usa para completar las versiones del paquete publicadas recientemente si utiliza la API que Pkg proporciona para esto (que se describe a continuación).Cuando decide que ya no desea tener un paquete desprotegido en una rama, puede \"liberarlo\" de nuevo al control del administrador de paquetes con Pkg.free(pkg):julia> Pkg.free(\"Distributions\")\nINFO: Freeing Distributions...\nINFO: No packages to install, update or remove.\n\njulia> Pkg.status()\nRequired packages:\n - Distributions                 0.2.9\nAdditional packages:\n - NumericExtensions             0.2.17\n - Stats                         0.2.7Después de esto, dado que el paquete está en una versión registrada y no en una sucursal, su versión se actualizará a medida que se publiquen nuevas versiones registradas del paquete.Si desea fijar un paquete en una versión específica para que llamar Pkg.update() no cambie la versión en la que está el paquete, puede usar Pkg.pin() función:julia> Pkg.pin(\"Stats\")\nINFO: Creating Stats branch pinned.47c198b1.tmp\n\njulia> Pkg.status()\nRequired packages:\n - Distributions                 0.2.9\nAdditional packages:\n - NumericExtensions             0.2.17\n - Stats                         0.2.7              pinned.47c198b1.tmpDespués de esto, el paquete Stats permanecerá anclado en la versión0.2.7 - o más específicamente, en el commit  47c198b1, pero como las versiones están asociadas permanentemente a un hash git dado, esto es lo mismo. Pkg.pin() funciona creando una rama descartable para la confirmación a la que desea fijar el paquete y luego verificando esa ramificación. De forma predeterminada, fija un paquete en la confirmación actual, pero puede elegir una versión diferente pasando un segundo argumento:julia> Pkg.pin(\"Stats\",v\"0.2.5\")\nINFO: Creating Stats branch pinned.1fd0983b.tmp\nINFO: No packages to install, update or remove.\n\njulia> Pkg.status()\nRequired packages:\n - Distributions                 0.2.9\nAdditional packages:\n - NumericExtensions             0.2.17\n - Stats                         0.2.5              pinned.1fd0983b.tmpAhora el paquete Stats está anclado en commit 1fd0983b, que corresponde a la versión 0.2.5. Cuando decides \"desanclar\" un paquete y dejar que el administrador de paquetes lo actualice nuevamente, puedes usar Pkg.free() como lo harías para deshacerte de cualquier rama:julia> Pkg.free(\"Stats\")\nINFO: Freeing Stats...\nINFO: No packages to install, update or remove.\n\njulia> Pkg.status()\nRequired packages:\n - Distributions                 0.2.9\nAdditional packages:\n - NumericExtensions             0.2.17\n - Stats                         0.2.7Después de esto, el paquete Stats es gestionado nuevamente por el administrador del paquete, y las futuras llamadas a Pkg.update() lo actualizarán a versiones más nuevas cuando se publiquen. La rama descartable pinned.1fd0983b.tmp permanece en el repositorio local deStats, pero como las ramas de git son extremadamente livianas, esto realmente no importa; si desea limpiarlos, puede acceder al repositorio y eliminar esas ramas [2].[2]: Los paquetes que no están en las ramas también se marcarán como sucios si realiza cambios en el repositorio,  pero eso es menos común."
},

{
    "location": "manual/packages.html#custom-metadata-repository-1",
    "page": "Paquetes",
    "title": "Repositorio METADATA Personalizado",
    "category": "section",
    "text": "Por defecto, Julia supone que utilizará el repositorio oficial METADATA.jl para descargar e instalar paquetes. También podemos proporcionar una ubicación de repositorio de metadatos diferente. Un enfoque común es mantener nuestra rama metadata-v2 actualizada con la rama oficial de Julia y agregar otra rama con sus paquetes personalizados. Puede inicializar su repositorio de metadatos local utilizando esa ubicación y rama personalizadas y luego volver a establecer la base de nuestra rama personalizada con la rama oficial metadata-v2. Para utilizar un repositorio y una sucursal personalizados, utilice el siguiente mandato:julia> Pkg.init(\"https://me.example.com/METADATA.jl.git\", \"branch\")El argumento de la rama es opcional y se predetermina a metadata-v2. Una vez inicializado, un archivo llamado META_BRANCH en su ruta ~/.julia/vX.Y/ hará un seguimiento de la rama con la que se inicializó su repositorio METADATA. Si desea cambiar de rama, necesitará modificar el archivo META_BRANCH directamente (¡tenga cuidado!) O elimine el directoriovX.Y y reinicie su repositorio METADATA utilizando el mandato Pkg.init."
},

{
    "location": "manual/packages.html#package-development-1",
    "page": "Paquetes",
    "title": "Desarrollo de Paquetes",
    "category": "section",
    "text": "El administrador de paquetes de Julia está diseñado para que cuando tenga un paquete instalado, ya pueda ver su código fuente y el historial completo de desarrollo. También puede realizar cambios en los paquetes, enviarlos por git y contribuir fácilmente a las correcciones y mejoras en el flujo ascendente. Del mismo modo, el sistema está diseñado para que, si desea crear un nuevo paquete, la forma más sencilla de hacerlo sea dentro de la infraestructura proporcionada por el administrador de paquetes."
},

{
    "location": "manual/packages.html#man-initial-setup-1",
    "page": "Paquetes",
    "title": "Initial Setup",
    "category": "section",
    "text": "Dado que los paquetes son repositorios de git, antes de realizar cualquier desarrollo de paquete, tenemos que fijar los siguientes ajustes de configuración de git global estándar:$ git config --global user.name \"FULL NAME\"\n$ git config --global user.email \"EMAIL\"donde FULL NAME es su nombre completo actual (se permiten espacios entre las comillas dobles) yEMAIL es su dirección de correo electrónico real. Aunque no es necesario usar GitHub para crear o publicar paquetes de Julia, la mayoría de los paquetes de Julia al momento de escribir esto están alojados en GitHub y el administrador de paquetes sabe cómo formatear correctamente las URL de origen. y de lo contrario trabajar con el servicio sin problemas. Le recomendamos que cree una cuenta gratuita en GitHub y luego haga lo siguiente:$ git config --global github.user \"USERNAME\"donde USERNAME es nuestro nombre real de usuario en GitHub. Una vez que hace esto, el administrador de paquetes reconoce el nombre de usuario GitHub y puede configurar las cosas en consecuencia. También debemos cargar nuestra clave pública SSH a GitHub y configurar un agente SSH en nuestra máquina de desarrollo para que pueda realizar cambios con una molestia mínima. En el futuro, haremos que este sistema sea extensible y admitiremos otras opciones comunes de alojamiento git como BitBucket y permitiremos a los desarrolladores elegir su favorito. Como las funciones de desarrollo del paquete se han movido al paquete PkgDev, debe ejecutar Pkg.add (\"PkgDev\"); import PkgDev para acceder a las funciones que comienzan con PkgDev en el documento siguiente."
},

{
    "location": "manual/packages.html#Hacer-cambios-a-un-paquete-existente-1",
    "page": "Paquetes",
    "title": "Hacer cambios a un paquete existente",
    "category": "section",
    "text": ""
},

{
    "location": "manual/packages.html#Cambios-en-la-Documentación-1",
    "page": "Paquetes",
    "title": "Cambios en la Documentación",
    "category": "section",
    "text": "Si desea mejorar la documentación en línea de un paquete, el enfoque más fácil (al menos para pequeños cambios) es utilizar la funcionalidad de edición en línea de GitHub. Primero, vaya a la \"página de inicio\" de GitHub del repositorio, busque el archivo (por ejemplo, README.md) dentro de la estructura de carpetas del repositorio y haga clic en él. Verá el contenido que se muestra, junto con un pequeño icono de \"lápiz\" en la esquina superior derecha. Al hacer clic en ese icono, se abre el archivo en modo de edición. Realice los cambios, escriba un breve resumen que describa los cambios que desea realizar (este es su mensaje de confirmación), y luego presione \"Proponer cambio de archivo\". Sus cambios serán enviados para su consideración por el propietario (s) del paquete y sus colaboradores.Para cambios de documentación más grandes, y especialmente aquellos que espera tener que actualizar en respuesta a los comentarios, puede que le resulte más fácil utilizar el procedimiento para los cambios de código que se describe a continuación."
},

{
    "location": "manual/packages.html#Caambios-en-el-Código-1",
    "page": "Paquetes",
    "title": "Caambios en el Código",
    "category": "section",
    "text": ""
},

{
    "location": "manual/packages.html#Resumen-Ejecutivo-1",
    "page": "Paquetes",
    "title": "Resumen Ejecutivo",
    "category": "section",
    "text": "Aquí suponemos que ya ha configurado git en su máquina local y tiene una cuenta de GitHub (consulte más arriba). Imaginemos que está solucionando un error en el paquete Images:Pkg.checkout(\"Images\")           # check out the master branch\n<here, make sure your bug is still a bug and hasn't been fixed already>\ncd(Pkg.dir(\"Images\"))\n;git checkout -b myfixes         # create a branch for your changes\n<edit code>                      # be sure to add a test for your bug\nPkg.test(\"Images\")               # make sure everything works now\n;git commit -a -m \"Fix foo by calling bar\"   # write a descriptive message\nusing PkgDev\nPkgDev.submit(\"Images\")La última línea le presentará un enlace para enviar una solicitud de extracción para incorporar sus cambios."
},

{
    "location": "manual/packages.html#Descripción-Detallada-1",
    "page": "Paquetes",
    "title": "Descripción Detallada",
    "category": "section",
    "text": "Si desea corregir un error o agregar una nueva funcionalidad, desea poder probar los cambios antes de enviarlos para su consideración. También debe tener una manera fácil de actualizar su propuesta en respuesta a los comentarios del propietario del paquete. En consecuencia, en este caso, la estrategia es trabajar localmente en su propia máquina; una vez que esté satisfecho con sus cambios, los envía para su consideración. Este proceso se llama solicitud de extracción porque usted está solicitando \"extraer\" sus cambios en el repositorio principal del proyecto. Debido a que el repositorio en línea no puede ver el código en su máquina privada, primero * envía * sus cambios a una ubicación visible públicamente, su propio * fork * en línea del paquete (alojado en su propia cuenta personal de GitHub).Supongamos que ya tiene instalado el paquete Foo. En la siguiente descripción, todo lo que comience con Pkg oPkgDev debe escribirse en el prompt de Julia; cualquier cosa que comience con git debe escribirse en modo de shell de julia (o usando el shell que viene con su sistema operativo). Dentro de Julia, puedes combinar estos dos modos:julia> cd(Pkg.dir(\"Foo\"))          # go to Foo's folder\n\nshell> git command arguments...    # command will apply to FooAhora supongamos que está listo para hacer algunos cambios en Foo. Si bien hay varios enfoques posibles, aquí hay uno que se utiliza ampliamente:Desde el prompt de Julia, escriba Pkg.checkout(\"Foo\"). Esto garantiza que está ejecutando  el último código (la rama master), en lugar de cualquier copia de la \"versión oficial\" que haya instalado.  (Si planea corregir un error, en este punto es una buena idea verificar nuevamente si el error ya ha sido  corregido por otra persona. Si lo ha hecho, puede solicitar que se etiquete un nuevo lanzamiento oficial  para que la corrección se distribuya al resto de la comunidad). Si recibe un error Foo is dirty, bailing,  consulte Paquetes sucios a continuación.\nCrea una rama para tus cambios: navega a la carpeta del paquete (la que Julia informa desde  Pkg.dir(\"Foo\")) y (en modo shell) crea una nueva rama usando git checkout -b <newbranch>,  donde <newbranch> podría ser un nombre descriptivo (por ejemplo,fixbar). Al crear una rama, se  asegura de que pueda moverse fácilmente entre su nuevo trabajo y la rama actual 'principal' (consulte  https://git-scm.com/book/es/v2/Git-Branching-Branches-in-a-Nutshell).Si olvida hacer este paso hasta que haya realizado algunos cambios, no se preocupe: consulte más detalles sobre la bifurcación a continuación.Haz tus cambios. Ya sea para corregir un error o agregar una nueva funcionalidad, en la mayoría de los casos tu  cambio debería incluir actualizaciones para las carpetas src/ y test/. Si estás solucionando un error, agrega  un ejemplo mínimo que demuestre el error (en el código actual) al conjunto de pruebas; al contribuir con una  prueba para el error, te aseguras de que el error no vuelva a aparecer accidentalmente en algún momento posterior  debido a otros cambios. Si agregas una nueva funcionalidad, la creación de pruebas le demuestra al propietario  del paquete que te has asegurado de que el código funcione según lo previsto.\nEjecuta las pruebas del paquete y asegúrate de que pasen. Hay varias formas de ejecutar las pruebas:\nDesde Julia, ejecuta Pkg.test(\"Foo\"): esto ejecutará tus pruebas en un proceso  separado (nuevo) julia.\nDesde Julia, include(\"runtests.jl\") desde la carpeta test/ del paquete (es posible que el  archivo tenga un nombre diferente, busque uno que ejecute todas las pruebas): esto te permite  ejecutar las pruebas repetidamente en la misma sesión sin volver a cargar todo el código del  paquete; para paquetes que tardan un poco en cargarse, esto puede ser mucho más rápido. Con  este enfoque, debes hacer un trabajo adicional para realizar  cambios en el código del paquete.\nDesde el shell, ejecute julia ../test / runtests.jl desde dentro de la carpetasrc /del  paquete.\nConfirma tus cambios: consulte https://git-scm.com/book/es/v2/Git-Basics-Recording-Changes-to-the-Repository.\nEnvía tus cambios: desde el prompt de Julia, escribe PkgDev.submit(\"Foo\"). Esto impulsará los  cambios a la bifurcacion de GitHub y la creará si aún no existe. (Si encuentras un error,  asegúrate de haber configurado tus claves SSH.) Julia le dará un  hipervínculo; abra ese enlace, edite el mensaje y luego haga clic en \"enviar\". En ese momento,  se notificará al propietario del paquete de sus cambios y podrá iniciar el debate.  (Si te sientes cómodo con git, también puedes hacer estos pasos manualmente desde el shell).\nEl propietario del paquete puede sugerir mejoras adicionales. Para responder a esas sugerencias,  puede actualizar fácilmente la solicitud de extracción (esto solo funciona para cambios que aún  no se han fusionado, para solicitudes de extracción fusionadas, realice nuevos cambios iniciando  una nueva rama):\nSi ha cambiado ramas mientras tanto, asegúrese de volver a la misma rama con git checkout fixbar \n(del modo shell) o Pkg.checkout(\"Foo\", \"fixbar\") (del prompt de Julia).\nComo arriba, haga sus cambios, ejecute las pruebas y comprometa sus cambios.\nDesde el shell, escribe git push. Esto agregará sus nuevas confirmaciones a la misma solicitud  de extracción; debería verlos aparecer automáticamente en la página que contiene la discusión de  su solicitud de extracción.Un posible tipo de cambio que el propietario puede solicitar es que elimine sus compromisos. Ver Squashing a continuación."
},

{
    "location": "manual/packages.html#dirty-packages-1",
    "page": "Paquetes",
    "title": "Paquetes Sucios",
    "category": "section",
    "text": "Si no se pueden cambiar las ramas porque el administrador del paquete se queja de que su paquete está sucio, significa que tiene algunos cambios que no se han confirmado (enviado). Desde el shell, use git diff para ver cuáles son estos cambios; puede descartarlos (git checkout changedfile.jl) o confirmarlos antes de cambiar de rama. Si no puede resolver los problemas manualmente, como último recurso, puede eliminar toda la carpeta \"Foo\" y reinstalar una nueva copia con Pkg.add(\"Foo\"). Naturalmente, esto borra cualquier cambio que haya realizado."
},

{
    "location": "manual/packages.html#man-branch-post-hoc-1",
    "page": "Paquetes",
    "title": "Haciendo una Rama post hoc",
    "category": "section",
    "text": "Especialmente para los recién llegados a git, uno a menudo se olvida de crear una nueva rama hasta después de que ya se hayan hecho algunos cambios. Si todavía no has organizado ni comprometido tus cambios, puedes crear una nueva rama con git checkout -b <newbranch> como siempre - git te mostrará amablemente que algunos archivos han sido modificados y creará la nueva rama para ti. Sus cambios aún no se han comprometido a esta nueva rama, por lo que las reglas de trabajo normales aún se aplican.Sin embargo, si ya has hecho un commit a master pero deseas volver almaster oficial (llamado origin/master), utiliza el siguiente procedimiento:Crea una nueva rama. Esta rama mantendrá tus cambios.\nAsegúrate de que todo esté comprometido con esta rama.\ngit checkout master. Si esto no funciona, no continúes hasta que hayas resuelto los problemas, o puedes perder los cambios.\nRestablece master (tu rama actual) a un estado anterior con git reset --hard origin/master (ver https://git-scm.com/blog/2011/07/11/reset.html).Esto requiere un poco más de familiaridad con git, por lo que es mucho mejor tener el hábito de crear una rama desde el principio."
},

{
    "location": "manual/packages.html#man-squashing-and-rebasing-1",
    "page": "Paquetes",
    "title": "Squashing and rebasing",
    "category": "section",
    "text": "Dependiendo de los gustos del propietario(s) del paquete, él podrá pedirte que \"squash\" tus compromisos. Esto es especialmente probable si el cambio es bastante simple, pero su historial de compromiso se ve así:WIP: add new 1-line whizbang function (currently breaks package)\nFinish whizbang function\nFix typo in variable name\nOops, don't forget to supply default argument\nSplit into two 1-line functions\nRats, forgot to export the second function\n...Esto entra en el territorio del uso de git más avanzado, y se te anima a leer un poco ([https://git-scm.com/book/en/v2/Git-Branching-Rebasing]]https://git -scm.com/book/en/v2/Git-Branching-Rebasing)). Sin embargo, un breve resumen del procedimiento es el siguiente:Para protegerse del error, comienza desde tu rama fixbar y crea una nueva rama congit checkout -b fixbar_backup. Como has comenzado desde fixbar, esta será una copia. Ahora vuelve a la que intentas modificar con git checkout fixbar.\nDesde el shell, escribe git rebase -i origin/master.\nPara combinar confirmaciones, cambia pick por squash (para opciones adicionales, consulta otras fuentes). Guarda el archivo y cierre la ventana del editor.\nEdita el mensaje de confirmación combinado.Si la operación de rebase funciona mal, puedes volver al principio para intentarlo de nuevo de esta manera:git checkout fixbar\ngit reset --hard fixbar_backupAhora supongamos que has realizado la operación de rebase con éxito. Como el repositorio fixbar ahora se ha separado del que está en tu fork GitHub, vas a tener que hacer un force push:Para que sea fácil referirse a tu rama GitHub, cree un \"manejador\" para ella con git remote add myfork https://github.com/myaccount/Foo.jl.git, donde la URL proviene de la \"URL de clonación\" en la página de tu bifurcación de GitHub.\nPara que sea fácil referirse a tu rama GitHub, cree un \"manejador\" para ella con git remote add myfork https://github.com/myaccount/Foo.jl.git,\nFuerza el push a tu bifurcación con git push myfork+fixbar. El + indica que esto debería reemplazar la rama fixbar encontrada enmyfork."
},

{
    "location": "manual/packages.html#Creando-un-nuevo-Paquete-1",
    "page": "Paquetes",
    "title": "Creando un nuevo Paquete",
    "category": "section",
    "text": ""
},

{
    "location": "manual/packages.html#REQUIRE-habla-por-sí-mismo-1",
    "page": "Paquetes",
    "title": "REQUIRE habla por sí mismo",
    "category": "section",
    "text": "Deberías tener un archivo REQUIRE en tu repositorio de paquetes, con una directiva mínima de la versión de Julia que esperas que los usuarios ejecuten para que el paquete funcione. Poniendo un piso en qué versión de Julia apoya tu paquete se hace simplemente agregando julia 0.x en este archivo. Si bien esta línea es parcialmente informativa, también tiene la consecuencia de si Pkg.update() actualizará el código que se encuentra en los directorios de versiones .julia. No actualizará el código encontrado en los directorios de versiones debajo del piso de lo que se especifica en su 'REQUIRE'.A medida que la versión de desarrollo '0.y' madura, es posible que la utilices con más frecuencia y desees que su paquete la admita. Ten cuidado, la rama de desarrollo de Julia es \"tierra de la rotura\", y puede esperar que haya cosas que se rompan. Cuando vayas a arreglar lo que rompió tu paquete en la rama de desarrollo 0.y, probablemente encontrarás que acaba de romper tu paquete en la versión estable.Hay un mecanismo que se encuentra en el paquete Compat que le permitirá admitir tanto la versión estable como los cambios de última hora que se encuentran en la versión de desarrollo. Si decide utilizar esta solución, deberá agregar Compat a su archivoREQUIRE. En este caso, todavía tendrá julia 0.x en suREQUIRE. La x es la versión de piso de lo que su paquete admite.Es posible que tampoco tengas interés en apoyar la versión de desarrollo de Julia. Del mismo modo que puede agregar un piso a la versión que espera que tengan los usuarios, puede establecer un límite superior. En este caso, pondría julia 0.x 0.y- en su archivo REQUIRE. El - al final del número de versión se refiere a las versiones preliminares de esa versión específica desde el primer compromiso. Al establecerlo como techo, quiere decir que el código es compatible con todo pero no incluye la versión de techo.Otra situación es que está escribiendo la mayor parte del código para su paquete con Julia 0.y y no desea admitir la versión estable actual de Julia. Si elige hacer esto, simplemente agregue julia 0.y- a su REQUIRE. Solo recuerda cambiar julia 0.y- a julia 0.y en tu archivoREQUIRE una vez que 0.y sea lanzado oficialmente. Si no edita el dash cruft, estás sugiriendo que admita tanto el desarrollo como las versiones estables del mismo número de versión. Eso sería una locura. Consulte la Especificación de requisitos para obtener el formato completo de REQUIRE.Por último, en muchos casos puede necesitar paquetes adicionales para las pruebas. Paquetes adicionales que solo son necesarios para las pruebas deben especificarse en el archivo test/REQUIRE. Este archivo REQUIRE tiene la misma especificación que el archivo REQUIRE estándar."
},

{
    "location": "manual/packages.html#Líneas-Guía-para-Nombrar-un-Paquete-1",
    "page": "Paquetes",
    "title": "Líneas Guía para Nombrar un Paquete",
    "category": "section",
    "text": "Los nombres de los paquetes deben ser sensatos para la mayoría de los usuarios de Julia, incluso para aquellos que no son expertos en el dominio. Cuando envíes tu paquete a METADATA, puedes esperar un poco de ida y vuelta sobre el nombre del paquete con tus colaboradores, especialmente si es ambiguo o puede confundirse con algo diferente de lo que es. Durante este intervalo de tiempo, no es raro obtener una variedad de diferentes sugerencias de nombres. Sin embargo, estas son solo sugerencias, con la intención de mantener un espacio de nombres ordenado en el repositorio de METADATA seleccionado. Como este repositorio pertenece a toda la comunidad, es probable que haya algunos colaboradores a los que les importe el nombre de su paquete. Aquí hay algunas pautas a seguir para nombrar su paquete:Evita la jerga. En particular, evita los acrónimos a menos que haya una mínima posibilidad de confusión.\nEstá bien decir USA si estás hablando de USA.\nNo está bien decir PMA, incluso si estás hablando de una actitud mental positiva.\nEvite usar Julia en el nombre de su paquete.\nPor lo general, es claro, por contexto y para sus usuarios, que el paquete es un paquete Julia.\nTener a Julia en el nombre puede implicar que el paquete está conectado a, o avalado por, colaboradores del propio lenguaje Julia.\nLos paquetes que proporcionan la mayor parte de su funcionalidad en asociación con un nuevo tipo deberían tener nombres pluralizados.\nDataFrames proporciona el tipoDataFrame.\nBloomFilters proporciona el tipoBloomFilter.\nPor el contrario, JuliaParser no proporciona ningún tipo nuevo, sino una nueva funcionalidad en la función JuliaParser.parse().\nErr del lado de la claridad, incluso si la claridad te parece larga.\nRandomMatrices es un nombre menos ambiguo queRndMat o RMT, aunque estos últimos sean más cortos.\nUn nombre menos sistemático puede adaptarse a un paquete que implemente uno de varios enfoques posibles para su dominio.\nJulia no tiene un solo paquete completo de graficación. En cambio, Gadfly,PyPlot, Winston y otros paquetes implementan cada uno un enfoque único basado en una filosofía de diseño particular.\nPor el contrario, SortingAlgorithms proporciona una interfaz coherente para usar muchos sistemas bien establecidos de algoritmos de clasificación.\nLos paquetes que envuelven bibliotecas externas o programas deben tener el nombre de esas bibliotecas o programas.\nCPLEX.jl envuelve la bibliotecaCPLEX, -que se puede identificar fácilmente en una búsqueda web.\nMATLAB.jl proporciona una interfaz para llamar al motor de MATLAB desde dentro de Julia."
},

{
    "location": "manual/packages.html#Generando-el-paquete-1",
    "page": "Paquetes",
    "title": "Generando el paquete",
    "category": "section",
    "text": "Supongamos que quiere crear un nuevo paquete de Julia llamado FooBar. Para comenzar, haga PkgDev.generate(pkg,license) donde pkg es el nuevo nombre del paquete ylicense es el nombre de una licencia que el generador de paquetes conoce:julia> PkgDev.generate(\"FooBar\",\"MIT\")\nINFO: Initializing FooBar repo: /Users/stefan/.julia/v0.6/FooBar\nINFO: Origin: git://github.com/StefanKarpinski/FooBar.jl.git\nINFO: Generating LICENSE.md\nINFO: Generating README.md\nINFO: Generating src/FooBar.jl\nINFO: Generating test/runtests.jl\nINFO: Generating REQUIRE\nINFO: Generating .travis.yml\nINFO: Generating appveyor.yml\nINFO: Generating .gitignore\nINFO: Committing FooBar generated filesEsto crea el directorio ~/.julia/v0.6/FooBar, lo inicializa como un repositorio de git, genera un grupo de archivos que todos los paquetes deben tener y los envía al repositorio:$ cd ~/.julia/v0.6/FooBar && git show --stat\n\ncommit 84b8e266dae6de30ab9703150b3bf771ec7b6285\nAuthor: Stefan Karpinski <stefan@karpinski.org>\nDate:   Wed Oct 16 17:57:58 2013 -0400\n\n    FooBar.jl generated files.\n\n        license: MIT\n        authors: Stefan Karpinski\n        years:   2013\n        user:    StefanKarpinski\n\n    Julia Version 0.3.0-prerelease+3217 [5fcfb13*]\n\n .gitignore       |  2 ++\n .travis.yml      | 13 +++++++++++++\n LICENSE.md       | 22 +++++++++++++++++++++++\n README.md        |  3 +++\n REQUIRE          |  1 +\n appveyor.yml     | 34 ++++++++++++++++++++++++++++++++++\n src/FooBar.jl    |  5 +++++\n test/runtests.jl |  5 +++++\n 8 files changed, 85 insertions(+)Por el momento, el administrador del paquete conoce la licencia \"Expat\" del MIT, indicada por \"MIT\", la licencia simplificada BSD, indicada por \"BSD\", y la versión 2.0 de la licencia del software Apache, indicada por \"ASL\". Si desea utilizar una licencia diferente, puede solicitarnos que la agreguemos al generador de paquetes, o simplemente seleccione una de estas tres y luego modifique el archivo ~/.julia/v0.6/PACKAGE/LICENSE.md después de haberlo generado.Si creó una cuenta de GitHub y configuró git para saber sobre ello, PkgDev.generate() establecerá una URL de origen adecuada para usted. También generará automáticamente un archivo .travis.yml para usar el servicio de prueba automatizado Travis, y un archivo appveyor.yml para usar AppVeyor. Deberá habilitar las pruebas en los sitios web de Travis y AppVeyor para su repositorio de paquetes, pero una vez que lo haya hecho, ya tendrá pruebas de funcionamiento. Por supuesto, todas las pruebas predeterminadas hacen es verificar que usando FooBar en Julia funciona."
},

{
    "location": "manual/packages.html#Cargando-ficheros-estáticos-No-Julia-1",
    "page": "Paquetes",
    "title": "Cargando ficheros estáticos No-Julia",
    "category": "section",
    "text": "Si su código de paquete necesita cargar archivos estáticos que no son código Julia, p. una biblioteca externa o archivos de datos, y se encuentran dentro del directorio del paquete, use la macro @__DIR__ para determinar el directorio del archivo fuente actual. Por ejemplo, si FooBar/src/FooBar.jl necesita cargar  FooBar/data/foo.csv, use el siguiente código:datapath = joinpath(@__DIR__, \"..\", \"data\")\nfoo = readcsv(joinpath(datapath, \"foo.csv\"))"
},

{
    "location": "manual/packages.html#Haciendo-Disponible-tu-Paquete-1",
    "page": "Paquetes",
    "title": "Haciendo Disponible tu Paquete",
    "category": "section",
    "text": "Una vez que haya realizado algunos commits y esté satisfecho con el funcionamiento de FooBar, es posible que desee conseguir que otras personas lo prueben. Primero tendrá que crear el repositorio remoto e insertar su código; todavía no hacemos esto automáticamente por usted, pero lo haremos en el futuro y no es demasiado difícil de entender [3]. Una vez que haya hecho esto, dejar que la gente pruebe su código es tan simple como enviarles la URL del repositorio publicado, en este caso:git://github.com/StefanKarpinski/FooBar.jl.gitPara su paquete, será su nombre de usuario GitHub y el nombre de su paquete, pero se entiende la idea. Las personas a las que envíes esta URL pueden usar Pkg.clone() para instalar el paquete y probarlo:julia> Pkg.clone(\"git://github.com/StefanKarpinski/FooBar.jl.git\")\nINFO: Cloning FooBar from git@github.com:StefanKarpinski/FooBar.jl.git[3]: Se recomienda encarecidamente instalar y usar la herramienta \"hub\" de GitHub.  Esta herramienta permite hacer cosas como ejecutar hub create en el repositorio del paquete y hacer que se  cree automáticamente a través de la API de GitHub."
},

{
    "location": "manual/packages.html#Tagging-and-Publishing-Your-Package-1",
    "page": "Paquetes",
    "title": "Tagging and Publishing Your Package",
    "category": "section",
    "text": "tip: Tip\nSi aloja su paquete en GitHub, puede usar la integración attobot  para gestionar el registro, etiquetado y publicación de paquetes.Una vez que haya decidido que FooBar está listo para registrarse como paquete oficial, puede agregarlo a su copia local deMETADATA usando PkgDev.register():julia> PkgDev.register(\"FooBar\")\nINFO: Registering FooBar at git://github.com/StefanKarpinski/FooBar.jl.git\nINFO: Committing METADATA for FooBarEsto crea un commit en el repositorio ~/.julia/v0.6/METADATA:$ cd ~/.julia/v0.6/METADATA && git show\n\ncommit 9f71f4becb05cadacb983c54a72eed744e5c019d\nAuthor: Stefan Karpinski <stefan@karpinski.org>\nDate:   Wed Oct 16 18:46:02 2013 -0400\n\n    Register FooBar\n\ndiff --git a/FooBar/url b/FooBar/url\nnew file mode 100644\nindex 0000000..30e525e\n--- /dev/null\n+++ b/FooBar/url\n@@ -0,0 +1 @@\n+git://github.com/StefanKarpinski/FooBar.jl.gitSin embargo, este compromiso sólo es visible localmente. Para que sea visible para la comunidad Julia, debe fusionar su METADATA local en el repositorio oficial. El comando PkgDev.publish() bifurca el repositorio METADATA en GitHub, inserta los cambios en su bifurcación, y abre una solicitud de extracción:julia> PkgDev.publish()\nINFO: Validating METADATA\nINFO: No new package versions to publish\nINFO: Submitting METADATA changes\nINFO: Forking JuliaLang/METADATA.jl to StefanKarpinski\nINFO: Pushing changes as branch pull-request/ef45f54b\nINFO: To create a pull-request open:\n\n  https://github.com/StefanKarpinski/METADATA.jl/compare/pull-request/ef45f54btip: Tip\nSi PkgDev.publish() falla con error:ERROR: key not found: \"token\"entonces puede que hayas encontrado un problema al usar la API de GitHub en múltiples sistemas. La solución es eliminar el token de acceso personal \"Julia Package Manager\" de tu cuenta Github e intentarlo de nuevo.Otros fallos pueden requerir que evites PkgDev.publish() al crear una solicitud de extracción en GitHub. Ver: Publicación de METADATA manualmente a continuación.Una vez que la URL del paquete para FooBar se registra en el repositorio oficial deMETADATA, las personas saben de dónde clonar el paquete, pero todavía no hay ninguna versión registrada disponible. Puede etiquetarlo y registrarlo con el comando PkgDev.tag():julia> PkgDev.tag(\"FooBar\")\nINFO: Tagging FooBar v0.0.1\nINFO: Committing METADATA for FooBarEsto etiqueta el reppositorio en FooBar con v0.0.1:$ cd ~/.julia/v0.6/FooBar && git tag\nv0.0.1También crea una nueva entrada de versión en su repositorio METADATA local paraFooBar:$ cd ~/.julia/v0.6/FooBar && git show\ncommit de77ee4dc0689b12c5e8b574aef7f70e8b311b0e\nAuthor: Stefan Karpinski <stefan@karpinski.org>\nDate:   Wed Oct 16 23:06:18 2013 -0400\n\n    Tag FooBar v0.0.1\n\ndiff --git a/FooBar/versions/0.0.1/sha1 b/FooBar/versions/0.0.1/sha1\nnew file mode 100644\nindex 0000000..c1cb1c1\n--- /dev/null\n+++ b/FooBar/versions/0.0.1/sha1\n@@ -0,0 +1 @@\n+84b8e266dae6de30ab9703150b3bf771ec7b6285El mandato PkgDev.tag() toma un segundo argumento opcional que es un objeto de número de versión explícito como v\"0.0.1\" o uno de los símbolos :patch,:minor o :major . Estos incrementan el parche, el número de versión menor o mayor de su paquete de forma inteligente.Agregar una versión etiquetada de su paquete agilizará el registro oficial en METADATA.jl por parte de los colaboradores. Se recomienda enfáticamente que complete este proceso, independientemente de si su paquete está completamente listo para una versión oficial.Como regla general, los paquetes deben etiquetarse como 0.0.1 primero. Como Julia no ha alcanzado el estado '1.0', es mejor ser conservador en las versiones etiquetadas de su paquete.Al igual que con PkgDev.register(), estos cambios en METADATA no están disponibles para nadie más hasta que se hayan incluido en la versión anterior. De nuevo, use el comando PkgDev.publish(), que primero se asegura de que los repos individuales de paquetes hayan sido etiquetados, los empuja si no han sido ya, y luego abre una solicitud de extracción a METADATA:julia> PkgDev.publish()\nINFO: Validating METADATA\nINFO: Pushing FooBar permanent tags: v0.0.1\nINFO: Submitting METADATA changes\nINFO: Forking JuliaLang/METADATA.jl to StefanKarpinski\nINFO: Pushing changes as branch pull-request/3ef4f5c4\nINFO: To create a pull-request open:\n\n  https://github.com/StefanKarpinski/METADATA.jl/compare/pull-request/3ef4f5c4"
},

{
    "location": "manual/packages.html#publishing-metadata-manually-1",
    "page": "Paquetes",
    "title": "Publishing METADATA manually",
    "category": "section",
    "text": "Si PkgDev.publish() falla, puede seguir estas instrucciones para publicar su paquete manualmente.Al \"bifurcar\" el repositorio principal de METADATA, puede crear una copia personal (de METADATA.jl) en su cuenta de GitHub. Una vez que existe esa copia, puede enviar sus cambios locales a su copia (al igual que cualquier otro proyecto de GitHub).Vaya a https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2FJuliaLang%2FMETADATA.jl%2Fforky cree su propia bifurcación.Agregue su bifurcación como un repositorio remoto para el repositorio METADATA en su computadora local (en la terminal donde USERNAME es su nombre de usuario github)::cd ~/.julia/v0.6/METADATA\ngit remote add USERNAME https://github.com/USERNAME/METADATA.jl.gitempuja tus cambios a tu bifurcación:\ngit push USERNAME metadata-v2\nSi todo eso funciona, regrese a la página de GitHub para su tenedor y haga clic en el enlace \"solicitar solicitud\"."
},

{
    "location": "manual/packages.html#Fixing-Package-Requirements-1",
    "page": "Paquetes",
    "title": "Fixing Package Requirements",
    "category": "section",
    "text": "Si necesita corregir los requisitos registrados de una versión de paquete ya publicada, puede hacerlo simplemente editando los metadatos de esa versión, que seguirá teniendo el mismo hash de confirmación: el hash asociado a una versión es permanente:$ cd ~/.julia/v0.6/METADATA/FooBar/versions/0.0.1 && cat requires\njulia 0.3-\n$ vi requiresComo el hash de confirmación (commit) permanece igual, el contenido del archivo REQUIRE que se retirará en el repositorio no coincidirá con los requisitos en METADATA después de dicho cambio; esto es inevitable. Sin embargo, cuando se fijan los requisitos en METADATA para una versión anterior de un paquete, también se debe corregir el archivoREQUIRE en la versión actual del paquete."
},

{
    "location": "manual/packages.html#requirements-specification-1",
    "page": "Paquetes",
    "title": "Especificación de Requisitos",
    "category": "section",
    "text": "El archivo ~/.julia/v0.6/REQUIRE, el archivoREQUIRE dentro de los paquetes y los archivos require del paquete METADATA utilizan un formato simple basado en línea para expresar los rangos de las versiones del paquete que necesitan estar instalados. Los archivos REQUIRE y METADATA requires también deben incluir el rango de versiones de julia con las que se espera que funcione el paquete. Además, los paquetes pueden incluir un archivo test/REQUIRE para especificar paquetes adicionales que solo son necesarios para la prueba.Así es cómo se analizan e interpretan estos archivos.Todo lo que haya después de que una marca # se elimina de cada línea como un comentario.\nSi solo queda espacio en blanco, la línea se ignorará.\nSi quedan caracteres que no sean espacios en blanco, la línea es un requisito y el espacio en blanco se  divide en palabras.El requisito más simple posible es simplemente el nombre del nombre de un paquete en una línea por sí mismo:DistributionsEste requisito se satisface con cualquier versión del paquete Distributions. El nombre del paquete puede ir seguido de cero o más números de versión en orden ascendente, lo que indica intervalos aceptables de versiones de ese paquete. Una versión abre un intervalo, la siguiente la cierra y la siguiente abre un nuevo intervalo, y así sucesivamente; si se da un número impar de números de versión, las versiones arbitrariamente grandes satisfarán; si se proporciona un número par de números de versión, el último es un límite superior para los números de versión aceptables. Por ejemplo, la línea:Distributions 0.1se satisface con cualquier versión de Distribuciones superior o igual a0.1.0. El sufijo de una versión con - también permite versiones preliminares. Por ejemplo:Distributions 0.1-se satisface con las versiones preliminares tales como 0.1-dev o0.1-rc1, o con cualquier versión mayor o igual a 0.1.0.Esta entrada de requisito:Distributions 0.1 0.2.5se satisface con versiones desde '0.1.0' hasta, pero sin incluir, '0.2.5'. Si quiere indicar que cualquier versión de 0.1.x va a funcionar, querrá escribir:Distributions 0.1 0.2-If you want to start accepting versions after 0.2.7, you can write:Distributions 0.1 0.2- 0.2.7Si una línea de requisitos tiene palabras iniciales que comienzan con @, es un requisito dependiente del sistema. Si su sistema coincide con estos condicionales del sistema, se incluye el requisito, de lo contrario, se ignora el requisito. Por ejemplo:@osx Homebrewrequerirá el paquete Homebrew solo en los sistemas donde el sistema operativo es OS X. Las condiciones del sistema que actualmente son compatibles son (jerárquicamente):@unix\n@linux\n@bsd\n@osx\n@windowsLa condición @unix se cumple en todos los sistemas UNIX, incluidos Linux y BSD. Los condicionales de sistema negados también son compatibles al agregar un ! Después del @ inicial. Ejemplos:@!windows\n@unix @!osxLa primera condición se aplica a cualquier sistema excepto Windows y la segunda condición se aplica a cualquier sistema UNIX además de OS X.Los controles de tiempo de ejecución para la versión actual de Julia se pueden realizar utilizando la variable incorporada VERSION, que es de tipo VersionNumber. Dicho código ocasionalmente es necesario para realizar un seguimiento de la funcionalidad nueva o obsoleta entre varias versiones de Julia. Ejemplos de controles de tiempo de ejecución:VERSION < v\"0.3-\" #exclude all pre-release versions of 0.3\n\nv\"0.2-\" <= VERSION < v\"0.3-\" #get all 0.2 versions, including pre-releases, up to the above\n\nv\"0.2\" <= VERSION < v\"0.3-\" #To get only stable 0.2 versions (Note v\"0.2\" == v\"0.2.0\")\n\nVERSION >= v\"0.2.1\" #get at least version 0.2.1See the section on version number literals for a more complete description."
},

{
    "location": "manual/profile.html#",
    "page": "Elaboración de Perfiles (Profiling)",
    "title": "Elaboración de Perfiles (Profiling)",
    "category": "page",
    "text": ""
},

{
    "location": "manual/profile.html#profiling-1",
    "page": "Elaboración de Perfiles (Profiling)",
    "title": "Elaboración de Perfiles (Profiling)",
    "category": "section",
    "text": "El módulo Profile proporciona herramientas para ayudar a los desarrolladores a mejorar el rendimiento de su código. Cuando se usa, toma medidas de código en ejecución y produce resultados que lo ayudan a comprender cuánto tiempo se gasta en línea(s) individual(es). El uso más común es identificar \"cuellos de botella\" como objetivos para la optimización.Profile implementa lo que se conoce como \"sampling\" o profiler estadístico. Funciona periódicamente tomando una traza inversa durante la ejecución de cualquier tarea. Cada traz inversa captura la función que se está ejecutando actualmente y el número de línea, más la cadena completa de llamadas a función que llevó a esta línea, y por lo tanto es una \"instantánea\" del estado actual de ejecución.Si se gasta una gran parte de su tiempo de ejecución al ejecutar una línea particular de código, esta línea aparecerá con frecuencia en el conjunto de todas las trazas inversas. En otras palabras, el \"costo\" de una línea determinada -o, en realidad, el costo de la secuencia de llamadas de función hasta e incluyendo esta línea- es proporcional a la frecuencia con que aparece en el conjunto de todas las trazas inversas.Un generador de perfiles de muestreo (sampling profiler) no proporciona una cobertura completa línea por línea, porque las trazas inversas se producen a intervalos (por defecto, 1 ms en sistemas Unix y 10 ms en Windows, aunque la programación real está sujeta a la carga del sistema operativo). Además, como se analiza más adelante, como las muestras se recogen en un subconjunto disperso de todos los puntos de ejecución, los datos recopilados por un generador de perfiles de muestreo están sujetos a ruido estadístico.A pesar de estas limitaciones, los perfiles de muestreo tienen fortalezas sustanciales:No tiene que hacer ninguna modificación en su código para tomar medidas de temporización (en contraste con la alternativa instrumenting profiler).  Puede perfilarse en el código central de Julia e incluso (opcionalmente) en las bibliotecas C y Fortran.\nAl ejecutarse \"con poca frecuencia\", hay muy poca sobrecarga de rendimiento; durante el perfilado,  su código puede ejecutarse a una velocidad casi nativa.Por estas razones, se recomienda que intente utilizar el generador de perfiles de muestreo incorporado antes de considerar cualquier alternativa."
},

{
    "location": "manual/profile.html#Uso-básico-1",
    "page": "Elaboración de Perfiles (Profiling)",
    "title": "Uso básico",
    "category": "section",
    "text": "Trabajemos con un simple caso de test:julia> function myfunc()\n           A = rand(200, 200, 400)\n           maximum(A)\n       endEs buena idea ejecutar primero el código que se intenta analizar al menos una vez (a menos que uno quiera analizar el compilador JIT de Julia):julia> myfunc() # run once to force compilationAhora estamos listos para analizar esta función:julia> @profile myfunc()Para ver los resultados del profiler hay disponible un navegador gráfico, pero aquí usaremos la pantalla basada en texto que viene con la librería estándar:julia> Profile.print()\n80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n 80 ./REPL.jl:97; macro expansion\n  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)\n   80 ./boot.jl:235; eval(::Module, ::Any)\n    80 ./<missing>:?; anonymous\n     80 ./profile.jl:23; macro expansion\n      52 ./REPL[1]:2; myfunc()\n       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...\n        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...\n       14 ./random.jl:278; rand\n        14 ./random.jl:277; rand\n         14 ./random.jl:366; rand\n          14 ./random.jl:369; rand\n      28 ./REPL[1]:3; myfunc()\n       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...\n        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...Cada línea de esta pantalla representa un punto particular (número de línea) en el código. La sangría se usa para indicar la secuencia anidada de llamadas a funciones, con líneas más sangradas que son más profundas en la secuencia de llamadas. En cada línea, el primer \"campo\" es el número de trazas inversas (muestras) tomadas en esta línea o en cualquier función ejecutada por esta línea. El segundo campo es el nombre del archivo y el número de línea, y el tercer campo es el nombre de la función. Tenga en cuenta que los números de línea específicos pueden cambiar como los cambios de código de Julia; si quieres seguir, es mejor que ejecutes este ejemplo tú mismo.En este ejemplo, podemos ver que la función de nivel superior llamada está en el archivo event.jl. Esta es la función que ejecuta REPL cuando se lanza Julia. Si se examina la línea 97 de REPL.jl, verá que aquí es donde se llama a la función eval_user_input(). Esta es la función que evalúa lo que escribes en el REPL, y dado que estamos trabajando de forma interactiva estas funciones se invocaron cuando ingresamos @profile myfunc(). La siguiente línea refleja las acciones tomadas en la macro @ profile.La primera línea muestra que se tomaron 80 trazas inversas en la línea 73 de event.jl, pero no es que esta línea fuera \"costosa\" por sí misma: la tercera línea revela que las 80 trazas inversas se desencadenaron dentro de su llamada a eval_user_input, y así sucesivamente. Para averiguar qué operaciones se están tomando realmente el tiempo, necesitamos buscar más profundamente en la cadena de llamadas.La primera línea \"importante\" en esta salida es esta:52 ./REPL[1]:2; myfunc()REPL se refiere al hecho de que definimosmyfunc en REPL, en lugar de ponerlo en un archivo; si hubiéramos usado un archivo, esto mostraría el nombre del archivo. El [1] muestra que la función myfunc fue la primera expresión evaluada en esta sesión REPL. La línea 2 de myfunc() contiene la llamada a rand, y hubo 52 (de 80) trazas inversas que ocurrieron en esta línea. Debajo de eso, puede ver una llamada a dsfmt_fill_array_close_open! Dentro de dSFMT.jl.Un poco más abajo, ves:28 ./REPL[1]:3; myfunc()La línea 3 de myfunc contiene la llamada amaximum, y hubo 28 (de 80) trazas inversas tomadas aquí. Debajo de eso, puede ver los lugares específicos en base/reduce.jl que llevan a cabo las operaciones que consumen mucho tiempo en la funciónmaximum para este tipo de datos de entrada.En general, podemos concluir tentativamente que generar los números aleatorios es aproximadamente el doble de costoso que encontrar el elemento máximo. Podríamos aumentar nuestra confianza en este resultado recopilando más muestras:julia> @profile (for i = 1:100; myfunc(); end)\n\njulia> Profile.print()\n[....]\n 3821 ./REPL[1]:2; myfunc()\n  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...\n   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...\n  310  ./random.jl:278; rand\n   [....]\n 2893 ./REPL[1]:3; myfunc()\n  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...\n   [....]En general, si tiene N muestras recopiladas en una línea, puede esperar una incertidumbre en el orden de sqrt(N) (excluyendo otras fuentes de ruido, como cuán ocupada está la computadora con otras tareas). La principal excepción a esta regla es la recolección de basura, que se ejecuta con poca frecuencia pero tiende a ser bastante costosa. (Dado que el recolector de basura de Julia está escrito en C, tales eventos pueden ser detectados usando el modo de salida C = true descrito a continuación, o usando ProfileView.jl.)Esto ilustra el volcado de \"árbol\" predeterminado; una alternativa es el volcado \"plano\", que acumula conteos independientemente de su anidación:julia> Profile.print(format=:flat)\n Count File          Line Function\n  6714 ./<missing>     -1 anonymous\n  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)\n  6714 ./REPL.jl       97 macro expansion\n  3821 ./REPL[1]        2 myfunc()\n  2893 ./REPL[1]        3 myfunc()\n  6714 ./REPL[7]        1 macro expansion\n  6714 ./boot.jl      235 eval(::Module, ::Any)\n  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...\n  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n  6714 ./profile.jl    23 macro expansion\n  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...\n   310 ./random.jl    277 rand\n   310 ./random.jl    278 rand\n   310 ./random.jl    366 rand\n   310 ./random.jl    369 rand\n  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...\n     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...Si nuestro código tiene recursión, un punto potencialmente confso es que una línea en una función \"hija\" puede acumular ms cuentas que hay de trazas inversas en total.Considere las siguientes definiciones de función:dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)\ndumbsum3() = dumbsum(3)Si tuviéramos que analizar  dumbsum3, y una traza inversa fuera tomada mientras estaba ejecutándose dumbsum(1), la traza inversa tendría este aspecto:dumbsum3\n    dumbsum(3)\n        dumbsum(2)\n            dumbsum(1)En consecuencia, esta función hija realiza tres cuentas incluso aunque la padre sólo realiza una. La representación en \"árbol\" hace esto mucho ms claro, y por esta razón (entre otras) es probablemente la forma más útil de ver los resultados."
},

{
    "location": "manual/profile.html#Acumulación-y-Limpieza-1",
    "page": "Elaboración de Perfiles (Profiling)",
    "title": "Acumulación y Limpieza",
    "category": "section",
    "text": "Los resultados de @profile se acumulan en un buffer; si ejecuta varios fragmentos de código en @profile, entonces Profile.print() le mostrará los resultados combinados. Esto puede ser muy útil, pero a veces desea comenzar de nuevo; puede hacerlo con Profile.clear()."
},

{
    "location": "manual/profile.html#Opciones-para-controlar-la-visión-de-los-resultados-del-análisis-1",
    "page": "Elaboración de Perfiles (Profiling)",
    "title": "Opciones para controlar la visión de los resultados del análisis",
    "category": "section",
    "text": "Profile.print() tienes más opciones de las que se han descrito hasta ahora. Veamos la declaración completa:function print(io::IO = STDOUT, data = fetch(); kwargs...)Primero discutamos los dos argumentos posicionales, y luego los argumentos keyword:io – Le permite guardar los resultados en un búfer, por ejemplo, un archivo, pero el predeterminado es  imprimir en STDOUT (la consola)..\ndata – Contiene los datos que desea analizar; de forma predeterminada, se obtiene de Profile.fetch(),  que extrae trazas inversas de un búfer preasignado. Por ejemplo, si desea perfilar el generador de perfiles,  podría decir:\ndata = copy(Profile.fetch())\nProfile.clear()\n@profile Profile.print(STDOUT, data) # Prints the previous results\nProfile.print()                      # Prints results from Profile.print()The argumentos keyword pueden ser cualquier combinación de:format – Introducido anteriormente, determina si se imprimen trazas inversas con (por defecto, : árbol)    o sin (: plano) indentación que indica la estructura en árbol.C – Sitrue, se muestran trazas inversas de C y Fortran (normalmente están excluidas). Intente ejecutar  el ejemplo introductorio con Profile.print(C = true). Esto puede ser extremadamente útil para decidir si  es el código Julia o el código C lo que está causando un cuello de botella; establecer C = true también    mejora la interpretabilidad del anidamiento, a coste de unos listados de perfil más largos. combine – Algunas líneas de código contienen múltiples operaciones; por ejemplo, s + = A [i] contiene  una referencia de matriz (A[i]) y una operación de suma. Estos corresponden a diferentes líneas en el  código máquina generado, y por lo tanto puede haber dos o más direcciones diferentes capturadas durante  las trazas inversas en esta línea. combine = true los agrupa, y es probablemente lo que generalmente  desea, pero puede generar un resultado por separado para cada puntero de instrucción concombine = false.\nmaxdepth – Limita los marcos a una profundidad mayor quemaxdepth en el formato :tree.\nsortedby – Controla el orden en formato :flat. :filefuncline (predeterminado) ordena por la línea  de origen, mientras que :count se ordena según el número de muestras recolectadas.\nnoisefloor – Límita los marcos que están debajo del umbral de ruido heurístico de la muestra (solo se aplica al formato: tree). Un valor sugerido para intentar esto es 2.0 (el valor predeterminado es 0). Este parámetro  oculta muestras para las cuales n <= noisefloor * √N, donden es el número de muestras en esta línea, y    N es el número de muestras para el método invocado.mincount – Limita marcos con menos de mincount ocurrencias.Los nombres de archivo/función a veces se truncan (con ...), y la sangría se trunca con un +n al principio, donde n es el número de espacios adicionales que se habrían insertado, si hubiera habido espacio . Si desea un perfil completo de código profundamente anidado, a menudo una buena idea es guardar en un archivo usando un ancho \"tamaño de pantalla\" en un IOContext:open(\"/tmp/prof.txt\", \"w\") do s\n    Profile.print(IOContext(s, :displaysize => (24, 500)))\nend"
},

{
    "location": "manual/profile.html#Configuración-1",
    "page": "Elaboración de Perfiles (Profiling)",
    "title": "Configuración",
    "category": "section",
    "text": "@ profile solo acumula backtraces, y el análisis ocurre cuando usted llama a Profile.print(). Para un cálculo de larga ejecución, es muy posible que se llene el búfer preasignado para almacenar backtraces. Si eso sucede, las trazas inversas se detienen pero su cálculo continúa. Como consecuencia, es posible que omitan algunos datos importantes de generación de perfiles (recibirá una advertencia cuando eso suceda).Puede obtener y configurar los parámetros relevantes de esta manera:Profile.init() # returns the current settings\nProfile.init(n = 10^7, delay = 0.01)n es la cantidad total de punteros de instrucción que puede almacenar, con un valor predeterminado de 10 ^ 6. Si su traza inversa típica es de 20 punteros de instrucción, puede recopilar 50000 trazas inversas, lo que sugiere una incertidumbre estadística de menos del 1%. Esto puede ser lo suficientemente bueno para la mayoría de las aplicaciones.En consecuencia, es más probable que necesite modificar el retraso, expresado en segundos, que establece la cantidad de tiempo que Julia obtiene entre las instantáneas para realizar los cálculos solicitados. Un trabajo de larga duración puede no necesitar trazas frecuentes. La configuración predeterminada es delay = 0.001. Por supuesto, puede disminuir la demora y aumentarla; sin embargo, la sobrecarga de los perfiles crece una vez que la demora se vuelve similar a la cantidad de tiempo necesaria para tomar una traza inversa (~ 30 microsegundos en la computadora portátil del autor)."
},

{
    "location": "manual/profile.html#memory-allocation-analysis-1",
    "page": "Elaboración de Perfiles (Profiling)",
    "title": "Análisis de la asignación de memoria",
    "category": "section",
    "text": "Una de las técnicas más comunes para mejorar el rendimiento es reducir la asignación de memoria. La cantidad total de  asignación se puede medir con @time y @allocated, y las líneas específicas que desencadenan la asignación a  pueden a menudo inferirse a partir del perfil a través del costo de la recolección de basura en la que incurren estas líneas. Sin embargo, a veces es más eficiente medir directamente la cantidad de memoria asignada por cada línea de código.Para medir la asignación línea por línea, inicie Julia con la opción de línea de comando --track-allocation = <setting>, para la cual puede elegir none (el predeterminado, no medir la asignación), user (mida la asignación de memoria en todas partes excepto el código central de Julia), o todo (mida la asignación de memoria en cada línea del código Julia). La asignación se mide para cada línea de código compilado. Cuando sale de Julia, los resultados acumulativos se escriben en archivos de texto con .mem adjunto después del nombre del archivo, que residen en el mismo directorio que el archivo de origen. Cada línea enumera la cantidad total de bytes asignados. El paquete Coverage contiene algunas herramientas de análisis elementales, por ejemplo, para ordenar las líneas en orden de cantidad de bytes asignados.Al interpretar los resultados, hay algunos detalles importantes. Bajo la configuración user, la primera línea de cualquier función directamente llamada desde REPL exhibirá asignación debido a eventos que ocurren en el código REPL. Más significativamente, la compilación de JIT también se suma a los recuentos de asignación, porque gran parte del compilador de Julia está escrito en Julia (y la compilación generalmente requiere asignación de memoria). El procedimiento recomendado es forzar la compilación ejecutando todos los comandos que desea analizar, luego llame a Profile.clear_malloc_data() para restablecer todos los contadores de asignación. Finalmente, ejecute los comandos deseados y salga de Julia para activar la generación de los archivos .mem."
},

{
    "location": "manual/stacktraces.html#",
    "page": "Trazas de Pila",
    "title": "Trazas de Pila",
    "category": "page",
    "text": ""
},

{
    "location": "manual/stacktraces.html#stacktraces-1",
    "page": "Trazas de Pila",
    "title": "Trazas de Pila",
    "category": "section",
    "text": "El módulo StackTraces proporciona simples seguimientos de pila que son legibles para los humanos y fáciles de usar mediante programación."
},

{
    "location": "manual/stacktraces.html#Viendo-un-rastro-de-pila-1",
    "page": "Trazas de Pila",
    "title": "Viendo un rastro de pila",
    "category": "section",
    "text": "La función principal utilizada para obtener un seguimiento de pila es stacktrace():julia> stacktrace()\n4-element Array{StackFrame,1}:\n eval(::Module, ::Any) at boot.jl:236\n eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66\n macro expansion at REPL.jl:97 [inlined]\n (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73Llamar a stacktrace() devuelve un vector de StackFrames. Para facilitar el uso, el alias StackTrace se puede usar en lugar de Vector{StackFrame}. (Los ejemplos con [...] indican que la salida puede variar dependiendo de cómo se ejecuta el código).julia> example() = stacktrace()\nexample (generic function with 1 method)\n\njulia> example()\n5-element Array{StackFrame,1}:\n example() at REPL[1]:1\n eval(::Module, ::Any) at boot.jl:236\n[...]\n\njulia> @noinline child() = stacktrace()\nchild (generic function with 1 method)\n\njulia> @noinline parent() = child()\nparent (generic function with 1 method)\n\njulia> grandparent() = parent()\ngrandparent (generic function with 1 method)\n\njulia> grandparent()\n7-element Array{StackFrame,1}:\n child() at REPL[3]:1\n parent() at REPL[4]:1\n grandparent() at REPL[5]:1\n[...]Tenga en cuenta que cuando llama a stacktrace() normalmente verá un marco con eval (...) en boot.jl. Al invocar stacktrace() desde el REPL, también tendrá algunos fotogramas adicionales en la pila de REPL.jl, que generalmente se ve así:julia> example() = stacktrace()\nexample (generic function with 1 method)\n\njulia> example()\n5-element Array{StackFrame,1}:\n example() at REPL[1]:1\n eval(::Module, ::Any) at boot.jl:236\n eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66\n macro expansion at REPL.jl:97 [inlined]\n (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73"
},

{
    "location": "manual/stacktraces.html#Extracting-useful-information-1",
    "page": "Trazas de Pila",
    "title": "Extracting useful information",
    "category": "section",
    "text": "Cada StackFrame contiene el nombre de la función, el nombre del archivo, el número de línea, la información lambda, un indicador que indica si el marco ha sido insertado, un indicador que indica si es una función C (por defecto las funciones C no aparecen en el seguimiento de la pila) y una representación entera del puntero devuelto por backtrace():julia> top_frame = stacktrace()[1]\neval(::Module, ::Any) at boot.jl:236\n\njulia> top_frame.func\n:eval\n\njulia> top_frame.file\nSymbol(\"./boot.jl\")\n\njulia> top_frame.line\n236\n\njulia> top_frame.linfo\nNullable{Core.MethodInstance}(MethodInstance for eval(::Module, ::Any))\n\njulia> top_frame.inlined\nfalse\n\njulia> top_frame.from_c\nfalsejulia> top_frame.pointer\n0x00007f390d152a59Esto hace que la información de seguimiento de pila esté disponible programáticamente para el registro, el manejo de errores y más."
},

{
    "location": "manual/stacktraces.html#Manejo-de-Errores-1",
    "page": "Trazas de Pila",
    "title": "Manejo de Errores",
    "category": "section",
    "text": "Si bien tener acceso fácil a la información sobre el estado actual de la pila de llamadas puede ser útil en muchos lugares, la aplicación más obvia es la gestión de errores y la depuración.julia> @noinline bad_function() = undeclared_variable\nbad_function (generic function with 1 method)\n\njulia> @noinline example() = try\n           bad_function()\n       catch\n           stacktrace()\n       end\nexample (generic function with 1 method)\n\njulia> example()\n5-element Array{StackFrame,1}:\n example() at REPL[2]:4\n eval(::Module, ::Any) at boot.jl:236\n[...]Puede observar que en el ejemplo anterior, el primer marco apila puntos en la línea 4, donde se llama a stacktrace(), en lugar de a la línea 2, donde se llama bad_function y el marco de bad_function falta por completo. Esto es comprensible, dado que stacktrace() se llama desde el contexto de catch. Si bien en este ejemplo es bastante fácil encontrar el origen real del error, en casos complejos, rastrear el origen del error no es trivial.Esto se puede remediar llamando a catch_stacktrace() en lugar de stacktrace(). En lugar de devolver la información de la pila de llamadas para el contexto actual, catch_stacktrace() devuelve la información de la pila para el contexto de la excepción más reciente:julia> @noinline bad_function() = undeclared_variable\nbad_function (generic function with 1 method)\n\njulia> @noinline example() = try\n           bad_function()\n       catch\n           catch_stacktrace()\n       end\nexample (generic function with 1 method)\n\njulia> example()\n6-element Array{StackFrame,1}:\n bad_function() at REPL[1]:1\n example() at REPL[2]:2\n[...]Nótese que la traza de la pila indica ahora el número de línea apropiado y el marco perdido.julia> @noinline child() = error(\"Whoops!\")\nchild (generic function with 1 method)\n\njulia> @noinline parent() = child()\nparent (generic function with 1 method)\n\njulia> @noinline function grandparent()\n           try\n               parent()\n           catch err\n               println(\"ERROR: \", err.msg)\n               catch_stacktrace()\n           end\n       end\ngrandparent (generic function with 1 method)\n\njulia> grandparent()\nERROR: Whoops!\n7-element Array{StackFrame,1}:\n child() at REPL[1]:1\n parent() at REPL[2]:1\n grandparent() at REPL[3]:3\n[...]"
},

{
    "location": "manual/stacktraces.html#Comparación-con-[backtrace()](@ref)-1",
    "page": "Trazas de Pila",
    "title": "Comparación con backtrace()",
    "category": "section",
    "text": "Una llamada a backtrace() devuelve un vector de Ptr{Void}, que puede pasarse luego a stacktrace() para la traducción:julia> trace = backtrace()\n21-element Array{Ptr{Void},1}:\n Ptr{Void} @0x00007f10049d5b2f\n Ptr{Void} @0x00007f0ffeb4d29c\n Ptr{Void} @0x00007f0ffeb4d2a9\n Ptr{Void} @0x00007f1004993fe7\n Ptr{Void} @0x00007f10049a92be\n Ptr{Void} @0x00007f10049a823a\n Ptr{Void} @0x00007f10049a9fb0\n Ptr{Void} @0x00007f10049aa718\n Ptr{Void} @0x00007f10049c0d5e\n Ptr{Void} @0x00007f10049a3286\n Ptr{Void} @0x00007f0ffe9ba3ba\n Ptr{Void} @0x00007f0ffe9ba3d0\n Ptr{Void} @0x00007f1004993fe7\n Ptr{Void} @0x00007f0ded34583d\n Ptr{Void} @0x00007f0ded345a87\n Ptr{Void} @0x00007f1004993fe7\n Ptr{Void} @0x00007f0ded34308f\n Ptr{Void} @0x00007f0ded343320\n Ptr{Void} @0x00007f1004993fe7\n Ptr{Void} @0x00007f10049aeb67\n Ptr{Void} @0x0000000000000000\n\njulia> stacktrace(trace)\n5-element Array{StackFrame,1}:\n backtrace() at error.jl:46\n eval(::Module, ::Any) at boot.jl:236\n eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66\n macro expansion at REPL.jl:97 [inlined]\n (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73Observe que el vector devuelto por backtrace() tenía 21 punteros, mientras que el vector devuelto por stacktrace() solo tiene 5. Esto es porque, de forma predeterminada, stacktrace() elimina cualquier función C de nivel inferior de la pila. Si desea incluir cuadros de pila de llamadas C, puede hacerlo así:julia> stacktrace(trace, true)\n27-element Array{StackFrame,1}:\n jl_backtrace_from_here at stackwalk.c:103\n backtrace() at error.jl:46\n backtrace() at sys.so:?\n jl_call_method_internal at julia_internal.h:248 [inlined]\n jl_apply_generic at gf.c:2215\n do_call at interpreter.c:75\n eval at interpreter.c:215\n eval_body at interpreter.c:519\n jl_interpret_toplevel_thunk at interpreter.c:664\n jl_toplevel_eval_flex at toplevel.c:592\n jl_toplevel_eval_in at builtins.c:614\n eval(::Module, ::Any) at boot.jl:236\n eval(::Module, ::Any) at sys.so:?\n jl_call_method_internal at julia_internal.h:248 [inlined]\n jl_apply_generic at gf.c:2215\n eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66\n ip:0x7f1c707f1846\n jl_call_method_internal at julia_internal.h:248 [inlined]\n jl_apply_generic at gf.c:2215\n macro expansion at REPL.jl:97 [inlined]\n (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73\n ip:0x7f1c707ea1ef\n jl_call_method_internal at julia_internal.h:248 [inlined]\n jl_apply_generic at gf.c:2215\n jl_apply at julia.h:1411 [inlined]\n start_task at task.c:261\n ip:0xffffffffffffffffLos punteros individuales devueltos por backtrace() se pueden traducir a StackFrame s pasándolos a StackTraces.lookup():julia> pointer = backtrace()[1];\n\njulia> frame = StackTraces.lookup(pointer)\n1-element Array{StackFrame,1}:\n jl_backtrace_from_here at stackwalk.c:103\n\njulia> println(\"The top frame is from $(frame[1].func)!\")\nThe top frame is from jl_backtrace_from_here!"
},

{
    "location": "manual/performance-tips.html#",
    "page": "Performance Tips",
    "title": "Performance Tips",
    "category": "page",
    "text": ""
},

{
    "location": "manual/performance-tips.html#man-performance-tips-1",
    "page": "Performance Tips",
    "title": "Performance Tips",
    "category": "section",
    "text": "In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible."
},

{
    "location": "manual/performance-tips.html#Avoid-global-variables-1",
    "page": "Performance Tips",
    "title": "Avoid global variables",
    "category": "section",
    "text": "A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.Any code that is performance critical or being benchmarked should be inside a function.We find that global names are frequently constants, and declaring them as such greatly improves performance:const DEFAULT_VAL = 0Uses of non-constant globals can be optimized by annotating their types at the point of use:global x\ny = f(x::Int + 1)Writing functions is better style. It leads to more reusable code and clarifies what steps are being done, and what their inputs and outputs are.note: Note\nAll code in the REPL is evaluated in global scope, so a variable defined and assigned at toplevel will be a global variable.In the following REPL session:julia> x = 1.0is equivalent to:julia> global x = 1.0so all the performance issues discussed previously apply."
},

{
    "location": "manual/performance-tips.html#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation-1",
    "page": "Performance Tips",
    "title": "Measure performance with @time and pay attention to memory allocation",
    "category": "section",
    "text": "A useful tool for measuring performance is the @time macro. The following example illustrates good working style:julia> function f(n)\n           s = 0\n           for i = 1:n\n               s += i/2\n           end\n           s\n       end\nf (generic function with 1 method)\n\njulia> @time f(1)\n  0.012686 seconds (2.09 k allocations: 103.421 KiB)\n0.5\n\njulia> @time f(10^6)\n  0.021061 seconds (3.00 M allocations: 45.777 MiB, 11.69% gc time)\n2.5000025e11On the first call (@time f(1)), f gets compiled.  (If you've not yet used @time in this session, it will also compile functions needed for timing.)  You should not take the results of this run seriously. For the second run, note that in addition to reporting the time, it also indicated that a large amount of memory was allocated. This is the single biggest advantage of @time vs. functions like tic() and toc(), which only report time.Unexpected memory allocation is almost always a sign of some problem with your code, usually a problem with type-stability. Consequently, in addition to the allocation itself, it's very likely that the code generated for your function is far from optimal. Take such indications seriously and follow the advice below.For more serious benchmarking, consider the BenchmarkTools.jl package which evaluates the function multiple times in order to reduce noise.As a teaser, an improved version of this function allocates no memory (the allocation reported below is due to running the @time macro in global scope) and has an order of magnitude faster execution after the first call:julia> @time f_improved(1)\n  0.007008 seconds (1.32 k allocations: 63.640 KiB)\n0.5\n\njulia> @time f_improved(10^6)\n  0.002997 seconds (6 allocations: 192 bytes)\n2.5000025e11Below you'll learn how to spot the problem with f and how to fix it.In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the tools below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see Pre-allocating outputs)."
},

{
    "location": "manual/performance-tips.html#tools-1",
    "page": "Performance Tips",
    "title": "Tools",
    "category": "section",
    "text": "Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:Profiling allows you to measure the performance of your running code and identify lines that serve as bottlenecks.  For complex projects, the ProfileView package can help you visualize your profiling results.\nUnexpectedly-large memory allocations–as reported by @time, @allocated, or the profiler (through calls to the garbage-collection routines)–hint that there might be issues with your code.  If you don't see another reason for the allocations, suspect a type problem.  You can also start Julia with the --track-allocation=user option and examine the resulting *.mem files to see information about where those allocations occur.  See Memory allocation analysis.\n@code_warntype generates a representation of your code that can be helpful in finding expressions that result in type uncertainty. See @code_warntype below.\nThe Lint package can also warn you of certain types of programming errors."
},

{
    "location": "manual/performance-tips.html#Avoid-containers-with-abstract-type-parameters-1",
    "page": "Performance Tips",
    "title": "Avoid containers with abstract type parameters",
    "category": "section",
    "text": "When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible.Consider the following:a = Real[]    # typeof(a) = Array{Real,1}\nif (f = rand()) < .8\n    push!(a, f)\nendBecause a is a an array of abstract type Real, it must be able to hold any Real value.  Since Real objects can be of arbitrary size and structure, a must be represented as an array of pointers to individually allocated Real objects. Because f will always be a Float64, we should instead, use:a = Float64[] # typeof(a) = Array{Float64,1}which will create a contiguous block of 64-bit floating-point values that can be manipulated efficiently.See also the discussion under Parametric Types."
},

{
    "location": "manual/performance-tips.html#Type-declarations-1",
    "page": "Performance Tips",
    "title": "Type declarations",
    "category": "section",
    "text": "In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is not the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful."
},

{
    "location": "manual/performance-tips.html#Avoid-fields-with-abstract-type-1",
    "page": "Performance Tips",
    "title": "Avoid fields with abstract type",
    "category": "section",
    "text": "Types can be declared without specifying the types of their fields:julia> struct MyAmbiguousType\n           a\n       endThis allows a to be of any type. This can often be useful, but it does have a downside: for objects of type MyAmbiguousType, the compiler will not be able to generate high-performance code.  The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type MyAmbiguousType:julia> b = MyAmbiguousType(\"Hello\")\nMyAmbiguousType(\"Hello\")\n\njulia> c = MyAmbiguousType(17)\nMyAmbiguousType(17)\n\njulia> typeof(b)\nMyAmbiguousType\n\njulia> typeof(c)\nMyAmbiguousTypeb and c have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field a, the fact that the memory representation of a UInt8 differs from a Float64 also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.You can do better by declaring the type of a. Here, we are focused on the case where a might be any one of several types, in which case the natural solution is to use parameters. For example:julia> mutable struct MyType{T<:AbstractFloat}\n           a::T\n       endThis is a better choice thanjulia> mutable struct MyStillAmbiguousType\n           a::AbstractFloat\n       endbecause the first version specifies the type of a from the type of the wrapper object.  For example:julia> m = MyType(3.2)\nMyType{Float64}(3.2)\n\njulia> t = MyStillAmbiguousType(3.2)\nMyStillAmbiguousType(3.2)\n\njulia> typeof(m)\nMyType{Float64}\n\njulia> typeof(t)\nMyStillAmbiguousTypeThe type of field a can be readily determined from the type of m, but not from the type of t.  Indeed, in t it's possible to change the type of field a:julia> typeof(t.a)\nFloat64\n\njulia> t.a = 4.5f0\n4.5f0\n\njulia> typeof(t.a)\nFloat32In contrast, once m is constructed, the type of m.a cannot change:julia> m.a = 4.5f0\n4.5f0\n\njulia> typeof(m.a)\nFloat64The fact that the type of m.a is known from m's type–coupled with the fact that its type cannot change mid-function–allows the compiler to generate highly-optimized code for objects like m but not for objects like t.Of course, all of this is true only if we construct m with a concrete type.  We can break this by explicitly constructing it with an abstract type:julia> m = MyType{AbstractFloat}(3.2)\nMyType{AbstractFloat}(3.2)\n\njulia> typeof(m.a)\nFloat64\n\njulia> m.a = 4.5f0\n4.5f0\n\njulia> typeof(m.a)\nFloat32For all practical purposes, such objects behave identically to those of MyStillAmbiguousType.It's quite instructive to compare the sheer amount code generated for a simple functionfunc(m::MyType) = m.a+1usingcode_llvm(func,Tuple{MyType{Float64}})\ncode_llvm(func,Tuple{MyType{AbstractFloat}})\ncode_llvm(func,Tuple{MyType})For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code."
},

{
    "location": "manual/performance-tips.html#avoid-fields-with-abstract-containers-1",
    "page": "Performance Tips",
    "title": "Avoid fields with abstract containers",
    "category": "section",
    "text": "The same best practices also work for container types:julia> mutable struct MySimpleContainer{A<:AbstractVector}\n           a::A\n       end\n\njulia> mutable struct MyAmbiguousContainer{T}\n           a::AbstractVector{T}\n       endFor example:julia> c = MySimpleContainer(1:3);\n\njulia> typeof(c)\nMySimpleContainer{UnitRange{Int64}}\n\njulia> c = MySimpleContainer([1:3;]);\n\njulia> typeof(c)\nMySimpleContainer{Array{Int64,1}}\n\njulia> b = MyAmbiguousContainer(1:3);\n\njulia> typeof(b)\nMyAmbiguousContainer{Int64}\n\njulia> b = MyAmbiguousContainer([1:3;]);\n\njulia> typeof(b)\nMyAmbiguousContainer{Int64}For MySimpleContainer, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.While the compiler can now do its job perfectly well, there are cases where you might wish that your code could do different things depending on the element type of a.  Usually the best way to achieve this is to wrap your specific operation (here, foo) in a separate function:julia> function sumfoo(c::MySimpleContainer)\n           s = 0\n           for x in c.a\n               s += foo(x)\n           end\n           s\n       end\nsumfoo (generic function with 1 method)\n\njulia> foo(x::Integer) = x\nfoo (generic function with 1 method)\n\njulia> foo(x::AbstractFloat) = round(x)\nfoo (generic function with 2 methods)This keeps things simple, while allowing the compiler to generate optimized code in all cases.However, there are cases where you may need to declare different versions of the outer function for different element types of a. You could do it like this:function myfun(c::MySimpleContainer{Vector{T}}) where T<:AbstractFloat\n    ...\nend\nfunction myfun(c::MySimpleContainer{Vector{T}}) where T<:Integer\n    ...\nendThis works fine for Vector{T}, but we'd also have to write explicit versions for UnitRange{T} or other abstract types. To prevent such tedium, you can use two parameters in the declaration of MyContainer:julia> mutable struct MyContainer{T, A<:AbstractVector}\n           a::A\n       end\n\njulia> MyContainer(v::AbstractVector) = MyContainer{eltype(v), typeof(v)}(v)\nMyContainer\n\njulia> b = MyContainer(1:5);\n\njulia> typeof(b)\nMyContainer{Int64,UnitRange{Int64}}Note the somewhat surprising fact that T doesn't appear in the declaration of field a, a point that we'll return to in a moment. With this approach, one can write functions such as:julia> function myfunc(c::MyContainer{<:Integer, <:AbstractArray})\n           return c.a[1]+1\n       end\nmyfunc (generic function with 1 method)\n\njulia> function myfunc(c::MyContainer{<:AbstractFloat})\n           return c.a[1]+2\n       end\nmyfunc (generic function with 2 methods)\n\njulia> function myfunc(c::MyContainer{T,Vector{T}}) where T<:Integer\n           return c.a[1]+3\n       end\nmyfunc (generic function with 3 methods)note: Note\nBecause we can only define MyContainer for A<:AbstractArray, and any unspecified parameters are arbitrary, the first function above could have been written more succinctly as function myfunc{T<:Integer}(c::MyContainer{T})julia> myfunc(MyContainer(1:3))\n2\n\njulia> myfunc(MyContainer(1.0:3))\n3.0\n\njulia> myfunc(MyContainer([1:3;]))\n4As you can see, with this approach it's possible to specialize on both the element type T and the array type A.However, there's one remaining hole: we haven't enforced that A has element type T, so it's perfectly possible to construct an object like this:julia> b = MyContainer{Int64, UnitRange{Float64}}(UnitRange(1.3, 5.0));\n\njulia> typeof(b)\nMyContainer{Int64,UnitRange{Float64}}To prevent this, we can add an inner constructor:julia> mutable struct MyBetterContainer{T<:Real, A<:AbstractVector}\n           a::A\n           MyBetterContainer{T,A}(v::AbstractVector{T}) where {T,A} = new(v)\n       end\n\njulia> MyBetterContainer(v::AbstractVector) = MyBetterContainer{eltype(v),typeof(v)}(v)\nMyBetterContainer\n\njulia> b = MyBetterContainer(UnitRange(1.3, 5.0));\n\njulia> typeof(b)\nMyBetterContainer{Float64,UnitRange{Float64}}\n\njulia> b = MyBetterContainer{Int64, UnitRange{Float64}}(UnitRange(1.3, 5.0));\nERROR: MethodError: Cannot `convert` an object of type UnitRange{Float64} to an object of type MyBetterContainer{Int64,UnitRange{Float64}}\n[...]The inner constructor requires that the element type of A be T."
},

{
    "location": "manual/performance-tips.html#Annotate-values-taken-from-untyped-locations-1",
    "page": "Performance Tips",
    "title": "Annotate values taken from untyped locations",
    "category": "section",
    "text": "It is often convenient to work with data structures that may contain values of any type (arrays of type Array{Any}). But, if you're using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:function foo(a::Array{Any,1})\n    x = a[1]::Int32\n    b = x+1\n    ...\nendHere, we happened to know that the first element of a would be an Int32. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier."
},

{
    "location": "manual/performance-tips.html#Declare-types-of-keyword-arguments-1",
    "page": "Performance Tips",
    "title": "Declare types of keyword arguments",
    "category": "section",
    "text": "Keyword arguments can have declared types:function with_keyword(x; name::Int = 1)\n    ...\nendFunctions are specialized on the types of keyword arguments, so these declarations will not affect performance of code inside the function. However, they will reduce the overhead of calls to the function that include keyword arguments.Functions with keyword arguments have near-zero overhead for call sites that pass only positional arguments.Passing dynamic lists of keyword arguments, as in f(x; keywords...), can be slow and should be avoided in performance-sensitive code."
},

{
    "location": "manual/performance-tips.html#Break-functions-into-multiple-definitions-1",
    "page": "Performance Tips",
    "title": "Break functions into multiple definitions",
    "category": "section",
    "text": "Writing a function as many small definitions allows the compiler to directly call the most applicable code, or even inline it.Here is an example of a \"compound function\" that should really be written as multiple definitions:function norm(A)\n    if isa(A, Vector)\n        return sqrt(real(dot(A,A)))\n    elseif isa(A, Matrix)\n        return maximum(svd(A)[2])\n    else\n        error(\"norm: invalid argument\")\n    end\nendThis can be written more concisely and efficiently as:norm(x::Vector) = sqrt(real(dot(x,x)))\nnorm(A::Matrix) = maximum(svd(A)[2])"
},

{
    "location": "manual/performance-tips.html#Write-\"type-stable\"-functions-1",
    "page": "Performance Tips",
    "title": "Write \"type-stable\" functions",
    "category": "section",
    "text": "When possible, it helps to ensure that a function always returns a value of the same type. Consider the following definition:pos(x) = x < 0 ? 0 : xAlthough this seems innocent enough, the problem is that 0 is an integer (of type Int) and x might be of any type. Thus, depending on the value of x, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:pos(x) = x < 0 ? zero(x) : xThere is also a one() function, and a more general oftype(x, y) function, which returns y converted to the type of x."
},

{
    "location": "manual/performance-tips.html#Avoid-changing-the-type-of-a-variable-1",
    "page": "Performance Tips",
    "title": "Avoid changing the type of a variable",
    "category": "section",
    "text": "An analogous \"type-stability\" problem exists for variables used repeatedly within a function:function foo()\n    x = 1\n    for i = 1:10\n        x = x/bar()\n    end\n    return x\nendLocal variable x starts as an integer, and after one loop iteration becomes a floating-point number (the result of / operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:Initialize x with x = 1.0\nDeclare the type of x: x::Float64 = 1\nUse an explicit conversion: x = oneunit(T)\nInitialize with the first loop iteration, to x = 1/bar(), then loop for i = 2:10"
},

{
    "location": "manual/performance-tips.html#kernal-functions-1",
    "page": "Performance Tips",
    "title": "Separate kernel functions (aka, function barriers)",
    "category": "section",
    "text": "Many functions follow a pattern of performing some set-up work, and then running many iterations to perform a core computation. Where possible, it is a good idea to put these core computations in separate functions. For example, the following contrived function returns an array of a randomly-chosen type:DocTestSetup = quote\n    srand(1234)\nendjulia> function strange_twos(n)\n           a = Vector{rand(Bool) ? Int64 : Float64}(n)\n           for i = 1:n\n               a[i] = 2\n           end\n           return a\n       end\nstrange_twos (generic function with 1 method)\n\njulia> strange_twos(3)\n3-element Array{Float64,1}:\n 2.0\n 2.0\n 2.0This should be written as:julia> function fill_twos!(a)\n           for i=1:length(a)\n               a[i] = 2\n           end\n       end\nfill_twos! (generic function with 1 method)\n\njulia> function strange_twos(n)\n           a = Array{rand(Bool) ? Int64 : Float64}(n)\n           fill_twos!(a)\n           return a\n       end\nstrange_twos (generic function with 1 method)\n\njulia> strange_twos(3)\n3-element Array{Float64,1}:\n 2.0\n 2.0\n 2.0Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of a during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of fill_twos! for different types of a.The second form is also often better style and can lead to more code reuse.This pattern is used in several places in the standard library. For example, see hvcat_fill in abstractarray.jl, or the fill! function, which we could have used instead of writing our own fill_twos!.Functions like strange_twos occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else."
},

{
    "location": "manual/performance-tips.html#Types-with-values-as-parameters-1",
    "page": "Performance Tips",
    "title": "Types with values-as-parameters",
    "category": "section",
    "text": "Let's say you want to create an N-dimensional array that has size 3 along each axis.  Such arrays can be created like this:julia> A = fill(5.0, (3, 3))\n3×3 Array{Float64,2}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0This approach works very well: the compiler can figure out that A is an Array{Float64,2} because it knows the type of the fill value (5.0::Float64) and the dimensionality ((3, 3)::NTuple{2,Int}). This implies that the compiler can generate very efficient code for any future usage of A in the same function.But now let's say you want to write a function that creates a 3×3×... array in arbitrary dimensions; you might be tempted to write a functionjulia> function array3(fillval, N)\n           fill(fillval, ntuple(d->3, N))\n       end\narray3 (generic function with 1 method)\n\njulia> array3(5.0, 2)\n3×3 Array{Float64,2}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0This works, but (as you can verify for yourself using @code_warntype array3(5.0, 2)) the problem is that the output type cannot be inferred: the argument N is a value of type Int, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of A; such code will be very slow.Now, one very good way to solve such problems is by using the function-barrier technique. However, in some cases you might want to eliminate the type-instability altogether.  In such cases, one approach is to pass the dimensionality as a parameter, for example through Val{T} (see \"Value types\"):julia> function array3(fillval, ::Type{Val{N}}) where N\n           fill(fillval, ntuple(d->3, Val{N}))\n       end\narray3 (generic function with 1 method)\n\njulia> array3(5.0, Val{2})\n3×3 Array{Float64,2}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0Julia has a specialized version of ntuple that accepts a Val{::Int} as the second parameter; by passing N as a type-parameter, you make its \"value\" known to the compiler. Consequently, this version of array3 allows the compiler to predict the return type.However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called array3 from a function like this:function call_array3(fillval, n)\n    A = array3(fillval, Val{n})\nendHere, you've created the same problem all over again: the compiler can't guess the type of n, so it doesn't know the type of Val{n}.  Attempting to use Val, but doing so incorrectly, can easily make performance worse in many situations.  (Only in situations where you're effectively combining Val with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)An example of correct usage of Val would be:function filter3(A::AbstractArray{T,N}) where {T,N}\n    kernel = array3(1, Val{N})\n    filter(A, kernel)\nendIn this example, N is passed as a parameter, so its \"value\" is known to the compiler.  Essentially, Val{T} works only when T is either hard-coded (Val{3}) or already specified in the type-domain."
},

{
    "location": "manual/performance-tips.html#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)-1",
    "page": "Performance Tips",
    "title": "The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)",
    "category": "section",
    "text": "Once one learns to appreciate multiple dispatch, there's an understandable tendency to go crazy and try to use it for everything. For example, you might imagine using it to store information, e.g.struct Car{Make,Model}\n    year::Int\n    ...more fields...\nendand then dispatch on objects like Car{:Honda,:Accord}(year, args...).This might be worthwhile when the following are true:You require CPU-intensive processing on each Car, and it becomes vastly more efficient if you know the Make and Model at compile time.\nYou have homogenous lists of the same type of Car to process, so that you can store them all in an Array{Car{:Honda,:Accord},N}.When the latter holds, a function processing such a homogenous array can be productively specialized: Julia knows the type of each element in advance (all objects in the container have the same concrete type), so Julia can \"look up\" the correct method calls when the function is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list.When these do not hold, then it's likely that you'll get no benefit; worse, the resulting \"combinatorial explosion of types\" will be counterproductive.  If items[i+1] has a different type than item[i], Julia has to look up the type at run-time, search for the appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In essence, you're asking the full type- system and JIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary lookup in your own code.Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a \"switch\" statement can be found on the mailing list.Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized functions for each different Car{Make, Model}; if you have hundreds or thousands of such types, then every function that accepts such an object as a parameter (from a custom get_year function you might write yourself, to the generic push! function in the standard library) will have hundreds or thousands of variants compiled for it.  Each of these increases the size of the cache of compiled code, the length of internal lists of methods, etc.  Excess enthusiasm for values-as-parameters can easily waste enormous resources."
},

{
    "location": "manual/performance-tips.html#Access-arrays-in-memory-order,-along-columns-1",
    "page": "Performance Tips",
    "title": "Access arrays in memory order, along columns",
    "category": "section",
    "text": "Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be verified using the vec function or the syntax [:] as shown below (notice that the array is ordered [1 3 2 4], not [1 2 3 4]):julia> x = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> x[:]\n4-element Array{Int64,1}:\n 1\n 3\n 2\n 4This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (numpy) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.Consider the following contrived example. Imagine we wanted to write a function that accepts a Vector and returns a square Matrix with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in repmat()):function copy_cols(x::Vector{T}) where T\n    n = size(x, 1)\n    out = Array{T}(n, n)\n    for i = 1:n\n        out[:, i] = x\n    end\n    out\nend\n\nfunction copy_rows(x::Vector{T}) where T\n    n = size(x, 1)\n    out = Array{T}(n, n)\n    for i = 1:n\n        out[i, :] = x\n    end\n    out\nend\n\nfunction copy_col_row(x::Vector{T}) where T\n    n = size(x, 1)\n    out = Array{T}(n, n)\n    for col = 1:n, row = 1:n\n        out[row, col] = x[row]\n    end\n    out\nend\n\nfunction copy_row_col(x::Vector{T}) where T\n    n = size(x, 1)\n    out = Array{T}(n, n)\n    for row = 1:n, col = 1:n\n        out[row, col] = x[col]\n    end\n    out\nendNow we will time each of these functions using the same random 10000 by 1 input vector:julia> x = randn(10000);\n\njulia> fmt(f) = println(rpad(string(f)*\": \", 14, ' '), @elapsed f(x))\n\njulia> map(fmt, Any[copy_cols, copy_rows, copy_col_row, copy_row_col]);\ncopy_cols:    0.331706323\ncopy_rows:    1.799009911\ncopy_col_row: 0.415630047\ncopy_row_col: 1.721531501Notice that copy_cols is much faster than copy_rows. This is expected because copy_cols respects the column-based memory layout of the Matrix and fills it one column at a time. Additionally, copy_col_row is much faster than copy_row_col because it follows our rule of thumb that the first element to appear in a slice expression should be coupled with the inner-most loop."
},

{
    "location": "manual/performance-tips.html#pre-allocating-outputs-1",
    "page": "Performance Tips",
    "title": "Pre-allocating outputs",
    "category": "section",
    "text": "If your function returns an Array or some other complex type, it may have to allocate memory.  Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.Sometimes you can circumvent the need to allocate memory on each function call by preallocating the output.  As a trivial example, comparefunction xinc(x)\n    return [x, x+1, x+2]\nend\n\nfunction loopinc()\n    y = 0\n    for i = 1:10^7\n        ret = xinc(i)\n        y += ret[2]\n    end\n    y\nendwithfunction xinc!(ret::AbstractVector{T}, x::T) where T\n    ret[1] = x\n    ret[2] = x+1\n    ret[3] = x+2\n    nothing\nend\n\nfunction loopinc_prealloc()\n    ret = Array{Int}(3)\n    y = 0\n    for i = 1:10^7\n        xinc!(ret, i)\n        y += ret[2]\n    end\n    y\nendTiming results:julia> @time loopinc()\n  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)\n50000015000000\n\njulia> @time loopinc_prealloc()\n  0.030850 seconds (6 allocations: 288 bytes)\n50000015000000Preallocation has other advantages, for example by allowing the caller to control the \"output\" type from an algorithm.  In the example above, we could have passed a SubArray rather than an Array, had we so desired.Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for \"vectorized\" (element-wise) functions, the convenient syntax x .= f.(y) can be used for in-place operations with fused loops and no temporary arrays (see the dot syntax for vectorizing functions)."
},

{
    "location": "manual/performance-tips.html#More-dots:-Fuse-vectorized-operations-1",
    "page": "Performance Tips",
    "title": "More dots: Fuse vectorized operations",
    "category": "section",
    "text": "Julia has a special dot syntax that converts any scalar function into a \"vectorized\" function call, and any operator into a \"vectorized\" operator, with the special property that nested \"dot calls\" are fusing: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use .= and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).In a linear-algebra context, this means that even though operations like vector + vector and vector * scalar are defined, it can be advantageous to instead use vector .+ vector and vector .* scalar because the resulting loops can be fused with surrounding computations. For example, consider the two functions:f(x) = 3x.^2 + 4x + 7x.^3\n\nfdot(x) = @. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3Both f and fdot compute the same thing.  However, fdot (defined with the help of the @. macro) is significantly faster when applied to an array:julia> x = rand(10^6);\n\njulia> @time f(x);\n  0.010986 seconds (18 allocations: 53.406 MiB, 11.45% gc time)\n\njulia> @time fdot(x);\n  0.003470 seconds (6 allocations: 7.630 MiB)\n\njulia> @time f.(x);\n  0.003297 seconds (30 allocations: 7.631 MiB)That is, fdot(x) is three times faster and allocates 1/7 the memory of f(x), because each * and + operation in f(x) allocates a new temporary array and executes in a separate loop. (Of course, if you just do f.(x) then it is as fast as fdot(x) in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)"
},

{
    "location": "manual/performance-tips.html#Consider-using-views-for-slices-1",
    "page": "Performance Tips",
    "title": "Consider using views for slices",
    "category": "section",
    "text": "In Julia, an array \"slice\" expression like array[1:5, :] creates a copy of that data (except on the left-hand side of an assignment, where array[1:5, :] = ... assigns in-place to that portion of array). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.An alternative is to create a \"view\" of the array, which is an array object (a SubArray) that actually references the data of the original array in-place, without making a copy.  (If you write to a view, it modifies the original array's data as well.) This can be done for individual slices by calling view(), or more simply for a whole expression or block of code by putting @views in front of that expression.  For example:julia> fcopy(x) = sum(x[2:end-1])\n\njulia> @views fview(x) = sum(x[2:end-1])\n\njulia> x = rand(10^6);\n\njulia> @time fcopy(x);\n  0.003051 seconds (7 allocations: 7.630 MB)\n\njulia> @time fview(x);\n  0.001020 seconds (6 allocations: 224 bytes)Notice both the 3× speedup and the decreased memory allocation of the fview version of the function."
},

{
    "location": "manual/performance-tips.html#Avoid-string-interpolation-for-I/O-1",
    "page": "Performance Tips",
    "title": "Avoid string interpolation for I/O",
    "category": "section",
    "text": "When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of:println(file, \"$a $b\")use:println(file, a, \" \", b)The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:println(file, \"$(f(a))$(f(b))\")versus:println(file, f(a), f(b))"
},

{
    "location": "manual/performance-tips.html#Optimize-network-I/O-during-parallel-execution-1",
    "page": "Performance Tips",
    "title": "Optimize network I/O during parallel execution",
    "category": "section",
    "text": "When executing a remote function in parallel:responses = Vector{Any}(nworkers())\n@sync begin\n    for (idx, pid) in enumerate(workers())\n        @async responses[idx] = remotecall_fetch(pid, foo, args...)\n    end\nendis faster than:refs = Vector{Any}(nworkers())\nfor (idx, pid) in enumerate(workers())\n    refs[idx] = @spawnat pid foo(args...)\nend\nresponses = [fetch(r) for r in refs]The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the @spawnat and the second due to the fetch (or even a wait). The fetch/wait is also being executed serially resulting in an overall poorer performance."
},

{
    "location": "manual/performance-tips.html#Fix-deprecation-warnings-1",
    "page": "Performance Tips",
    "title": "Fix deprecation warnings",
    "category": "section",
    "text": "A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings."
},

{
    "location": "manual/performance-tips.html#Tweaks-1",
    "page": "Performance Tips",
    "title": "Tweaks",
    "category": "section",
    "text": "These are some minor points that might help in tight inner loops.Avoid unnecessary arrays. For example, instead of sum([x,y,z]) use x+y+z.\nUse abs2(z) instead of abs(z)^2 for complex z. In general, try to rewrite code to use abs2() instead of abs() for complex arguments.\nUse div(x,y) for truncating division of integers instead of trunc(x/y), fld(x,y) instead of floor(x/y), and cld(x,y) instead of ceil(x/y)."
},

{
    "location": "manual/performance-tips.html#Performance-Annotations-1",
    "page": "Performance Tips",
    "title": "Performance Annotations",
    "category": "section",
    "text": "Sometimes you can enable better optimization by promising certain program properties.Use @inbounds to eliminate array bounds checking within expressions. Be certain before doing this. If the subscripts are ever out of bounds, you may suffer crashes or silent corruption.\nUse @fastmath to allow floating point optimizations that are correct for real numbers, but lead to differences for IEEE numbers. Be careful when doing this, as this may change numerical results. This corresponds to the -ffast-math option of clang.\nWrite @simd in front of for loops that are amenable to vectorization. This feature is experimental and could change or disappear in future versions of Julia.Note: While @simd needs to be placed directly in front of a loop, both @inbounds and @fastmath can be applied to several statements at once, e.g. using begin ... end, or even to a whole function.Here is an example with both @inbounds and @simd markup:function inner(x, y)\n    s = zero(eltype(x))\n    for i=1:length(x)\n        @inbounds s += x[i]*y[i]\n    end\n    s\nend\n\nfunction innersimd(x, y)\n    s = zero(eltype(x))\n    @simd for i=1:length(x)\n        @inbounds s += x[i]*y[i]\n    end\n    s\nend\n\nfunction timeit(n, reps)\n    x = rand(Float32,n)\n    y = rand(Float32,n)\n    s = zero(Float64)\n    time = @elapsed for j in 1:reps\n        s+=inner(x,y)\n    end\n    println(\"GFlop/sec        = \",2.0*n*reps/time*1E-9)\n    time = @elapsed for j in 1:reps\n        s+=innersimd(x,y)\n    end\n    println(\"GFlop/sec (SIMD) = \",2.0*n*reps/time*1E-9)\nend\n\ntimeit(1000,1000)On a computer with a 2.4GHz Intel Core i5 processor, this produces:GFlop/sec        = 1.9467069505224963\nGFlop/sec (SIMD) = 17.578554163920018(GFlop/sec measures the performance, and larger numbers are better.) The range for a @simd for loop should be a one-dimensional range. A variable used for accumulating, such as s in the example, is called a reduction variable. By using @simd, you are asserting several properties of the loop:It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.\nFloating-point operations on reduction variables can be reordered, possibly causing different results than without @simd.\nNo iteration ever waits on another iteration to make forward progress.A loop containing break, continue, or @goto will cause a compile-time error.Using @simd merely gives the compiler license to vectorize. Whether it actually does so depends on the compiler. To actually benefit from the current implementation, your loop should have the following additional properties:The loop must be an innermost loop.\nThe loop body must be straight-line code. This is why @inbounds is currently needed for all array accesses. The compiler can sometimes turn short &&, ||, and ?: expressions into straight-line code, if it is safe to evaluate all operands unconditionally. Consider using ifelse() instead of ?: in the loop if it is safe to do so.\nAccesses must have a stride pattern and cannot be \"gathers\" (random-index reads) or \"scatters\" (random-index writes).\nThe stride should be unit stride.\nIn some simple cases, for example with 2-3 arrays accessed in a loop, the LLVM auto-vectorization may kick in automatically, leading to no further speedup with @simd.Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:function init!(u)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds @simd for i in 1:n\n        u[i] = sin(2pi*dx*i)\n    end\nend\n\nfunction deriv!(u, du)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx\n    @fastmath @inbounds @simd for i in 2:n-1\n        du[i] = (u[i+1] - u[i-1]) / (2*dx)\n    end\n    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx\nend\n\nfunction norm(u)\n    n = length(u)\n    T = eltype(u)\n    s = zero(T)\n    @fastmath @inbounds @simd for i in 1:n\n        s += u[i]^2\n    end\n    @fastmath @inbounds return sqrt(s/n)\nend\n\nfunction main()\n    n = 2000\n    u = Array{Float64}(n)\n    init!(u)\n    du = similar(u)\n\n    deriv!(u, du)\n    nu = norm(du)\n\n    @time for i in 1:10^6\n        deriv!(u, du)\n        nu = norm(du)\n    end\n\n    println(nu)\nend\n\nmain()On a computer with a 2.7 GHz Intel Core i7 processor, this produces:$ julia wave.jl;\nelapsed time: 1.207814709 seconds (0 bytes allocated)\n\n$ julia --math-mode=ieee wave.jl;\nelapsed time: 4.487083643 seconds (0 bytes allocated)Here, the option --math-mode=ieee disables the @fastmath macro, so that we can compare results.In this case, the speedup due to @fastmath is a factor of about 3.7. This is unusually large – in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result – in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.The annotation @fastmath re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression 1 / (2*dx) in the function deriv is hoisted out of the loop (i.e. calculated outside the loop), as if one had written idx = 1 / (2*dx). In the loop, the expression ... / (2*dx) then becomes ... * idx, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia's code_native() function."
},

{
    "location": "manual/performance-tips.html#Treat-Subnormal-Numbers-as-Zeros-1",
    "page": "Performance Tips",
    "title": "Treat Subnormal Numbers as Zeros",
    "category": "section",
    "text": "Subnormal numbers, formerly called denormal numbers, are useful in many contexts, but incur a performance penalty on some hardware. A call set_zero_subnormals(true) grants permission for floating-point operations to treat subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call set_zero_subnormals(false) enforces strict IEEE behavior for subnormal numbers.Below is an example where subnormals noticeably impact performance on some hardware:function timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T\n    @assert length(a)==length(b)\n    n = length(b)\n    b[1] = 1                            # Boundary condition\n    for i=2:n-1\n        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt\n    end\n    b[n] = 0                            # Boundary condition\nend\n\nfunction heatflow(a::Vector{T}, nstep::Integer) where T\n    b = similar(a)\n    for t=1:div(nstep,2)                # Assume nstep is even\n        timestep(b,a,T(0.1))\n        timestep(a,b,T(0.1))\n    end\nend\n\nheatflow(zeros(Float32,10),2)           # Force compilation\nfor trial=1:6\n    a = zeros(Float32,1000)\n    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic\n    @time heatflow(a,1000)\nendThis example generates many subnormal numbers because the values in a become an exponentially decreasing curve, which slowly flattens out over time.Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as x-y == 0 implies x == y:julia> x = 3f-38; y = 2f-38;\n\njulia> set_zero_subnormals(true); (x - y, x == y)\n(0.0f0, false)\n\njulia> set_zero_subnormals(false); (x - y, x == y)\n(1.0000001f-38, false)In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.  For example, instead of initializing a with zeros, initialize it with:a = rand(Float32,1000) * 1.f-9"
},

{
    "location": "manual/performance-tips.html#man-code-warntype-1",
    "page": "Performance Tips",
    "title": "@code_warntype",
    "category": "section",
    "text": "The macro @code_warntype (or its function variant code_warntype()) can sometimes be helpful in diagnosing type-related problems. Here's an example:pos(x) = x < 0 ? 0 : x\n\nfunction f(x)\n    y = pos(x)\n    sin(y*x+1)\nend\n\njulia> @code_warntype f(3.2)\nVariables:\n  #self#::#f\n  x::Float64\n  y::UNION{FLOAT64,INT64}\n  fy::Float64\n  #temp#@_5::UNION{FLOAT64,INT64}\n  #temp#@_6::Core.MethodInstance\n  #temp#@_7::Float64\n\nBody:\n  begin\n      $(Expr(:inbounds, false))\n      # meta: location REPL[1] pos 1\n      # meta: location float.jl < 487\n      fy::Float64 = (Core.typeassert)((Base.sitofp)(Float64,0)::Float64,Float64)::Float64\n      # meta: pop location\n      unless (Base.or_int)((Base.lt_float)(x::Float64,fy::Float64)::Bool,(Base.and_int)((Base.and_int)((Base.eq_float)(x::Float64,fy::Float64)::Bool,(Base.lt_float)(fy::Float64,9.223372036854776e18)::Bool)::Bool,(Base.slt_int)((Base.fptosi)(Int64,fy::Float64)::Int64,0)::Bool)::Bool)::Bool goto 9\n      #temp#@_5::UNION{FLOAT64,INT64} = 0\n      goto 11\n      9:\n      #temp#@_5::UNION{FLOAT64,INT64} = x::Float64\n      11:\n      # meta: pop location\n      $(Expr(:inbounds, :pop))\n      y::UNION{FLOAT64,INT64} = #temp#@_5::UNION{FLOAT64,INT64} # line 3:\n      unless (y::UNION{FLOAT64,INT64} isa Int64)::ANY goto 19\n      #temp#@_6::Core.MethodInstance = MethodInstance for *(::Int64, ::Float64)\n      goto 28\n      19:\n      unless (y::UNION{FLOAT64,INT64} isa Float64)::ANY goto 23\n      #temp#@_6::Core.MethodInstance = MethodInstance for *(::Float64, ::Float64)\n      goto 28\n      23:\n      goto 25\n      25:\n      #temp#@_7::Float64 = (y::UNION{FLOAT64,INT64} * x::Float64)::Float64\n      goto 30\n      28:\n      #temp#@_7::Float64 = $(Expr(:invoke, :(#temp#@_6), :(Main.*), :(y), :(x)))\n      30:\n      return $(Expr(:invoke, MethodInstance for sin(::Float64), :(Main.sin), :((Base.add_float)(#temp#@_7,(Base.sitofp)(Float64,1)::Float64)::Float64)))\n  end::Float64Interpreting the output of @code_warntype, like that of its cousins @code_lowered, @code_typed, @code_llvm, and @code_native, takes a little practice. Your code is being presented in form that has been partially digested on its way to generating compiled machine code.  Most of the expressions are annotated by a type, indicated by the ::T (where T might be Float64, for example). The most important characteristic of @code_warntype is that non-concrete types are displayed in red; in the above example, such output is shown in all-caps.The top part of the output summarizes the type information for the different variables internal to the function. You can see that y, one of the variables you created, is a Union{Int64,Float64}, due to the type-instability of pos.  There is another variable, _var4, which you can see also has the same type.The next lines represent the body of f. The lines starting with a number followed by a colon (1:, 2:) are labels, and represent targets for jumps (via goto) in your code.  Looking at the body, you can see that pos has been inlined into f–everything before 2: comes from code defined in pos.Starting at 2:, the variable y is defined, and again annotated as a Union type.  Next, we see that the compiler created the temporary variable _var1 to hold the result of y*x. Because a Float64 times either an Int64 or Float64 yields a Float64, all type-instability ends here. The net result is that f(x::Float64) will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.How you use this information is up to you. Obviously, it would be far and away best to fix pos to be type-stable: if you did so, all of the variables in f would be concrete, and its performance would be optimal.  However, there are circumstances where this kind of ephemeral type instability might not matter too much: for example, if pos is never used in isolation, the fact that f's output is type-stable (for Float64 inputs) will shield later code from the propagating effects of type instability.  This is particularly relevant in cases where fixing the type instability is difficult or impossible: for example, currently it's not possible to infer the return type of an anonymous function.  In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the \"damage\" from type instability.The following examples may help you interpret expressions marked as containing non-leaf types:Function body ending in end::Union{T1,T2})\nInterpretation: function with unstable return type\nSuggestion: make the return value type-stable, even if you have to annotate it\nf(x::T)::Union{T1,T2}\nInterpretation: call to a type-unstable function\nSuggestion: fix the function, or if necessary annotate the return value\n(top(arrayref))(A::Array{Any,1},1)::Any\nInterpretation: accessing elements of poorly-typed arrays\nSuggestion: use arrays with better-defined types, or if necessary annotate the type of individual element accesses\n(top(getfield))(A::ArrayContainer{Float64},:data)::Array{Float64,N}\nInterpretation: getting a field that is of non-leaf type. In this case, ArrayContainer had a field data::Array{T}. But Array needs the dimension N, too, to be a concrete type.\nSuggestion: use concrete types like Array{T,3} or Array{T,N}, where N is now a parameter of ArrayContainer"
},

{
    "location": "manual/workflow-tips.html#",
    "page": "Workflow Tips",
    "title": "Workflow Tips",
    "category": "page",
    "text": ""
},

{
    "location": "manual/workflow-tips.html#man-workflow-tips-1",
    "page": "Workflow Tips",
    "title": "Workflow Tips",
    "category": "section",
    "text": "Here are some tips for working with Julia efficiently."
},

{
    "location": "manual/workflow-tips.html#REPL-based-workflow-1",
    "page": "Workflow Tips",
    "title": "REPL-based workflow",
    "category": "section",
    "text": "As already elaborated in Interacting With Julia, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line."
},

{
    "location": "manual/workflow-tips.html#A-basic-editor/REPL-workflow-1",
    "page": "Workflow Tips",
    "title": "A basic editor/REPL workflow",
    "category": "section",
    "text": "The most basic Julia workflows involve using a text editor in conjunction with the julia command line. A common pattern includes the following elements:Put code under development in a temporary module. Create a file, say Tmp.jl, and include within it\nmodule Tmp\n\n<your definitions here>\n\nend\nPut your test code in another file. Create another file, say tst.jl, which begins with\nimport Tmp\nand includes tests for the contents of Tmp. The value of using import versus using is that you can call reload(\"Tmp\") instead of having to restart the REPL when your definitions change. Of course, the cost is the need to prepend Tmp. to uses of names defined in your module. (You can lower that cost by keeping your module name short.)\nAlternatively, you can wrap the contents of your test file in a module, as\nmodule Tst\n    using Tmp\n\n    <scratch work>\n\nend\nThe advantage is that you can now do using Tmp in your test code and can therefore avoid prepending Tmp. everywhere. The disadvantage is that code can no longer be selectively copied to the REPL without some tweaking.\nLather. Rinse. Repeat. Explore ideas at the julia command prompt. Save good ideas in tst.jl. Occasionally restart the REPL, issuing\nreload(\"Tmp\")\ninclude(\"tst.jl\")"
},

{
    "location": "manual/workflow-tips.html#Simplify-initialization-1",
    "page": "Workflow Tips",
    "title": "Simplify initialization",
    "category": "section",
    "text": "To simplify restarting the REPL, put project-specific initialization code in a file, say _init.jl, which you can run on startup by issuing the command:julia -L _init.jlIf you further add the following to your .juliarc.jl fileisfile(\"_init.jl\") && include(joinpath(pwd(), \"_init.jl\"))then calling julia from that directory will run the initialization code without the additional command line argument."
},

{
    "location": "manual/workflow-tips.html#Browser-based-workflow-1",
    "page": "Workflow Tips",
    "title": "Browser-based workflow",
    "category": "section",
    "text": "It is also possible to interact with a Julia REPL in the browser via IJulia. See the package home for details."
},

{
    "location": "manual/style-guide.html#",
    "page": "Guía de Estilo",
    "title": "Guía de Estilo",
    "category": "page",
    "text": ""
},

{
    "location": "manual/style-guide.html#style-guide-1",
    "page": "Guía de Estilo",
    "title": "Guía de Estilo",
    "category": "section",
    "text": "Las siguientes secciones explican unos cuantos aspectos del estilo de codificación idiomático de Julia. Ninguna de estas reglas son absolutas; sólo son sugerencias para ayudar a familiarizarte con el lenguaje y ayudarte a elegir entre diseños alternativos."
},

{
    "location": "manual/style-guide.html#Escribe-funciones,-no-sólo-*scripts*-1",
    "page": "Guía de Estilo",
    "title": "Escribe funciones, no sólo scripts",
    "category": "section",
    "text": "Escribir código como una serie de pasos a nivel superior Es una forma rápida de empezar a  resolver un problema, pero uno debería intentar dividir un programa en funciones tan pronto como  sea posible. La función son más reusabes y testables, y clarifican qué pasos se están dando y  cuáles son sus entradas y sus salidas. Además, el código dentro de las funciones tiende a ejecutar  mucho más rápido que el código de nivel superior debido a cómo funciona el compilador de Julia.También merece la pena señalar que las funciones deberían tomar argumentos, en lugar de operar directamente sobre las variables globales (aparte de constantes como pi)."
},

{
    "location": "manual/style-guide.html#Evita-escribir-tipos-demasiado-específicos-1",
    "page": "Guía de Estilo",
    "title": "Evita escribir tipos demasiado específicos",
    "category": "section",
    "text": "El código debería ser tan genérico como sea posible. En lugar de escribir:convert(Complex{Float64}, x)es mejor usar funciones genéricas disponibles:complex(float(x))La segunda versión convertirá x a un tipo apropiado, en lugrar de siempre al mismo tipo. Este punto de estilo es especialmente relevante para los argumentos de función. Por ejemplo, no declare que un argumento sea de tipo Int o Int32 si realmente pudiera ser cualquier número entero, expresado con el tipo abstracto Integer. De hecho, en muchos casos puede omitir el tipo de argumento por completo, a menos que sea necesario para eliminar la ambigüedad de otras definiciones de método, ya que se lanzará MethodError de todos modos si se pasa un tipo que no admite ninguna de las operaciones requeridas. (Esto se conoce como duck typing.)Por ejemplo, considere las siguientes definiciones de una función addone que devuelve uno más su argumento:addone(x::Int) = x + 1                 # works only for Int\naddone(x::Integer) = x + oneunit(x)    # any integer type\naddone(x::Number) = x + oneunit(x)     # any numeric type\naddone(x) = x + oneunit(x)             # any type supporting + and oneunitLa última definición de addone maneja cualquier tipo que soporte oneunit (que devuelve 1 en el mismo tipo que x, lo que evita la promoción de tipos no deseados) y  la función + con esos argumentos. La clave para darse cuenta es que no hay ninguna penalización de rendimiento para definir solo el general addone (x) = x + oneunit (x), porque Julia compilará automáticamente versiones especializadas según sea necesario. Por ejemplo, la primera vez que llame a addone(12), Julia compilará automáticamente una función especializada addone para argumentos x :: Int, reemplazando la llamada a oneunit por su valor1. Por lo tanto, las primeras tres definiciones de 'addone' anteriores son completamente redundantes con la cuarta definición."
},

{
    "location": "manual/style-guide.html#Manejar-el-exceso-de-diversidad-de-argumentos-en-el-\"código-llamador\"-1",
    "page": "Guía de Estilo",
    "title": "Manejar el exceso de diversidad de argumentos en el \"código llamador\"",
    "category": "section",
    "text": "En lugar de:function foo(x, y)\n    x = Int(x); y = Int(y)\n    ...\nend\nfoo(x, y)use:function foo(x::Int, y::Int)\n    ...\nend\nfoo(Int(x), Int(y))Este es mucho mejor estilo debido a que foo no acepta realmente números de todos los tipos, sino que necesita Int s.Un problema aquí es que si una función requiere números enteros intrínsecamente, podría ser mejor forzar al autor de la llamada a decidir cómo deberían convertirse los no enteros (por ejemplo, redondeando por abajo o por arriba). Otro problema es que la declaración de tipos más específicos deja más \"espacio\" para las futuras definiciones de métodos."
},

{
    "location": "manual/style-guide.html#Añadir-!-para-los-nombres-de-funciones-que-modifican-sus-argumentos-1",
    "page": "Guía de Estilo",
    "title": "Añadir ! para los nombres de funciones que modifican sus argumentos",
    "category": "section",
    "text": "En lugar de:function double(a::AbstractArray{<:Number})\n    for i = 1:endof(a)\n        a[i] *= 2\n    end\n    return a\nenduse:function double!(a::AbstractArray{<:Number})\n    for i = 1:endof(a)\n        a[i] *= 2\n    end\n    return a\nendLa biblioteca estándar de Julia usa esta convención y contiene ejemplos de funciones con formas tanto de copiado como de modificación (por ejemplo, sort() y sort!()), y otras que simplemente están modificando (por ejemplo, push!(), pop!(), splice!()). Es típico para tales funciones devolver también la matriz modificada por conveniencia."
},

{
    "location": "manual/style-guide.html#Evitar-tipos-Union-extraños-1",
    "page": "Guía de Estilo",
    "title": "Evitar tipos Union extraños",
    "category": "section",
    "text": "Tipos tales como Union{Function,AbstractString} son frecuentemente un signo de que hay que limpiar algo en el diseño."
},

{
    "location": "manual/style-guide.html#Evitar-las-Uniones-de-tipos-en-campos-1",
    "page": "Guía de Estilo",
    "title": "Evitar las Uniones de tipos en campos",
    "category": "section",
    "text": "Cuando se crea un tipo tal como :mutable struct MyType\n    ...\n    x::Union{Void,T}\nendpregunte si la opción de x para ser nada (de tipo Void) es realmente necesaria. Aquí hay algunas alternativas a considerar:Encuentre un valor predeterminado seguro con el que inicializar x\nIntroduce otro tipo del que carece x\nSi hay muchos campos como x, guárdelos en un diccionario\nDetermine si hay una regla simple para cuando x esnada. Por ejemplo, a menudo el campo comenzará  como nada pero se inicializará en algún punto bien definido. En ese caso, considere dejarlo indefinido  al principio.\nSi x realmente no necesita contener ningún valor en algún momento, defínalo como ::Nullable{T} en  su lugar, ya que esto garantiza estabilidad de tipo en el código que accede a este campo  (ver TiposNullable)."
},

{
    "location": "manual/style-guide.html#Evitar-elaborar-tipos-contenedor-1",
    "page": "Guía de Estilo",
    "title": "Evitar elaborar tipos contenedor",
    "category": "section",
    "text": "Usualmente no es de mucha ayuda construir arrays como los siguientes:a = Array{Union{Int,AbstractString,Tuple,Array}}(n)En este caso Array{Any}(n) es mejor. Es también de más ayuda para el compilador anotar usos específicos (por ejemplo  a[i]::Int) que intentar empaquetar muchas alternativas en un tipo."
},

{
    "location": "manual/style-guide.html#Usar-convenciones-de-nombrado-consistentes-con-el-paquete-base/-de-Julia-1",
    "page": "Guía de Estilo",
    "title": "Usar convenciones de nombrado consistentes con el paquete base/ de Julia",
    "category": "section",
    "text": "Los nombres de los módulos y tipos usan mayúsculas y came case: module SparseArrays, struct UnitRange.\nLas funciones van en minúscula (maximum(), convert()) y, cuando es legible, con múltiples palabras pegadas juntas (isequal(), haskey()). Cuando sea necesario, use guiones bajos como separadores de palabra. Los guiones bajos también se usan para indicar una combinacin de conceptos (remotecall_fetch() como una implementación más eficiente de fetch(remotecall(...))) o como modificadores (sum_kbn()).\nSe valora la concisión, pero debe evitarse la abreviatura (indexin() en lugar de indxin()) ya   que se vuelve difícil recordar si se abrevian palabras particulares y cómo se han abreviado.Si el nombre de una función requiere varias palabras, considere si podría representar más de un concepto y podría dividirse mejor en partes."
},

{
    "location": "manual/style-guide.html#No-usar-demasiado-try-catch-1",
    "page": "Guía de Estilo",
    "title": "No usar demasiado try-catch",
    "category": "section",
    "text": "Es mejor evitar errores que basarse en atraparlos."
},

{
    "location": "manual/style-guide.html#No-meter-entre-paréntesis-las-condiciones-1",
    "page": "Guía de Estilo",
    "title": "No meter entre paréntesis las condiciones",
    "category": "section",
    "text": "Julia no necesita que se rodeen entre paréntesis las condiciones en if and while. Escriba:if a == ben lugar de:if (a == b)"
},

{
    "location": "manual/style-guide.html#No-usar-demasiado-...-1",
    "page": "Guía de Estilo",
    "title": "No usar demasiado ...",
    "category": "section",
    "text": "El uso de ... en los argumentos de función puede ser adictivo. En lugar de [a..., b...], use [a; b], que ya concatena arrays. collect(a) es mejor que [a...], pero como a ya es iterable suele ser  incluso mejor d3jarlo solo, y no convertirlo en array."
},

{
    "location": "manual/style-guide.html#No-usar-parámetros-estáticos-innecesarios-1",
    "page": "Guía de Estilo",
    "title": "No usar parámetros estáticos innecesarios",
    "category": "section",
    "text": "Una signatura de función:foo(x::T) where {T<:Real} = ...debería ser escrita comofoo(x::Real) = ...especialmente si T no se usa en el cuerpo de la función. Incluso si se usa T, se puede reemplazar con typeof(x) si es conveniente. No hay diferencia de rendimiento. Tenga en cuenta que esto no es una precaución general contra los parámetros estáticos, solo contra uso donde no son necesarios.Tenga en cuenta también que los tipos de contenedores, específicamente pueden necesitar parámetros de tipo en las llamadas a función. Consulte las Preguntas frecuentes Evitar campos con contenedores abstractos para obtener más información."
},

{
    "location": "manual/style-guide.html#Evitar-la-confusion-sobre-si-algo-es-una-instancia-o-un-tipo-1",
    "page": "Guía de Estilo",
    "title": "Evitar la confusion sobre si algo es una instancia o un tipo",
    "category": "section",
    "text": "Conjuntos de definiciones como las siguientes son confusas:foo(::Type{MyType}) = ...\nfoo(::MyType) = foo(MyType)Decida si el concepto en cuestión se escribirá como MyType o MyType(), y sígalo.El estilo preferido es usar instancias por defecto, y solo agregue métodos que incluyan Tipo{MiTipo} más tarde si se vuelven necesarios para resolver algún problema.Si un tipo es efectivamente una enumeración, debe definirse como un tipo único (idealmente, immutable struct o primitivo), con los valores de enumeración como instancias de este. Los constructores y las conversiones pueden verificar si los valores son válidos. Este diseño es preferible a hacer que la enumeración sea un tipo abstracto, con los \"valores\" como subtipos."
},

{
    "location": "manual/style-guide.html#No-abusar-de-las-macros-1",
    "page": "Guía de Estilo",
    "title": "No abusar de las macros",
    "category": "section",
    "text": "Tenga en cuenta cuando una macro realmente podría ser una función en su lugar.Llamar a eval() dentro de una macro es un signo de advertencia particularmente peligroso; significa que la macro solo funcionará cuando se llame al nivel superior. Si tal macro se escribe como una función en su lugar, naturalmente tendrá acceso a los valores en tiempo de ejecución que necesita."
},

{
    "location": "manual/style-guide.html#No-exponer-operaciones-inseguras-al-nivel-de-interfaz-1",
    "page": "Guía de Estilo",
    "title": "No exponer operaciones inseguras al nivel de interfaz",
    "category": "section",
    "text": "Si se tiene un tipo que use un puntero nativo:mutable struct NativeType\n    p::Ptr{UInt8}\n    ...\nendno escriba definiciones como la siguiente:getindex(x::NativeType, i) = unsafe_load(x.p, i)El problema es que los usuarios de este tipo pueden escribir x[i] sin darse cuenta de que la operación no es segura y, luego, ser susceptibles a errores de memoria.Dicha función debería verificar la operación para asegurarse de que sea segura, o incluir unsafe en alguna parte de su nombre para alertar a las personas que la invocan."
},

{
    "location": "manual/style-guide.html#No-sobrecargar-métodos-de-tipos-de-contenedores-base-1",
    "page": "Guía de Estilo",
    "title": "No sobrecargar métodos de tipos de contenedores base",
    "category": "section",
    "text": "Es posible escribir definiciones como la siguiente:show(io::IO, v::Vector{MyType}) = ...Esto proporcionaría una muestra personalizada de vectores con un nuevo tipo de elemento específico. Aunque es tentador, es algo que debe evitarse. El problema es que los usuarios esperarán que un tipo conocido como Vector() se comporte de cierta manera, y la personalización excesiva de su comportamiento puede dificultar el trabajo."
},

{
    "location": "manual/style-guide.html#Evitar-la-piratería-de-tipos-1",
    "page": "Guía de Estilo",
    "title": "Evitar la piratería de tipos",
    "category": "section",
    "text": "La \"Piratería de Tipos\" se refiere a la práctica de extender o redefinir métodos en Base u otros paquetes en tipos que no han definido. En algunos casos, puede la piratería de tipo va a tener un efecto poco negativo. Sin embargo, en casos extremos, incluso puede bloquear Julia (por ejemplo, si la extensión o redefinición de su método hace que se pase una entrada inválida a ccall). La piratería de tipos puede complicar el razonamiento sobre el código y puede introducir incompatibilidades que son difíciles de predecir y diagnosticar.Como ejemplo, suponga que quiere definir la multiplicación en símbolos en un módulo: module A\nimport Base.*\n*(x::Symbol, y::Symbol) = Symbol(x,y)\nendEl problema es que ahora cualquier otro módulo que use Base.* También verá esta definición. Dado que Symbol se define en Base y es utilizado por otros módulos, esto puede cambiar el comportamiento del código no relacionado de forma inesperada. Aquí hay varias alternativas, incluido el uso de un nombre de función diferente o el ajuste de Symbols en otro tipo que defina.Algunas veces, los paquetes acoplados pueden involucrarse en la piratería de tipos para separar las características de las definiciones, especialmente cuando los paquetes fueron diseñados por autores colaboradores, y cuando las definiciones son reutilizables. Por ejemplo, un paquete puede proporcionar algunos tipos útiles para trabajar con colores; otro paquete podría definir métodos para aquellos tipos que permiten conversiones entre espacios de color. Otro ejemplo podría ser un paquete que actúa como un envoltorio delgado para algún código C, que otro paquete podría piratear para implementar una API de nivel superior compatible con Julia."
},

{
    "location": "manual/style-guide.html#Ser-cuidadoso-con-la-igualdad-de-tipos-1",
    "page": "Guía de Estilo",
    "title": "Ser cuidadoso con la igualdad de tipos",
    "category": "section",
    "text": "Por lo general, uno desea utilizar isa() y <: para los tipos de prueba, no ==. La comprobación de los tipos para la igualdad exacta normalmente solo tiene sentido cuando se compara con un tipo concreto conocido (por ejemplo, T == Float64), o si realmente uno sabe lo que está haciendo."
},

{
    "location": "manual/style-guide.html#No-escribir-x-f(x)-1",
    "page": "Guía de Estilo",
    "title": "No escribir x->f(x)",
    "category": "section",
    "text": "Como las funciones de orden superior a menudo se llaman con funciones anónimas, es fácil concluir que esto es deseable o incluso necesario. Pero cualquier función se puede pasar directamente, sin estar \"envuelta\" en una función anónima. En lugar de escribir map (x-> f(x), a), escriba map(f, a)."
},

{
    "location": "manual/style-guide.html#Evitar-usar-floats-para-literales-numericos-en-codigo-generico-cuando-sea-posible-1",
    "page": "Guía de Estilo",
    "title": "Evitar usar floats para literales numericos en codigo generico cuando sea posible",
    "category": "section",
    "text": "Si escribe código genérico que maneja números, y que se puede esperar que se ejecute con muchos tipos de argumentos numéricos diferentes, intente utilizar literales de un tipo numérico que afectarán los argumentos lo menos posible mediante la promoción.Por ejemplo,julia> f(x) = 2.0 * x\nf (generic function with 1 method)\n\njulia> f(1//2)\n1.0\n\njulia> f(1/2)\n1.0\n\njulia> f(1)\n2.0mientras quejulia> g(x) = 2 * x\ng (generic function with 1 method)\n\njulia> g(1//2)\n1//1\n\njulia> g(1/2)\n1.0\n\njulia> g(1)\n2Como puede ver, la segunda versión, donde usamos un literal Int, conserva el tipo de argumento de entrada, mientras que la primera no. Esto se debe a, por ejemplo, promote_type(Int, Float64) == Float64, y la promoción ocurre con la multiplicación. De manera similar, los literales Rational son menos disruptivos que los literales Float64, pero son más perjudiciales que los Ints:julia> h(x) = 2//1 * x\nh (generic function with 1 method)\n\njulia> h(1//2)\n1//1\n\njulia> h(1/2)\n1.0\n\njulia> h(1)\n2//1Por tanto, use literales Int cuando sea posible, con Rational{Int} para literales numéricos no enteros, en orden a hacer nuestro código ms fácil de usar."
},

{
    "location": "manual/faq.html#",
    "page": "Frequently Asked Questions",
    "title": "Frequently Asked Questions",
    "category": "page",
    "text": ""
},

{
    "location": "manual/faq.html#faq-1",
    "page": "Frequently Asked Questions",
    "title": "Frequently Asked Questions",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#Sessions-and-the-REPL-1",
    "page": "Frequently Asked Questions",
    "title": "Sessions and the REPL",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#How-do-I-delete-an-object-in-memory?-1",
    "page": "Frequently Asked Questions",
    "title": "How do I delete an object in memory?",
    "category": "section",
    "text": "Julia does not have an analog of MATLAB's clear function; once a name is defined in a Julia session (technically, in module Main), it is always present.If memory usage is your concern, you can always replace objects with ones that consume less memory.  For example, if A is a gigabyte-sized array that you no longer need, you can free the memory with A = 0.  The memory will be released the next time the garbage collector runs; you can force this to happen with gc()."
},

{
    "location": "manual/faq.html#How-can-I-modify-the-declaration-of-a-type-in-my-session?-1",
    "page": "Frequently Asked Questions",
    "title": "How can I modify the declaration of a type in my session?",
    "category": "section",
    "text": "Perhaps you've defined a type and then realize you need to add a new field.  If you try this at the REPL, you get the error:ERROR: invalid redefinition of constant MyTypeTypes in module Main cannot be redefined.While this can be inconvenient when you are developing new code, there's an excellent workaround.  Modules can be replaced by redefining them, and so if you wrap all your new code inside a module you can redefine types and constants.  You can't import the type names into Main and then expect to be able to redefine them there, but you can use the module name to resolve the scope.  In other words, while developing you might use a workflow something like this:include(\"mynewcode.jl\")              # this defines a module MyModule\nobj1 = MyModule.ObjConstructor(a, b)\nobj2 = MyModule.somefunction(obj1)\n# Got an error. Change something in \"mynewcode.jl\"\ninclude(\"mynewcode.jl\")              # reload the module\nobj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct\nobj2 = MyModule.somefunction(obj1)   # this time it worked!\nobj3 = MyModule.someotherfunction(obj2, c)\n..."
},

{
    "location": "manual/faq.html#functions-1",
    "page": "Frequently Asked Questions",
    "title": "Functions",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#I-passed-an-argument-x-to-a-function,-modified-it-inside-that-function,-but-on-the-outside,-1",
    "page": "Frequently Asked Questions",
    "title": "I passed an argument x to a function, modified it inside that function, but on the outside,",
    "category": "section",
    "text": "the variable x is still unchanged. Why?Suppose you call a function like this:julia> x = 10\n10\n\njulia> function change_value!(y)\n           y = 17\n       end\nchange_value! (generic function with 1 method)\n\njulia> change_value!(x)\n17\n\njulia> x # x is unchanged!\n10In Julia, the binding of a variable x cannot be changed by passing x as an argument to a function. When calling change_value!(x) in the above example, y is a newly created variable, bound initially to the value of x, i.e. 10; then y is rebound to the constant 17, while the variable x of the outer scope is left untouched.But here is a thing you should pay attention to: suppose x is bound to an object of type Array (or any other mutable type). From within the function, you cannot \"unbind\" x from this Array, but you can change its content. For example:julia> x = [1,2,3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> function change_array!(A)\n           A[1] = 5\n       end\nchange_array! (generic function with 1 method)\n\njulia> change_array!(x)\n5\n\njulia> x\n3-element Array{Int64,1}:\n 5\n 2\n 3Here we created a function change_array!(), that assigns 5 to the first element of the passed array (bound to x at the call site, and bound to A within the function). Notice that, after the function call, x is still bound to the same array, but the content of that array changed: the variables A and x were distinct bindings refering to the same mutable Array object."
},

{
    "location": "manual/faq.html#Can-I-use-using-or-import-inside-a-function?-1",
    "page": "Frequently Asked Questions",
    "title": "Can I use using or import inside a function?",
    "category": "section",
    "text": "No, you are not allowed to have a using or import statement inside a function.  If you want to import a module but only use its symbols inside a specific function or set of functions, you have two options:Use import:\nimport Foo\nfunction bar(...)\n    # ... refer to Foo symbols via Foo.baz ...\nend\nThis loads the module Foo and defines a variable Foo that refers to the module, but does not import any of the other symbols from the module into the current namespace.  You refer to the Foo symbols by their qualified names Foo.bar etc.\nWrap your function in a module:\nmodule Bar\nexport bar\nusing Foo\nfunction bar(...)\n    # ... refer to Foo.baz as simply baz ....\nend\nend\nusing Bar\nThis imports all the symbols from Foo, but only inside the module Bar."
},

{
    "location": "manual/faq.html#What-does-the-...-operator-do?-1",
    "page": "Frequently Asked Questions",
    "title": "What does the ... operator do?",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#The-two-uses-of-the-...-operator:-slurping-and-splatting-1",
    "page": "Frequently Asked Questions",
    "title": "The two uses of the ... operator: slurping and splatting",
    "category": "section",
    "text": "Many newcomers to Julia find the use of ... operator confusing. Part of what makes the ... operator confusing is that it means two different things depending on context."
},

{
    "location": "manual/faq.html#...-combines-many-arguments-into-one-argument-in-function-definitions-1",
    "page": "Frequently Asked Questions",
    "title": "... combines many arguments into one argument in function definitions",
    "category": "section",
    "text": "In the context of function definitions, the ... operator is used to combine many different arguments into a single argument. This use of ... for combining many different arguments into a single argument is called slurping:julia> function printargs(args...)\n           @printf(\"%s\\n\", typeof(args))\n           for (i, arg) in enumerate(args)\n               @printf(\"Arg %d = %s\\n\", i, arg)\n           end\n       end\nprintargs (generic function with 1 method)\n\njulia> printargs(1, 2, 3)\nTuple{Int64,Int64,Int64}\nArg 1 = 1\nArg 2 = 2\nArg 3 = 3If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as <-... instead of ...."
},

{
    "location": "manual/faq.html#...-splits-one-argument-into-many-different-arguments-in-function-calls-1",
    "page": "Frequently Asked Questions",
    "title": "... splits one argument into many different arguments in function calls",
    "category": "section",
    "text": "In contrast to the use of the ... operator to denote slurping many different arguments into one argument when defining a function, the ... operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of ... is called splatting:julia> function threeargs(a, b, c)\n           @printf(\"a = %s::%s\\n\", a, typeof(a))\n           @printf(\"b = %s::%s\\n\", b, typeof(b))\n           @printf(\"c = %s::%s\\n\", c, typeof(c))\n       end\nthreeargs (generic function with 1 method)\n\njulia> vec = [1, 2, 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> threeargs(vec...)\na = 1::Int64\nb = 2::Int64\nc = 3::Int64If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as ...-> instead of ...."
},

{
    "location": "manual/faq.html#Types,-type-declarations,-and-constructors-1",
    "page": "Frequently Asked Questions",
    "title": "Types, type declarations, and constructors",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#man-type-stability-1",
    "page": "Frequently Asked Questions",
    "title": "What does \"type-stable\" mean?",
    "category": "section",
    "text": "It means that the type of the output is predictable from the types of the inputs.  In particular, it means that the type of the output cannot vary depending on the values of the inputs. The following code is not type-stable:julia> function unstable(flag::Bool)\n           if flag\n               return 1\n           else\n               return 1.0\n           end\n       end\nunstable (generic function with 1 method)It returns either an Int or a Float64 depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult."
},

{
    "location": "manual/faq.html#faq-domain-errors-1",
    "page": "Frequently Asked Questions",
    "title": "Why does Julia give a DomainError for certain seemingly-sensible operations?",
    "category": "section",
    "text": "Certain operations make mathematical sense but result in errors:julia> sqrt(-2.0)\nERROR: DomainError:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).\nStacktrace:\n [1] sqrt(::Float64) at ./math.jl:425\n\njulia> 2^-5\nERROR: DomainError:\nCannot raise an integer x to a negative power -n.\nMake x a float by adding a zero decimal (e.g. 2.0^-n instead of 2^-n), or write 1/x^n, float(x)^-n, or (x//1)^-n.\nStacktrace:\n [1] power_by_squaring(::Int64, ::Int64) at ./intfuncs.jl:173\n [2] literal_pow(::Base.#^, ::Int64, ::Type{Val{-5}}) at ./intfuncs.jl:208This behavior is an inconvenient consequence of the requirement for type-stability.  In the case of sqrt(), most users want sqrt(2.0) to give a real number, and would be unhappy if it produced the complex number 1.4142135623730951 + 0.0im.  One could write the sqrt() function to switch to a complex-valued output only when passed a negative number (which is what sqrt() does in some other languages), but then the result would not be type-stable and the sqrt() function would have poor performance.In these and other cases, you can get the result you want by choosing an input type that conveys your willingness to accept an output type in which the result can be represented:julia> sqrt(-2.0+0im)\n0.0 + 1.4142135623730951im\n\njulia> 2.0^-5\n0.03125"
},

{
    "location": "manual/faq.html#Why-does-Julia-use-native-machine-integer-arithmetic?-1",
    "page": "Frequently Asked Questions",
    "title": "Why does Julia use native machine integer arithmetic?",
    "category": "section",
    "text": "Julia uses machine arithmetic for integer computations. This means that the range of Int values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:julia> typemax(Int)\n9223372036854775807\n\njulia> ans+1\n-9223372036854775808\n\njulia> -ans\n-9223372036854775808\n\njulia> 2*ans\n0Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as Int128 or BigInt in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) – it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, type-stability is crucial for effective generation of efficient code. If you can't count on the results of integer operations being integers, it's impossible to generate fast, simple code the way C and Fortran compilers do.A variation on this approach, which avoids the appearance of type instability is to merge the Int and BigInt types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach can be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots – large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps – situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab™ does:>> int64(9223372036854775807)\n\nans =\n\n  9223372036854775807\n\n>> int64(9223372036854775807) + 1\n\nans =\n\n  9223372036854775807\n\n>> int64(-9223372036854775808)\n\nans =\n\n -9223372036854775808\n\n>> int64(-9223372036854775808) - 1\n\nans =\n\n -9223372036854775808At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with typemin(Int) or typemax(Int) as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse – saturating integer arithmetic isn't associative. Consider this Matlab computation:>> n = int64(2)^62\n4611686018427387904\n\n>> n + (n - 1)\n9223372036854775807\n\n>> (n + n) - 1\n9223372036854775806This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow is associative. Consider finding the midpoint between integer values lo and hi in Julia using the expression (lo + hi) >>> 1:julia> n = 2^62\n4611686018427387904\n\njulia> (n + 2n) >>> 1\n6917529027641081856See? No problem. That's the correct midpoint between 2^62 and 2^63, despite the fact that n + 2n is -4611686018427387904. Now try it in Matlab:>> (n + 2*n)/2\n\nans =\n\n  4611686018427387904Oops. Adding a >>> operator to Matlab wouldn't help, because saturation that occurs when adding n and 2n has already destroyed the information necessary to compute the correct midpoint.Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions like f(k) = 5k-1. The machine code for this function is just this:julia> code_native(f, Tuple{Int})\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 1\n  leaq  -1(%rdi,%rdi,4), %rax\n  popq  %rbp\n  retq\n  nopl  (%rax,%rax)The actual body of the function is a single leaq instruction, which computes the integer multiply and add at once. This is even more beneficial when f gets inlined into another function:julia> function g(k, n)\n           for i = 1:n\n               k = f(k)\n           end\n           return k\n       end\ng (generic function with 1 methods)\n\njulia> code_native(g, Tuple{Int,Int})\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 2\n  testq %rsi, %rsi\n  jle L26\n  nopl  (%rax)\nSource line: 3\nL16:\n  leaq  -1(%rdi,%rdi,4), %rdi\nSource line: 2\n  decq  %rsi\n  jne L16\nSource line: 5\nL26:\n  movq  %rdi, %rax\n  popq  %rbp\n  retq\n  nopSince the call to f gets inlined, the loop body ends up being just a single leaq instruction. Next, consider what happens if we make the number of loop iterations fixed:julia> function g(k)\n           for i = 1:10\n               k = f(k)\n           end\n           return k\n       end\ng (generic function with 2 methods)\n\njulia> code_native(g,(Int,))\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 3\n  imulq $9765625, %rdi, %rax    # imm = 0x9502F9\n  addq  $-2441406, %rax         # imm = 0xFFDABF42\nSource line: 5\n  popq  %rbp\n  retq\n  nopw  %cs:(%rax,%rax)Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition – neither of which is true of saturating arithmetic – it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this blog post, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow."
},

{
    "location": "manual/faq.html#What-are-the-possible-causes-of-an-UndefVarError-during-remote-execution?-1",
    "page": "Frequently Asked Questions",
    "title": "What are the possible causes of an UndefVarError during remote execution?",
    "category": "section",
    "text": "As the error states, an immediate cause of an UndefVarError on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.julia> module Foo\n           foo() = remotecall_fetch(x->x, 2, \"Hello\")\n       end\n\njulia> Foo.foo()\nERROR: On worker 2:\nUndefVarError: Foo not defined\n[...]The closure x->x carries a reference to Foo, and since Foo is unavailable on node 2, an UndefVarError is thrown.Globals under modules other than Main are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under Main) may cause an UndefVarError to be thrown later.julia> @everywhere module Foo\n           function foo()\n               global gvar = \"Hello\"\n               remotecall_fetch(()->gvar, 2)\n           end\n       end\n\njulia> Foo.foo()\nERROR: On worker 2:\nUndefVarError: gvar not defined\n[...]In the above example, @everywhere module Foo defined Foo on all nodes. However the call to Foo.foo() created a new global binding gvar on the local node, but this was not found on node 2 resulting in an UndefVarError error.Note that this does not apply to globals created under module Main. Globals under module Main are serialized and new bindings created under Main on the remote node.julia> gvar_self = \"Node1\"\n\"Node1\"\n\njulia> remotecall_fetch(()->gvar_self, 2)\n\"Node1\"\n\njulia> remotecall_fetch(whos, 2)\n	From worker 2:	                          Base  41762 KB     Module\n	From worker 2:	                          Core  27337 KB     Module\n	From worker 2:	                           Foo   2477 bytes  Module\n	From worker 2:	                          Main  46191 KB     Module\n	From worker 2:	                     gvar_self     13 bytes  StringThis does not apply to function or type declarations. However, anonymous functions bound to global variables are serialized as can be seen below.julia> bar() = 1\nbar (generic function with 1 method)\n\njulia> remotecall_fetch(bar, 2)\nERROR: On worker 2:\nUndefVarError: #bar not defined\n[...]\n\njulia> anon_bar  = ()->1\n(::#21) (generic function with 1 method)\n\njulia> remotecall_fetch(anon_bar, 2)\n1"
},

{
    "location": "manual/faq.html#Packages-and-Modules-1",
    "page": "Frequently Asked Questions",
    "title": "Packages and Modules",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#What-is-the-difference-between-\"using\"-and-\"importall\"?-1",
    "page": "Frequently Asked Questions",
    "title": "What is the difference between \"using\" and \"importall\"?",
    "category": "section",
    "text": "There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between using and importall is that with using you need to say function Foo.bar(.. to extend module Foo's function bar with a new method, but with importall or import Foo.bar, you only need to say function bar(... and it automatically extends module Foo's function bar.If you use importall, then function Foo.bar(... and function bar(... become equivalent. If you use using, then they are different.The reason this is important enough to have been given separate syntax is that you don't want to accidentally extend a function that you didn't know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use importall, then you'll replace the other module's implementation of bar(s::AbstractString) with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar)."
},

{
    "location": "manual/faq.html#nothingness-and-missing-values-1",
    "page": "Frequently Asked Questions",
    "title": "Nothingness and missing values",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#How-does-\"null\"-or-\"nothingness\"-work-in-Julia?-1",
    "page": "Frequently Asked Questions",
    "title": "How does \"null\" or \"nothingness\" work in Julia?",
    "category": "section",
    "text": "Unlike many languages (for example, C and Java), Julia does not have a \"null\" value. When a reference (variable, object field, or array element) is uninitialized, accessing it will immediately throw an error. This situation can be detected using the isdefined function.Some functions are used only for their side effects, and do not need to return a value. In these cases, the convention is to return the value nothing, which is just a singleton object of type Void. This is an ordinary type with no fields; there is nothing special about it except for this convention, and that the REPL does not print anything for it. Some language constructs that would not otherwise have a value also yield nothing, for example if false; end.For situations where a value exists only sometimes (for example, missing statistical data), it is best to use the Nullable{T} type, which allows specifying the type of a missing value.The empty tuple (()) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.In code written for Julia prior to version 0.4 you may occasionally see None, which is quite different. It is the empty (or \"bottom\") type, a type with no values and no subtypes (except itself). This is now written as Union{} (an empty union type). You will generally not need to use this type."
},

{
    "location": "manual/faq.html#Memory-1",
    "page": "Frequently Asked Questions",
    "title": "Memory",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#Why-does-x-y-allocate-memory-when-x-and-y-are-arrays?-1",
    "page": "Frequently Asked Questions",
    "title": "Why does x += y allocate memory when x and y are arrays?",
    "category": "section",
    "text": "In Julia, x += y gets replaced during parsing by x = x + y. For arrays, this has the consequence that, rather than storing the result in the same location in memory as x, it allocates a new array to store the result.While this behavior might surprise some, the choice is deliberate. The main reason is the presence of immutable objects within Julia, which cannot change their value once created.  Indeed, a number is an immutable object; the statements x = 5; x += 1 do not modify the meaning of 5, they modify the value bound to x. For an immutable, the only way to change the value is to reassign it.To amplify a bit further, consider the following function:function power_by_squaring(x, n::Int)\n    ispow2(n) || error(\"This implementation only works for powers of 2\")\n    while n >= 2\n        x *= x\n        n >>= 1\n    end\n    x\nendAfter a call like x = 5; y = power_by_squaring(x, 4), you would get the expected result: x == 5 && y == 625.  However, now suppose that *=, when used with matrices, instead mutated the left hand side.  There would be two problems:For general square matrices, A = A*B cannot be implemented without temporary storage: A[1,1] gets computed and stored on the left hand side before you're done using it on the right hand side.\nSuppose you were willing to allocate a temporary for the computation (which would eliminate most of the point of making *= work in-place); if you took advantage of the mutability of x, then this function would behave differently for mutable vs. immutable inputs. In particular, for immutable x, after the call you'd have (in general) y != x, but for mutable x you'd have y == x.Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like += and *= work by rebinding new values."
},

{
    "location": "manual/faq.html#Asynchronous-IO-and-concurrent-synchronous-writes-1",
    "page": "Frequently Asked Questions",
    "title": "Asynchronous IO and concurrent synchronous writes",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#Why-do-concurrent-writes-to-the-same-stream-result-in-inter-mixed-output?-1",
    "page": "Frequently Asked Questions",
    "title": "Why do concurrent writes to the same stream result in inter-mixed output?",
    "category": "section",
    "text": "While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.Consider the printed output from the following:julia> @sync for i in 1:3\n           @async write(STDOUT, string(i), \" Foo \", \" Bar \")\n       end\n123 Foo  Foo  Foo  Bar  Bar  BarThis is happening because, while the write call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.print and println \"lock\" the stream during a call. Consequently changing write to println in the above example results in:julia> @sync for i in 1:3\n           @async println(STDOUT, string(i), \" Foo \", \" Bar \")\n       end\n1 Foo  Bar\n2 Foo  Bar\n3 Foo  BarYou can lock your writes with a ReentrantLock like this:julia> l = ReentrantLock()\nReentrantLock(Nullable{Task}(), Condition(Any[]), 0)\n\njulia> @sync for i in 1:3\n           @async begin\n               lock(l)\n               try\n                   write(STDOUT, string(i), \" Foo \", \" Bar \")\n               finally\n                   unlock(l)\n               end\n           end\n       end\n1 Foo  Bar 2 Foo  Bar 3 Foo  Bar"
},

{
    "location": "manual/faq.html#Julia-Releases-1",
    "page": "Frequently Asked Questions",
    "title": "Julia Releases",
    "category": "section",
    "text": ""
},

{
    "location": "manual/faq.html#Do-I-want-to-use-a-release,-beta,-or-nightly-version-of-Julia?-1",
    "page": "Frequently Asked Questions",
    "title": "Do I want to use a release, beta, or nightly version of Julia?",
    "category": "section",
    "text": "You may prefer the release version of Julia if you are looking for a stable code base. Releases generally occur every 6 months, giving you a stable platform for writing code.You may prefer the beta version of Julia if you don't mind being slightly behind the latest bugfixes and changes, but find the slightly faster rate of changes more appealing. Additionally, these binaries are tested before they are published to ensure they are fully functional.You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don't mind if the version available today occasionally doesn't actually work.Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our guidelines for contributing.Links to each of these download types can be found on the download page at https://julialang.org/downloads/. Note that not all versions of Julia are available for all platforms."
},

{
    "location": "manual/faq.html#When-are-deprecated-functions-removed?-1",
    "page": "Frequently Asked Questions",
    "title": "When are deprecated functions removed?",
    "category": "section",
    "text": "Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release."
},

{
    "location": "manual/noteworthy-differences.html#",
    "page": "Diferencias notables con otros idiomas",
    "title": "Diferencias notables con otros idiomas",
    "category": "page",
    "text": ""
},

{
    "location": "manual/noteworthy-differences.html#noteworthy-differences-1",
    "page": "Diferencias notables con otros idiomas",
    "title": "Diferencias notables con otros idiomas",
    "category": "section",
    "text": ""
},

{
    "location": "manual/noteworthy-differences.html#Diferencias-notables-con-MATLAB-1",
    "page": "Diferencias notables con otros idiomas",
    "title": "Diferencias notables con MATLAB",
    "category": "section",
    "text": "Aunque los usuarios de MATLAB pueden encontrar la sintaxis de Julia familiar, Julia no es un clon de MATLAB. Hay importantes diferencias sintácticas y funcionales. Las siguientes son algunas diferencias notables que pueden hacer tropezar a los usuarios de Julia acostumbrados a MATLAB:Los arrays de Julia están indexados con corchetes, A[i, j].\nLos arrays de Julia se asignan por referencia. Después de A = B, el cambio de elementos de B también modificará A.\nLos valores de Julia se pasan y se asignan por referencia. Si una función modifica una matriz, los cambios serán visibles en el código que la invoca.\nJulia no genera automáticamente matrices en una declaración de asignación. Mientras que en MATLAB a(4) = 3.2 puede crear la matriz a = [0 0 0 3.2] y a(5) = 7 puede crecer hasta a = [0 0 0 3.2 7], la declaración correspondiente de Julia a[5] = 7 arroja un error si la longitud de a es menor que 5 o si esta afirmación es el primer uso del identificador a. Julia tiene push!() y append!(), que crecen Vectors mucho más eficientemente que a(end + 1) = val de MATLAB.\nLa unidad imaginaria sqrt(-1) se representa en Julia como im, no como i o j como en MATLAB.\nEn Julia, los números literales sin un punto decimal (como 42) crean números enteros en lugar de números de coma flotante. Se admiten literales enteros arbitrariamente grandes. Como resultado, algunas operaciones como 2^-1 arrojarán un error de dominio ya que el resultado no es un número entero (ver la entrada de preguntas frecuentes sobre errores de dominio para más detalles).\nEn Julia, los valores múltiples se devuelven y se asignan como tuplas, p. (a, b) = (1, 2) o a, b = 1, 2. \"nargout\" de MATLAB, que a menudo se usa en MATLAB para hacer trabajos opcionales basados en el número de valores devueltos, no existe en Julia. En cambio, los usuarios pueden usar argumentos opcionales y de palabras clave para lograr capacidades similares.\nJulia tiene verdaderos arrays unidimensionales. Los vectores columna son de tamaño N, noNx1. Por ejemplo, rand(N) forma una matriz de 1 dimensión.\nEn Julia, [x, y, z] siempre construirá una matriz de 3 elementos que contiene x,y y z.\nPara concatenar en la primera dimensión (\"vertical\") se usa vcat(x, y, z) o se separa con punto y coma ([x; y; z]).\nPara concatenar en la segunda dimensión (\"horizontal\"), se usa hcat(x, y, z) o se separa con espacios ([x y z]).\nPara construir matrices de bloques (concatenando en las dos primeras dimensiones), se usa hvcat() o se combinan espacios y puntos y comas ([a b; c d]).\nEn Julia, a:b ya:b:c construyen objetos Range. Para construir un vector completo como en MATLAB, use collect(a:b). En general, no es necesario llamar a collect aunque. Range actuará como un array normal en la mayoría de los casos, pero es más eficiente porque calcula perezosamente sus valores. Este patrón de creación de objetos especializados en lugar de matrices completas se usa con frecuencia, y también se ve en funciones como linspace, o con iteradores como enumerate y zip. Los objetos especiales se pueden usar principalmente como si fueran matrices normales.\nLas funciones en Julia devuelven valores de su última expresión o la palabra clave return en lugar de enumerar los nombres de las variables a devolver en la definición de la función (ver La palabra clave return para más detalles).\nUn script de Julia puede contener cualquier cantidad de funciones, y todas las definiciones serán visibles externamente cuando se cargue el archivo. Las definiciones de funciones se pueden cargar desde archivos fuera del directorio de trabajo actual.\nEn Julia, las reducciones como sum(), prod(), y max() se realizan sobre cada elemento de un array cuando se llama con un solo argumento, como en sum(A), incluso si A tiene más de una dimensión.\nEn Julia, las funciones como sort() que operan en forma de columnas por defecto (sort(A) es equivalente a sort(A,1)) no tienen un comportamiento especial para Conjuntos 1xN; el argumento se devuelve sin modificar ya que todavía ejecuta sort (A,1). Para ordenar una matriz 1xN como un vector, use sort(A,2).\nIn Julia, if A is a 2-dimensional array, fft(A) computes a 2D FFT. In particular, it is not equivalent to fft(A,1), which computes a 1D FFT acting column-wise.\nEn Julia, los paréntesis se deben usar para llamar a una función con cero argumentos, como en tic() y toc().\nJulia desalienta el uso de punto y coma para finalizar las declaraciones. Los resultados de las declaraciones no se imprimen automáticamente (excepto en el aviso interactivo), y las líneas de código no necesitan terminar con punto y coma. println() o @printf() se pueden usar para imprimir resultados específicos.\nEn Julia, si A yB son matrices, las operaciones de comparación lógica como A == B no devuelven una matriz de booleanos. En cambio, use A == B, y de manera similar para los otros operadores booleanos como <, > y =.\nEn Julia, los operadores &, | y ⊻ (xor) realizan el operaciones a nivel de bit equivalentes a y,o, y xor respectivamente en MATLAB, y tienen precedencia similar a los operadores de bit a bit de Python (a diferencia de C). Pueden operar en escalas o en elementos a través de matrices y se pueden usar para combinar matrices lógicas, pero tenga en cuenta la diferencia en el orden de las operaciones: pueden ser necesarios paréntesis (por ejemplo, para seleccionar elementos de 'A' igual a 1 o 2 use (A. == 1) | (A. == 2)).\nEn Julia, los elementos de una colección se pueden pasar como argumentos a una función usando el operador splat ..., como en xs = [1,2]; f(xs...).\nJulia svd() devuelve valores singulares como un vector en lugar de una matriz diagonal densa.\nEn Julia, ... no se usa para continuar líneas de código. En cambio, las expresiones incompletas continúan automáticamente en la siguiente línea.\nTanto en Julia como en MATLAB, la variable ans se establece en el valor de la última expresión emitida en una sesión interactiva. En Julia, a diferencia de MATLAB, ans no se establece cuando el código de Julia se ejecuta en modo no interactivo.\nLos types de Julia no son compatibles con la adición dinámica de campos en el tiempo de ejecución, a diferencia de classes es de MATLAB. En su lugar, use un Dict.\nEn Julia, cada módulo tiene su propio ámbito / espacio de nombres global, mientras que en MATLAB solo hay un ámbito global.\nEn MATLAB, una forma idiomática de eliminar valores no deseados es usar la indexación lógica, como en la expresión x (x> 3) o en la declaración x (x> 3) = [] para modificar x en -lugar. Por el contrario, Julia proporciona las funciones de orden superior filter() y filter!(), permitiendo a los usuarios escribir filter (z-> z> 3, x) y filter! (z-> z> 3, x) como alternativas a las transliteraciones correspondientes x [x.> 3] y x = x [x.> 3]. El uso de filter!() reduce el uso de matrices temporales.\nEl análogo de extracción (o \"desreferenciación\") de todos los elementos de una matriz de celdas, p. en vertcat(A {:}) en MATLAB, se escribe utilizando el operador splat en Julia, p. como vcat(A ...)."
},

{
    "location": "manual/noteworthy-differences.html#Diferencias-notables-con-R-1",
    "page": "Diferencias notables con otros idiomas",
    "title": "Diferencias notables con R",
    "category": "section",
    "text": "Uno de los objetivos de Julia es proporcionar un lenguaje efectivo para el análisis de datos y la programación estadística. Para los usuarios que vienen a Julia de R, estas son algunas diferencias notables:Las comillas simples de Julia encierran caracteres, no cadenas.\nJulia puede crear subcadenas indexando en cadenas. En R, las cadenas deben convertirse en vectores de caracteres antes de crear subcadenas.\nEn Julia, como Python pero a diferencia de R, las cadenas se pueden crear con comillas triples \"\"\" ... \"\"\". Esta sintaxis es conveniente para construir cadenas que contienen saltos de línea.\nEn Julia, las variables se especifican utilizando el operador splat ..., que siempre sigue el nombre de una variable específica, a diferencia de R, para el que ... puede ocurrir de forma aislada.\nEn Julia, el módulo es mod(a, b), no a %% b. % en Julia es el operador restante.\nEn Julia, no todas las estructuras de datos admiten la indexación lógica. Además, la indexación lógica en Julia solo se admite con vectores de longitud igual al objeto que se indexa. Por ejemplo:\nEn R, c (1, 2, 3, 4) [c (TRUE, FALSE)] es equivalente a c (1, 3).\nEn R, c (1, 2, 3, 4) [c (TRUE, FALSE, TRUE, FALSE)] es equivalente a c (1, 3).\nEn Julia, [1, 2, 3, 4] [[verdadero, falso]] arroja un BoundsError.\nEn Julia, [1, 2, 3, 4] [[verdadero, falso, verdadero, falso]] produce [1, 3].\nComo en muchos lenguajes, Julia no siempre permite operaciones en vectores de diferentes longitudes, a diferencia de R, donde los vectores solo necesitan compartir un rango de índice común. Por ejemplo, c(1, 2, 3, 4) + c (1, 2) es válido R pero el equivalente [1, 2, 3, 4] + [1, 2] arrojará un error en Julia.\nJulia map() toma primero la función, luego sus argumentos, a diferencia de lapply (<structure>, function, ...) en R. De forma similar, el equivalente de Julia de apply(X, MARGIN , FUN, ...) en R esmapslices() donde la función es el primer argumento.\nLa aplicación multivariada en R, es decir, mapply(choose, 11:13, 1: 3), se puede escribir como broadcast(binomial, 11:13, 1:3) en Julia. Equivalentemente, Julia ofrece una sintaxis de punto más corta para vectorizar funciones binomial.(11:13, 1: 3).\nJulia usa end para denotar el final de bloques condicionales, comoif, bloques de bucle, como while /for, y funciones. En lugar de la sentencia de una línea if (cond), Julia permite las declaraciones de la forma if cond; declaración; end, cond && statement y !cond || declaración. Las declaraciones de asignación en las dos últimas sintaxis deben estar explícitamente entrelazadas entre paréntesis, por ejemplo, cond && (x = value).\nEn Julia, <-,<< -y->no son operadores de asignación.\nEn Julia, -> crea una función anónima, como en Python.\nJulia construye vectores usando corchetes. El [1, 2, 3] de Julia es el equivalente de R a c(1, 2, 3).\nEl operador de Julia * puede realizar la multiplicación de la matriz, a diferencia de R. Si A yB son matrices, entonces A * B denota una multiplicación de matriz en Julia, equivalente a R A %*% B. En R, esta misma notación realizaría un producto de elemento (Hadamard). Para obtener la operación de multiplicación por elementos, debe escribir A.*B en Julia.\nJulia realiza la transposición de la matriz utilizando el operador .' y la transposición conjugada con el operador '. Por lo tanto, A.' de Julia es equivalente a t(A)en R.\nJulia no requiere paréntesis cuando escribe bucles if ofor / while: usefor i en [1, 2, 3]en lugar defor (i en c (1, 2, 3) ) o if i == 1 en lugar de if (i == 1).\nJulia no trata los números 0 y1 como booleanos. No puede escribir if(1) en Julia, porque las sentencias if solo aceptan booleanos. En su lugar, puede escribir if true , if Bool(1), oif 1 == 1.\nJulia no proporciona nrow yncol. En su lugar, use size(M,1) para nrow(M) y size(M,2) para ncol(M).\nJulia tiene cuidado de distinguir escalares, vectores y matrices. En R, 1 y c(1) son lo mismo. En Julia, no se pueden usar indistintamente. Un resultado potencialmente confuso de esto es que x'* y para los vectores x e y es un vector de 1 elemento, no escalar. Para obtener un escalar, use dot(x, y).\nJulia's diag() y diagm() no son como R's.\nJulia no puede asignar los resultados de llamadas a funciones en el lado izquierdo de una operación de asignación: no puede escribir diag(M) = ones(n).\nJulia desaconseja llenar el espacio de nombres principal con funciones. La mayoría de las funcionalidades estadísticas para Julia se encuentran en paquetes bajo la organización JuliaStats. Por ejemplo:\nLas funciones relacionadas con las distribuciones de probabilidad son proporcionadas por el Paquete Distributions.\nEl paquete DataFrames proporciona el tipo de datos DataFrame.\nEl paquete GLM proporciona modelos lineales generalizados.\nJulia proporciona tuplas y tablas hash reales, pero no listas R-style. Al devolver varios elementos, normalmente debe usar una tupla: en lugar de list(a = 1, b = 2), use (1, 2).\nJulia anima a los usuarios a escribir sus propios tipos, que son más fáciles de usar que los objetos S3 o S4 de R. El sistema de despacho múltiple de Julia significa que table(x::TypeA) y table(x::TypeB) actúan como R table.TypeA(x) y table.TypeB(x).\nEn Julia, los valores se pasan y se asignan por referencia. Si una función modifica una matriz, los cambios serán visibles en el código que invoca la función. Esto es muy diferente de R y permite que las nuevas funciones operen en estructuras de datos de gran tamaño de manera mucho más eficiente.\nEn Julia, los vectores y las matrices se concatenan usando hcat(), vcat() y hvcat(), no c , rbind ycbind como en R.\nEn Julia, un rango como a:b no es una abreviatura para un vector como en R, sino que es un Range especializado que se usa para la iteración sin una gran sobrecarga de memoria. Para convertir un rango en un vector, use collect(a:b).\nLas funciones de Julia max() y min() son el equivalente de pmax y pmin respectivamente en R, pero ambos argumentos deben tener las mismas dimensiones. Mientras que maximum() y minimum() reemplazan max y min en R, hay diferencias importantes.\nLas funciones de Julia  sum(), prod(), maximum(), y minimum() son diferentes de sus contrapartes en R. Todos aceptan uno o dos argumentos. El primer argumento es una colección iterable tal como una matriz. Si hay un segundo argumento, este argumento indica las dimensiones sobre las cuales se lleva a cabo la operación. Por ejemplo, deje A = [[1 2], [3 4]] en Julia y B = rbind(c(1,2), c(3,4)) sea la misma matriz en R. Luego sum(A) da el mismo resultado que sum(B), pero sum(A, 1) es un vector de fila que contiene la suma sobre cada columna y suma (A, 2) es un vector de columna que contiene la suma sobre cada fila. Esto contrasta con el comportamiento de R, donde suma (B, 1) = 11 ysuma (B, 2) = 12. Si el segundo argumento es un vector, entonces especifica todas las dimensiones sobre las cuales se realiza la suma, por ejemplo, suma (A, [1,2]) = 10. Cabe señalar que no hay errores de comprobación con respecto al segundo argumento.\nJulia tiene varias funciones que pueden mutar sus argumentos. Por ejemplo, tiene ambos sort() y sort!().\nEn R, el rendimiento requiere vectorización. En Julia, casi todo lo contrario es cierto: el código de mejor rendimiento a menudo se logra mediante el uso de bucles devectorized.\nJulia es evaluada con entusiasmo y no es compatible con la evaluación perezosa de estilo R. Para la mayoría de los usuarios, esto significa que hay muy pocas expresiones sin comillas o nombres de columnas.\nJulia no admite el tipo NULL.\nA Julia le falta el equivalente de \"asignar\" o \"obtener\" de R.\nEn Julia, return no requiere paréntesis.\nEn R, una forma idiomática de eliminar valores no deseados es usar indexación lógica, como en la expresión x[x> 3] o en la declaración x = x[x > 3] para modificar x lugar. Por el contrario, Julia proporciona las funciones de orden superior filter() y filter!(), permitiendo a los usuarios escribir filter (z -> z>3, x)yfilter! (z-> z> 3, x)como alternativas a las transliteraciones correspondientesx[x .> 3]yx = x [x.> 3]. El uso de filter!() reduce el uso de matrices temporales."
},

{
    "location": "manual/noteworthy-differences.html#Diferencias-notables-con-Python-1",
    "page": "Diferencias notables con otros idiomas",
    "title": "Diferencias notables con Python",
    "category": "section",
    "text": "Julia requiere end para finalizar un bloque. A diferencia de Python, Julia no tiene la palabra clave pass.\nEn Julia, la indexación de matrices, cadenas, etc. se basa en 1 y no en 0.\nLa indexación de segmentos de Julia incluye el último elemento, a diferencia de Python. a[2:3] en Julia es a[1:3] en Python.\nJulia no admite índices negativos. En particular, el último elemento de una lista o matriz se indexa con end en Julia, no-1 como en Python.\nLos bloques for,if, while, etc. de Julia terminan con la palabra clave end. El nivel de sangría no es significativo ya que está en Python.\nJulia no tiene sintaxis de continuación de línea: si, al final de una línea, la entrada hasta ahora es una expresión completa, se considera hecho; de lo contrario, la entrada continúa. Una forma de forzar que una expresión continúe es envolverla entre paréntesis.\nLos arrays de Julia son column major (orden de Fortran) mientras que los arrays de NumPy son row major (orden de C) por defecto. Para obtener un rendimiento óptimo al alternar sobre matrices, el orden de los bucles debe invertirse en Julia en relación con NumPy (consulte la sección correspondiente de Sugerencias de rendimiento).\nLos operadores de actualización de Julia (por ejemplo, +=, -=, ...) no están en el lugar mientras que los de NumPy sí lo están. Esto significa A = ones(4); B = A; B += 3 no cambia los valores en A, sino que vuelve a enlazar el nombreB con el resultado del lado derecho B = B + 3, que es una nueva matriz. Para la operación in-situ, use B[:] += 3 (vea también operadores de punto), loops explícitos, o InplaceOps.jl.\nJulia evalúa los valores predeterminados de los argumentos de la función cada vez que se invoca el método, a diferencia de Python, donde los valores predeterminados se evalúan solo una vez cuando se define la función. Por ejemplo, la función f(x = rand()) = x devuelve un nuevo número aleatorio cada vez que se invoca sin argumentos. Por otro lado, la función g (x = [1,2]) = push!(X, 3) devuelve [1,2,3] cada vez que se llama como g().\nEn Julia % es el operador restante, mientras que en Python es el módulo."
},

{
    "location": "manual/noteworthy-differences.html#Noteworthy-differences-from-C/C-1",
    "page": "Diferencias notables con otros idiomas",
    "title": "Noteworthy differences from C/C++",
    "category": "section",
    "text": "Los arrays de Julia están indexados con corchetes y pueden tener más de una dimensión A[i,j]. Esta sintaxis no es apropiada para una referencia a un puntero o dirección como en C/C ++. Consulte la documentación de Julia sobre la sintaxis para la construcción de matrices (ha cambiado entre versiones).\nEn Julia, la indexación de matrices, cadenas, etc. se basa en 1 y no en 0.\nLos arrays de Julia se asignan por referencia. Después de A = B, el cambio de elementos deB también modificará A. Los operadores de actualización como + = no funcionan in situ, son equivalentes a A = A + B, que vuelve a enlazar el lado izquierdo con el resultado de la expresión del lado derecho.\nLos arrays de Julia column major (ordenación de Fortran), mientras que los conjuntos de C/C++ son row major. Para obtener un rendimiento óptimo al realizar un bucle sobre matrices, el orden de los bucles debe invertirse en Julia en relación con C/C++ (consulte la sección correspondiente de Sugerencias de rendimiento).\nLos valores de Julia se pasan y se asignan por referencia. Si una función modifica una matriz, los cambios serán visibles en la persona que llama.\nEn Julia, el espacio en blanco es significativo, a diferencia de C/C ++, por lo que se debe tener cuidado al agregar/eliminar espacios en blanco de un programa Julia.\nEn Julia, los números literales sin un punto decimal (como 42) crean enteros con signo, de tipoInt, pero los literales demasiado grandes para caber en el tamaño de palabra de la máquina se promocionarán automáticamente a un tipo de tamaño mayor, como Int64 (siInt es Int32),Int128, o el tipo arbitrariamente grande BigInt. No hay sufijos literales numéricos, tales como L,LL, U,UL, ULL para indicar unsigned y/o signed vs. unsigned. Los literales decimales siempre se firman y los literales hexadecimales (que comienzan con 0x como C / C ++), no tienen signo. Los literales hexadecimales también, a diferencia de C / C ++ / Java y, a diferencia de los literales decimales en Julia, tienen un tipo basado en la longitud del literal, incluidos los primeros 0. Por ejemplo, 0x0 y 0x00 tienen el tipo UInt8,0x000 y 0x0000 tienen el tipo UInt16, luego los literales con 5 a 8 dígitos hexadecimales tienen se consideran UInt32, de 9 a 16 dígitos hexadecimalesUInt64 y de 17 a 32 dígitos hexadecibles UInt128. Esto debe tenerse en cuenta al definir máscaras hexadecimales, por ejemplo ~0xf == 0xf0 es muy diferente de~0x000f == 0xfff0. Los literales de 64 bit Float64 y 32 bit Float32 los bit se expresan como 1.0 y1.0f0 respectivamente. Los literales de punto flotante se redondean (y no se promocionan al tipo BigFloat) si no se pueden representar exactamente. Los literales de coma flotante tienen un comportamiento más cercano a C/C ++. Los literales Octal (prefijado con 0o) y binario (prefijado con0b) también se tratan como sin signo.\nLos literales de cadenas se pueden delimitar con los literales delimitados por \" o \"\"\", que pueden contener caracteres \" sin citarlo como \"\\\" \" Los literales de cadena pueden tener valores de otras variables o expresiones interpoladas en ellos, indicadas por $nombrevariable o$(expresión), que evalúa el nombre de la variable o la expresión en el contexto de la función.\n// indica un número Rational, y no un comentario de una sola línea (que es #en Julia)\n#= indica el comienzo de un comentario de líneas múltiples, y =# lo finaliza.\nLas funciones en Julia devuelven valores de sus últimas expresiones o la palabra clave return. Pueden devolverse múltiplesvalores desde funciones y asignarse como tuplas, por ejemplo, (a, b) = myfunction () o a, b = myfunction (), en lugar de tener que pasar los punteros a los valores como debería hacerse en C / C ++ (es decir, a = myfunction (&b).Julia no requiere el uso de punto y coma para finalizar las declaraciones. Los resultados de las expresiones no se imprimen automáticamente (excepto en el prompt interactivo, es decir, el REPL), y las líneas de código no necesitan terminar con punto y coma. println() o @printf() se pueden usar para imprimir resultados específicos. En REPL, ; se puede usar para suprimir la salida. ; también tiene un significado diferente dentro de [], algo de lo que hay que tener cuidado. ; se puede usar para separar expresiones en una sola línea, pero no son estrictamente necesarias en muchos casos, y son más una ayuda para la legibilidad.\nEn Julia, el operador ⊻ (xor) realiza la operación XOR bit a bit, es decir ^ en C / C++. Además, los operadores bit a bit no tienen la misma precedencia que C / C++, por lo que puede ser necesario un paréntesis.\nJulia ^ es exponenciación (pow), no bit a bit XOR como en C / C++ (use ⊻, o xor, en Julia)\nJulia tiene dos operadores de desplazamiento a la derecha, >> y >>>. >>> realiza un desplazamiento aritmético, >> siempre realiza un desplazamiento lógico, a diferencia de C / C ++, donde el significado de >> depende del tipo del valor que se está desplazando.\nJulia's -> crea una función anónima, no accede a un miembro a través de un puntero.\nJulia no requiere paréntesis cuando escribe declaraciones if ofor / while loops: usefor i en [1, 2, 3]en lugar defor (int i = 1; i <= 3; i ++)ysi i == 1 en lugar de if (i == 1).\nJulia no trata los números 0 y1 como booleanos. No puede escribir if (1) en Julia, porque las sentencias if solo aceptan booleanos. En su lugar, puede escribir if true,if Bool (1), oif 1 == 1.\nJulia usa end para denotar el final de bloques condicionales, comoif, bloques de bucle, como while /for, y funciones. En lugar de la sentencia de una línea if (cond), Julia permite las declaraciones de la forma if cond; declaración; end, cond && statement y !cond || declaración. Las declaraciones de asignación en las dos últimas sintaxis deben estar explícitamente entrelazadas entre paréntesis, p. cond && (x = value), debido a la precedencia del operador.\nJulia no tiene sintaxis de continuación de línea: si, al final de una línea, la entrada hasta ahora es una expresión completa, se considera hecho; de lo contrario, la entrada continúa. Una forma de forzar que una expresión continúe es envolverla entre paréntesis.\nLas macros de Julia operan en expresiones analizadas, en lugar del texto del programa, lo que les permite realizar transformaciones sofisticadas del código de Julia. Los nombres de macro comienzan con el carácter @, y tienen una sintaxis similar a la función, @mymacro (arg1, arg2, arg3), y una sintaxis similar a una declaración, @mymacro arg1 arg2 arg3. Las formas son intercambiables; la forma de función es particularmente útil si la macro aparece dentro de otra expresión, y es a menudo más clara. La forma similar a una declaración se usa a menudo para anotar bloques, como en la construcción paralela for:@parallel para i en 1: n; # = cuerpo = #; fin. Donde el final de la macroconstrucción puede no ser claro, use la forma similar a la función.\nJulia ahora tiene un tipo de enumeración, expresado con el macro @enum (name, value1, value2, ...) Por ejemplo: @enum (Fruit, banana = 1, apple, pear)\nPor convención, las funciones que modifican sus argumentos tienen un ! Al final del nombre, por ejemplo push!.\nEn C ++, de forma predeterminada, tiene despacho estático, es decir, necesita anotar una función como virtual, para tener un despacho dinámico. Por otro lado, en Julia todos los métodos son \"virtuales\" (aunque es más general que eso ya que los métodos se envían en cada tipo de argumento, no solo this, usando la regla de declaración más específica)."
},

{
    "location": "manual/unicode-input.html#",
    "page": "Entrada Unicode",
    "title": "Entrada Unicode",
    "category": "page",
    "text": ""
},

{
    "location": "manual/unicode-input.html#unicode-input-1",
    "page": "Entrada Unicode",
    "title": "Entrada Unicode",
    "category": "section",
    "text": "La siguiente tabla enumera los caracteres Unicode que pueden ingresarse mediante la terminación de pestañas de las abreviaturas similares a LaTeX en Julia REPL (y en otros entornos de edición). También puede obtener información sobre cómo escribir un símbolo ingresándolo en la ayuda REPL, es decir, escribiendo ? Y luego ingresando el símbolo en REPL (por ejemplo, mediante copiar y pegar desde algún lugar donde vio el símbolo).warning: Warning\nPuede parecer que esta tabla contiene caracteres faltantes en la segunda columna,  o incluso muestra caracteres que son inconsistentes con los caracteres tal como  se representan en Julia REPL. En estos casos, se recomienda encarecidamente a los  usuarios que comprueben la elección de las fuentes en su navegador y entorno REPL,  ya que existen problemas conocidos con los glifos en muchas fuentes.#\n# Generate a table containing all LaTeX and Emoji tab completions available in the REPL.\n#\n\nfunction tab_completions(symbols...)\n    completions = Dict{String, Vector{String}}()\n    for each in symbols, (k, v) in each\n        completions[v] = push!(get!(completions, v, String[]), k)\n    end\n    return completions\nend\n\nfunction unicode_data()\n    file = normpath(JULIA_HOME, \"..\", \"..\", \"doc\", \"UnicodeData.txt\")\n    names = Dict{UInt32, String}()\n    open(file) do unidata\n        for line in readlines(unidata)\n            id, name, desc = split(line, \";\")[[1, 2, 11]]\n            codepoint = parse(UInt32, \"0x$id\")\n            names[codepoint] = titlecase(lowercase(name == \"\" ? desc : desc == \"\" ? name : \"$name / $desc\"))\n        end\n    end\n    return names\nend\n\n# Prepend a dotted circle ('◌' i.e. '\\u25CC') to combining characters\nfunction fix_combining_chars(char)\n    cat = Base.UTF8proc.category_code(char)\n    return string(cat == 6 || cat == 8 ? \"◌\" : \"\", char)\nend\n\n\nfunction table_entries(completions, unicode_dict)\n    entries = [[\n        \"Code point(s)\", \"Character(s)\",\n        \"Tab completion sequence(s)\", \"Unicode name(s)\"\n    ]]\n    for (chars, inputs) in sort!(collect(completions), by = first)\n        code_points, unicode_names, characters = String[], String[], String[]\n        for char in chars\n            push!(code_points, \"U+$(uppercase(hex(char, 5)))\")\n            push!(unicode_names, get(unicode_dict, UInt32(char), \"(No Unicode name)\"))\n            push!(characters, isempty(characters) ? fix_combining_chars(char) : \"$char\")\n        end\n        push!(entries, [\n            join(code_points, \" + \"), join(characters),\n            join(inputs, \", \"), join(unicode_names, \" + \")\n        ])\n    end\n    return Markdown.Table(entries, [:l, :l, :l, :l])\nend\n\ntable_entries(\n    tab_completions(\n        Base.REPLCompletions.latex_symbols,\n        Base.REPLCompletions.emoji_symbols\n    ),\n    unicode_data()\n)"
},

{
    "location": "stdlib/base.html#",
    "page": "Essentials",
    "title": "Essentials",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/base.html#essentials-1",
    "page": "Essentials",
    "title": "Essentials",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/base.html#Introducción-1",
    "page": "Essentials",
    "title": "Introducción",
    "category": "section",
    "text": "La librería estándar de Julia contiene un rango de funciones y marcos apropiados para realizar  computación científica y numérica, pero es también tan amplia como la de muchos lenguajes de  programación de propósito general. También hay funcionalidad adicional disponible en una  creciente colección de paquetes disponibles. Las funciones están agrupadas abajo por temas.Algunas notas generales:Excepto para las funciones en los módulos predefinidos (Pkg, Collections, Test y Profile), todas las funciones documentadas aquí están disponibles  para ser usadas en programas directamente.Para usar funciones de módulos, usar import Module para importar el módulo, y Module.fn(x) para usar las funciones.Alternativamente using Module importará todas las funciones exportadas por el módulo en el espacio de nombres actual.Por convenio, los nombres de funciones que acaban con un signo de admiración (!) modifican sus argumentos. Algunas funciones tienen las dos versiones (con y sin modificación  de los argumentos)."
},

{
    "location": "stdlib/base.html#Base.exit",
    "page": "Essentials",
    "title": "Base.exit",
    "category": "Function",
    "text": "exit([code])\n\nQuit (or control-D at the prompt). The default exit code is zero, indicating that the processes completed successfully.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.quit",
    "page": "Essentials",
    "title": "Base.quit",
    "category": "Function",
    "text": "quit()\n\nQuit the program indicating that the processes completed successfully. This function calls exit(0) (see exit).\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.atexit",
    "page": "Essentials",
    "title": "Base.atexit",
    "category": "Function",
    "text": "atexit(f)\n\nRegister a zero-argument function f() to be called at process exit. atexit() hooks are called in last in first out (LIFO) order and run before object finalizers.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.atreplinit",
    "page": "Essentials",
    "title": "Base.atreplinit",
    "category": "Function",
    "text": "atreplinit(f)\n\nRegister a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of f is the REPL object. This function should be called from within the .juliarc.jl initialization file.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isinteractive",
    "page": "Essentials",
    "title": "Base.isinteractive",
    "category": "Function",
    "text": "isinteractive() -> Bool\n\nDetermine whether Julia is running an interactive session.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.whos",
    "page": "Essentials",
    "title": "Base.whos",
    "category": "Function",
    "text": "whos(io::IO=STDOUT, m::Module=current_module(), pattern::Regex=r\"\")\n\nPrint information about exported global variables in a module, optionally restricted to those matching pattern.\n\nThe memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.summarysize",
    "page": "Essentials",
    "title": "Base.summarysize",
    "category": "Function",
    "text": "Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -> Int\n\nCompute the amount of memory used by all unique objects reachable from the argument.\n\nKeyword Arguments\n\nexclude: specifies the types of objects to exclude from the traversal.\nchargeall: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.edit-Tuple{AbstractString,Integer}",
    "page": "Essentials",
    "title": "Base.edit",
    "category": "Method",
    "text": "edit(path::AbstractString, line::Integer=0)\n\nEdit a file or directory optionally providing a line number to edit the file at. Returns to the julia prompt when you quit the editor. The editor can be changed by setting JULIA_EDITOR, VISUAL or EDITOR as an environment variable.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.edit-Tuple{Any}",
    "page": "Essentials",
    "title": "Base.edit",
    "category": "Method",
    "text": "edit(function, [types])\n\nEdit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. The editor can be changed by setting JULIA_EDITOR, VISUAL or EDITOR as an environment variable.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@edit",
    "page": "Essentials",
    "title": "Base.@edit",
    "category": "Macro",
    "text": "@edit\n\nEvaluates the arguments to the function or macro call, determines their types, and calls the edit function on the resulting expression.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.less-Tuple{AbstractString}",
    "page": "Essentials",
    "title": "Base.less",
    "category": "Method",
    "text": "less(file::AbstractString, [line::Integer])\n\nShow a file using the default pager, optionally providing a starting line number. Returns to the julia prompt when you quit the pager.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.less-Tuple{Any}",
    "page": "Essentials",
    "title": "Base.less",
    "category": "Method",
    "text": "less(function, [types])\n\nShow the definition of a function using the default pager, optionally specifying a tuple of types to indicate which method to see.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@less",
    "page": "Essentials",
    "title": "Base.@less",
    "category": "Macro",
    "text": "@less\n\nEvaluates the arguments to the function or macro call, determines their types, and calls the less function on the resulting expression.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.clipboard-Tuple{Any}",
    "page": "Essentials",
    "title": "Base.clipboard",
    "category": "Method",
    "text": "clipboard(x)\n\nSend a printed form of x to the operating system clipboard (\"copy\").\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.clipboard-Tuple{}",
    "page": "Essentials",
    "title": "Base.clipboard",
    "category": "Method",
    "text": "clipboard() -> AbstractString\n\nReturn a string with the contents of the operating system clipboard (\"paste\").\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.reload",
    "page": "Essentials",
    "title": "Base.reload",
    "category": "Function",
    "text": "reload(name::AbstractString)\n\nForce reloading of a package, even if it has been loaded before. This is intended for use during package development as code is modified.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.require",
    "page": "Essentials",
    "title": "Base.require",
    "category": "Function",
    "text": "require(module::Symbol)\n\nThis function is part of the implementation of using / import, if a module is not already defined in Main. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).\n\nLoads a source file, in the context of the Main module, on every active node, searching standard locations for files. require is considered a top-level operation, so it sets the current include path but does not use it to search for files (see help for include). This function is typically used to load library code, and is implicitly called by using to load packages.\n\nWhen searching for files, require first looks for package code under Pkg.dir(), then tries paths in the global array LOAD_PATH. require is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.compilecache",
    "page": "Essentials",
    "title": "Base.compilecache",
    "category": "Function",
    "text": "Base.compilecache(module::String)\n\nCreates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in LOAD_CACHE_PATH[1], which defaults to ~/.julia/lib/VERSION. See Module initialization and precompilation for important notes.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.__precompile__",
    "page": "Essentials",
    "title": "Base.__precompile__",
    "category": "Function",
    "text": "__precompile__(isprecompilable::Bool=true)\n\nSpecify whether the file calling this function is precompilable. If isprecompilable is true, then __precompile__ throws an exception when the file is loaded by using/import/require unless the file is being precompiled, and in a module file it causes the module to be automatically precompiled when it is imported. Typically, __precompile__() should occur before the module declaration in the file, or better yet VERSION >= v\"0.4\" && __precompile__() in order to be backward-compatible with Julia 0.3.\n\nIf a module or file is not safely precompilable, it should call __precompile__(false) in order to throw an error if Julia attempts to precompile it.\n\n__precompile__() should not be used in a module unless all of its dependencies are also using __precompile__(). Failure to do so can result in a runtime error when loading the module.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.include",
    "page": "Essentials",
    "title": "Base.include",
    "category": "Function",
    "text": "include(path::AbstractString)\n\nEvaluate the contents of the input source file in the current context. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to include will search relative to that path. All paths refer to files on node 1 when running in parallel, and files will be fetched from node 1. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.include_string",
    "page": "Essentials",
    "title": "Base.include_string",
    "category": "Function",
    "text": "include_string(code::AbstractString, filename::AbstractString=\"string\")\n\nLike include, except reads code from the given string rather than from a file. Since there is no file path involved, no path processing or fetching from node 1 is done.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.include_dependency",
    "page": "Essentials",
    "title": "Base.include_dependency",
    "category": "Function",
    "text": "include_dependency(path::AbstractString)\n\nIn a module, declare that the file specified by path (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.\n\nThis is only needed if your module depends on a file that is not used via include. It has no effect outside of compilation.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Docs.apropos",
    "page": "Essentials",
    "title": "Base.Docs.apropos",
    "category": "Function",
    "text": "apropos(string)\n\nSearch through all documentation for a string, ignoring case.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.which-Tuple{Any,Any}",
    "page": "Essentials",
    "title": "Base.which",
    "category": "Method",
    "text": "which(f, types)\n\nReturns the method of f (a Method object) that would be called for arguments of the given types.\n\nIf types is an abstract type, then the method that would be called by invoke is returned.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.which-Tuple{Symbol}",
    "page": "Essentials",
    "title": "Base.which",
    "category": "Method",
    "text": "which(symbol)\n\nReturn the module in which the binding for the variable referenced by symbol was created.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@which",
    "page": "Essentials",
    "title": "Base.@which",
    "category": "Macro",
    "text": "@which\n\nApplied to a function or macro call, it evaluates the arguments to the specified call, and returns the Method object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the which function.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.methods",
    "page": "Essentials",
    "title": "Base.methods",
    "category": "Function",
    "text": "methods(f, [types])\n\nReturns the method table for f.\n\nIf types is specified, returns an array of methods whose types match.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.methodswith",
    "page": "Essentials",
    "title": "Base.methodswith",
    "category": "Function",
    "text": "methodswith(typ[, module or function][, showparents::Bool=false])\n\nReturn an array of methods with an argument of type typ.\n\nThe optional second argument restricts the search to a particular module or function (the default is all modules, starting from Main).\n\nIf optional showparents is true, also return arguments with a parent type of typ, excluding type Any.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@show",
    "page": "Essentials",
    "title": "Base.@show",
    "category": "Macro",
    "text": "@show\n\nShow an expression and result, returning the result.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.versioninfo",
    "page": "Essentials",
    "title": "Base.versioninfo",
    "category": "Function",
    "text": "versioninfo(io::IO=STDOUT, verbose::Bool=false)\n\nPrint information about the version of Julia in use. If the verbose argument is true, detailed system information is shown as well.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.workspace",
    "page": "Essentials",
    "title": "Base.workspace",
    "category": "Function",
    "text": "workspace()\n\nReplace the top-level module (Main) with a new one, providing a clean workspace. The previous Main module is made available as LastMain. A previously-loaded package can be accessed using a statement such as using LastMain.Package.\n\nThis function should only be used interactively.\n\n\n\n"
},

{
    "location": "stdlib/base.html#ans",
    "page": "Essentials",
    "title": "ans",
    "category": "Keyword",
    "text": "ans\n\nA variable referring to the last computed value, automatically set at the interactive prompt.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Moviéndose-1",
    "page": "Essentials",
    "title": "Moviéndose",
    "category": "section",
    "text": "Base.exit\nBase.quit\nBase.atexit\nBase.atreplinit\nBase.isinteractive\nBase.whos\nBase.summarysize\nBase.edit(::AbstractString, ::Integer)\nBase.edit(::Any)\nBase.@edit\nBase.less(::AbstractString)\nBase.less(::Any)\nBase.@less\nBase.clipboard(::Any)\nBase.clipboard()\nBase.reload\nBase.require\nBase.compilecache\nBase.__precompile__\nBase.include\nBase.include_string\nBase.include_dependency\nBase.Docs.apropos\nBase.which(::Any, ::Any)\nBase.which(::Symbol)\nBase.@which\nBase.methods\nBase.methodswith\nBase.@show\nBase.versioninfo\nBase.workspace\nans"
},

{
    "location": "stdlib/base.html#Core.:===",
    "page": "Essentials",
    "title": "Core.:===",
    "category": "Function",
    "text": "===(x,y) -> Bool\n≡(x,y) -> Bool\n\nDetermine whether x and y are identical, in the sense that no program could distinguish them. Compares mutable objects by address in memory, and compares immutable objects (such as numbers) by contents at the bit level. This function is sometimes called egal.\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a == b\ntrue\n\njulia> a === b\nfalse\n\njulia> a === a\ntrue\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.isa",
    "page": "Essentials",
    "title": "Core.isa",
    "category": "Function",
    "text": "isa(x, type) -> Bool\n\nDetermine whether x is of the given type. Can also be used as an infix operator, e.g. x isa type.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isequal-Tuple{Any,Any}",
    "page": "Essentials",
    "title": "Base.isequal",
    "category": "Method",
    "text": "isequal(x, y)\n\nSimilar to ==, except treats all floating-point NaN values as equal to each other, and treats -0.0 as unequal to 0.0. The default implementation of isequal calls ==, so if you have a type that doesn't have these floating-point subtleties then you probably only need to define ==.\n\nisequal is the comparison function used by hash tables (Dict). isequal(x,y) must imply that hash(x) == hash(y).\n\nThis typically means that if you define your own == function then you must define a corresponding hash (and vice versa). Collections typically implement isequal by calling isequal recursively on all contents.\n\nScalar types generally do not need to implement isequal separate from ==, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on isnan, signbit, and ==).\n\njulia> isequal([1., NaN], [1., NaN])\ntrue\n\njulia> [1., NaN] == [1., NaN]\nfalse\n\njulia> 0.0 == -0.0\ntrue\n\njulia> isequal(0.0, -0.0)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isequal-Tuple{Nullable,Nullable}",
    "page": "Essentials",
    "title": "Base.isequal",
    "category": "Method",
    "text": "isequal(x, y)\n\nSimilar to ==, except treats all floating-point NaN values as equal to each other, and treats -0.0 as unequal to 0.0. The default implementation of isequal calls ==, so if you have a type that doesn't have these floating-point subtleties then you probably only need to define ==.\n\nisequal is the comparison function used by hash tables (Dict). isequal(x,y) must imply that hash(x) == hash(y).\n\nThis typically means that if you define your own == function then you must define a corresponding hash (and vice versa). Collections typically implement isequal by calling isequal recursively on all contents.\n\nScalar types generally do not need to implement isequal separate from ==, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on isnan, signbit, and ==).\n\njulia> isequal([1., NaN], [1., NaN])\ntrue\n\njulia> [1., NaN] == [1., NaN]\nfalse\n\njulia> 0.0 == -0.0\ntrue\n\njulia> isequal(0.0, -0.0)\nfalse\n\n\n\nisequal(x::Nullable, y::Nullable)\n\nIf neither x nor y is null, compare them according to their values (i.e. isequal(get(x), get(y))). Else, return true if both arguments are null, and false if one is null but not the other: nulls are considered equal.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isless",
    "page": "Essentials",
    "title": "Base.isless",
    "category": "Function",
    "text": "isless(x, y)\n\nTest whether x is less than y, according to a canonical total order. Values that are normally unordered, such as NaN, are ordered in an arbitrary but consistent fashion. This is the default comparison used by sort. Non-numeric types with a canonical total order should implement this function. Numeric types only need to implement it if they have special values such as NaN.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isless-Tuple{Nullable,Nullable}",
    "page": "Essentials",
    "title": "Base.isless",
    "category": "Method",
    "text": "isless(x::Nullable, y::Nullable)\n\nIf neither x nor y is null, compare them according to their values (i.e. isless(get(x), get(y))). Else, return true if only y is null, and false otherwise: nulls are always considered greater than non-nulls, but not greater than another null.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.ifelse",
    "page": "Essentials",
    "title": "Base.ifelse",
    "category": "Function",
    "text": "ifelse(condition::Bool, x, y)\n\nReturn x if condition is true, otherwise return y. This differs from ? or if in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using ifelse instead of an if statement can eliminate the branch in generated code and provide higher performance in tight loops.\n\njulia> ifelse(1 > 2, 1, 2)\n2\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.lexcmp",
    "page": "Essentials",
    "title": "Base.lexcmp",
    "category": "Function",
    "text": "lexcmp(x, y)\n\nCompare x and y lexicographically and return -1, 0, or 1 depending on whether x is less than, equal to, or greater than y, respectively. This function should be defined for lexicographically comparable types, and lexless will call lexcmp by default.\n\njulia> lexcmp(\"abc\", \"abd\")\n-1\n\njulia> lexcmp(\"abc\", \"abc\")\n0\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.lexless",
    "page": "Essentials",
    "title": "Base.lexless",
    "category": "Function",
    "text": "lexless(x, y)\n\nDetermine whether x is lexicographically less than y.\n\njulia> lexless(\"abc\", \"abd\")\ntrue\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.typeof",
    "page": "Essentials",
    "title": "Core.typeof",
    "category": "Function",
    "text": "typeof(x)\n\nGet the concrete type of x.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.tuple",
    "page": "Essentials",
    "title": "Core.tuple",
    "category": "Function",
    "text": "tuple(xs...)\n\nConstruct a tuple of the given objects.\n\nExample\n\njulia> tuple(1, 'a', pi)\n(1, 'a', π = 3.1415926535897...)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.ntuple",
    "page": "Essentials",
    "title": "Base.ntuple",
    "category": "Function",
    "text": "ntuple(f::Function, n::Integer)\n\nCreate a tuple of length n, computing each element as f(i), where i is the index of the element.\n\njulia> ntuple(i -> 2*i, 4)\n(2, 4, 6, 8)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.object_id",
    "page": "Essentials",
    "title": "Base.object_id",
    "category": "Function",
    "text": "object_id(x)\n\nGet a hash value for x based on object identity. object_id(x)==object_id(y) if x === y.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.hash",
    "page": "Essentials",
    "title": "Base.hash",
    "category": "Function",
    "text": "hash(x[, h::UInt])\n\nCompute an integer hash code such that isequal(x,y) implies hash(x)==hash(y). The optional second argument h is a hash code to be mixed with the result.\n\nNew types should implement the 2-argument form, typically by calling the 2-argument hash method recursively in order to mix hashes of the contents with each other (and with h). Typically, any type that implements hash should also implement its own == (hence isequal) to guarantee the property mentioned above.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.finalizer",
    "page": "Essentials",
    "title": "Base.finalizer",
    "category": "Function",
    "text": "finalizer(x, f)\n\nRegister a function f(x) to be called when there are no program-accessible references to x. The type of x must be a mutable struct, otherwise the behavior of this function is unpredictable.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.finalize",
    "page": "Essentials",
    "title": "Base.finalize",
    "category": "Function",
    "text": "finalize(x)\n\nImmediately run finalizers registered for object x.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.copy",
    "page": "Essentials",
    "title": "Base.copy",
    "category": "Function",
    "text": "copy(x)\n\nCreate a shallow copy of x: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.deepcopy",
    "page": "Essentials",
    "title": "Base.deepcopy",
    "category": "Function",
    "text": "deepcopy(x)\n\nCreate a deep copy of x: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling deepcopy on an object should generally have the same effect as serializing and then deserializing it.\n\nAs a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.\n\nWhile it isn't normally necessary, user-defined types can override the default deepcopy behavior by defining a specialized version of the function deepcopy_internal(x::T, dict::ObjectIdDict) (which shouldn't otherwise be used), where T is the type to be specialized for, and dict keeps track of objects copied so far within the recursion. Within the definition, deepcopy_internal should be used in place of deepcopy, and the dict variable should be updated as appropriate before returning.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.isdefined",
    "page": "Essentials",
    "title": "Core.isdefined",
    "category": "Function",
    "text": "isdefined([m::Module,] s::Symbol)\nisdefined(object, s::Symbol)\nisdefined(object, index::Int)\n\nTests whether an assignable location is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index. With a single symbol argument, tests whether a global variable with that name is defined in current_module().\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.convert",
    "page": "Essentials",
    "title": "Base.convert",
    "category": "Function",
    "text": "convert(T, x)\n\nConvert x to a value of type T.\n\nIf T is an Integer type, an InexactError will be raised if x is not representable by T, for example if x is not integer-valued, or is outside the range supported by T.\n\nExamples\n\njulia> convert(Int, 3.0)\n3\n\njulia> convert(Int, 3.5)\nERROR: InexactError()\nStacktrace:\n [1] convert(::Type{Int64}, ::Float64) at ./float.jl:679\n\nIf T is a AbstractFloat or Rational type, then it will return the closest value to x representable by T.\n\njulia> x = 1/3\n0.3333333333333333\n\njulia> convert(Float32, x)\n0.33333334f0\n\njulia> convert(Rational{Int32}, x)\n1//3\n\njulia> convert(Rational{Int64}, x)\n6004799503160661//18014398509481984\n\nIf T is a collection type and x a collection, the result of convert(T, x) may alias x.\n\njulia> x = Int[1,2,3];\n\njulia> y = convert(Vector{Int}, x);\n\njulia> y === x\ntrue\n\nSimilarly, if T is a composite type and x a related instance, the result of convert(T, x) may alias part or all of x.\n\njulia> x = speye(5);\n\njulia> typeof(x)\nSparseMatrixCSC{Float64,Int64}\n\njulia> y = convert(SparseMatrixCSC{Float64,Int64}, x);\n\njulia> z = convert(SparseMatrixCSC{Float32,Int64}, y);\n\njulia> y === x\ntrue\n\njulia> z === x\nfalse\n\njulia> z.colptr === x.colptr\ntrue\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.promote",
    "page": "Essentials",
    "title": "Base.promote",
    "category": "Function",
    "text": "promote(xs...)\n\nConvert all arguments to their common promotion type (if any), and return them all (as a tuple).\n\nExample\n\njulia> promote(Int8(1), Float16(4.5), Float32(4.1))\n(1.0f0, 4.5f0, 4.1f0)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.oftype",
    "page": "Essentials",
    "title": "Base.oftype",
    "category": "Function",
    "text": "oftype(x, y)\n\nConvert y to the type of x (convert(typeof(x), y)).\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.widen",
    "page": "Essentials",
    "title": "Base.widen",
    "category": "Function",
    "text": "widen(x)\n\nIf x is a type, return a \"larger\" type (for numeric types, this will be a type with at least as much range and precision as the argument, and usually more). Otherwise x is converted to widen(typeof(x)).\n\nExamples\n\njulia> widen(Int32)\nInt64\n\njulia> widen(1.5f0)\n1.5\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.identity",
    "page": "Essentials",
    "title": "Base.identity",
    "category": "Function",
    "text": "identity(x)\n\nThe identity function. Returns its argument.\n\njulia> identity(\"Well, what did you expect?\")\n\"Well, what did you expect?\"\n\n\n\n"
},

{
    "location": "stdlib/base.html#Todos-los-Objetos-1",
    "page": "Essentials",
    "title": "Todos los Objetos",
    "category": "section",
    "text": "Core.:(===)\nCore.isa\nBase.isequal(::Any, ::Any)\nBase.isequal(::Nullable, ::Nullable)\nBase.isless\nBase.isless(::Nullable, ::Nullable)\nBase.ifelse\nBase.lexcmp\nBase.lexless\nCore.typeof\nCore.tuple\nBase.ntuple\nBase.object_id\nBase.hash\nBase.finalizer\nBase.finalize\nBase.copy\nBase.deepcopy\nCore.isdefined\nBase.convert\nBase.promote\nBase.oftype\nBase.widen\nBase.identity"
},

{
    "location": "stdlib/base.html#Base.supertype",
    "page": "Essentials",
    "title": "Base.supertype",
    "category": "Function",
    "text": "supertype(T::DataType)\n\nReturn the supertype of DataType T.\n\njulia> supertype(Int32)\nSigned\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.issubtype",
    "page": "Essentials",
    "title": "Core.issubtype",
    "category": "Function",
    "text": "issubtype(type1, type2)\n\nReturn true if and only if all values of type1 are also of type2. Can also be written using the <: infix operator as type1 <: type2.\n\nExamples\n\njulia> issubtype(Int8, Int32)\nfalse\n\njulia> Int8 <: Integer\ntrue\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.:<:",
    "page": "Essentials",
    "title": "Base.:<:",
    "category": "Function",
    "text": "<:(T1, T2)\n\nSubtype operator, equivalent to issubtype(T1, T2).\n\njulia> Float64 <: AbstractFloat\ntrue\n\njulia> Vector{Int} <: AbstractArray\ntrue\n\njulia> Matrix{Float64} <: Matrix{AbstractFloat}\nfalse\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.:>:",
    "page": "Essentials",
    "title": "Base.:>:",
    "category": "Function",
    "text": ">:(T1, T2)\n\nSupertype operator, equivalent to issubtype(T2, T1).\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.subtypes",
    "page": "Essentials",
    "title": "Base.subtypes",
    "category": "Function",
    "text": "subtypes(T::DataType)\n\nReturn a list of immediate subtypes of DataType T. Note that all currently loaded subtypes are included, including those not visible in the current module.\n\njulia> subtypes(Integer)\n4-element Array{Union{DataType, UnionAll},1}:\n BigInt\n Bool\n Signed\n Unsigned\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.typemin",
    "page": "Essentials",
    "title": "Base.typemin",
    "category": "Function",
    "text": "typemin(T)\n\nThe lowest value representable by the given (real) numeric DataType T.\n\nExamples\n\njulia> typemin(Float16)\n-Inf16\n\njulia> typemin(Float32)\n-Inf32\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.typemax",
    "page": "Essentials",
    "title": "Base.typemax",
    "category": "Function",
    "text": "typemax(T)\n\nThe highest value representable by the given (real) numeric DataType.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.realmin",
    "page": "Essentials",
    "title": "Base.realmin",
    "category": "Function",
    "text": "realmin(T)\n\nThe smallest in absolute value non-subnormal value representable by the given floating-point DataType T.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.realmax",
    "page": "Essentials",
    "title": "Base.realmax",
    "category": "Function",
    "text": "realmax(T)\n\nThe highest finite value representable by the given floating-point DataType T.\n\nExamples\n\njulia> realmax(Float16)\nFloat16(6.55e4)\n\njulia> realmax(Float32)\n3.4028235f38\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.maxintfloat",
    "page": "Essentials",
    "title": "Base.maxintfloat",
    "category": "Function",
    "text": "maxintfloat(T)\n\nThe largest integer losslessly representable by the given floating-point DataType T.\n\n\n\nmaxintfloat(T, S)\n\nThe largest integer losslessly representable by the given floating-point DataType T that also does not exceed the maximum integer representable by the integer DataType S.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.sizeof-Tuple{Type}",
    "page": "Essentials",
    "title": "Base.sizeof",
    "category": "Method",
    "text": "sizeof(T)\n\nSize, in bytes, of the canonical binary representation of the given DataType T, if any.\n\nExamples\n\njulia> sizeof(Float32)\n4\n\njulia> sizeof(Complex128)\n16\n\nIf T does not have a specific size, an error is thrown.\n\njulia> sizeof(Base.LinAlg.LU)\nERROR: argument is an abstract type; size is indeterminate\nStacktrace:\n [1] sizeof(::Type{T} where T) at ./essentials.jl:159\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.eps-Tuple{Type{#s27} where #s27<:AbstractFloat}",
    "page": "Essentials",
    "title": "Base.eps",
    "category": "Method",
    "text": "eps(::Type{T}) where T<:AbstractFloat\neps()\n\nReturns the machine epsilon of the floating point type T (T = Float64 by default). This is defined as the gap between 1 and the next largest value representable by T, and is equivalent to eps(one(T)).\n\njulia> eps()\n2.220446049250313e-16\n\njulia> eps(Float32)\n1.1920929f-7\n\njulia> 1.0 + eps()\n1.0000000000000002\n\njulia> 1.0 + eps()/2\n1.0\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.eps-Tuple{AbstractFloat}",
    "page": "Essentials",
    "title": "Base.eps",
    "category": "Method",
    "text": "eps(x::AbstractFloat)\n\nReturns the unit in last place (ulp) of x. This is the distance between consecutive representable floating point values at x. In most cases, if the distance on either side of x is different, then the larger of the two is taken, that is\n\neps(x) == max(x-prevfloat(x), nextfloat(x)-x)\n\nThe exceptions to this rule are the smallest and largest finite values (e.g. nextfloat(-Inf) and prevfloat(Inf) for Float64), which round to the smaller of the values.\n\nThe rationale for this behavior is that eps bounds the floating point rounding error. Under the default RoundNearest rounding mode, if y is a real number and x is the nearest floating point number to y, then\n\ny-x leq operatornameeps(x)2\n\njulia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(prevfloat(2.0))\n2.220446049250313e-16\n\njulia> eps(2.0)\n4.440892098500626e-16\n\njulia> x = prevfloat(Inf)      # largest finite Float64\n1.7976931348623157e308\n\njulia> x + eps(x)/2            # rounds up\nInf\n\njulia> x + prevfloat(eps(x)/2) # rounds down\n1.7976931348623157e308\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.promote_type",
    "page": "Essentials",
    "title": "Base.promote_type",
    "category": "Function",
    "text": "promote_type(type1, type2)\n\nDetermine a type big enough to hold values of each argument type without loss, whenever possible. In some cases, where no type exists to which both types can be promoted losslessly, some loss is tolerated; for example, promote_type(Int64, Float64) returns Float64 even though strictly, not all Int64 values can be represented exactly as Float64 values.\n\njulia> promote_type(Int64, Float64)\nFloat64\n\njulia> promote_type(Int32, Int64)\nInt64\n\njulia> promote_type(Float32, BigInt)\nBigFloat\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.promote_rule",
    "page": "Essentials",
    "title": "Base.promote_rule",
    "category": "Function",
    "text": "promote_rule(type1, type2)\n\nSpecifies what type should be used by promote when given values of types type1 and type2. This function should not be called directly, but should have definitions added to it for new types as appropriate.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.getfield",
    "page": "Essentials",
    "title": "Core.getfield",
    "category": "Function",
    "text": "getfield(value, name::Symbol)\n\nExtract a named field from a value of composite type. The syntax a.b calls getfield(a, :b).\n\nExample\n\njulia> a = 1//2\n1//2\n\njulia> getfield(a, :num)\n1\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.setfield!",
    "page": "Essentials",
    "title": "Core.setfield!",
    "category": "Function",
    "text": "setfield!(value, name::Symbol, x)\n\nAssign x to a named field in value of composite type. The syntax a.b = c calls setfield!(a, :b, c).\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.fieldoffset",
    "page": "Essentials",
    "title": "Base.fieldoffset",
    "category": "Function",
    "text": "fieldoffset(type, i)\n\nThe byte offset of field i of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:\n\njulia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:nfields(T)];\n\njulia> structinfo(Base.Filesystem.StatStruct)\n12-element Array{Tuple{UInt64,Symbol,DataType},1}:\n (0x0000000000000000, :device, UInt64)\n (0x0000000000000008, :inode, UInt64)\n (0x0000000000000010, :mode, UInt64)\n (0x0000000000000018, :nlink, Int64)\n (0x0000000000000020, :uid, UInt64)\n (0x0000000000000028, :gid, UInt64)\n (0x0000000000000030, :rdev, UInt64)\n (0x0000000000000038, :size, Int64)\n (0x0000000000000040, :blksize, Int64)\n (0x0000000000000048, :blocks, Int64)\n (0x0000000000000050, :mtime, Float64)\n (0x0000000000000058, :ctime, Float64)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.fieldtype",
    "page": "Essentials",
    "title": "Core.fieldtype",
    "category": "Function",
    "text": "fieldtype(T, name::Symbol | index::Int)\n\nDetermine the declared type of a field (specified by name or index) in a composite DataType T.\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldtype(Foo, :x)\nInt64\n\njulia> fieldtype(Foo, 2)\nString\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isimmutable",
    "page": "Essentials",
    "title": "Base.isimmutable",
    "category": "Function",
    "text": "isimmutable(v)\n\nReturn true iff value v is immutable.  See Mutable Composite Types for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of DataType is mutable.\n\njulia> isimmutable(1)\ntrue\n\njulia> isimmutable([1,2])\nfalse\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isbits",
    "page": "Essentials",
    "title": "Base.isbits",
    "category": "Function",
    "text": "isbits(T)\n\nReturn true if T is a \"plain data\" type, meaning it is immutable and contains no references to other values. Typical examples are numeric types such as UInt8, Float64, and Complex{Float64}.\n\njulia> isbits(Complex{Float64})\ntrue\n\njulia> isbits(Complex)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isleaftype",
    "page": "Essentials",
    "title": "Base.isleaftype",
    "category": "Function",
    "text": "isleaftype(T)\n\nDetermine whether T's only subtypes are itself and Union{}. This means T is a concrete type that can have instances.\n\njulia> isleaftype(Complex)\nfalse\n\njulia> isleaftype(Complex{Float32})\ntrue\n\njulia> isleaftype(Vector{Complex})\ntrue\n\njulia> isleaftype(Vector{Complex{Float32}})\ntrue\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.typejoin",
    "page": "Essentials",
    "title": "Base.typejoin",
    "category": "Function",
    "text": "typejoin(T, S)\n\nCompute a type that contains both T and S.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.typeintersect",
    "page": "Essentials",
    "title": "Base.typeintersect",
    "category": "Function",
    "text": "typeintersect(T, S)\n\nCompute a type that contains the intersection of T and S. Usually this will be the smallest such type or one close to it.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Val",
    "page": "Essentials",
    "title": "Base.Val",
    "category": "Type",
    "text": "Val{c}\n\nCreate a \"value type\" out of c, which must be an isbits value. The intent of this construct is to be able to dispatch on constants, e.g., f(Val{false}) allows you to dispatch directly (at compile-time) to an implementation f(::Type{Val{false}}), without having to test the boolean value at runtime.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Enums.@enum",
    "page": "Essentials",
    "title": "Base.Enums.@enum",
    "category": "Macro",
    "text": "@enum EnumName[::BaseType] value1[=x] value2[=y]\n\nCreate an Enum{BaseType} subtype with name EnumName and enum member values of value1 and value2 with optional assigned values of x and y, respectively. EnumName can be used just like other types and enum member values as regular values, such as\n\njulia> @enum Fruit apple=1 orange=2 kiwi=3\n\njulia> f(x::Fruit) = \"I'm a Fruit with value: $(Int(x))\"\nf (generic function with 1 method)\n\njulia> f(apple)\n\"I'm a Fruit with value: 1\"\n\nBaseType, which defaults to Int32, must be a primitive subtype of Integer. Member values can be converted between the enum type and BaseType. read and write perform these conversions automatically.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.instances",
    "page": "Essentials",
    "title": "Base.instances",
    "category": "Function",
    "text": "instances(T::Type)\n\nReturn a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see @enum).\n\njulia> @enum Color red blue green\n\njulia> instances(Color)\n(red::Color = 0, blue::Color = 1, green::Color = 2)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Tipos-1",
    "page": "Essentials",
    "title": "Tipos",
    "category": "section",
    "text": "Base.supertype\nCore.issubtype\nBase.:(<:)\nBase.:(>:)\nBase.subtypes\nBase.typemin\nBase.typemax\nBase.realmin\nBase.realmax\nBase.maxintfloat\nBase.sizeof(::Type)\nBase.eps(::Type{<:AbstractFloat})\nBase.eps(::AbstractFloat)\nBase.promote_type\nBase.promote_rule\nCore.getfield\nCore.setfield!\nBase.fieldoffset\nCore.fieldtype\nBase.isimmutable\nBase.isbits\nBase.isleaftype\nBase.typejoin\nBase.typeintersect\nBase.Val\nBase.Enums.@enum\nBase.instances"
},

{
    "location": "stdlib/base.html#Core.Function",
    "page": "Essentials",
    "title": "Core.Function",
    "category": "Type",
    "text": "Function\n\nAbstract type of all functions.\n\njulia> isa(+, Function)\ntrue\n\njulia> typeof(sin)\nBase.#sin\n\njulia> ans <: Function\ntrue\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.method_exists",
    "page": "Essentials",
    "title": "Base.method_exists",
    "category": "Function",
    "text": "method_exists(f, Tuple type, world=typemax(UInt)) -> Bool\n\nDetermine whether the given generic function has a method matching the given Tuple of argument types with the upper bound of world age given by world.\n\njulia> method_exists(length, Tuple{Array})\ntrue\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.applicable",
    "page": "Essentials",
    "title": "Core.applicable",
    "category": "Function",
    "text": "applicable(f, args...) -> Bool\n\nDetermine whether the given generic function has a method applicable to the given arguments.\n\nExamples\n\njulia> function f(x, y)\n           x + y\n       end;\n\njulia> applicable(f, 1)\nfalse\n\njulia> applicable(f, 1, 2)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.invoke",
    "page": "Essentials",
    "title": "Core.invoke",
    "category": "Function",
    "text": "invoke(f, types <: Tuple, args...)\n\nInvoke a method for the given generic function matching the specified types, on the specified arguments. The arguments must be compatible with the specified types. This allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.invokelatest",
    "page": "Essentials",
    "title": "Base.invokelatest",
    "category": "Function",
    "text": "invokelatest(f, args...)\n\nCalls f(args...), but guarantees that the most recent method of f will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function f. (The drawback is that invokelatest is somewhat slower than calling f directly, and the type of the result cannot be inferred by the compiler.)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.:|>",
    "page": "Essentials",
    "title": "Base.:|>",
    "category": "Function",
    "text": "|>(x, f)\n\nApplies a function to the preceding argument. This allows for easy function chaining.\n\njulia> [1:5;] |> x->x.^2 |> sum |> inv\n0.01818181818181818\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.:∘",
    "page": "Essentials",
    "title": "Base.:∘",
    "category": "Function",
    "text": "f ∘ g\n\nCompose functions: i.e. (f ∘ g)(args...) means f(g(args...)). The ∘ symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing \\circ<tab>. Example:\n\njulia> map(uppercase∘hex, 250:255)\n6-element Array{String,1}:\n \"FA\"\n \"FB\"\n \"FC\"\n \"FD\"\n \"FE\"\n \"FF\"\n\n\n\n"
},

{
    "location": "stdlib/base.html#Funciones-Genéricas-1",
    "page": "Essentials",
    "title": "Funciones Genéricas",
    "category": "section",
    "text": "Core.Function\nBase.method_exists\nCore.applicable\nCore.invoke\nBase.invokelatest\nBase.:(|>)\nBase.:(∘)"
},

{
    "location": "stdlib/base.html#Core.eval",
    "page": "Essentials",
    "title": "Core.eval",
    "category": "Function",
    "text": "eval([m::Module], expr::Expr)\n\nEvaluate an expression in the given module and return the result. Every Module (except those defined with baremodule) has its own 1-argument definition of eval, which evaluates expressions in that module.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@eval",
    "page": "Essentials",
    "title": "Base.@eval",
    "category": "Macro",
    "text": "@eval [mod,] ex\n\nEvaluate an expression with values interpolated into it using eval. If two arguments are provided, the first is the module to evaluate in.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.evalfile",
    "page": "Essentials",
    "title": "Base.evalfile",
    "category": "Function",
    "text": "evalfile(path::AbstractString, args::Vector{String}=String[])\n\nLoad the file using include, evaluate all expressions, and return the value of the last one.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.esc",
    "page": "Essentials",
    "title": "Base.esc",
    "category": "Function",
    "text": "esc(e::ANY)\n\nOnly valid in the context of an Expr returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the Macros section of the Metaprogramming chapter of the manual for more details and examples.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@inbounds",
    "page": "Essentials",
    "title": "Base.@inbounds",
    "category": "Macro",
    "text": "@inbounds(blk)\n\nEliminates array bounds checking within expressions.\n\nIn the example below the bound check of array A is skipped to improve performance.\n\nfunction sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i = 1:length(A)\n        @inbounds r += A[i]\n    end\n    return r\nend\n\nwarning: Warning\nUsing @inbounds may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@inline",
    "page": "Essentials",
    "title": "Base.@inline",
    "category": "Macro",
    "text": "@inline\n\nGive a hint to the compiler that this function is worth inlining.\n\nSmall functions typically do not need the @inline annotation, as the compiler does it automatically. By using @inline on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:\n\n@inline function bigfunction(x)\n    #=\n        Function Definition\n    =#\nend\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@noinline",
    "page": "Essentials",
    "title": "Base.@noinline",
    "category": "Macro",
    "text": "@noinline\n\nPrevents the compiler from inlining a function.\n\nSmall functions are typically inlined automatically. By using @noinline on small functions, auto-inlining can be prevented. This is shown in the following example:\n\n@noinline function smallfunction(x)\n    #=\n        Function Definition\n    =#\nend\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.gensym",
    "page": "Essentials",
    "title": "Base.gensym",
    "category": "Function",
    "text": "gensym([tag])\n\nGenerates a symbol which will not conflict with other variable names.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@gensym",
    "page": "Essentials",
    "title": "Base.@gensym",
    "category": "Macro",
    "text": "@gensym\n\nGenerates a gensym symbol for a variable. For example, @gensym x y is transformed into x = gensym(\"x\"); y = gensym(\"y\").\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@polly",
    "page": "Essentials",
    "title": "Base.@polly",
    "category": "Macro",
    "text": "@polly\n\nTells the compiler to apply the polyhedral optimizer Polly to a function.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.parse-Tuple{Any,Any}",
    "page": "Essentials",
    "title": "Base.parse",
    "category": "Method",
    "text": "parse(str, start; greedy=true, raise=true)\n\nParse the expression string and return an expression (which could later be passed to eval for execution). start is the index of the first character to start parsing. If greedy is true (default), parse will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return Expr(:incomplete, \"(error message)\"). If raise is true (default), syntax errors other than incomplete expressions will raise an error. If raise is false, parse will return an expression that will raise an error upon evaluation.\n\njulia> parse(\"x = 3, y = 5\", 7)\n(:(y = 5), 13)\n\njulia> parse(\"x = 3, y = 5\", 5)\n(:((3, y) = 5), 13)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.parse-Tuple{Any}",
    "page": "Essentials",
    "title": "Base.parse",
    "category": "Method",
    "text": "parse(str; raise=true)\n\nParse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If raise is true (default), syntax errors will raise an error; otherwise, parse will return an expression that will raise an error upon evaluation.\n\njulia> parse(\"x = 3\")\n:(x = 3)\n\njulia> parse(\"x = \")\n:($(Expr(:incomplete, \"incomplete: premature end of input\")))\n\njulia> parse(\"1.0.2\")\nERROR: ParseError(\"invalid numeric constant \\\"1.0.\\\"\")\nStacktrace:\n[...]\n\njulia> parse(\"1.0.2\"; raise = false)\n:($(Expr(:error, \"invalid numeric constant \\\"1.0.\\\"\")))\n\n\n\n"
},

{
    "location": "stdlib/base.html#Sintaxis-1",
    "page": "Essentials",
    "title": "Sintaxis",
    "category": "section",
    "text": "Core.eval\nBase.@eval\nBase.evalfile\nBase.esc\nBase.@inbounds\nBase.@inline\nBase.@noinline\nBase.gensym\nBase.@gensym\nBase.@polly\nBase.parse(::Any, ::Any)\nBase.parse(::Any)"
},

{
    "location": "stdlib/base.html#Base.Nullable",
    "page": "Essentials",
    "title": "Base.Nullable",
    "category": "Type",
    "text": "Nullable(x, hasvalue::Bool=true)\n\nWrap value x in an object of type Nullable, which indicates whether a value is present. Nullable(x) yields a non-empty wrapper and Nullable{T}() yields an empty instance of a wrapper that might contain a value of type T.\n\nNullable(x, false) yields Nullable{typeof(x)}() with x stored in the result's value field.\n\nExamples\n\njulia> Nullable(1)\nNullable{Int64}(1)\n\njulia> Nullable{Int64}()\nNullable{Int64}()\n\njulia> Nullable(1, false)\nNullable{Int64}()\n\njulia> dump(Nullable(1, false))\nNullable{Int64}\n  hasvalue: Bool false\n  value: Int64 1\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.get-Tuple{Nullable,Any}",
    "page": "Essentials",
    "title": "Base.get",
    "category": "Method",
    "text": "get(x::Nullable[, y])\n\nAttempt to access the value of x. Returns the value if it is present; otherwise, returns y if provided, or throws a NullException if not.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isnull",
    "page": "Essentials",
    "title": "Base.isnull",
    "category": "Function",
    "text": "isnull(x)\n\nReturn whether or not x is null for Nullable x; return false for all other x.\n\nExamples\n\njulia> x = Nullable(1, false)\nNullable{Int64}()\n\njulia> isnull(x)\ntrue\n\njulia> x = Nullable(1, true)\nNullable{Int64}(1)\n\njulia> isnull(x)\nfalse\n\njulia> x = 1\n1\n\njulia> isnull(x)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.unsafe_get",
    "page": "Essentials",
    "title": "Base.unsafe_get",
    "category": "Function",
    "text": "unsafe_get(x)\n\nReturn the value of x for Nullable x; return x for all other x.\n\nThis method does not check whether or not x is null before attempting to access the value of x for x::Nullable (hence \"unsafe\").\n\njulia> x = Nullable(1)\nNullable{Int64}(1)\n\njulia> unsafe_get(x)\n1\n\njulia> x = Nullable{String}()\nNullable{String}()\n\njulia> unsafe_get(x)\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n [1] unsafe_get(::Nullable{String}) at ./nullable.jl:125\n\njulia> x = 1\n1\n\njulia> unsafe_get(x)\n1\n\n\n\n"
},

{
    "location": "stdlib/base.html#*Nullables*-1",
    "page": "Essentials",
    "title": "Nullables",
    "category": "section",
    "text": "Base.Nullable\nBase.get(::Nullable, ::Any)\nBase.isnull\nBase.unsafe_get"
},

{
    "location": "stdlib/base.html#Base.run",
    "page": "Essentials",
    "title": "Base.run",
    "category": "Function",
    "text": "run(command, args...)\n\nRun a command object, constructed with backticks. Throws an error if anything goes wrong, including the process exiting with a non-zero status.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.spawn",
    "page": "Essentials",
    "title": "Base.spawn",
    "category": "Function",
    "text": "spawn(command)\n\nRun a command object asynchronously, returning the resulting Process object.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.DevNull",
    "page": "Essentials",
    "title": "Base.DevNull",
    "category": "Constant",
    "text": "DevNull\n\nUsed in a stream redirect to discard all data written to it. Essentially equivalent to /dev/null on Unix or NUL on Windows. Usage:\n\nrun(pipeline(`cat test.txt`, DevNull))\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.success",
    "page": "Essentials",
    "title": "Base.success",
    "category": "Function",
    "text": "success(command)\n\nRun a command object, constructed with backticks, and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.process_running",
    "page": "Essentials",
    "title": "Base.process_running",
    "category": "Function",
    "text": "process_running(p::Process)\n\nDetermine whether a process is currently running.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.process_exited",
    "page": "Essentials",
    "title": "Base.process_exited",
    "category": "Function",
    "text": "process_exited(p::Process)\n\nDetermine whether a process has exited.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.kill-Tuple{Base.Process,Integer}",
    "page": "Essentials",
    "title": "Base.kill",
    "category": "Method",
    "text": "kill(p::Process, signum=SIGTERM)\n\nSend a signal to a process. The default is to terminate the process.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Sys.set_process_title",
    "page": "Essentials",
    "title": "Base.Sys.set_process_title",
    "category": "Function",
    "text": "Sys.set_process_title(title::AbstractString)\n\nSet the process title. No-op on some operating systems.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Sys.get_process_title",
    "page": "Essentials",
    "title": "Base.Sys.get_process_title",
    "category": "Function",
    "text": "Sys.get_process_title()\n\nGet the process title. On some systems, will always return an empty string.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.readandwrite",
    "page": "Essentials",
    "title": "Base.readandwrite",
    "category": "Function",
    "text": "readandwrite(command)\n\nStarts running a command asynchronously, and returns a tuple (stdout,stdin,process) of the output stream and input stream of the process, and the process object itself.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.ignorestatus",
    "page": "Essentials",
    "title": "Base.ignorestatus",
    "category": "Function",
    "text": "ignorestatus(command)\n\nMark a command object so that running it will not throw an error if the result code is non-zero.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.detach",
    "page": "Essentials",
    "title": "Base.detach",
    "category": "Function",
    "text": "detach(command)\n\nMark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Cmd",
    "page": "Essentials",
    "title": "Base.Cmd",
    "category": "Type",
    "text": "Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)\n\nConstruct a new Cmd object, representing an external program and arguments, from cmd, while changing the settings of the optional keyword arguments:\n\nignorestatus::Bool: If true (defaults to false), then the Cmd will not throw an error if the return code is nonzero.\ndetach::Bool: If true (defaults to false), then the Cmd will be run in a new process group, allowing it to outlive the julia process and not have Ctrl-C passed to it.\nwindows_verbatim::Bool: If true (defaults to false), then on Windows the Cmd will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single \"command-line\" string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes \" in the command line, and \\ or \" are preceded by backslashes. windows_verbatim=true is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.\nwindows_hide::Bool: If true (defaults to false), then on Windows no new console window is displayed when the Cmd is executed. This has no effect if a console is already open or on non-Windows systems.\nenv: Set environment variables to use when running the Cmd. env is either a dictionary mapping strings to strings, an array of strings of the form \"var=val\", an array or tuple of \"var\"=>val pairs, or nothing. In order to modify (rather than replace) the existing environment, create env by copy(ENV) and then set env[\"var\"]=val as desired.\ndir::AbstractString: Specify a working directory for the command (instead of the current directory).\n\nFor any keywords that are not specified, the current settings from cmd are used. Normally, to create a Cmd object in the first place, one uses backticks, e.g.\n\nCmd(`echo \"Hello world\"`, ignorestatus=true, detach=false)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.setenv",
    "page": "Essentials",
    "title": "Base.setenv",
    "category": "Function",
    "text": "setenv(command::Cmd, env; dir=\"\")\n\nSet environment variables to use when running the given command. env is either a dictionary mapping strings to strings, an array of strings of the form \"var=val\", or zero or more \"var\"=>val pair arguments. In order to modify (rather than replace) the existing environment, create env by copy(ENV) and then setting env[\"var\"]=val as desired, or use withenv.\n\nThe dir keyword argument can be used to specify a working directory for the command.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.withenv",
    "page": "Essentials",
    "title": "Base.withenv",
    "category": "Function",
    "text": "withenv(f::Function, kv::Pair...)\n\nExecute f() in an environment that is temporarily modified (not replaced as in setenv) by zero or more \"var\"=>val arguments kv. withenv is generally used via the withenv(kv...) do ... end syntax. A value of nothing can be used to temporarily unset an environment variable (if it is set). When withenv returns, the original environment has been restored.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.pipeline-Tuple{Any,Any,Any,Vararg{Any,N} where N}",
    "page": "Essentials",
    "title": "Base.pipeline",
    "category": "Method",
    "text": "pipeline(from, to, ...)\n\nCreate a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other pipeline calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example pipeline(a,b,c) is equivalent to pipeline(pipeline(a,b),c). This provides a more concise way to specify multi-stage pipelines.\n\nExamples:\n\nrun(pipeline(`ls`, `grep xyz`))\nrun(pipeline(`ls`, \"out.txt\"))\nrun(pipeline(\"out.txt\", `grep xyz`))\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.pipeline-Tuple{Base.AbstractCmd}",
    "page": "Essentials",
    "title": "Base.pipeline",
    "category": "Method",
    "text": "pipeline(command; stdin, stdout, stderr, append=false)\n\nRedirect I/O to or from the given command. Keyword arguments specify which of the command's streams should be redirected. append controls whether file output appends to the file. This is a more general version of the 2-argument pipeline function. pipeline(from, to) is equivalent to pipeline(from, stdout=to) when from is a command, and to pipeline(to, stdin=from) when from is another kind of data source.\n\nExamples:\n\nrun(pipeline(`dothings`, stdout=\"out.txt\", stderr=\"errs.txt\"))\nrun(pipeline(`update`, stdout=\"log.txt\", append=true))\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Libc.gethostname",
    "page": "Essentials",
    "title": "Base.Libc.gethostname",
    "category": "Function",
    "text": "gethostname() -> AbstractString\n\nGet the local machine's host name.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.getipaddr",
    "page": "Essentials",
    "title": "Base.getipaddr",
    "category": "Function",
    "text": "getipaddr() -> IPAddr\n\nGet the IP address of the local machine.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Libc.getpid",
    "page": "Essentials",
    "title": "Base.Libc.getpid",
    "category": "Function",
    "text": "getpid() -> Int32\n\nGet Julia's process ID.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Libc.time-Tuple{}",
    "page": "Essentials",
    "title": "Base.Libc.time",
    "category": "Method",
    "text": "time()\n\nGet the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.time_ns",
    "page": "Essentials",
    "title": "Base.time_ns",
    "category": "Function",
    "text": "time_ns()\n\nGet the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.tic",
    "page": "Essentials",
    "title": "Base.tic",
    "category": "Function",
    "text": "tic()\n\nSet a timer to be read by the next call to toc or toq. The macro call @time expr can also be used to time evaluation.\n\njulia> tic()\n0x0000c45bc7abac95\n\njulia> sleep(0.3)\n\njulia> toc()\nelapsed time: 0.302745944 seconds\n0.302745944\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.toc",
    "page": "Essentials",
    "title": "Base.toc",
    "category": "Function",
    "text": "toc()\n\nPrint and return the time elapsed since the last tic. The macro call @time expr can also be used to time evaluation.\n\njulia> tic()\n0x0000c45bc7abac95\n\njulia> sleep(0.3)\n\njulia> toc()\nelapsed time: 0.302745944 seconds\n0.302745944\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.toq",
    "page": "Essentials",
    "title": "Base.toq",
    "category": "Function",
    "text": "toq()\n\nReturn, but do not print, the time elapsed since the last tic. The macro calls @timed expr and @elapsed expr also return evaluation time.\n\njulia> tic()\n0x0000c46477a9675d\n\njulia> sleep(0.3)\n\njulia> toq()\n0.302251004\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@time",
    "page": "Essentials",
    "title": "Base.@time",
    "category": "Macro",
    "text": "@time\n\nA macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.\n\nSee also @timev, @timed, @elapsed, and @allocated.\n\njulia> @time rand(10^6);\n  0.001525 seconds (7 allocations: 7.630 MiB)\n\njulia> @time begin\n           sleep(0.3)\n           1+1\n       end\n  0.301395 seconds (8 allocations: 336 bytes)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@timev",
    "page": "Essentials",
    "title": "Base.@timev",
    "category": "Macro",
    "text": "@timev\n\nThis is a verbose version of the @time macro. It first prints the same information as @time, then any non-zero memory allocation counters, and then returns the value of the expression.\n\nSee also @time, @timed, @elapsed, and @allocated.\n\njulia> @timev rand(10^6);\n  0.001006 seconds (7 allocations: 7.630 MiB)\nelapsed time (ns): 1005567\nbytes allocated:   8000256\npool allocs:       6\nmalloc() calls:    1\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@timed",
    "page": "Essentials",
    "title": "Base.@timed",
    "category": "Macro",
    "text": "@timed\n\nA macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.\n\nSee also @time, @timev, @elapsed, and @allocated.\n\njulia> val, t, bytes, gctime, memallocs = @timed rand(10^6);\n\njulia> t\n0.006634834\n\njulia> bytes\n8000256\n\njulia> gctime\n0.0055765\n\njulia> fieldnames(typeof(memallocs))\n9-element Array{Symbol,1}:\n :allocd\n :malloc\n :realloc\n :poolalloc\n :bigalloc\n :freecall\n :total_time\n :pause\n :full_sweep\n\njulia> memallocs.total_time\n5576500\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@elapsed",
    "page": "Essentials",
    "title": "Base.@elapsed",
    "category": "Macro",
    "text": "@elapsed\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.\n\nSee also @time, @timev, @timed, and @allocated.\n\njulia> @elapsed sleep(0.3)\n0.301391426\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@allocated",
    "page": "Essentials",
    "title": "Base.@allocated",
    "category": "Macro",
    "text": "@allocated\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the @time macros, which do not try to adjust for the effects of compilation.\n\nSee also @time, @timev, @timed, and @elapsed.\n\njulia> @allocated rand(10^6)\n8000080\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.EnvHash",
    "page": "Essentials",
    "title": "Base.EnvHash",
    "category": "Type",
    "text": "EnvHash() -> EnvHash\n\nA singleton of this type provides a hash table interface to environment variables.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.ENV",
    "page": "Essentials",
    "title": "Base.ENV",
    "category": "Constant",
    "text": "ENV\n\nReference to the singleton EnvHash, providing a dictionary interface to system environment variables.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.is_unix",
    "page": "Essentials",
    "title": "Base.is_unix",
    "category": "Function",
    "text": "is_unix([os])\n\nPredicate for testing if the OS provides a Unix-like interface. See documentation in Handling Operating System Variation.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.is_apple",
    "page": "Essentials",
    "title": "Base.is_apple",
    "category": "Function",
    "text": "is_apple([os])\n\nPredicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in Handling Operating System Variation.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.is_linux",
    "page": "Essentials",
    "title": "Base.is_linux",
    "category": "Function",
    "text": "is_linux([os])\n\nPredicate for testing if the OS is a derivative of Linux. See documentation in Handling Operating System Variation.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.is_bsd",
    "page": "Essentials",
    "title": "Base.is_bsd",
    "category": "Function",
    "text": "is_bsd([os])\n\nPredicate for testing if the OS is a derivative of BSD. See documentation in Handling Operating System Variation.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.is_windows",
    "page": "Essentials",
    "title": "Base.is_windows",
    "category": "Function",
    "text": "is_windows([os])\n\nPredicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation in Handling Operating System Variation.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Sys.windows_version",
    "page": "Essentials",
    "title": "Base.Sys.windows_version",
    "category": "Function",
    "text": "Sys.windows_version()\n\nReturns the version number for the Windows NT Kernel as a (major, minor) pair, or (0, 0) if this is not running on Windows.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@static",
    "page": "Essentials",
    "title": "Base.@static",
    "category": "Macro",
    "text": "@static\n\nPartially evaluates an expression at parse time.\n\nFor example, @static is_windows() ? foo : bar will evaluate is_windows() and insert either foo or bar into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a ccall to a non-existent function. @static if is_apple() foo end and @static foo <&&,||> bar are also valid syntax.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Sistema-1",
    "page": "Essentials",
    "title": "Sistema",
    "category": "section",
    "text": "Base.run\nBase.spawn\nBase.DevNull\nBase.success\nBase.process_running\nBase.process_exited\nBase.kill(::Base.Process, ::Integer)\nBase.Sys.set_process_title\nBase.Sys.get_process_title\nBase.readandwrite\nBase.ignorestatus\nBase.detach\nBase.Cmd\nBase.setenv\nBase.withenv\nBase.pipeline(::Any, ::Any, ::Any, ::Any...)\nBase.pipeline(::Base.AbstractCmd)\nBase.Libc.gethostname\nBase.getipaddr\nBase.Libc.getpid\nBase.Libc.time()\nBase.time_ns\nBase.tic\nBase.toc\nBase.toq\nBase.@time\nBase.@timev\nBase.@timed\nBase.@elapsed\nBase.@allocated\nBase.EnvHash\nBase.ENV\nBase.is_unix\nBase.is_apple\nBase.is_linux\nBase.is_bsd\nBase.is_windows\nBase.Sys.windows_version\nBase.@static"
},

{
    "location": "stdlib/base.html#Base.error",
    "page": "Essentials",
    "title": "Base.error",
    "category": "Function",
    "text": "error(message::AbstractString)\n\nRaise an ErrorException with the given message.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.throw",
    "page": "Essentials",
    "title": "Core.throw",
    "category": "Function",
    "text": "throw(e)\n\nThrow an object as an exception.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.rethrow",
    "page": "Essentials",
    "title": "Base.rethrow",
    "category": "Function",
    "text": "rethrow([e])\n\nThrow an object without changing the current exception backtrace. The default argument is the current exception (if called within a catch block).\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.backtrace",
    "page": "Essentials",
    "title": "Base.backtrace",
    "category": "Function",
    "text": "backtrace()\n\nGet a backtrace object for the current program point.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.catch_backtrace",
    "page": "Essentials",
    "title": "Base.catch_backtrace",
    "category": "Function",
    "text": "catch_backtrace()\n\nGet the backtrace of the current exception, for use within catch blocks.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.assert",
    "page": "Essentials",
    "title": "Base.assert",
    "category": "Function",
    "text": "assert(cond)\n\nThrow an AssertionError if cond is false. Also available as the macro @assert expr.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@assert",
    "page": "Essentials",
    "title": "Base.@assert",
    "category": "Macro",
    "text": "@assert cond [text]\n\nThrow an AssertionError if cond is false. Preferred syntax for writing assertions. Message text is optionally displayed upon assertion failure.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.ArgumentError",
    "page": "Essentials",
    "title": "Base.ArgumentError",
    "category": "Type",
    "text": "ArgumentError(msg)\n\nThe parameters to a function call do not match a valid signature. Argument msg is a descriptive error string.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.AssertionError",
    "page": "Essentials",
    "title": "Base.AssertionError",
    "category": "Type",
    "text": "AssertionError([msg])\n\nThe asserted condition did not evaluate to true. Optional argument msg is a descriptive error string.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.BoundsError",
    "page": "Essentials",
    "title": "Core.BoundsError",
    "category": "Type",
    "text": "BoundsError([a],[i])\n\nAn indexing operation into an array, a, tried to access an out-of-bounds element, i.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.DimensionMismatch",
    "page": "Essentials",
    "title": "Base.DimensionMismatch",
    "category": "Type",
    "text": "DimensionMismatch([msg])\n\nThe objects called do not have matching dimensionality. Optional argument msg is a descriptive error string.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.DivideError",
    "page": "Essentials",
    "title": "Core.DivideError",
    "category": "Type",
    "text": "DivideError()\n\nInteger division was attempted with a denominator value of 0.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.DomainError",
    "page": "Essentials",
    "title": "Core.DomainError",
    "category": "Type",
    "text": "DomainError()\n\nThe arguments to a function or constructor are outside the valid domain.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.EOFError",
    "page": "Essentials",
    "title": "Base.EOFError",
    "category": "Type",
    "text": "EOFError()\n\nNo more data was available to read from a file or stream.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.ErrorException",
    "page": "Essentials",
    "title": "Core.ErrorException",
    "category": "Type",
    "text": "ErrorException(msg)\n\nGeneric error type. The error message, in the .msg field, may provide more specific details.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.InexactError",
    "page": "Essentials",
    "title": "Core.InexactError",
    "category": "Type",
    "text": "InexactError()\n\nType conversion cannot be done exactly.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.InterruptException",
    "page": "Essentials",
    "title": "Core.InterruptException",
    "category": "Type",
    "text": "InterruptException()\n\nThe process was stopped by a terminal interrupt (CTRL+C).\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.KeyError",
    "page": "Essentials",
    "title": "Base.KeyError",
    "category": "Type",
    "text": "KeyError(key)\n\nAn indexing operation into an Associative (Dict) or Set like object tried to access or delete a non-existent element.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.LoadError",
    "page": "Essentials",
    "title": "Base.LoadError",
    "category": "Type",
    "text": "LoadError(file::AbstractString, line::Int, error)\n\nAn error occurred while includeing, requireing, or using a file. The error specifics should be available in the .error field.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.MethodError",
    "page": "Essentials",
    "title": "Base.MethodError",
    "category": "Type",
    "text": "MethodError(f, args)\n\nA method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.NullException",
    "page": "Essentials",
    "title": "Base.NullException",
    "category": "Type",
    "text": "NullException()\n\nAn attempted access to a Nullable with no defined value.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.OutOfMemoryError",
    "page": "Essentials",
    "title": "Core.OutOfMemoryError",
    "category": "Type",
    "text": "OutOfMemoryError()\n\nAn operation allocated too much memory for either the system or the garbage collector to handle properly.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.ReadOnlyMemoryError",
    "page": "Essentials",
    "title": "Core.ReadOnlyMemoryError",
    "category": "Type",
    "text": "ReadOnlyMemoryError()\n\nAn operation tried to write to memory that is read-only.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.OverflowError",
    "page": "Essentials",
    "title": "Core.OverflowError",
    "category": "Type",
    "text": "OverflowError()\n\nThe result of an expression is too large for the specified type and will cause a wraparound.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.ParseError",
    "page": "Essentials",
    "title": "Base.ParseError",
    "category": "Type",
    "text": "ParseError(msg)\n\nThe expression passed to the parse function could not be interpreted as a valid Julia expression.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Distributed.ProcessExitedException",
    "page": "Essentials",
    "title": "Base.Distributed.ProcessExitedException",
    "category": "Type",
    "text": "ProcessExitedException()\n\nAfter a client Julia process has exited, further attempts to reference the dead child will throw this exception.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.StackOverflowError",
    "page": "Essentials",
    "title": "Core.StackOverflowError",
    "category": "Type",
    "text": "StackOverflowError()\n\nThe function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.SystemError",
    "page": "Essentials",
    "title": "Base.SystemError",
    "category": "Type",
    "text": "SystemError(prefix::AbstractString, [errno::Int32])\n\nA system call failed with an error code (in the errno global variable).\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.TypeError",
    "page": "Essentials",
    "title": "Core.TypeError",
    "category": "Type",
    "text": "TypeError(func::Symbol, context::AbstractString, expected::Type, got)\n\nA type assertion failure, or calling an intrinsic function with an incorrect argument type.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.UndefRefError",
    "page": "Essentials",
    "title": "Core.UndefRefError",
    "category": "Type",
    "text": "UndefRefError()\n\nThe item or field is not defined for the given object.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.UndefVarError",
    "page": "Essentials",
    "title": "Core.UndefVarError",
    "category": "Type",
    "text": "UndefVarError(var::Symbol)\n\nA symbol in the current scope is not defined.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.InitError",
    "page": "Essentials",
    "title": "Base.InitError",
    "category": "Type",
    "text": "InitError(mod::Symbol, error)\n\nAn error occurred when running a module's __init__ function. The actual error thrown is available in the .error field.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.retry",
    "page": "Essentials",
    "title": "Base.retry",
    "category": "Function",
    "text": "retry(f::Function;  delays=ExponentialBackOff(), check=nothing) -> Function\n\nReturns an anonymous function that calls function f.  If an exception arises, f is repeatedly called again, each time check returns true, after waiting the number of seconds specified in delays.  check should input delays's current state and the Exception.\n\nExamples\n\nretry(f, delays=fill(5.0, 3))\nretry(f, delays=rand(5:10, 2))\nretry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))\nretry(http_get, check=(s,e)->e.status == \"503\")(url)\nretry(read, check=(s,e)->isa(e, UVError))(io, 128; all=false)\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.ExponentialBackOff",
    "page": "Essentials",
    "title": "Base.ExponentialBackOff",
    "category": "Type",
    "text": "ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)\n\nA Float64 iterator of length n whose elements exponentially increase at a rate in the interval factor * (1 ± jitter).  The first element is first_delay and all elements are clamped to max_delay.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Errores-1",
    "page": "Essentials",
    "title": "Errores",
    "category": "section",
    "text": "Base.error\nCore.throw\nBase.rethrow\nBase.backtrace\nBase.catch_backtrace\nBase.assert\nBase.@assert\nBase.ArgumentError\nBase.AssertionError\nCore.BoundsError\nBase.DimensionMismatch\nCore.DivideError\nCore.DomainError\nBase.EOFError\nCore.ErrorException\nCore.InexactError\nCore.InterruptException\nBase.KeyError\nBase.LoadError\nBase.MethodError\nBase.NullException\nCore.OutOfMemoryError\nCore.ReadOnlyMemoryError\nCore.OverflowError\nBase.ParseError\nBase.ProcessExitedException\nCore.StackOverflowError\nBase.SystemError\nCore.TypeError\nCore.UndefRefError\nCore.UndefVarError\nBase.InitError\nBase.retry\nBase.ExponentialBackOff"
},

{
    "location": "stdlib/base.html#Base.Timer-Tuple{Function,Real,Real}",
    "page": "Essentials",
    "title": "Base.Timer",
    "category": "Method",
    "text": "Timer(callback::Function, delay, repeat=0)\n\nCreate a timer to call the given callback function. The callback is passed one argument, the timer object itself. The callback will be invoked after the specified initial delay, and then repeating with the given repeat interval. If repeat is 0, the timer is only triggered once. Times are in seconds. A timer is stopped and has its resources freed by calling close on it.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.Timer",
    "page": "Essentials",
    "title": "Base.Timer",
    "category": "Type",
    "text": "Timer(delay, repeat=0)\n\nCreate a timer that wakes up tasks waiting for it (by calling wait on the timer object) at a specified interval.  Times are in seconds.  Waiting tasks are woken with an error when the timer is closed (by close. Use isopen to check whether a timer is still active.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.AsyncCondition",
    "page": "Essentials",
    "title": "Base.AsyncCondition",
    "category": "Type",
    "text": "AsyncCondition()\n\nCreate a async condition that wakes up tasks waiting for it (by calling wait on the object) when notified from C by a call to uv_async_send. Waiting tasks are woken with an error when the object is closed (by close. Use isopen to check whether it is still active.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.AsyncCondition-Tuple{Function}",
    "page": "Essentials",
    "title": "Base.AsyncCondition",
    "category": "Method",
    "text": "AsyncCondition(callback::Function)\n\nCreate a async condition that calls the given callback function. The callback is passed one argument, the async condition object itself.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Eventos-1",
    "page": "Essentials",
    "title": "Eventos",
    "category": "section",
    "text": "Base.Timer(::Function, ::Real, ::Real)\nBase.Timer\nBase.AsyncCondition\nBase.AsyncCondition(::Function)"
},

{
    "location": "stdlib/base.html#Base.module_name",
    "page": "Essentials",
    "title": "Base.module_name",
    "category": "Function",
    "text": "module_name(m::Module) -> Symbol\n\nGet the name of a Module as a Symbol.\n\njulia> module_name(Base.LinAlg)\n:LinAlg\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.module_parent",
    "page": "Essentials",
    "title": "Base.module_parent",
    "category": "Function",
    "text": "module_parent(m::Module) -> Module\n\nGet a module's enclosing Module. Main is its own parent, as is LastMain after workspace().\n\njulia> module_parent(Main)\nMain\n\njulia> module_parent(Base.LinAlg.BLAS)\nBase.LinAlg\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.current_module",
    "page": "Essentials",
    "title": "Base.current_module",
    "category": "Function",
    "text": "current_module() -> Module\n\nGet the dynamically current Module, which is the Module code is currently being read from. In general, this is not the same as the module containing the call to this function.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.fullname",
    "page": "Essentials",
    "title": "Base.fullname",
    "category": "Function",
    "text": "fullname(m::Module)\n\nGet the fully-qualified name of a module as a tuple of symbols. For example,\n\njulia> fullname(Base.Pkg)\n(:Base, :Pkg)\n\njulia> fullname(Main)\n()\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.names",
    "page": "Essentials",
    "title": "Base.names",
    "category": "Function",
    "text": "names(x::Module, all::Bool=false, imported::Bool=false)\n\nGet an array of the names exported by a Module, excluding deprecated names. If all is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If imported is true, then names explicitly imported from other modules are also included.\n\nAs a special case, all names defined in Main are considered \"exported\", since it is not idiomatic to explicitly export names from Main.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Core.nfields",
    "page": "Essentials",
    "title": "Core.nfields",
    "category": "Function",
    "text": "nfields(x::DataType) -> Int\n\nGet the number of fields of a DataType.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.fieldnames",
    "page": "Essentials",
    "title": "Base.fieldnames",
    "category": "Function",
    "text": "fieldnames(x::DataType)\n\nGet an array of the fields of a DataType.\n\njulia> fieldnames(Hermitian)\n2-element Array{Symbol,1}:\n :data\n :uplo\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.fieldname",
    "page": "Essentials",
    "title": "Base.fieldname",
    "category": "Function",
    "text": "fieldname(x::DataType, i::Integer)\n\nGet the name of field i of a DataType.\n\njulia> fieldname(SparseMatrixCSC,1)\n:m\n\njulia> fieldname(SparseMatrixCSC,5)\n:nzval\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.datatype_module",
    "page": "Essentials",
    "title": "Base.datatype_module",
    "category": "Function",
    "text": "Base.datatype_module(t::DataType) -> Module\n\nDetermine the module containing the definition of a DataType.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.datatype_name",
    "page": "Essentials",
    "title": "Base.datatype_name",
    "category": "Function",
    "text": "Base.datatype_name(t) -> Symbol\n\nGet the name of a (potentially UnionAll-wrapped) DataType (without its parent module) as a symbol.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.isconst",
    "page": "Essentials",
    "title": "Base.isconst",
    "category": "Function",
    "text": "isconst([m::Module], s::Symbol) -> Bool\n\nDetermine whether a global is declared const in a given Module. The default Module argument is current_module().\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.function_name",
    "page": "Essentials",
    "title": "Base.function_name",
    "category": "Function",
    "text": "Base.function_name(f::Function) -> Symbol\n\nGet the name of a generic Function as a symbol, or :anonymous.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.function_module-Tuple{Function}",
    "page": "Essentials",
    "title": "Base.function_module",
    "category": "Method",
    "text": "Base.function_module(f::Function) -> Module\n\nDetermine the module containing the (first) definition of a generic function.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.function_module-Tuple{Any,Any}",
    "page": "Essentials",
    "title": "Base.function_module",
    "category": "Method",
    "text": "Base.function_module(f::Function, types) -> Module\n\nDetermine the module containing a given definition of a generic function.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.functionloc-Tuple{Any,Any}",
    "page": "Essentials",
    "title": "Base.functionloc",
    "category": "Method",
    "text": "functionloc(f::Function, types)\n\nReturns a tuple (filename,line) giving the location of a generic Function definition.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.functionloc-Tuple{Method}",
    "page": "Essentials",
    "title": "Base.functionloc",
    "category": "Method",
    "text": "functionloc(m::Method)\n\nReturns a tuple (filename,line) giving the location of a Method definition.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@functionloc",
    "page": "Essentials",
    "title": "Base.@functionloc",
    "category": "Macro",
    "text": "@functionloc\n\nApplied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple (filename,line) giving the location for the method that would be called for those arguments. It calls out to the functionloc function.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Reflexión-1",
    "page": "Essentials",
    "title": "Reflexión",
    "category": "section",
    "text": "Base.module_name\nBase.module_parent\nBase.current_module\nBase.fullname\nBase.names\nCore.nfields\nBase.fieldnames\nBase.fieldname\nBase.datatype_module\nBase.datatype_name\nBase.isconst\nBase.function_name\nBase.function_module(::Function)\nBase.function_module(::Any, ::Any)\nBase.functionloc(::Any, ::Any)\nBase.functionloc(::Method)\nBase.@functionloc"
},

{
    "location": "stdlib/base.html#Base.gc",
    "page": "Essentials",
    "title": "Base.gc",
    "category": "Function",
    "text": "gc()\n\nPerform garbage collection. This should not generally be used.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.gc_enable",
    "page": "Essentials",
    "title": "Base.gc_enable",
    "category": "Function",
    "text": "gc_enable(on::Bool)\n\nControl whether garbage collection is enabled using a boolean argument (true for enabled, false for disabled). Returns previous GC state. Disabling garbage collection should be used only with extreme caution, as it can cause memory use to grow without bound.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.macroexpand",
    "page": "Essentials",
    "title": "Base.macroexpand",
    "category": "Function",
    "text": "macroexpand(x)\n\nTakes the expression x and returns an equivalent expression with all macros removed (expanded).\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@macroexpand",
    "page": "Essentials",
    "title": "Base.@macroexpand",
    "category": "Macro",
    "text": "@macroexpand\n\nReturn equivalent expression with all macros removed (expanded).\n\nThere is a subtle difference between @macroexpand and macroexpand in that expansion takes place in different contexts. This is best seen in the following example:\n\njulia> module M\n           macro m()\n               1\n           end\n           function f()\n               (@macroexpand(@m), macroexpand(:(@m)))\n           end\n       end\nM\n\njulia> macro m()\n           2\n       end\n@m (macro with 1 method)\n\njulia> M.f()\n(1, 2)\n\nWith @macroexpand the expression expands where @macroexpand appears in the code (module M in the example). With macroexpand the expression expands in the current module where the code was finally called (REPL in the example). Note that when calling macroexpand or @macroexpand directly from the REPL, both of these contexts coincide, hence there is no difference.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.expand",
    "page": "Essentials",
    "title": "Base.expand",
    "category": "Function",
    "text": "expand(x)\n\nTakes the expression x and returns an equivalent expression in lowered form. See also code_lowered.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.code_lowered",
    "page": "Essentials",
    "title": "Base.code_lowered",
    "category": "Function",
    "text": "code_lowered(f, types)\n\nReturns an array of lowered ASTs for the methods matching the given generic function and type signature.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@code_lowered",
    "page": "Essentials",
    "title": "Base.@code_lowered",
    "category": "Macro",
    "text": "@code_lowered\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_lowered on the resulting expression.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.code_typed",
    "page": "Essentials",
    "title": "Base.code_typed",
    "category": "Function",
    "text": "code_typed(f, types; optimize=true)\n\nReturns an array of lowered and type-inferred ASTs for the methods matching the given generic function and type signature. The keyword argument optimize controls whether additional optimizations, such as inlining, are also applied.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@code_typed",
    "page": "Essentials",
    "title": "Base.@code_typed",
    "category": "Macro",
    "text": "@code_typed\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_typed on the resulting expression.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.code_warntype",
    "page": "Essentials",
    "title": "Base.code_warntype",
    "category": "Function",
    "text": "code_warntype([io::IO], f, types)\n\nPrints lowered and type-inferred ASTs for the methods matching the given generic function and type signature to io which defaults to STDOUT. The ASTs are annotated in such a way as to cause \"non-leaf\" types to be emphasized (if color is available, displayed in red). This serves as a warning of potential type instability. Not all non-leaf types are particularly problematic for performance, so the results need to be used judiciously. See @code_warntype for more information.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@code_warntype",
    "page": "Essentials",
    "title": "Base.@code_warntype",
    "category": "Macro",
    "text": "@code_warntype\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_warntype on the resulting expression.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.code_llvm",
    "page": "Essentials",
    "title": "Base.code_llvm",
    "category": "Function",
    "text": "code_llvm([io], f, types)\n\nPrints the LLVM bitcodes generated for running the method matching the given generic function and type signature to io which defaults to STDOUT.\n\nAll metadata and dbg.* calls are removed from the printed bitcode. Use code_llvm_raw for the full IR.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@code_llvm",
    "page": "Essentials",
    "title": "Base.@code_llvm",
    "category": "Macro",
    "text": "@code_llvm\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_llvm on the resulting expression.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.code_native",
    "page": "Essentials",
    "title": "Base.code_native",
    "category": "Function",
    "text": "code_native([io], f, types, [syntax])\n\nPrints the native assembly instructions generated for running the method matching the given generic function and type signature to io which defaults to STDOUT. Switch assembly syntax using syntax symbol parameter set to :att for AT&T syntax or :intel for Intel syntax. Output is AT&T syntax by default.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.@code_native",
    "page": "Essentials",
    "title": "Base.@code_native",
    "category": "Macro",
    "text": "@code_native\n\nEvaluates the arguments to the function or macro call, determines their types, and calls code_native on the resulting expression.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Base.precompile",
    "page": "Essentials",
    "title": "Base.precompile",
    "category": "Function",
    "text": "precompile(f,args::Tuple{Vararg{Any}})\n\nCompile the given function f for the argument tuple (of types) args, but do not execute it.\n\n\n\n"
},

{
    "location": "stdlib/base.html#Interioridades-1",
    "page": "Essentials",
    "title": "Interioridades",
    "category": "section",
    "text": "Base.gc\nBase.gc_enable\nBase.macroexpand\nBase.@macroexpand\nBase.expand\nBase.code_lowered\nBase.@code_lowered\nBase.code_typed\nBase.@code_typed\nBase.code_warntype\nBase.@code_warntype\nBase.code_llvm\nBase.@code_llvm\nBase.code_native\nBase.@code_native\nBase.precompile"
},

{
    "location": "stdlib/collections.html#",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Colecciones y Estructuras de Datos",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/collections.html#collections-1",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Colecciones y Estructuras de Datos",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/collections.html#Base.start",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.start",
    "category": "Function",
    "text": "start(iter) -> state\n\nGet initial iteration state for an iterable object.\n\nExamples\n\njulia> start(1:5)\n1\n\njulia> start([1;2;3])\n1\n\njulia> start([4;2;3])\n1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.done",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.done",
    "category": "Function",
    "text": "done(iter, state) -> Bool\n\nTest whether we are done iterating.\n\nExamples\n\njulia> done(1:5, 3)\nfalse\n\njulia> done(1:5, 5)\nfalse\n\njulia> done(1:5, 6)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.next",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.next",
    "category": "Function",
    "text": "next(iter, state) -> item, state\n\nFor a given iterable object and iteration state, return the current item and the next iteration state.\n\nExamples\n\njulia> next(1:5, 3)\n(3, 4)\n\njulia> next(1:5, 5)\n(5, 6)\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.iteratorsize",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.iteratorsize",
    "category": "Function",
    "text": "iteratorsize(itertype::Type) -> IteratorSize\n\nGiven the type of an iterator, returns one of the following values:\n\nSizeUnknown() if the length (number of elements) cannot be determined in advance.\nHasLength() if there is a fixed, finite length.\nHasShape() if there is a known length plus a notion of multidimensional shape (as for an array).  In this case the size function is valid for the iterator.\nIsInfinite() if the iterator yields values forever.\n\nThe default value (for iterators that do not define this function) is HasLength(). This means that most iterators are assumed to implement length.\n\nThis trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.\n\njulia> Base.iteratorsize(1:5)\nBase.HasShape()\n\njulia> Base.iteratorsize((2,3))\nBase.HasLength()\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.iteratoreltype",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.iteratoreltype",
    "category": "Function",
    "text": "iteratoreltype(itertype::Type) -> IteratorEltype\n\nGiven the type of an iterator, returns one of the following values:\n\nEltypeUnknown() if the type of elements yielded by the iterator is not known in advance.\nHasEltype() if the element type is known, and eltype would return a meaningful value.\n\nHasEltype() is the default, since iterators are assumed to implement eltype.\n\nThis trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.\n\njulia> Base.iteratoreltype(1:5)\nBase.HasEltype()\n\n\n\n"
},

{
    "location": "stdlib/collections.html#lib-collections-iteration-1",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Iteración",
    "category": "section",
    "text": "La iteración secuencial es implementada por los métodos start(), done() y next(). El bucle for general:for i = I   # o  \"for i in I\"\n    # cuerpo\nendes traducido a:state = start(I)\nwhile !done(I, state)\n    (i, state) = next(I, state)\n    # cuerpo\nendEl objeto state puede ser cualquier cosa, y debería ser elegido apropiadamente para cada tipo iterable. Ver la sección del manual sobre la interfaz de iteración para más detalles sobre definir un tipo iterable personalizado.Base.start\nBase.done\nBase.next\nBase.iteratorsize\nBase.iteratoreltypeCompletamente implementada por:Range\nUnitRange\nTuple\nNumber\nAbstractArray\nIntSet\nObjectIdDict\nDict\nWeakKeyDict\nEachLine\nAbstractString\nSet"
},

{
    "location": "stdlib/collections.html#Base.isempty",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.isempty",
    "category": "Function",
    "text": "isempty(collection) -> Bool\n\nDetermine whether a collection is empty (has no elements).\n\nExamples\n\njulia> isempty([])\ntrue\n\njulia> isempty([1 2 3])\nfalse\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.empty!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.empty!",
    "category": "Function",
    "text": "empty!(collection) -> collection\n\nRemove all elements from a collection.\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String,Int64} with 0 entries\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.length-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.length",
    "category": "Method",
    "text": "length(collection) -> Integer\n\nFor ordered, indexable collections, returns the maximum index i for which getindex(collection, i) is valid. For unordered collections, returns the number of elements.\n\nExamples\n\njulia> length(1:5)\n5\n\njulia> length([1; 2; 3; 4])\n4\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.endof",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.endof",
    "category": "Function",
    "text": "endof(collection) -> Integer\n\nReturns the last index of the collection.\n\nExample\n\njulia> endof([1,2,4])\n3\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Colecciones-Generales-1",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Colecciones Generales",
    "category": "section",
    "text": "Base.isempty\nBase.empty!\nBase.length(::Any)\nBase.endofCompletamente implementado por:Range\nUnitRange\nTuple\nNumber\nAbstractArray\nIntSet\nObjectIdDict\nDict\nWeakKeyDict\nAbstractString\nSet"
},

{
    "location": "stdlib/collections.html#Base.in",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.in",
    "category": "Function",
    "text": "in(item, collection) -> Bool\n∈(item,collection) -> Bool\n∋(collection,item) -> Bool\n∉(item,collection) -> Bool\n∌(collection,item) -> Bool\n\nDetermine whether an item is in the given collection, in the sense that it is == to one of the values generated by iterating over the collection. Some collections need a slightly different definition; for example Sets check whether the item isequal to one of the elements. Dicts look for (key,value) pairs, and the key is compared using isequal. To test for the presence of a key in a dictionary, use haskey or k in keys(dict).\n\njulia> a = 1:3:20\n1:3:19\n\njulia> 4 in a\ntrue\n\njulia> 5 in a\nfalse\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.eltype",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.eltype",
    "category": "Function",
    "text": "eltype(type)\n\nDetermine the type of the elements generated by iterating a collection of the given type. For associative collection types, this will be a Pair{KeyType,ValType}. The definition eltype(x) = eltype(typeof(x)) is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.\n\njulia> eltype(ones(Float32,2,2))\nFloat32\n\njulia> eltype(ones(Int8,2,2))\nInt8\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.indexin",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.indexin",
    "category": "Function",
    "text": "indexin(a, b)\n\nReturns a vector containing the highest index in b for each value in a that is a member of b . The output vector contains 0 wherever a is not a member of b.\n\nExamples\n\njulia> a = ['a', 'b', 'c', 'b', 'd', 'a'];\n\njulia> b = ['a','b','c'];\n\njulia> indexin(a,b)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 2\n 0\n 1\n\njulia> indexin(b,a)\n3-element Array{Int64,1}:\n 6\n 4\n 3\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.findin",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.findin",
    "category": "Function",
    "text": "findin(a, b)\n\nReturns the indices of elements in collection a that appear in collection b.\n\nExamples\n\njulia> a = collect(1:3:15)\n5-element Array{Int64,1}:\n  1\n  4\n  7\n 10\n 13\n\njulia> b = collect(2:4:10)\n3-element Array{Int64,1}:\n  2\n  6\n 10\n\njulia> findin(a,b) # 10 is the only common element\n1-element Array{Int64,1}:\n 4\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.unique",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.unique",
    "category": "Function",
    "text": "unique(itr)\n\nReturns an array containing one value from itr for each unique value, as determined by isequal.\n\njulia> unique([1; 2; 2; 6])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\n\n\nunique(f, itr)\n\nReturns an array containing one value from itr for each unique value produced by f applied to elements of itr.\n\njulia> unique(isodd, [1; 2; 2; 6])\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\nunique(itr[, dim])\n\nReturns an array containing only the unique elements of the iterable itr, in the order that the first of each set of equivalent elements originally appears. If dim is specified, returns unique regions of the array itr along dim.\n\njulia> A = map(isodd, reshape(collect(1:8), (2,2,2)))\n2×2×2 Array{Bool,3}:\n[:, :, 1] =\n  true   true\n false  false\n\n[:, :, 2] =\n  true   true\n false  false\n\njulia> unique(A)\n2-element Array{Bool,1}:\n  true\n false\n\njulia> unique(A, 2)\n2×1×2 Array{Bool,3}:\n[:, :, 1] =\n  true\n false\n\n[:, :, 2] =\n  true\n false\n\njulia> unique(A, 3)\n2×2×1 Array{Bool,3}:\n[:, :, 1] =\n  true   true\n false  false\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.allunique",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.allunique",
    "category": "Function",
    "text": "allunique(itr) -> Bool\n\nReturn true if all values from itr are distinct when compared with isequal.\n\njulia> a = [1; 2; 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> allunique([a, a])\nfalse\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.reduce-Tuple{Any,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.reduce",
    "category": "Method",
    "text": "reduce(op, v0, itr)\n\nReduce the given collection ìtr with the given binary operator op. v0 must be a neutral element for op that will be returned for empty collections. It is unspecified whether v0 is used for non-empty collections.\n\nReductions for certain commonly-used operators have special implementations which should be used instead: maximum(itr), minimum(itr), sum(itr), prod(itr), any(itr), all(itr).\n\nThe associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like - because it is undefined whether reduce(-,[1,2,3]) should be evaluated as (1-2)-3 or 1-(2-3). Use foldl or foldr instead for guaranteed left or right associativity.\n\nSome operations accumulate error, and parallelism will also be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.\n\nExamples\n\njulia> reduce(*, 1, [2; 3; 4])\n24\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.reduce-Tuple{Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.reduce",
    "category": "Method",
    "text": "reduce(op, itr)\n\nLike reduce(op, v0, itr). This cannot be used with empty collections, except for some special cases (e.g. when op is one of +, *, max, min, &, |) when Julia can determine the neutral element of op.\n\njulia> reduce(*, [2; 3; 4])\n24\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.foldl-Tuple{Any,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.foldl",
    "category": "Method",
    "text": "foldl(op, v0, itr)\n\nLike reduce, but with guaranteed left associativity. v0 will be used exactly once.\n\njulia> foldl(-, 1, 2:5)\n-13\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.foldl-Tuple{Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.foldl",
    "category": "Method",
    "text": "foldl(op, itr)\n\nLike foldl(op, v0, itr), but using the first element of itr as v0. In general, this cannot be used with empty collections (see reduce(op, itr)).\n\njulia> foldl(-, 2:5)\n-10\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.foldr-Tuple{Any,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.foldr",
    "category": "Method",
    "text": "foldr(op, v0, itr)\n\nLike reduce, but with guaranteed right associativity. v0 will be used exactly once.\n\njulia> foldr(-, 1, 2:5)\n-1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.foldr-Tuple{Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.foldr",
    "category": "Method",
    "text": "foldr(op, itr)\n\nLike foldr(op, v0, itr), but using the last element of itr as v0. In general, this cannot be used with empty collections (see reduce(op, itr)).\n\njulia> foldr(-, 2:5)\n-2\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.maximum-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.maximum",
    "category": "Method",
    "text": "maximum(itr)\n\nReturns the largest element in a collection.\n\njulia> maximum(-20.5:10)\n9.5\n\njulia> maximum([1,2,3])\n3\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.maximum-Tuple{Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.maximum",
    "category": "Method",
    "text": "maximum(A, dims)\n\nCompute the maximum value of an array over the given dimensions. See also the max(a,b) function to take the maximum of two or more arguments, which can be applied elementwise to arrays via max.(a,b).\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> maximum(A, 1)\n1×2 Array{Int64,2}:\n 3  4\n\njulia> maximum(A, 2)\n2×1 Array{Int64,2}:\n 2\n 4\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.maximum!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.maximum!",
    "category": "Function",
    "text": "maximum!(r, A)\n\nCompute the maximum value of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> maximum!([1; 1], A)\n2-element Array{Int64,1}:\n 2\n 4\n\njulia> maximum!([1 1], A)\n1×2 Array{Int64,2}:\n 3  4\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.minimum-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.minimum",
    "category": "Method",
    "text": "minimum(itr)\n\nReturns the smallest element in a collection.\n\njulia> minimum(-20.5:10)\n-20.5\n\njulia> minimum([1,2,3])\n1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.minimum-Tuple{Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.minimum",
    "category": "Method",
    "text": "minimum(A, dims)\n\nCompute the minimum value of an array over the given dimensions. See also the min(a,b) function to take the minimum of two or more arguments, which can be applied elementwise to arrays via min.(a,b).\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> minimum(A, 1)\n1×2 Array{Int64,2}:\n 1  2\n\njulia> minimum(A, 2)\n2×1 Array{Int64,2}:\n 1\n 3\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.minimum!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.minimum!",
    "category": "Function",
    "text": "minimum!(r, A)\n\nCompute the minimum value of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> minimum!([1; 1], A)\n2-element Array{Int64,1}:\n 1\n 3\n\njulia> minimum!([1 1], A)\n1×2 Array{Int64,2}:\n 1  2\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.extrema-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.extrema",
    "category": "Method",
    "text": "extrema(itr) -> Tuple\n\nCompute both the minimum and maximum element in a single pass, and return them as a 2-tuple.\n\njulia> extrema(2:10)\n(2, 10)\n\njulia> extrema([9,pi,4.5])\n(3.141592653589793, 9.0)\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.extrema-Tuple{AbstractArray,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.extrema",
    "category": "Method",
    "text": "extrema(A, dims) -> Array{Tuple}\n\nCompute the minimum and maximum elements of an array over the given dimensions.\n\nExample\n\njulia> A = reshape(collect(1:2:16), (2,2,2))\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  5\n 3  7\n\n[:, :, 2] =\n  9  13\n 11  15\n\njulia> extrema(A, (1,2))\n1×1×2 Array{Tuple{Int64,Int64},3}:\n[:, :, 1] =\n (1, 7)\n\n[:, :, 2] =\n (9, 15)\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.indmax",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.indmax",
    "category": "Function",
    "text": "indmax(itr) -> Integer\n\nReturns the index of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned. NaN values are ignored, unless all elements are NaN.\n\nThe collection must not be empty.\n\nExamples\n\njulia> indmax([8,0.1,-9,pi])\n1\n\njulia> indmax([1,7,7,6])\n2\n\njulia> indmax([1,7,7,NaN])\n2\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.indmin",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.indmin",
    "category": "Function",
    "text": "indmin(itr) -> Integer\n\nReturns the index of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned. NaN values are ignored, unless all elements are NaN.\n\nThe collection must not be empty.\n\nExamples\n\njulia> indmin([8,0.1,-9,pi])\n3\n\njulia> indmin([7,1,1,6])\n2\n\njulia> indmin([7,1,1,NaN])\n2\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.findmax-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.findmax",
    "category": "Method",
    "text": "findmax(itr) -> (x, index)\n\nReturns the maximum element of the collection itr and its index. If there are multiple maximal elements, then the first one will be returned. NaN values are ignored, unless all elements are NaN.\n\nThe collection must not be empty.\n\nExamples\n\njulia> findmax([8,0.1,-9,pi])\n(8.0, 1)\n\njulia> findmax([1,7,7,6])\n(7, 2)\n\njulia> findmax([1,7,7,NaN])\n(7.0, 2)\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.findmax-Tuple{AbstractArray,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.findmax",
    "category": "Method",
    "text": "findmax(A, region) -> (maxval, index)\n\nFor an array input, returns the value and index of the maximum over the given region.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> findmax(A,1)\n([3 4], [2 4])\n\njulia> findmax(A,2)\n([2; 4], [3; 4])\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.findmin-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.findmin",
    "category": "Method",
    "text": "findmin(itr) -> (x, index)\n\nReturns the minimum element of the collection itr and its index. If there are multiple minimal elements, then the first one will be returned. NaN values are ignored, unless all elements are NaN.\n\nThe collection must not be empty.\n\nExamples\n\njulia> findmin([8,0.1,-9,pi])\n(-9.0, 3)\n\njulia> findmin([7,1,1,6])\n(1, 2)\n\njulia> findmin([7,1,1,NaN])\n(1.0, 2)\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.findmin-Tuple{AbstractArray,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.findmin",
    "category": "Method",
    "text": "findmin(A, region) -> (minval, index)\n\nFor an array input, returns the value and index of the minimum over the given region.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> findmin(A, 1)\n([1 2], [1 3])\n\njulia> findmin(A, 2)\n([1; 3], [1; 2])\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.findmax!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.findmax!",
    "category": "Function",
    "text": "findmax!(rval, rind, A, [init=true]) -> (maxval, index)\n\nFind the maximum of A and the corresponding linear index along singleton dimensions of rval and rind, and store the results in rval and rind.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.findmin!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.findmin!",
    "category": "Function",
    "text": "findmin!(rval, rind, A, [init=true]) -> (minval, index)\n\nFind the minimum of A and the corresponding linear index along singleton dimensions of rval and rind, and store the results in rval and rind.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.sum",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.sum",
    "category": "Function",
    "text": "sum(f, itr)\n\nSum the results of calling function f on each element of itr.\n\njulia> sum(abs2, [2; 3; 4])\n29\n\n\n\nsum(itr)\n\nReturns the sum of all elements in a collection.\n\njulia> sum(1:20)\n210\n\n\n\nsum(A, dims)\n\nSum elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> sum(A, 1)\n1×2 Array{Int64,2}:\n 4  6\n\njulia> sum(A, 2)\n2×1 Array{Int64,2}:\n 3\n 7\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.sum!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.sum!",
    "category": "Function",
    "text": "sum!(r, A)\n\nSum elements of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> sum!([1; 1], A)\n2-element Array{Int64,1}:\n 3\n 7\n\njulia> sum!([1 1], A)\n1×2 Array{Int64,2}:\n 4  6\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.prod",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.prod",
    "category": "Function",
    "text": "prod(f, itr)\n\nReturns the product of f applied to each element of itr.\n\njulia> prod(abs2, [2; 3; 4])\n576\n\n\n\nprod(itr)\n\nReturns the product of all elements of a collection.\n\njulia> prod(1:20)\n2432902008176640000\n\n\n\nprod(A, dims)\n\nMultiply elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> prod(A, 1)\n1×2 Array{Int64,2}:\n 3  8\n\njulia> prod(A, 2)\n2×1 Array{Int64,2}:\n  2\n 12\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.prod!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.prod!",
    "category": "Function",
    "text": "prod!(r, A)\n\nMultiply elements of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> prod!([1; 1], A)\n2-element Array{Int64,1}:\n  2\n 12\n\njulia> prod!([1 1], A)\n1×2 Array{Int64,2}:\n 3  8\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.any-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.any",
    "category": "Method",
    "text": "any(itr) -> Bool\n\nTest whether any elements of a boolean collection are true, returning true as soon as the first true value in itr is encountered (short-circuiting).\n\njulia> a = [true,false,false,true]\n4-element Array{Bool,1}:\n  true\n false\n false\n  true\n\njulia> any(a)\ntrue\n\njulia> any((println(i); v) for (i, v) in enumerate(a))\n1\ntrue\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.any-Tuple{AbstractArray,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.any",
    "category": "Method",
    "text": "any(A, dims)\n\nTest whether any values along the given dimensions of an array are true.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n true  false\n true  false\n\njulia> any(A, 1)\n1×2 Array{Bool,2}:\n true  false\n\njulia> any(A, 2)\n2×1 Array{Bool,2}:\n true\n true\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.any!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.any!",
    "category": "Function",
    "text": "any!(r, A)\n\nTest whether any values in A along the singleton dimensions of r are true, and write results to r.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n true  false\n true  false\n\njulia> any!([1; 1], A)\n2-element Array{Int64,1}:\n 1\n 1\n\njulia> any!([1 1], A)\n1×2 Array{Int64,2}:\n 1  0\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.all-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.all",
    "category": "Method",
    "text": "all(itr) -> Bool\n\nTest whether all elements of a boolean collection are true, returning false as soon as the first false value in itr is encountered (short-circuiting).\n\njulia> a = [true,false,false,true]\n4-element Array{Bool,1}:\n  true\n false\n false\n  true\n\njulia> all(a)\nfalse\n\njulia> all((println(i); v) for (i, v) in enumerate(a))\n1\n2\nfalse\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.all-Tuple{AbstractArray,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.all",
    "category": "Method",
    "text": "all(A, dims)\n\nTest whether all values along the given dimensions of an array are true.\n\nExamples\n\njulia> A = [true false; true true]\n2×2 Array{Bool,2}:\n true  false\n true   true\n\njulia> all(A, 1)\n1×2 Array{Bool,2}:\n true  false\n\njulia> all(A, 2)\n2×1 Array{Bool,2}:\n false\n  true\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.all!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.all!",
    "category": "Function",
    "text": "all!(r, A)\n\nTest whether all values in A along the singleton dimensions of r are true, and write results to r.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Array{Bool,2}:\n true  false\n true  false\n\njulia> all!([1; 1], A)\n2-element Array{Int64,1}:\n 0\n 0\n\njulia> all!([1 1], A)\n1×2 Array{Int64,2}:\n 1  0\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.count",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.count",
    "category": "Function",
    "text": "count(p, itr) -> Integer\ncount(itr) -> Integer\n\nCount the number of elements in itr for which predicate p returns true. If p is omitted, counts the number of true elements in itr (which should be a collection of boolean values).\n\njulia> count(i->(4<=i<=6), [2,3,4,5,6])\n3\n\njulia> count([true, false, true, true])\n3\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.any-Tuple{Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.any",
    "category": "Method",
    "text": "any(p, itr) -> Bool\n\nDetermine whether predicate p returns true for any elements of itr, returning true as soon as the first item in itr for which p returns true is encountered (short-circuiting).\n\njulia> any(i->(4<=i<=6), [3,5,7])\ntrue\n\njulia> any(i -> (println(i); i > 3), 1:10)\n1\n2\n3\n4\ntrue\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.all-Tuple{Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.all",
    "category": "Method",
    "text": "all(p, itr) -> Bool\n\nDetermine whether predicate p returns true for all elements of itr, returning false as soon as the first item in itr for which p returns false is encountered (short-circuiting).\n\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n\njulia> all(i -> (println(i); i < 3), 1:10)\n1\n2\n3\nfalse\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.foreach",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.foreach",
    "category": "Function",
    "text": "foreach(f, c...) -> Void\n\nCall function f on each element of iterable c. For multiple iterable arguments, f is called elementwise. foreach should be used instead of map when the results of f are not needed, for example in foreach(println, array).\n\nExample\n\njulia> a = 1:3:7;\n\njulia> foreach(x -> println(x^2), a)\n1\n16\n49\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.map",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.map",
    "category": "Function",
    "text": "map(f, c...) -> collection\n\nTransform collection c by applying f to each element. For multiple collection arguments, apply f elementwise.\n\nExamples\n\njulia> map(x -> x * 2, [1, 2, 3])\n3-element Array{Int64,1}:\n 2\n 4\n 6\n\njulia> map(+, [1, 2, 3], [10, 20, 30])\n3-element Array{Int64,1}:\n 11\n 22\n 33\n\n\n\nmap(f, x::Nullable)\n\nReturn f applied to the value of x if it has one, as a Nullable. If x is null, then return a null value of type Nullable{S}. S is guaranteed to be either Union{} or a concrete type. Whichever of these is chosen is an implementation detail, but typically the choice that maximizes performance would be used. If x has a value, then the return type is guaranteed to be of type Nullable{typeof(f(x))}.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.map!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.map!",
    "category": "Function",
    "text": "map!(function, destination, collection...)\n\nLike map, but stores the result in destination rather than a new collection. destination must be at least as large as the first collection.\n\nExample\n\njulia> x = zeros(3);\n\njulia> map!(x -> x * 2, x, [1, 2, 3]);\n\njulia> x\n3-element Array{Float64,1}:\n 2.0\n 4.0\n 6.0\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.mapreduce-NTuple{4,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.mapreduce",
    "category": "Method",
    "text": "mapreduce(f, op, v0, itr)\n\nApply function f to each element in itr, and then reduce the result using the binary function op. v0 must be a neutral element for op that will be returned for empty collections. It is unspecified whether v0 is used for non-empty collections.\n\nmapreduce is functionally equivalent to calling reduce(op, v0, map(f, itr)), but will in general execute faster since no intermediate collection needs to be created. See documentation for reduce and map.\n\njulia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9\n14\n\nThe associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of f for elements that appear multiple times in itr. Use mapfoldl or mapfoldr instead for guaranteed left or right associativity and invocation of f for every value.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.mapreduce-Tuple{Any,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.mapreduce",
    "category": "Method",
    "text": "mapreduce(f, op, itr)\n\nLike mapreduce(f, op, v0, itr). In general, this cannot be used with empty collections (see reduce(op, itr)).\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.mapfoldl-NTuple{4,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.mapfoldl",
    "category": "Method",
    "text": "mapfoldl(f, op, v0, itr)\n\nLike mapreduce, but with guaranteed left associativity, as in foldl. v0 will be used exactly once.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.mapfoldl-Tuple{Any,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.mapfoldl",
    "category": "Method",
    "text": "mapfoldl(f, op, itr)\n\nLike mapfoldl(f, op, v0, itr), but using the first element of itr as v0. In general, this cannot be used with empty collections (see reduce(op, itr)).\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.mapfoldr-NTuple{4,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.mapfoldr",
    "category": "Method",
    "text": "mapfoldr(f, op, v0, itr)\n\nLike mapreduce, but with guaranteed right associativity, as in foldr. v0 will be used exactly once.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.mapfoldr-Tuple{Any,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.mapfoldr",
    "category": "Method",
    "text": "mapfoldr(f, op, itr)\n\nLike mapfoldr(f, op, v0, itr), but using the first element of itr as v0. In general, this cannot be used with empty collections (see reduce(op, itr)).\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.first",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.first",
    "category": "Function",
    "text": "first(coll)\n\nGet the first element of an iterable collection. Returns the start point of a Range even if it is empty.\n\njulia> first(2:2:10)\n2\n\njulia> first([1; 2; 3; 4])\n1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.last",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.last",
    "category": "Function",
    "text": "last(coll)\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling endof to get the last index. Returns the end point of a Range even if it is empty.\n\njulia> last(1:2:10)\n9\n\njulia> last([1; 2; 3; 4])\n4\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.step",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.step",
    "category": "Function",
    "text": "step(r)\n\nGet the step size of a Range object.\n\njulia> step(1:10)\n1\n\njulia> step(1:2:10)\n2\n\njulia> step(2.5:0.3:10.9)\n0.3\n\njulia> step(linspace(2.5,10.9,85))\n0.1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.collect-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.collect",
    "category": "Method",
    "text": "collect(collection)\n\nReturn an Array of all items in a collection or iterator. For associative collections, returns Pair{KeyType, ValType}. If the argument is array-like or is an iterator with the HasShape() trait, the result will have the same shape and number of dimensions as the argument.\n\nExample\n\njulia> collect(1:2:13)\n7-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n 13\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.collect-Tuple{Type,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.collect",
    "category": "Method",
    "text": "collect(element_type, collection)\n\nReturn an Array with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as collection.\n\njulia> collect(Float64, 1:2:5)\n3-element Array{Float64,1}:\n 1.0\n 3.0\n 5.0\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.issubset-Tuple{Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.issubset",
    "category": "Method",
    "text": "issubset(a, b)\n⊆(a,b) -> Bool\n⊈(a,b) -> Bool\n⊊(a,b) -> Bool\n\nDetermine whether every element of a is also in b, using in.\n\nExamples\n\njulia> issubset([1, 2], [1, 2, 3])\ntrue\n\njulia> issubset([1, 2, 3], [1, 2])\nfalse\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.filter",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.filter",
    "category": "Function",
    "text": "filter(function, collection)\n\nReturn a copy of collection, removing elements for which function is false. For associative collections, the function is passed two arguments (key and value).\n\nExamples\n\njulia> a = 1:10\n1:10\n\njulia> filter(isodd, a)\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n 9\n\njulia> d = Dict(1=>\"a\", 2=>\"b\")\nDict{Int64,String} with 2 entries:\n  2 => \"b\"\n  1 => \"a\"\n\njulia> filter((x,y)->isodd(x), d)\nDict{Int64,String} with 1 entry:\n  1 => \"a\"\n\n\n\nfilter(p, x::Nullable)\n\nReturn null if either x is null or p(get(x)) is false, and x otherwise.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.filter!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.filter!",
    "category": "Function",
    "text": "filter!(function, collection)\n\nUpdate collection, removing elements for which function is false. For associative collections, the function is passed two arguments (key and value).\n\nExample\n\njulia> filter!(isodd, collect(1:10))\n5-element Array{Int64,1}:\n 1\n 3\n 5\n 7\n 9\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Colecciones-Iterables-1",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Colecciones Iterables",
    "category": "section",
    "text": "Base.in\nBase.eltype\nBase.indexin\nBase.findin\nBase.unique\nBase.allunique\nBase.reduce(::Any, ::Any, ::Any)\nBase.reduce(::Any, ::Any)\nBase.foldl(::Any, ::Any, ::Any)\nBase.foldl(::Any, ::Any)\nBase.foldr(::Any, ::Any, ::Any)\nBase.foldr(::Any, ::Any)\nBase.maximum(::Any)\nBase.maximum(::Any, ::Any)\nBase.maximum!\nBase.minimum(::Any)\nBase.minimum(::Any, ::Any)\nBase.minimum!\nBase.extrema(::Any)\nBase.extrema(::AbstractArray, ::Any)\nBase.indmax\nBase.indmin\nBase.findmax(::Any)\nBase.findmax(::AbstractArray, ::Any)\nBase.findmin(::Any)\nBase.findmin(::AbstractArray, ::Any)\nBase.findmax!\nBase.findmin!\nBase.sum\nBase.sum!\nBase.prod\nBase.prod!\nBase.any(::Any)\nBase.any(::AbstractArray, ::Any)\nBase.any!\nBase.all(::Any)\nBase.all(::AbstractArray, ::Any)\nBase.all!\nBase.count\nBase.any(::Any, ::Any)\nBase.all(::Any, ::Any)\nBase.foreach\nBase.map\nBase.map!\nBase.mapreduce(::Any, ::Any, ::Any, ::Any)\nBase.mapreduce(::Any, ::Any, ::Any)\nBase.mapfoldl(::Any, ::Any, ::Any, ::Any)\nBase.mapfoldl(::Any, ::Any, ::Any)\nBase.mapfoldr(::Any, ::Any, ::Any, ::Any)\nBase.mapfoldr(::Any, ::Any, ::Any)\nBase.first\nBase.last\nBase.step\nBase.collect(::Any)\nBase.collect(::Type, ::Any)\nBase.issubset(::Any, ::Any)\nBase.filter\nBase.filter!"
},

{
    "location": "stdlib/collections.html#Base.getindex-Tuple{Any,Vararg{Any,N} where N}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.getindex",
    "category": "Method",
    "text": "getindex(collection, key...)\n\nRetrieve the value(s) stored at the given key or index within a collection. The syntax a[i,j,...] is converted by the compiler to getindex(a, i, j, ...).\n\nExample\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> getindex(A, \"a\")\n1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.setindex!-Tuple{Any,Any,Vararg{Any,N} where N}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.setindex!",
    "category": "Method",
    "text": "setindex!(collection, value, key...)\n\nStore the given value at the given key or index within a collection. The syntax a[i,j,...] = x is converted by the compiler to (setindex!(a, x, i, j, ...); x).\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Colecciones-Indexables-1",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Colecciones Indexables",
    "category": "section",
    "text": "Base.getindex(::Any, ::Any...)\nBase.setindex!(::Any, ::Any, ::Any...)Completamente implementado por:Array\nBitArray\nAbstractArray\nSubArray\nObjectIdDict\nDict\nWeakKeyDict\nAbstractStringParcialmente implementado por:Range\nUnitRange\nTuple"
},

{
    "location": "stdlib/collections.html#Base.Dict",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.Dict",
    "category": "Type",
    "text": "Dict([itr])\n\nDict{K,V}() constructs a hash table with keys of type K and values of type V.\n\nGiven a single iterable argument, constructs a Dict whose key-value pairs are taken from 2-tuples (key,value) generated by the argument.\n\njulia> Dict([(\"A\", 1), (\"B\", 2)])\nDict{String,Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\nAlternatively, a sequence of pair arguments may be passed.\n\njulia> Dict(\"A\"=>1, \"B\"=>2)\nDict{String,Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.ObjectIdDict",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.ObjectIdDict",
    "category": "Type",
    "text": "ObjectIdDict([itr])\n\nObjectIdDict() constructs a hash table where the keys are (always) object identities.  Unlike Dict it is not parameterized on its key and value type and thus its eltype is always Pair{Any,Any}.\n\nSee Dict for further help.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.WeakKeyDict",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.WeakKeyDict",
    "category": "Type",
    "text": "WeakKeyDict([itr])\n\nWeakKeyDict() constructs a hash table where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.\n\nSee Dict for further help.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.haskey",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.haskey",
    "category": "Function",
    "text": "haskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given key.\n\njulia> a = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'b' => 3\n  'a' => 2\n\njulia> haskey(a,'a')\ntrue\n\njulia> haskey(a,'c')\nfalse\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.get-Tuple{Any,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.get",
    "category": "Method",
    "text": "get(collection, key, default)\n\nReturn the value stored for the given key, or the given default value if no mapping for the key is present.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> get(d, \"a\", 3)\n1\n\njulia> get(d, \"c\", 3)\n3\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.get",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.get",
    "category": "Function",
    "text": "get(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, return f().  Use get! to also store the default value in the dictionary.\n\nThis is intended to be called using do block syntax\n\nget(dict, key) do\n    # default value calculated here\n    time()\nend\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.get!-Tuple{Any,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.get!",
    "category": "Method",
    "text": "get!(collection, key, default)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store key => default, and return default.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> get!(d, \"a\", 5)\n1\n\njulia> get!(d, \"d\", 4)\n4\n\njulia> d\nDict{String,Int64} with 4 entries:\n  \"c\" => 3\n  \"b\" => 2\n  \"a\" => 1\n  \"d\" => 4\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.get!-Tuple{Function,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.get!",
    "category": "Method",
    "text": "get!(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store key => f(), and return f().\n\nThis is intended to be called using do block syntax:\n\nget!(dict, key) do\n    # default value calculated here\n    time()\nend\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.getkey",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.getkey",
    "category": "Function",
    "text": "getkey(collection, key, default)\n\nReturn the key matching argument key if one exists in collection, otherwise return default.\n\njulia> a = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'b' => 3\n  'a' => 2\n\njulia> getkey(a,'a',1)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> getkey(a,'d','a')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.delete!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.delete!",
    "category": "Function",
    "text": "delete!(collection, key)\n\nDelete the mapping for the given key in a collection, and return the collection.\n\nExample\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> delete!(d, \"b\")\nDict{String,Int64} with 1 entry:\n  \"a\" => 1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.pop!-Tuple{Any,Any,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.pop!",
    "category": "Method",
    "text": "pop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n [1] pop!(::Dict{String,Int64}, ::String) at ./dict.jl:539\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.keys",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.keys",
    "category": "Function",
    "text": "keys(a::Associative)\n\nReturn an iterator over all keys in a collection. collect(keys(a)) returns an array of keys. Since the keys are stored internally in a hash table, the order in which they are returned may vary. But keys(a) and values(a) both iterate a and return the elements in the same order.\n\njulia> a = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'b' => 3\n  'a' => 2\n\njulia> collect(keys(a))\n2-element Array{Char,1}:\n 'b'\n 'a'\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.values",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.values",
    "category": "Function",
    "text": "values(a::Associative)\n\nReturn an iterator over all values in a collection. collect(values(a)) returns an array of values. Since the values are stored internally in a hash table, the order in which they are returned may vary. But keys(a) and values(a) both iterate a and return the elements in the same order.\n\njulia> a = Dict('a'=>2, 'b'=>3)\nDict{Char,Int64} with 2 entries:\n  'b' => 3\n  'a' => 2\n\njulia> collect(values(a))\n2-element Array{Int64,1}:\n 3\n 2\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.merge",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.merge",
    "category": "Function",
    "text": "merge(d::Associative, others::Associative...)\n\nConstruct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.\n\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String,Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String,Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(a, b)\nDict{String,Float64} with 3 entries:\n  \"bar\" => 4711.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\njulia> merge(b, a)\nDict{String,Float64} with 3 entries:\n  \"bar\" => 42.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\n\n\nmerge(combine, d::Associative, others::Associative...)\n\nConstruct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.\n\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String,Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String,Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(+, a, b)\nDict{String,Float64} with 3 entries:\n  \"bar\" => 4753.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.merge!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.merge!",
    "category": "Function",
    "text": "Merge changes into current head \n\n\n\nInternal implementation of merge. Returns true if merge was successful, otherwise false\n\n\n\nmerge!(repo::GitRepo; kwargs...) -> Bool\n\nPerform a git merge on the repository repo, merging commits with diverging history into the current branch. Returns true if the merge succeeded, false if not.\n\nThe keyword arguments are:\n\ncommittish::AbstractString=\"\": Merge the named commit(s) in committish.\nbranch::AbstractString=\"\": Merge the branch branch and all its commits since it diverged from the current branch.\nfastforward::Bool=false: If fastforward is true, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return false. This is equivalent to the git CLI option --ff-only.\nmerge_opts::MergeOptions=MergeOptions(): merge_opts specifies options for the merge, such as merge strategy in case of conflicts.\ncheckout_opts::CheckoutOptions=CheckoutOptions(): checkout_opts specifies options for the checkout step.\n\nEquivalent to git merge [--ff-only] [<committish> | <branch>].\n\nnote: Note\nIf you specify a branch, this must be done in reference format, since the string will be turned into a GitReference. For example, if you wanted to merge branch branch_a, you would call merge!(repo, branch=\"refs/heads/branch_a\").\n\n\n\nmerge!(d::Associative, others::Associative...)\n\nUpdate collection with pairs from the other collections. See also merge.\n\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> merge!(d1, d2);\n\njulia> d1\nDict{Int64,Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 4\n\n\n\nmerge!(combine, d::Associative, others::Associative...)\n\nUpdate collection with pairs from the other collections. Values with the same key will be combined using the combiner function.\n\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> merge!(+, d1, d2);\n\njulia> d1\nDict{Int64,Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 6\n\njulia> merge!(-, d1, d1);\n\njulia> d1\nDict{Int64,Int64} with 3 entries:\n  4 => 0\n  3 => 0\n  1 => 0\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.sizehint!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.sizehint!",
    "category": "Function",
    "text": "sizehint!(s, n)\n\nSuggest that collection s reserve capacity for at least n elements. This can improve performance.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.keytype",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.keytype",
    "category": "Function",
    "text": "keytype(type)\n\nGet the key type of an associative collection type. Behaves similarly to eltype.\n\njulia> keytype(Dict(Int32(1) => \"foo\"))\nInt32\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.valtype",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.valtype",
    "category": "Function",
    "text": "valtype(type)\n\nGet the value type of an associative collection type. Behaves similarly to eltype.\n\njulia> valtype(Dict(Int32(1) => \"foo\"))\nString\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Colecciones-Asociativas-1",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Colecciones Asociativas",
    "category": "section",
    "text": "Dict es la colección asociativa estándar. Su implementación usa hash() como función de hashing para la clave, e isequal() para determinar la igualdad. Si redefine estas dos funciones en un tipo personalizado, sobreescribirán cómo se almacenan dichos tipos en una tabla hash.ObjectIdDict es una tabla hash especial donde las claves son siempre identidades de objeto.WeakKeyDict es una implementación de tabla hash donde las claves son referencias débiles a los objetos y, por lo tanto, permiten recolección de basura recogida incluso cuando se referencian en una tabla hash.Dicts se pueden crear pasando pares de objetos construidos con =>() a un constructor Dict: Dict (\"A\"=> 1,\" B \"=> 2). Esta llamada intentará inferir información sobre el tipo de las claves y los valores (es decir, este ejemplo crea un Dict{String, Int64}). Para especificar los tipos explícitamente, use la sintaxis Dict{KeyType,ValueType}(...). Por ejemplo, Dict{String,Int32}(\" A \"=> 1,\" B \"=> 2).Las colecciones asociativas también pueden ser creadas con generadores. Por ejemplo, Dict(i => f(i) for i = 1:10).Dado un diccionario D, la sintaxis D[x] devuelve el valor de la clave x (si existe) o arroja un error, y D[x] = y almacena el par de clave-valor x => y en D (reemplazando cualquier valor existente para la clavex). Múltiples argumentos para D [...] se convierten a tuplas; por ejemplo, la sintaxis D[x,y] es equivalente a D[(x,y)], es decir, se refiere al valor introducido para la tupla (x,y).Base.Dict\nBase.ObjectIdDict\nBase.WeakKeyDict\nBase.haskey\nBase.get(::Any, ::Any, ::Any)\nBase.get\nBase.get!(::Any, ::Any, ::Any)\nBase.get!(::Function, ::Any, ::Any)\nBase.getkey\nBase.delete!\nBase.pop!(::Any, ::Any, ::Any)\nBase.keys\nBase.values\nBase.merge\nBase.merge!\nBase.sizehint!\nBase.keytype\nBase.valtypeCompletamente implementado por:ObjectIdDict\nDict\nWeakKeyDictParcialmente implementado por:IntSet\nSet\nEnvHash\nArray\nBitArray"
},

{
    "location": "stdlib/collections.html#Base.Set",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.Set",
    "category": "Type",
    "text": "Set([itr])\n\nConstruct a Set of the values generated by the given iterable object, or an empty set. Should be used instead of IntSet for sparse integer sets, or for sets of arbitrary objects.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.IntSet",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.IntSet",
    "category": "Type",
    "text": "IntSet([itr])\n\nConstruct a sorted set of positive Ints generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. Only Ints greater than 0 can be stored. If the set will be sparse (for example holding a few very large integers), use Set instead.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.union",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.union",
    "category": "Function",
    "text": "union(s1,s2...)\n∪(s1,s2...)\n\nConstruct the union of two or more sets. Maintains order with arrays.\n\nExamples\n\njulia> union([1, 2], [3, 4])\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> union([1, 2], [2, 4])\n3-element Array{Int64,1}:\n 1\n 2\n 4\n\njulia> union([4, 2], [1, 2])\n3-element Array{Int64,1}:\n 4\n 2\n 1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.union!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.union!",
    "category": "Function",
    "text": "union!(s, iterable)\n\nUnion each element of iterable into set s in-place.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.intersect",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.intersect",
    "category": "Function",
    "text": "intersect(s1,s2...)\n∩(s1,s2)\n\nConstruct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.setdiff",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.setdiff",
    "category": "Function",
    "text": "setdiff(a, b)\n\nConstruct the set of elements in a but not b. Maintains order with arrays. Note that both arguments must be collections, and both will be iterated over. In particular, setdiff(set,element) where element is a potential member of set, will not work in general.\n\nExample\n\njulia> setdiff([1,2,3],[3,4,5])\n2-element Array{Int64,1}:\n 1\n 2\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.setdiff!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.setdiff!",
    "category": "Function",
    "text": "setdiff!(s, iterable)\n\nRemove each element of iterable from set s in-place.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.symdiff",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.symdiff",
    "category": "Function",
    "text": "symdiff(a, b, rest...)\n\nConstruct the symmetric difference of elements in the passed in sets or arrays. Maintains order with arrays.\n\nExample\n\njulia> symdiff([1,2,3],[3,4,5],[4,5,6])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.symdiff!-Tuple{IntSet,Integer}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.symdiff!",
    "category": "Method",
    "text": "symdiff!(s, n)\n\nThe set s is destructively modified to toggle the inclusion of integer n.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.symdiff!-Tuple{IntSet,Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.symdiff!",
    "category": "Method",
    "text": "symdiff!(s, itr)\n\nFor each element in itr, destructively toggle its inclusion in set s.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.symdiff!-Tuple{IntSet,IntSet}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.symdiff!",
    "category": "Method",
    "text": "symdiff!(s, itr)\n\nFor each element in itr, destructively toggle its inclusion in set s.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.intersect!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.intersect!",
    "category": "Function",
    "text": "intersect!(s1::IntSet, s2::IntSet)\n\nIntersects sets s1 and s2 and overwrites the set s1 with the result. If needed, s1 will be expanded to the size of s2.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.issubset",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.issubset",
    "category": "Function",
    "text": "issubset(A, S) -> Bool\n⊆(A,S) -> Bool\n\nReturn true if A is a subset of or equal to S.\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Colecciones-de-tipo-Conjunto-1",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Colecciones de tipo Conjunto",
    "category": "section",
    "text": "Base.Set\nBase.IntSet\nBase.union\nBase.union!\nBase.intersect\nBase.setdiff\nBase.setdiff!\nBase.symdiff\nBase.symdiff!(::IntSet, ::Integer)\nBase.symdiff!(::IntSet, ::Any)\nBase.symdiff!(::IntSet, ::IntSet)\nBase.intersect!\nBase.issubsetCompletamente implementado por:IntSet\nSetParcialmente implementado por:Array"
},

{
    "location": "stdlib/collections.html#Base.push!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.push!",
    "category": "Function",
    "text": "push!(collection, items...) -> collection\n\nInsert one or more items at the end of collection.\n\nExample\n\njulia> push!([1, 2, 3], 4, 5, 6)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse append! to add all the elements of another collection to collection. The result of the preceding example is equivalent to append!([1, 2, 3], [4, 5, 6]).\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.pop!-Tuple{Any}",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.pop!",
    "category": "Method",
    "text": "pop!(collection) -> item\n\nRemove the last item in collection and return it.\n\nExamples\n\njulia> A=[1, 2, 3, 4, 5, 6]\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> pop!(A)\n6\n\njulia> A\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.unshift!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.unshift!",
    "category": "Function",
    "text": "unshift!(collection, items...) -> collection\n\nInsert one or more items at the beginning of collection.\n\nExample\n\njulia> unshift!([1, 2, 3, 4], 5, 6)\n6-element Array{Int64,1}:\n 5\n 6\n 1\n 2\n 3\n 4\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.shift!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.shift!",
    "category": "Function",
    "text": "shift!(collection) -> item\n\nRemove the first item from collection.\n\nExample\n\njulia> A = [1, 2, 3, 4, 5, 6]\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> shift!(A)\n1\n\njulia> A\n5-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n 6\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.insert!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.insert!",
    "category": "Function",
    "text": "insert!(a::Vector, index::Integer, item)\n\nInsert an item into a at the given index. index is the index of item in the resulting a.\n\nExample\n\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.deleteat!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.deleteat!",
    "category": "Function",
    "text": "deleteat!(a::Vector, i::Integer)\n\nRemove the item at the given i and return the modified a. Subsequent items are shifted to fill the resulting gap.\n\nExample\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], 2)\n5-element Array{Int64,1}:\n 6\n 4\n 3\n 2\n 1\n\n\n\ndeleteat!(a::Vector, inds)\n\nRemove the items at the indices given by inds, and return the modified a. Subsequent items are shifted to fill the resulting gap.\n\ninds can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as a with true indicating entries to delete.\n\nExamples\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)\n3-element Array{Int64,1}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])\n3-element Array{Int64,1}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))\nERROR: ArgumentError: indices must be unique and sorted\nStacktrace:\n [1] _deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:926\n [2] deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:913\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.splice!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.splice!",
    "category": "Function",
    "text": "splice!(a::Vector, index::Integer, [replacement]) -> item\n\nRemove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.\n\nExamples\n\njulia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)\n2\n\njulia> A\n5-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 1\n\njulia> splice!(A, 5, -1)\n1\n\njulia> A\n5-element Array{Int64,1}:\n  6\n  5\n  4\n  3\n -1\n\njulia> splice!(A, 1, [-1, -2, -3])\n6\n\njulia> A\n7-element Array{Int64,1}:\n -1\n -2\n -3\n  5\n  4\n  3\n -1\n\nTo insert replacement before an index n without removing any items, use splice!(collection, n:n-1, replacement).\n\n\n\nsplice!(a::Vector, range, [replacement]) -> items\n\nRemove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.\n\nTo insert replacement before an index n without removing any items, use splice!(collection, n:n-1, replacement).\n\nExample\n\njulia> splice!(A, 4:3, 2)\n0-element Array{Int64,1}\n\njulia> A\n8-element Array{Int64,1}:\n -1\n -2\n -3\n  2\n  5\n  4\n  3\n -1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.resize!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.resize!",
    "category": "Function",
    "text": "resize!(a::Vector, n::Integer) -> Vector\n\nResize a to contain n elements. If n is smaller than the current collection length, the first n elements will be retained. If n is larger, the new elements are not guaranteed to be initialized.\n\nExamples\n\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Array{Int64,1}:\n 6\n 5\n 4\n\njulia> a = resize!([6, 5, 4, 3, 2, 1], 8);\n\njulia> length(a)\n8\n\njulia> a[1:6]\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.append!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.append!",
    "category": "Function",
    "text": "append!(collection, collection2) -> collection.\n\nAdd the elements of collection2 to the end of collection.\n\nExamples\n\njulia> append!([1],[2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> append!([1, 2, 3], [4, 5, 6])\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse push! to add individual items to collection which are not already themselves in another collection. The result is of the preceding example is equivalent to push!([1, 2, 3], 4, 5, 6).\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Base.prepend!",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Base.prepend!",
    "category": "Function",
    "text": "prepend!(a::Vector, items) -> collection\n\nInsert the elements of items to the beginning of a.\n\nExample\n\njulia> prepend!([3],[1,2])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n"
},

{
    "location": "stdlib/collections.html#Acciones-relacionadas-con-Colas-1",
    "page": "Colecciones y Estructuras de Datos",
    "title": "Acciones relacionadas con Colas",
    "category": "section",
    "text": "Base.push!\nBase.pop!(::Any)\nBase.unshift!\nBase.shift!\nBase.insert!\nBase.deleteat!\nBase.splice!\nBase.resize!\nBase.append!\nBase.prepend!Completamente implementado por:Vector (también conocido como 1-dimensional Array)\nBitVector (también conocido como 1-dimensional BitArray)"
},

{
    "location": "stdlib/math.html#",
    "page": "Matemáticas",
    "title": "Matemáticas",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/math.html#math-1",
    "page": "Matemáticas",
    "title": "Matemáticas",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/math.html#Base.:--Tuple{Any}",
    "page": "Matemáticas",
    "title": "Base.:-",
    "category": "Method",
    "text": "-(x)\n\nUnary minus operator.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:+",
    "page": "Matemáticas",
    "title": "Base.:+",
    "category": "Function",
    "text": "+(x, y...)\n\nAddition operator. x+y+z+... calls this function with all arguments, i.e. +(x, y, z, ...).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:--Tuple{Any,Any}",
    "page": "Matemáticas",
    "title": "Base.:-",
    "category": "Method",
    "text": "-(x, y)\n\nSubtraction operator.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:*-Tuple{Any,Vararg{Any,N} where N}",
    "page": "Matemáticas",
    "title": "Base.:*",
    "category": "Method",
    "text": "*(x, y...)\n\nMultiplication operator. x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:/",
    "page": "Matemáticas",
    "title": "Base.:/",
    "category": "Function",
    "text": "/(x, y)\n\nRight division operator: multiplication of x by the inverse of y on the right. Gives floating-point results for integer arguments.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:\\-Tuple{Any,Any}",
    "page": "Matemáticas",
    "title": "Base.:\\",
    "category": "Method",
    "text": "\\(x, y)\n\nLeft division operator: multiplication of y by the inverse of x on the left. Gives floating-point results for integer arguments.\n\njulia> 3 \\ 6\n2.0\n\njulia> inv(3) * 6\n2.0\n\njulia> A = [1 2; 3 4]; x = [5, 6];\n\njulia> A \\ x\n2-element Array{Float64,1}:\n -4.0\n  4.5\n\njulia> inv(A) * x\n2-element Array{Float64,1}:\n -4.0\n  4.5\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:^-Tuple{Number,Number}",
    "page": "Matemáticas",
    "title": "Base.:^",
    "category": "Method",
    "text": "^(x, y)\n\nExponentiation operator. If x is a matrix, computes matrix exponentiation.\n\nIf y is an Int literal (e.g. 2 in x^2 or -3 in x^-3), the Julia code x^y is transformed by the compiler to Base.literal_pow(^, x, Val{y}), to enable compile-time specialization on the value of the exponent. (As a default fallback we have Base.literal_pow(^, x, Val{y}) = ^(x,y), where usually ^ == Base.^ unless ^ has been defined in the calling namespace.)\n\njulia> 3^5\n243\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> A^3\n2×2 Array{Int64,2}:\n 37   54\n 81  118\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.fma",
    "page": "Matemáticas",
    "title": "Base.fma",
    "category": "Function",
    "text": "fma(x, y, z)\n\nComputes x*y+z without rounding the intermediate result x*y. On some systems this is significantly more expensive than x*y+z. fma is used to improve accuracy in certain algorithms. See muladd.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.muladd",
    "page": "Matemáticas",
    "title": "Base.muladd",
    "category": "Function",
    "text": "muladd(x, y, z)\n\nCombined multiply-add, computes x*y+z in an efficient manner. This may on some systems be equivalent to x*y+z, or to fma(x,y,z). muladd is used to improve performance. See fma.\n\nExample\n\njulia> muladd(3, 2, 1)\n7\n\njulia> 3 * 2 + 1\n7\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.div",
    "page": "Matemáticas",
    "title": "Base.div",
    "category": "Function",
    "text": "div(x, y)\n÷(x, y)\n\nThe quotient from Euclidean division. Computes x/y, truncated to an integer.\n\njulia> 9 ÷ 4\n2\n\njulia> -5 ÷ 3\n-1\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.fld",
    "page": "Matemáticas",
    "title": "Base.fld",
    "category": "Function",
    "text": "fld(x, y)\n\nLargest integer less than or equal to x/y.\n\njulia> fld(7.3,5.5)\n1.0\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.cld",
    "page": "Matemáticas",
    "title": "Base.cld",
    "category": "Function",
    "text": "cld(x, y)\n\nSmallest integer larger than or equal to x/y.\n\njulia> cld(5.5,2.2)\n3.0\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.mod",
    "page": "Matemáticas",
    "title": "Base.mod",
    "category": "Function",
    "text": "mod(x, y)\nrem(x, y, RoundDown)\n\nThe reduction of x modulo y, or equivalently, the remainder of x after floored division by y, i.e.\n\nx - y*fld(x,y)\n\nif computed without intermediate rounding.\n\nThe result will have the same sign as y, and magnitude less than abs(y) (with some exceptions, see note below).\n\nnote: Note\nWhen used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to y, then it may be rounded to y.\n\njulia> mod(8, 3)\n2\n\njulia> mod(9, 3)\n0\n\njulia> mod(8.9, 3)\n2.9000000000000004\n\njulia> mod(eps(), 3)\n2.220446049250313e-16\n\njulia> mod(-eps(), 3)\n3.0\n\n\n\nrem(x::Integer, T::Type{<:Integer}) -> T\nmod(x::Integer, T::Type{<:Integer}) -> T\n%(x::Integer, T::Type{<:Integer}) -> T\n\nFind y::T such that x ≡ y (mod n), where n is the number of integers representable in T, and y is an integer in [typemin(T),typemax(T)]. If T can represent any integer (e.g. T == BigInt), then this operation corresponds to a conversion to T.\n\njulia> 129 % Int8\n-127\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.rem",
    "page": "Matemáticas",
    "title": "Base.rem",
    "category": "Function",
    "text": "rem(x, y)\n%(x, y)\n\nRemainder from Euclidean division, returning a value of the same sign as x, and smaller in magnitude than y. This value is always exact.\n\njulia> x = 15; y = 4;\n\njulia> x % y\n3\n\njulia> x == div(x, y) * y + rem(x, y)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.rem2pi",
    "page": "Matemáticas",
    "title": "Base.Math.rem2pi",
    "category": "Function",
    "text": "rem2pi(x, r::RoundingMode)\n\nCompute the remainder of x after integer division by 2π, with the quotient rounded according to the rounding mode r. In other words, the quantity\n\nx - 2π*round(x/(2π),r)\n\nwithout any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than rem(x,2π,r)\n\nif r == RoundNearest, then the result is in the interval - . This will generally be the most accurate result.\nif r == RoundToZero, then the result is in the interval 0 2 if x is positive,. or -2 0 otherwise.\nif r == RoundDown, then the result is in the interval 0 2.\nif r == RoundUp, then the result is in the interval -2 0.\n\nExample\n\njulia> rem2pi(7pi/4, RoundNearest)\n-0.7853981633974485\n\njulia> rem2pi(7pi/4, RoundDown)\n5.497787143782138\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.mod2pi",
    "page": "Matemáticas",
    "title": "Base.Math.mod2pi",
    "category": "Function",
    "text": "mod2pi(x)\n\nModulus after division by 2π, returning in the range 02).\n\nThis function computes a floating point representation of the modulus after division by numerically exact 2π, and is therefore not exactly the same as mod(x,2π), which would compute the modulus of x relative to division by the floating-point number 2π.\n\nExample\n\njulia> mod2pi(9*pi/4)\n0.7853981633974481\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.divrem",
    "page": "Matemáticas",
    "title": "Base.divrem",
    "category": "Function",
    "text": "divrem(x, y)\n\nThe quotient and remainder from Euclidean division. Equivalent to (div(x,y), rem(x,y)) or (x÷y, x%y).\n\njulia> divrem(3,7)\n(0, 3)\n\njulia> divrem(7,3)\n(2, 1)\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.fldmod",
    "page": "Matemáticas",
    "title": "Base.fldmod",
    "category": "Function",
    "text": "fldmod(x, y)\n\nThe floored quotient and modulus after division. Equivalent to (fld(x,y), mod(x,y)).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.fld1",
    "page": "Matemáticas",
    "title": "Base.fld1",
    "category": "Function",
    "text": "fld1(x, y)\n\nFlooring division, returning a value consistent with mod1(x,y)\n\nSee also: mod1.\n\njulia> x = 15; y = 4;\n\njulia> fld1(x, y)\n4\n\njulia> x == fld(x, y) * y + mod(x, y)\ntrue\n\njulia> x == (fld1(x, y) - 1) * y + mod1(x, y)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.mod1",
    "page": "Matemáticas",
    "title": "Base.mod1",
    "category": "Function",
    "text": "mod1(x, y)\n\nModulus after flooring division, returning a value r such that mod(r, y) == mod(x, y) in the range (0 y for positive y and in the range y0) for negative y.\n\njulia> mod1(4, 2)\n2\n\njulia> mod1(4, 3)\n1\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.fldmod1",
    "page": "Matemáticas",
    "title": "Base.fldmod1",
    "category": "Function",
    "text": "fldmod1(x, y)\n\nReturn (fld1(x,y), mod1(x,y)).\n\nSee also: fld1, mod1.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.://",
    "page": "Matemáticas",
    "title": "Base.://",
    "category": "Function",
    "text": "//(num, den)\n\nDivide two integers or rational numbers, giving a Rational result.\n\njulia> 3 // 5\n3//5\n\njulia> (3 // 5) // (2 // 1)\n3//10\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.rationalize",
    "page": "Matemáticas",
    "title": "Base.rationalize",
    "category": "Function",
    "text": "rationalize([T<:Integer=Int,] x; tol::Real=eps(x))\n\nApproximate floating point number x as a Rational number with components of the given integer type. The result will differ from x by no more than tol. If T is not provided, it defaults to Int.\n\njulia> rationalize(5.6)\n28//5\n\njulia> a = rationalize(BigInt, 10.3)\n103//10\n\njulia> typeof(numerator(a))\nBigInt\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.numerator",
    "page": "Matemáticas",
    "title": "Base.numerator",
    "category": "Function",
    "text": "numerator(x)\n\nNumerator of the rational representation of x.\n\njulia> numerator(2//3)\n2\n\njulia> numerator(4)\n4\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.denominator",
    "page": "Matemáticas",
    "title": "Base.denominator",
    "category": "Function",
    "text": "denominator(x)\n\nDenominator of the rational representation of x.\n\njulia> denominator(2//3)\n3\n\njulia> denominator(4)\n1\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:<<",
    "page": "Matemáticas",
    "title": "Base.:<<",
    "category": "Function",
    "text": "<<(x, n)\n\nLeft bit shift operator, x << n. For n >= 0, the result is x shifted left by n bits, filling with 0s. This is equivalent to x * 2^n. For n < 0, this is equivalent to x >> -n.\n\njulia> Int8(3) << 2\n12\n\njulia> bits(Int8(3))\n\"00000011\"\n\njulia> bits(Int8(12))\n\"00001100\"\n\nSee also >>, >>>.\n\n\n\n<<(B::BitVector, n) -> BitVector\n\nLeft bit shift operator, B << n. For n >= 0, the result is B with elements shifted n positions backwards, filling with false values. If n < 0, elements are shifted forwards. Equivalent to B >> -n.\n\nExamples\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitArray{1}:\n  true\n false\n  true\n false\n false\n\njulia> B << 1\n5-element BitArray{1}:\n false\n  true\n false\n false\n false\n\njulia> B << -1\n5-element BitArray{1}:\n false\n  true\n false\n  true\n false\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:>>",
    "page": "Matemáticas",
    "title": "Base.:>>",
    "category": "Function",
    "text": ">>(x, n)\n\nRight bit shift operator, x >> n. For n >= 0, the result is x shifted right by n bits, where n >= 0, filling with 0s if x >= 0, 1s if x < 0, preserving the sign of x. This is equivalent to fld(x, 2^n). For n < 0, this is equivalent to x << -n.\n\njulia> Int8(13) >> 2\n3\n\njulia> bits(Int8(13))\n\"00001101\"\n\njulia> bits(Int8(3))\n\"00000011\"\n\njulia> Int8(-14) >> 2\n-4\n\njulia> bits(Int8(-14))\n\"11110010\"\n\njulia> bits(Int8(-4))\n\"11111100\"\n\nSee also >>>, <<.\n\n\n\n>>(B::BitVector, n) -> BitVector\n\nRight bit shift operator, B >> n. For n >= 0, the result is B with elements shifted n positions forward, filling with false values. If n < 0, elements are shifted backwards. Equivalent to B << -n.\n\nExample\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitArray{1}:\n  true\n false\n  true\n false\n false\n\njulia> B >> 1\n5-element BitArray{1}:\n false\n  true\n false\n  true\n false\n\njulia> B >> -1\n5-element BitArray{1}:\n false\n  true\n false\n false\n false\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:>>>",
    "page": "Matemáticas",
    "title": "Base.:>>>",
    "category": "Function",
    "text": ">>>(x, n)\n\nUnsigned right bit shift operator, x >>> n. For n >= 0, the result is x shifted right by n bits, where n >= 0, filling with 0s. For n < 0, this is equivalent to x << -n.\n\nFor Unsigned integer types, this is equivalent to >>. For Signed integer types, this is equivalent to signed(unsigned(x) >> n).\n\njulia> Int8(-14) >>> 2\n60\n\njulia> bits(Int8(-14))\n\"11110010\"\n\njulia> bits(Int8(60))\n\"00111100\"\n\nBigInts are treated as if having infinite size, so no filling is required and this is equivalent to >>.\n\nSee also >>, <<.\n\n\n\n>>>(B::BitVector, n) -> BitVector\n\nUnsigned right bitshift operator, B >>> n. Equivalent to B >> n. See >> for details and examples.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.colon",
    "page": "Matemáticas",
    "title": "Base.colon",
    "category": "Function",
    "text": "colon(start, [step], stop)\n\nCalled by : syntax for constructing ranges.\n\njulia> colon(1, 2, 5)\n1:2:5\n\n\n\n:(start, [step], stop)\n\nRange operator. a:b constructs a range from a to b with a step size of 1, and a:s:b is similar but uses a step size of s. These syntaxes call the function colon. The colon is also used in indexing to select whole dimensions.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.range",
    "page": "Matemáticas",
    "title": "Base.range",
    "category": "Function",
    "text": "range(start, [step], length)\n\nConstruct a range by length, given a starting value and optional step (defaults to 1).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.OneTo",
    "page": "Matemáticas",
    "title": "Base.OneTo",
    "category": "Type",
    "text": "Base.OneTo(n)\n\nDefine an AbstractUnitRange that behaves like 1:n, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.StepRangeLen",
    "page": "Matemáticas",
    "title": "Base.StepRangeLen",
    "category": "Type",
    "text": "StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1])\n\nA range r where r[i] produces values of type T, parametrized by a reference value, a step, and the length.  By default ref is the starting value r[1], but alternatively you can supply it as the value of r[offset] for some other index 1 <= offset <= len.  In conjunction with TwicePrecision this can be used to implement ranges that are free of roundoff error.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:==",
    "page": "Matemáticas",
    "title": "Base.:==",
    "category": "Function",
    "text": "==(x, y)\n\nGeneric equality operator, giving a single Bool result. Falls back to ===. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding.\n\nFollows IEEE semantics for floating-point numbers.\n\nCollections should generally implement == by calling == recursively on all contents.\n\nNew numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:!=",
    "page": "Matemáticas",
    "title": "Base.:!=",
    "category": "Function",
    "text": "!=(x, y)\n≠(x,y)\n\nNot-equals comparison operator. Always gives the opposite answer as ==. New types should generally not implement this, and rely on the fallback definition !=(x,y) = !(x==y) instead.\n\njulia> 3 != 2\ntrue\n\njulia> \"foo\" ≠ \"foo\"\nfalse\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:!==",
    "page": "Matemáticas",
    "title": "Base.:!==",
    "category": "Function",
    "text": "!==(x, y)\n≢(x,y)\n\nEquivalent to !(x === y).\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a ≢ b\ntrue\n\njulia> a ≢ a\nfalse\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:<",
    "page": "Matemáticas",
    "title": "Base.:<",
    "category": "Function",
    "text": "<(x, y)\n\nLess-than comparison operator. New numeric types should implement this function for two arguments of the new type. Because of the behavior of floating-point NaN values, < implements a partial order. Types with a canonical partial order should implement <, and types with a canonical total order should implement isless.\n\njulia> 'a' < 'b'\ntrue\n\njulia> \"abc\" < \"abd\"\ntrue\n\njulia> 5 < 3\nfalse\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:<=",
    "page": "Matemáticas",
    "title": "Base.:<=",
    "category": "Function",
    "text": "<=(x, y)\n≤(x,y)\n\nLess-than-or-equals comparison operator.\n\njulia> 'a' <= 'b'\ntrue\n\njulia> 7 ≤ 7 ≤ 9\ntrue\n\njulia> \"abc\" ≤ \"abc\"\ntrue\n\njulia> 5 <= 3\nfalse\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:>",
    "page": "Matemáticas",
    "title": "Base.:>",
    "category": "Function",
    "text": ">(x, y)\n\nGreater-than comparison operator. Generally, new types should implement < instead of this function, and rely on the fallback definition >(x, y) = y < x.\n\njulia> 'a' > 'b'\nfalse\n\njulia> 7 > 3 > 1\ntrue\n\njulia> \"abc\" > \"abd\"\nfalse\n\njulia> 5 > 3\ntrue\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:>=",
    "page": "Matemáticas",
    "title": "Base.:>=",
    "category": "Function",
    "text": ">=(x, y)\n≥(x,y)\n\nGreater-than-or-equals comparison operator.\n\njulia> 'a' >= 'b'\nfalse\n\njulia> 7 ≥ 7 ≥ 3\ntrue\n\njulia> \"abc\" ≥ \"abc\"\ntrue\n\njulia> 5 >= 3\ntrue\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.cmp",
    "page": "Matemáticas",
    "title": "Base.cmp",
    "category": "Function",
    "text": "cmp(x,y)\n\nReturn -1, 0, or 1 depending on whether x is less than, equal to, or greater than y, respectively. Uses the total order implemented by isless. For floating-point numbers, uses < but throws an error for unordered arguments.\n\njulia> cmp(1, 2)\n-1\n\njulia> cmp(2, 1)\n1\n\njulia> cmp(2+im, 3-im)\nERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})\n[...]\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:~",
    "page": "Matemáticas",
    "title": "Base.:~",
    "category": "Function",
    "text": "~(x)\n\nBitwise not.\n\nExamples\n\njulia> ~4\n-5\n\njulia> ~10\n-11\n\njulia> ~true\nfalse\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:&",
    "page": "Matemáticas",
    "title": "Base.:&",
    "category": "Function",
    "text": "&(x, y)\n\nBitwise and.\n\nExamples\n\njulia> 4 & 10\n0\n\njulia> 4 & 12\n4\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:|",
    "page": "Matemáticas",
    "title": "Base.:|",
    "category": "Function",
    "text": "|(x, y)\n\nBitwise or.\n\nExamples\n\njulia> 4 | 10\n14\n\njulia> 4 | 1\n5\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.xor",
    "page": "Matemáticas",
    "title": "Base.xor",
    "category": "Function",
    "text": "xor(x, y)\n⊻(x, y)\n\nBitwise exclusive or of x and y.  The infix operation a ⊻ b is a synonym for xor(a,b), and ⊻ can be typed by tab-completing \\xor or \\veebar in the Julia REPL.\n\njulia> [true; true; false] .⊻ [true; false; false]\n3-element BitArray{1}:\n false\n  true\n false\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.:!",
    "page": "Matemáticas",
    "title": "Base.:!",
    "category": "Function",
    "text": "!(x)\n\nBoolean not.\n\njulia> !true\nfalse\n\njulia> !false\ntrue\n\njulia> .![true false true]\n1×3 BitArray{2}:\n false  true  false\n\n\n\n!f::Function\n\nPredicate function negation: when the argument of ! is a function, it returns a function which computes the boolean negation of f. Example:\n\njulia> str = \"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\njulia> filter(isalpha, str)\n\"εδxyδfxfyε\"\n\njulia> filter(!isalpha, str)\n\"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < \"\n\n\n\n"
},

{
    "location": "stdlib/math.html#&&",
    "page": "Matemáticas",
    "title": "&&",
    "category": "Keyword",
    "text": "x && y\n\nShort-circuiting boolean AND.\n\n\n\n"
},

{
    "location": "stdlib/math.html#||",
    "page": "Matemáticas",
    "title": "||",
    "category": "Keyword",
    "text": "x || y\n\nShort-circuiting boolean OR.\n\n\n\n"
},

{
    "location": "stdlib/math.html#math-ops-1",
    "page": "Matemáticas",
    "title": "Operadores Matemáticos",
    "category": "section",
    "text": "Base.:-(::Any)\nBase.:(+)\nBase.:-(::Any, ::Any)\nBase.:*(::Any, ::Any...)\nBase.:(/)\nBase.:\\(::Any, ::Any)\nBase.:^(::Number, ::Number)\nBase.fma\nBase.muladd\nBase.div\nBase.fld\nBase.cld\nBase.mod\nBase.rem\nBase.rem2pi\nBase.Math.mod2pi\nBase.divrem\nBase.fldmod\nBase.fld1\nBase.mod1\nBase.fldmod1\nBase.:(//)\nBase.rationalize\nBase.numerator\nBase.denominator\nBase.:(<<)\nBase.:(>>)\nBase.:(>>>)\nBase.colon\nBase.range\nBase.OneTo\nBase.StepRangeLen\nBase.:(==)\nBase.:(!=)\nBase.:(!==)\nBase.:(<)\nBase.:(<=)\nBase.:(>)\nBase.:(>=)\nBase.cmp\nBase.:(~)\nBase.:(&)\nBase.:(|)\nBase.xor\nBase.:(!)\n&&\n||"
},

{
    "location": "stdlib/math.html#Base.isapprox",
    "page": "Matemáticas",
    "title": "Base.isapprox",
    "category": "Function",
    "text": "isapprox(x, y; rtol::Real=sqrt(eps), atol::Real=0, nans::Bool=false, norm::Function)\n\nInexact equality comparison: true if norm(x-y) <= atol + rtol*max(norm(x), norm(y)). The default atol is zero and the default rtol depends on the types of x and y. The keyword argument nans determines whether or not NaN values are considered equal (defaults to false).\n\nFor real or complex floating-point values, rtol defaults to sqrt(eps(typeof(real(x-y)))). This corresponds to requiring equality of about half of the significand digits. For other types, rtol defaults to zero.\n\nx and y may also be arrays of numbers, in which case norm defaults to vecnorm but may be changed by passing a norm::Function keyword argument. (For numbers, norm is the same thing as abs.) When x and y are arrays, if norm(x-y) is not finite (i.e. ±Inf or NaN), the comparison falls back to checking whether all elements of x and y are approximately equal component-wise.\n\nThe binary operator ≈ is equivalent to isapprox with the default arguments, and x ≉ y is equivalent to !isapprox(x,y).\n\njulia> 0.1 ≈ (0.1 - 1e-10)\ntrue\n\njulia> isapprox(10, 11; atol = 2)\ntrue\n\njulia> isapprox([10.0^9, 1.0], [10.0^9, 2.0])\ntrue\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.sin",
    "page": "Matemáticas",
    "title": "Base.sin",
    "category": "Function",
    "text": "sin(x)\n\nCompute sine of x, where x is in radians.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.cos",
    "page": "Matemáticas",
    "title": "Base.cos",
    "category": "Function",
    "text": "cos(x)\n\nCompute cosine of x, where x is in radians.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.tan",
    "page": "Matemáticas",
    "title": "Base.tan",
    "category": "Function",
    "text": "tan(x)\n\nCompute tangent of x, where x is in radians.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.sind",
    "page": "Matemáticas",
    "title": "Base.Math.sind",
    "category": "Function",
    "text": "sind(x)\n\nCompute sine of x, where x is in degrees. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.cosd",
    "page": "Matemáticas",
    "title": "Base.Math.cosd",
    "category": "Function",
    "text": "cosd(x)\n\nCompute cosine of x, where x is in degrees. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.tand",
    "page": "Matemáticas",
    "title": "Base.Math.tand",
    "category": "Function",
    "text": "tand(x)\n\nCompute tangent of x, where x is in degrees. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.sinpi",
    "page": "Matemáticas",
    "title": "Base.Math.sinpi",
    "category": "Function",
    "text": "sinpi(x)\n\nCompute sin(pi x) more accurately than sin(pi*x), especially for large x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.cospi",
    "page": "Matemáticas",
    "title": "Base.Math.cospi",
    "category": "Function",
    "text": "cospi(x)\n\nCompute cos(pi x) more accurately than cos(pi*x), especially for large x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.sinh",
    "page": "Matemáticas",
    "title": "Base.sinh",
    "category": "Function",
    "text": "sinh(x)\n\nCompute hyperbolic sine of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.cosh",
    "page": "Matemáticas",
    "title": "Base.cosh",
    "category": "Function",
    "text": "cosh(x)\n\nCompute hyperbolic cosine of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.tanh",
    "page": "Matemáticas",
    "title": "Base.tanh",
    "category": "Function",
    "text": "tanh(x)\n\nCompute hyperbolic tangent of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.asin",
    "page": "Matemáticas",
    "title": "Base.asin",
    "category": "Function",
    "text": "asin(x)\n\nCompute the inverse sine of x, where the output is in radians.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.acos",
    "page": "Matemáticas",
    "title": "Base.acos",
    "category": "Function",
    "text": "acos(x)\n\nCompute the inverse cosine of x, where the output is in radians\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.atan",
    "page": "Matemáticas",
    "title": "Base.atan",
    "category": "Function",
    "text": "atan(x)\n\nCompute the inverse tangent of x, where the output is in radians.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.atan2",
    "page": "Matemáticas",
    "title": "Base.Math.atan2",
    "category": "Function",
    "text": "atan2(y, x)\n\nCompute the inverse tangent of y/x, using the signs of both x and y to determine the quadrant of the return value.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.asind",
    "page": "Matemáticas",
    "title": "Base.Math.asind",
    "category": "Function",
    "text": "asind(x)\n\nCompute the inverse sine of x, where the output is in degrees. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.acosd",
    "page": "Matemáticas",
    "title": "Base.Math.acosd",
    "category": "Function",
    "text": "acosd(x)\n\nCompute the inverse cosine of x, where the output is in degrees. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.atand",
    "page": "Matemáticas",
    "title": "Base.Math.atand",
    "category": "Function",
    "text": "atand(x)\n\nCompute the inverse tangent of x, where the output is in degrees. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.sec",
    "page": "Matemáticas",
    "title": "Base.Math.sec",
    "category": "Function",
    "text": "sec(x)\n\nCompute the secant of x, where x is in radians.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.csc",
    "page": "Matemáticas",
    "title": "Base.Math.csc",
    "category": "Function",
    "text": "csc(x)\n\nCompute the cosecant of x, where x is in radians.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.cot",
    "page": "Matemáticas",
    "title": "Base.Math.cot",
    "category": "Function",
    "text": "cot(x)\n\nCompute the cotangent of x, where x is in radians.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.secd",
    "page": "Matemáticas",
    "title": "Base.Math.secd",
    "category": "Function",
    "text": "secd(x)\n\nCompute the secant of x, where x is in degrees.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.cscd",
    "page": "Matemáticas",
    "title": "Base.Math.cscd",
    "category": "Function",
    "text": "cscd(x)\n\nCompute the cosecant of x, where x is in degrees.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.cotd",
    "page": "Matemáticas",
    "title": "Base.Math.cotd",
    "category": "Function",
    "text": "cotd(x)\n\nCompute the cotangent of x, where x is in degrees.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.asec",
    "page": "Matemáticas",
    "title": "Base.Math.asec",
    "category": "Function",
    "text": "asec(x)\n\nCompute the inverse secant of x, where the output is in radians. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.acsc",
    "page": "Matemáticas",
    "title": "Base.Math.acsc",
    "category": "Function",
    "text": "acsc(x)\n\nCompute the inverse cosecant of x, where the output is in radians. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.acot",
    "page": "Matemáticas",
    "title": "Base.Math.acot",
    "category": "Function",
    "text": "acot(x)\n\nCompute the inverse cotangent of x, where the output is in radians. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.asecd",
    "page": "Matemáticas",
    "title": "Base.Math.asecd",
    "category": "Function",
    "text": "asecd(x)\n\nCompute the inverse secant of x, where the output is in degrees. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.acscd",
    "page": "Matemáticas",
    "title": "Base.Math.acscd",
    "category": "Function",
    "text": "acscd(x)\n\nCompute the inverse cosecant of x, where the output is in degrees. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.acotd",
    "page": "Matemáticas",
    "title": "Base.Math.acotd",
    "category": "Function",
    "text": "acotd(x)\n\nCompute the inverse cotangent of x, where the output is in degrees. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.sech",
    "page": "Matemáticas",
    "title": "Base.Math.sech",
    "category": "Function",
    "text": "sech(x)\n\nCompute the hyperbolic secant of x\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.csch",
    "page": "Matemáticas",
    "title": "Base.Math.csch",
    "category": "Function",
    "text": "csch(x)\n\nCompute the hyperbolic cosecant of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.coth",
    "page": "Matemáticas",
    "title": "Base.Math.coth",
    "category": "Function",
    "text": "coth(x)\n\nCompute the hyperbolic cotangent of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.asinh",
    "page": "Matemáticas",
    "title": "Base.asinh",
    "category": "Function",
    "text": "asinh(x)\n\nCompute the inverse hyperbolic sine of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.acosh",
    "page": "Matemáticas",
    "title": "Base.acosh",
    "category": "Function",
    "text": "acosh(x)\n\nCompute the inverse hyperbolic cosine of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.atanh",
    "page": "Matemáticas",
    "title": "Base.atanh",
    "category": "Function",
    "text": "atanh(x)\n\nCompute the inverse hyperbolic tangent of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.asech",
    "page": "Matemáticas",
    "title": "Base.Math.asech",
    "category": "Function",
    "text": "asech(x)\n\nCompute the inverse hyperbolic secant of x. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.acsch",
    "page": "Matemáticas",
    "title": "Base.Math.acsch",
    "category": "Function",
    "text": "acsch(x)\n\nCompute the inverse hyperbolic cosecant of x. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.acoth",
    "page": "Matemáticas",
    "title": "Base.Math.acoth",
    "category": "Function",
    "text": "acoth(x)\n\nCompute the inverse hyperbolic cotangent of x. \n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.sinc",
    "page": "Matemáticas",
    "title": "Base.Math.sinc",
    "category": "Function",
    "text": "sinc(x)\n\nCompute sin(pi x)  (pi x) if x neq 0, and 1 if x = 0.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.cosc",
    "page": "Matemáticas",
    "title": "Base.Math.cosc",
    "category": "Function",
    "text": "cosc(x)\n\nCompute cos(pi x)  x - sin(pi x)  (pi x^2) if x neq 0, and 0 if x = 0. This is the derivative of sinc(x).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.deg2rad",
    "page": "Matemáticas",
    "title": "Base.Math.deg2rad",
    "category": "Function",
    "text": "deg2rad(x)\n\nConvert x from degrees to radians.\n\njulia> deg2rad(90)\n1.5707963267948966\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.rad2deg",
    "page": "Matemáticas",
    "title": "Base.Math.rad2deg",
    "category": "Function",
    "text": "rad2deg(x)\n\nConvert x from radians to degrees.\n\njulia> rad2deg(pi)\n180.0\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.hypot",
    "page": "Matemáticas",
    "title": "Base.Math.hypot",
    "category": "Function",
    "text": "hypot(x, y)\n\nCompute the hypotenuse sqrtx^2+y^2 avoiding overflow and underflow.\n\nExamples\n\njulia> a = 10^10;\n\njulia> hypot(a, a)\n1.4142135623730951e10\n\njulia> √(a^2 + a^2) # a^2 overflows\nERROR: DomainError:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).\nStacktrace:\n [1] sqrt(::Int64) at ./math.jl:434\n\n\n\nhypot(x...)\n\nCompute the hypotenuse sqrtsum x_i^2 avoiding overflow and underflow.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.log-Tuple{Any}",
    "page": "Matemáticas",
    "title": "Base.log",
    "category": "Method",
    "text": "log(x)\n\nCompute the natural logarithm of x. Throws DomainError for negative Real arguments. Use complex negative arguments to obtain complex results.\n\nThere is an experimental variant in the Base.Math.JuliaLibm module, which is typically faster and more accurate.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.log-Tuple{Number,Number}",
    "page": "Matemáticas",
    "title": "Base.log",
    "category": "Method",
    "text": "log(b,x)\n\nCompute the base b logarithm of x. Throws DomainError for negative Real arguments.\n\njulia> log(4,8)\n1.5\n\njulia> log(4,2)\n0.5\n\nnote: Note\nIf b is a power of 2 or 10, log2 or log10 should be used, as these will typically be faster and more accurate. For example,julia> log(100,1000000)\n2.9999999999999996\n\njulia> log10(1000000)/2\n3.0\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.log2",
    "page": "Matemáticas",
    "title": "Base.log2",
    "category": "Function",
    "text": "log2(x)\n\nCompute the logarithm of x to base 2. Throws DomainError for negative Real arguments.\n\nExample\n\njulia> log2(4)\n2.0\n\njulia> log2(10)\n3.321928094887362\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.log10",
    "page": "Matemáticas",
    "title": "Base.log10",
    "category": "Function",
    "text": "log10(x)\n\nCompute the logarithm of x to base 10. Throws DomainError for negative Real arguments.\n\nExample\n\njulia> log10(100)\n2.0\n\njulia> log10(2)\n0.3010299956639812\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.log1p",
    "page": "Matemáticas",
    "title": "Base.log1p",
    "category": "Function",
    "text": "log1p(x)\n\nAccurate natural logarithm of 1+x. Throws DomainError for Real arguments less than -1.\n\nThere is an experimental variant in the Base.Math.JuliaLibm module, which is typically faster and more accurate.\n\nExamples\n\njulia> log1p(-0.5)\n-0.6931471805599453\n\njulia> log1p(0)\n0.0\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.frexp",
    "page": "Matemáticas",
    "title": "Base.Math.frexp",
    "category": "Function",
    "text": "frexp(val)\n\nReturn (x,exp) such that x has a magnitude in the interval 12 1) or 0, and val is equal to x times 2^exp.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.exp",
    "page": "Matemáticas",
    "title": "Base.exp",
    "category": "Function",
    "text": "exp(x)\n\nCompute the natural base exponential of x, in other words e^x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.exp2",
    "page": "Matemáticas",
    "title": "Base.exp2",
    "category": "Function",
    "text": "exp2(x)\n\nCompute 2^x.\n\njulia> exp2(5)\n32.0\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.exp10",
    "page": "Matemáticas",
    "title": "Base.exp10",
    "category": "Function",
    "text": "exp10(x)\n\nCompute 10^x.\n\nExamples\n\njulia> exp10(2)\n100.0\n\njulia> exp10(0.2)\n1.5848931924611136\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.ldexp",
    "page": "Matemáticas",
    "title": "Base.Math.ldexp",
    "category": "Function",
    "text": "ldexp(x, n)\n\nCompute x times 2^n.\n\nExample\n\njulia> ldexp(5., 2)\n20.0\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.modf",
    "page": "Matemáticas",
    "title": "Base.Math.modf",
    "category": "Function",
    "text": "modf(x)\n\nReturn a tuple (fpart,ipart) of the fractional and integral parts of a number. Both parts have the same sign as the argument.\n\nExample\n\njulia> modf(3.5)\n(0.5, 3.0)\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.expm1",
    "page": "Matemáticas",
    "title": "Base.expm1",
    "category": "Function",
    "text": "expm1(x)\n\nAccurately compute e^x-1.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.round-Tuple{Type,Any}",
    "page": "Matemáticas",
    "title": "Base.round",
    "category": "Method",
    "text": "round([T,] x, [digits, [base]], [r::RoundingMode])\n\nRounds x to an integer value according to the provided RoundingMode, returning a value of the same type as x. When not specifying a rounding mode the global mode will be used (see rounding), which by default is round to the nearest integer (RoundNearest mode), with ties (fractional values of 0.5) being rounded to the nearest even integer.\n\njulia> round(1.7)\n2.0\n\njulia> round(1.5)\n2.0\n\njulia> round(2.5)\n2.0\n\nThe optional RoundingMode argument will change how the number gets rounded.\n\nround(T, x, [r::RoundingMode]) converts the result to type T, throwing an InexactError if the value is not representable.\n\nround(x, digits) rounds to the specified number of digits after the decimal place (or before if negative). round(x, digits, base) rounds using a base other than 10.\n\njulia> round(pi, 2)\n3.14\n\njulia> round(pi, 3, 2)\n3.125\n\nnote: Note\nRounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the Float64 value represented by 1.15 is actually less than 1.15, yet will be rounded to 1.2.julia> x = 1.15\n1.15\n\njulia> @sprintf \"%.20f\" x\n\"1.14999999999999991118\"\n\njulia> x < 115//100\ntrue\n\njulia> round(x, 1)\n1.2\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Rounding.RoundingMode",
    "page": "Matemáticas",
    "title": "Base.Rounding.RoundingMode",
    "category": "Type",
    "text": "RoundingMode\n\nA type used for controlling the rounding mode of floating point operations (via rounding/setrounding functions), or as optional arguments for rounding to the nearest integer (via the round function).\n\nCurrently supported rounding modes are:\n\nRoundNearest (default)\nRoundNearestTiesAway\nRoundNearestTiesUp\nRoundToZero\nRoundFromZero (BigFloat only)\nRoundUp\nRoundDown\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Rounding.RoundNearest",
    "page": "Matemáticas",
    "title": "Base.Rounding.RoundNearest",
    "category": "Constant",
    "text": "RoundNearest\n\nThe default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Rounding.RoundNearestTiesAway",
    "page": "Matemáticas",
    "title": "Base.Rounding.RoundNearestTiesAway",
    "category": "Constant",
    "text": "RoundNearestTiesAway\n\nRounds to nearest integer, with ties rounded away from zero (C/C++ round behaviour).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Rounding.RoundNearestTiesUp",
    "page": "Matemáticas",
    "title": "Base.Rounding.RoundNearestTiesUp",
    "category": "Constant",
    "text": "RoundNearestTiesUp\n\nRounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript round behaviour).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Rounding.RoundToZero",
    "page": "Matemáticas",
    "title": "Base.Rounding.RoundToZero",
    "category": "Constant",
    "text": "RoundToZero\n\nround using this rounding mode is an alias for trunc.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Rounding.RoundUp",
    "page": "Matemáticas",
    "title": "Base.Rounding.RoundUp",
    "category": "Constant",
    "text": "RoundUp\n\nround using this rounding mode is an alias for ceil.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Rounding.RoundDown",
    "page": "Matemáticas",
    "title": "Base.Rounding.RoundDown",
    "category": "Constant",
    "text": "RoundDown\n\nround using this rounding mode is an alias for floor.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.round-Union{Tuple{Complex{T},RoundingMode{MR},RoundingMode{MI}}, Tuple{MI}, Tuple{MR}, Tuple{T}} where MI where MR where T<:AbstractFloat",
    "page": "Matemáticas",
    "title": "Base.round",
    "category": "Method",
    "text": "round(z, RoundingModeReal, RoundingModeImaginary)\n\nReturns the nearest integral value of the same type as the complex-valued z to z, breaking ties using the specified RoundingModes. The first RoundingMode is used for rounding the real components while the second is used for rounding the imaginary components.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.ceil",
    "page": "Matemáticas",
    "title": "Base.ceil",
    "category": "Function",
    "text": "ceil([T,] x, [digits, [base]])\n\nceil(x) returns the nearest integral value of the same type as x that is greater than or equal to x.\n\nceil(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\n\ndigits and base work as for round.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.floor",
    "page": "Matemáticas",
    "title": "Base.floor",
    "category": "Function",
    "text": "floor([T,] x, [digits, [base]])\n\nfloor(x) returns the nearest integral value of the same type as x that is less than or equal to x.\n\nfloor(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\n\ndigits and base work as for round.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.trunc",
    "page": "Matemáticas",
    "title": "Base.trunc",
    "category": "Function",
    "text": "trunc([T,] x, [digits, [base]])\n\ntrunc(x) returns the nearest integral value of the same type as x whose absolute value is less than or equal to x.\n\ntrunc(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\n\ndigits and base work as for round.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.unsafe_trunc",
    "page": "Matemáticas",
    "title": "Base.unsafe_trunc",
    "category": "Function",
    "text": "unsafe_trunc(T, x)\n\nunsafe_trunc(T, x) returns the nearest integral value of type T whose absolute value is less than or equal to x. If the value is not representable by T, an arbitrary value will be returned.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.signif",
    "page": "Matemáticas",
    "title": "Base.signif",
    "category": "Function",
    "text": "signif(x, digits, [base])\n\nRounds (in the sense of round) x so that there are digits significant digits, under a base base representation, default 10. E.g., signif(123.456, 2) is 120.0, and signif(357.913, 4, 2) is 352.0.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.min",
    "page": "Matemáticas",
    "title": "Base.min",
    "category": "Function",
    "text": "min(x, y, ...)\n\nReturn the minimum of the arguments. See also the minimum function to take the minimum element from a collection.\n\njulia> min(2, 5, 1)\n1\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.max",
    "page": "Matemáticas",
    "title": "Base.max",
    "category": "Function",
    "text": "max(x, y, ...)\n\nReturn the maximum of the arguments. See also the maximum function to take the maximum element from a collection.\n\njulia> max(2, 5, 1)\n5\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.minmax",
    "page": "Matemáticas",
    "title": "Base.minmax",
    "category": "Function",
    "text": "minmax(x, y)\n\nReturn (min(x,y), max(x,y)). See also: extrema that returns (minimum(x), maximum(x)).\n\njulia> minmax('c','b')\n('b', 'c')\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.clamp",
    "page": "Matemáticas",
    "title": "Base.Math.clamp",
    "category": "Function",
    "text": "clamp(x, lo, hi)\n\nReturn x if lo <= x <= hi. If x < lo, return lo. If x > hi, return hi. Arguments are promoted to a common type.\n\njulia> clamp.([pi, 1.0, big(10.)], 2., 9.)\n3-element Array{BigFloat,1}:\n 3.141592653589793238462643383279502884197169399375105820974944592307816406286198\n 2.000000000000000000000000000000000000000000000000000000000000000000000000000000\n 9.000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.clamp!",
    "page": "Matemáticas",
    "title": "Base.Math.clamp!",
    "category": "Function",
    "text": "clamp!(array::AbstractArray, lo, hi)\n\nRestrict values in array to the specified range, in-place. See also clamp.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.abs",
    "page": "Matemáticas",
    "title": "Base.abs",
    "category": "Function",
    "text": "abs(x)\n\nThe absolute value of x.\n\nWhen abs is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when abs is applied to the minimum representable value of a signed integer. That is, when x == typemin(typeof(x)), abs(x) == x < 0, not -x as might be expected.\n\njulia> abs(-3)\n3\n\njulia> abs(1 + im)\n1.4142135623730951\n\njulia> abs(typemin(Int64))\n-9223372036854775808\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_abs",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_abs",
    "category": "Function",
    "text": "Base.checked_abs(x)\n\nCalculates abs(x), checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. Int) cannot represent abs(typemin(Int)), thus leading to an overflow.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_neg",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_neg",
    "category": "Function",
    "text": "Base.checked_neg(x)\n\nCalculates -x, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. Int) cannot represent -typemin(Int), thus leading to an overflow.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_add",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_add",
    "category": "Function",
    "text": "Base.checked_add(x, y)\n\nCalculates x+y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_sub",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_sub",
    "category": "Function",
    "text": "Base.checked_sub(x, y)\n\nCalculates x-y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_mul",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_mul",
    "category": "Function",
    "text": "Base.checked_mul(x, y)\n\nCalculates x*y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_div",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_div",
    "category": "Function",
    "text": "Base.checked_div(x, y)\n\nCalculates div(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_rem",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_rem",
    "category": "Function",
    "text": "Base.checked_rem(x, y)\n\nCalculates x%y, checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_fld",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_fld",
    "category": "Function",
    "text": "Base.checked_fld(x, y)\n\nCalculates fld(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_mod",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_mod",
    "category": "Function",
    "text": "Base.checked_mod(x, y)\n\nCalculates mod(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.checked_cld",
    "page": "Matemáticas",
    "title": "Base.Checked.checked_cld",
    "category": "Function",
    "text": "Base.checked_cld(x, y)\n\nCalculates cld(x,y), checking for overflow errors where applicable.\n\nThe overflow protection may impose a perceptible performance penalty.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.add_with_overflow",
    "page": "Matemáticas",
    "title": "Base.Checked.add_with_overflow",
    "category": "Function",
    "text": "Base.add_with_overflow(x, y) -> (r, f)\n\nCalculates r = x+y, with the flag f indicating whether overflow has occurred.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.sub_with_overflow",
    "page": "Matemáticas",
    "title": "Base.Checked.sub_with_overflow",
    "category": "Function",
    "text": "Base.sub_with_overflow(x, y) -> (r, f)\n\nCalculates r = x-y, with the flag f indicating whether overflow has occurred.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Checked.mul_with_overflow",
    "page": "Matemáticas",
    "title": "Base.Checked.mul_with_overflow",
    "category": "Function",
    "text": "Base.mul_with_overflow(x, y) -> (r, f)\n\nCalculates r = x*y, with the flag f indicating whether overflow has occurred.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.abs2",
    "page": "Matemáticas",
    "title": "Base.abs2",
    "category": "Function",
    "text": "abs2(x)\n\nSquared absolute value of x.\n\njulia> abs2(-3)\n9\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.copysign",
    "page": "Matemáticas",
    "title": "Base.copysign",
    "category": "Function",
    "text": "copysign(x, y) -> z\n\nReturn z which has the magnitude of x and the same sign as y.\n\nExamples\n\njulia> copysign(1, -2)\n-1\n\njulia> copysign(-1, 2)\n1\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.sign",
    "page": "Matemáticas",
    "title": "Base.sign",
    "category": "Function",
    "text": "sign(x)\n\nReturn zero if x==0 and xx otherwise (i.e., ±1 for real x).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.signbit",
    "page": "Matemáticas",
    "title": "Base.signbit",
    "category": "Function",
    "text": "signbit(x)\n\nReturns true if the value of the sign of x is negative, otherwise false.\n\nExamples\n\njulia> signbit(-4)\ntrue\n\njulia> signbit(5)\nfalse\n\njulia> signbit(5.5)\nfalse\n\njulia> signbit(-4.1)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.flipsign",
    "page": "Matemáticas",
    "title": "Base.flipsign",
    "category": "Function",
    "text": "flipsign(x, y)\n\nReturn x with its sign flipped if y is negative. For example abs(x) = flipsign(x,x).\n\njulia> flipsign(5, 3)\n5\n\njulia> flipsign(5, -3)\n-5\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.sqrt",
    "page": "Matemáticas",
    "title": "Base.sqrt",
    "category": "Function",
    "text": "sqrt(x)\n\nReturn sqrtx. Throws DomainError for negative Real arguments. Use complex negative arguments instead. The prefix operator √ is equivalent to sqrt.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.isqrt",
    "page": "Matemáticas",
    "title": "Base.isqrt",
    "category": "Function",
    "text": "isqrt(n::Integer)\n\nInteger square root: the largest integer m such that m*m <= n.\n\njulia> isqrt(5)\n2\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.cbrt",
    "page": "Matemáticas",
    "title": "Base.Math.cbrt",
    "category": "Function",
    "text": "cbrt(x::Real)\n\nReturn the cube root of x, i.e. x^13. Negative values are accepted (returning the negative real root when x  0).\n\nThe prefix operator ∛ is equivalent to cbrt.\n\njulia> cbrt(big(27))\n3.000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.real-Tuple{Complex}",
    "page": "Matemáticas",
    "title": "Base.real",
    "category": "Method",
    "text": "real(z)\n\nReturn the real part of the complex number z.\n\njulia> real(1 + 3im)\n1\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.imag",
    "page": "Matemáticas",
    "title": "Base.imag",
    "category": "Function",
    "text": "imag(z)\n\nReturn the imaginary part of the complex number z.\n\njulia> imag(1 + 3im)\n3\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.reim",
    "page": "Matemáticas",
    "title": "Base.reim",
    "category": "Function",
    "text": "reim(z)\n\nReturn both the real and imaginary parts of the complex number z.\n\njulia> reim(1 + 3im)\n(1, 3)\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.conj",
    "page": "Matemáticas",
    "title": "Base.conj",
    "category": "Function",
    "text": "conj(v::RowVector)\n\nReturns a ConjArray lazy view of the input, where each element is conjugated.\n\nExample\n\njulia> v = [1+im, 1-im].'\n1×2 RowVector{Complex{Int64},Array{Complex{Int64},1}}:\n 1+1im  1-1im\n\njulia> conj(v)\n1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:\n 1-1im  1+1im\n\n\n\nconj(z)\n\nCompute the complex conjugate of a complex number z.\n\njulia> conj(1 + 3im)\n1 - 3im\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.angle",
    "page": "Matemáticas",
    "title": "Base.angle",
    "category": "Function",
    "text": "angle(z)\n\nCompute the phase angle in radians of a complex number z.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.cis",
    "page": "Matemáticas",
    "title": "Base.cis",
    "category": "Function",
    "text": "cis(z)\n\nReturn exp(iz).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.binomial",
    "page": "Matemáticas",
    "title": "Base.binomial",
    "category": "Function",
    "text": "binomial(n, k)\n\nNumber of ways to choose k out of n items.\n\nExample\n\njulia> binomial(5, 3)\n10\n\njulia> factorial(5) ÷ (factorial(5-3) * factorial(3))\n10\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.factorial",
    "page": "Matemáticas",
    "title": "Base.factorial",
    "category": "Function",
    "text": "factorial(n)\n\nFactorial of n. If n is an Integer, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if n is not small, but you can use factorial(big(n)) to compute the result exactly in arbitrary precision. If n is not an Integer, factorial(n) is equivalent to gamma(n+1).\n\njulia> factorial(6)\n720\n\njulia> factorial(21)\nERROR: OverflowError()\n[...]\n\njulia> factorial(21.0)\n5.109094217170944e19\n\njulia> factorial(big(21))\n51090942171709440000\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.gcd",
    "page": "Matemáticas",
    "title": "Base.gcd",
    "category": "Function",
    "text": "gcd(x,y)\n\nGreatest common (positive) divisor (or zero if x and y are both zero).\n\nExamples\n\njulia> gcd(6,9)\n3\n\njulia> gcd(6,-9)\n3\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.lcm",
    "page": "Matemáticas",
    "title": "Base.lcm",
    "category": "Function",
    "text": "lcm(x,y)\n\nLeast common (non-negative) multiple.\n\nExamples\n\njulia> lcm(2,3)\n6\n\njulia> lcm(-2,3)\n6\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.gcdx",
    "page": "Matemáticas",
    "title": "Base.gcdx",
    "category": "Function",
    "text": "gcdx(x,y)\n\nComputes the greatest common (positive) divisor of x and y and their Bézout coefficients, i.e. the integer coefficients u and v that satisfy ux+vy = d = gcd(xy). gcdx(xy) returns (duv).\n\nExamples\n\njulia> gcdx(12, 42)\n(6, -3, 1)\n\njulia> gcdx(240, 46)\n(2, -9, 47)\n\nnote: Note\nBézout coefficients are not uniquely defined. gcdx returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients u and v are minimal in the sense that u  yd and v  xd. Furthermore, the signs of u and v are chosen so that d is positive. For unsigned integers, the coefficients u and v might be near their typemax, and the identity then holds only via the unsigned integers' modulo arithmetic.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.ispow2",
    "page": "Matemáticas",
    "title": "Base.ispow2",
    "category": "Function",
    "text": "ispow2(n::Integer) -> Bool\n\nTest whether n is a power of two.\n\nExamples\n\njulia> ispow2(4)\ntrue\n\njulia> ispow2(5)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.nextpow2",
    "page": "Matemáticas",
    "title": "Base.nextpow2",
    "category": "Function",
    "text": "nextpow2(n::Integer)\n\nThe smallest power of two not less than n. Returns 0 for n==0, and returns -nextpow2(-n) for negative arguments.\n\nExamples\n\njulia> nextpow2(16)\n16\n\njulia> nextpow2(17)\n32\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.prevpow2",
    "page": "Matemáticas",
    "title": "Base.prevpow2",
    "category": "Function",
    "text": "prevpow2(n::Integer)\n\nThe largest power of two not greater than n. Returns 0 for n==0, and returns -prevpow2(-n) for negative arguments.\n\nExamples\n\njulia> prevpow2(5)\n4\n\njulia> prevpow2(0)\n0\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.nextpow",
    "page": "Matemáticas",
    "title": "Base.nextpow",
    "category": "Function",
    "text": "nextpow(a, x)\n\nThe smallest a^n not less than x, where n is a non-negative integer. a must be greater than 1, and x must be greater than 0.\n\nExamples\n\njulia> nextpow(2, 7)\n8\n\njulia> nextpow(2, 9)\n16\n\njulia> nextpow(5, 20)\n25\n\njulia> nextpow(4, 16)\n16\n\nSee also prevpow.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.prevpow",
    "page": "Matemáticas",
    "title": "Base.prevpow",
    "category": "Function",
    "text": "prevpow(a, x)\n\nThe largest a^n not greater than x, where n is a non-negative integer. a must be greater than 1, and x must not be less than 1.\n\nExamples\n\njulia> prevpow(2, 7)\n4\n\njulia> prevpow(2, 9)\n8\n\njulia> prevpow(5, 20)\n5\n\njulia> prevpow(4, 16)\n16\n\nSee also nextpow.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.nextprod",
    "page": "Matemáticas",
    "title": "Base.nextprod",
    "category": "Function",
    "text": "nextprod([k_1, k_2,...], n)\n\nNext integer greater than or equal to n that can be written as prod k_i^p_i for integers p_1, p_2, etc.\n\nExample\n\njulia> nextprod([2, 3], 105)\n108\n\njulia> 2^2 * 3^3\n108\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.invmod",
    "page": "Matemáticas",
    "title": "Base.invmod",
    "category": "Function",
    "text": "invmod(x,m)\n\nTake the inverse of x modulo m: y such that x y = 1 pmod m, with div(xy) = 0. This is undefined for m = 0, or if gcd(xm) neq 1.\n\nExamples\n\njulia> invmod(2,5)\n3\n\njulia> invmod(2,3)\n2\n\njulia> invmod(5,6)\n5\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.powermod",
    "page": "Matemáticas",
    "title": "Base.powermod",
    "category": "Function",
    "text": "powermod(x::Integer, p::Integer, m)\n\nCompute x^p pmod m.\n\nExamples\n\njulia> powermod(2, 6, 5)\n4\n\njulia> mod(2^6, 5)\n4\n\njulia> powermod(5, 2, 20)\n5\n\njulia> powermod(5, 2, 19)\n6\n\njulia> powermod(5, 3, 19)\n11\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.gamma",
    "page": "Matemáticas",
    "title": "Base.Math.gamma",
    "category": "Function",
    "text": "gamma(x)\n\nCompute the gamma function of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.lgamma",
    "page": "Matemáticas",
    "title": "Base.Math.lgamma",
    "category": "Function",
    "text": "lgamma(x)\n\nCompute the logarithm of the absolute value of gamma for Real x, while for Complex x compute the principal branch cut of the logarithm of gamma(x) (defined for negative real(x) by analytic continuation from positive real(x)).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.lfact",
    "page": "Matemáticas",
    "title": "Base.Math.lfact",
    "category": "Function",
    "text": "lfact(x)\n\nCompute the logarithmic factorial of a nonnegative integer x. Equivalent to lgamma of x + 1, but lgamma extends this function to non-integer x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.beta",
    "page": "Matemáticas",
    "title": "Base.Math.beta",
    "category": "Function",
    "text": "beta(x, y)\n\nEuler integral of the first kind operatornameB(xy) = Gamma(x)Gamma(y)Gamma(x+y).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.lbeta",
    "page": "Matemáticas",
    "title": "Base.Math.lbeta",
    "category": "Function",
    "text": "lbeta(x, y)\n\nNatural logarithm of the absolute value of the beta function log(operatornameB(xy)).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.ndigits",
    "page": "Matemáticas",
    "title": "Base.ndigits",
    "category": "Function",
    "text": "ndigits(n::Integer, b::Integer=10)\n\nCompute the number of digits in integer n written in base b. The base b must not be in [-1, 0, 1].\n\nExamples\n\njulia> ndigits(12345)\n5\n\njulia> ndigits(1022, 16)\n3\n\njulia> base(16, 1022)\n\"3fe\"\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.widemul",
    "page": "Matemáticas",
    "title": "Base.widemul",
    "category": "Function",
    "text": "widemul(x, y)\n\nMultiply x and y, giving the result as a larger type.\n\njulia> widemul(Float32(3.), 4.)\n1.200000000000000000000000000000000000000000000000000000000000000000000000000000e+01\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.Math.@evalpoly",
    "page": "Matemáticas",
    "title": "Base.Math.@evalpoly",
    "category": "Macro",
    "text": "@evalpoly(z, c...)\n\nEvaluate the polynomial sum_k ck z^k-1 for the coefficients c[1], c[2], ...; that is, the coefficients are given in ascending order by power of z.  This macro expands to efficient inline code that uses either Horner's method or, for complex z, a more efficient Goertzel-like algorithm.\n\njulia> @evalpoly(3, 1, 0, 1)\n10\n\njulia> @evalpoly(2, 1, 0, 1)\n5\n\njulia> @evalpoly(2, 1, 1, 1)\n7\n\n\n\n"
},

{
    "location": "stdlib/math.html#Funciones-Matemáticas-1",
    "page": "Matemáticas",
    "title": "Funciones Matemáticas",
    "category": "section",
    "text": "Base.isapprox\nBase.sin\nBase.cos\nBase.tan\nBase.Math.sind\nBase.Math.cosd\nBase.Math.tand\nBase.Math.sinpi\nBase.Math.cospi\nBase.sinh\nBase.cosh\nBase.tanh\nBase.asin\nBase.acos\nBase.atan\nBase.Math.atan2\nBase.Math.asind\nBase.Math.acosd\nBase.Math.atand\nBase.Math.sec\nBase.Math.csc\nBase.Math.cot\nBase.Math.secd\nBase.Math.cscd\nBase.Math.cotd\nBase.Math.asec\nBase.Math.acsc\nBase.Math.acot\nBase.Math.asecd\nBase.Math.acscd\nBase.Math.acotd\nBase.Math.sech\nBase.Math.csch\nBase.Math.coth\nBase.asinh\nBase.acosh\nBase.atanh\nBase.Math.asech\nBase.Math.acsch\nBase.Math.acoth\nBase.Math.sinc\nBase.Math.cosc\nBase.Math.deg2rad\nBase.Math.rad2deg\nBase.Math.hypot\nBase.log(::Any)\nBase.log(::Number, ::Number)\nBase.log2\nBase.log10\nBase.log1p\nBase.Math.frexp\nBase.exp\nBase.exp2\nBase.exp10\nBase.Math.ldexp\nBase.Math.modf\nBase.expm1\nBase.round(::Type, ::Any)\nBase.Rounding.RoundingMode\nBase.Rounding.RoundNearest\nBase.Rounding.RoundNearestTiesAway\nBase.Rounding.RoundNearestTiesUp\nBase.Rounding.RoundToZero\nBase.Rounding.RoundUp\nBase.Rounding.RoundDown\nBase.round{T <: AbstractFloat, MR, MI}(::Complex{T}, ::RoundingMode{MR}, ::RoundingMode{MI})\nBase.ceil\nBase.floor\nBase.trunc\nBase.unsafe_trunc\nBase.signif\nBase.min\nBase.max\nBase.minmax\nBase.Math.clamp\nBase.Math.clamp!\nBase.abs\nBase.Checked.checked_abs\nBase.Checked.checked_neg\nBase.Checked.checked_add\nBase.Checked.checked_sub\nBase.Checked.checked_mul\nBase.Checked.checked_div\nBase.Checked.checked_rem\nBase.Checked.checked_fld\nBase.Checked.checked_mod\nBase.Checked.checked_cld\nBase.Checked.add_with_overflow\nBase.Checked.sub_with_overflow\nBase.Checked.mul_with_overflow\nBase.abs2\nBase.copysign\nBase.sign\nBase.signbit\nBase.flipsign\nBase.sqrt\nBase.isqrt\nBase.Math.cbrt\nBase.real(::Complex)\nBase.imag\nBase.reim\nBase.conj\nBase.angle\nBase.cis\nBase.binomial\nBase.factorial\nBase.gcd\nBase.lcm\nBase.gcdx\nBase.ispow2\nBase.nextpow2\nBase.prevpow2\nBase.nextpow\nBase.prevpow\nBase.nextprod\nBase.invmod\nBase.powermod\nBase.Math.gamma\nBase.Math.lgamma\nBase.Math.lfact\nBase.Math.beta\nBase.Math.lbeta\nBase.ndigits\nBase.widemul\nBase.Math.@evalpoly"
},

{
    "location": "stdlib/math.html#Base.mean",
    "page": "Matemáticas",
    "title": "Base.mean",
    "category": "Function",
    "text": "mean(f::Function, v)\n\nApply the function f to each element of v and take the mean.\n\njulia> mean(√, [1, 2, 3])\n1.3820881233139908\n\njulia> mean([√1, √2, √3])\n1.3820881233139908\n\n\n\nmean(v[, region])\n\nCompute the mean of whole array v, or optionally along the dimensions in region.\n\nnote: Note\nJulia does not ignore NaN values in the computation. For applications requiring the handling of missing data, the DataArrays.jl package is recommended.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.mean!",
    "page": "Matemáticas",
    "title": "Base.mean!",
    "category": "Function",
    "text": "mean!(r, v)\n\nCompute the mean of v over the singleton dimensions of r, and write results to r.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.std",
    "page": "Matemáticas",
    "title": "Base.std",
    "category": "Function",
    "text": "std(v[, region]; corrected::Bool=true, mean=nothing)\n\nCompute the sample standard deviation of a vector or array v, optionally along dimensions in region. The algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of v is an IID drawn from that generative distribution. This computation is equivalent to calculating sqrt(sum((v - mean(v)).^2) / (length(v) - 1)). A pre-computed mean may be provided. If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\n\nnote: Note\nJulia does not ignore NaN values in the computation. For applications requiring the handling of missing data, the DataArrays.jl package is recommended.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.stdm",
    "page": "Matemáticas",
    "title": "Base.stdm",
    "category": "Function",
    "text": "stdm(v, m::Number; corrected::Bool=true)\n\nCompute the sample standard deviation of a vector v with known mean m. If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\n\nnote: Note\nJulia does not ignore NaN values in the computation. For applications requiring the handling of missing data, the DataArrays.jl package is recommended.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.var",
    "page": "Matemáticas",
    "title": "Base.var",
    "category": "Function",
    "text": "var(v[, region]; corrected::Bool=true, mean=nothing)\n\nCompute the sample variance of a vector or array v, optionally along dimensions in region. The algorithm will return an estimator of the generative distribution's variance under the assumption that each entry of v is an IID drawn from that generative distribution. This computation is equivalent to calculating sum(abs2, v - mean(v)) / (length(v) - 1). If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x). The mean mean over the region may be provided.\n\nnote: Note\nJulia does not ignore NaN values in the computation. For applications requiring the handling of missing data, the DataArrays.jl package is recommended.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.varm",
    "page": "Matemáticas",
    "title": "Base.varm",
    "category": "Function",
    "text": "varm(v, m[, region]; corrected::Bool=true)\n\nCompute the sample variance of a collection v with known mean(s) m, optionally over region. m may contain means for each dimension of v. If corrected is true, then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\n\nnote: Note\nJulia does not ignore NaN values in the computation. For applications requiring the handling of missing data, the DataArrays.jl package is recommended.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.middle",
    "page": "Matemáticas",
    "title": "Base.middle",
    "category": "Function",
    "text": "middle(x)\n\nCompute the middle of a scalar value, which is equivalent to x itself, but of the type of middle(x, x) for consistency.\n\n\n\nmiddle(x, y)\n\nCompute the middle of two reals x and y, which is equivalent in both value and type to computing their mean ((x + y) / 2).\n\n\n\nmiddle(range)\n\nCompute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.\n\njulia> middle(1:10)\n5.5\n\n\n\nmiddle(a)\n\nCompute the middle of an array a, which consists of finding its extrema and then computing their mean.\n\njulia> a = [1,2,3.6,10.9]\n4-element Array{Float64,1}:\n  1.0\n  2.0\n  3.6\n 10.9\n\njulia> middle(a)\n5.95\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.median",
    "page": "Matemáticas",
    "title": "Base.median",
    "category": "Function",
    "text": "median(v[, region])\n\nCompute the median of an entire array v, or, optionally, along the dimensions in region. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.\n\nnote: Note\nJulia does not ignore NaN values in the computation. For applications requiring the handling of missing data, the DataArrays.jl package is recommended.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.median!",
    "page": "Matemáticas",
    "title": "Base.median!",
    "category": "Function",
    "text": "median!(v)\n\nLike median, but may overwrite the input vector.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.quantile",
    "page": "Matemáticas",
    "title": "Base.quantile",
    "category": "Function",
    "text": "quantile(v, p; sorted=false)\n\nCompute the quantile(s) of a vector v at a specified probability or vector p. The keyword argument sorted indicates whether v can be assumed to be sorted.\n\nThe p should be on the interval [0,1], and v should not have any NaN values.\n\nQuantiles are computed via linear interpolation between the points ((k-1)/(n-1), v[k]), for k = 1:n where n = length(v). This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.\n\nnote: Note\nJulia does not ignore NaN values in the computation. For applications requiring the handling of missing data, the DataArrays.jl package is recommended. quantile will throw an ArgumentError in the presence of NaN values in the data array.\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", The American Statistician, Vol. 50, No. 4, pp. 361-365\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.quantile!",
    "page": "Matemáticas",
    "title": "Base.quantile!",
    "category": "Function",
    "text": "quantile!([q, ] v, p; sorted=false)\n\nCompute the quantile(s) of a vector v at the probabilities p, with optional output into array q (if not provided, a new output array is created). The keyword argument sorted indicates whether v can be assumed to be sorted; if false (the default), then the elements of v may be partially sorted.\n\nThe elements of p should be on the interval [0,1], and v should not have any NaN values.\n\nQuantiles are computed via linear interpolation between the points ((k-1)/(n-1), v[k]), for k = 1:n where n = length(v). This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.\n\nnote: Note\nJulia does not ignore NaN values in the computation. For applications requiring the handling of missing data, the DataArrays.jl package is recommended. quantile! will throw an ArgumentError in the presence of NaN values in the data array.\n\nHyndman, R.J and Fan, Y. (1996) \"Sample Quantiles in Statistical Packages\", The American Statistician, Vol. 50, No. 4, pp. 361-365\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.cov",
    "page": "Matemáticas",
    "title": "Base.cov",
    "category": "Function",
    "text": "cov(x[, corrected=true])\n\nCompute the variance of the vector x. If corrected is true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = length(x).\n\n\n\ncov(X[, vardim=1, corrected=true])\n\nCompute the covariance matrix of the matrix X along the dimension vardim. If corrected is true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = size(X, vardim).\n\n\n\ncov(x, y[, corrected=true])\n\nCompute the covariance between the vectors x and y. If corrected is true (the default), computes frac1n-1sum_i=1^n (x_i-bar x) (y_i-bar y)^* where * denotes the complex conjugate and n = length(x) = length(y). If corrected is false, computes rac1nsum_i=1^n (x_i-bar x) (y_i-bar y)^*.\n\n\n\ncov(X, Y[, vardim=1, corrected=true])\n\nCompute the covariance between the vectors or matrices X and Y along the dimension vardim. If corrected is true (the default) then the sum is scaled with n-1, whereas the sum is scaled with n if corrected is false where n = size(X, vardim) = size(Y, vardim).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.cor",
    "page": "Matemáticas",
    "title": "Base.cor",
    "category": "Function",
    "text": "cor(x)\n\nReturn the number one.\n\n\n\ncor(X[, vardim=1])\n\nCompute the Pearson correlation matrix of the matrix X along the dimension vardim.\n\n\n\ncor(x, y)\n\nCompute the Pearson correlation between the vectors x and y.\n\n\n\ncor(X, Y[, vardim=1])\n\nCompute the Pearson correlation between the vectors or matrices X and Y along the dimension vardim.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Estadística-1",
    "page": "Matemáticas",
    "title": "Estadística",
    "category": "section",
    "text": "Base.mean\nBase.mean!\nBase.std\nBase.stdm\nBase.var\nBase.varm\nBase.middle\nBase.median\nBase.median!\nBase.quantile\nBase.quantile!\nBase.cov\nBase.cor"
},

{
    "location": "stdlib/math.html#Base.DFT.fft",
    "page": "Matemáticas",
    "title": "Base.DFT.fft",
    "category": "Function",
    "text": "fft(A [, dims])\n\nPerforms a multidimensional FFT of the array A. The optional dims argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of A along the transformed dimensions is a product of small primes; see nextprod(). See also plan_fft() for even greater efficiency.\n\nA one-dimensional FFT computes the one-dimensional discrete Fourier transform (DFT) as defined by\n\noperatornameDFT(A)k =\n  sum_n=1^operatornamelength(A)\n  expleft(-ifrac2pi\n  (n-1)(k-1)operatornamelength(A) right) An\n\nA multidimensional FFT simply performs this operation along each transformed dimension of A.\n\nnote: Note\nJulia starts FFTW up with 1 thread by default. Higher performance is usually possible by increasing number of threads. Use FFTW.set_num_threads(Sys.CPU_CORES) to use as many threads as cores on your system.\nThis performs a multidimensional FFT by default. FFT libraries in other languages such as Python and Octave perform a one-dimensional FFT along the first non-singleton dimension of the array. This is worth noting while performing comparisons. For more details, refer to the Noteworthy Differences from other Languages section of the manual.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.fft!",
    "page": "Matemáticas",
    "title": "Base.DFT.fft!",
    "category": "Function",
    "text": "fft!(A [, dims])\n\nSame as fft, but operates in-place on A, which must be an array of complex floating-point numbers.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.ifft",
    "page": "Matemáticas",
    "title": "Base.DFT.ifft",
    "category": "Function",
    "text": "ifft(A [, dims])\n\nMultidimensional inverse FFT.\n\nA one-dimensional inverse FFT computes\n\noperatornameIDFT(A)k = frac1operatornamelength(A)\nsum_n=1^operatornamelength(A) expleft(+ifrac2pi (n-1)(k-1)\noperatornamelength(A) right) An\n\nA multidimensional inverse FFT simply performs this operation along each transformed dimension of A.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.ifft!",
    "page": "Matemáticas",
    "title": "Base.DFT.ifft!",
    "category": "Function",
    "text": "ifft!(A [, dims])\n\nSame as ifft, but operates in-place on A.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.bfft",
    "page": "Matemáticas",
    "title": "Base.DFT.bfft",
    "category": "Function",
    "text": "bfft(A [, dims])\n\nSimilar to ifft, but computes an unnormalized inverse (backward) transform, which must be divided by the product of the sizes of the transformed dimensions in order to obtain the inverse. (This is slightly more efficient than ifft because it omits a scaling step, which in some applications can be combined with other computational steps elsewhere.)\n\noperatornameBDFT(A)k = operatornamelength(A) operatornameIDFT(A)k\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.bfft!",
    "page": "Matemáticas",
    "title": "Base.DFT.bfft!",
    "category": "Function",
    "text": "bfft!(A [, dims])\n\nSame as bfft, but operates in-place on A.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.plan_fft",
    "page": "Matemáticas",
    "title": "Base.DFT.plan_fft",
    "category": "Function",
    "text": "plan_fft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)\n\nPre-plan an optimized FFT along given dimensions (dims) of arrays matching the shape and type of A.  (The first two arguments have the same meaning as for fft.) Returns an object P which represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly.\n\nTo apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices.  (A plan can only be applied to arrays of the same size as the A for which the plan was created.)  You can also apply a plan with a preallocated output array Â by calling A_mul_B!(Â, plan, A).  (For A_mul_B!, however, the input array A must be a complex floating-point array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \\ Â (the inverse plan is cached and reused for subsequent calls to inv or \\), and apply the inverse plan to a pre-allocated output array A with A_ldiv_B!(A, P, Â).\n\nThe flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags.  The optional timelimit argument specifies a rough upper bound on the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation.\n\nplan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar but produce plans that perform the equivalent of the inverse transforms ifft and so on.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.plan_ifft",
    "page": "Matemáticas",
    "title": "Base.DFT.plan_ifft",
    "category": "Function",
    "text": "plan_ifft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)\n\nSame as plan_fft, but produces a plan that performs inverse transforms ifft.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.plan_bfft",
    "page": "Matemáticas",
    "title": "Base.DFT.plan_bfft",
    "category": "Function",
    "text": "plan_bfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)\n\nSame as plan_fft, but produces a plan that performs an unnormalized backwards transform bfft.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.plan_fft!",
    "page": "Matemáticas",
    "title": "Base.DFT.plan_fft!",
    "category": "Function",
    "text": "plan_fft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)\n\nSame as plan_fft, but operates in-place on A.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.plan_ifft!",
    "page": "Matemáticas",
    "title": "Base.DFT.plan_ifft!",
    "category": "Function",
    "text": "plan_ifft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)\n\nSame as plan_ifft, but operates in-place on A.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.plan_bfft!",
    "page": "Matemáticas",
    "title": "Base.DFT.plan_bfft!",
    "category": "Function",
    "text": "plan_bfft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)\n\nSame as plan_bfft, but operates in-place on A.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.rfft",
    "page": "Matemáticas",
    "title": "Base.DFT.rfft",
    "category": "Function",
    "text": "rfft(A [, dims])\n\nMultidimensional FFT of a real array A, exploiting the fact that the transform has conjugate symmetry in order to save roughly half the computational time and storage costs compared with fft. If A has size (n_1, ..., n_d), the result has size (div(n_1,2)+1, ..., n_d).\n\nThe optional dims argument specifies an iterable subset of one or more dimensions of A to transform, similar to fft. Instead of (roughly) halving the first dimension of A in the result, the dims[1] dimension is (roughly) halved in the same way.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.irfft",
    "page": "Matemáticas",
    "title": "Base.DFT.irfft",
    "category": "Function",
    "text": "irfft(A, d [, dims])\n\nInverse of rfft: for a complex array A, gives the corresponding real array whose FFT yields A in the first half. As for rfft, dims is an optional subset of dimensions to transform, defaulting to 1:ndims(A).\n\nd is the length of the transformed real array along the dims[1] dimension, which must satisfy div(d,2)+1 == size(A,dims[1]). (This parameter cannot be inferred from size(A) since both 2*size(A,dims[1])-2 as well as 2*size(A,dims[1])-1 are valid sizes for the transformed real array.)\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.brfft",
    "page": "Matemáticas",
    "title": "Base.DFT.brfft",
    "category": "Function",
    "text": "brfft(A, d [, dims])\n\nSimilar to irfft but computes an unnormalized inverse transform (similar to bfft), which must be divided by the product of the sizes of the transformed dimensions (of the real output array) in order to obtain the inverse transform.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.plan_rfft",
    "page": "Matemáticas",
    "title": "Base.DFT.plan_rfft",
    "category": "Function",
    "text": "plan_rfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)\n\nPre-plan an optimized real-input FFT, similar to plan_fft except for rfft instead of fft. The first two arguments, and the size of the transformed result, are the same as for rfft.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.plan_brfft",
    "page": "Matemáticas",
    "title": "Base.DFT.plan_brfft",
    "category": "Function",
    "text": "plan_brfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)\n\nPre-plan an optimized real-input unnormalized transform, similar to plan_rfft except for brfft instead of rfft. The first two arguments and the size of the transformed result, are the same as for brfft.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.plan_irfft",
    "page": "Matemáticas",
    "title": "Base.DFT.plan_irfft",
    "category": "Function",
    "text": "plan_irfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)\n\nPre-plan an optimized inverse real-input FFT, similar to plan_rfft except for irfft and brfft, respectively. The first three arguments have the same meaning as for irfft.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.dct",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.dct",
    "category": "Function",
    "text": "dct(A [, dims])\n\nPerforms a multidimensional type-II discrete cosine transform (DCT) of the array A, using the unitary normalization of the DCT. The optional dims argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along.  Most efficient if the size of A along the transformed dimensions is a product of small primes; see nextprod. See also plan_dct for even greater efficiency.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.dct!",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.dct!",
    "category": "Function",
    "text": "dct!(A [, dims])\n\nSame as dct!, except that it operates in-place on A, which must be an array of real or complex floating-point values.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.idct",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.idct",
    "category": "Function",
    "text": "idct(A [, dims])\n\nComputes the multidimensional inverse discrete cosine transform (DCT) of the array A (technically, a type-III DCT with the unitary normalization). The optional dims argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along.  Most efficient if the size of A along the transformed dimensions is a product of small primes; see nextprod.  See also plan_idct for even greater efficiency.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.idct!",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.idct!",
    "category": "Function",
    "text": "idct!(A [, dims])\n\nSame as idct!, but operates in-place on A.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.plan_dct",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.plan_dct",
    "category": "Function",
    "text": "plan_dct(A [, dims [, flags [, timelimit]]])\n\nPre-plan an optimized discrete cosine transform (DCT), similar to plan_fft except producing a function that computes dct. The first two arguments have the same meaning as for dct.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.plan_dct!",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.plan_dct!",
    "category": "Function",
    "text": "plan_dct!(A [, dims [, flags [, timelimit]]])\n\nSame as plan_dct, but operates in-place on A.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.plan_idct",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.plan_idct",
    "category": "Function",
    "text": "plan_idct(A [, dims [, flags [, timelimit]]])\n\nPre-plan an optimized inverse discrete cosine transform (DCT), similar to plan_fft except producing a function that computes idct. The first two arguments have the same meaning as for idct.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.plan_idct!",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.plan_idct!",
    "category": "Function",
    "text": "plan_idct!(A [, dims [, flags [, timelimit]]])\n\nSame as plan_idct, but operates in-place on A.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.fftshift-Tuple{Any}",
    "page": "Matemáticas",
    "title": "Base.DFT.fftshift",
    "category": "Method",
    "text": "fftshift(x)\n\nSwap the first and second halves of each dimension of x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.fftshift-Tuple{Any,Any}",
    "page": "Matemáticas",
    "title": "Base.DFT.fftshift",
    "category": "Method",
    "text": "fftshift(x,dim)\n\nSwap the first and second halves of the given dimension or iterable of dimensions of array x.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.ifftshift",
    "page": "Matemáticas",
    "title": "Base.DFT.ifftshift",
    "category": "Function",
    "text": "ifftshift(x, [dim])\n\nUndoes the effect of fftshift.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DSP.filt",
    "page": "Matemáticas",
    "title": "Base.DSP.filt",
    "category": "Function",
    "text": "filt(b, a, x, [si])\n\nApply filter described by vectors a and b to vector x, with an optional initial filter state vector si (defaults to zeros).\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DSP.filt!",
    "page": "Matemáticas",
    "title": "Base.DSP.filt!",
    "category": "Function",
    "text": "filt!(out, b, a, x, [si])\n\nSame as filt but writes the result into the out argument, which may alias the input x to modify it in-place.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DSP.deconv",
    "page": "Matemáticas",
    "title": "Base.DSP.deconv",
    "category": "Function",
    "text": "deconv(b,a) -> c\n\nConstruct vector c such that b = conv(a,c) + r. Equivalent to polynomial division.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DSP.conv",
    "page": "Matemáticas",
    "title": "Base.DSP.conv",
    "category": "Function",
    "text": "conv(u,v)\n\nConvolution of two vectors. Uses FFT algorithm.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DSP.conv2",
    "page": "Matemáticas",
    "title": "Base.DSP.conv2",
    "category": "Function",
    "text": "conv2(u,v,A)\n\n2-D convolution of the matrix A with the 2-D separable kernel generated by the vectors u and v. Uses 2-D FFT algorithm.\n\n\n\nconv2(B,A)\n\n2-D convolution of the matrix B with the matrix A. Uses 2-D FFT algorithm.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DSP.xcorr",
    "page": "Matemáticas",
    "title": "Base.DSP.xcorr",
    "category": "Function",
    "text": "xcorr(u,v)\n\nCompute the cross-correlation of two vectors.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.r2r",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.r2r",
    "category": "Function",
    "text": "r2r(A, kind [, dims])\n\nPerforms a multidimensional real-input/real-output (r2r) transform of type kind of the array A, as defined in the FFTW manual. kind specifies either a discrete cosine transform of various types (FFTW.REDFT00, FFTW.REDFT01, FFTW.REDFT10, or FFTW.REDFT11), a discrete sine transform of various types (FFTW.RODFT00, FFTW.RODFT01, FFTW.RODFT10, or FFTW.RODFT11), a real-input DFT with halfcomplex-format output (FFTW.R2HC and its inverse FFTW.HC2R), or a discrete Hartley transform (FFTW.DHT).  The kind argument may be an array or tuple in order to specify different transform types along the different dimensions of A; kind[end] is used for any unspecified dimensions.  See the FFTW manual for precise definitions of these transform types, at http://www.fftw.org/doc.\n\nThe optional dims argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. kind[i] is then the transform type for dims[i], with kind[end] being used for i > length(kind).\n\nSee also plan_r2r to pre-plan optimized r2r transforms.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.r2r!",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.r2r!",
    "category": "Function",
    "text": "r2r!(A, kind [, dims])\n\nSame as r2r, but operates in-place on A, which must be an array of real or complex floating-point numbers.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.plan_r2r",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.plan_r2r",
    "category": "Function",
    "text": "plan_r2r(A, kind [, dims [, flags [, timelimit]]])\n\nPre-plan an optimized r2r transform, similar to plan_fft except that the transforms (and the first three arguments) correspond to r2r and r2r!, respectively.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Base.DFT.FFTW.plan_r2r!",
    "page": "Matemáticas",
    "title": "Base.DFT.FFTW.plan_r2r!",
    "category": "Function",
    "text": "plan_r2r!(A, kind [, dims [, flags [, timelimit]]])\n\nSimilar to plan_fft, but corresponds to r2r!.\n\n\n\n"
},

{
    "location": "stdlib/math.html#Procesamiento-de-Señales-1",
    "page": "Matemáticas",
    "title": "Procesamiento de Señales",
    "category": "section",
    "text": "Las funciones de transformada rápida de Fourier (Fast Fourier transform – FFT) en Julia están implementadas mediante llamadas a funciones de la librería FFTW.Base.DFT.fft\nBase.DFT.fft!\nBase.DFT.ifft\nBase.DFT.ifft!\nBase.DFT.bfft\nBase.DFT.bfft!\nBase.DFT.plan_fft\nBase.DFT.plan_ifft\nBase.DFT.plan_bfft\nBase.DFT.plan_fft!\nBase.DFT.plan_ifft!\nBase.DFT.plan_bfft!\nBase.DFT.rfft\nBase.DFT.irfft\nBase.DFT.brfft\nBase.DFT.plan_rfft\nBase.DFT.plan_brfft\nBase.DFT.plan_irfft\nBase.DFT.FFTW.dct\nBase.DFT.FFTW.dct!\nBase.DFT.FFTW.idct\nBase.DFT.FFTW.idct!\nBase.DFT.FFTW.plan_dct\nBase.DFT.FFTW.plan_dct!\nBase.DFT.FFTW.plan_idct\nBase.DFT.FFTW.plan_idct!\nBase.DFT.fftshift(::Any)\nBase.DFT.fftshift(::Any, ::Any)\nBase.DFT.ifftshift\nBase.DSP.filt\nBase.DSP.filt!\nBase.DSP.deconv\nBase.DSP.conv\nBase.DSP.conv2\nBase.DSP.xcorrLas siguientes funciones están definidas dentro del módulo Base.FFTW.Base.DFT.FFTW.r2r\nBase.DFT.FFTW.r2r!\nBase.DFT.FFTW.plan_r2r\nBase.DFT.FFTW.plan_r2r!"
},

{
    "location": "stdlib/numbers.html#",
    "page": "Números",
    "title": "Números",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/numbers.html#lib-numbers-1",
    "page": "Números",
    "title": "Números",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/numbers.html#Tipos-Numéricos-Estándar-1",
    "page": "Números",
    "title": "Tipos Numéricos Estándar",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/numbers.html#Core.Number",
    "page": "Números",
    "title": "Core.Number",
    "category": "Type",
    "text": "Number\n\nAbstract supertype for all number types.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Real",
    "page": "Números",
    "title": "Core.Real",
    "category": "Type",
    "text": "Real <: Number\n\nAbstract supertype for all real numbers.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.AbstractFloat",
    "page": "Números",
    "title": "Core.AbstractFloat",
    "category": "Type",
    "text": "AbstractFloat <: Real\n\nAbstract supertype for all floating point numbers.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Integer",
    "page": "Números",
    "title": "Core.Integer",
    "category": "Type",
    "text": "Integer <: Real\n\nAbstract supertype for all integers.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Signed",
    "page": "Números",
    "title": "Core.Signed",
    "category": "Type",
    "text": "Signed <: Integer\n\nAbstract supertype for all signed integers.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Unsigned",
    "page": "Números",
    "title": "Core.Unsigned",
    "category": "Type",
    "text": "Unsigned <: Integer\n\nAbstract supertype for all unsigned integers.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Tipos-Numéricos-Abstractos-1",
    "page": "Números",
    "title": "Tipos Numéricos Abstractos",
    "category": "section",
    "text": "Core.Number\nCore.Real\nCore.AbstractFloat\nCore.Integer\nCore.Signed\nCore.Unsigned"
},

{
    "location": "stdlib/numbers.html#Core.Float16",
    "page": "Números",
    "title": "Core.Float16",
    "category": "Type",
    "text": "Float16 <: AbstractFloat\n\n16-bit floating point number type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Float32",
    "page": "Números",
    "title": "Core.Float32",
    "category": "Type",
    "text": "Float32 <: AbstractFloat\n\n32-bit floating point number type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Float64",
    "page": "Números",
    "title": "Core.Float64",
    "category": "Type",
    "text": "Float64 <: AbstractFloat\n\n64-bit floating point number type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.MPFR.BigFloat",
    "page": "Números",
    "title": "Base.MPFR.BigFloat",
    "category": "Type",
    "text": "BigFloat <: AbstractFloat\n\nArbitrary precision floating point number type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Bool",
    "page": "Números",
    "title": "Core.Bool",
    "category": "Type",
    "text": "Bool <: Integer\n\nBoolean type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Int8",
    "page": "Números",
    "title": "Core.Int8",
    "category": "Type",
    "text": "Int8 <: Signed\n\n8-bit signed integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.UInt8",
    "page": "Números",
    "title": "Core.UInt8",
    "category": "Type",
    "text": "UInt8 <: Unsigned\n\n8-bit unsigned integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Int16",
    "page": "Números",
    "title": "Core.Int16",
    "category": "Type",
    "text": "Int16 <: Signed\n\n16-bit signed integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.UInt16",
    "page": "Números",
    "title": "Core.UInt16",
    "category": "Type",
    "text": "UInt16 <: Unsigned\n\n16-bit unsigned integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Int32",
    "page": "Números",
    "title": "Core.Int32",
    "category": "Type",
    "text": "Int32 <: Signed\n\n32-bit signed integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.UInt32",
    "page": "Números",
    "title": "Core.UInt32",
    "category": "Type",
    "text": "UInt32 <: Unsigned\n\n32-bit unsigned integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Int64",
    "page": "Números",
    "title": "Core.Int64",
    "category": "Type",
    "text": "Int64 <: Signed\n\n64-bit signed integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.UInt64",
    "page": "Números",
    "title": "Core.UInt64",
    "category": "Type",
    "text": "UInt64 <: Unsigned\n\n64-bit unsigned integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Int128",
    "page": "Números",
    "title": "Core.Int128",
    "category": "Type",
    "text": "Int128 <: Signed\n\n128-bit signed integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.UInt128",
    "page": "Números",
    "title": "Core.UInt128",
    "category": "Type",
    "text": "UInt128 <: Unsigned\n\n128-bit unsigned integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.GMP.BigInt",
    "page": "Números",
    "title": "Base.GMP.BigInt",
    "category": "Type",
    "text": "BigInt <: Integer\n\nArbitrary precision integer type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Complex",
    "page": "Números",
    "title": "Base.Complex",
    "category": "Type",
    "text": "Complex{T<:Real} <: Number\n\nComplex number type with real and imaginary part of type T.\n\nComplex32, Complex64 and Complex128 are aliases for Complex{Float16}, Complex{Float32} and Complex{Float64} respectively.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Rational",
    "page": "Números",
    "title": "Base.Rational",
    "category": "Type",
    "text": "Rational{T<:Integer} <: Real\n\nRational number type, with numerator and denominator of type T.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Irrational",
    "page": "Números",
    "title": "Base.Irrational",
    "category": "Type",
    "text": "Irrational <: Real\n\nIrrational number type.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Tipos-Numéricos-Concretos-1",
    "page": "Números",
    "title": "Tipos Numéricos Concretos",
    "category": "section",
    "text": "Core.Float16\nCore.Float32\nCore.Float64\nBase.BigFloat\nCore.Bool\nCore.Int8\nCore.UInt8\nCore.Int16\nCore.UInt16\nCore.Int32\nCore.UInt32\nCore.Int64\nCore.UInt64\nCore.Int128\nCore.UInt128\nBase.BigInt\nBase.Complex\nBase.Rational\nBase.Irrational"
},

{
    "location": "stdlib/numbers.html#Base.bin",
    "page": "Números",
    "title": "Base.bin",
    "category": "Function",
    "text": "bin(n, pad::Int=1)\n\nConvert an integer to a binary string, optionally specifying a number of digits to pad to.\n\njulia> bin(10,2)\n\"1010\"\n\njulia> bin(10,8)\n\"00001010\"\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.hex",
    "page": "Números",
    "title": "Base.hex",
    "category": "Function",
    "text": "hex(n, pad::Int=1)\n\nConvert an integer to a hexadecimal string, optionally specifying a number of digits to pad to.\n\njulia> hex(20)\n\"14\"\n\njulia> hex(20, 3)\n\"014\"\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.dec",
    "page": "Números",
    "title": "Base.dec",
    "category": "Function",
    "text": "dec(n, pad::Int=1)\n\nConvert an integer to a decimal string, optionally specifying a number of digits to pad to.\n\nExamples\n\njulia> dec(20)\n\"20\"\n\njulia> dec(20, 3)\n\"020\"\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.oct",
    "page": "Números",
    "title": "Base.oct",
    "category": "Function",
    "text": "oct(n, pad::Int=1)\n\nConvert an integer to an octal string, optionally specifying a number of digits to pad to.\n\njulia> oct(20)\n\"24\"\n\njulia> oct(20, 3)\n\"024\"\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.base",
    "page": "Números",
    "title": "Base.base",
    "category": "Function",
    "text": "base(base::Integer, n::Integer, pad::Integer=1)\n\nConvert an integer n to a string in the given base, optionally specifying a number of digits to pad to.\n\njulia> base(13,5,4)\n\"0005\"\n\njulia> base(5,13,4)\n\"0023\"\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.digits",
    "page": "Números",
    "title": "Base.digits",
    "category": "Function",
    "text": "digits([T<:Integer], n::Integer, base::T=10, pad::Integer=1)\n\nReturns an array with element type T (default Int) of the digits of n in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indexes, such that n == sum([digits[k]*base^(k-1) for k=1:length(digits)]).\n\nExamples\n\njulia> digits(10, 10)\n2-element Array{Int64,1}:\n 0\n 1\n\njulia> digits(10, 2)\n4-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n\njulia> digits(10, 2, 6)\n6-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.digits!",
    "page": "Números",
    "title": "Base.digits!",
    "category": "Function",
    "text": "digits!(array, n::Integer, base::Integer=10)\n\nFills an array of the digits of n in the given base. More significant digits are at higher indexes. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.\n\nExamples\n\njulia> digits!([2,2,2,2], 10, 2)\n4-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n\njulia> digits!([2,2,2,2,2,2], 10, 2)\n6-element Array{Int64,1}:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.bits",
    "page": "Números",
    "title": "Base.bits",
    "category": "Function",
    "text": "bits(n)\n\nA string giving the literal bit representation of a number.\n\nExample\n\njulia> bits(4)\n\"0000000000000000000000000000000000000000000000000000000000000100\"\n\njulia> bits(2.2)\n\"0100000000000001100110011001100110011001100110011001100110011010\"\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.parse-Tuple{Type,Any,Any}",
    "page": "Números",
    "title": "Base.parse",
    "category": "Method",
    "text": "parse(type, str, [base])\n\nParse a string as a number. If the type is an integer type, then a base can be specified (the default is 10). If the type is a floating point type, the string is parsed as a decimal floating point number. If the string does not contain a valid number, an error is raised.\n\njulia> parse(Int, \"1234\")\n1234\n\njulia> parse(Int, \"1234\", 5)\n194\n\njulia> parse(Int, \"afc\", 16)\n2812\n\njulia> parse(Float64, \"1.2e-3\")\n0.0012\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.tryparse",
    "page": "Números",
    "title": "Base.tryparse",
    "category": "Function",
    "text": "tryparse(type, str, [base])\n\nLike parse, but returns a Nullable of the requested type. The result will be null if the string does not contain a valid number.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.big",
    "page": "Números",
    "title": "Base.big",
    "category": "Function",
    "text": "big(x)\n\nConvert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about some pitfalls with floating-point numbers.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.signed",
    "page": "Números",
    "title": "Base.signed",
    "category": "Function",
    "text": "signed(x)\n\nConvert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.unsigned",
    "page": "Números",
    "title": "Base.unsigned",
    "category": "Function",
    "text": "unsigned(x) -> Unsigned\n\nConvert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.\n\nExamples\n\njulia> unsigned(-2)\n0xfffffffffffffffe\n\njulia> unsigned(2)\n0x0000000000000002\n\njulia> signed(unsigned(-2))\n-2\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.float-Tuple{Any}",
    "page": "Números",
    "title": "Base.float",
    "category": "Method",
    "text": "float(x)\n\nConvert a number or array to a floating point data type. When passed a string, this function is equivalent to parse(Float64, x).\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Math.significand",
    "page": "Números",
    "title": "Base.Math.significand",
    "category": "Function",
    "text": "significand(x)\n\nExtract the significand(s) (a.k.a. mantissa), in binary representation, of a floating-point number. If x is a non-zero finite number, then the result will be a number of the same type on the interval 12). Otherwise x is returned.\n\nExamples\n\njulia> significand(15.2)/15.2\n0.125\n\njulia> significand(15.2)*8\n15.2\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Math.exponent",
    "page": "Números",
    "title": "Base.Math.exponent",
    "category": "Function",
    "text": "exponent(x) -> Int\n\nGet the exponent of a normalized floating-point number.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.complex-Tuple{Complex}",
    "page": "Números",
    "title": "Base.complex",
    "category": "Method",
    "text": "complex(r, [i])\n\nConvert real numbers or arrays to complex. i defaults to zero.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.bswap",
    "page": "Números",
    "title": "Base.bswap",
    "category": "Function",
    "text": "bswap(n)\n\nByte-swap an integer. Flip the bits of its binary representation.\n\nExamples\n\njulia> a = bswap(4)\n288230376151711744\n\njulia> bswap(a)\n4\n\njulia> bin(1)\n\"1\"\n\njulia> bin(bswap(1))\n\"100000000000000000000000000000000000000000000000000000000\"\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.num2hex",
    "page": "Números",
    "title": "Base.num2hex",
    "category": "Function",
    "text": "num2hex(f)\n\nGet a hexadecimal string of the binary representation of a floating point number.\n\nExample\n\njulia> num2hex(2.2)\n\"400199999999999a\"\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.hex2num",
    "page": "Números",
    "title": "Base.hex2num",
    "category": "Function",
    "text": "hex2num(str)\n\nConvert a hexadecimal string to the floating point number it represents.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.hex2bytes",
    "page": "Números",
    "title": "Base.hex2bytes",
    "category": "Function",
    "text": "hex2bytes(s::AbstractString)\n\nConvert an arbitrarily long hexadecimal string to its binary representation. Returns an Array{UInt8,1}, i.e. an array of bytes.\n\njulia> a = hex(12345)\n\"3039\"\n\njulia> hex2bytes(a)\n2-element Array{UInt8,1}:\n 0x30\n 0x39\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.bytes2hex",
    "page": "Números",
    "title": "Base.bytes2hex",
    "category": "Function",
    "text": "bytes2hex(bin_arr::Array{UInt8, 1}) -> String\n\nConvert an array of bytes to its hexadecimal representation. All characters are in lower-case.\n\njulia> a = hex(12345)\n\"3039\"\n\njulia> b = hex2bytes(a)\n2-element Array{UInt8,1}:\n 0x30\n 0x39\n\njulia> bytes2hex(b)\n\"3039\"\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Formatos-de-Datos-1",
    "page": "Números",
    "title": "Formatos de Datos",
    "category": "section",
    "text": "Base.bin\nBase.hex\nBase.dec\nBase.oct\nBase.base\nBase.digits\nBase.digits!\nBase.bits\nBase.parse(::Type, ::Any, ::Any)\nBase.tryparse\nBase.big\nBase.signed\nBase.unsigned\nBase.float(::Any)\nBase.Math.significand\nBase.Math.exponent\nBase.complex(::Complex)\nBase.bswap\nBase.num2hex\nBase.hex2num\nBase.hex2bytes\nBase.bytes2hex"
},

{
    "location": "stdlib/numbers.html#Base.one",
    "page": "Números",
    "title": "Base.one",
    "category": "Function",
    "text": "one(x)\none(T::type)\n\nReturn a multiplicative identity for x: a value such that one(x)*x == x*one(x) == x.  Alternatively one(T) can take a type T, in which case one returns a multiplicative identity for any x of type T.\n\nIf possible, one(x) returns a value of the same type as x, and one(T) returns a value of type T.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, one(x) should return an identity value of the same precision (and shape, for matrices) as x.\n\nIf you want a quantity that is of the same type as x, or of type T, even if x is dimensionful, use oneunit instead.\n\njulia> one(3.7)\n1.0\n\njulia> one(Int)\n1\n\njulia> one(Dates.Day(1))\n1\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.oneunit",
    "page": "Números",
    "title": "Base.oneunit",
    "category": "Function",
    "text": "oneunit(x::T)\noneunit(T::Type)\n\nReturns T(one(x)), where T is either the type of the argument or (if a type is passed) the argument.  This differs from one for dimensionful quantities: one is dimensionless (a multiplicative identity) while oneunit is dimensionful (of the same type as x, or of type T).\n\njulia> oneunit(3.7)\n1.0\n\njulia> oneunit(Dates.Day)\n1 day\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.zero",
    "page": "Números",
    "title": "Base.zero",
    "category": "Function",
    "text": "zero(x)\n\nGet the additive identity element for the type of x (x can also specify the type itself).\n\njulia> zero(1)\n0\n\njulia> zero(big\"2.0\")\n0.000000000000000000000000000000000000000000000000000000000000000000000000000000\n\njulia> zero(rand(2,2))\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.pi",
    "page": "Números",
    "title": "Base.pi",
    "category": "Constant",
    "text": "pi\nπ\n\nThe constant pi.\n\njulia> pi\nπ = 3.1415926535897...\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.im",
    "page": "Números",
    "title": "Base.im",
    "category": "Constant",
    "text": "im\n\nThe imaginary unit.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.eu",
    "page": "Números",
    "title": "Base.eu",
    "category": "Constant",
    "text": "e\neu\n\nThe constant e.\n\njulia> e\ne = 2.7182818284590...\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.catalan",
    "page": "Números",
    "title": "Base.catalan",
    "category": "Constant",
    "text": "catalan\n\nCatalan's constant.\n\njulia> catalan\ncatalan = 0.9159655941772...\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.eulergamma",
    "page": "Números",
    "title": "Base.eulergamma",
    "category": "Constant",
    "text": "γ\neulergamma\n\nEuler's constant.\n\njulia> eulergamma\nγ = 0.5772156649015...\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.golden",
    "page": "Números",
    "title": "Base.golden",
    "category": "Constant",
    "text": "φ\ngolden\n\nThe golden ratio.\n\njulia> golden\nφ = 1.6180339887498...\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Inf",
    "page": "Números",
    "title": "Base.Inf",
    "category": "Constant",
    "text": "Inf\n\nPositive infinity of type Float64.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Inf32",
    "page": "Números",
    "title": "Base.Inf32",
    "category": "Constant",
    "text": "Inf32\n\nPositive infinity of type Float32.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Inf16",
    "page": "Números",
    "title": "Base.Inf16",
    "category": "Constant",
    "text": "Inf16\n\nPositive infinity of type Float16.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.NaN",
    "page": "Números",
    "title": "Base.NaN",
    "category": "Constant",
    "text": "NaN\n\nA not-a-number value of type Float64.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.NaN32",
    "page": "Números",
    "title": "Base.NaN32",
    "category": "Constant",
    "text": "NaN32\n\nA not-a-number value of type Float32.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.NaN16",
    "page": "Números",
    "title": "Base.NaN16",
    "category": "Constant",
    "text": "NaN16\n\nA not-a-number value of type Float16.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.issubnormal",
    "page": "Números",
    "title": "Base.issubnormal",
    "category": "Function",
    "text": "issubnormal(f) -> Bool\n\nTest whether a floating point number is subnormal.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.isfinite",
    "page": "Números",
    "title": "Base.isfinite",
    "category": "Function",
    "text": "isfinite(f) -> Bool\n\nTest whether a number is finite.\n\njulia> isfinite(5)\ntrue\n\njulia> isfinite(NaN32)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.isinf",
    "page": "Números",
    "title": "Base.isinf",
    "category": "Function",
    "text": "isinf(f) -> Bool\n\nTest whether a number is infinite.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.isnan",
    "page": "Números",
    "title": "Base.isnan",
    "category": "Function",
    "text": "isnan(f) -> Bool\n\nTest whether a floating point number is not a number (NaN).\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.iszero",
    "page": "Números",
    "title": "Base.iszero",
    "category": "Function",
    "text": "iszero(x)\n\nReturn true if x == zero(x); if x is an array, this checks whether all of the elements of x are zero.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.nextfloat",
    "page": "Números",
    "title": "Base.nextfloat",
    "category": "Function",
    "text": "nextfloat(x::AbstractFloat, n::Integer)\n\nThe result of n iterative applications of nextfloat to x if n >= 0, or -n applications of prevfloat if n < 0.\n\n\n\nnextfloat(x::AbstractFloat)\n\nReturns the smallest floating point number y of the same type as x such x < y. If no such y exists (e.g. if x is Inf or NaN), then returns x.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.prevfloat",
    "page": "Números",
    "title": "Base.prevfloat",
    "category": "Function",
    "text": "prevfloat(x::AbstractFloat)\n\nReturns the largest floating point number y of the same type as x such y < x. If no such y exists (e.g. if x is -Inf or NaN), then returns x.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.isinteger",
    "page": "Números",
    "title": "Base.isinteger",
    "category": "Function",
    "text": "isinteger(x) -> Bool\n\nTest whether x is numerically equal to some integer.\n\njulia> isinteger(4.0)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.isreal",
    "page": "Números",
    "title": "Base.isreal",
    "category": "Function",
    "text": "isreal(x) -> Bool\n\nTest whether x or all its elements are numerically equal to some real number.\n\njulia> isreal(5.)\ntrue\n\njulia> isreal([4.; complex(0,1)])\nfalse\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Float32-Tuple{Any}",
    "page": "Números",
    "title": "Core.Float32",
    "category": "Method",
    "text": "Float32(x [, mode::RoundingMode])\n\nCreate a Float32 from x. If x is not exactly representable then mode determines how x is rounded.\n\nExamples\n\njulia> Float32(1/3, RoundDown)\n0.3333333f0\n\njulia> Float32(1/3, RoundUp)\n0.33333334f0\n\nSee RoundingMode for available rounding modes.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Core.Float64-Tuple{Any}",
    "page": "Números",
    "title": "Core.Float64",
    "category": "Method",
    "text": "Float64(x [, mode::RoundingMode])\n\nCreate a Float64 from x. If x is not exactly representable then mode determines how x is rounded.\n\nExamples\n\njulia> Float64(pi, RoundDown)\n3.141592653589793\n\njulia> Float64(pi, RoundUp)\n3.1415926535897936\n\nSee RoundingMode for available rounding modes.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.GMP.BigInt-Tuple{Any}",
    "page": "Números",
    "title": "Base.GMP.BigInt",
    "category": "Method",
    "text": "BigInt(x)\n\nCreate an arbitrary precision integer. x may be an Int (or anything that can be converted to an Int). The usual mathematical operators are defined for this type, and results are promoted to a BigInt.\n\nInstances can be constructed from strings via parse, or using the big string literal.\n\njulia> parse(BigInt, \"42\")\n42\n\njulia> big\"313\"\n313\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.MPFR.BigFloat-Tuple{Any}",
    "page": "Números",
    "title": "Base.MPFR.BigFloat",
    "category": "Method",
    "text": "BigFloat(x)\n\nCreate an arbitrary precision floating point number. x may be an Integer, a Float64 or a BigInt. The usual mathematical operators are defined for this type, and results are promoted to a BigFloat.\n\nNote that because decimal literals are converted to floating point numbers when parsed, BigFloat(2.1) may not yield what you expect. You may instead prefer to initialize constants from strings via parse, or using the big string literal.\n\njulia> BigFloat(2.1)\n2.100000000000000088817841970012523233890533447265625000000000000000000000000000\n\njulia> big\"2.1\"\n2.099999999999999999999999999999999999999999999999999999999999999999999999999986\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Rounding.rounding",
    "page": "Números",
    "title": "Base.Rounding.rounding",
    "category": "Function",
    "text": "rounding(T)\n\nGet the current floating point rounding mode for type T, controlling the rounding of basic arithmetic functions (+, -, *, / and sqrt) and type conversion.\n\nSee RoundingMode for available modes.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Rounding.setrounding-Tuple{Type,Any}",
    "page": "Números",
    "title": "Base.Rounding.setrounding",
    "category": "Method",
    "text": "setrounding(T, mode)\n\nSet the rounding mode of floating point type T, controlling the rounding of basic arithmetic functions (+, -, *, / and sqrt) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default RoundNearest.\n\nNote that this may affect other types, for instance changing the rounding mode of Float64 will change the rounding mode of Float32. See RoundingMode for available modes.\n\nwarning: Warning\nThis feature is still experimental, and may give unexpected or incorrect values.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Rounding.setrounding-Tuple{Function,Type,RoundingMode}",
    "page": "Números",
    "title": "Base.Rounding.setrounding",
    "category": "Method",
    "text": "setrounding(f::Function, T, mode)\n\nChange the rounding mode of floating point type T for the duration of f. It is logically equivalent to:\n\nold = rounding(T)\nsetrounding(T, mode)\nf()\nsetrounding(T, old)\n\nSee RoundingMode for available rounding modes.\n\nwarning: Warning\nThis feature is still experimental, and may give unexpected or incorrect values. A known problem is the interaction with compiler optimisations, e.g.julia> setrounding(Float64,RoundDown) do\n           1.1 + 0.1\n       end\n1.2000000000000002Here the compiler is constant folding, that is evaluating a known constant expression at compile time, however the rounding mode is only changed at runtime, so this is not reflected in the function result. This can be avoided by moving constants outside the expression, e.g.julia> x = 1.1; y = 0.1;\n\njulia> setrounding(Float64,RoundDown) do\n           x + y\n       end\n1.2\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Rounding.get_zero_subnormals",
    "page": "Números",
    "title": "Base.Rounding.get_zero_subnormals",
    "category": "Function",
    "text": "get_zero_subnormals() -> Bool\n\nReturns false if operations on subnormal floating-point values (\"denormals\") obey rules for IEEE arithmetic, and true if they might be converted to zeros.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Rounding.set_zero_subnormals",
    "page": "Números",
    "title": "Base.Rounding.set_zero_subnormals",
    "category": "Function",
    "text": "set_zero_subnormals(yes::Bool) -> Bool\n\nIf yes is false, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (\"denormals\"). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns true unless yes==true but the hardware does not support zeroing of subnormal numbers.\n\nset_zero_subnormals(true) can speed up some computations on some hardware. However, it can break identities such as (x-y==0) == (x==y).\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Constantes-y-Funciones-de-Números-Generales-1",
    "page": "Números",
    "title": "Constantes y Funciones de Números Generales",
    "category": "section",
    "text": "Base.one\nBase.oneunit\nBase.zero\nBase.pi\nBase.im\nBase.eu\nBase.catalan\nBase.eulergamma\nBase.golden\nBase.Inf\nBase.Inf32\nBase.Inf16\nBase.NaN\nBase.NaN32\nBase.NaN16\nBase.issubnormal\nBase.isfinite\nBase.isinf\nBase.isnan\nBase.iszero\nBase.nextfloat\nBase.prevfloat\nBase.isinteger\nBase.isreal\nCore.Float32(::Any)\nCore.Float64(::Any)\nBase.GMP.BigInt(::Any)\nBase.MPFR.BigFloat(::Any)\nBase.Rounding.rounding\nBase.Rounding.setrounding(::Type, ::Any)\nBase.Rounding.setrounding(::Function, ::Type, ::RoundingMode)\nBase.Rounding.get_zero_subnormals\nBase.Rounding.set_zero_subnormals"
},

{
    "location": "stdlib/numbers.html#Base.count_ones",
    "page": "Números",
    "title": "Base.count_ones",
    "category": "Function",
    "text": "count_ones(x::Integer) -> Integer\n\nNumber of ones in the binary representation of x.\n\njulia> count_ones(7)\n3\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.count_zeros",
    "page": "Números",
    "title": "Base.count_zeros",
    "category": "Function",
    "text": "count_zeros(x::Integer) -> Integer\n\nNumber of zeros in the binary representation of x.\n\njulia> count_zeros(Int32(2 ^ 16 - 1))\n16\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.leading_zeros",
    "page": "Números",
    "title": "Base.leading_zeros",
    "category": "Function",
    "text": "leading_zeros(x::Integer) -> Integer\n\nNumber of zeros leading the binary representation of x.\n\njulia> leading_zeros(Int32(1))\n31\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.leading_ones",
    "page": "Números",
    "title": "Base.leading_ones",
    "category": "Function",
    "text": "leading_ones(x::Integer) -> Integer\n\nNumber of ones leading the binary representation of x.\n\njulia> leading_ones(UInt32(2 ^ 32 - 2))\n31\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.trailing_zeros",
    "page": "Números",
    "title": "Base.trailing_zeros",
    "category": "Function",
    "text": "trailing_zeros(x::Integer) -> Integer\n\nNumber of zeros trailing the binary representation of x.\n\njulia> trailing_zeros(2)\n1\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.trailing_ones",
    "page": "Números",
    "title": "Base.trailing_ones",
    "category": "Function",
    "text": "trailing_ones(x::Integer) -> Integer\n\nNumber of ones trailing the binary representation of x.\n\njulia> trailing_ones(3)\n2\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.isodd",
    "page": "Números",
    "title": "Base.isodd",
    "category": "Function",
    "text": "isodd(x::Integer) -> Bool\n\nReturns true if x is odd (that is, not divisible by 2), and false otherwise.\n\njulia> isodd(9)\ntrue\n\njulia> isodd(10)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.iseven",
    "page": "Números",
    "title": "Base.iseven",
    "category": "Function",
    "text": "iseven(x::Integer) -> Bool\n\nReturns true is x is even (that is, divisible by 2), and false otherwise.\n\njulia> iseven(9)\nfalse\n\njulia> iseven(10)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Enteros-1",
    "page": "Números",
    "title": "Enteros",
    "category": "section",
    "text": "Base.count_ones\nBase.count_zeros\nBase.leading_zeros\nBase.leading_ones\nBase.trailing_zeros\nBase.trailing_ones\nBase.isodd\nBase.iseven"
},

{
    "location": "stdlib/numbers.html#Base.precision",
    "page": "Números",
    "title": "Base.precision",
    "category": "Function",
    "text": "precision(num::AbstractFloat)\n\nGet the precision of a floating point number, as defined by the effective number of bits in the mantissa.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.precision-Tuple{Type{BigFloat}}",
    "page": "Números",
    "title": "Base.precision",
    "category": "Method",
    "text": "precision(BigFloat)\n\nGet the precision (in bits) currently used for BigFloat arithmetic.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.MPFR.setprecision",
    "page": "Números",
    "title": "Base.MPFR.setprecision",
    "category": "Function",
    "text": "setprecision([T=BigFloat,] precision::Int)\n\nSet the precision (in bits) to be used for T arithmetic.\n\n\n\nsetprecision(f::Function, [T=BigFloat,] precision::Integer)\n\nChange the T arithmetic precision (in bits) for the duration of f. It is logically equivalent to:\n\nold = precision(BigFloat)\nsetprecision(BigFloat, precision)\nf()\nsetprecision(BigFloat, old)\n\nOften used as setprecision(T, precision) do ... end\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.MPFR.BigFloat-Tuple{Any,Int64}",
    "page": "Números",
    "title": "Base.MPFR.BigFloat",
    "category": "Method",
    "text": "BigFloat(x, prec::Int)\n\nCreate a representation of x as a BigFloat with precision prec.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.MPFR.BigFloat-Tuple{Union{AbstractFloat, Integer, String},RoundingMode}",
    "page": "Números",
    "title": "Base.MPFR.BigFloat",
    "category": "Method",
    "text": "BigFloat(x, rounding::RoundingMode)\n\nCreate a representation of x as a BigFloat with the current global precision and rounding mode rounding.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.MPFR.BigFloat-Tuple{Any,Int64,RoundingMode}",
    "page": "Números",
    "title": "Base.MPFR.BigFloat",
    "category": "Method",
    "text": "BigFloat(x, prec::Int, rounding::RoundingMode)\n\nCreate a representation of x as a BigFloat with precision prec and rounding mode rounding.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.MPFR.BigFloat-Tuple{String}",
    "page": "Números",
    "title": "Base.MPFR.BigFloat",
    "category": "Method",
    "text": "BigFloat(x::String)\n\nCreate a representation of the string x as a BigFloat.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#BigFloats-1",
    "page": "Números",
    "title": "BigFloats",
    "category": "section",
    "text": "El tipo BigFloat implementa el punto flotante de precisión arbitraria usando la librería GNU MPFR library.Base.precision\nBase.MPFR.precision(::Type{BigFloat})\nBase.MPFR.setprecision\nBase.MPFR.BigFloat(x, prec::Int)\nBigFloat(x::Union{Integer, AbstractFloat, String}, rounding::RoundingMode)\nBase.MPFR.BigFloat(x, prec::Int, rounding::RoundingMode)\nBase.MPFR.BigFloat(x::String)"
},

{
    "location": "stdlib/numbers.html#Base.Random.srand",
    "page": "Números",
    "title": "Base.Random.srand",
    "category": "Function",
    "text": "srand([rng=GLOBAL_RNG], [seed]) -> rng\nsrand([rng=GLOBAL_RNG], filename, n=4) -> rng\n\nReseed the random number generator. If a seed is provided, the RNG will give a reproducible sequence of numbers, otherwise Julia will get entropy from the system. For MersenneTwister, the seed may be a non-negative integer, a vector of UInt32 integers or a filename, in which case the seed is read from a file (4n bytes are read from the file, where n is an optional argument). RandomDevice does not support seeding.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.MersenneTwister",
    "page": "Números",
    "title": "Base.Random.MersenneTwister",
    "category": "Type",
    "text": "MersenneTwister(seed)\n\nCreate a MersenneTwister RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.RandomDevice",
    "page": "Números",
    "title": "Base.Random.RandomDevice",
    "category": "Type",
    "text": "RandomDevice()\n\nCreate a RandomDevice RNG object. Two such objects will always generate different streams of random numbers.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.rand",
    "page": "Números",
    "title": "Base.Random.rand",
    "category": "Function",
    "text": "rand([rng=GLOBAL_RNG], [S], [dims...])\n\nPick a random element or array of random elements from the set of values specified by S; S can be\n\nan indexable collection (for example 1:n or ['x','y','z']), or\na type: the set of values to pick from is then equivalent to typemin(S):typemax(S) for integers (this is not applicable to BigInt), and to 0 1) for floating point numbers;\n\nS defaults to Float64.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.rand!",
    "page": "Números",
    "title": "Base.Random.rand!",
    "category": "Function",
    "text": "rand!([rng=GLOBAL_RNG], A, [coll])\n\nPopulate the array A with random values. If the indexable collection coll is specified, the values are picked randomly from coll. This is equivalent to copy!(A, rand(rng, coll, size(A))) or copy!(A, rand(rng, eltype(A), size(A))) but without allocating a new array.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> rand!(rng, zeros(5))\n5-element Array{Float64,1}:\n 0.590845\n 0.766797\n 0.566237\n 0.460085\n 0.794026\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.bitrand",
    "page": "Números",
    "title": "Base.Random.bitrand",
    "category": "Function",
    "text": "bitrand([rng=GLOBAL_RNG], [dims...])\n\nGenerate a BitArray of random boolean values.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> bitrand(rng, 10)\n10-element BitArray{1}:\n  true\n  true\n  true\n false\n  true\n false\n false\n  true\n false\n  true\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.randn",
    "page": "Números",
    "title": "Base.Random.randn",
    "category": "Function",
    "text": "randn([rng=GLOBAL_RNG], [T=Float64], [dims...])\n\nGenerate a normally-distributed random number of type T with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The Base module currently provides an implementation for the types Float16, Float32, and Float64 (the default).\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> randn(rng, Float64)\n0.8673472019512456\n\njulia> randn(rng, Float32, (2, 4))\n2×4 Array{Float32,2}:\n -0.901744  -0.902914  2.21188   -0.271735\n -0.494479   0.864401  0.532813   0.502334\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.randn!",
    "page": "Números",
    "title": "Base.Random.randn!",
    "category": "Function",
    "text": "randn!([rng=GLOBAL_RNG], A::AbstractArray) -> A\n\nFill the array A with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the rand function.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> randn!(rng, zeros(5))\n5-element Array{Float64,1}:\n  0.867347\n -0.901744\n -0.494479\n -0.902914\n  0.864401\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.randexp",
    "page": "Números",
    "title": "Base.Random.randexp",
    "category": "Function",
    "text": "randexp([rng=GLOBAL_RNG], [T=Float64], [dims...])\n\nGenerate a random number of type T according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The Base module currently provides an implementation for the types Float16, Float32, and Float64 (the default).\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> randexp(rng, Float32)\n2.4835055f0\n\njulia> randexp(rng, 3, 3)\n3×3 Array{Float64,2}:\n 1.5167    1.30652   0.344435\n 0.604436  2.78029   0.418516\n 0.695867  0.693292  0.643644\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.randexp!",
    "page": "Números",
    "title": "Base.Random.randexp!",
    "category": "Function",
    "text": "randexp!([rng=GLOBAL_RNG], A::AbstractArray) -> A\n\nFill the array A with random numbers following the exponential distribution (with scale 1).\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> randexp!(rng, zeros(5))\n5-element Array{Float64,1}:\n 2.48351\n 1.5167\n 0.604436\n 0.695867\n 1.30652\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#Base.Random.randjump",
    "page": "Números",
    "title": "Base.Random.randjump",
    "category": "Function",
    "text": "randjump(r::MersenneTwister, jumps::Integer, [jumppoly::AbstractString=dSFMT.JPOLY1e21]) -> Vector{MersenneTwister}\n\nCreate an array of the size jumps of initialized MersenneTwister RNG objects. The first RNG object given as a parameter and following MersenneTwister RNGs in the array are initialized such that a state of the RNG object in the array would be moved forward (without generating numbers) from a previous RNG object array element on a particular number of steps encoded by the jump polynomial jumppoly.\n\nDefault jump polynomial moves forward MersenneTwister RNG state by 10^20 steps.\n\n\n\n"
},

{
    "location": "stdlib/numbers.html#random-numbers-1",
    "page": "Números",
    "title": "Números Aleatorios",
    "category": "section",
    "text": "La generación de números aleatorios en Julia utiliza la librería Mersenne Twister a través de objetos MersenneTwister. Julia tiene un RNG global que es usado por defecto. Pueden conectarse otros tipos RNG heredando del tipo AbstractRNG; estos pueden ser usados entonces para tener múltiples flujos de números aleatorios. Ademas de MersenneTwister, Julia proporciona el tipo RNG RandomDevice que es un wrapper sobre la entropía proporcionada por el SO.La mayoría de las funciones relacionadas con la generación aleatoria aceptan un AbstractRNG opcional como primer argumento,rng, que se predetermina al global si no se proporciona. Además, algunos de ellos aceptan opcionalmente especificaciones de dimensión dims ... (que pueden darse como una tupla) para generar matrices de valores aleatorios.Un RNG de tipo MersenneTwister o RandomDevice puede generar números aleatorios de los siguientes tipos: Float16, Float32, Float64, Bool, Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Int128, UInt128, BigInt (o números complejos de estos tipos). Los números aleatorios en punto flotante son generados uniformemente en 0 1). Como BigInt representa números sin límite, el intervalo debe ser especificado (por ejemplo, rand(big(1:6))).Base.Random.srand\nBase.Random.MersenneTwister\nBase.Random.RandomDevice\nBase.Random.rand\nBase.Random.rand!\nBase.Random.bitrand\nBase.Random.randn\nBase.Random.randn!\nBase.Random.randexp\nBase.Random.randexp!\nBase.Random.randjump"
},

{
    "location": "stdlib/strings.html#",
    "page": "Cadenas",
    "title": "Cadenas",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/strings.html#Base.length-Tuple{AbstractString}",
    "page": "Cadenas",
    "title": "Base.length",
    "category": "Method",
    "text": "length(s::AbstractString)\n\nThe number of characters in string s.\n\nExample\n\njulia> length(\"jμΛIα\")\n5\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.sizeof-Tuple{AbstractString}",
    "page": "Cadenas",
    "title": "Base.sizeof",
    "category": "Method",
    "text": "sizeof(s::AbstractString)\n\nThe number of bytes in string s.\n\nExample\n\njulia> sizeof(\"❤\")\n3\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.:*-Tuple{AbstractString,Vararg{Any,N} where N}",
    "page": "Cadenas",
    "title": "Base.:*",
    "category": "Method",
    "text": "*(x, y...)\n\nMultiplication operator. x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...).\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.:^-Tuple{AbstractString,Integer}",
    "page": "Cadenas",
    "title": "Base.:^",
    "category": "Method",
    "text": "^(s::AbstractString, n::Integer)\n\nRepeat n times the string s. The repeat function is an alias to this operator.\n\njulia> \"Test \"^3\n\"Test Test Test \"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.string",
    "page": "Cadenas",
    "title": "Base.string",
    "category": "Function",
    "text": "string(xs...)\n\nCreate a string from any values using the print function.\n\njulia> string(\"a\", 1, true)\n\"a1true\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.repr",
    "page": "Cadenas",
    "title": "Base.repr",
    "category": "Function",
    "text": "repr(x)\n\nCreate a string from any value using the showall function.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Core.String-Tuple{AbstractString}",
    "page": "Cadenas",
    "title": "Core.String",
    "category": "Method",
    "text": "String(s::AbstractString)\n\nConvert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.transcode",
    "page": "Cadenas",
    "title": "Base.transcode",
    "category": "Function",
    "text": "transcode(T, src)\n\nConvert string data between Unicode encodings. src is either a String or a Vector{UIntXX} of UTF-XX code units, where XX is 8, 16, or 32. T indicates the encoding of the return value: String to return a (UTF-8 encoded) String or UIntXX to return a Vector{UIntXX} of UTF-XX data.   (The alias Cwchar_t can also be used as the integer type, for converting wchar_t* strings used by external C libraries.)\n\nThe transcode function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.\n\nOnly conversion to/from UTF-8 is currently supported.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.unsafe_string",
    "page": "Cadenas",
    "title": "Base.unsafe_string",
    "category": "Function",
    "text": "unsafe_string(p::Ptr{UInt8}, [length::Integer])\n\nCopy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If length is specified (the length of the data in bytes), the string does not have to be NUL-terminated.\n\nThis function is labelled \"unsafe\" because it will crash if p is not a valid memory address to data of the requested length.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.codeunit-Tuple{AbstractString,Integer}",
    "page": "Cadenas",
    "title": "Base.codeunit",
    "category": "Method",
    "text": "codeunit(s::AbstractString, i::Integer)\n\nGet the ith code unit of an encoded string. For example, returns the ith byte of the representation of a UTF-8 string.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.ascii",
    "page": "Cadenas",
    "title": "Base.ascii",
    "category": "Function",
    "text": "ascii(s::AbstractString)\n\nConvert a string to String type and check that it contains only ASCII data, otherwise throwing an ArgumentError indicating the position of the first non-ASCII byte.\n\njulia> ascii(\"abcdeγfgh\")\nERROR: ArgumentError: invalid ASCII at index 6 in \"abcdeγfgh\"\nStacktrace:\n [1] ascii(::String) at ./strings/util.jl:479\n\njulia> ascii(\"abcdefgh\")\n\"abcdefgh\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.@r_str",
    "page": "Cadenas",
    "title": "Base.@r_str",
    "category": "Macro",
    "text": "@r_str -> Regex\n\nConstruct a regex, such as r\"^[a-z]*$\". The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:\n\ni enables case-insensitive matching\nm treats the ^ and $ tokens as matching the start and end of individual lines, as opposed to the whole string.\ns allows the . modifier to match newlines.\nx enables \"comment mode\": whitespace is enabled except when escaped with \\, and # is treated as starting a comment.\n\nFor example, this regex has all three flags enabled:\n\njulia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\nRegexMatch(\"angry,\\nBad world\")\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.Docs.@html_str",
    "page": "Cadenas",
    "title": "Base.Docs.@html_str",
    "category": "Macro",
    "text": "@html_str -> Docs.HTML\n\nCreate an HTML object from a literal string.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.Docs.@text_str",
    "page": "Cadenas",
    "title": "Base.Docs.@text_str",
    "category": "Macro",
    "text": "@text_str -> Docs.Text\n\nCreate a Text object from a literal string.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.normalize_string",
    "page": "Cadenas",
    "title": "Base.UTF8proc.normalize_string",
    "category": "Function",
    "text": "normalize_string(s::AbstractString, normalform::Symbol)\n\nNormalize the string s according to one of the four \"normal forms\" of the Unicode standard: normalform can be :NFC, :NFD, :NFKC, or :NFKD.  Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact.  Normal forms KC and KD additionally canonicalize \"compatibility equivalents\": they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.\n\nAlternatively, finer control and additional transformations may be be obtained by calling normalize_string(s; keywords...), where any number of the following boolean keywords options (which all default to false except for compose) are specified:\n\ncompose=false: do not perform canonical composition\ndecompose=true: do canonical decomposition instead of canonical composition (compose=true is ignored if present)\ncompat=true: compatibility equivalents are canonicalized\ncasefold=true: perform Unicode case folding, e.g. for case-insensitive string comparison\nnewline2lf=true, newline2ls=true, or newline2ps=true: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively\nstripmark=true: strip diacritical marks (e.g. accents)\nstripignore=true: strip Unicode's \"default ignorable\" characters (e.g. the soft hyphen or the left-to-right marker)\nstripcc=true: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified\nrejectna=true: throw an error if unassigned code points are found\nstable=true: enforce Unicode Versioning Stability\n\nFor example, NFKC corresponds to the options compose=true, compat=true, stable=true.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.graphemes",
    "page": "Cadenas",
    "title": "Base.UTF8proc.graphemes",
    "category": "Function",
    "text": "graphemes(s::AbstractString) -> GraphemeIterator\n\nReturns an iterator over substrings of s that correspond to the extended graphemes in the string, as defined by Unicode UAX #29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.isvalid-Tuple{Any}",
    "page": "Cadenas",
    "title": "Base.isvalid",
    "category": "Method",
    "text": "isvalid(value) -> Bool\n\nReturns true if the given value is valid for its type, which currently can be either Char or String.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.isvalid-Tuple{Any,Any}",
    "page": "Cadenas",
    "title": "Base.isvalid",
    "category": "Method",
    "text": "isvalid(T, value) -> Bool\n\nReturns true if the given value is valid for that type. Types currently can be either Char or String. Values for Char can be of type Char or UInt32. Values for String can be of that type, or Vector{UInt8}.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.isvalid-Tuple{AbstractString,Integer}",
    "page": "Cadenas",
    "title": "Base.isvalid",
    "category": "Method",
    "text": "isvalid(str::AbstractString, i::Integer)\n\nTells whether index i is valid for the given string.\n\nExamples\n\njulia> str = \"αβγdef\";\n\njulia> isvalid(str, 1)\ntrue\n\njulia> str[1]\n'α': Unicode U+03b1 (category Ll: Letter, lowercase)\n\njulia> isvalid(str, 2)\nfalse\n\njulia> str[2]\nERROR: UnicodeError: invalid character index\n[...]\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.is_assigned_char",
    "page": "Cadenas",
    "title": "Base.UTF8proc.is_assigned_char",
    "category": "Function",
    "text": "is_assigned_char(c) -> Bool\n\nReturns true if the given char or integer is an assigned Unicode code point.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.ismatch",
    "page": "Cadenas",
    "title": "Base.ismatch",
    "category": "Function",
    "text": "ismatch(r::Regex, s::AbstractString) -> Bool\n\nTest whether a string contains a match of the given regular expression.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.match",
    "page": "Cadenas",
    "title": "Base.match",
    "category": "Function",
    "text": "match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])\n\nSearch for the first match of the regular expression r in s and return a RegexMatch object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing m.match and the captured sequences can be retrieved by accessing m.captures The optional idx argument specifies an index at which to start the search.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.eachmatch",
    "page": "Cadenas",
    "title": "Base.eachmatch",
    "category": "Function",
    "text": "eachmatch(r::Regex, s::AbstractString[, overlap::Bool=false])\n\nSearch for all matches of a the regular expression r in s and return a iterator over the matches. If overlap is true, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.matchall",
    "page": "Cadenas",
    "title": "Base.matchall",
    "category": "Function",
    "text": "matchall(r::Regex, s::AbstractString[, overlap::Bool=false]) -> Vector{AbstractString}\n\nReturn a vector of the matching substrings from eachmatch.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.lpad",
    "page": "Cadenas",
    "title": "Base.lpad",
    "category": "Function",
    "text": "lpad(s, n::Integer, p::AbstractString=\" \")\n\nMake a string at least n columns wide when printed by padding s on the left with copies of p.\n\njulia> lpad(\"March\",10)\n\"     March\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.rpad",
    "page": "Cadenas",
    "title": "Base.rpad",
    "category": "Function",
    "text": "rpad(s, n::Integer, p::AbstractString=\" \")\n\nMake a string at least n columns wide when printed by padding s on the right with copies of p.\n\njulia> rpad(\"March\",20)\n\"March               \"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.search",
    "page": "Cadenas",
    "title": "Base.search",
    "category": "Function",
    "text": "search(string::AbstractString, chars::Chars, [start::Integer])\n\nSearch for the first occurrence of the given characters within the given string. The second argument may be a single character, a vector or a set of characters, a string, or a regular expression (though regular expressions are only allowed on contiguous strings, such as ASCII or UTF-8 strings). The third argument optionally specifies a starting index. The return value is a range of indexes where the matching sequence is found, such that s[search(s,x)] == x:\n\nsearch(string, \"substring\") = start:end such that string[start:end] == \"substring\", or 0:-1 if unmatched.\n\nsearch(string, 'c') = index such that string[index] == 'c', or 0 if unmatched.\n\njulia> search(\"Hello to the world\", \"z\")\n0:-1\n\njulia> search(\"JuliaLang\",\"Julia\")\n1:5\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.rsearch",
    "page": "Cadenas",
    "title": "Base.rsearch",
    "category": "Function",
    "text": "rsearch(s::AbstractString, chars::Chars, [start::Integer])\n\nSimilar to search, but returning the last occurrence of the given characters within the given string, searching in reverse from start.\n\njulia> rsearch(\"aaabbb\",\"b\")\n6:6\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.searchindex",
    "page": "Cadenas",
    "title": "Base.searchindex",
    "category": "Function",
    "text": "searchindex(s::AbstractString, substring, [start::Integer])\n\nSimilar to search, but return only the start index at which the substring is found, or 0 if it is not.\n\njulia> searchindex(\"Hello to the world\", \"z\")\n0\n\njulia> searchindex(\"JuliaLang\",\"Julia\")\n1\n\njulia> searchindex(\"JuliaLang\",\"Lang\")\n6\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.rsearchindex",
    "page": "Cadenas",
    "title": "Base.rsearchindex",
    "category": "Function",
    "text": "rsearchindex(s::AbstractString, substring, [start::Integer])\n\nSimilar to rsearch, but return only the start index at which the substring is found, or 0 if it is not.\n\njulia> rsearchindex(\"aaabbb\",\"b\")\n6\n\njulia> rsearchindex(\"aaabbb\",\"a\")\n3\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.contains-Tuple{AbstractString,AbstractString}",
    "page": "Cadenas",
    "title": "Base.contains",
    "category": "Method",
    "text": "contains(haystack::AbstractString, needle::AbstractString)\n\nDetermine whether the second argument is a substring of the first.\n\njulia> contains(\"JuliaLang is pretty cool!\", \"Julia\")\ntrue\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.reverse-Tuple{AbstractString}",
    "page": "Cadenas",
    "title": "Base.reverse",
    "category": "Method",
    "text": "reverse(s::AbstractString) -> AbstractString\n\nReverses a string.\n\njulia> reverse(\"JuliaLang\")\n\"gnaLailuJ\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.replace",
    "page": "Cadenas",
    "title": "Base.replace",
    "category": "Function",
    "text": "replace(string::AbstractString, pat, r[, n::Integer=0])\n\nSearch for the given pattern pat, and replace each occurrence with r. If n is provided, replace at most n occurrences. As with search, the second argument may be a single character, a vector or a set of characters, a string, or a regular expression. If r is a function, each occurrence is replaced with r(s) where s is the matched substring. If pat is a regular expression and r is a SubstitutionString, then capture group references in r are replaced with the corresponding matched text.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.split",
    "page": "Cadenas",
    "title": "Base.split",
    "category": "Function",
    "text": "split(s::AbstractString, [chars]; limit::Integer=0, keep::Bool=true)\n\nReturn an array of substrings by splitting the given string on occurrences of the given character delimiters, which may be specified in any of the formats allowed by search's second argument (i.e. a single character, collection of characters, string, or regular expression). If chars is omitted, it defaults to the set of all space characters, and keep is taken to be false. The two keyword arguments are optional: they are a maximum size for the result and a flag determining whether empty fields should be kept in the result.\n\njulia> a = \"Ma.rch\"\n\"Ma.rch\"\n\njulia> split(a,\".\")\n2-element Array{SubString{String},1}:\n \"Ma\"\n \"rch\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.rsplit",
    "page": "Cadenas",
    "title": "Base.rsplit",
    "category": "Function",
    "text": "rsplit(s::AbstractString, [chars]; limit::Integer=0, keep::Bool=true)\n\nSimilar to split, but starting from the end of the string.\n\njulia> a = \"M.a.r.c.h\"\n\"M.a.r.c.h\"\n\njulia> rsplit(a,\".\")\n5-element Array{SubString{String},1}:\n \"M\"\n \"a\"\n \"r\"\n \"c\"\n \"h\"\n\njulia> rsplit(a,\".\";limit=1)\n1-element Array{SubString{String},1}:\n \"M.a.r.c.h\"\n\njulia> rsplit(a,\".\";limit=2)\n2-element Array{SubString{String},1}:\n \"M.a.r.c\"\n \"h\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.strip",
    "page": "Cadenas",
    "title": "Base.strip",
    "category": "Function",
    "text": "strip(s::AbstractString, [chars::Chars])\n\nReturn s with any leading and trailing whitespace removed. If chars (a character, or vector or set of characters) is provided, instead remove characters contained in it.\n\njulia> strip(\"{3, 5}\\n\", ['{', '}', '\\n'])\n\"3, 5\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.lstrip",
    "page": "Cadenas",
    "title": "Base.lstrip",
    "category": "Function",
    "text": "lstrip(s::AbstractString[, chars::Chars])\n\nReturn s with any leading whitespace and delimiters removed. The default delimiters to remove are ' ', \\t, \\n, \\v, \\f, and \\r. If chars (a character, or vector or set of characters) is provided, instead remove characters contained in it.\n\njulia> a = lpad(\"March\", 20)\n\"               March\"\n\njulia> lstrip(a)\n\"March\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.rstrip",
    "page": "Cadenas",
    "title": "Base.rstrip",
    "category": "Function",
    "text": "rstrip(s::AbstractString[, chars::Chars])\n\nReturn s with any trailing whitespace and delimiters removed. The default delimiters to remove are ' ', \\t, \\n, \\v, \\f, and \\r. If chars (a character, or vector or set of characters) is provided, instead remove characters contained in it.\n\njulia> a = rpad(\"March\", 20)\n\"March               \"\n\njulia> rstrip(a)\n\"March\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.startswith",
    "page": "Cadenas",
    "title": "Base.startswith",
    "category": "Function",
    "text": "startswith(s::AbstractString, prefix::AbstractString)\n\nReturns true if s starts with prefix. If prefix is a vector or set of characters, tests whether the first character of s belongs to that set.\n\nSee also endswith.\n\njulia> startswith(\"JuliaLang\", \"Julia\")\ntrue\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.endswith",
    "page": "Cadenas",
    "title": "Base.endswith",
    "category": "Function",
    "text": "endswith(s::AbstractString, suffix::AbstractString)\n\nReturns true if s ends with suffix. If suffix is a vector or set of characters, tests whether the last character of s belongs to that set.\n\nSee also startswith.\n\njulia> endswith(\"Sunday\", \"day\")\ntrue\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.uppercase",
    "page": "Cadenas",
    "title": "Base.uppercase",
    "category": "Function",
    "text": "uppercase(s::AbstractString)\n\nReturns s with all characters converted to uppercase.\n\nExample\n\njulia> uppercase(\"Julia\")\n\"JULIA\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.lowercase",
    "page": "Cadenas",
    "title": "Base.lowercase",
    "category": "Function",
    "text": "lowercase(s::AbstractString)\n\nReturns s with all characters converted to lowercase.\n\nExample\n\njulia> lowercase(\"STRINGS AND THINGS\")\n\"strings and things\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.titlecase",
    "page": "Cadenas",
    "title": "Base.titlecase",
    "category": "Function",
    "text": "titlecase(s::AbstractString)\n\nCapitalizes the first character of each word in s.\n\nExample\n\njulia> titlecase(\"the julia programming language\")\n\"The Julia Programming Language\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.ucfirst",
    "page": "Cadenas",
    "title": "Base.ucfirst",
    "category": "Function",
    "text": "ucfirst(s::AbstractString)\n\nReturns string with the first character converted to uppercase.\n\nExample\n\njulia> ucfirst(\"python\")\n\"Python\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.lcfirst",
    "page": "Cadenas",
    "title": "Base.lcfirst",
    "category": "Function",
    "text": "lcfirst(s::AbstractString)\n\nReturns string with the first character converted to lowercase.\n\nExample\n\njulia> lcfirst(\"Julia\")\n\"julia\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.join",
    "page": "Cadenas",
    "title": "Base.join",
    "category": "Function",
    "text": "join(io::IO, strings, delim, [last])\n\nJoin an array of strings into a single string, inserting the given delimiter between adjacent strings. If last is given, it will be used instead of delim between the last two strings. For example,\n\njulia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n\"apples, bananas and pineapples\"\n\nstrings can be any iterable over elements x which are convertible to strings via print(io::IOBuffer, x). strings will be printed to io.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.chop",
    "page": "Cadenas",
    "title": "Base.chop",
    "category": "Function",
    "text": "chop(s::AbstractString)\n\nRemove the last character from s.\n\njulia> a = \"March\"\n\"March\"\n\njulia> chop(a)\n\"Marc\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.chomp",
    "page": "Cadenas",
    "title": "Base.chomp",
    "category": "Function",
    "text": "chomp(s::AbstractString)\n\nRemove a single trailing newline from a string.\n\njulia> chomp(\"Hello\\n\")\n\"Hello\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.ind2chr",
    "page": "Cadenas",
    "title": "Base.ind2chr",
    "category": "Function",
    "text": "ind2chr(s::AbstractString, i::Integer)\n\nConvert a byte index i to a character index with respect to string s.\n\nSee also chr2ind.\n\nExample\n\njulia> str = \"αβγdef\";\n\njulia> ind2chr(str, 3)\n2\n\njulia> chr2ind(str, 2)\n3\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.chr2ind",
    "page": "Cadenas",
    "title": "Base.chr2ind",
    "category": "Function",
    "text": "chr2ind(s::AbstractString, i::Integer)\n\nConvert a character index i to a byte index.\n\nSee also ind2chr.\n\nExample\n\njulia> str = \"αβγdef\";\n\njulia> chr2ind(str, 2)\n3\n\njulia> ind2chr(str, 3)\n2\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.nextind",
    "page": "Cadenas",
    "title": "Base.nextind",
    "category": "Function",
    "text": "nextind(str::AbstractString, i::Integer)\n\nGet the next valid string index after i. Returns a value greater than endof(str) at or after the end of the string.\n\nExamples\n\njulia> str = \"αβγdef\";\n\njulia> nextind(str, 1)\n3\n\njulia> endof(str)\n9\n\njulia> nextind(str, 9)\n10\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.prevind",
    "page": "Cadenas",
    "title": "Base.prevind",
    "category": "Function",
    "text": "prevind(str::AbstractString, i::Integer)\n\nGet the previous valid string index before i. Returns a value less than 1 at the beginning of the string.\n\nExamples\n\njulia> prevind(\"αβγdef\", 3)\n1\n\njulia> prevind(\"αβγdef\", 1)\n0\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.Random.randstring",
    "page": "Cadenas",
    "title": "Base.Random.randstring",
    "category": "Function",
    "text": "randstring([rng,] len=8)\n\nCreate a random ASCII string of length len, consisting of upper- and lower-case letters and the digits 0-9. The optional rng argument specifies a random number generator, see Random Numbers.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> randstring(rng, 4)\n\"mbDd\"\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.charwidth",
    "page": "Cadenas",
    "title": "Base.UTF8proc.charwidth",
    "category": "Function",
    "text": "charwidth(c)\n\nGives the number of columns needed to print a character.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.strwidth",
    "page": "Cadenas",
    "title": "Base.strwidth",
    "category": "Function",
    "text": "strwidth(s::AbstractString)\n\nGives the number of columns needed to print a string.\n\nExample\n\njulia> strwidth(\"March\")\n5\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.isalnum",
    "page": "Cadenas",
    "title": "Base.UTF8proc.isalnum",
    "category": "Function",
    "text": "isalnum(c::Char) -> Bool\n\nTests whether a character is alphanumeric. A character is classified as alphabetic if it belongs to the Unicode general category Letter or Number, i.e. a character whose category code begins with 'L' or 'N'.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.isalpha",
    "page": "Cadenas",
    "title": "Base.UTF8proc.isalpha",
    "category": "Function",
    "text": "isalpha(c::Char) -> Bool\n\nTests whether a character is alphabetic. A character is classified as alphabetic if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with 'L'.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.isascii",
    "page": "Cadenas",
    "title": "Base.isascii",
    "category": "Function",
    "text": "isascii(c::Union{Char,AbstractString}) -> Bool\n\nTests whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.iscntrl",
    "page": "Cadenas",
    "title": "Base.UTF8proc.iscntrl",
    "category": "Function",
    "text": "iscntrl(c::Char) -> Bool\n\nTests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.isdigit",
    "page": "Cadenas",
    "title": "Base.UTF8proc.isdigit",
    "category": "Function",
    "text": "isdigit(c::Char) -> Bool\n\nTests whether a character is a numeric digit (0-9).\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.isgraph",
    "page": "Cadenas",
    "title": "Base.UTF8proc.isgraph",
    "category": "Function",
    "text": "isgraph(c::Char) -> Bool\n\nTests whether a character is printable, and not a space. Any character that would cause a printer to use ink should be classified with isgraph(c)==true.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.islower",
    "page": "Cadenas",
    "title": "Base.UTF8proc.islower",
    "category": "Function",
    "text": "islower(c::Char) -> Bool\n\nTests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.isnumber",
    "page": "Cadenas",
    "title": "Base.UTF8proc.isnumber",
    "category": "Function",
    "text": "isnumber(c::Char) -> Bool\n\nTests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.isprint",
    "page": "Cadenas",
    "title": "Base.UTF8proc.isprint",
    "category": "Function",
    "text": "isprint(c::Char) -> Bool\n\nTests whether a character is printable, including spaces, but not a control character.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.ispunct",
    "page": "Cadenas",
    "title": "Base.UTF8proc.ispunct",
    "category": "Function",
    "text": "ispunct(c::Char) -> Bool\n\nTests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with 'P'.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.isspace",
    "page": "Cadenas",
    "title": "Base.UTF8proc.isspace",
    "category": "Function",
    "text": "isspace(c::Char) -> Bool\n\nTests whether a character is any whitespace character. Includes ASCII characters '\\t', '\\n', '\\v', '\\f', '\\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.UTF8proc.isupper",
    "page": "Cadenas",
    "title": "Base.UTF8proc.isupper",
    "category": "Function",
    "text": "isupper(c::Char) -> Bool\n\nTests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.isxdigit",
    "page": "Cadenas",
    "title": "Base.isxdigit",
    "category": "Function",
    "text": "isxdigit(c::Char) -> Bool\n\nTests whether a character is a valid hexadecimal digit. Note that this does not include x (as in the standard 0x prefix).\n\nExample\n\njulia> isxdigit('a')\ntrue\n\njulia> isxdigit('x')\nfalse\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Core.Symbol",
    "page": "Cadenas",
    "title": "Core.Symbol",
    "category": "Type",
    "text": "Symbol(x...) -> Symbol\n\nCreate a Symbol by concatenating the string representations of the arguments together.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.escape_string",
    "page": "Cadenas",
    "title": "Base.escape_string",
    "category": "Function",
    "text": "escape_string([io,] str::AbstractString[, esc::AbstractString]) -> AbstractString\n\nGeneral escaping of traditional C and Unicode escape sequences. Any characters in esc are also escaped (with a backslash). See also unescape_string.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#Base.unescape_string",
    "page": "Cadenas",
    "title": "Base.unescape_string",
    "category": "Function",
    "text": "unescape_string([io,] s::AbstractString) -> AbstractString\n\nGeneral unescaping of traditional C and Unicode escape sequences. Reverse of escape_string.\n\n\n\n"
},

{
    "location": "stdlib/strings.html#lib-strings-1",
    "page": "Cadenas",
    "title": "Cadenas",
    "category": "section",
    "text": "Base.length(::AbstractString)\nBase.sizeof(::AbstractString)\nBase.:*(::AbstractString, ::Any...)\nBase.:^(::AbstractString, ::Integer)\nBase.string\nBase.repr\nCore.String(::AbstractString)\nBase.transcode\nBase.unsafe_string\nBase.codeunit(::AbstractString, ::Integer)\nBase.ascii\nBase.@r_str\nBase.Docs.@html_str\nBase.Docs.@text_str\nBase.UTF8proc.normalize_string\nBase.UTF8proc.graphemes\nBase.isvalid(::Any)\nBase.isvalid(::Any, ::Any)\nBase.isvalid(::AbstractString, ::Integer)\nBase.UTF8proc.is_assigned_char\nBase.ismatch\nBase.match\nBase.eachmatch\nBase.matchall\nBase.lpad\nBase.rpad\nBase.search\nBase.rsearch\nBase.searchindex\nBase.rsearchindex\nBase.contains(::AbstractString, ::AbstractString)\nBase.reverse(::AbstractString)\nBase.replace\nBase.split\nBase.rsplit\nBase.strip\nBase.lstrip\nBase.rstrip\nBase.startswith\nBase.endswith\nBase.uppercase\nBase.lowercase\nBase.titlecase\nBase.ucfirst\nBase.lcfirst\nBase.join\nBase.chop\nBase.chomp\nBase.ind2chr\nBase.chr2ind\nBase.nextind\nBase.prevind\nBase.Random.randstring\nBase.UTF8proc.charwidth\nBase.strwidth\nBase.UTF8proc.isalnum\nBase.UTF8proc.isalpha\nBase.isascii\nBase.UTF8proc.iscntrl\nBase.UTF8proc.isdigit\nBase.UTF8proc.isgraph\nBase.UTF8proc.islower\nBase.UTF8proc.isnumber\nBase.UTF8proc.isprint\nBase.UTF8proc.ispunct\nBase.UTF8proc.isspace\nBase.UTF8proc.isupper\nBase.isxdigit\nCore.Symbol\nBase.escape_string\nBase.unescape_string"
},

{
    "location": "stdlib/arrays.html#",
    "page": "Arrays",
    "title": "Arrays",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/arrays.html#lib-arrays-1",
    "page": "Arrays",
    "title": "Arrays",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/arrays.html#Core.AbstractArray",
    "page": "Arrays",
    "title": "Core.AbstractArray",
    "category": "Type",
    "text": "AbstractArray{T, N}\n\nAbstract array supertype which arrays inherit from.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Core.Array",
    "page": "Arrays",
    "title": "Core.Array",
    "category": "Type",
    "text": "Array{T}(dims)\nArray{T,N}(dims)\n\nConstruct an uninitialized N-dimensional dense array with element type T, where N is determined from the length or number of dims. dims may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank N is supplied explicitly as in Array{T,N}(dims), then it must match the length or number of dims.\n\nExample\n\njulia> A = Array{Float64, 2}(2, 2);\n\njulia> ndims(A)\n2\n\njulia> eltype(A)\nFloat64\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}",
    "page": "Arrays",
    "title": "Base.getindex",
    "category": "Method",
    "text": "getindex(type[, elements...])\n\nConstruct a 1-d array of the specified type. This is usually called with the syntax Type[]. Element values can be specified using Type[a,b,c,...].\n\nExample\n\njulia> Int8[1, 2, 3]\n3-element Array{Int8,1}:\n 1\n 2\n 3\n\njulia> getindex(Int8, 1, 2, 3)\n3-element Array{Int8,1}:\n 1\n 2\n 3\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.zeros",
    "page": "Arrays",
    "title": "Base.zeros",
    "category": "Function",
    "text": "zeros([A::AbstractArray,] [T=eltype(A)::Type,] [dims=size(A)::Tuple])\n\nCreate an array of all zeros with the same layout as A, element type T and size dims. The A argument can be skipped, which behaves like Array{Float64,0}() was passed. For convenience dims may also be passed in variadic form.\n\nExamples\n\njulia> zeros(1)\n1-element Array{Float64,1}:\n 0.0\n\njulia> zeros(Int8, 2, 3)\n2×3 Array{Int8,2}:\n 0  0  0\n 0  0  0\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> zeros(A)\n2×2 Array{Int64,2}:\n 0  0\n 0  0\n\njulia> zeros(A, Float64)\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\njulia> zeros(A, Bool, (3,))\n3-element Array{Bool,1}:\n false\n false\n false\n\nSee also ones, similar.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.ones",
    "page": "Arrays",
    "title": "Base.ones",
    "category": "Function",
    "text": "ones([A::AbstractArray,] [T=eltype(A)::Type,] [dims=size(A)::Tuple])\n\nCreate an array of all ones with the same layout as A, element type T and size dims. The A argument can be skipped, which behaves like Array{Float64,0}() was passed. For convenience dims may also be passed in variadic form.\n\nExamples\n\njulia> ones(Complex128, 2, 3)\n2×3 Array{Complex{Float64},2}:\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n\njulia> ones(1,2)\n1×2 Array{Float64,2}:\n 1.0  1.0\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> ones(A)\n2×2 Array{Int64,2}:\n 1  1\n 1  1\n\njulia> ones(A, Float64)\n2×2 Array{Float64,2}:\n 1.0  1.0\n 1.0  1.0\n\njulia> ones(A, Bool, (3,))\n3-element Array{Bool,1}:\n true\n true\n true\n\nSee also zeros, similar.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.BitArray",
    "page": "Arrays",
    "title": "Base.BitArray",
    "category": "Type",
    "text": "BitArray(dims::Integer...)\nBitArray{N}(dims::NTuple{N,Int})\n\nConstruct an uninitialized BitArray with the given dimensions. Behaves identically to the Array constructor.\n\njulia> BitArray(2, 2)\n2×2 BitArray{2}:\n false  false\n false  true\n\njulia> BitArray((3, 1))\n3×1 BitArray{2}:\n false\n true\n false\n\n\n\nBitArray(itr)\n\nConstruct a BitArray generated by the given iterable object. The shape is inferred from the itr object.\n\njulia> BitArray([1 0; 0 1])\n2×2 BitArray{2}:\n  true  false\n false   true\n\njulia> BitArray(x+y == 3 for x = 1:2, y = 1:3)\n2×3 BitArray{2}:\n false   true  false\n  true  false  false\n\njulia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)\n6-element BitArray{1}:\n false\n  true\n false\n  true\n false\n false\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.trues",
    "page": "Arrays",
    "title": "Base.trues",
    "category": "Function",
    "text": "trues(dims)\n\nCreate a BitArray with all values set to true.\n\njulia> trues(2,3)\n2×3 BitArray{2}:\n true  true  true\n true  true  true\n\n\n\ntrues(A)\n\nCreate a BitArray with all values set to true of the same shape as A.\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> trues(A)\n2×2 BitArray{2}:\n true  true\n true  true\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.falses",
    "page": "Arrays",
    "title": "Base.falses",
    "category": "Function",
    "text": "falses(dims)\n\nCreate a BitArray with all values set to false.\n\njulia> falses(2,3)\n2×3 BitArray{2}:\n false  false  false\n false  false  false\n\n\n\nfalses(A)\n\nCreate a BitArray with all values set to false of the same shape as A.\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> falses(A)\n2×2 BitArray{2}:\n false  false\n false  false\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.fill",
    "page": "Arrays",
    "title": "Base.fill",
    "category": "Function",
    "text": "fill(x, dims)\n\nCreate an array filled with the value x. For example, fill(1.0, (5,5)) returns a 5×5 array of floats, with each element initialized to 1.0.\n\njulia> fill(1.0, (5,5))\n5×5 Array{Float64,2}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n\nIf x is an object reference, all elements will refer to the same object. fill(Foo(), dims) will return an array filled with the result of evaluating Foo() once.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.fill!",
    "page": "Arrays",
    "title": "Base.fill!",
    "category": "Function",
    "text": "fill!(A, x)\n\nFill array A with the value x. If x is an object reference, all elements will refer to the same object. fill!(A, Foo()) will return A filled with the result of evaluating Foo() once.\n\nExamples\n\njulia> A = zeros(2,3)\n2×3 Array{Float64,2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> fill!(A, 2.)\n2×3 Array{Float64,2}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(3), a); a[1] = 2; A\n3-element Array{Array{Int64,1},1}:\n [2, 1, 1]\n [2, 1, 1]\n [2, 1, 1]\n\njulia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(3), f())\n3-element Array{Int64,1}:\n 1\n 1\n 1\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.similar-Tuple{AbstractArray}",
    "page": "Arrays",
    "title": "Base.similar",
    "category": "Method",
    "text": "similar(array, [element_type=eltype(array)], [dims=size(array)])\n\nCreate an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array's eltype and size. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.\n\nCustom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an Array{element_type}(dims...).\n\nFor example, similar(1:10, 1, 4) returns an uninitialized Array{Int,2} since ranges are neither mutable nor support 2 dimensions:\n\njulia> similar(1:10, 1, 4)\n1×4 Array{Int64,2}:\n 4419743872  4374413872  4419743888  0\n\nConversely, similar(trues(10,10), 2) returns an uninitialized BitVector with two elements since BitArrays are both mutable and can support 1-dimensional arrays:\n\njulia> similar(trues(10,10), 2)\n2-element BitArray{1}:\n false\n false\n\nSince BitArrays can only store elements of type Bool, however, if you request a different element type it will create a regular Array instead:\n\njulia> similar(falses(10), Float64, 2, 4)\n2×4 Array{Float64,2}:\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.similar-Tuple{Any,Tuple}",
    "page": "Arrays",
    "title": "Base.similar",
    "category": "Method",
    "text": "similar(storagetype, indices)\n\nCreate an uninitialized mutable array analogous to that specified by storagetype, but with indices specified by the last argument. storagetype might be a type or a function.\n\nExamples:\n\nsimilar(Array{Int}, indices(A))\n\ncreates an array that \"acts like\" an Array{Int} (and might indeed be backed by one), but which is indexed identically to A. If A has conventional indexing, this will be identical to Array{Int}(size(A)), but if A has unconventional indexing then the indices of the result will match A.\n\nsimilar(BitArray, (indices(A, 2),))\n\nwould create a 1-dimensional logical array whose indices match those of the columns of A.\n\nsimilar(dims->zeros(Int, dims), indices(A))\n\nwould create an array of Int, initialized to zero, matching the indices of A.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.eye",
    "page": "Arrays",
    "title": "Base.eye",
    "category": "Function",
    "text": "eye([T::Type=Float64,] m::Integer, n::Integer)\n\nm-by-n identity matrix. The default element type is Float64.\n\nExamples\n\njulia> eye(3, 4)\n3×4 Array{Float64,2}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n\njulia> eye(2, 2)\n2×2 Array{Float64,2}:\n 1.0  0.0\n 0.0  1.0\n\njulia> eye(Int, 2, 2)\n2×2 Array{Int64,2}:\n 1  0\n 0  1\n\n\n\neye(m, n)\n\nm-by-n identity matrix.\n\n\n\neye([T::Type=Float64,] n::Integer)\n\nn-by-n identity matrix. The default element type is Float64.\n\nExamples\n\njulia> eye(Int, 2)\n2×2 Array{Int64,2}:\n 1  0\n 0  1\n\njulia> eye(2)\n2×2 Array{Float64,2}:\n 1.0  0.0\n 0.0  1.0\n\n\n\neye(A)\n\nConstructs an identity matrix of the same dimensions and type as A.\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> eye(A)\n3×3 Array{Int64,2}:\n 1  0  0\n 0  1  0\n 0  0  1\n\nNote the difference from ones.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.linspace",
    "page": "Arrays",
    "title": "Base.linspace",
    "category": "Function",
    "text": "linspace(start, stop, n=50)\n\nConstruct a range of n linearly spaced elements from start to stop.\n\njulia> linspace(1.3,2.9,9)\n1.3:0.2:2.9\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.logspace",
    "page": "Arrays",
    "title": "Base.logspace",
    "category": "Function",
    "text": "logspace(start::Real, stop::Real, n::Integer=50)\n\nConstruct a vector of n logarithmically spaced numbers from 10^start to 10^stop.\n\njulia> logspace(1.,10.,5)\n5-element Array{Float64,1}:\n   10.0\n 1778.28\n    3.16228e5\n    5.62341e7\n    1.0e10\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.Random.randsubseq",
    "page": "Arrays",
    "title": "Base.Random.randsubseq",
    "category": "Function",
    "text": "randsubseq(A, p) -> Vector\n\nReturn a vector consisting of a random subsequence of the given array A, where each element of A is included (in order) with independent probability p. (Complexity is linear in p*length(A), so this function is efficient even if p is small and A is large.) Technically, this process is known as \"Bernoulli sampling\" of A.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.Random.randsubseq!",
    "page": "Arrays",
    "title": "Base.Random.randsubseq!",
    "category": "Function",
    "text": "randsubseq!(S, A, p)\n\nLike randsubseq, but the results are stored in S (which is resized as needed).\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Constructores-y-Tipos-1",
    "page": "Arrays",
    "title": "Constructores y Tipos",
    "category": "section",
    "text": "Core.AbstractArray\nCore.Array\nBase.getindex(::Type, ::Any...)\nBase.zeros\nBase.ones\nBase.BitArray\nBase.trues\nBase.falses\nBase.fill\nBase.fill!\nBase.similar(::AbstractArray)\nBase.similar(::Any, ::Tuple)\nBase.eye\nBase.linspace\nBase.logspace\nBase.Random.randsubseq\nBase.Random.randsubseq!"
},

{
    "location": "stdlib/arrays.html#Base.ndims",
    "page": "Arrays",
    "title": "Base.ndims",
    "category": "Function",
    "text": "ndims(A::AbstractArray) -> Integer\n\nReturns the number of dimensions of A.\n\njulia> A = ones(3,4,5);\n\njulia> ndims(A)\n3\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.size",
    "page": "Arrays",
    "title": "Base.size",
    "category": "Function",
    "text": "size(A::AbstractArray, [dim...])\n\nReturns a tuple containing the dimensions of A. Optionally you can specify the dimension(s) you want the length of, and get the length of that dimension, or a tuple of the lengths of dimensions you asked for.\n\njulia> A = ones(2,3,4);\n\njulia> size(A, 2)\n3\n\njulia> size(A,3,2)\n(4, 3)\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.indices-Tuple{Any}",
    "page": "Arrays",
    "title": "Base.indices",
    "category": "Method",
    "text": "indices(A)\n\nReturns the tuple of valid indices for array A.\n\njulia> A = ones(5,6,7);\n\njulia> indices(A)\n(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.indices-Tuple{AbstractArray,Any}",
    "page": "Arrays",
    "title": "Base.indices",
    "category": "Method",
    "text": "indices(A, d)\n\nReturns the valid range of indices for array A along dimension d.\n\njulia> A = ones(5,6,7);\n\njulia> indices(A,2)\nBase.OneTo(6)\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.length-Tuple{AbstractArray}",
    "page": "Arrays",
    "title": "Base.length",
    "category": "Method",
    "text": "length(A::AbstractArray) -> Integer\n\nReturns the number of elements in A.\n\njulia> A = ones(3,4,5);\n\njulia> length(A)\n60\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.eachindex",
    "page": "Arrays",
    "title": "Base.eachindex",
    "category": "Function",
    "text": "eachindex(A...)\n\nCreates an iterable object for visiting each index of an AbstractArray A in an efficient manner. For array types that have opted into fast linear indexing (like Array), this is simply the range 1:length(A). For other array types, this returns a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, this returns an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).\n\nExample for a sparse 2-d array:\n\njulia> A = sparse([1, 1, 2], [1, 3, 1], [1, 2, -5])\n2×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [1, 1]  =  1\n  [2, 1]  =  -5\n  [1, 3]  =  2\n\njulia> for iter in eachindex(A)\n           @show iter.I[1], iter.I[2]\n           @show A[iter]\n       end\n(iter.I[1], iter.I[2]) = (1, 1)\nA[iter] = 1\n(iter.I[1], iter.I[2]) = (2, 1)\nA[iter] = -5\n(iter.I[1], iter.I[2]) = (1, 2)\nA[iter] = 0\n(iter.I[1], iter.I[2]) = (2, 2)\nA[iter] = 0\n(iter.I[1], iter.I[2]) = (1, 3)\nA[iter] = 2\n(iter.I[1], iter.I[2]) = (2, 3)\nA[iter] = 0\n\nIf you supply more than one AbstractArray argument, eachindex will create an iterable object that is fast for all arguments (a UnitRange if all inputs have fast linear indexing, a CartesianRange otherwise). If the arrays have different sizes and/or dimensionalities, eachindex returns an iterable that spans the largest range along each dimension.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.linearindices",
    "page": "Arrays",
    "title": "Base.linearindices",
    "category": "Function",
    "text": "linearindices(A)\n\nReturns a UnitRange specifying the valid range of indices for A[i] where i is an Int. For arrays with conventional indexing (indices start at 1), or any multidimensional array, this is 1:length(A); however, for one-dimensional arrays with unconventional indices, this is indices(A, 1).\n\nCalling this function is the \"safe\" way to write algorithms that exploit linear indexing.\n\njulia> A = ones(5,6,7);\n\njulia> b = linearindices(A);\n\njulia> extrema(b)\n(1, 210)\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.IndexStyle",
    "page": "Arrays",
    "title": "Base.IndexStyle",
    "category": "Type",
    "text": "IndexStyle(A)\nIndexStyle(typeof(A))\n\nIndexStyle specifies the \"native indexing style\" for array A. When you define a new AbstractArray type, you can choose to implement either linear indexing or cartesian indexing.  If you decide to implement linear indexing, then you must set this trait for your array type:\n\nBase.IndexStyle(::Type{<:MyArray}) = IndexLinear()\n\nThe default is IndexCartesian().\n\nJulia's internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style using sub2ind or ind2sub. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.\n\nIf you define both styles of indexing for your AbstractArray, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, eachindex creates an iterator whose type depends on the setting of this trait.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.countnz",
    "page": "Arrays",
    "title": "Base.countnz",
    "category": "Function",
    "text": "countnz(A) -> Integer\n\nCounts the number of nonzero values in array A (dense or sparse). Note that this is not a constant-time operation. For sparse matrices, one should usually use nnz, which returns the number of stored values.\n\njulia> A = [1 2 4; 0 0 1; 1 1 0]\n3×3 Array{Int64,2}:\n 1  2  4\n 0  0  1\n 1  1  0\n\njulia> countnz(A)\n6\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.conj!",
    "page": "Arrays",
    "title": "Base.conj!",
    "category": "Function",
    "text": "conj!(A)\n\nTransform an array to its complex conjugate in-place.\n\nSee also conj.\n\nExample\n\njulia> A = [1+im 2-im; 2+2im 3+im]\n2×2 Array{Complex{Int64},2}:\n 1+1im  2-1im\n 2+2im  3+1im\n\njulia> conj!(A);\n\njulia> A\n2×2 Array{Complex{Int64},2}:\n 1-1im  2+1im\n 2-2im  3-1im\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.stride",
    "page": "Arrays",
    "title": "Base.stride",
    "category": "Function",
    "text": "stride(A, k::Integer)\n\nReturns the distance in memory (in number of elements) between adjacent elements in dimension k.\n\njulia> A = ones(3,4,5);\n\njulia> stride(A,2)\n3\n\njulia> stride(A,3)\n12\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.strides",
    "page": "Arrays",
    "title": "Base.strides",
    "category": "Function",
    "text": "strides(A)\n\nReturns a tuple of the memory strides in each dimension.\n\njulia> A = ones(3,4,5);\n\njulia> strides(A)\n(1, 3, 12)\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.ind2sub",
    "page": "Arrays",
    "title": "Base.ind2sub",
    "category": "Function",
    "text": "ind2sub(a, index) -> subscripts\n\nReturns a tuple of subscripts into array a corresponding to the linear index index.\n\njulia> A = ones(5,6,7);\n\njulia> ind2sub(A,35)\n(5, 1, 2)\n\njulia> ind2sub(A,70)\n(5, 2, 3)\n\n\n\nind2sub(dims, index) -> subscripts\n\nReturns a tuple of subscripts into an array with dimensions dims, corresponding to the linear index index.\n\nExample:\n\ni, j, ... = ind2sub(size(A), indmax(A))\n\nprovides the indices of the maximum element.\n\njulia> ind2sub((3,4),2)\n(2, 1)\n\njulia> ind2sub((3,4),3)\n(3, 1)\n\njulia> ind2sub((3,4),4)\n(1, 2)\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.sub2ind",
    "page": "Arrays",
    "title": "Base.sub2ind",
    "category": "Function",
    "text": "sub2ind(dims, i, j, k...) -> index\n\nThe inverse of ind2sub, returns the linear index corresponding to the provided subscripts.\n\njulia> sub2ind((5,6,7),1,2,3)\n66\n\njulia> sub2ind((5,6,7),1,6,3)\n86\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.LinAlg.checksquare",
    "page": "Arrays",
    "title": "Base.LinAlg.checksquare",
    "category": "Function",
    "text": "LinAlg.checksquare(A)\n\nCheck that a matrix is square, then return its common dimension. For multiple arguments, return a vector.\n\nExample\n\njulia> A = ones(4,4); B = zeros(5,5);\n\njulia> LinAlg.checksquare(A, B)\n2-element Array{Int64,1}:\n 4\n 5\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Funciones-básicas-1",
    "page": "Arrays",
    "title": "Funciones básicas",
    "category": "section",
    "text": "Base.ndims\nBase.size\nBase.indices(::Any)\nBase.indices(::AbstractArray, ::Any)\nBase.length(::AbstractArray)\nBase.eachindex\nBase.linearindices\nBase.IndexStyle\nBase.countnz\nBase.conj!\nBase.stride\nBase.strides\nBase.ind2sub\nBase.sub2ind\nBase.LinAlg.checksquare"
},

{
    "location": "stdlib/arrays.html#Base.broadcast",
    "page": "Arrays",
    "title": "Base.broadcast",
    "category": "Function",
    "text": "broadcast(f, As...)\n\nBroadcasts the arrays, tuples, Refs, nullables, and/or scalars As to a container of the appropriate type and dimensions. In this context, anything that is not a subtype of AbstractArray, Ref (except for Ptrs), Tuple, or Nullable is considered a scalar. The resulting container is established by the following rules:\n\nIf all the arguments are scalars, it returns a scalar.\nIf the arguments are tuples and zero or more scalars, it returns a tuple.\nIf the arguments contain at least one array or Ref, it returns an array (expanding singleton dimensions), and treats Refs as 0-dimensional arrays, and tuples as 1-dimensional arrays.\n\nThe following additional rule applies to Nullable arguments: If there is at least one Nullable, and all the arguments are scalars or Nullable, it returns a Nullable treating Nullables as \"containers\".\n\nA special syntax exists for broadcasting: f.(args...) is equivalent to broadcast(f, args...), and nested f.(g.(args...)) calls are fused into a single broadcast loop.\n\njulia> A = [1, 2, 3, 4, 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> B = [1 2; 3 4; 5 6; 7 8; 9 10]\n5×2 Array{Int64,2}:\n 1   2\n 3   4\n 5   6\n 7   8\n 9  10\n\njulia> broadcast(+, A, B)\n5×2 Array{Int64,2}:\n  2   3\n  5   6\n  8   9\n 11  12\n 14  15\n\njulia> parse.(Int, [\"1\", \"2\"])\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> abs.((1, -2))\n(1, 2)\n\njulia> broadcast(+, 1.0, (0, -2.0))\n(1.0, -1.0)\n\njulia> broadcast(+, 1.0, (0, -2.0), Ref(1))\n2-element Array{Float64,1}:\n 2.0\n 0.0\n\njulia> (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))\n2-element Array{Array{Int64,1},1}:\n [1, 1]\n [2, 2]\n\njulia> string.((\"one\",\"two\",\"three\",\"four\"), \": \", 1:4)\n4-element Array{String,1}:\n \"one: 1\"\n \"two: 2\"\n \"three: 3\"\n \"four: 4\"\n\njulia> Nullable(\"X\") .* \"Y\"\nNullable{String}(\"XY\")\n\njulia> broadcast(/, 1.0, Nullable(2.0))\nNullable{Float64}(0.5)\n\njulia> (1 + im) ./ Nullable{Int}()\nNullable{Complex{Float64}}()\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.broadcast!",
    "page": "Arrays",
    "title": "Base.broadcast!",
    "category": "Function",
    "text": "broadcast!(f, dest, As...)\n\nLike broadcast, but store the result of broadcast(f, As...) in the dest array. Note that dest is only used to store the result, and does not supply arguments to f unless it is also listed in the As, as in broadcast!(f, A, A, B) to perform A[:] = broadcast(f, A, B).\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.Broadcast.@__dot__",
    "page": "Arrays",
    "title": "Base.Broadcast.@__dot__",
    "category": "Macro",
    "text": "@. expr\n\nConvert every function call or operator in expr into a \"dot call\" (e.g. convert f(x) to f.(x)), and convert every assignment in expr to a \"dot assignment\" (e.g. convert += to .+=).\n\nIf you want to avoid adding dots for selected function calls in expr, splice those function calls in with $.  For example, @. sqrt(abs($sort(x))) is equivalent to sqrt.(abs.(sort(x))) (no dot for sort).\n\n(@. is equivalent to a call to @__dot__.)\n\njulia> x = 1.0:3.0; y = similar(x);\n\njulia> @. y = x + 3 * sin(x)\n3-element Array{Float64,1}:\n 3.52441\n 4.72789\n 3.42336\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.Broadcast.broadcast_getindex",
    "page": "Arrays",
    "title": "Base.Broadcast.broadcast_getindex",
    "category": "Function",
    "text": "broadcast_getindex(A, inds...)\n\nBroadcasts the inds arrays to a common size like broadcast and returns an array of the results A[ks...], where ks goes over the positions in the broadcast result A.\n\njulia> A = [1, 2, 3, 4, 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> B = [1 2; 3 4; 5 6; 7 8; 9 10]\n5×2 Array{Int64,2}:\n 1   2\n 3   4\n 5   6\n 7   8\n 9  10\n\njulia> C = broadcast(+,A,B)\n5×2 Array{Int64,2}:\n  2   3\n  5   6\n  8   9\n 11  12\n 14  15\n\njulia> broadcast_getindex(C,[1,2,10])\n3-element Array{Int64,1}:\n  2\n  5\n 15\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.Broadcast.broadcast_setindex!",
    "page": "Arrays",
    "title": "Base.Broadcast.broadcast_setindex!",
    "category": "Function",
    "text": "broadcast_setindex!(A, X, inds...)\n\nBroadcasts the X and inds arrays to a common size and stores the value from each position in X at the indices in A given by the same positions in inds.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Retransmisión-y-Vectorización-1",
    "page": "Arrays",
    "title": "Retransmisión y Vectorización",
    "category": "section",
    "text": "Ver también la sintaxis de puntos para vectorizar funciones; por ejemplo, f. (args ...) llama implícitamente a broadcast(f, args...). En lugar de confiar en los métodos \"vectorizados\" de funciones como sin para operar en arrays, debe usar sin.(A) para vectorizar a través de broadcast.Base.broadcast\nBase.Broadcast.broadcast!\nBase.@__dot__\nBase.Broadcast.broadcast_getindex\nBase.Broadcast.broadcast_setindex!"
},

{
    "location": "stdlib/arrays.html#Base.getindex-Tuple{AbstractArray,Vararg{Any,N} where N}",
    "page": "Arrays",
    "title": "Base.getindex",
    "category": "Method",
    "text": "getindex(A, inds...)\n\nReturns a subset of array A as specified by inds, where each ind may be an Int, a Range, or a Vector. See the manual section on array indexing for details.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> getindex(A, 1)\n1\n\njulia> getindex(A, [2, 1])\n2-element Array{Int64,1}:\n 3\n 1\n\njulia> getindex(A, 2:4)\n3-element Array{Int64,1}:\n 3\n 2\n 4\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}",
    "page": "Arrays",
    "title": "Base.setindex!",
    "category": "Method",
    "text": "setindex!(A, X, inds...)\n\nStore values from array X within some subset of A as specified by inds.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.copy!-Tuple{AbstractArray,CartesianRange,AbstractArray,CartesianRange}",
    "page": "Arrays",
    "title": "Base.copy!",
    "category": "Method",
    "text": "copy!(dest, Rdest::CartesianRange, src, Rsrc::CartesianRange) -> dest\n\nCopy the block of src in the range of Rsrc to the block of dest in the range of Rdest. The sizes of the two regions must match.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.isassigned",
    "page": "Arrays",
    "title": "Base.isassigned",
    "category": "Function",
    "text": "isassigned(array, i) -> Bool\n\nTests whether the given array has a value associated with index i. Returns false if the index is out of bounds, or has an undefined reference.\n\njulia> isassigned(rand(3, 3), 5)\ntrue\n\njulia> isassigned(rand(3, 3), 3 * 3 + 1)\nfalse\n\njulia> mutable struct Foo end\n\njulia> v = similar(rand(3), Foo)\n3-element Array{Foo,1}:\n #undef\n #undef\n #undef\n\njulia> isassigned(v, 1)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.Colon",
    "page": "Arrays",
    "title": "Base.Colon",
    "category": "Type",
    "text": "Colon()\n\nColons (:) are used to signify indexing entire objects or dimensions at once.\n\nVery few operations are defined on Colons directly; instead they are converted by to_indices to an internal vector type (Base.Slice) to represent the collection of indices they span before being used.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.IteratorsMD.CartesianIndex",
    "page": "Arrays",
    "title": "Base.IteratorsMD.CartesianIndex",
    "category": "Type",
    "text": "CartesianIndex(i, j, k...)   -> I\nCartesianIndex((i, j, k...)) -> I\n\nCreate a multidimensional index I, which can be used for indexing a multidimensional array A.  In particular, A[I] is equivalent to A[i,j,k...].  One can freely mix integer and CartesianIndex indices; for example, A[Ipre, i, Ipost] (where Ipre and Ipost are CartesianIndex indices and i is an Int) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.\n\nA CartesianIndex is sometimes produced by eachindex, and always when iterating with an explicit CartesianRange.\n\nExample\n\njulia> A = reshape(collect(1:16), (2, 2, 2, 2))\n2×2×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> A[CartesianIndex((1, 1, 1, 1))]\n1\n\njulia> A[CartesianIndex((1, 1, 1, 2))]\n9\n\njulia> A[CartesianIndex((1, 1, 2, 1))]\n5\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.IteratorsMD.CartesianRange",
    "page": "Arrays",
    "title": "Base.IteratorsMD.CartesianRange",
    "category": "Type",
    "text": "CartesianRange(Istart::CartesianIndex, Istop::CartesianIndex) -> R\nCartesianRange(sz::Dims) -> R\nCartesianRange(istart:istop, jstart:jstop, ...) -> R\n\nDefine a region R spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where for I in R ... end will return CartesianIndex indices I equivalent to the nested loops\n\nfor j = jstart:jstop\n    for i = istart:istop\n        ...\n    end\nend\n\nConsequently these can be useful for writing algorithms that work in arbitrary dimensions.\n\njulia> foreach(println, CartesianRange((2, 2, 2)))\nCartesianIndex{3}((1, 1, 1))\nCartesianIndex{3}((2, 1, 1))\nCartesianIndex{3}((1, 2, 1))\nCartesianIndex{3}((2, 2, 1))\nCartesianIndex{3}((1, 1, 2))\nCartesianIndex{3}((2, 1, 2))\nCartesianIndex{3}((1, 2, 2))\nCartesianIndex{3}((2, 2, 2))\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.to_indices",
    "page": "Arrays",
    "title": "Base.to_indices",
    "category": "Function",
    "text": "to_indices(A, I::Tuple)\n\nConvert the tuple I to a tuple of indices for use in indexing into array A.\n\nThe returned tuple must only contain either Ints or AbstractArrays of scalar indices that are supported by array A. It will error upon encountering a novel index type that it does not know how to process.\n\nFor simple index types, it defers to the unexported Base.to_index(A, i) to process each index i. While this internal function is not intended to be called directly, Base.to_index may be extended by custom array or index types to provide custom indexing behaviors.\n\nMore complicated index types may require more context about the dimension into which they index. To support those cases, to_indices(A, I) calls to_indices(A, indices(A), I), which then recursively walks through both the given tuple of indices and the dimensional indices of A in tandem. As such, not all index types are guaranteed to propagate to Base.to_index.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.checkbounds",
    "page": "Arrays",
    "title": "Base.checkbounds",
    "category": "Function",
    "text": "checkbounds(Bool, A, I...)\n\nReturn true if the specified indices I are in bounds for the given array A. Subtypes of AbstractArray should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on A's indices and checkindex.\n\nSee also checkindex.\n\njulia> A = rand(3, 3);\n\njulia> checkbounds(Bool, A, 2)\ntrue\n\njulia> checkbounds(Bool, A, 3, 4)\nfalse\n\njulia> checkbounds(Bool, A, 1:3)\ntrue\n\njulia> checkbounds(Bool, A, 1:3, 2:4)\nfalse\n\n\n\ncheckbounds(A, I...)\n\nThrow an error if the specified indices I are not in bounds for the given array A.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.checkindex",
    "page": "Arrays",
    "title": "Base.checkindex",
    "category": "Function",
    "text": "checkindex(Bool, inds::AbstractUnitRange, index)\n\nReturn true if the given index is within the bounds of inds. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.\n\njulia> checkindex(Bool,1:20,8)\ntrue\n\njulia> checkindex(Bool,1:20,21)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Indexación-y-Asignación-1",
    "page": "Arrays",
    "title": "Indexación y Asignación",
    "category": "section",
    "text": "Base.getindex(::AbstractArray, ::Any...)\nBase.setindex!(::AbstractArray, ::Any, ::Any...)\nBase.copy!(::AbstractArray, ::CartesianRange, ::AbstractArray, ::CartesianRange)\nBase.isassigned\nBase.Colon\nBase.CartesianIndex\nBase.CartesianRange\nBase.to_indices\nBase.checkbounds\nBase.checkindex"
},

{
    "location": "stdlib/arrays.html#Base.view",
    "page": "Arrays",
    "title": "Base.view",
    "category": "Function",
    "text": "view(A, inds...)\n\nLike getindex, but returns a view into the parent array A with the given indices instead of making a copy.  Calling getindex or setindex! on the returned SubArray computes the indices to the parent array on the fly without checking bounds.\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = view(A, :, 1)\n2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:\n 0\n 0\n\njulia> A # Note A has changed even though we modified b\n2×2 Array{Int64,2}:\n 0  2\n 0  4\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.@view",
    "page": "Arrays",
    "title": "Base.@view",
    "category": "Macro",
    "text": "@view A[inds...]\n\nCreates a SubArray from an indexing expression. This can only be applied directly to a reference expression (e.g. @view A[1,2:end]), and should not be used as the target of an assignment (e.g. @view(A[1,2:end]) = ...).  See also @views to switch an entire block of code to use views for slicing.\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = @view A[:, 1]\n2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:\n 0\n 0\n\njulia> A\n2×2 Array{Int64,2}:\n 0  2\n 0  4\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.@views",
    "page": "Arrays",
    "title": "Base.@views",
    "category": "Macro",
    "text": "@views expression\n\nConvert every array-slicing operation in the given expression (which may be a begin/end block, loop, function, etc.) to return a view.   Scalar indices, non-array types, and explicit getindex calls (as opposed to array[...]) are unaffected.\n\nNote that the @views macro only affects array[...] expressions that appear explicitly in the given expression, not array slicing that occurs in functions called by that code.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.parent",
    "page": "Arrays",
    "title": "Base.parent",
    "category": "Function",
    "text": "parent(A)\n\nReturns the \"parent array\" of an array view type (e.g., SubArray), or the array itself if it is not a view.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.parentindexes",
    "page": "Arrays",
    "title": "Base.parentindexes",
    "category": "Function",
    "text": "parentindexes(A)\n\nFrom an array view A, returns the corresponding indexes in the parent.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.slicedim",
    "page": "Arrays",
    "title": "Base.slicedim",
    "category": "Function",
    "text": "slicedim(A, d::Integer, i)\n\nReturn all the data of A where the index for dimension d equals i. Equivalent to A[:,:,...,i,:,:,...] where i is in position d.\n\nExample\n\njulia> A = [1 2 3 4; 5 6 7 8]\n2×4 Array{Int64,2}:\n 1  2  3  4\n 5  6  7  8\n\njulia> slicedim(A,2,3)\n2-element Array{Int64,1}:\n 3\n 7\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.reinterpret",
    "page": "Arrays",
    "title": "Base.reinterpret",
    "category": "Function",
    "text": "reinterpret(type, A)\n\nChange the type-interpretation of a block of memory. For arrays, this constructs an array with the same binary data as the given array, but with the specified element type. For example, reinterpret(Float32, UInt32(7)) interprets the 4 bytes corresponding to UInt32(7) as a Float32.\n\nwarning: Warning\nIt is not allowed to reinterpret an array to an element type with a larger alignment then the alignment of the array. For a normal Array, this is the alignment of its element type. For a reinterpreted array, this is the alignment of the Array it was reinterpreted from. For example, reinterpret(UInt32, UInt8[0, 0, 0, 0]) is not allowed but reinterpret(UInt32, reinterpret(UInt8, Float32[1.0])) is allowed.\n\nExamples\n\njulia> reinterpret(Float32, UInt32(7))\n1.0f-44\n\njulia> reinterpret(Float32, UInt32[1 2 3 4 5])\n1×5 Array{Float32,2}:\n 1.4013f-45  2.8026f-45  4.2039f-45  5.60519f-45  7.00649f-45\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.reshape",
    "page": "Arrays",
    "title": "Base.reshape",
    "category": "Function",
    "text": "reshape(A, dims...) -> R\nreshape(A, dims) -> R\n\nReturn an array R with the same data as A, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that setting elements of R alters the values of A and vice versa.\n\nThe new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a :, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array A. The total number of elements must not change.\n\njulia> A = collect(1:16)\n16-element Array{Int64,1}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n\njulia> reshape(A, (4, 4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reshape(A, 2, :)\n2×8 Array{Int64,2}:\n 1  3  5  7   9  11  13  15\n 2  4  6  8  10  12  14  16\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.squeeze",
    "page": "Arrays",
    "title": "Base.squeeze",
    "category": "Function",
    "text": "squeeze(A, dims)\n\nRemove the dimensions specified by dims from array A. Elements of dims must be unique and within the range 1:ndims(A). size(A,i) must equal 1 for all i in dims.\n\nExample\n\njulia> a = reshape(collect(1:4),(2,2,1,1))\n2×2×1×1 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\njulia> squeeze(a,3)\n2×2×1 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.vec",
    "page": "Arrays",
    "title": "Base.vec",
    "category": "Function",
    "text": "vec(a::AbstractArray) -> Vector\n\nReshape the array a as a one-dimensional column vector. The resulting array shares the same underlying data as a, so modifying one will also modify the other.\n\nExample\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> vec(a)\n6-element Array{Int64,1}:\n 1\n 4\n 2\n 5\n 3\n 6\n\nSee also reshape.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Vistas-(SubArrays-y-otros-tipos-de-vistas)-1",
    "page": "Arrays",
    "title": "Vistas (SubArrays y otros tipos de vistas)",
    "category": "section",
    "text": "Base.view\nBase.@view\nBase.@views\nBase.parent\nBase.parentindexes\nBase.slicedim\nBase.reinterpret\nBase.reshape\nBase.squeeze\nBase.vec"
},

{
    "location": "stdlib/arrays.html#Base.cat",
    "page": "Arrays",
    "title": "Base.cat",
    "category": "Function",
    "text": "cat(dims, A...)\n\nConcatenate the input arrays along the specified dimensions in the iterable dims. For dimensions not in dims, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in dims, the size of the output array is the sum of the sizes of the input arrays along that dimension. If dims is a single number, the different arrays are tightly stacked along that dimension. If dims is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, cat([1,2], matrices...) builds a block diagonal matrix, i.e. a block matrix with matrices[1], matrices[2], ... as diagonal blocks and matching zero blocks away from the diagonal.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.vcat",
    "page": "Arrays",
    "title": "Base.vcat",
    "category": "Function",
    "text": "vcat(A...)\n\nConcatenate along dimension 1.\n\njulia> a = [1 2 3 4 5]\n1×5 Array{Int64,2}:\n 1  2  3  4  5\n\njulia> b = [6 7 8 9 10; 11 12 13 14 15]\n2×5 Array{Int64,2}:\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> vcat(a,b)\n3×5 Array{Int64,2}:\n  1   2   3   4   5\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> c = ([1 2 3], [4 5 6])\n([1 2 3], [4 5 6])\n\njulia> vcat(c...)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.hcat",
    "page": "Arrays",
    "title": "Base.hcat",
    "category": "Function",
    "text": "hcat(A...)\n\nConcatenate along dimension 2.\n\njulia> a = [1; 2; 3; 4; 5]\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> b = [6 7; 8 9; 10 11; 12 13; 14 15]\n5×2 Array{Int64,2}:\n  6   7\n  8   9\n 10  11\n 12  13\n 14  15\n\njulia> hcat(a,b)\n5×3 Array{Int64,2}:\n 1   6   7\n 2   8   9\n 3  10  11\n 4  12  13\n 5  14  15\n\njulia> c = ([1; 2; 3], [4; 5; 6])\n([1, 2, 3], [4, 5, 6])\n\njulia> hcat(c...)\n3×2 Array{Int64,2}:\n 1  4\n 2  5\n 3  6\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.hvcat",
    "page": "Arrays",
    "title": "Base.hvcat",
    "category": "Function",
    "text": "hvcat(rows::Tuple{Vararg{Int}}, values...)\n\nHorizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.\n\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\n(1, 2, 3, 4, 5, 6)\n\njulia> [a b c; d e f]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> hvcat((3,3), a,b,c,d,e,f)\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> [a b;c d; e f]\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n\njulia> hvcat((2,2,2), a,b,c,d,e,f)\n3×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n\nIf the first argument is a single integer n, then all block rows are assumed to have n block columns.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.flipdim",
    "page": "Arrays",
    "title": "Base.flipdim",
    "category": "Function",
    "text": "flipdim(A, d::Integer)\n\nReverse A in dimension d.\n\nExample\n\njulia> b = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> flipdim(b,2)\n2×2 Array{Int64,2}:\n 2  1\n 4  3\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.circshift",
    "page": "Arrays",
    "title": "Base.circshift",
    "category": "Function",
    "text": "circshift(A, shifts)\n\nCircularly shift the data in an array. The second argument is a vector giving the amount to shift in each dimension.\n\nExample\n\njulia> b = reshape(collect(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> circshift(b, (0,2))\n4×4 Array{Int64,2}:\n  9  13  1  5\n 10  14  2  6\n 11  15  3  7\n 12  16  4  8\n\njulia> circshift(b, (-1,0))\n4×4 Array{Int64,2}:\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n 1  5   9  13\n\nSee also circshift!.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.circshift!",
    "page": "Arrays",
    "title": "Base.circshift!",
    "category": "Function",
    "text": "circshift!(dest, src, shifts)\n\nCircularly shift the data in src, storing the result in dest. shifts specifies the amount to shift in each dimension.\n\nThe dest array must be distinct from the src array (they cannot alias each other).\n\nSee also circshift.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.circcopy!",
    "page": "Arrays",
    "title": "Base.circcopy!",
    "category": "Function",
    "text": "circcopy!(dest, src)\n\nCopy src to dest, indexing each dimension modulo its length. src and dest must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap dest agrees with src.\n\nExample\n\njulia> src = reshape(collect(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> dest = OffsetArray{Int}((0:3,2:5))\n\njulia> circcopy!(dest, src)\nOffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:\n 8  12  16  4\n 5   9  13  1\n 6  10  14  2\n 7  11  15  3\n\njulia> dest[1:3,2:4] == src[1:3,2:4]\ntrue\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.contains-Tuple{Function,Any,Any}",
    "page": "Arrays",
    "title": "Base.contains",
    "category": "Method",
    "text": "contains(fun, itr, x) -> Bool\n\nReturns true if there is at least one element y in itr such that fun(y,x) is true.\n\njulia> vec = [10, 100, 200]\n3-element Array{Int64,1}:\n  10\n 100\n 200\n\njulia> contains(==, vec, 200)\ntrue\n\njulia> contains(==, vec, 300)\nfalse\n\njulia> contains(>, vec, 100)\ntrue\n\njulia> contains(>, vec, 200)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.find-Tuple{Any}",
    "page": "Arrays",
    "title": "Base.find",
    "category": "Method",
    "text": "find(A)\n\nReturn a vector of the linear indexes of the non-zeros in A (determined by A[i]!=0). A common use of this is to convert a boolean array to an array of indexes of the true elements. If there are no non-zero elements of A, find returns an empty array.\n\nExamples\n\njulia> A = [true false; false true]\n2×2 Array{Bool,2}:\n  true  false\n false   true\n\njulia> find(A)\n2-element Array{Int64,1}:\n 1\n 4\n\njulia> find(zeros(3))\n0-element Array{Int64,1}\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.find-Tuple{Function,Any}",
    "page": "Arrays",
    "title": "Base.find",
    "category": "Method",
    "text": "find(f::Function, A)\n\nReturn a vector I of the linear indexes of A where f(A[I]) returns true. If there are no such elements of A, find returns an empty array.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> find(isodd,A)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> find(isodd, [2, 4])\n0-element Array{Int64,1}\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findn",
    "page": "Arrays",
    "title": "Base.findn",
    "category": "Function",
    "text": "findn(A)\n\nReturn a vector of indexes for each dimension giving the locations of the non-zeros in A (determined by A[i]!=0). If there are no non-zero elements of A, findn returns a 2-tuple of empty arrays.\n\nExamples\n\njulia> A = [1 2 0; 0 0 3; 0 4 0]\n3×3 Array{Int64,2}:\n 1  2  0\n 0  0  3\n 0  4  0\n\njulia> findn(A)\n([1, 1, 3, 2], [1, 2, 2, 3])\n\njulia> A = zeros(2,2)\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\njulia> findn(A)\n(Int64[], Int64[])\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findnz",
    "page": "Arrays",
    "title": "Base.findnz",
    "category": "Function",
    "text": "findnz(A)\n\nReturn a tuple (I, J, V) where I and J are the row and column indexes of the non-zero values in matrix A, and V is a vector of the non-zero values.\n\nExample\n\njulia> A = [1 2 0; 0 0 3; 0 4 0]\n3×3 Array{Int64,2}:\n 1  2  0\n 0  0  3\n 0  4  0\n\njulia> findnz(A)\n([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findfirst-Tuple{Any}",
    "page": "Arrays",
    "title": "Base.findfirst",
    "category": "Method",
    "text": "findfirst(A)\n\nReturn the linear index of the first non-zero value in A (determined by A[i]!=0). Returns 0 if no such value is found.\n\nExamples\n\njulia> A = [0 0; 1 0]\n2×2 Array{Int64,2}:\n 0  0\n 1  0\n\njulia> findfirst(A)\n2\n\njulia> findfirst(zeros(3))\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findfirst-Tuple{Any,Any}",
    "page": "Arrays",
    "title": "Base.findfirst",
    "category": "Method",
    "text": "findfirst(A, v)\n\nReturn the linear index of the first element equal to v in A. Returns 0 if v is not found.\n\nExamples\n\njulia> A = [4 6; 2 2]\n2×2 Array{Int64,2}:\n 4  6\n 2  2\n\njulia> findfirst(A,2)\n2\n\njulia> findfirst(A,3)\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findfirst-Tuple{Function,Any}",
    "page": "Arrays",
    "title": "Base.findfirst",
    "category": "Method",
    "text": "findfirst(predicate::Function, A)\n\nReturn the linear index of the first element of A for which predicate returns true. Returns 0 if there is no such element.\n\nExamples\n\njulia> A = [1 4; 2 2]\n2×2 Array{Int64,2}:\n 1  4\n 2  2\n\njulia> findfirst(iseven, A)\n2\n\njulia> findfirst(x -> x>10, A)\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findlast-Tuple{Any}",
    "page": "Arrays",
    "title": "Base.findlast",
    "category": "Method",
    "text": "findlast(A)\n\nReturn the linear index of the last non-zero value in A (determined by A[i]!=0). Returns 0 if there is no non-zero value in A.\n\nExamples\n\njulia> A = [1 0; 1 0]\n2×2 Array{Int64,2}:\n 1  0\n 1  0\n\njulia> findlast(A)\n2\n\njulia> A = zeros(2,2)\n2×2 Array{Float64,2}:\n 0.0  0.0\n 0.0  0.0\n\njulia> findlast(A)\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findlast-Tuple{Any,Any}",
    "page": "Arrays",
    "title": "Base.findlast",
    "category": "Method",
    "text": "findlast(A, v)\n\nReturn the linear index of the last element equal to v in A. Returns 0 if there is no element of A equal to v.\n\nExamples\n\njulia> A = [1 2; 2 1]\n2×2 Array{Int64,2}:\n 1  2\n 2  1\n\njulia> findlast(A,1)\n4\n\njulia> findlast(A,2)\n3\n\njulia> findlast(A,3)\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findlast-Tuple{Function,Any}",
    "page": "Arrays",
    "title": "Base.findlast",
    "category": "Method",
    "text": "findlast(predicate::Function, A)\n\nReturn the linear index of the last element of A for which predicate returns true. Returns 0 if there is no such element.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> findlast(isodd, A)\n2\n\njulia> findlast(x -> x > 5, A)\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findnext-Tuple{Any,Integer}",
    "page": "Arrays",
    "title": "Base.findnext",
    "category": "Method",
    "text": "findnext(A, i::Integer)\n\nFind the next linear index >= i of a non-zero element of A, or 0 if not found.\n\nExamples\n\njulia> A = [0 0; 1 0]\n2×2 Array{Int64,2}:\n 0  0\n 1  0\n\njulia> findnext(A,1)\n2\n\njulia> findnext(A,3)\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findnext-Tuple{Function,Any,Integer}",
    "page": "Arrays",
    "title": "Base.findnext",
    "category": "Method",
    "text": "findnext(predicate::Function, A, i::Integer)\n\nFind the next linear index >= i of an element of A for which predicate returns true, or 0 if not found.\n\nExamples\n\njulia> A = [1 4; 2 2]\n2×2 Array{Int64,2}:\n 1  4\n 2  2\n\njulia> findnext(isodd, A, 1)\n1\n\njulia> findnext(isodd, A, 2)\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findnext-Tuple{Any,Any,Integer}",
    "page": "Arrays",
    "title": "Base.findnext",
    "category": "Method",
    "text": "findnext(A, v, i::Integer)\n\nFind the next linear index >= i of an element of A equal to v (using ==), or 0 if not found.\n\nExamples\n\njulia> A = [1 4; 2 2]\n2×2 Array{Int64,2}:\n 1  4\n 2  2\n\njulia> findnext(A,4,4)\n0\n\njulia> findnext(A,4,3)\n3\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findprev-Tuple{Any,Integer}",
    "page": "Arrays",
    "title": "Base.findprev",
    "category": "Method",
    "text": "findprev(A, i::Integer)\n\nFind the previous linear index <= i of a non-zero element of A, or 0 if not found.\n\nExamples\n\njulia> A = [0 0; 1 2]\n2×2 Array{Int64,2}:\n 0  0\n 1  2\n\njulia> findprev(A,2)\n2\n\njulia> findprev(A,1)\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findprev-Tuple{Function,Any,Integer}",
    "page": "Arrays",
    "title": "Base.findprev",
    "category": "Method",
    "text": "findprev(predicate::Function, A, i::Integer)\n\nFind the previous linear index <= i of an element of A for which predicate returns true, or 0 if not found.\n\nExamples\n\njulia> A = [4 6; 1 2]\n2×2 Array{Int64,2}:\n 4  6\n 1  2\n\njulia> findprev(isodd, A, 1)\n0\n\njulia> findprev(isodd, A, 3)\n2\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.findprev-Tuple{Any,Any,Integer}",
    "page": "Arrays",
    "title": "Base.findprev",
    "category": "Method",
    "text": "findprev(A, v, i::Integer)\n\nFind the previous linear index <= i of an element of A equal to v (using ==), or 0 if not found.\n\nExamples\n\njulia> A = [0 0; 1 2]\n2×2 Array{Int64,2}:\n 0  0\n 1  2\n\njulia> findprev(A, 1, 4)\n2\n\njulia> findprev(A, 1, 1)\n0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.permutedims",
    "page": "Arrays",
    "title": "Base.permutedims",
    "category": "Function",
    "text": "permutedims(A, perm)\n\nPermute the dimensions of array A. perm is a vector specifying a permutation of length ndims(A). This is a generalization of transpose for multi-dimensional arrays. Transpose is equivalent to permutedims(A, [2,1]).\n\nSee also: PermutedDimsArray.\n\nExample\n\njulia> A = reshape(collect(1:8), (2,2,2))\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\njulia> permutedims(A, [3, 2, 1])\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 5  7\n\n[:, :, 2] =\n 2  4\n 6  8\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.permutedims!",
    "page": "Arrays",
    "title": "Base.permutedims!",
    "category": "Function",
    "text": "permutedims!(dest, src, perm)\n\nPermute the dimensions of array src and store the result in the array dest. perm is a vector specifying a permutation of length ndims(src). The preallocated array dest should have size(dest) == size(src)[perm] and is completely overwritten. No in-place permutation is supported and unexpected results will happen if src and dest have overlapping memory regions.\n\nSee also permutedims.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.PermutedDimsArrays.PermutedDimsArray",
    "page": "Arrays",
    "title": "Base.PermutedDimsArrays.PermutedDimsArray",
    "category": "Type",
    "text": "PermutedDimsArray(A, perm) -> B\n\nGiven an AbstractArray A, create a view B such that the dimensions appear to be permuted. Similar to permutedims, except that no copying occurs (B shares storage with A).\n\nSee also: permutedims.\n\nExample\n\njulia> A = rand(3,5,4);\n\njulia> B = PermutedDimsArray(A, (3,1,2));\n\njulia> size(B)\n(4, 3, 5)\n\njulia> B[3,1,2] == A[1,2,3]\ntrue\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.promote_shape",
    "page": "Arrays",
    "title": "Base.promote_shape",
    "category": "Function",
    "text": "promote_shape(s1, s2)\n\nCheck two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.\n\njulia> a = ones(3,4,1,1,1);\n\njulia> b = ones(3,4);\n\njulia> promote_shape(a,b)\n(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))\n\njulia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))\n(2, 3, 1, 4, 1)\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Concatenación-y-permutación-1",
    "page": "Arrays",
    "title": "Concatenación y permutación",
    "category": "section",
    "text": "Base.cat\nBase.vcat\nBase.hcat\nBase.hvcat\nBase.flipdim\nBase.circshift\nBase.circshift!\nBase.circcopy!\nBase.contains(::Function, ::Any, ::Any)\nBase.find(::Any)\nBase.find(::Function, ::Any)\nBase.findn\nBase.findnz\nBase.findfirst(::Any)\nBase.findfirst(::Any, ::Any)\nBase.findfirst(::Function, ::Any)\nBase.findlast(::Any)\nBase.findlast(::Any, ::Any)\nBase.findlast(::Function, ::Any)\nBase.findnext(::Any, ::Integer)\nBase.findnext(::Function, ::Any, ::Integer)\nBase.findnext(::Any, ::Any, ::Integer)\nBase.findprev(::Any, ::Integer)\nBase.findprev(::Function, ::Any, ::Integer)\nBase.findprev(::Any, ::Any, ::Integer)\nBase.permutedims\nBase.permutedims!\nBase.PermutedDimsArray\nBase.promote_shape"
},

{
    "location": "stdlib/arrays.html#Base.accumulate-Tuple{Any,Any,Integer}",
    "page": "Arrays",
    "title": "Base.accumulate",
    "category": "Method",
    "text": "accumulate(op, A, dim=1)\n\nCumulative operation op along a dimension dim (defaults to 1). See also accumulate! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of accumulate, see: cumsum, cumprod\n\njulia> accumulate(+, [1,2,3])\n3-element Array{Int64,1}:\n 1\n 3\n 6\n\njulia> accumulate(*, [1,2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 6\n\n\n\naccumulate(op, v0, A)\n\nLike accumulate, but using a starting element v0. The first entry of the result will be op(v0, first(A)). For example:\n\njulia> accumulate(+, 100, [1,2,3])\n3-element Array{Int64,1}:\n 101\n 103\n 106\n\njulia> accumulate(min, 0, [1,2,-1])\n3-element Array{Int64,1}:\n  0\n  0\n -1\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.accumulate!",
    "page": "Arrays",
    "title": "Base.accumulate!",
    "category": "Function",
    "text": "accumulate!(op, B, A, dim=1)\n\nCumulative operation op on A along a dimension, storing the result in B. The dimension defaults to 1. See also accumulate.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.cumprod",
    "page": "Arrays",
    "title": "Base.cumprod",
    "category": "Function",
    "text": "cumprod(A, dim=1)\n\nCumulative product along a dimension dim (defaults to 1). See also cumprod! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> cumprod(a,1)\n2×3 Array{Int64,2}:\n 1   2   3\n 4  10  18\n\njulia> cumprod(a,2)\n2×3 Array{Int64,2}:\n 1   2    6\n 4  20  120\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.cumprod!",
    "page": "Arrays",
    "title": "Base.cumprod!",
    "category": "Function",
    "text": "cumprod!(B, A, dim::Integer=1)\n\nCumulative product of A along a dimension, storing the result in B. The dimension defaults to 1. See also cumprod.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.cumsum",
    "page": "Arrays",
    "title": "Base.cumsum",
    "category": "Function",
    "text": "cumsum(A, dim=1)\n\nCumulative sum along a dimension dim (defaults to 1). See also cumsum! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n\njulia> cumsum(a,1)\n2×3 Array{Int64,2}:\n 1  2  3\n 5  7  9\n\njulia> cumsum(a,2)\n2×3 Array{Int64,2}:\n 1  3   6\n 4  9  15\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.cumsum!",
    "page": "Arrays",
    "title": "Base.cumsum!",
    "category": "Function",
    "text": "cumsum!(B, A, dim::Integer=1)\n\nCumulative sum of A along a dimension, storing the result in B. The dimension defaults to 1. See also cumsum.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.cumsum_kbn",
    "page": "Arrays",
    "title": "Base.cumsum_kbn",
    "category": "Function",
    "text": "cumsum_kbn(A, [dim::Integer=1])\n\nCumulative sum along a dimension, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy. The dimension defaults to 1.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.LinAlg.diff",
    "page": "Arrays",
    "title": "Base.LinAlg.diff",
    "category": "Function",
    "text": "diff(A, [dim::Integer=1])\n\nFinite difference operator of matrix or vector A. If A is a matrix, compute the finite difference over a dimension dim (default 1).\n\nExample\n\njulia> a = [2 4; 6 16]\n2×2 Array{Int64,2}:\n 2   4\n 6  16\n\njulia> diff(a,2)\n2×1 Array{Int64,2}:\n  2\n 10\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.LinAlg.gradient",
    "page": "Arrays",
    "title": "Base.LinAlg.gradient",
    "category": "Function",
    "text": "gradient(F::AbstractVector, [h::Real])\n\nCompute differences along vector F, using h as the spacing between points. The default spacing is one.\n\nExample\n\njulia> a = [2,4,6,8];\n\njulia> gradient(a)\n4-element Array{Float64,1}:\n 2.0\n 2.0\n 2.0\n 2.0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.rot180",
    "page": "Arrays",
    "title": "Base.rot180",
    "category": "Function",
    "text": "rot180(A)\n\nRotate matrix A 180 degrees.\n\nExample\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rot180(a)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\n\n\nrot180(A, k)\n\nRotate matrix A 180 degrees an integer k number of times. If k is even, this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rot180(a,1)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\njulia> rot180(a,2)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.rotl90",
    "page": "Arrays",
    "title": "Base.rotl90",
    "category": "Function",
    "text": "rotl90(A)\n\nRotate matrix A left 90 degrees.\n\nExample\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotl90(a)\n2×2 Array{Int64,2}:\n 2  4\n 1  3\n\n\n\nrotl90(A, k)\n\nRotate matrix A left 90 degrees an integer k number of times. If k is zero or a multiple of four, this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotl90(a,1)\n2×2 Array{Int64,2}:\n 2  4\n 1  3\n\njulia> rotl90(a,2)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\njulia> rotl90(a,3)\n2×2 Array{Int64,2}:\n 3  1\n 4  2\n\njulia> rotl90(a,4)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.rotr90",
    "page": "Arrays",
    "title": "Base.rotr90",
    "category": "Function",
    "text": "rotr90(A)\n\nRotate matrix A right 90 degrees.\n\nExample\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotr90(a)\n2×2 Array{Int64,2}:\n 3  1\n 4  2\n\n\n\nrotr90(A, k)\n\nRotate matrix A right 90 degrees an integer k number of times. If k is zero or a multiple of four, this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> rotr90(a,1)\n2×2 Array{Int64,2}:\n 3  1\n 4  2\n\njulia> rotr90(a,2)\n2×2 Array{Int64,2}:\n 4  3\n 2  1\n\njulia> rotr90(a,3)\n2×2 Array{Int64,2}:\n 2  4\n 1  3\n\njulia> rotr90(a,4)\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.reducedim",
    "page": "Arrays",
    "title": "Base.reducedim",
    "category": "Function",
    "text": "reducedim(f, A, region[, v0])\n\nReduce 2-argument function f along dimensions of A. region is a vector specifying the dimensions to reduce, and v0 is the initial value to use in the reductions. For +, *, max and min the v0 argument is optional.\n\nThe associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop. See documentation for reduce.\n\nExamples\n\njulia> a = reshape(collect(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reducedim(max, a, 2)\n4×1 Array{Int64,2}:\n 13\n 14\n 15\n 16\n\njulia> reducedim(max, a, 1)\n1×4 Array{Int64,2}:\n 4  8  12  16\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.mapreducedim",
    "page": "Arrays",
    "title": "Base.mapreducedim",
    "category": "Function",
    "text": "mapreducedim(f, op, A, region[, v0])\n\nEvaluates to the same as reducedim(op, map(f, A), region, f(v0)), but is generally faster because the intermediate array is avoided.\n\nExamples\n\njulia> a = reshape(collect(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> mapreducedim(isodd, *, a, 1)\n1×4 Array{Bool,2}:\n false  false  false  false\n\njulia> mapreducedim(isodd, |, a, 1, true)\n1×4 Array{Bool,2}:\n true  true  true  true\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.mapslices",
    "page": "Arrays",
    "title": "Base.mapslices",
    "category": "Function",
    "text": "mapslices(f, A, dims)\n\nTransform the given dimensions of array A using function f. f is called on each slice of A of the form A[...,:,...,:,...]. dims is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if dims is [1,2] and A is 4-dimensional, f is called on A[:,:,i,j] for all i and j.\n\nExamples\n\njulia> a = reshape(collect(1:16),(2,2,2,2))\n2×2×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> mapslices(sum, a, [1,2])\n1×1×2×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 10\n\n[:, :, 2, 1] =\n 26\n\n[:, :, 1, 2] =\n 42\n\n[:, :, 2, 2] =\n 58\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.sum_kbn",
    "page": "Arrays",
    "title": "Base.sum_kbn",
    "category": "Function",
    "text": "sum_kbn(A)\n\nReturns the sum of all elements of A, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Funciones-de-Arrays-1",
    "page": "Arrays",
    "title": "Funciones de Arrays",
    "category": "section",
    "text": "Base.accumulate(::Any, ::Any, ::Integer)\nBase.accumulate!\nBase.cumprod\nBase.cumprod!\nBase.cumsum\nBase.cumsum!\nBase.cumsum_kbn\nBase.LinAlg.diff\nBase.LinAlg.gradient\nBase.rot180\nBase.rotl90\nBase.rotr90\nBase.reducedim\nBase.mapreducedim\nBase.mapslices\nBase.sum_kbn"
},

{
    "location": "stdlib/arrays.html#Base.Random.randperm",
    "page": "Arrays",
    "title": "Base.Random.randperm",
    "category": "Function",
    "text": "randperm([rng=GLOBAL_RNG,] n::Integer)\n\nConstruct a random permutation of length n. The optional rng argument specifies a random number generator (see Random Numbers). To randomly permute a arbitrary vector, see shuffle or shuffle!.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> randperm(rng, 4)\n4-element Array{Int64,1}:\n 2\n 1\n 4\n 3\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.invperm",
    "page": "Arrays",
    "title": "Base.invperm",
    "category": "Function",
    "text": "invperm(v)\n\nReturn the inverse permutation of v. If B = A[v], then A == B[invperm(v)].\n\nExample\n\njulia> v = [2; 4; 3; 1];\n\njulia> invperm(v)\n4-element Array{Int64,1}:\n 4\n 1\n 3\n 2\n\njulia> A = ['a','b','c','d'];\n\njulia> B = A[v]\n4-element Array{Char,1}:\n 'b'\n 'd'\n 'c'\n 'a'\n\njulia> B[invperm(v)]\n4-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n 'd'\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.isperm",
    "page": "Arrays",
    "title": "Base.isperm",
    "category": "Function",
    "text": "isperm(v) -> Bool\n\nReturns true if v is a valid permutation.\n\nExamples\n\njulia> isperm([1; 2])\ntrue\n\njulia> isperm([1; 3])\nfalse\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.permute!-Tuple{Any,AbstractArray{T,1} where T}",
    "page": "Arrays",
    "title": "Base.permute!",
    "category": "Method",
    "text": "permute!(v, p)\n\nPermute vector v in-place, according to permutation p. No checking is done to verify that p is a permutation.\n\nTo return a new permutation, use v[p]. Note that this is generally faster than permute!(v,p) for large vectors.\n\nSee also ipermute!.\n\nExample\n\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> permute!(A, perm);\n\njulia> A\n4-element Array{Int64,1}:\n 1\n 4\n 3\n 1\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.ipermute!",
    "page": "Arrays",
    "title": "Base.ipermute!",
    "category": "Function",
    "text": "ipermute!(v, p)\n\nLike permute!, but the inverse of the given permutation is applied.\n\nExample\n\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> ipermute!(A, perm);\n\njulia> A\n4-element Array{Int64,1}:\n 4\n 1\n 3\n 1\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.Random.randcycle",
    "page": "Arrays",
    "title": "Base.Random.randcycle",
    "category": "Function",
    "text": "randcycle([rng=GLOBAL_RNG,] n::Integer)\n\nConstruct a random cyclic permutation of length n. The optional rng argument specifies a random number generator, see Random Numbers.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> randcycle(rng, 6)\n6-element Array{Int64,1}:\n 3\n 5\n 4\n 6\n 1\n 2\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.Random.shuffle",
    "page": "Arrays",
    "title": "Base.Random.shuffle",
    "category": "Function",
    "text": "shuffle([rng=GLOBAL_RNG,] v)\n\nReturn a randomly permuted copy of v. The optional rng argument specifies a random number generator (see Random Numbers). To permute v in-place, see shuffle!.  To obtain randomly permuted indices, see randperm.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> shuffle(rng, collect(1:10))\n10-element Array{Int64,1}:\n  6\n  1\n 10\n  2\n  3\n  9\n  5\n  7\n  4\n  8\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.Random.shuffle!",
    "page": "Arrays",
    "title": "Base.Random.shuffle!",
    "category": "Function",
    "text": "shuffle!([rng=GLOBAL_RNG,] v)\n\nIn-place version of shuffle: randomly permute the array v in-place, optionally supplying the random-number generator rng.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> shuffle!(rng, collect(1:16))\n16-element Array{Int64,1}:\n  2\n 15\n  5\n 14\n  1\n  9\n 10\n  6\n 11\n  3\n 16\n  7\n  4\n 12\n  8\n 13\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.reverse",
    "page": "Arrays",
    "title": "Base.reverse",
    "category": "Function",
    "text": "reverse(v [, start=1 [, stop=length(v) ]] )\n\nReturn a copy of v reversed from start to stop.\n\nExamples\n\njulia> A = collect(1:5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\njulia> reverse(A)\n5-element Array{Int64,1}:\n 5\n 4\n 3\n 2\n 1\n\njulia> reverse(A, 1, 4)\n5-element Array{Int64,1}:\n 4\n 3\n 2\n 1\n 5\n\njulia> reverse(A, 3, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 5\n 4\n 3\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.reverseind",
    "page": "Arrays",
    "title": "Base.reverseind",
    "category": "Function",
    "text": "reverseind(v, i)\n\nGiven an index i in reverse(v), return the corresponding index in v so that v[reverseind(v,i)] == reverse(v)[i]. (This can be nontrivial in the case where v is a Unicode string.)\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.reverse!",
    "page": "Arrays",
    "title": "Base.reverse!",
    "category": "Function",
    "text": "reverse!(v [, start=1 [, stop=length(v) ]]) -> v\n\nIn-place version of reverse.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Combinatoria-1",
    "page": "Arrays",
    "title": "Combinatoria",
    "category": "section",
    "text": "Base.Random.randperm\nBase.invperm\nBase.isperm\nBase.permute!(::Any, ::AbstractVector)\nBase.ipermute!\nBase.Random.randcycle\nBase.Random.shuffle\nBase.Random.shuffle!\nBase.reverse\nBase.reverseind\nBase.reverse!"
},

{
    "location": "stdlib/arrays.html#Base.flipbits!",
    "page": "Arrays",
    "title": "Base.flipbits!",
    "category": "Function",
    "text": "flipbits!(B::BitArray{N}) -> BitArray{N}\n\nPerforms a bitwise not operation on B. See ~.\n\nExample\n\njulia> A = trues(2,2)\n2×2 BitArray{2}:\n true  true\n true  true\n\njulia> flipbits!(A)\n2×2 BitArray{2}:\n false  false\n false  false\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.rol!",
    "page": "Arrays",
    "title": "Base.rol!",
    "category": "Function",
    "text": "rol!(dest::BitVector, src::BitVector, i::Integer) -> BitVector\n\nPerforms a left rotation operation on src and puts the result into dest. i controls how far to rotate the bits.\n\n\n\nrol!(B::BitVector, i::Integer) -> BitVector\n\nPerforms a left rotation operation in-place on B. i controls how far to rotate the bits.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.rol",
    "page": "Arrays",
    "title": "Base.rol",
    "category": "Function",
    "text": "rol(B::BitVector, i::Integer) -> BitVector\n\nPerforms a left rotation operation, returning a new BitVector. i controls how far to rotate the bits. See also rol!.\n\nExamples\n\njulia> A = BitArray([true, true, false, false, true])\n5-element BitArray{1}:\n  true\n  true\n false\n false\n  true\n\njulia> rol(A,1)\n5-element BitArray{1}:\n  true\n false\n false\n  true\n  true\n\njulia> rol(A,2)\n5-element BitArray{1}:\n false\n false\n  true\n  true\n  true\n\njulia> rol(A,5)\n5-element BitArray{1}:\n  true\n  true\n false\n false\n  true\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.ror!",
    "page": "Arrays",
    "title": "Base.ror!",
    "category": "Function",
    "text": "ror!(dest::BitVector, src::BitVector, i::Integer) -> BitVector\n\nPerforms a right rotation operation on src and puts the result into dest. i controls how far to rotate the bits.\n\n\n\nror!(B::BitVector, i::Integer) -> BitVector\n\nPerforms a right rotation operation in-place on B. i controls how far to rotate the bits.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.ror",
    "page": "Arrays",
    "title": "Base.ror",
    "category": "Function",
    "text": "ror(B::BitVector, i::Integer) -> BitVector\n\nPerforms a right rotation operation on B, returning a new BitVector. i controls how far to rotate the bits. See also ror!.\n\nExamples\n\njulia> A = BitArray([true, true, false, false, true])\n5-element BitArray{1}:\n  true\n  true\n false\n false\n  true\n\njulia> ror(A,1)\n5-element BitArray{1}:\n  true\n  true\n  true\n false\n false\n\njulia> ror(A,2)\n5-element BitArray{1}:\n false\n  true\n  true\n  true\n false\n\njulia> ror(A,5)\n5-element BitArray{1}:\n  true\n  true\n false\n false\n  true\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#BitArrays-1",
    "page": "Arrays",
    "title": "BitArrays",
    "category": "section",
    "text": "BitArrays son matrices booleanas \"compactas\" eficientes en el uso del espacio, que almacenan un bit por valor booleano. Se pueden usar de forma similar a los arrays Array{Bool} (que almacenan un byte por valor booleano), y se pueden convertir a/desde este último a través de Array(bitarray) y BitArray(array), respectivamente.Base.flipbits!\nBase.rol!\nBase.rol\nBase.ror!\nBase.ror"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.SparseVector",
    "page": "Arrays",
    "title": "Base.SparseArrays.SparseVector",
    "category": "Type",
    "text": "SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}\n\nVector type for storing sparse vectors.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.SparseMatrixCSC",
    "page": "Arrays",
    "title": "Base.SparseArrays.SparseMatrixCSC",
    "category": "Type",
    "text": "SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}\n\nMatrix type for storing sparse matrices in the Compressed Sparse Column format.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.sparse",
    "page": "Arrays",
    "title": "Base.SparseArrays.sparse",
    "category": "Function",
    "text": "sparse(A)\n\nConvert an AbstractMatrix A into a sparse matrix.\n\nExample\n\njulia> A = eye(3)\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> sparse(A)\n3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n\n\n\nsparse(I, J, V,[ m, n, combine])\n\nCreate a sparse matrix S of dimensions m x n such that S[I[k], J[k]] = V[k]. The combine function is used to combine duplicates. If m and n are not specified, they are set to maximum(I) and maximum(J) respectively. If the combine function is not supplied, combine defaults to + unless the elements of V are Booleans in which case combine defaults to |. All elements of I must satisfy 1 <= I[k] <= m, and all elements of J must satisfy 1 <= J[k] <= n. Numerical zeros in (I, J, V) are retained as structural nonzeros; to drop numerical zeros, use dropzeros!.\n\nFor additional documentation and an expert driver, see Base.SparseArrays.sparse!.\n\nExample\n\njulia> Is = [1; 2; 3];\n\njulia> Js = [1; 2; 3];\n\njulia> Vs = [1; 2; 3];\n\njulia> sparse(Is, Js, Vs)\n3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:\n  [1, 1]  =  1\n  [2, 2]  =  2\n  [3, 3]  =  3\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.sparsevec",
    "page": "Arrays",
    "title": "Base.SparseArrays.sparsevec",
    "category": "Function",
    "text": "sparsevec(I, V, [m, combine])\n\nCreate a sparse vector S of length m such that S[I[k]] = V[k]. Duplicates are combined using the combine function, which defaults to + if no combine argument is provided, unless the elements of V are Booleans in which case combine defaults to |.\n\njulia> II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];\n\njulia> sparsevec(II, V)\n5-element SparseVector{Float64,Int64} with 3 stored entries:\n  [1]  =  0.1\n  [3]  =  0.5\n  [5]  =  0.2\n\njulia> sparsevec(II, V, 8, -)\n8-element SparseVector{Float64,Int64} with 3 stored entries:\n  [1]  =  0.1\n  [3]  =  -0.1\n  [5]  =  0.2\n\njulia> sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])\n3-element SparseVector{Bool,Int64} with 3 stored entries:\n  [1]  =  true\n  [2]  =  false\n  [3]  =  true\n\n\n\nsparsevec(d::Dict, [m])\n\nCreate a sparse vector of length m where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.\n\njulia> sparsevec(Dict(1 => 3, 2 => 2))\n2-element SparseVector{Int64,Int64} with 2 stored entries:\n  [1]  =  3\n  [2]  =  2\n\n\n\nsparsevec(A)\n\nConvert a vector A into a sparse vector of length m.\n\nExample\n\njulia> sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])\n6-element SparseVector{Float64,Int64} with 3 stored entries:\n  [1]  =  1.0\n  [2]  =  2.0\n  [5]  =  3.0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.issparse",
    "page": "Arrays",
    "title": "Base.SparseArrays.issparse",
    "category": "Function",
    "text": "issparse(S)\n\nReturns true if S is sparse, and false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.full",
    "page": "Arrays",
    "title": "Base.full",
    "category": "Function",
    "text": "full(S)\n\nConvert a sparse matrix or vector S into a dense matrix or vector.\n\nExample\n\njulia> A = speye(3)\n3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n\njulia> full(A)\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.nnz",
    "page": "Arrays",
    "title": "Base.SparseArrays.nnz",
    "category": "Function",
    "text": "nnz(A)\n\nReturns the number of stored (filled) elements in a sparse array.\n\nExample\n\njulia> A = speye(3)\n3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n\njulia> nnz(A)\n3\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.spzeros",
    "page": "Arrays",
    "title": "Base.SparseArrays.spzeros",
    "category": "Function",
    "text": "spzeros([type,]m[,n])\n\nCreate a sparse vector of length m or sparse matrix of size m x n. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to Float64 if not specified.\n\nExamples\n\njulia> spzeros(3, 3)\n3×3 SparseMatrixCSC{Float64,Int64} with 0 stored entries\n\njulia> spzeros(Float32, 4)\n4-element SparseVector{Float32,Int64} with 0 stored entries\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.spones",
    "page": "Arrays",
    "title": "Base.SparseArrays.spones",
    "category": "Function",
    "text": "spones(S)\n\nCreate a sparse array with the same structure as that of S, but with every nonzero element having the value 1.0.\n\nExample\n\njulia> A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])\n4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:\n  [4, 1]  =  2.0\n  [1, 2]  =  5.0\n  [3, 3]  =  3.0\n  [2, 4]  =  4.0\n\njulia> spones(A)\n4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:\n  [4, 1]  =  1.0\n  [1, 2]  =  1.0\n  [3, 3]  =  1.0\n  [2, 4]  =  1.0\n\nNote the difference from speye.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.speye-Tuple{Type,Integer,Integer}",
    "page": "Arrays",
    "title": "Base.SparseArrays.speye",
    "category": "Method",
    "text": "speye([type,]m[,n])\n\nCreate a sparse identity matrix of size m x m. When n is supplied, create a sparse identity matrix of size m x n. The type defaults to Float64 if not specified.\n\nsparse(I, m, n) is equivalent to speye(Int, m, n), and sparse(α*I, m, n) can be used to efficiently create a sparse multiple α of the identity matrix.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.speye-Tuple{SparseMatrixCSC}",
    "page": "Arrays",
    "title": "Base.SparseArrays.speye",
    "category": "Method",
    "text": "speye(S)\n\nCreate a sparse identity matrix with the same size as S.\n\nExample\n\njulia> A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])\n4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:\n  [4, 1]  =  2.0\n  [1, 2]  =  5.0\n  [3, 3]  =  3.0\n  [2, 4]  =  4.0\n\njulia> speye(A)\n4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n  [4, 4]  =  1.0\n\nNote the difference from spones.\n\n\n\nspeye([type,]m[,n])\n\nCreate a sparse identity matrix of size m x m. When n is supplied, create a sparse identity matrix of size m x n. The type defaults to Float64 if not specified.\n\nsparse(I, m, n) is equivalent to speye(Int, m, n), and sparse(α*I, m, n) can be used to efficiently create a sparse multiple α of the identity matrix.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.spdiagm",
    "page": "Arrays",
    "title": "Base.SparseArrays.spdiagm",
    "category": "Function",
    "text": "spdiagm(B, d[, m, n])\n\nConstruct a sparse diagonal matrix. B is a tuple of vectors containing the diagonals and d is a tuple containing the positions of the diagonals. In the case the input contains only one diagonal, B can be a vector (instead of a tuple) and d can be the diagonal position (instead of a tuple), defaulting to 0 (diagonal). Optionally, m and n specify the size of the resulting sparse matrix.\n\nExample\n\njulia> spdiagm(([1,2,3,4],[4,3,2,1]),(-1,1))\n5×5 SparseMatrixCSC{Int64,Int64} with 8 stored entries:\n  [2, 1]  =  1\n  [1, 2]  =  4\n  [3, 2]  =  2\n  [2, 3]  =  3\n  [4, 3]  =  3\n  [3, 4]  =  2\n  [5, 4]  =  4\n  [4, 5]  =  1\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.sprand",
    "page": "Arrays",
    "title": "Base.SparseArrays.sprand",
    "category": "Function",
    "text": "sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])\n\nCreate a random length m sparse vector or m by n sparse matrix, in which the probability of any element being nonzero is independently given by p (and hence the mean density of nonzeros is also exactly p). Nonzero values are sampled from the distribution specified by rfn and have the type type. The uniform distribution is used in case rfn is not specified. The optional rng argument specifies a random number generator, see Random Numbers.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> sprand(rng, Bool, 2, 2, 0.5)\n2×2 SparseMatrixCSC{Bool,Int64} with 2 stored entries:\n  [1, 1]  =  true\n  [2, 1]  =  true\n\njulia> sprand(rng, Float64, 3, 0.75)\n3-element SparseVector{Float64,Int64} with 1 stored entry:\n  [3]  =  0.298614\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.sprandn",
    "page": "Arrays",
    "title": "Base.SparseArrays.sprandn",
    "category": "Function",
    "text": "sprandn([rng], m[,n],p::AbstractFloat)\n\nCreate a random sparse vector of length m or sparse matrix of size m by n with the specified (independent) probability p of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional rng argument specifies a random number generator, see Random Numbers.\n\nExample\n\njulia> rng = MersenneTwister(1234);\n\njulia> sprandn(rng, 2, 2, 0.75)\n2×2 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  0.532813\n  [2, 1]  =  -0.271735\n  [2, 2]  =  0.502334\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.nonzeros",
    "page": "Arrays",
    "title": "Base.SparseArrays.nonzeros",
    "category": "Function",
    "text": "nonzeros(A)\n\nReturn a vector of the structural nonzero values in sparse array A. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of A, and any modifications to the returned vector will mutate A as well. See rowvals and nzrange.\n\nExample\n\njulia> A = speye(3)\n3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n\njulia> nonzeros(A)\n3-element Array{Float64,1}:\n 1.0\n 1.0\n 1.0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.rowvals",
    "page": "Arrays",
    "title": "Base.SparseArrays.rowvals",
    "category": "Function",
    "text": "rowvals(A::SparseMatrixCSC)\n\nReturn a vector of the row indices of A. Any modifications to the returned vector will mutate A as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also nonzeros and nzrange.\n\nExample\n\njulia> A = speye(3)\n3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n\njulia> rowvals(A)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.nzrange",
    "page": "Arrays",
    "title": "Base.SparseArrays.nzrange",
    "category": "Function",
    "text": "nzrange(A::SparseMatrixCSC, col::Integer)\n\nReturn the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with nonzeros and rowvals, this allows for convenient iterating over a sparse matrix :\n\nA = sparse(I,J,V)\nrows = rowvals(A)\nvals = nonzeros(A)\nm, n = size(A)\nfor i = 1:n\n   for j in nzrange(A, i)\n      row = rows[j]\n      val = vals[j]\n      # perform sparse wizardry...\n   end\nend\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.dropzeros!-Tuple{SparseMatrixCSC,Bool}",
    "page": "Arrays",
    "title": "Base.SparseArrays.dropzeros!",
    "category": "Method",
    "text": "dropzeros!(A::SparseMatrixCSC, trim::Bool = true)\n\nRemoves stored numerical zeros from A, optionally trimming resulting excess space from A.rowval and A.nzval when trim is true.\n\nFor an out-of-place version, see dropzeros. For algorithmic information, see fkeep!.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.dropzeros-Tuple{SparseMatrixCSC,Bool}",
    "page": "Arrays",
    "title": "Base.SparseArrays.dropzeros",
    "category": "Method",
    "text": "dropzeros(A::SparseMatrixCSC, trim::Bool = true)\n\nGenerates a copy of A and removes stored numerical zeros from that copy, optionally trimming excess space from the result's rowval and nzval arrays when trim is true.\n\nFor an in-place version and algorithmic information, see dropzeros!.\n\nExample\n\njulia> A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])\n3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  0.0\n  [3, 3]  =  1.0\n\njulia> dropzeros(A)\n3×3 SparseMatrixCSC{Float64,Int64} with 2 stored entries:\n  [1, 1]  =  1.0\n  [3, 3]  =  1.0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.dropzeros!-Tuple{SparseVector,Bool}",
    "page": "Arrays",
    "title": "Base.SparseArrays.dropzeros!",
    "category": "Method",
    "text": "dropzeros!(x::SparseVector, trim::Bool = true)\n\nRemoves stored numerical zeros from x, optionally trimming resulting excess space from x.nzind and x.nzval when trim is true.\n\nFor an out-of-place version, see dropzeros. For algorithmic information, see fkeep!.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.dropzeros-Tuple{SparseVector,Bool}",
    "page": "Arrays",
    "title": "Base.SparseArrays.dropzeros",
    "category": "Method",
    "text": "dropzeros(x::SparseVector, trim::Bool = true)\n\nGenerates a copy of x and removes numerical zeros from that copy, optionally trimming excess space from the result's nzind and nzval arrays when trim is true.\n\nFor an in-place version and algorithmic information, see dropzeros!.\n\nExample\n\njulia> A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])\n3-element SparseVector{Float64,Int64} with 3 stored entries:\n  [1]  =  1.0\n  [2]  =  0.0\n  [3]  =  1.0\n\njulia> dropzeros(A)\n3-element SparseVector{Float64,Int64} with 2 stored entries:\n  [1]  =  1.0\n  [3]  =  1.0\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.SparseArrays.permute",
    "page": "Arrays",
    "title": "Base.SparseArrays.permute",
    "category": "Function",
    "text": "permute{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},\n    q::AbstractVector{<:Integer})\n\nBilaterally permute A, returning PAQ (A[p,q]). Column-permutation q's length must match A's column count (length(q) == A.n). Row-permutation p's length must match A's row count (length(p) == A.m).\n\nFor expert drivers and additional information, see permute!.\n\nExample\n\njulia> A = spdiagm([1, 2, 3, 4], 0, 4, 4) + spdiagm([5, 6, 7], 1, 4, 4)\n4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:\n  [1, 1]  =  1\n  [1, 2]  =  5\n  [2, 2]  =  2\n  [2, 3]  =  6\n  [3, 3]  =  3\n  [3, 4]  =  7\n  [4, 4]  =  4\n\njulia> permute(A, [4, 3, 2, 1], [1, 2, 3, 4])\n4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:\n  [4, 1]  =  1\n  [3, 2]  =  2\n  [4, 2]  =  5\n  [2, 3]  =  3\n  [3, 3]  =  6\n  [1, 4]  =  4\n  [2, 4]  =  7\n\njulia> permute(A, [1, 2, 3, 4], [4, 3, 2, 1])\n4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:\n  [3, 1]  =  7\n  [4, 1]  =  4\n  [2, 2]  =  6\n  [3, 2]  =  3\n  [1, 3]  =  5\n  [2, 3]  =  2\n  [1, 4]  =  1\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#Base.permute!-Union{Tuple{SparseMatrixCSC{Tv,Ti},SparseMatrixCSC{Tv,Ti},AbstractArray{Tp,1},AbstractArray{Tq,1}}, Tuple{Ti}, Tuple{Tp}, Tuple{Tq}, Tuple{Tv}} where Tq<:Integer where Tp<:Integer where Ti where Tv",
    "page": "Arrays",
    "title": "Base.permute!",
    "category": "Method",
    "text": "permute!{Tv,Ti}(X::SparseMatrixCSC{Tv,Ti}, A::SparseMatrixCSC{Tv,Ti},\n    p::AbstractVector{<:Integer}, q::AbstractVector{<:Integer}[, C::SparseMatrixCSC{Tv,Ti}])\n\nBilaterally permute A, storing result PAQ (A[p,q]) in X. Stores intermediate result (AQ)^T (transpose(A[:,q])) in optional argument C if present. Requires that none of X, A, and, if present, C alias each other; to store result PAQ back into A, use the following method lacking X:\n\npermute!{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},\n    q::AbstractVector{<:Integer}[, C::SparseMatrixCSC{Tv,Ti}[, workcolptr::Vector{Ti}]])\n\nX's dimensions must match those of A (X.m == A.m and X.n == A.n), and X must have enough storage to accommodate all allocated entries in A (length(X.rowval) >= nnz(A) and length(X.nzval) >= nnz(A)). Column-permutation q's length must match A's column count (length(q) == A.n). Row-permutation p's length must match A's row count (length(p) == A.m).\n\nC's dimensions must match those of transpose(A) (C.m == A.n and C.n == A.m), and C must have enough storage to accommodate all allocated entries in A (length(C.rowval) >= nnz(A) and length(C.nzval) >= nnz(A)).\n\nFor additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods unchecked_noalias_permute! and unchecked_aliasing_permute!.\n\nSee also: permute.\n\n\n\n"
},

{
    "location": "stdlib/arrays.html#stdlib-sparse-arrays-1",
    "page": "Arrays",
    "title": "Matrices y Vectores Sparse",
    "category": "section",
    "text": "Los vectores y las matrices sparse soportan ampliamente el mismo conjunto de operaciones que sus contrapartidas densas. Las siguientes funciones son específicas para arrays sparse.Base.SparseArrays.SparseVector\nBase.SparseArrays.SparseMatrixCSC\nBase.SparseArrays.sparse\nBase.SparseArrays.sparsevec\nBase.SparseArrays.issparse\nBase.full\nBase.SparseArrays.nnz\nBase.SparseArrays.spzeros\nBase.SparseArrays.spones\nBase.SparseArrays.speye(::Type, ::Integer, ::Integer)\nBase.SparseArrays.speye(::SparseMatrixCSC)\nBase.SparseArrays.spdiagm\nBase.SparseArrays.sprand\nBase.SparseArrays.sprandn\nBase.SparseArrays.nonzeros\nBase.SparseArrays.rowvals\nBase.SparseArrays.nzrange\nBase.SparseArrays.dropzeros!(::SparseMatrixCSC, ::Bool)\nBase.SparseArrays.dropzeros(::SparseMatrixCSC, ::Bool)\nBase.SparseArrays.dropzeros!(::SparseVector, ::Bool)\nBase.SparseArrays.dropzeros(::SparseVector, ::Bool)\nBase.SparseArrays.permute\nBase.permute!{Tv, Ti, Tp <: Integer, Tq <: Integer}(::SparseMatrixCSC{Tv,Ti}, ::SparseMatrixCSC{Tv,Ti}, ::AbstractArray{Tp,1}, ::AbstractArray{Tq,1})"
},

{
    "location": "stdlib/parallel.html#",
    "page": "Tareas y Computación Paralela",
    "title": "Tareas y Computación Paralela",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/parallel.html#tasks-and-parallel-computing-1",
    "page": "Tareas y Computación Paralela",
    "title": "Tareas y Computación Paralela",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/parallel.html#Core.Task",
    "page": "Tareas y Computación Paralela",
    "title": "Core.Task",
    "category": "Type",
    "text": "Task(func)\n\nCreate a Task (i.e. coroutine) to execute the given function (which must be callable with no arguments). The task exits when this function returns.\n\nExample\n\njulia> a() = det(rand(1000, 1000));\n\njulia> b = Task(a);\n\nIn this example, b is a runnable Task that hasn't started yet.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.current_task",
    "page": "Tareas y Computación Paralela",
    "title": "Base.current_task",
    "category": "Function",
    "text": "current_task()\n\nGet the currently running Task.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.istaskdone",
    "page": "Tareas y Computación Paralela",
    "title": "Base.istaskdone",
    "category": "Function",
    "text": "istaskdone(t::Task) -> Bool\n\nDetermine whether a task has exited.\n\njulia> a2() = det(rand(1000, 1000));\n\njulia> b = Task(a2);\n\njulia> istaskdone(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.istaskstarted",
    "page": "Tareas y Computación Paralela",
    "title": "Base.istaskstarted",
    "category": "Function",
    "text": "istaskstarted(t::Task) -> Bool\n\nDetermine whether a task has started executing.\n\njulia> a3() = det(rand(1000, 1000));\n\njulia> b = Task(a3);\n\njulia> istaskstarted(b)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.yield",
    "page": "Tareas y Computación Paralela",
    "title": "Base.yield",
    "category": "Function",
    "text": "yield()\n\nSwitch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.\n\n\n\nyield(t::Task, arg = nothing)\n\nA fast, unfair-scheduling version of schedule(t, arg); yield() which immediately yields to t before calling the scheduler.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.yieldto",
    "page": "Tareas y Computación Paralela",
    "title": "Base.yieldto",
    "category": "Function",
    "text": "yieldto(t::Task, arg = nothing)\n\nSwitch to the given task. The first time a task is switched to, the task's function is called with no arguments. On subsequent switches, arg is returned from the task's last call to yieldto. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.task_local_storage-Tuple{Any}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.task_local_storage",
    "category": "Method",
    "text": "task_local_storage(key)\n\nLook up the value of a key in the current task's task-local storage.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.task_local_storage-Tuple{Any,Any}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.task_local_storage",
    "category": "Method",
    "text": "task_local_storage(key, value)\n\nAssign a value to a key in the current task's task-local storage.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.task_local_storage-Tuple{Function,Any,Any}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.task_local_storage",
    "category": "Method",
    "text": "task_local_storage(body, key, value)\n\nCall the function body with a modified task-local storage, in which value is assigned to key; the previous value of key, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Condition",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Condition",
    "category": "Type",
    "text": "Condition()\n\nCreate an edge-triggered event source that tasks can wait for. Tasks that call wait on a Condition are suspended and queued. Tasks are woken up when notify is later called on the Condition. Edge triggering means that only tasks waiting at the time notify is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The Channel type does this, and so can be used for level-triggered events.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.notify",
    "page": "Tareas y Computación Paralela",
    "title": "Base.notify",
    "category": "Function",
    "text": "notify(condition, val=nothing; all=true, error=false)\n\nWake up tasks waiting for a condition, passing them val. If all is true (the default), all waiting tasks are woken, otherwise only one is. If error is true, the passed value is raised as an exception in the woken tasks.\n\nReturns the count of tasks woken up. Returns 0 if no tasks are waiting on condition.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.schedule",
    "page": "Tareas y Computación Paralela",
    "title": "Base.schedule",
    "category": "Function",
    "text": "schedule(t::Task, [val]; error=false)\n\nAdd a Task to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as wait.\n\nIf a second argument val is provided, it will be passed to the task (via the return value of yieldto) when it runs again. If error is true, the value is raised as an exception in the woken task.\n\njulia> a5() = det(rand(1000, 1000));\n\njulia> b = Task(a5);\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskstarted(b)\ntrue\n\njulia> istaskdone(b)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.@schedule",
    "page": "Tareas y Computación Paralela",
    "title": "Base.@schedule",
    "category": "Macro",
    "text": "@schedule\n\nWrap an expression in a Task and add it to the local machine's scheduler queue. Similar to @async except that an enclosing @sync does NOT wait for tasks started with an @schedule.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.@task",
    "page": "Tareas y Computación Paralela",
    "title": "Base.@task",
    "category": "Macro",
    "text": "@task\n\nWrap an expression in a Task without executing it, and return the Task. This only creates a task, and does not run it.\n\njulia> a1() = det(rand(1000, 1000));\n\njulia> b = @task a1();\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.sleep",
    "page": "Tareas y Computación Paralela",
    "title": "Base.sleep",
    "category": "Function",
    "text": "sleep(seconds)\n\nBlock the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of 0.001.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Channel",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Channel",
    "category": "Type",
    "text": "Channel{T}(sz::Int)\n\nConstructs a Channel with an internal buffer that can hold a maximum of sz objects of type T. put! calls on a full channel block until an object is removed with take!.\n\nChannel(0) constructs an unbuffered channel. put! blocks until a matching take! is called. And vice-versa.\n\nOther constructors:\n\nChannel(Inf): equivalent to Channel{Any}(typemax(Int))\nChannel(sz): equivalent to Channel{Any}(sz)\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.put!-Tuple{Channel,Any}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.put!",
    "category": "Method",
    "text": "put!(c::Channel, v)\n\nAppends an item v to the channel c. Blocks if the channel is full.\n\nFor unbuffered channels, blocks until a take! is performed by a different task.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.take!-Tuple{Channel}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.take!",
    "category": "Method",
    "text": "take!(c::Channel)\n\nRemoves and returns a value from a Channel. Blocks until data is available.\n\nFor unbuffered channels, blocks until a put! is performed by a different task.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.isready-Tuple{Channel}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.isready",
    "category": "Method",
    "text": "isready(c::Channel)\n\nDetermine whether a Channel has a value stored to it. Returns immediately, does not block.\n\nFor unbuffered channels returns true if there are tasks waiting on a put!.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.fetch-Tuple{Channel}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.fetch",
    "category": "Method",
    "text": "fetch(c::Channel)\n\nWaits for and gets the first available item from the channel. Does not remove the item. fetch is unsupported on an unbuffered (0-size) channel.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.close-Tuple{Channel}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.close",
    "category": "Method",
    "text": "close(c::Channel)\n\nCloses a channel. An exception is thrown by:\n\nput! on a closed channel.\ntake! and fetch on an empty, closed channel.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.bind-Tuple{Channel,Task}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.bind",
    "category": "Method",
    "text": "bind(chnl::Channel, task::Task)\n\nAssociates the lifetime of chnl with a task. Channel chnl is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on chnl.\n\nThe chnl object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.\n\nWhen a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.\n\njulia> c = Channel(0);\n\njulia> task = @schedule foreach(i->put!(c, i), 1:4);\n\njulia> bind(c,task);\n\njulia> for i in c\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\njulia> isopen(c)\nfalse\n\njulia> c = Channel(0);\n\njulia> task = @schedule (put!(c,1);error(\"foo\"));\n\njulia> bind(c,task);\n\njulia> take!(c)\n1\n\njulia> put!(c,1);\nERROR: foo\nStacktrace:\n [1] check_channel_state(::Channel{Any}) at ./channels.jl:131\n [2] put!(::Channel{Any}, ::Int64) at ./channels.jl:261\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.asyncmap",
    "page": "Tareas y Computación Paralela",
    "title": "Base.asyncmap",
    "category": "Function",
    "text": "asyncmap(f, c...; ntasks=0, batch_size=nothing)\n\nUses multiple concurrent tasks to map f over a collection (or multiple equal length collections). For multiple collection arguments, f is applied elementwise.\n\nntasks specifies the number of tasks to run concurrently. Depending on the length of the collections, if ntasks is unspecified, up to 100 tasks will be used for concurrent mapping.\n\nntasks can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of ntasks_func() is less than the current number of tasks.\n\nIf batch_size is specified, the collection is processed in batch mode. f must then be a function that must accept a Vector of argument tuples and must return a vector of results. The input vector will have a length of batch_size or less.\n\nThe following examples highlight execution in different tasks by returning the object_id of the tasks in which the mapping function is executed.\n\nFirst, with ntasks undefined, each element is processed in a different task.\n\njulia> tskoid() = object_id(current_task());\n\njulia> asyncmap(x->tskoid(), 1:5)\n5-element Array{UInt64,1}:\n 0x6e15e66c75c75853\n 0x440f8819a1baa682\n 0x9fb3eeadd0c83985\n 0xebd3e35fe90d4050\n 0x29efc93edce2b961\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5)))\n5\n\nWith ntasks=2 all elements are processed in 2 tasks.\n\njulia> asyncmap(x->tskoid(), 1:5; ntasks=2)\n5-element Array{UInt64,1}:\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))\n2\n\nWith batch_size defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. map is used in the modified mapping function to achieve this.\n\njulia> batch_func(input) = map(x->string(\"args_tuple: \", x, \", element_val: \", x[1], \", task: \", tskoid()), input)\nbatch_func (generic function with 1 method)\n\njulia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)\n5-element Array{String,1}:\n \"args_tuple: (1,), element_val: 1, task: 9118321258196414413\"\n \"args_tuple: (2,), element_val: 2, task: 4904288162898683522\"\n \"args_tuple: (3,), element_val: 3, task: 9118321258196414413\"\n \"args_tuple: (4,), element_val: 4, task: 4904288162898683522\"\n \"args_tuple: (5,), element_val: 5, task: 9118321258196414413\"\n\nnote: Note\nCurrently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, ayncmap is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.asyncmap!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.asyncmap!",
    "category": "Function",
    "text": "asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)\n\nLike asyncmap(), but stores output in results rather than returning a collection.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#tasks-1",
    "page": "Tareas y Computación Paralela",
    "title": "Tareas",
    "category": "section",
    "text": "Core.Task\nBase.current_task\nBase.istaskdone\nBase.istaskstarted\nBase.yield\nBase.yieldto\nBase.task_local_storage(::Any)\nBase.task_local_storage(::Any, ::Any)\nBase.task_local_storage(::Function, ::Any, ::Any)\nBase.Condition\nBase.notify\nBase.schedule\nBase.@schedule\nBase.@task\nBase.sleep\nBase.Channel\nBase.put!(::Channel, ::Any)\nBase.take!(::Channel)\nBase.isready(::Channel)\nBase.fetch(::Channel)\nBase.close(::Channel)\nBase.bind(c::Channel, task::Task)\nBase.asyncmap\nBase.asyncmap!"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.addprocs",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.addprocs",
    "category": "Function",
    "text": "addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers\n\nLaunches worker processes via the specified cluster manager.\n\nFor example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl.\n\nThe number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport.\n\n\n\naddprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers\n\nAdd processes on remote machines via SSH. Requires julia to be installed in the same location on each node, or to be available via a shared file system.\n\nmachines is a vector of machine specifications. Workers are started for each specification.\n\nA machine specification is either a string machine_spec or a tuple - (machine_spec, count).\n\nmachine_spec is a string of the form [user@]host[:port] [bind_addr[:port]]. user defaults to current user, port to the standard ssh port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified bind_addr and port.\n\ncount is the number of workers to be launched on the specified host. If specified as :auto it will launch as many workers as the number of cores on the specific host.\n\nKeyword arguments:\n\ntunnel: if true then SSH tunneling will be used to connect to the worker from the master process. Default is false.\nsshflags: specifies additional ssh options, e.g. sshflags=`-i /home/foo/bar.pem`\nmax_parallel: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.\ndir: specifies the working directory on the workers. Defaults to the host's current directory (as found by pwd())\nenable_threaded_blas: if true then  BLAS will run on multiple threads in added processes. Default is false.\nexename: name of the julia executable. Defaults to \"$JULIA_HOME/julia\" or \"$JULIA_HOME/julia-debug\" as the case may be.\nexeflags: additional flags passed to the worker processes.\ntopology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.\ntopology=:all_to_all: All processes are connected to each other. The default.\ntopology=:master_slave: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each other.\ntopology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in connect_idents.\n\nEnvironment variables :\n\nIf the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the master process specifies the number of seconds a newly launched worker waits for connection establishment.\n\n\n\naddprocs(; kwargs...) -> List of process identifiers\n\nEquivalent to addprocs(Sys.CPU_CORES; kwargs...)\n\nNote that workers do not run a .juliarc.jl startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.\n\n\n\naddprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers\n\nLaunches workers using the in-built LocalManager which only launches workers on the local host. This can be used to take advantage of multiple cores. addprocs(4) will add 4 processes on the local machine. If restrict is true, binding is restricted to 127.0.0.1. Keyword args dir, exename, exeflags, topology, and enable_threaded_blas have the same effect as documented for addprocs(machines).\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.nprocs",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.nprocs",
    "category": "Function",
    "text": "nprocs()\n\nGet the number of available processes.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.nworkers",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.nworkers",
    "category": "Function",
    "text": "nworkers()\n\nGet the number of available worker processes. This is one less than nprocs(). Equal to nprocs() if nprocs() == 1.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.procs-Tuple{}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.procs",
    "category": "Method",
    "text": "procs()\n\nReturns a list of all process identifiers.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.procs-Tuple{Integer}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.procs",
    "category": "Method",
    "text": "procs(pid::Integer)\n\nReturns a list of all process identifiers on the same physical node. Specifically all workers bound to the same ip-address as pid are returned.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.workers",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.workers",
    "category": "Function",
    "text": "workers()\n\nReturns a list of all worker process identifiers.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.rmprocs",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.rmprocs",
    "category": "Function",
    "text": "rmprocs(pids...; waitfor=typemax(Int))\n\nRemoves the specified workers. Note that only process 1 can add or remove workers.\n\nArgument waitfor specifies how long to wait for the workers to shut down:     - If unspecified, rmprocs will wait until all requested pids are removed.     - An ErrorException is raised if all workers cannot be terminated before       the requested waitfor seconds.     - With a waitfor value of 0, the call returns immediately with the workers       scheduled for removal in a different task. The scheduled Task object is       returned. The user should call wait on the task before invoking any other       parallel calls.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.interrupt",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.interrupt",
    "category": "Function",
    "text": "interrupt(pids::Integer...)\n\nInterrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.\n\n\n\ninterrupt(pids::AbstractVector=workers())\n\nInterrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.myid",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.myid",
    "category": "Function",
    "text": "myid()\n\nGet the id of the current process.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.pmap",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.pmap",
    "category": "Function",
    "text": "pmap([::AbstractWorkerPool], f, c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[]), retry_check=nothing) -> collection\n\nTransform collection c by applying f to each element using available workers and tasks.\n\nFor multiple collection arguments, apply f elementwise.\n\nNote that f must be made available to all worker processes; see Code Availability and Loading Packages for details.\n\nIf a worker pool is not specified, all available workers, i.e., the default worker pool is used.\n\nBy default, pmap distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify distributed=false. This is equivalent to using asyncmap. For example, pmap(f, c; distributed=false) is equivalent to asyncmap(f,c; ntasks=()->nworkers())\n\npmap can also use a mix of processes and tasks via the batch_size argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length batch_size or less. A batch is sent as a single request to a free worker, where a local asyncmap processes elements from the batch using multiple concurrent tasks.\n\nAny error stops pmap from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument on_error which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.\n\nConsider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:\n\njulia> pmap(x->iseven(x) ? error(\"foo\") : x, 1:4; on_error=identity)\n4-element Array{Any,1}:\n 1\n  ErrorException(\"foo\")\n 3\n  ErrorException(\"foo\")\n\njulia> pmap(x->iseven(x) ? error(\"foo\") : x, 1:4; on_error=ex->0)\n4-element Array{Int64,1}:\n 1\n 0\n 3\n 0\n\nErrors can also be handled by retrying failed computations. Keyword arguments retry_delays and retry_check are passed through to retry as keyword arguments delays and check respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.\n\nNote that if both on_error and retry_delays are specified, the on_error hook is called before retrying. If on_error does not throw (or rethrow) an exception, the element will not be retried.\n\nExample: On errors, retry f on an element a maximum of 3 times without any delay between retries.\n\npmap(f, c; retry_delays = zeros(3))\n\nExample: Retry f only if the exception is not of type InexactError, with exponentially increasing delays up to 3 times. Return a NaN in place for all InexactError occurrences.\n\npmap(f, c; on_error = e->(isa(e, InexactError) ? NaN : rethrow(e)), retry_delays = ExponentialBackOff(n = 3))\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.RemoteException",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.RemoteException",
    "category": "Type",
    "text": "RemoteException(captured)\n\nExceptions on remote computations are captured and rethrown locally.  A RemoteException wraps the pid of the worker and a captured exception. A CapturedException captures the remote exception and a serializable form of the call stack when the exception was raised.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.Future",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.Future",
    "category": "Type",
    "text": "Future(pid::Integer=myid())\n\nCreate a Future on process pid. The default pid is the current process.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.RemoteChannel-Tuple{Integer}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.RemoteChannel",
    "category": "Method",
    "text": "RemoteChannel(pid::Integer=myid())\n\nMake a reference to a Channel{Any}(1) on process pid. The default pid is the current process.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.RemoteChannel-Tuple{Function,Integer}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.RemoteChannel",
    "category": "Method",
    "text": "RemoteChannel(f::Function, pid::Integer=myid())\n\nCreate references to remote channels of a specific size and type. f() is a function that when executed on pid must return an implementation of an AbstractChannel.\n\nFor example, RemoteChannel(()->Channel{Int}(10), pid), will return a reference to a channel of type Int and size 10 on pid.\n\nThe default pid is the current process.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.wait",
    "page": "Tareas y Computación Paralela",
    "title": "Base.wait",
    "category": "Function",
    "text": "wait([x])\n\nBlock the current task until some event occurs, depending on the type of the argument:\n\nRemoteChannel : Wait for a value to become available on the specified remote channel.\nFuture : Wait for a value to become available for the specified future.\nChannel: Wait for a value to be appended to the channel.\nCondition: Wait for notify on a condition.\nProcess: Wait for a process or process chain to exit. The exitcode field of a process can be used to determine success or failure.\nTask: Wait for a Task to finish, returning its result value. If the task fails with an exception, the exception is propagated (re-thrown in the task that called wait).\nRawFD: Wait for changes on a file descriptor (see poll_fd for keyword arguments and return code)\n\nIf no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to schedule or yieldto.\n\nOften wait is called within a while loop to ensure a waited-for condition is met before proceeding.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.fetch-Tuple{Any}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.fetch",
    "category": "Method",
    "text": "fetch(x)\n\nWaits and fetches a value from x depending on the type of x:\n\nFuture: Wait for and get the value of a Future. The fetched value is cached locally. Further calls to fetch on the same reference return the cached value. If the remote value is an exception, throws a RemoteException which captures the remote exception and backtrace.\nRemoteChannel: Wait for and get the value of a remote reference. Exceptions raised are same as for a Future .\n\nDoes not remove the item fetched.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remotecall-Tuple{Any,Integer,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remotecall",
    "category": "Method",
    "text": "remotecall(f, id::Integer, args...; kwargs...) -> Future\n\nCall a function f asynchronously on the given arguments on the specified process. Returns a Future. Keyword arguments, if any, are passed through to f.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remotecall_wait-Tuple{Any,Integer,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remotecall_wait",
    "category": "Method",
    "text": "remotecall_wait(f, id::Integer, args...; kwargs...)\n\nPerform a faster wait(remotecall(...)) in one message on the Worker specified by worker id id. Keyword arguments, if any, are passed through to f.\n\nSee also wait and remotecall.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remotecall_fetch-Tuple{Any,Integer,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remotecall_fetch",
    "category": "Method",
    "text": "remotecall_fetch(f, id::Integer, args...; kwargs...)\n\nPerform fetch(remotecall(...)) in one message. Keyword arguments, if any, are passed through to f. Any remote exceptions are captured in a RemoteException and thrown.\n\nSee also fetch and remotecall.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remote_do-Tuple{Any,Integer,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remote_do",
    "category": "Method",
    "text": "remote_do(f, id::Integer, args...; kwargs...) -> nothing\n\nExecutes f on worker id asynchronously. Unlike remotecall, it does not store the result of computation, nor is there a way to wait for its completion.\n\nA successful invocation indicates that the request has been accepted for execution on the remote node.\n\nWhile consecutive remotecalls to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, remote_do(f1, 2); remotecall(f2, 2); remote_do(f3, 2) will serialize the call to f1, followed by f2 and f3 in that order. However, it is not guaranteed that f1 is executed before f3 on worker 2.\n\nAny exceptions thrown by f are printed to STDERR on the remote worker.\n\nKeyword arguments, if any, are passed through to f.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.put!-Tuple{RemoteChannel,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.put!",
    "category": "Method",
    "text": "put!(rr::RemoteChannel, args...)\n\nStore a set of values to the RemoteChannel. If the channel is full, blocks until space is available. Returns its first argument.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.put!-Tuple{Future,Any}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.put!",
    "category": "Method",
    "text": "put!(rr::Future, v)\n\nStore a value to a Future rr. Futures are write-once remote references. A put! on an already set Future throws an Exception. All asynchronous remote calls return Futures and set the value to the return value of the call upon completion.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.take!-Tuple{RemoteChannel,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.take!",
    "category": "Method",
    "text": "take!(rr::RemoteChannel, args...)\n\nFetch value(s) from a RemoteChannel rr, removing the value(s) in the processs.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.isready-Tuple{RemoteChannel,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.isready",
    "category": "Method",
    "text": "isready(rr::RemoteChannel, args...)\n\nDetermine whether a RemoteChannel has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a Future since they are assigned only once.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.isready-Tuple{Future}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.isready",
    "category": "Method",
    "text": "isready(rr::Future)\n\nDetermine whether a Future has a value stored to it.\n\nIf the argument Future is owned by a different node, this call will block to wait for the answer. It is recommended to wait for rr in a separate task instead or to use a local Channel as a proxy:\n\nc = Channel(1)\n@async put!(c, remotecall_fetch(long_computation, p))\nisready(c)  # will not block\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.WorkerPool",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.WorkerPool",
    "category": "Type",
    "text": "WorkerPool(workers::Vector{Int})\n\nCreate a WorkerPool from a vector of worker ids.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.CachingPool",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.CachingPool",
    "category": "Type",
    "text": "CachingPool(workers::Vector{Int})\n\nAn implementation of an AbstractWorkerPool. remote, remotecall_fetch, pmap (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).\n\nThe remote cache is maintained for the lifetime of the returned CachingPool object. To clear the cache earlier, use clear!(pool).\n\nFor global variables, only the bindings are captured in a closure, not the data. let blocks can be used to capture global data.\n\nFor example:\n\nconst foo=rand(10^8);\nwp=CachingPool(workers())\nlet foo=foo\n    pmap(wp, i->sum(foo)+i, 1:100);\nend\n\nThe above would transfer foo only once to each worker.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.default_worker_pool",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.default_worker_pool",
    "category": "Function",
    "text": "default_worker_pool()\n\nWorkerPool containing idle workers() - used by remote(f) and pmap (by default).\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.clear!-Tuple{CachingPool}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.clear!",
    "category": "Method",
    "text": "clear!(pool::CachingPool) -> pool\n\nRemoves all cached functions from all participating workers.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remote",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remote",
    "category": "Function",
    "text": "remote([::AbstractWorkerPool], f) -> Function\n\nReturns an anonymous function that executes function f on an available worker using remotecall_fetch.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remotecall-Tuple{Any,Base.Distributed.AbstractWorkerPool,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remotecall",
    "category": "Method",
    "text": "remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future\n\nWorkerPool variant of remotecall(f, pid, ....). Waits for and takes a free worker from pool and performs a remotecall on it.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remotecall_wait-Tuple{Any,Base.Distributed.AbstractWorkerPool,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remotecall_wait",
    "category": "Method",
    "text": "remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future\n\nWorkerPool variant of remotecall_wait(f, pid, ....). Waits for and takes a free worker from pool and performs a remotecall_wait on it.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remotecall_fetch-Tuple{Any,Base.Distributed.AbstractWorkerPool,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remotecall_fetch",
    "category": "Method",
    "text": "remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -> result\n\nWorkerPool variant of remotecall_fetch(f, pid, ....). Waits for and takes a free worker from pool and performs a remotecall_fetch on it.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remote_do-Tuple{Any,Base.Distributed.AbstractWorkerPool,Vararg{Any,N} where N}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remote_do",
    "category": "Method",
    "text": "remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -> nothing\n\nWorkerPool variant of remote_do(f, pid, ....). Waits for and takes a free worker from pool and performs a remote_do on it.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.timedwait",
    "page": "Tareas y Computación Paralela",
    "title": "Base.timedwait",
    "category": "Function",
    "text": "timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)\n\nWaits until testcb returns true or for secs seconds, whichever is earlier. testcb is polled every pollint seconds.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.@spawn",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.@spawn",
    "category": "Macro",
    "text": "@spawn\n\nCreates a closure around an expression and runs it on an automatically-chosen process, returning a Future to the result.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.@spawnat",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.@spawnat",
    "category": "Macro",
    "text": "@spawnat\n\nAccepts two arguments, p and an expression. A closure is created around the expression and run asynchronously on process p. Returns a Future to the result.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.@fetch",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.@fetch",
    "category": "Macro",
    "text": "@fetch\n\nEquivalent to fetch(@spawn expr). See fetch and @spawn.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.@fetchfrom",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.@fetchfrom",
    "category": "Macro",
    "text": "@fetchfrom\n\nEquivalent to fetch(@spawnat p expr). See fetch and @spawnat.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.@async",
    "page": "Tareas y Computación Paralela",
    "title": "Base.@async",
    "category": "Macro",
    "text": "@async\n\nLike @schedule, @async wraps an expression in a Task and adds it to the local machine's scheduler queue. Additionally it adds the task to the set of items that the nearest enclosing @sync waits for.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.@sync",
    "page": "Tareas y Computación Paralela",
    "title": "Base.@sync",
    "category": "Macro",
    "text": "@sync\n\nWait until all dynamically-enclosed uses of @async, @spawn, @spawnat and @parallel are complete. All exceptions thrown by enclosed async operations are collected and thrown as a CompositeException.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.@parallel",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.@parallel",
    "category": "Macro",
    "text": "@parallel\n\nA parallel for loop of the form :\n\n@parallel [reducer] for var = range\n    body\nend\n\nThe specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, @parallel performs local reductions on each worker with a final reduction on the calling process.\n\nNote that without a reducer function, @parallel executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with @sync, like :\n\n@sync @parallel for var = range\n    body\nend\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.@everywhere",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.@everywhere",
    "category": "Macro",
    "text": "@everywhere expr\n\nExecute an expression under Main everywhere. Equivalent to calling eval(Main, expr) on all processes. Errors on any of the processes are collected into a CompositeException and thrown. For example :\n\n@everywhere bar=1\n\nwill define Main.bar on all processes.\n\nUnlike @spawn and @spawnat, @everywhere does not capture any local variables. Prefixing @everywhere with @eval allows us to broadcast local variables using interpolation :\n\nfoo = 1\n@eval @everywhere bar=$foo\n\nThe expression is evaluated under Main irrespective of where @everywhere is called from. For example :\n\nmodule FooBar\n    foo() = @everywhere bar()=myid()\nend\nFooBar.foo()\n\nwill result in Main.bar being defined on all processes and not FooBar.bar.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.clear!-Tuple{Any,Any}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.clear!",
    "category": "Method",
    "text": "clear!(syms, pids=workers(); mod=Main)\n\nClears global bindings in modules by initializing them to nothing. syms should be of type Symbol or a collection of Symbols . pids and mod identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under mod are cleared.\n\nAn exception is raised if a global constant is requested to be cleared.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.remoteref_id",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.remoteref_id",
    "category": "Function",
    "text": "Base.remoteref_id(r::AbstractRemoteRef) -> RRID\n\nFutures and RemoteChannels are identified by fields:\n\nwhere - refers to the node where the underlying object/storage referred to by the reference actually exists.\nwhence - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling RemoteChannel(2) from the master process would result in a where value of 2 and a whence value of 1.\nid is unique across all references created from the worker specified by whence.\n\nTaken together,  whence and id uniquely identify a reference across all workers.\n\nBase.remoteref_id is a low-level API which returns a Base.RRID object that wraps whence and id values of a remote reference.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.channel_from_id",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.channel_from_id",
    "category": "Function",
    "text": "Base.channel_from_id(id) -> c\n\nA low-level API which returns the backing AbstractChannel for an id returned by remoteref_id. The call is valid only on the node where the backing channel exists.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.worker_id_from_socket",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.worker_id_from_socket",
    "category": "Function",
    "text": "Base.worker_id_from_socket(s) -> pid\n\nA low-level API which given a IO connection or a Worker, returns the pid of the worker it is connected to. This is useful when writing custom serialize methods for a type, which optimizes the data written out depending on the receiving process id.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.cluster_cookie-Tuple{}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.cluster_cookie",
    "category": "Method",
    "text": "Base.cluster_cookie() -> cookie\n\nReturns the cluster cookie.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.cluster_cookie-Tuple{Any}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.cluster_cookie",
    "category": "Method",
    "text": "Base.cluster_cookie(cookie) -> cookie\n\nSets the passed cookie as the cluster cookie, then returns it.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Soporte-General-a-la-Computación-Paralela-1",
    "page": "Tareas y Computación Paralela",
    "title": "Soporte General a la Computación Paralela",
    "category": "section",
    "text": "Base.addprocs\nBase.nprocs\nBase.nworkers\nBase.procs()\nBase.procs(::Integer)\nBase.workers\nBase.rmprocs\nBase.interrupt\nBase.myid\nBase.pmap\nBase.RemoteException\nBase.Future\nBase.RemoteChannel(::Integer)\nBase.RemoteChannel(::Function, ::Integer)\nBase.wait\nBase.fetch(::Any)\nBase.remotecall(::Any, ::Integer, ::Any...)\nBase.remotecall_wait(::Any, ::Integer, ::Any...)\nBase.remotecall_fetch(::Any, ::Integer, ::Any...)\nBase.remote_do(::Any, ::Integer, ::Any...)\nBase.put!(::RemoteChannel, ::Any...)\nBase.put!(::Future, ::Any)\nBase.take!(::RemoteChannel, ::Any...)\nBase.isready(::RemoteChannel, ::Any...)\nBase.isready(::Future)\nBase.WorkerPool\nBase.CachingPool\nBase.default_worker_pool\nBase.clear!(::CachingPool)\nBase.remote\nBase.remotecall(::Any, ::Base.Distributed.AbstractWorkerPool, ::Any...)\nBase.remotecall_wait(::Any, ::Base.Distributed.AbstractWorkerPool, ::Any...)\nBase.remotecall_fetch(::Any, ::Base.Distributed.AbstractWorkerPool, ::Any...)\nBase.remote_do(::Any, ::Base.Distributed.AbstractWorkerPool, ::Any...)\nBase.timedwait\nBase.@spawn\nBase.@spawnat\nBase.@fetch\nBase.@fetchfrom\nBase.@async\nBase.@sync\nBase.@parallel\nBase.@everywhere\nBase.clear!(::Any, ::Any; ::Any)\nBase.remoteref_id\nBase.channel_from_id\nBase.worker_id_from_socket\nBase.cluster_cookie()\nBase.cluster_cookie(::Any)"
},

{
    "location": "stdlib/parallel.html#Base.SharedArray",
    "page": "Tareas y Computación Paralela",
    "title": "Base.SharedArray",
    "category": "Type",
    "text": "SharedArray{T}(dims::NTuple; init=false, pids=Int[])\nSharedArray{T,N}(...)\n\nConstruct a SharedArray of a bits type T and size dims across the processes specified by pids - all of which have to be on the same host.  If N is specified by calling SharedArray{T,N}(dims), then N must match the length of dims.\n\nIf pids is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, localindexes and indexpids will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.\n\nIf an init function of the type initfn(S::SharedArray) is specified, it is called on all the participating workers.\n\nThe shared array is valid as long as a reference to the SharedArray object exists on the node which created the mapping.\n\nSharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids=Int[])\nSharedArray{T,N}(...)\n\nConstruct a SharedArray backed by the file filename, with element type T (must be a bits type) and size dims, across the processes specified by pids - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:\n\nThe array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)\nAny changes you make to the array values (e.g., A[3] = 0) will also change the values on disk\n\nIf pids is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, localindexes and indexpids will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.\n\nmode must be one of \"r\", \"r+\", \"w+\", or \"a+\", and defaults to \"r+\" if the file specified by filename already exists, or \"w+\" if not. If an init function of the type initfn(S::SharedArray) is specified, it is called on all the participating workers. You cannot specify an init function if the file is not writable.\n\noffset allows you to skip the specified number of bytes at the beginning of the file.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.procs-Tuple{SharedArray}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.procs",
    "category": "Method",
    "text": "procs(S::SharedArray)\n\nGet the vector of processes mapping the shared array.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.sdata",
    "page": "Tareas y Computación Paralela",
    "title": "Base.sdata",
    "category": "Function",
    "text": "sdata(S::SharedArray)\n\nReturns the actual Array object backing S.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.indexpids",
    "page": "Tareas y Computación Paralela",
    "title": "Base.indexpids",
    "category": "Function",
    "text": "indexpids(S::SharedArray)\n\nReturns the current worker's index in the list of workers mapping the SharedArray (i.e. in the same list returned by procs(S)), or 0 if the SharedArray is not mapped locally.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.localindexes",
    "page": "Tareas y Computación Paralela",
    "title": "Base.localindexes",
    "category": "Function",
    "text": "localindexes(S::SharedArray)\n\nReturns a range describing the \"default\" indexes to be handled by the current process.  This range should be interpreted in the sense of linear indexing, i.e., as a sub-range of 1:length(S).  In multi-process contexts, returns an empty range in the parent process (or any process for which indexpids returns 0).\n\nIt's worth emphasizing that localindexes exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a SharedArray, all indexes should be equally fast for each worker process.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Arrays-Compartidos-1",
    "page": "Tareas y Computación Paralela",
    "title": "Arrays Compartidos",
    "category": "section",
    "text": "Base.SharedArray\nBase.procs(::SharedArray)\nBase.sdata\nBase.indexpids\nBase.localindexes"
},

{
    "location": "stdlib/parallel.html#Base.Threads.threadid",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.threadid",
    "category": "Function",
    "text": "Threads.threadid()\n\nGet the ID number of the current thread of execution. The master thread has ID 1.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.nthreads",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.nthreads",
    "category": "Function",
    "text": "Threads.nthreads()\n\nGet the number of threads available to the Julia process. This is the inclusive upper bound on threadid().\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.@threads",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.@threads",
    "category": "Macro",
    "text": "Threads.@threads\n\nA macro to parallelize a for-loop to run with multiple threads. This spawns nthreads() number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.Atomic",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.Atomic",
    "category": "Type",
    "text": "Threads.Atomic{T}\n\nHolds a reference to an object of type T, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.\n\nOnly certain \"simple\" types can be used atomically, namely the primitive integer and float-point types. These are Int8...Int128, UInt8...UInt128, and Float16...Float64.\n\nNew atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.\n\nAtomic objects can be accessed using the [] notation:\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> x[] = 1\n1\n\njulia> x[]\n1\n\nAtomic operations use an atomic_ prefix, such as atomic_add!, atomic_xchg!, etc.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_cas!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_cas!",
    "category": "Function",
    "text": "Threads.atomic_cas!{T}(x::Atomic{T}, cmp::T, newval::T)\n\nAtomically compare-and-set x\n\nAtomically compares the value in x with cmp. If equal, write newval to x. Otherwise, leaves x unmodified. Returns the old value in x. By comparing the returned value to cmp (via ===) one knows whether x was modified and now holds the new value newval.\n\nFor further details, see LLVM's cmpxchg instruction.\n\nThis function can be used to implement transactional semantics. Before the transaction, one records the value in x. After the transaction, the new value is stored only if x has not been modified in the mean time.\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_cas!(x, 4, 2);\n\njulia> x\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_cas!(x, 3, 2);\n\njulia> x\nBase.Threads.Atomic{Int64}(2)\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_xchg!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_xchg!",
    "category": "Function",
    "text": "Threads.atomic_xchg!{T}(x::Atomic{T}, newval::T)\n\nAtomically exchange the value in x\n\nAtomically exchanges the value in x with newval. Returns the old value.\n\nFor further details, see LLVM's atomicrmw xchg instruction.\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_xchg!(x, 2)\n3\n\njulia> x[]\n2\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_add!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_add!",
    "category": "Function",
    "text": "Threads.atomic_add!{T}(x::Atomic{T}, val::T)\n\nAtomically add val to x\n\nPerforms x[] += val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw add instruction.\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_add!(x, 2)\n3\n\njulia> x[]\n5\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_sub!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_sub!",
    "category": "Function",
    "text": "Threads.atomic_sub!{T}(x::Atomic{T}, val::T)\n\nAtomically subtract val from x\n\nPerforms x[] -= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw sub instruction.\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_sub!(x, 2)\n3\n\njulia> x[]\n1\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_and!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_and!",
    "category": "Function",
    "text": "Threads.atomic_and!{T}(x::Atomic{T}, val::T)\n\nAtomically bitwise-and x with val\n\nPerforms x[] &= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw and instruction.\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_and!(x, 2)\n3\n\njulia> x[]\n2\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_nand!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_nand!",
    "category": "Function",
    "text": "Threads.atomic_nand!{T}(x::Atomic{T}, val::T)\n\nAtomically bitwise-nand (not-and) x with val\n\nPerforms x[] = ~(x[] & val) atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw nand instruction.\n\njulia> x = Threads.Atomic{Int}(3)\nBase.Threads.Atomic{Int64}(3)\n\njulia> Threads.atomic_nand!(x, 2)\n3\n\njulia> x[]\n-3\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_or!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_or!",
    "category": "Function",
    "text": "Threads.atomic_or!{T}(x::Atomic{T}, val::T)\n\nAtomically bitwise-or x with val\n\nPerforms x[] |= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw or instruction.\n\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_or!(x, 7)\n5\n\njulia> x[]\n7\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_xor!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_xor!",
    "category": "Function",
    "text": "Threads.atomic_xor!{T}(x::Atomic{T}, val::T)\n\nAtomically bitwise-xor (exclusive-or) x with val\n\nPerforms x[] $= val atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw xor instruction.\n\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_xor!(x, 7)\n5\n\njulia> x[]\n2\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_max!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_max!",
    "category": "Function",
    "text": "Threads.atomic_max!{T}(x::Atomic{T}, val::T)\n\nAtomically store the maximum of x and val in x\n\nPerforms x[] = max(x[], val) atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw max instruction.\n\njulia> x = Threads.Atomic{Int}(5)\nBase.Threads.Atomic{Int64}(5)\n\njulia> Threads.atomic_max!(x, 7)\n5\n\njulia> x[]\n7\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_min!",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_min!",
    "category": "Function",
    "text": "Threads.atomic_min!{T}(x::Atomic{T}, val::T)\n\nAtomically store the minimum of x and val in x\n\nPerforms x[] = min(x[], val) atomically. Returns the old value.\n\nFor further details, see LLVM's atomicrmw min instruction.\n\njulia> x = Threads.Atomic{Int}(7)\nBase.Threads.Atomic{Int64}(7)\n\njulia> Threads.atomic_min!(x, 5)\n7\n\njulia> x[]\n5\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.atomic_fence",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.atomic_fence",
    "category": "Function",
    "text": "Threads.atomic_fence()\n\nInsert a sequential-consistency memory fence\n\nInserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.\n\nThis is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.\n\nFor further details, see LLVM's fence instruction.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Multi-Hilo-1",
    "page": "Tareas y Computación Paralela",
    "title": "Multi-Hilo",
    "category": "section",
    "text": "Este interfaz experimental soporta las capacidades multi-hilo de Julia. Los tipos y funciones descritos aquí pueden cambiar en el futuro (y probablemente lo harán).Base.Threads.threadid\nBase.Threads.nthreads\nBase.Threads.@threads\nBase.Threads.Atomic\nBase.Threads.atomic_cas!\nBase.Threads.atomic_xchg!\nBase.Threads.atomic_add!\nBase.Threads.atomic_sub!\nBase.Threads.atomic_and!\nBase.Threads.atomic_nand!\nBase.Threads.atomic_or!\nBase.Threads.atomic_xor!\nBase.Threads.atomic_max!\nBase.Threads.atomic_min!\nBase.Threads.atomic_fence"
},

{
    "location": "stdlib/parallel.html#Base.@threadcall",
    "page": "Tareas y Computación Paralela",
    "title": "Base.@threadcall",
    "category": "Macro",
    "text": "@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)\n\nThe @threadcall macro is called in the same way as ccall but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main julia thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the UV_THREADPOOL_SIZE environment variable and restarting the julia process.\n\nNote that the called function should never call back into Julia.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#ccall-utilianzdo-una-threadpool-(Experimental)-1",
    "page": "Tareas y Computación Paralela",
    "title": "ccall utilianzdo una threadpool (Experimental)",
    "category": "section",
    "text": "Base.@threadcall"
},

{
    "location": "stdlib/parallel.html#Base.Threads.AbstractLock",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.AbstractLock",
    "category": "Type",
    "text": "AbstractLock\n\nAbstract supertype describing types that implement the thread-safe synchronization primitives: lock, trylock, unlock, and islocked\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.lock",
    "page": "Tareas y Computación Paralela",
    "title": "Base.lock",
    "category": "Function",
    "text": "lock(the_lock)\n\nAcquires the lock when it becomes available. If the lock is already locked by a different task/thread, it waits for it to become available.\n\nEach lock must be matched by an unlock.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.unlock",
    "page": "Tareas y Computación Paralela",
    "title": "Base.unlock",
    "category": "Function",
    "text": "unlock(the_lock)\n\nReleases ownership of the lock.\n\nIf this is a recursive lock which has been acquired before, it just decrements an internal counter and returns immediately.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.trylock",
    "page": "Tareas y Computación Paralela",
    "title": "Base.trylock",
    "category": "Function",
    "text": "trylock(the_lock) -> Success (Boolean)\n\nAcquires the lock if it is available, returning true if successful. If the lock is already locked by a different task/thread, returns false.\n\nEach successful trylock must be matched by an unlock.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.islocked",
    "page": "Tareas y Computación Paralela",
    "title": "Base.islocked",
    "category": "Function",
    "text": "islocked(the_lock) -> Status (Boolean)\n\nCheck whether the lock is held by any task/thread. This should not be used for synchronization (see instead trylock).\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.ReentrantLock",
    "page": "Tareas y Computación Paralela",
    "title": "Base.ReentrantLock",
    "category": "Type",
    "text": "ReentrantLock()\n\nCreates a reentrant lock for synchronizing Tasks. The same task can acquire the lock as many times as required. Each lock must be matched with an unlock.\n\nThis lock is NOT threadsafe. See Threads.Mutex for a threadsafe lock.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.Mutex",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.Mutex",
    "category": "Type",
    "text": "Mutex()\n\nThese are standard system mutexes for locking critical sections of logic.\n\nOn Windows, this is a critical section object, on pthreads, this is a pthread_mutex_t.\n\nSee also SpinLock for a lighter-weight lock.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.SpinLock",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.SpinLock",
    "category": "Type",
    "text": "SpinLock()\n\nCreates a non-reentrant lock. Recursive use will result in a deadlock. Each lock must be matched with an unlock.\n\nTest-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, perhaps a lock is the wrong way to synchronize.\n\nSee also RecursiveSpinLock for a version that permits recursion.\n\nSee also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Threads.RecursiveSpinLock",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Threads.RecursiveSpinLock",
    "category": "Type",
    "text": "RecursiveSpinLock()\n\nCreates a reentrant lock. The same thread can acquire the lock as many times as required. Each lock must be matched with an unlock.\n\nSee also SpinLock for a slightly faster version.\n\nSee also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Semaphore",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Semaphore",
    "category": "Type",
    "text": "Semaphore(sem_size)\n\nCreates a counting semaphore that allows at most sem_size acquires to be in use at any time. Each acquire must be mached with a release.\n\nThis construct is NOT threadsafe.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.acquire",
    "page": "Tareas y Computación Paralela",
    "title": "Base.acquire",
    "category": "Function",
    "text": "acquire(s::Semaphore)\n\nWait for one of the sem_size permits to be available, blocking until one can be acquired.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.release",
    "page": "Tareas y Computación Paralela",
    "title": "Base.release",
    "category": "Function",
    "text": "release(s::Semaphore)\n\nReturn one permit to the pool, possibly allowing another task to acquire it and resume execution.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Primitivas-de-Sincronización-1",
    "page": "Tareas y Computación Paralela",
    "title": "Primitivas de Sincronización",
    "category": "section",
    "text": "Base.Threads.AbstractLock\nBase.lock\nBase.unlock\nBase.trylock\nBase.islocked\nBase.ReentrantLock\nBase.Threads.Mutex\nBase.Threads.SpinLock\nBase.Threads.RecursiveSpinLock\nBase.Semaphore\nBase.acquire\nBase.release"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.launch",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.launch",
    "category": "Function",
    "text": "launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)\n\nImplemented by cluster managers. For every Julia worker launched by this function, it should append a WorkerConfig entry to launched and notify launch_ntfy. The function MUST exit once all workers, requested by manager have been launched. params is a dictionary of all keyword arguments addprocs was called with.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.manage",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.manage",
    "category": "Function",
    "text": "manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)\n\nImplemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate op values:\n\nwith :register/:deregister when a worker is added / removed from the Julia worker pool.\nwith :interrupt when interrupt(workers) is called. The ClusterManager should signal the appropriate worker with an interrupt signal.\nwith :finalize for cleanup purposes.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.kill-Tuple{ClusterManager,Int64,WorkerConfig}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.kill",
    "category": "Method",
    "text": "kill(manager::ClusterManager, pid::Int, config::WorkerConfig)\n\nImplemented by cluster managers. It is called on the master process, by rmprocs. It should cause the remote worker specified by pid to exit. kill(manager::ClusterManager.....) executes a remote exit() on pid.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.init_worker",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.init_worker",
    "category": "Function",
    "text": "init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())\n\nCalled by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument --worker has the effect of initializing a process as a worker using TCP/IP sockets for transport. cookie is a cluster_cookie.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.connect-Tuple{ClusterManager,Int64,WorkerConfig}",
    "page": "Tareas y Computación Paralela",
    "title": "Base.connect",
    "category": "Method",
    "text": "connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -> (instrm::IO, outstrm::IO)\n\nImplemented by cluster managers using custom transports. It should establish a logical connection to worker with id pid, specified by config and return a pair of IO objects. Messages from pid to current process will be read off instrm, while messages to be sent to pid will be written to outstrm. The custom transport implementation must ensure that messages are delivered and received completely and in order. connect(manager::ClusterManager.....) sets up TCP/IP socket connections in-between workers.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Base.Distributed.process_messages",
    "page": "Tareas y Computación Paralela",
    "title": "Base.Distributed.process_messages",
    "category": "Function",
    "text": "Base.process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)\n\nCalled by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two IO objects, one for incoming messages and the other for messages addressed to the remote worker. If incoming is true, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.\n\nSee also cluster_cookie.\n\n\n\n"
},

{
    "location": "stdlib/parallel.html#Interfaz-de-Administración-de-Cluster-1",
    "page": "Tareas y Computación Paralela",
    "title": "Interfaz de Administración de Cluster",
    "category": "section",
    "text": "Esta interfaz proporciona un mecanismo para lanzar y gestionar workers Julia sobre diferentes entornos cluster. Hay dos tipos de administrafores presentes en Base: LocalManager, para lanzar workers adicionales sobre el mismo host, y SSHManager, para lanzarlos sobre hosts remotos vía ssh. Para conectar y transportar mensajes entre procesos se usan los sockets TCP/IP. Es posible que los administradores de clusters proporcionen un transporte diferente.Base.launch\nBase.manage\nBase.kill(::ClusterManager, ::Int, ::WorkerConfig)\nBase.init_worker\nBase.connect(::ClusterManager, ::Int, ::WorkerConfig)\nBase.process_messages"
},

{
    "location": "stdlib/linalg.html#",
    "page": "Álgebra Lineal",
    "title": "Álgebra Lineal",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/linalg.html#lib-linear-algebra-1",
    "page": "Álgebra Lineal",
    "title": "Álgebra Lineal",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/linalg.html#Base.:*-Tuple{AbstractArray,AbstractArray}",
    "page": "Álgebra Lineal",
    "title": "Base.:*",
    "category": "Method",
    "text": "*(x, y...)\n\nMultiplication operator. x*y*z*... calls this function with all arguments, i.e. *(x, y, z, ...).\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.:\\-Tuple{AbstractArray,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.:\\",
    "category": "Method",
    "text": "\\(x, y)\n\nLeft division operator: multiplication of y by the inverse of x on the left. Gives floating-point results for integer arguments.\n\njulia> 3 \\ 6\n2.0\n\njulia> inv(3) * 6\n2.0\n\njulia> A = [1 2; 3 4]; x = [5, 6];\n\njulia> A \\ x\n2-element Array{Float64,1}:\n -4.0\n  4.5\n\njulia> inv(A) * x\n2-element Array{Float64,1}:\n -4.0\n  4.5\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.dot",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.dot",
    "category": "Function",
    "text": "dot(n, X, incx, Y, incy)\n\nDot product of two vectors consisting of n elements of array X with stride incx and n elements of array Y with stride incy.\n\nExample:\n\njulia> dot(10, ones(10), 1, ones(20), 2)\n10.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.vecdot",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.vecdot",
    "category": "Function",
    "text": "vecdot(x, y)\n\nFor any iterable containers x and y (including arrays of any dimension) of numbers (or any element type for which dot is defined), compute the Euclidean dot product (the sum of dot(x[i],y[i])) as if they were vectors.\n\nExamples\n\njulia> vecdot(1:5, 2:6)\n70\n\njulia> x = fill(2., (5,5));\n\njulia> y = fill(3., (5,5));\n\njulia> vecdot(x, y)\n150.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.cross",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.cross",
    "category": "Function",
    "text": "cross(x, y)\n×(x,y)\n\nCompute the cross product of two 3-vectors.\n\nExample\n\njulia> a = [0;1;0]\n3-element Array{Int64,1}:\n 0\n 1\n 0\n\njulia> b = [0;0;1]\n3-element Array{Int64,1}:\n 0\n 0\n 1\n\njulia> cross(a,b)\n3-element Array{Int64,1}:\n 1\n 0\n 0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.factorize",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.factorize",
    "category": "Function",
    "text": "factorize(A)\n\nCompute a convenient factorization of A, based upon the type of the input matrix. factorize checks A to see if it is symmetric/triangular/etc. if A is passed as a generic matrix. factorize checks every element of A to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: A=factorize(A); x=A\\b; y=A\\C.\n\nProperties of A type of factorization\nPositive-definite Cholesky (see cholfact)\nDense Symmetric/Hermitian Bunch-Kaufman (see bkfact)\nSparse Symmetric/Hermitian LDLt (see ldltfact)\nTriangular Triangular\nDiagonal Diagonal\nBidiagonal Bidiagonal\nTridiagonal LU (see lufact)\nSymmetric real tridiagonal LDLt (see ldltfact)\nGeneral square LU (see lufact)\nGeneral non-square QR (see qrfact)\n\nIf factorize is called on a Hermitian positive-definite matrix, for instance, then factorize will return a Cholesky factorization.\n\nExample\n\njulia> A = Array(Bidiagonal(ones(5, 5), true))\n5×5 Array{Float64,2}:\n 1.0  1.0  0.0  0.0  0.0\n 0.0  1.0  1.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0\n 0.0  0.0  0.0  1.0  1.0\n 0.0  0.0  0.0  0.0  1.0\n\njulia> factorize(A) # factorize will check to see that A is already factorized\n5×5 Bidiagonal{Float64}:\n 1.0  1.0   ⋅    ⋅    ⋅\n  ⋅   1.0  1.0   ⋅    ⋅\n  ⋅    ⋅   1.0  1.0   ⋅\n  ⋅    ⋅    ⋅   1.0  1.0\n  ⋅    ⋅    ⋅    ⋅   1.0\n\nThis returns a 5×5 Bidiagonal{Float64}, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for Bidiagonal types.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.Diagonal",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.Diagonal",
    "category": "Type",
    "text": "Diagonal(A::AbstractMatrix)\n\nConstructs a matrix from the diagonal of A.\n\nExample\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> Diagonal(A)\n3×3 Diagonal{Int64}:\n 1  ⋅  ⋅\n ⋅  5  ⋅\n ⋅  ⋅  9\n\n\n\nDiagonal(V::AbstractVector)\n\nConstructs a matrix with V as its diagonal.\n\nExample\n\njulia> V = [1; 2]\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> Diagonal(V)\n2×2 Diagonal{Int64}:\n 1  ⋅\n ⋅  2\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.Bidiagonal",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.Bidiagonal",
    "category": "Type",
    "text": "Bidiagonal(dv, ev, isupper::Bool)\n\nConstructs an upper (isupper=true) or lower (isupper=false) bidiagonal matrix using the given diagonal (dv) and off-diagonal (ev) vectors.  The result is of type Bidiagonal and provides efficient specialized linear solvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short). ev's length must be one less than the length of dv.\n\nExample\n\njulia> dv = [1; 2; 3; 4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> ev = [7; 8; 9]\n3-element Array{Int64,1}:\n 7\n 8\n 9\n\njulia> Bu = Bidiagonal(dv, ev, true) # ev is on the first superdiagonal\n4×4 Bidiagonal{Int64}:\n 1  7  ⋅  ⋅\n ⋅  2  8  ⋅\n ⋅  ⋅  3  9\n ⋅  ⋅  ⋅  4\n\njulia> Bl = Bidiagonal(dv, ev, false) # ev is on the first subdiagonal\n4×4 Bidiagonal{Int64}:\n 1  ⋅  ⋅  ⋅\n 7  2  ⋅  ⋅\n ⋅  8  3  ⋅\n ⋅  ⋅  9  4\n\n\n\nBidiagonal(dv, ev, uplo::Char)\n\nConstructs an upper (uplo='U') or lower (uplo='L') bidiagonal matrix using the given diagonal (dv) and off-diagonal (ev) vectors.  The result is of type Bidiagonal and provides efficient specialized linear solvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short). ev's length must be one less than the length of dv.\n\nExample\n\njulia> dv = [1; 2; 3; 4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> ev = [7; 8; 9]\n3-element Array{Int64,1}:\n 7\n 8\n 9\n\njulia> Bu = Bidiagonal(dv, ev, 'U') #e is on the first superdiagonal\n4×4 Bidiagonal{Int64}:\n 1  7  ⋅  ⋅\n ⋅  2  8  ⋅\n ⋅  ⋅  3  9\n ⋅  ⋅  ⋅  4\n\njulia> Bl = Bidiagonal(dv, ev, 'L') #e is on the first subdiagonal\n4×4 Bidiagonal{Int64}:\n 1  ⋅  ⋅  ⋅\n 7  2  ⋅  ⋅\n ⋅  8  3  ⋅\n ⋅  ⋅  9  4\n\n\n\nBidiagonal(A, isupper::Bool)\n\nConstruct a Bidiagonal matrix from the main diagonal of A and its first super- (if isupper=true) or sub-diagonal (if isupper=false).\n\nExample\n\njulia> A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]\n4×4 Array{Int64,2}:\n 1  1  1  1\n 2  2  2  2\n 3  3  3  3\n 4  4  4  4\n\njulia> Bidiagonal(A, true) #contains the main diagonal and first superdiagonal of A\n4×4 Bidiagonal{Int64}:\n 1  1  ⋅  ⋅\n ⋅  2  2  ⋅\n ⋅  ⋅  3  3\n ⋅  ⋅  ⋅  4\n\njulia> Bidiagonal(A, false) #contains the main diagonal and first subdiagonal of A\n4×4 Bidiagonal{Int64}:\n 1  ⋅  ⋅  ⋅\n 2  2  ⋅  ⋅\n ⋅  3  3  ⋅\n ⋅  ⋅  4  4\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.SymTridiagonal",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.SymTridiagonal",
    "category": "Type",
    "text": "SymTridiagonal(dv, ev)\n\nConstruct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, respectively. The result is of type SymTridiagonal and provides efficient specialized eigensolvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short).\n\nExample\n\njulia> dv = [1; 2; 3; 4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> ev = [7; 8; 9]\n3-element Array{Int64,1}:\n 7\n 8\n 9\n\njulia> SymTridiagonal(dv, ev)\n4×4 SymTridiagonal{Int64}:\n 1  7  ⋅  ⋅\n 7  2  8  ⋅\n ⋅  8  3  9\n ⋅  ⋅  9  4\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.Tridiagonal",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.Tridiagonal",
    "category": "Type",
    "text": "Tridiagonal(dl, d, du)\n\nConstruct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively.  The result is of type Tridiagonal and provides efficient specialized linear solvers, but may be converted into a regular matrix with convert(Array, _) (or Array(_) for short). The lengths of dl and du must be one less than the length of d.\n\nExample\n\njulia> dl = [1; 2; 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> du = [4; 5; 6]\n3-element Array{Int64,1}:\n 4\n 5\n 6\n\njulia> d = [7; 8; 9; 0]\n4-element Array{Int64,1}:\n 7\n 8\n 9\n 0\n\njulia> Tridiagonal(dl, d, du)\n4×4 Tridiagonal{Int64}:\n 7  4  ⋅  ⋅\n 1  8  5  ⋅\n ⋅  2  9  6\n ⋅  ⋅  3  0\n\n\n\nTridiagonal(A)\n\nreturns a Tridiagonal array based on (abstract) matrix A, using its first lower diagonal, main diagonal, and first upper diagonal.\n\nExample\n\njulia> A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]\n4×4 Array{Int64,2}:\n 1  2  3  4\n 1  2  3  4\n 1  2  3  4\n 1  2  3  4\n\njulia> Tridiagonal(A)\n4×4 Tridiagonal{Int64}:\n 1  2  ⋅  ⋅\n 1  2  3  ⋅\n ⋅  2  3  4\n ⋅  ⋅  3  4\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.Symmetric",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.Symmetric",
    "category": "Type",
    "text": "Symmetric(A, uplo=:U)\n\nConstruct a Symmetric view of the upper (if uplo = :U) or lower (if uplo = :L) triangle of the matrix A.\n\nExample\n\njulia> A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]\n5×5 Array{Int64,2}:\n 1  0  2  0  3\n 0  4  0  5  0\n 6  0  7  0  8\n 0  9  0  1  0\n 2  0  3  0  4\n\njulia> Supper = Symmetric(A)\n5×5 Symmetric{Int64,Array{Int64,2}}:\n 1  0  2  0  3\n 0  4  0  5  0\n 2  0  7  0  8\n 0  5  0  1  0\n 3  0  8  0  4\n\njulia> Slower = Symmetric(A, :L)\n5×5 Symmetric{Int64,Array{Int64,2}}:\n 1  0  6  0  2\n 0  4  0  9  0\n 6  0  7  0  3\n 0  9  0  1  0\n 2  0  3  0  4\n\nNote that Supper will not be equal to Slower unless A is itself symmetric (e.g. if A == A.').\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.Hermitian",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.Hermitian",
    "category": "Type",
    "text": "Hermitian(A, uplo=:U)\n\nConstruct a Hermitian view of the upper (if uplo = :U) or lower (if uplo = :L) triangle of the matrix A.\n\nExample\n\njulia> A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];\n\njulia> Hupper = Hermitian(A)\n5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:\n 1+0im  0+0im  2+2im  0+0im  3-3im\n 0+0im  4+0im  0+0im  5+0im  0+0im\n 2-2im  0+0im  7+0im  0+0im  8+8im\n 0+0im  5+0im  0+0im  1+0im  0+0im\n 3+3im  0+0im  8-8im  0+0im  4+0im\n\njulia> Hlower = Hermitian(A, :L)\n5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:\n 1+0im  0+0im  6+6im  0+0im  2-2im\n 0+0im  4+0im  0+0im  9+0im  0+0im\n 6-6im  0+0im  7+0im  0+0im  3+3im\n 0+0im  9+0im  0+0im  1+0im  0+0im\n 2+2im  0+0im  3-3im  0+0im  4+0im\n\nNote that Hupper will not be equal to Hlower unless A is itself Hermitian (e.g. if A == A').\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LowerTriangular",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LowerTriangular",
    "category": "Type",
    "text": "LowerTriangular(A::AbstractMatrix)\n\nConstruct a LowerTriangular view of the the matrix A.\n\nExample\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> LowerTriangular(A)\n3×3 LowerTriangular{Float64,Array{Float64,2}}:\n 1.0   ⋅    ⋅\n 4.0  5.0   ⋅\n 7.0  8.0  9.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.UpperTriangular",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.UpperTriangular",
    "category": "Type",
    "text": "UpperTriangular(A::AbstractMatrix)\n\nConstruct an UpperTriangular view of the the matrix A.\n\nExample\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]\n3×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n 7.0  8.0  9.0\n\njulia> UpperTriangular(A)\n3×3 UpperTriangular{Float64,Array{Float64,2}}:\n 1.0  2.0  3.0\n  ⋅   5.0  6.0\n  ⋅    ⋅   9.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lu",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lu",
    "category": "Function",
    "text": "lu(A, pivot=Val{true}) -> L, U, p\n\nCompute the LU factorization of A, such that A[p,:] = L*U. By default, pivoting is used. This can be overridden by passing Val{false} for the second argument.\n\nSee also lufact.\n\nExample\n\njulia> A = [4. 3.; 6. 3.]\n2×2 Array{Float64,2}:\n 4.0  3.0\n 6.0  3.0\n\njulia> L, U, p = lu(A)\n([1.0 0.0; 0.666667 1.0], [6.0 3.0; 0.0 1.0], [2, 1])\n\njulia> A[p, :] == L * U\ntrue\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lufact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lufact",
    "category": "Function",
    "text": "lufact(A [,pivot=Val{true}]) -> F::LU\n\nCompute the LU factorization of A.\n\nIn most cases, if A is a subtype S of AbstractMatrix{T} with an element type T supporting +, -, * and /, the return type is LU{T,S{T}}. If pivoting is chosen (default) the element type should also support abs and <.\n\nThe individual components of the factorization F can be accessed by indexing:\n\nComponent Description\nF[:L] L (lower triangular) part of LU\nF[:U] U (upper triangular) part of LU\nF[:p] (right) permutation Vector\nF[:P] (right) permutation Matrix\n\nThe relationship between F and A is\n\nF[:L]*F[:U] == A[F[:p], :]\n\nF further supports the following functions:\n\nSupported function LU LU{T,Tridiagonal{T}}\n/ ✓ \n\\ ✓ ✓\ncond ✓ \ninv ✓ ✓\ndet ✓ ✓\nlogdet ✓ ✓\nlogabsdet ✓ ✓\nsize ✓ ✓\n\nExample\n\njulia> A = [4 3; 6 3]\n2×2 Array{Int64,2}:\n 4  3\n 6  3\n\njulia> F = lufact(A)\nBase.LinAlg.LU{Float64,Array{Float64,2}} with factors L and U:\n[1.0 0.0; 1.5 1.0]\n[4.0 3.0; 0.0 -1.5]\n\njulia> F[:L] * F[:U] == A[F[:p], :]\ntrue\n\n\n\nlufact(A::SparseMatrixCSC) -> F::UmfpackLU\n\nCompute the LU factorization of a sparse matrix A.\n\nFor sparse A with real or complex element type, the return type of F is UmfpackLU{Tv, Ti}, with Tv = Float64 or Complex128 respectively and Ti is an integer type (Int32 or Int64).\n\nThe individual components of the factorization F can be accessed by indexing:\n\nComponent Description\nF[:L] L (lower triangular) part of LU\nF[:U] U (upper triangular) part of LU\nF[:p] right permutation Vector\nF[:q] left permutation Vector\nF[:Rs] Vector of scaling factors\nF[:(:)] (L,U,p,q,Rs) components\n\nThe relation between F and A is\n\nF[:L]*F[:U] == (F[:Rs] .* A)[F[:p], F[:q]]\n\nF further supports the following functions:\n\n\\\ncond\ndet\n\nnote: Note\nlufact(A::SparseMatrixCSC) uses the UMFPACK library that is part of SuiteSparse. As this library only supports sparse matrices with Float64 or Complex128 elements, lufact converts A into a copy that is of type SparseMatrixCSC{Float64} or SparseMatrixCSC{Complex128} as appropriate.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lufact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lufact!",
    "category": "Function",
    "text": "lufact!(A, pivot=Val{true}) -> LU\n\nlufact! is the same as lufact, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.chol",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.chol",
    "category": "Function",
    "text": "chol(A) -> U\n\nCompute the Cholesky factorization of a positive definite matrix A and return the UpperTriangular matrix U such that A = U'U.\n\nExample\n\njulia> A = [1. 2.; 2. 50.]\n2×2 Array{Float64,2}:\n 1.0   2.0\n 2.0  50.0\n\njulia> U = chol(A)\n2×2 UpperTriangular{Float64,Array{Float64,2}}:\n 1.0  2.0\n  ⋅   6.78233\n\njulia> U'U\n2×2 Array{Float64,2}:\n 1.0   2.0\n 2.0  50.0\n\n\n\nchol(x::Number) -> y\n\nCompute the square root of a non-negative number x.\n\nExample\n\njulia> chol(16)\n4.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.cholfact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.cholfact",
    "category": "Function",
    "text": "cholfact(A, [uplo::Symbol,] Val{false}) -> Cholesky\n\nCompute the Cholesky factorization of a dense symmetric positive definite matrix A and return a Cholesky factorization. The matrix A can either be a Symmetric or Hermitian StridedMatrix or a perfectly symmetric or Hermitian StridedMatrix. In the latter case, the optional argument uplo may be :L for using the lower part or :U for the upper part of A. The default is to use :U. The triangular Cholesky factor can be obtained from the factorization F with: F[:L] and F[:U]. The following functions are available for Cholesky objects: size, \\, inv, and det. A PosDefException exception is thrown in case the matrix is not positive definite.\n\nExample\n\njulia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]\n3×3 Array{Float64,2}:\n   4.0   12.0  -16.0\n  12.0   37.0  -43.0\n -16.0  -43.0   98.0\n\njulia> C = cholfact(A)\nBase.LinAlg.Cholesky{Float64,Array{Float64,2}} with factor:\n[2.0 6.0 -8.0; 0.0 1.0 5.0; 0.0 0.0 3.0]\n\njulia> C[:U]\n3×3 UpperTriangular{Float64,Array{Float64,2}}:\n 2.0  6.0  -8.0\n  ⋅   1.0   5.0\n  ⋅    ⋅    3.0\n\njulia> C[:L]\n3×3 LowerTriangular{Float64,Array{Float64,2}}:\n  2.0   ⋅    ⋅\n  6.0  1.0   ⋅\n -8.0  5.0  3.0\n\njulia> C[:L] * C[:U] == A\ntrue\n\n\n\ncholfact(A, [uplo::Symbol,] Val{true}; tol = 0.0) -> CholeskyPivoted\n\nCompute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix A and return a CholeskyPivoted factorization. The matrix A can either be a Symmetric or Hermitian StridedMatrix or a perfectly symmetric or Hermitian StridedMatrix. In the latter case, the optional argument uplo may be :L for using the lower part or :U for the upper part of A. The default is to use :U. The triangular Cholesky factor can be obtained from the factorization F with: F[:L] and F[:U]. The following functions are available for PivotedCholesky objects: size, \\, inv, det, and rank. The argument tol determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.\n\n\n\ncholfact(A; shift = 0.0, perm = Int[]) -> CHOLMOD.Factor\n\nCompute the Cholesky factorization of a sparse positive definite matrix A. A must be a SparseMatrixCSC or a Symmetric/Hermitian view of a SparseMatrixCSC. Note that even if A doesn't have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. F = cholfact(A) is most frequently used to solve systems of equations with F\\b, but also the methods diag, det, and logdet are defined for F. You can also extract individual factors from F, using F[:L]. However, since pivoting is on by default, the factorization is internally represented as A == P'*L*L'*P with a permutation matrix P; using just L without accounting for P will give incorrect answers. To include the effects of permutation, it's typically preferable to extract \"combined\" factors like PtL = F[:PtL] (the equivalent of P'*L) and LtP = F[:UP] (the equivalent of L'*P).\n\nSetting the optional shift keyword argument computes the factorization of A+shift*I instead of A. If the perm argument is nonempty, it should be a permutation of 1:size(A,1) giving the ordering to use (instead of CHOLMOD's default AMD ordering).\n\nnote: Note\nThis method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to SparseMatrixCSC{Float64} or SparseMatrixCSC{Complex128} as appropriate.Many other functions from CHOLMOD are wrapped but not exported from the Base.SparseArrays.CHOLMOD module.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.cholfact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.cholfact!",
    "category": "Function",
    "text": "cholfact!(A, [uplo::Symbol,] Val{false}) -> Cholesky\n\nThe same as cholfact, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\n\nExample\n\njulia> A = [1 2; 2 50]\n2×2 Array{Int64,2}:\n 1   2\n 2  50\n\njulia> cholfact!(A)\nERROR: InexactError()\n\n\n\ncholfact!(A, [uplo::Symbol,] Val{true}; tol = 0.0) -> CholeskyPivoted\n\nThe same as cholfact, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\n\n\n\ncholfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor\n\nCompute the Cholesky (LL) factorization of A, reusing the symbolic factorization F. A must be a SparseMatrixCSC or a Symmetric/ Hermitian view of a SparseMatrixCSC. Note that even if A doesn't have the type tag, it must still be symmetric or Hermitian.\n\nSee also cholfact.\n\nnote: Note\nThis method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to SparseMatrixCSC{Float64} or SparseMatrixCSC{Complex128} as appropriate.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lowrankupdate",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lowrankupdate",
    "category": "Function",
    "text": "lowrankupdate(C::Cholesky, v::StridedVector) -> CC::Cholesky\n\nUpdate a Cholesky factorization C with the vector v. If A = C[:U]'C[:U] then CC = cholfact(C[:U]'C[:U] + v*v') but the computation of CC only uses O(n^2) operations.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lowrankdowndate",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lowrankdowndate",
    "category": "Function",
    "text": "lowrankdowndate(C::Cholesky, v::StridedVector) -> CC::Cholesky\n\nDowndate a Cholesky factorization C with the vector v. If A = C[:U]'C[:U] then CC = cholfact(C[:U]'C[:U] - v*v') but the computation of CC only uses O(n^2) operations.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lowrankupdate!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lowrankupdate!",
    "category": "Function",
    "text": "lowrankupdate!(C::Cholesky, v::StridedVector) -> CC::Cholesky\n\nUpdate a Cholesky factorization C with the vector v. If A = C[:U]'C[:U] then CC = cholfact(C[:U]'C[:U] + v*v') but the computation of CC only uses O(n^2) operations. The input factorization C is updated in place such that on exit C == CC. The vector v is destroyed during the computation.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lowrankdowndate!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lowrankdowndate!",
    "category": "Function",
    "text": "lowrankdowndate!(C::Cholesky, v::StridedVector) -> CC::Cholesky\n\nDowndate a Cholesky factorization C with the vector v. If A = C[:U]'C[:U] then CC = cholfact(C[:U]'C[:U] - v*v') but the computation of CC only uses O(n^2) operations. The input factorization C is updated in place such that on exit C == CC. The vector v is destroyed during the computation.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.ldltfact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.ldltfact",
    "category": "Function",
    "text": "ldltfact(S::SymTridiagonal) -> LDLt\n\nCompute an LDLt factorization of a real symmetric tridiagonal matrix such that A = L*Diagonal(d)*L' where L is a unit lower triangular matrix and d is a vector. The main use of an LDLt factorization F = ldltfact(A) is to solve the linear system of equations Ax = b with F\\b.\n\n\n\nldltfact(A; shift = 0.0, perm=Int[]) -> CHOLMOD.Factor\n\nCompute the LDL factorization of a sparse matrix A. A must be a SparseMatrixCSC or a Symmetric/Hermitian view of a SparseMatrixCSC. Note that even if A doesn't have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. F = ldltfact(A) is most frequently used to solve systems of equations A*x = b with F\\b. The returned factorization object F also supports the methods diag, det, logdet, and inv. You can extract individual factors from F using F[:L]. However, since pivoting is on by default, the factorization is internally represented as A == P'*L*D*L'*P with a permutation matrix P; using just L without accounting for P will give incorrect answers. To include the effects of permutation, it is typically preferable to extract \"combined\" factors like PtL = F[:PtL] (the equivalent of P'*L) and LtP = F[:UP] (the equivalent of L'*P). The complete list of supported factors is :L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP.\n\nSetting the optional shift keyword argument computes the factorization of A+shift*I instead of A. If the perm argument is nonempty, it should be a permutation of 1:size(A,1) giving the ordering to use (instead of CHOLMOD's default AMD ordering).\n\nnote: Note\nThis method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to SparseMatrixCSC{Float64} or SparseMatrixCSC{Complex128} as appropriate.Many other functions from CHOLMOD are wrapped but not exported from the Base.SparseArrays.CHOLMOD module.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.ldltfact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.ldltfact!",
    "category": "Function",
    "text": "ldltfact!(S::SymTridiagonal) -> LDLt\n\nSame as ldltfact, but saves space by overwriting the input A, instead of creating a copy.\n\n\n\nldltfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor\n\nCompute the LDL factorization of A, reusing the symbolic factorization F. A must be a SparseMatrixCSC or a Symmetric/Hermitian view of a SparseMatrixCSC. Note that even if A doesn't have the type tag, it must still be symmetric or Hermitian.\n\nSee also ldltfact.\n\nnote: Note\nThis method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to SparseMatrixCSC{Float64} or SparseMatrixCSC{Complex128} as appropriate.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.qr",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.qr",
    "category": "Function",
    "text": "qr(A, pivot=Val{false}; thin::Bool=true) -> Q, R, [p]\n\nCompute the (pivoted) QR factorization of A such that either A = Q*R or A[:,p] = Q*R. Also see qrfact. The default is to compute a thin factorization. Note that R is not extended with zeros when the full Q is requested.\n\n\n\nqr(v::AbstractVector) -> w, r\n\nComputes the polar decomposition of a vector. Returns w, a unit vector in the direction of v, and r, the norm of v.\n\nSee also normalize, normalize!, and LinAlg.qr!.\n\nExample\n\njulia> v = [1; 2]\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> w, r = qr(v)\n([0.447214, 0.894427], 2.23606797749979)\n\njulia> w*r == v\ntrue\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.qr!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.qr!",
    "category": "Function",
    "text": "LinAlg.qr!(v::AbstractVector) -> w, r\n\nComputes the polar decomposition of a vector. Instead of returning a new vector as qr(v::AbstractVector), this function mutates the input vector v in place. Returns w, a unit vector in the direction of v (this is a mutation of v), and r, the norm of v.\n\nSee also normalize, normalize!, and qr.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.qrfact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.qrfact",
    "category": "Function",
    "text": "qrfact(A) -> SPQR.Factorization\n\nCompute the QR factorization of a sparse matrix A. A fill-reducing permutation is used. The main application of this type is to solve least squares problems with \\. The function calls the C library SPQR and a few additional functions from the library are wrapped but not exported.\n\n\n\nqrfact(A, pivot=Val{false}) -> F\n\nCompute the QR factorization of the matrix A: an orthogonal (or unitary if A is complex-valued) matrix Q, and an upper triangular matrix R such that\n\nA = Q R\n\nThe returned object F stores the factorization in a packed format:\n\nif pivot == Val{true} then F is a QRPivoted object,\notherwise if the element type of A is a BLAS type (Float32, Float64, Complex64 or Complex128), then F is a QRCompactWY object,\notherwise F is a QR object.\n\nThe individual components of the factorization F can be accessed by indexing with a symbol:\n\nF[:Q]: the orthogonal/unitary matrix Q\nF[:R]: the upper triangular matrix R\nF[:p]: the permutation vector of the pivot (QRPivoted only)\nF[:P]: the permutation matrix of the pivot (QRPivoted only)\n\nThe following functions are available for the QR objects: inv, size, and \\. When A is rectangular, \\ will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.\n\nMultiplication with respect to either thin or full Q is allowed, i.e. both F[:Q]*F[:R] and F[:Q]*A are supported. A Q matrix can be converted into a regular matrix with full which has a named argument thin.\n\nExample\n\njulia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]\n3×2 Array{Float64,2}:\n 3.0  -6.0\n 4.0  -8.0\n 0.0   1.0\n\njulia> F = qrfact(A)\nBase.LinAlg.QRCompactWY{Float64,Array{Float64,2}} with factors Q and R:\n[-0.6 0.0 0.8; -0.8 0.0 -0.6; 0.0 -1.0 0.0]\n[-5.0 10.0; 0.0 -1.0]\n\njulia> F[:Q] * F[:R] == A\ntrue\n\nnote: Note\nqrfact returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the Q and R matrices can be stored compactly rather as two separate dense matrices.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.qrfact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.qrfact!",
    "category": "Function",
    "text": "qrfact!(A, pivot=Val{false})\n\nqrfact! is the same as qrfact when A is a subtype of StridedMatrix, but saves space by overwriting the input A, instead of creating a copy. An InexactError exception is thrown if the factorization produces a number not representable by the element type of A, e.g. for integer types.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.QR",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.QR",
    "category": "Type",
    "text": "QR <: Factorization\n\nA QR matrix factorization stored in a packed format, typically obtained from qrfact. If A is an m×n matrix, then\n\nA = Q R\n\nwhere Q is an orthogonal/unitary matrix and R is upper triangular. The matrix Q is stored as a sequence of Householder reflectors v_i and coefficients tau_i where:\n\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T)\n\nThe object has two fields:\n\nfactors is an m×n matrix.\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\nThe subdiagonal part contains the reflectors v_i stored in a packed format where v_i is the ith column of the matrix V = eye(m,n) + tril(F.factors,-1).\nτ is a vector  of length min(m,n) containing the coefficients au_i.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.QRCompactWY",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.QRCompactWY",
    "category": "Type",
    "text": "QRCompactWY <: Factorization\n\nA QR matrix factorization stored in a compact blocked format, typically obtained from qrfact. If A is an m×n matrix, then\n\nA = Q R\n\nwhere Q is an orthogonal/unitary matrix and R is upper triangular. It is similar to the QR format except that the orthogonal/unitary matrix Q is stored in Compact WY format [Schreiber1989], as a lower trapezoidal matrix V and an upper triangular matrix T where\n\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T) = I - V T V^T\n\nsuch that v_i is the ith column of V, and au_i is the ith diagonal element of T.\n\nThe object has two fields:\n\nfactors, as in the QR type, is an m×n matrix.\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\nThe subdiagonal part contains the reflectors v_i stored in a packed format such that V = eye(m,n) + tril(F.factors,-1).\nT is a square matrix with min(m,n) columns, whose upper triangular part gives the matrix T above (the subdiagonal elements are ignored).\n\nnote: Note\nThis format should not to be confused with the older WY representation [Bischof1987].\n\n[Bischof1987]: C Bischof and C Van Loan, \"The WY representation for products of Householder matrices\", SIAM J Sci Stat Comput 8 (1987), s2-s13. doi:10.1137/0908009\n\n[Schreiber1989]: R Schreiber and C Van Loan, \"A storage-efficient WY representation for products of Householder transformations\", SIAM J Sci Stat Comput 10 (1989), 53-57. doi:10.1137/0910005\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.QRPivoted",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.QRPivoted",
    "category": "Type",
    "text": "QRPivoted <: Factorization\n\nA QR matrix factorization with column pivoting in a packed format, typically obtained from qrfact. If A is an m×n matrix, then\n\nA P = Q R\n\nwhere P is a permutation matrix, Q is an orthogonal/unitary matrix and R is upper triangular. The matrix Q is stored as a sequence of Householder reflectors:\n\nQ = prod_i=1^min(mn) (I - tau_i v_i v_i^T)\n\nThe object has three fields:\n\nfactors is an m×n matrix.\nThe upper triangular part contains the elements of R, that is R = triu(F.factors) for a QR object F.\nThe subdiagonal part contains the reflectors v_i stored in a packed format where v_i is the ith column of the matrix V = eye(m,n) + tril(F.factors,-1).\nτ is a vector of length min(m,n) containing the coefficients au_i.\njpvt is an integer vector of length n corresponding to the permutation P.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lqfact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lqfact!",
    "category": "Function",
    "text": "lqfact!(A) -> LQ\n\nCompute the LQ factorization of A, using the input matrix as a workspace. See also lq.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lqfact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lqfact",
    "category": "Function",
    "text": "lqfact(A) -> LQ\n\nCompute the LQ factorization of A. See also lq.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lq",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lq",
    "category": "Function",
    "text": "lq(A; [thin=true]) -> L, Q\n\nPerform an LQ factorization of A such that A = L*Q. The default is to compute a thin factorization. The LQ factorization is the QR factorization of A.'. L is not extended with zeros if the full Q is requested.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.bkfact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.bkfact",
    "category": "Function",
    "text": "bkfact(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -> BunchKaufman\n\nCompute the Bunch-Kaufman [Bunch1977] factorization of a symmetric or Hermitian matrix A and return a BunchKaufman object. uplo indicates which triangle of matrix A to reference. If symmetric is true, A is assumed to be symmetric. If symmetric is false, A is assumed to be Hermitian. If rook is true, rook pivoting is used. If rook is false, rook pivoting is not used. The following functions are available for BunchKaufman objects: size, \\, inv, issymmetric, ishermitian.\n\n[Bunch1977]: J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. url.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.bkfact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.bkfact!",
    "category": "Function",
    "text": "bkfact!(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -> BunchKaufman\n\nbkfact! is the same as bkfact, but saves space by overwriting the input A, instead of creating a copy.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eig",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eig",
    "category": "Function",
    "text": "eig(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> D, V\neig(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> D, V\neig(A, permute::Bool=true, scale::Bool=true) -> D, V\n\nComputes eigenvalues (D) and eigenvectors (V) of A. See eigfact for details on the irange, vl, and vu arguments (for SymTridiagonal, Hermitian, and Symmetric matrices) and the permute and scale keyword arguments. The eigenvectors are returned columnwise.\n\nExample\n\njulia> eig([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\n([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])\n\neig is a wrapper around eigfact, extracting all parts of the factorization to a tuple; where possible, using eigfact is recommended.\n\n\n\neig(A, B) -> D, V\n\nComputes generalized eigenvalues (D) and vectors (V) of A with respect to B.\n\neig is a wrapper around eigfact, extracting all parts of the factorization to a tuple; where possible, using eigfact is recommended.\n\nExample\n\njulia> A = [1 0; 0 -1]\n2×2 Array{Int64,2}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Array{Int64,2}:\n 0  1\n 1  0\n\njulia> eig(A, B)\n(Complex{Float64}[0.0+1.0im, 0.0-1.0im], Complex{Float64}[0.0-1.0im 0.0+1.0im; -1.0-0.0im -1.0+0.0im])\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eigvals",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eigvals",
    "category": "Function",
    "text": "eigvals(A; permute::Bool=true, scale::Bool=true) -> values\n\nReturns the eigenvalues of A.\n\nFor general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is true for both options.\n\n\n\neigvals(A, B) -> values\n\nComputes the generalized eigenvalues of A and B.\n\nExample\n\njulia> A = [1 0; 0 -1]\n2×2 Array{Int64,2}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Array{Int64,2}:\n 0  1\n 1  0\n\njulia> eigvals(A,B)\n2-element Array{Complex{Float64},1}:\n 0.0+1.0im\n 0.0-1.0im\n\n\n\neigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values\n\nReturns the eigenvalues of A. It is possible to calculate only a subset of the eigenvalues by specifying a UnitRange irange covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.\n\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\n3×3 SymTridiagonal{Float64}:\n 1.0  2.0   ⋅\n 2.0  2.0  3.0\n  ⋅   3.0  1.0\n\njulia> eigvals(A, 2:2)\n1-element Array{Float64,1}:\n 1.0\n\njulia> eigvals(A)\n3-element Array{Float64,1}:\n -2.14005\n  1.0\n  5.14005\n\n\n\neigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values\n\nReturns the eigenvalues of A. It is possible to calculate only a subset of the eigenvalues by specifying a pair vl and vu for the lower and upper boundaries of the eigenvalues.\n\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\n3×3 SymTridiagonal{Float64}:\n 1.0  2.0   ⋅\n 2.0  2.0  3.0\n  ⋅   3.0  1.0\n\njulia> eigvals(A, -1, 2)\n1-element Array{Float64,1}:\n 1.0\n\njulia> eigvals(A)\n3-element Array{Float64,1}:\n -2.14005\n  1.0\n  5.14005\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eigvals!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eigvals!",
    "category": "Function",
    "text": "eigvals!(A; permute::Bool=true, scale::Bool=true) -> values\n\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm.\n\n\n\neigvals!(A, B) -> values\n\nSame as eigvals, but saves space by overwriting the input A (and B), instead of creating copies.\n\n\n\neigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values\n\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy. irange is a range of eigenvalue indices to search for - for instance, the 2nd to 8th eigenvalues.\n\n\n\neigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values\n\nSame as eigvals, but saves space by overwriting the input A, instead of creating a copy. vl is the lower bound of the interval to search for eigenvalues, and vu is the upper bound.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eigmax",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eigmax",
    "category": "Function",
    "text": "eigmax(A; permute::Bool=true, scale::Bool=true)\n\nReturns the largest eigenvalue of A. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of A are complex, this method will fail, since complex numbers cannot be sorted.\n\nExample\n\njulia> A = [0 im; -im 0]\n2×2 Array{Complex{Int64},2}:\n 0+0im  0+1im\n 0-1im  0+0im\n\njulia> eigmax(A)\n1.0\n\njulia> A = [0 im; -1 0]\n2×2 Array{Complex{Int64},2}:\n  0+0im  0+1im\n -1+0im  0+0im\n\njulia> eigmax(A)\nERROR: DomainError:\nStacktrace:\n [1] #eigmax#46(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:238\n [2] eigmax(::Array{Complex{Int64},2}) at ./linalg/eigen.jl:236\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eigmin",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eigmin",
    "category": "Function",
    "text": "eigmin(A; permute::Bool=true, scale::Bool=true)\n\nReturns the smallest eigenvalue of A. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of A are complex, this method will fail, since complex numbers cannot be sorted.\n\nExample\n\njulia> A = [0 im; -im 0]\n2×2 Array{Complex{Int64},2}:\n 0+0im  0+1im\n 0-1im  0+0im\n\njulia> eigmin(A)\n-1.0\n\njulia> A = [0 im; -1 0]\n2×2 Array{Complex{Int64},2}:\n  0+0im  0+1im\n -1+0im  0+0im\n\njulia> eigmin(A)\nERROR: DomainError:\nStacktrace:\n [1] #eigmin#47(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:280\n [2] eigmin(::Array{Complex{Int64},2}) at ./linalg/eigen.jl:278\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eigvecs",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eigvecs",
    "category": "Function",
    "text": "eigvecs(A::SymTridiagonal[, eigvals]) -> Matrix\n\nReturns a matrix M whose columns are the eigenvectors of A. (The kth eigenvector can be obtained from the slice M[:, k].)\n\nIf the optional vector of eigenvalues eigvals is specified, eigvecs returns the specific corresponding eigenvectors.\n\nExample\n\njulia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])\n3×3 SymTridiagonal{Float64}:\n 1.0  2.0   ⋅\n 2.0  2.0  3.0\n  ⋅   3.0  1.0\n\njulia> eigvals(A)\n3-element Array{Float64,1}:\n -2.14005\n  1.0\n  5.14005\n\njulia> eigvecs(A)\n3×3 Array{Float64,2}:\n  0.418304  -0.83205      0.364299\n -0.656749  -7.39009e-16  0.754109\n  0.627457   0.5547       0.546448\n\njulia> eigvecs(A, [1.])\n3×1 Array{Float64,2}:\n  0.83205\n  4.26351e-17\n -0.5547\n\n\n\neigvecs(A; permute::Bool=true, scale::Bool=true) -> Matrix\n\nReturns a matrix M whose columns are the eigenvectors of A. (The kth eigenvector can be obtained from the slice M[:, k].) The permute and scale keywords are the same as for eigfact.\n\nExample\n\njulia> eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\neigvecs(A, B) -> Matrix\n\nReturns a matrix M whose columns are the generalized eigenvectors of A and B. (The kth eigenvector can be obtained from the slice M[:, k].)\n\nExample\n\njulia> A = [1 0; 0 -1]\n2×2 Array{Int64,2}:\n 1   0\n 0  -1\n\njulia> B = [0 1; 1 0]\n2×2 Array{Int64,2}:\n 0  1\n 1  0\n\njulia> eigvecs(A, B)\n2×2 Array{Complex{Float64},2}:\n  0.0-1.0im   0.0+1.0im\n -1.0-0.0im  -1.0+0.0im\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eigfact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eigfact",
    "category": "Function",
    "text": "eigfact(A; permute::Bool=true, scale::Bool=true) -> Eigen\n\nComputes the eigenvalue decomposition of A, returning an Eigen factorization object F which contains the eigenvalues in F[:values] and the eigenvectors in the columns of the matrix F[:vectors]. (The kth eigenvector can be obtained from the slice F[:vectors][:, k].)\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\nFor general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option permute=true permutes the matrix to become closer to upper triangular, and scale=true scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is true for both options.\n\nExample\n\njulia> F = eigfact([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])\nBase.LinAlg.Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])\n\njulia> F[:values]\n3-element Array{Float64,1}:\n  1.0\n  3.0\n 18.0\n\njulia> F[:vectors]\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\neigfact(A, B) -> GeneralizedEigen\n\nComputes the generalized eigenvalue decomposition of A and B, returning a GeneralizedEigen factorization object F which contains the generalized eigenvalues in F[:values] and the generalized eigenvectors in the columns of the matrix F[:vectors]. (The kth generalized eigenvector can be obtained from the slice F[:vectors][:, k].)\n\n\n\neigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen\n\nComputes the eigenvalue decomposition of A, returning an Eigen factorization object F which contains the eigenvalues in F[:values] and the eigenvectors in the columns of the matrix F[:vectors]. (The kth eigenvector can be obtained from the slice F[:vectors][:, k].)\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\nThe UnitRange irange specifies indices of the sorted eigenvalues to search for.\n\nnote: Note\nIf irange is not 1:n, where n is the dimension of A, then the returned factorization will be a truncated factorization.\n\n\n\neigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen\n\nComputes the eigenvalue decomposition of A, returning an Eigen factorization object F which contains the eigenvalues in F[:values] and the eigenvectors in the columns of the matrix F[:vectors]. (The kth eigenvector can be obtained from the slice F[:vectors][:, k].)\n\nThe following functions are available for Eigen objects: inv, det, and isposdef.\n\nvl is the lower bound of the window of eigenvalues to search for, and vu is the upper bound.\n\nnote: Note\nIf [vl, vu] does not contain all eigenvalues of A, then the returned factorization will be a truncated factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eigfact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eigfact!",
    "category": "Function",
    "text": "eigfact!(A, [B])\n\nSame as eigfact, but saves space by overwriting the input A (and B), instead of creating a copy.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.hessfact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.hessfact",
    "category": "Function",
    "text": "hessfact(A) -> Hessenberg\n\nCompute the Hessenberg decomposition of A and return a Hessenberg object. If F is the factorization object, the unitary matrix can be accessed with F[:Q] and the Hessenberg matrix with F[:H]. When Q is extracted, the resulting type is the HessenbergQ object, and may be converted to a regular matrix with convert(Array, _)  (or Array(_) for short).\n\nExample\n\njulia> A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]\n3×3 Array{Float64,2}:\n 4.0  9.0  7.0\n 4.0  4.0  1.0\n 4.0  3.0  2.0\n\njulia> F = hessfact(A);\n\njulia> F[:Q] * F[:H] * F[:Q]'\n3×3 Array{Float64,2}:\n 4.0  9.0  7.0\n 4.0  4.0  1.0\n 4.0  3.0  2.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.hessfact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.hessfact!",
    "category": "Function",
    "text": "hessfact!(A) -> Hessenberg\n\nhessfact! is the same as hessfact, but saves space by overwriting the input A, instead of creating a copy.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.schurfact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.schurfact",
    "category": "Function",
    "text": "schurfact(A::StridedMatrix) -> F::Schur\n\nComputes the Schur factorization of the matrix A. The (quasi) triangular Schur factor can be obtained from the Schur object F with either F[:Schur] or F[:T] and the orthogonal/unitary Schur vectors can be obtained with F[:vectors] or F[:Z] such that A = F[:vectors]*F[:Schur]*F[:vectors]'. The eigenvalues of A can be obtained with F[:values].\n\nExample\n\njulia> A = [-2. 1. 3.; 2. 1. -1.; -7. 2. 7.]\n3×3 Array{Float64,2}:\n -2.0  1.0   3.0\n  2.0  1.0  -1.0\n -7.0  2.0   7.0\n\njulia> F = schurfact(A)\nBase.LinAlg.Schur{Float64,Array{Float64,2}} with factors T and Z:\n[2.0 0.801792 6.63509; -8.55988e-11 2.0 8.08286; 0.0 0.0 1.99999]\n[0.577351 0.154299 -0.801784; 0.577346 -0.77152 0.267262; 0.577354 0.617211 0.534522]\nand values:\nComplex{Float64}[2.0+8.28447e-6im, 2.0-8.28447e-6im, 1.99999+0.0im]\n\njulia> F[:vectors] * F[:Schur] * F[:vectors]'\n3×3 Array{Float64,2}:\n -2.0  1.0   3.0\n  2.0  1.0  -1.0\n -7.0  2.0   7.0\n\n\n\nschurfact(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur\n\nComputes the Generalized Schur (or QZ) factorization of the matrices A and B. The (quasi) triangular Schur factors can be obtained from the Schur object F with F[:S] and F[:T], the left unitary/orthogonal Schur vectors can be obtained with F[:left] or F[:Q] and the right unitary/orthogonal Schur vectors can be obtained with F[:right] or F[:Z] such that A=F[:left]*F[:S]*F[:right]' and B=F[:left]*F[:T]*F[:right]'. The generalized eigenvalues of A and B can be obtained with F[:alpha]./F[:beta].\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.schurfact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.schurfact!",
    "category": "Function",
    "text": "schurfact!(A::StridedMatrix) -> F::Schur\n\nSame as schurfact but uses the input argument as workspace.\n\n\n\nschurfact!(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur\n\nSame as schurfact but uses the input matrices A and B as workspace.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.schur",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.schur",
    "category": "Function",
    "text": "schur(A::StridedMatrix) -> T::Matrix, Z::Matrix, λ::Vector\n\nComputes the Schur factorization of the matrix A. The methods return the (quasi) triangular Schur factor T and the orthogonal/unitary Schur vectors Z such that A = Z*T*Z'. The eigenvalues of A are returned in the vector λ.\n\nSee schurfact.\n\nExample\n\njulia> A = [-2. 1. 3.; 2. 1. -1.; -7. 2. 7.]\n3×3 Array{Float64,2}:\n -2.0  1.0   3.0\n  2.0  1.0  -1.0\n -7.0  2.0   7.0\n\njulia> T, Z, lambda = schur(A)\n([2.0 0.801792 6.63509; -8.55988e-11 2.0 8.08286; 0.0 0.0 1.99999], [0.577351 0.154299 -0.801784; 0.577346 -0.77152 0.267262; 0.577354 0.617211 0.534522], Complex{Float64}[2.0+8.28447e-6im, 2.0-8.28447e-6im, 1.99999+0.0im])\n\njulia> Z * T * Z'\n3×3 Array{Float64,2}:\n -2.0  1.0   3.0\n  2.0  1.0  -1.0\n -7.0  2.0   7.0\n\n\n\nschur(A::StridedMatrix, B::StridedMatrix) -> S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector\n\nSee schurfact.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.ordschur",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.ordschur",
    "category": "Function",
    "text": "ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur\n\nReorders the Schur factorization F of a matrix A = Z*T*Z' according to the logical array select returning the reordered factorization F object. The selected eigenvalues appear in the leading diagonal of F[:Schur] and the corresponding leading columns of F[:vectors] form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via select.\n\n\n\nordschur(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -> T::StridedMatrix, Z::StridedMatrix, λ::Vector\n\nReorders the Schur factorization of a real matrix A = Z*T*Z' according to the logical array select returning the reordered matrices T and Z as well as the vector of eigenvalues λ. The selected eigenvalues appear in the leading diagonal of T and the corresponding leading columns of Z form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via select.\n\n\n\nordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur\n\nReorders the Generalized Schur factorization F of a matrix pair (A, B) = (Q*S*Z', Q*T*Z') according to the logical array select and returns a GeneralizedSchur object F. The selected eigenvalues appear in the leading diagonal of both F[:S] and F[:T], and the left and right orthogonal/unitary Schur vectors are also reordered such that (A, B) = F[:Q]*(F[:S], F[:T])*F[:Z]' still holds and the generalized eigenvalues of A and B can still be obtained with F[:alpha]./F[:beta].\n\n\n\nordschur(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -> S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector\n\nReorders the Generalized Schur factorization of a matrix pair (A, B) = (Q*S*Z', Q*T*Z') according to the logical array select and returns the matrices S, T, Q, Z and vectors α and β.  The selected eigenvalues appear in the leading diagonal of both S and T, and the left and right unitary/orthogonal Schur vectors are also reordered such that (A, B) = Q*(S, T)*Z' still holds and the generalized eigenvalues of A and B can still be obtained with α./β.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.ordschur!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.ordschur!",
    "category": "Function",
    "text": "ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur\n\nSame as ordschur but overwrites the factorization F.\n\n\n\nordschur!(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -> T::StridedMatrix, Z::StridedMatrix, λ::Vector\n\nSame as ordschur but overwrites the input arguments.\n\n\n\nordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur\n\nSame as ordschur but overwrites the factorization F.\n\n\n\nordschur!(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -> S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector\n\nSame as ordschur but overwrites the factorization the input arguments.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.svdfact",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.svdfact",
    "category": "Function",
    "text": "svdfact(A; thin::Bool=true) -> SVD\n\nCompute the singular value decomposition (SVD) of A and return an SVD object.\n\nU, S, V and Vt can be obtained from the factorization F with F[:U], F[:S], F[:V] and F[:Vt], such that A = U*diagm(S)*Vt. The algorithm produces Vt and hence Vt is more efficient to extract than V. The singular values in S are sorted in descending order.\n\nIf thin=true (default), a thin SVD is returned. For a M times N matrix A, U is M times M for a full SVD (thin=false) and M times min(M N) for a thin SVD.\n\nExample\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> F = svdfact(A)\nBase.LinAlg.SVD{Float64,Float64,Array{Float64,2}}([0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0; 0.0 0.0 1.0 0.0], [3.0, 2.23607, 2.0, 0.0], [-0.0 0.0 … -0.0 0.0; 0.447214 0.0 … 0.0 0.894427; -0.0 1.0 … -0.0 0.0; 0.0 0.0 … 1.0 0.0])\n\njulia> F[:U] * diagm(F[:S]) * F[:Vt]\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\n\n\nsvdfact(A, B) -> GeneralizedSVD\n\nCompute the generalized SVD of A and B, returning a GeneralizedSVD factorization object F, such that A = F[:U]*F[:D1]*F[:R0]*F[:Q]' and B = F[:V]*F[:D2]*F[:R0]*F[:Q]'.\n\nFor an M-by-N matrix A and P-by-N matrix B,\n\nF[:U] is a M-by-M orthogonal matrix,\nF[:V] is a P-by-P orthogonal matrix,\nF[:Q] is a N-by-N orthogonal matrix,\nF[:R0] is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,\nF[:D1] is a M-by-(K+L) diagonal matrix with 1s in the first K entries,\nF[:D2] is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,\n\nK+L is the effective numerical rank of the matrix [A; B].\n\nThe entries of F[:D1] and F[:D2] are related, as explained in the LAPACK documentation for the generalized SVD and the xGGSVD3 routine which is called underneath (in LAPACK 3.6.0 and newer).\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.svdfact!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.svdfact!",
    "category": "Function",
    "text": "svdfact!(A, thin::Bool=true) -> SVD\n\nsvdfact! is the same as svdfact, but saves space by overwriting the input A, instead of creating a copy.\n\n\n\nsvdfact!(A, B) -> GeneralizedSVD\n\nsvdfact! is the same as svdfact, but modifies the arguments A and B in-place, instead of making copies.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.svd",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.svd",
    "category": "Function",
    "text": "svd(A; thin::Bool=true) -> U, S, V\n\nComputes the SVD of A, returning U, vector S, and V such that A == U*diagm(S)*V'. The singular values in S are sorted in descending order.\n\nIf thin=true (default), a thin SVD is returned. For a M times N matrix A, U is M times M for a full SVD (thin=false) and M times min(M N) for a thin SVD.\n\nsvd is a wrapper around svdfact, extracting all parts of the SVD factorization to a tuple. Direct use of svdfact is therefore more efficient.\n\nExample\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> U, S, V = svd(A)\n([0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0; 0.0 0.0 1.0 0.0], [3.0, 2.23607, 2.0, 0.0], [-0.0 0.447214 -0.0 0.0; 0.0 0.0 1.0 0.0; … ; -0.0 0.0 -0.0 1.0; 0.0 0.894427 0.0 0.0])\n\njulia> U*diagm(S)*V'\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\n\n\nsvd(A, B) -> U, V, Q, D1, D2, R0\n\nWrapper around svdfact extracting all parts of the factorization to a tuple. Direct use of svdfact is therefore generally more efficient. The function returns the generalized SVD of A and B, returning U, V, Q, D1, D2, and R0 such that A = U*D1*R0*Q' and B = V*D2*R0*Q'.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.svdvals",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.svdvals",
    "category": "Function",
    "text": "svdvals(A)\n\nReturns the singular values of A in descending order.\n\nExample\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Array{Float64,2}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> svdvals(A)\n4-element Array{Float64,1}:\n 3.0\n 2.23607\n 2.0\n 0.0\n\n\n\nsvdvals(A, B)\n\nReturn the generalized singular values from the generalized singular value decomposition of A and B. See also svdfact.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.Givens",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.Givens",
    "category": "Type",
    "text": "LinAlg.Givens(i1,i2,c,s) -> G\n\nA Givens rotation linear operator. The fields c and s represent the cosine and sine of the rotation angle, respectively. The Givens type supports left multiplication G*A and conjugated transpose right multiplication A*G'. The type doesn't have a size and can therefore be multiplied with matrices of arbitrary size as long as i2<=size(A,2) for G*A or i2<=size(A,1) for A*G'.\n\nSee also: givens\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.givens",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.givens",
    "category": "Function",
    "text": "givens{T}(f::T, g::T, i1::Integer, i2::Integer) -> (G::Givens, r::T)\n\nComputes the Givens rotation G and scalar r such that for any vector x where\n\nx[i1] = f\nx[i2] = g\n\nthe result of the multiplication\n\ny = G*x\n\nhas the property that\n\ny[i1] = r\ny[i2] = 0\n\nSee also: LinAlg.Givens\n\n\n\ngivens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -> (G::Givens, r)\n\nComputes the Givens rotation G and scalar r such that the result of the multiplication\n\nB = G*A\n\nhas the property that\n\nB[i1,j] = r\nB[i2,j] = 0\n\nSee also: LinAlg.Givens\n\n\n\ngivens(x::AbstractVector, i1::Integer, i2::Integer) -> (G::Givens, r)\n\nComputes the Givens rotation G and scalar r such that the result of the multiplication\n\nB = G*x\n\nhas the property that\n\nB[i1] = r\nB[i2] = 0\n\nSee also: LinAlg.Givens\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.triu",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.triu",
    "category": "Function",
    "text": "triu(M)\n\nUpper triangle of a matrix.\n\nExample\n\njulia> a = ones(4,4)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> triu(a)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 0.0  1.0  1.0  1.0\n 0.0  0.0  1.0  1.0\n 0.0  0.0  0.0  1.0\n\n\n\ntriu(M, k::Integer)\n\nReturns the upper triangle of M starting from the kth superdiagonal.\n\nExample\n\njulia> a = ones(4,4)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> triu(a,3)\n4×4 Array{Float64,2}:\n 0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\njulia> triu(a,-3)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.triu!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.triu!",
    "category": "Function",
    "text": "triu!(M)\n\nUpper triangle of a matrix, overwriting M in the process. See also triu.\n\n\n\ntriu!(M, k::Integer)\n\nReturns the upper triangle of M starting from the kth superdiagonal, overwriting M in the process.\n\nExample\n\njulia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]\n5×5 Array{Int64,2}:\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n\njulia> triu!(M, 1)\n5×5 Array{Int64,2}:\n 0  2  3  4  5\n 0  0  3  4  5\n 0  0  0  4  5\n 0  0  0  0  5\n 0  0  0  0  0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.tril",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.tril",
    "category": "Function",
    "text": "tril(M)\n\nLower triangle of a matrix.\n\nExample\n\njulia> a = ones(4,4)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> tril(a)\n4×4 Array{Float64,2}:\n 1.0  0.0  0.0  0.0\n 1.0  1.0  0.0  0.0\n 1.0  1.0  1.0  0.0\n 1.0  1.0  1.0  1.0\n\n\n\ntril(M, k::Integer)\n\nReturns the lower triangle of M starting from the kth superdiagonal.\n\nExample\n\njulia> a = ones(4,4)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> tril(a,3)\n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> tril(a,-3)\n4×4 Array{Float64,2}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 1.0  0.0  0.0  0.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.tril!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.tril!",
    "category": "Function",
    "text": "tril!(M)\n\nLower triangle of a matrix, overwriting M in the process. See also tril.\n\n\n\ntril!(M, k::Integer)\n\nReturns the lower triangle of M starting from the kth superdiagonal, overwriting M in the process.\n\nExample\n\njulia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]\n5×5 Array{Int64,2}:\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n\njulia> tril!(M, 2)\n5×5 Array{Int64,2}:\n 1  2  3  0  0\n 1  2  3  4  0\n 1  2  3  4  5\n 1  2  3  4  5\n 1  2  3  4  5\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.diagind",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.diagind",
    "category": "Function",
    "text": "diagind(M, k::Integer=0)\n\nA Range giving the indices of the kth diagonal of the matrix M.\n\nExample\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> diagind(A,-1)\n2:4:6\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.diag",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.diag",
    "category": "Function",
    "text": "diag(M, k::Integer=0)\n\nThe kth diagonal of a matrix, as a vector. Use diagm to construct a diagonal matrix.\n\nExample\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> diag(A,1)\n2-element Array{Int64,1}:\n 2\n 6\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.diagm",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.diagm",
    "category": "Function",
    "text": "diagm(v, k::Integer=0)\n\nConstruct a matrix by placing v on the kth diagonal.\n\nExample\n\njulia> diagm([1,2,3],1)\n4×4 Array{Int64,2}:\n 0  1  0  0\n 0  0  2  0\n 0  0  0  3\n 0  0  0  0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.scale!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.scale!",
    "category": "Function",
    "text": "scale!(A, b)\nscale!(b, A)\n\nScale an array A by a scalar b overwriting A in-place.\n\nIf A is a matrix and b is a vector, then scale!(A,b) scales each column i of A by b[i] (similar to A*Diagonal(b)), while scale!(b,A) scales each row i of A by b[i] (similar to Diagonal(b)*A), again operating in-place on A. An InexactError exception is thrown if the scaling produces a number not representable by the element type of A, e.g. for integer types.\n\nExample\n\njulia> a = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> b = [1; 2]\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> scale!(a,b)\n2×2 Array{Int64,2}:\n 1  4\n 3  8\n\njulia> a = [1 2; 3 4];\n\njulia> b = [1; 2];\n\njulia> scale!(b,a)\n2×2 Array{Int64,2}:\n 1  2\n 6  8\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.rank",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.rank",
    "category": "Function",
    "text": "rank(M[, tol::Real])\n\nCompute the rank of a matrix by counting how many singular values of M have magnitude greater than tol. By default, the value of tol is the largest dimension of M multiplied by the eps of the eltype of M.\n\nExample\n\njulia> rank(eye(3))\n3\n\njulia> rank(diagm([1, 0, 2]))\n2\n\njulia> rank(diagm([1, 0.001, 2]), 0.1)\n2\n\njulia> rank(diagm([1, 0.001, 2]), 0.00001)\n3\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.norm",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.norm",
    "category": "Function",
    "text": "norm(A::AbstractArray, p::Real=2)\n\nCompute the p-norm of a vector or the operator norm of a matrix A, defaulting to the 2-norm.\n\nnorm(A::AbstractVector, p::Real=2)\n\nFor vectors, this is equivalent to vecnorm and equal to:\n\nA_p = left( sum_i=1^n  a_i  ^p right)^1p\n\nwith a_i the entries of A and n its length.\n\np can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, norm(A, Inf) returns the largest value in abs(A), whereas norm(A, -Inf) returns the smallest.\n\nExample\n\njulia> v = [3, -2, 6]\n3-element Array{Int64,1}:\n  3\n -2\n  6\n\njulia> norm(v)\n7.0\n\njulia> norm(v, Inf)\n6.0\n\n\n\nnorm(A::AbstractMatrix, p::Real=2)\n\nFor matrices, the matrix norm induced by the vector p-norm is used, where valid values of p are 1, 2, or Inf. (Note that for sparse matrices, p=2 is currently not implemented.) Use vecnorm to compute the Frobenius norm.\n\nWhen p=1, the matrix norm is the maximum absolute column sum of A:\n\nA_1 = max_1  j  n sum_i=1^m  a_ij \n\nwith a_ij the entries of A, and m and n its dimensions.\n\nWhen p=2, the matrix norm is the spectral norm, equal to the largest singular value of A.\n\nWhen p=Inf, the matrix norm is the maximum absolute row sum of A:\n\nA_infty = max_1  i  m sum _j=1^n  a_ij \n\nExample\n\njulia> A = [1 -2 -3; 2 3 -1]\n2×3 Array{Int64,2}:\n 1  -2  -3\n 2   3  -1\n\njulia> norm(A, Inf)\n6.0\n\n\n\nnorm(x::Number, p::Real=2)\n\nFor numbers, return left( x^p right)^1p. This is equivalent to vecnorm.\n\n\n\nnorm(A::RowVector, q::Real=2)\n\nFor row vectors, return the q-norm of A, which is equivalent to the p-norm with value p = q/(q-1). They coincide at p = q = 2.\n\nThe difference in norm between a vector space and its dual arises to preserve the relationship between duality and the inner product, and the result is consistent with the p-norm of 1 × n matrix.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.vecnorm",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.vecnorm",
    "category": "Function",
    "text": "vecnorm(A, p::Real=2)\n\nFor any iterable container A (including arrays of any dimension) of numbers (or any element type for which norm is defined), compute the p-norm (defaulting to p=2) as if A were a vector of the corresponding length.\n\nThe p-norm is defined as:\n\nA_p = left( sum_i=1^n  a_i  ^p right)^1p\n\nwith a_i the entries of A and n its length.\n\np can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, vecnorm(A, Inf) returns the largest value in abs(A), whereas vecnorm(A, -Inf) returns the smallest. If A is a matrix and p=2, then this is equivalent to the Frobenius norm.\n\nExample\n\njulia> vecnorm([1 2 3; 4 5 6; 7 8 9])\n16.881943016134134\n\njulia> vecnorm([1 2 3 4 5 6 7 8 9])\n16.881943016134134\n\n\n\nvecnorm(x::Number, p::Real=2)\n\nFor numbers, return left( x^p right) ^1p.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.normalize!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.normalize!",
    "category": "Function",
    "text": "normalize!(v::AbstractVector, p::Real=2)\n\nNormalize the vector v in-place so that its p-norm equals unity, i.e. norm(v, p) == 1. See also normalize and vecnorm.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.normalize",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.normalize",
    "category": "Function",
    "text": "normalize(v::AbstractVector, p::Real=2)\n\nNormalize the vector v so that its p-norm equals unity, i.e. norm(v, p) == vecnorm(v, p) == 1. See also normalize! and vecnorm.\n\nExamples\n\njulia> a = [1,2,4];\n\njulia> b = normalize(a)\n3-element Array{Float64,1}:\n 0.218218\n 0.436436\n 0.872872\n\njulia> norm(b)\n1.0\n\njulia> c = normalize(a, 1)\n3-element Array{Float64,1}:\n 0.142857\n 0.285714\n 0.571429\n\njulia> norm(c, 1)\n1.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.cond",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.cond",
    "category": "Function",
    "text": "cond(M, p::Real=2)\n\nCondition number of the matrix M, computed using the operator p-norm. Valid values for p are 1, 2 (default), or Inf.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.condskeel",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.condskeel",
    "category": "Function",
    "text": "condskeel(M, [x, p::Real=Inf])\n\nkappa_S(M p) = leftVert leftvert M rightvert leftvert M^-1 rightvert rightVert_p \nkappa_S(M x p) = leftVert leftvert M rightvert leftvert M^-1 rightvert leftvert x rightvert rightVert_p\n\nSkeel condition number kappa_S of the matrix M, optionally with respect to the vector x, as computed using the operator p-norm. leftvert M rightvert denotes the matrix of (entry wise) absolute values of M; leftvert M rightvert_ij = leftvert M_ij rightvert. Valid values for p are 1, 2 and Inf (default).\n\nThis quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.trace",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.trace",
    "category": "Function",
    "text": "trace(M)\n\nMatrix trace. Sums the diagonal elements of M.\n\nExample\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> trace(A)\n5\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.det",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.det",
    "category": "Function",
    "text": "det(M)\n\nMatrix determinant.\n\nExample\n\njulia> M = [1 0; 2 2]\n2×2 Array{Int64,2}:\n 1  0\n 2  2\n\njulia> det(M)\n2.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.logdet",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.logdet",
    "category": "Function",
    "text": "logdet(M)\n\nLog of matrix determinant. Equivalent to log(det(M)), but may provide increased accuracy and/or speed.\n\nExamples\n\njulia> M = [1 0; 2 2]\n2×2 Array{Int64,2}:\n 1  0\n 2  2\n\njulia> logdet(M)\n0.6931471805599453\n\njulia> logdet(eye(3))\n0.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.logabsdet",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.logabsdet",
    "category": "Function",
    "text": "logabsdet(M)\n\nLog of absolute value of matrix determinant. Equivalent to (log(abs(det(M))), sign(det(M))), but may provide increased accuracy and/or speed.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.inv",
    "page": "Álgebra Lineal",
    "title": "Base.inv",
    "category": "Function",
    "text": "inv(M)\n\nMatrix inverse. Computes matrix N such that M * N = I, where I is the identity matrix. Computed by solving the left-division N = M \\ I.\n\nExample\n\njulia> M = [2 5; 1 3]\n2×2 Array{Int64,2}:\n 2  5\n 1  3\n\njulia> N = inv(M)\n2×2 Array{Float64,2}:\n  3.0  -5.0\n -1.0   2.0\n\njulia> M*N == N*M == eye(2)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.pinv",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.pinv",
    "category": "Function",
    "text": "pinv(M[, tol::Real])\n\nComputes the Moore-Penrose pseudoinverse.\n\nFor matrices M with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values above a given threshold, tol.\n\nThe optimal choice of tol varies both with the value of M and the intended application of the pseudoinverse. The default value of tol is eps(real(float(one(eltype(M)))))*maximum(size(A)), which is essentially machine epsilon for the real part of a matrix element multiplied by the larger matrix dimension. For inverting dense ill-conditioned matrices in a least-squares sense, tol = sqrt(eps(real(float(one(eltype(M)))))) is recommended.\n\nFor more information, see [issue8859], [B96], [S84], [KY88].\n\nExample\n\njulia> M = [1.5 1.3; 1.2 1.9]\n2×2 Array{Float64,2}:\n 1.5  1.3\n 1.2  1.9\n\njulia> N = pinv(M)\n2×2 Array{Float64,2}:\n  1.47287   -1.00775\n -0.930233   1.16279\n\njulia> M * N\n2×2 Array{Float64,2}:\n 1.0          -2.22045e-16\n 4.44089e-16   1.0\n\n[issue8859]: Issue 8859, \"Fix least squares\", https://github.com/JuliaLang/julia/pull/8859\n\n[B96]: Åke Björck, \"Numerical Methods for Least Squares Problems\",  SIAM Press, Philadelphia, 1996, \"Other Titles in Applied Mathematics\", Vol. 51. doi:10.1137/1.9781611971484\n\n[S84]: G. W. Stewart, \"Rank Degeneracy\", SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. doi:10.1137/0905030\n\n[KY88]: Konstantinos Konstantinides and Kung Yao, \"Statistical analysis of effective singular values in matrix rank determination\", IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. doi:10.1109/29.1585\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.nullspace",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.nullspace",
    "category": "Function",
    "text": "nullspace(M)\n\nBasis for nullspace of M.\n\nExample\n\njulia> M = [1 0 0; 0 1 0; 0 0 0]\n3×3 Array{Int64,2}:\n 1  0  0\n 0  1  0\n 0  0  0\n\njulia> nullspace(M)\n3×1 Array{Float64,2}:\n 0.0\n 0.0\n 1.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.repmat",
    "page": "Álgebra Lineal",
    "title": "Base.repmat",
    "category": "Function",
    "text": "repmat(A, m::Integer, n::Integer=1)\n\nConstruct a matrix by repeating the given matrix (or vector) m times in dimension 1 and n times in dimension 2.\n\nExamples\n\njulia> repmat([1, 2, 3], 2)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 1\n 2\n 3\n\njulia> repmat([1, 2, 3], 2, 3)\n6×3 Array{Int64,2}:\n 1  1  1\n 2  2  2\n 3  3  3\n 1  1  1\n 2  2  2\n 3  3  3\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.repeat",
    "page": "Álgebra Lineal",
    "title": "Base.repeat",
    "category": "Function",
    "text": "repeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))\n\nConstruct an array by repeating the entries of A. The i-th element of inner specifies the number of times that the individual entries of the i-th dimension of A should be repeated. The i-th element of outer specifies the number of times that a slice along the i-th dimension of A should be repeated. If inner or outer are omitted, no repetition is performed.\n\nExamples\n\njulia> repeat(1:2, inner=2)\n4-element Array{Int64,1}:\n 1\n 1\n 2\n 2\n\njulia> repeat(1:2, outer=2)\n4-element Array{Int64,1}:\n 1\n 2\n 1\n 2\n\njulia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))\n4×6 Array{Int64,2}:\n 1  2  1  2  1  2\n 1  2  1  2  1  2\n 3  4  3  4  3  4\n 3  4  3  4  3  4\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.kron",
    "page": "Álgebra Lineal",
    "title": "Base.kron",
    "category": "Function",
    "text": "kron(A, B)\n\nKronecker tensor product of two vectors or two matrices.\n\nExample\n\njulia> A = [1 2; 3 4]\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\njulia> B = [im 1; 1 -im]\n2×2 Array{Complex{Int64},2}:\n 0+1im  1+0im\n 1+0im  0-1im\n\njulia> kron(A, B)\n4×4 Array{Complex{Int64},2}:\n 0+1im  1+0im  0+2im  2+0im\n 1+0im  0-1im  2+0im  0-2im\n 0+3im  3+0im  0+4im  4+0im\n 3+0im  0-3im  4+0im  0-4im\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.SparseArrays.blkdiag",
    "page": "Álgebra Lineal",
    "title": "Base.SparseArrays.blkdiag",
    "category": "Function",
    "text": "blkdiag(A...)\n\nConcatenate matrices block-diagonally. Currently only implemented for sparse matrices.\n\nExample\n\njulia> blkdiag(speye(3), 2*speye(2))\n5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:\n  [1, 1]  =  1.0\n  [2, 2]  =  1.0\n  [3, 3]  =  1.0\n  [4, 4]  =  2.0\n  [5, 5]  =  2.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.linreg",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.linreg",
    "category": "Function",
    "text": "linreg(x, y)\n\nPerform simple linear regression using Ordinary Least Squares. Returns a and b such that a + b*x is the closest straight line to the given points (x, y), i.e., such that the squared error between y and a + b*x is minimized.\n\nExamples:\n\nusing PyPlot\nx = 1.0:12.0\ny = [5.5, 6.3, 7.6, 8.8, 10.9, 11.79, 13.48, 15.02, 17.77, 20.81, 22.0, 22.99]\na, b = linreg(x, y)          # Linear regression\nplot(x, y, \"o\")              # Plot (x, y) points\nplot(x, a + b*x)             # Plot line determined by linear regression\n\nSee also:\n\n\\, cov, std, mean.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.expm",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.expm",
    "category": "Function",
    "text": "expm(A)\n\nCompute the matrix exponential of A, defined by\n\ne^A = sum_n=0^infty fracA^nn\n\nFor symmetric or Hermitian A, an eigendecomposition (eigfact) is used, otherwise the scaling and squaring algorithm (see [H05]) is chosen.\n\n[H05]: Nicholas J. Higham, \"The squaring and scaling method for the matrix exponential revisited\", SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. doi:10.1137/090768539\n\nExample\n\njulia> A = eye(2, 2)\n2×2 Array{Float64,2}:\n 1.0  0.0\n 0.0  1.0\n\njulia> expm(A)\n2×2 Array{Float64,2}:\n 2.71828  0.0\n 0.0      2.71828\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.logm",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.logm",
    "category": "Function",
    "text": "logm(A{T}::StridedMatrix{T})\n\nIf A has no negative real eigenvalue, compute the principal matrix logarithm of A, i.e. the unique matrix X such that e^X = A and -pi  Im(lambda)  pi for all the eigenvalues lambda of X. If A has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigfact) is used, if A is triangular an improved version of the inverse scaling and squaring method is employed (see [AH12] and [AHR13]). For general matrices, the complex Schur form (schur) is computed and the triangular algorithm is used on the triangular factor.\n\n[AH12]: Awad H. Al-Mohy and Nicholas J. Higham, \"Improved inverse  scaling and squaring algorithms for the matrix logarithm\", SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. doi:10.1137/110852553\n\n[AHR13]: Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, \"Computing the Fréchet derivative of the matrix logarithm and estimating the condition number\", SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. doi:10.1137/120885991\n\nExample\n\njulia> A = 2.7182818 * eye(2)\n2×2 Array{Float64,2}:\n 2.71828  0.0\n 0.0      2.71828\n\njulia> logm(A)\n2×2 Symmetric{Float64,Array{Float64,2}}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.sqrtm",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.sqrtm",
    "category": "Function",
    "text": "sqrtm(A)\n\nIf A has no negative real eigenvalues, compute the principal matrix square root of A, that is the unique matrix X with eigenvalues having positive real part such that X^2 = A. Otherwise, a nonprincipal square root is returned.\n\nIf A is symmetric or Hermitian, its eigendecomposition (eigfact) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method [BH83], which computes the complex Schur form (schur) and then the complex square root of the triangular factor.\n\n[BH83]: Åke Björck and Sven Hammarling, \"A Schur method for the square root of a matrix\", Linear Algebra and its Applications, 52-53, 1983, 127-140. doi:10.1016/0024-3795(83)80010-X\n\nExample\n\njulia> A = [4 0; 0 4]\n2×2 Array{Int64,2}:\n 4  0\n 0  4\n\njulia> sqrtm(A)\n2×2 Array{Float64,2}:\n 2.0  0.0\n 0.0  2.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.lyap",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.lyap",
    "category": "Function",
    "text": "lyap(A, C)\n\nComputes the solution X to the continuous Lyapunov equation AX + XA' + C = 0, where no eigenvalue of A has a zero real part and no two eigenvalues are negative complex conjugates of each other.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.sylvester",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.sylvester",
    "category": "Function",
    "text": "sylvester(A, B, C)\n\nComputes the solution X to the Sylvester equation AX + XB + C = 0, where A, B and C have compatible dimensions and A and -B have no eigenvalues with equal real part.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.issymmetric",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.issymmetric",
    "category": "Function",
    "text": "issymmetric(A) -> Bool\n\nTest whether a matrix is symmetric.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> issymmetric(a)\ntrue\n\njulia> b = [1 im; -im 1]\n2×2 Array{Complex{Int64},2}:\n 1+0im  0+1im\n 0-1im  1+0im\n\njulia> issymmetric(b)\nfalse\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.isposdef",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.isposdef",
    "category": "Function",
    "text": "isposdef(A) -> Bool\n\nTest whether a matrix is positive definite.\n\nExample\n\njulia> A = [1 2; 2 50]\n2×2 Array{Int64,2}:\n 1   2\n 2  50\n\njulia> isposdef(A)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.isposdef!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.isposdef!",
    "category": "Function",
    "text": "isposdef!(A) -> Bool\n\nTest whether a matrix is positive definite, overwriting A in the process.\n\nExample\n\njulia> A = [1. 2.; 2. 50.];\n\njulia> isposdef!(A)\ntrue\n\njulia> A\n2×2 Array{Float64,2}:\n 1.0  2.0\n 2.0  6.78233\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.istril",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.istril",
    "category": "Function",
    "text": "istril(A) -> Bool\n\nTest whether a matrix is lower triangular.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> istril(a)\nfalse\n\njulia> b = [1 0; -im -1]\n2×2 Array{Complex{Int64},2}:\n 1+0im   0+0im\n 0-1im  -1+0im\n\njulia> istril(b)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.istriu",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.istriu",
    "category": "Function",
    "text": "istriu(A) -> Bool\n\nTest whether a matrix is upper triangular.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> istriu(a)\nfalse\n\njulia> b = [1 im; 0 -1]\n2×2 Array{Complex{Int64},2}:\n 1+0im   0+1im\n 0+0im  -1+0im\n\njulia> istriu(b)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.isdiag",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.isdiag",
    "category": "Function",
    "text": "isdiag(A) -> Bool\n\nTest whether a matrix is diagonal.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> isdiag(a)\nfalse\n\njulia> b = [im 0; 0 -im]\n2×2 Array{Complex{Int64},2}:\n 0+1im  0+0im\n 0+0im  0-1im\n\njulia> isdiag(b)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.ishermitian",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.ishermitian",
    "category": "Function",
    "text": "ishermitian(A) -> Bool\n\nTest whether a matrix is Hermitian.\n\nExamples\n\njulia> a = [1 2; 2 -1]\n2×2 Array{Int64,2}:\n 1   2\n 2  -1\n\njulia> ishermitian(a)\ntrue\n\njulia> b = [1 im; -im 1]\n2×2 Array{Complex{Int64},2}:\n 1+0im  0+1im\n 0-1im  1+0im\n\njulia> ishermitian(b)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.RowVector",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.RowVector",
    "category": "Type",
    "text": "RowVector(vector)\n\nA lazy-view wrapper of an AbstractVector, which turns a length-n vector into a 1×n shaped row vector and represents the transpose of a vector (the elements are also transposed recursively). This type is usually constructed (and unwrapped) via the transpose function or .' operator (or related ctranspose or ' operator).\n\nBy convention, a vector can be multiplied by a matrix on its left (A * v) whereas a row vector can be multiplied by a matrix on its right (such that v.' * A = (A.' * v).'). It differs from a 1×n-sized matrix by the facts that its transpose returns a vector and the inner product v1.' * v2 returns a scalar, but will otherwise behave similarly.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.ConjArray",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.ConjArray",
    "category": "Type",
    "text": "ConjArray(array)\n\nA lazy-view wrapper of an AbstractArray, taking the elementwise complex conjugate. This type is usually constructed (and unwrapped) via the conj function (or related ctranspose), but currently this is the default behavior for RowVector only. For other arrays, the ConjArray constructor can be used directly.\n\nExamples\n\njulia> [1+im, 1-im]'\n1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:\n 1-1im  1+1im\n\njulia> ConjArray([1+im 0; 0 1-im])\n2×2 ConjArray{Complex{Int64},2,Array{Complex{Int64},2}}:\n 1-1im  0+0im\n 0+0im  1+1im\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.transpose",
    "page": "Álgebra Lineal",
    "title": "Base.transpose",
    "category": "Function",
    "text": "transpose(A::AbstractMatrix)\n\nThe transposition operator (.').\n\nExample\n\njulia> A = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> transpose(A)\n3×3 Array{Int64,2}:\n 1  4  7\n 2  5  8\n 3  6  9\n\n\n\ntranspose(v::AbstractVector)\n\nThe transposition operator (.').\n\nExample\n\njulia> v = [1,2,3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> transpose(v)\n1×3 RowVector{Int64,Array{Int64,1}}:\n 1  2  3\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.transpose!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.transpose!",
    "category": "Function",
    "text": "transpose!(dest,src)\n\nTranspose array src and store the result in the preallocated array dest, which should have a size corresponding to (size(src,2),size(src,1)). No in-place transposition is supported and unexpected results will happen if src and dest have overlapping memory regions.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.ctranspose",
    "page": "Álgebra Lineal",
    "title": "Base.ctranspose",
    "category": "Function",
    "text": "ctranspose(A)\n\nThe conjugate transposition operator (').\n\nExample\n\njulia> A =  [3+2im 9+2im; 8+7im  4+6im]\n2×2 Array{Complex{Int64},2}:\n 3+2im  9+2im\n 8+7im  4+6im\n\njulia> ctranspose(A)\n2×2 Array{Complex{Int64},2}:\n 3-2im  8-7im\n 9-2im  4-6im\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.ctranspose!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.ctranspose!",
    "category": "Function",
    "text": "ctranspose!(dest,src)\n\nConjugate transpose array src and store the result in the preallocated array dest, which should have a size corresponding to (size(src,2),size(src,1)). No in-place transposition is supported and unexpected results will happen if src and dest have overlapping memory regions.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eigs-Tuple{Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eigs",
    "category": "Method",
    "text": "eigs(A; nev=6, ncv=max(20,2*nev+1), which=:LM, tol=0.0, maxiter=300, sigma=nothing, ritzvec=true, v0=zeros((0,))) -> (d,[v,],nconv,niter,nmult,resid)\n\nComputes eigenvalues d of A using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.\n\nThe following keyword arguments are supported:\n\nnev: Number of eigenvalues\nncv: Number of Krylov vectors used in the computation; should satisfy nev+1 <= ncv <= n for real symmetric problems and nev+2 <= ncv <= n for other problems, where n is the size of the input matrix A. The default is ncv = max(20,2*nev+1). Note that these restrictions limit the input matrix A to be of dimension at least 2.\nwhich: type of eigenvalues to compute. See the note below.\n\nwhich type of eigenvalues\n:LM eigenvalues of largest magnitude (default)\n:SM eigenvalues of smallest magnitude\n:LR eigenvalues of largest real part\n:SR eigenvalues of smallest real part\n:LI eigenvalues of largest imaginary part (nonsymmetric or complex A only)\n:SI eigenvalues of smallest imaginary part (nonsymmetric or complex A only)\n:BE compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric A only)\n\ntol: parameter defining the relative tolerance for convergence of Ritz values (eigenvalue estimates).    A Ritz value  is considered converged when its associated residual    is less than or equal to the product of tol and max(^23 ),    where ɛ = eps(real(eltype(A)))/2 is LAPACK's machine epsilon.    The residual associated with  and its corresponding Ritz vector v    is defined as the norm Av - v.    The specified value of tol should be positive; otherwise, it is ignored    and  is used instead.    Default: .\nmaxiter: Maximum number of iterations (default = 300)\nsigma: Specifies the level shift used in inverse iteration. If nothing (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to sigma using shift and invert iterations.\nritzvec: Returns the Ritz vectors v (eigenvectors) if true\nv0: starting vector from which to start the iterations\n\neigs returns the nev requested eigenvalues in d, the corresponding Ritz vectors v (only if ritzvec=true), the number of converged eigenvalues nconv, the number of iterations niter and the number of matrix vector multiplications nmult, as well as the final residual vector resid.\n\nExample\n\njulia> A = spdiagm(1:4);\n\njulia> λ, ϕ = eigs(A, nev = 2);\n\njulia> λ\n2-element Array{Float64,1}:\n 4.0\n 3.0\n\nnote: Note\nThe sigma and which keywords interact: the description of eigenvalues searched for by which do not necessarily refer to the eigenvalues of A, but rather the linear operator constructed by the specification of the iteration mode implied by sigma.sigma iteration mode which refers to eigenvalues of\nnothing ordinary (forward) A\nreal or complex inverse with level shift sigma (A - sigma I )^-1\n\nnote: Note\nAlthough tol has a default value, the best choice depends strongly on the matrix A. We recommend that users _always_ specify a value for tol which suits their specific needs.For details of how the errors in the computed eigenvalues are estimated, see:B. N. Parlett, \"The Symmetric Eigenvalue Problem\", SIAM: Philadelphia, 2/e (1998), Ch. 13.2, \"Accessing Accuracy in Lanczos Problems\", pp. 290-292 ff.\nR. B. Lehoucq and D. C. Sorensen, \"Deflation Techniques for an Implicitly Restarted Arnoldi Iteration\", SIAM Journal on Matrix Analysis and Applications (1996), 17(4), 789–821.  doi:10.1137/S0895479895281484\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.eigs-Tuple{Any,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.eigs",
    "category": "Method",
    "text": "eigs(A, B; nev=6, ncv=max(20,2*nev+1), which=:LM, tol=0.0, maxiter=300, sigma=nothing, ritzvec=true, v0=zeros((0,))) -> (d,[v,],nconv,niter,nmult,resid)\n\nComputes generalized eigenvalues d of A and B using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.\n\nThe following keyword arguments are supported:\n\nnev: Number of eigenvalues\nncv: Number of Krylov vectors used in the computation; should satisfy nev+1 <= ncv <= n for real symmetric problems and nev+2 <= ncv <= n for other problems, where n is the size of the input matrices A and B. The default is ncv = max(20,2*nev+1). Note that these restrictions limit the input matrix A to be of dimension at least 2.\nwhich: type of eigenvalues to compute. See the note below.\n\nwhich type of eigenvalues\n:LM eigenvalues of largest magnitude (default)\n:SM eigenvalues of smallest magnitude\n:LR eigenvalues of largest real part\n:SR eigenvalues of smallest real part\n:LI eigenvalues of largest imaginary part (nonsymmetric or complex A only)\n:SI eigenvalues of smallest imaginary part (nonsymmetric or complex A only)\n:BE compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric A only)\n\ntol: relative tolerance used in the convergence criterion for eigenvalues, similar to    tol in the eigs(A) method for the ordinary eigenvalue    problem, but effectively for the eigenvalues of B^-1 A instead of A.    See the documentation for the ordinary eigenvalue problem in    eigs(A) and the accompanying note about tol.\nmaxiter: Maximum number of iterations (default = 300)\nsigma: Specifies the level shift used in inverse iteration. If nothing (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to sigma using shift and invert iterations.\nritzvec: Returns the Ritz vectors v (eigenvectors) if true\nv0: starting vector from which to start the iterations\n\neigs returns the nev requested eigenvalues in d, the corresponding Ritz vectors v (only if ritzvec=true), the number of converged eigenvalues nconv, the number of iterations niter and the number of matrix vector multiplications nmult, as well as the final residual vector resid.\n\nExample\n\njulia> A = speye(4, 4); B = spdiagm(1:4);\n\njulia> λ, ϕ = eigs(A, B, nev = 2);\n\njulia> λ\n2-element Array{Float64,1}:\n 1.0\n 0.5\n\nnote: Note\nThe sigma and which keywords interact: the description of eigenvalues searched for by which do not necessarily refer to the eigenvalue problem Av = Bvlambda, but rather the linear operator constructed by the specification of the iteration mode implied by sigma.sigma iteration mode which refers to the problem\nnothing ordinary (forward) Av = Bvlambda\nreal or complex inverse with level shift sigma (A - sigma B )^-1B = vnu\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.svds",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.svds",
    "category": "Function",
    "text": "svds(A; nsv=6, ritzvec=true, tol=0.0, maxiter=1000, ncv=2*nsv, u0=zeros((0,)), v0=zeros((0,))) -> (SVD([left_sv,] s, [right_sv,]), nconv, niter, nmult, resid)\n\nComputes the largest singular values s of A using implicitly restarted Lanczos iterations derived from eigs.\n\nInputs\n\nA: Linear operator whose singular values are desired. A may be represented as a subtype of AbstractArray, e.g., a sparse matrix, or any other type supporting the four methods size(A), eltype(A), A * vector, and A' * vector.\nnsv: Number of singular values. Default: 6.\nritzvec: If true, return the left and right singular vectors left_sv and right_sv.  If false, omit the singular vectors. Default: true.\ntol: tolerance, see eigs.\nmaxiter: Maximum number of iterations, see eigs. Default: 1000.\nncv: Maximum size of the Krylov subspace, see eigs (there called nev). Default: 2*nsv.\nu0: Initial guess for the first left Krylov vector. It may have length m (the first dimension of A), or 0.\nv0: Initial guess for the first right Krylov vector. It may have length n (the second dimension of A), or 0.\n\nOutputs\n\nsvd: An SVD object containing the left singular vectors, the requested values, and the right singular vectors. If ritzvec = false, the left and right singular vectors will be empty.\nnconv: Number of converged singular values.\nniter: Number of iterations.\nnmult: Number of matrix–vector products used.\nresid: Final residual vector.\n\nExample\n\njulia> A = spdiagm(1:4);\n\njulia> s = svds(A, nsv = 2)[1];\n\njulia> s[:S]\n2-element Array{Float64,1}:\n 4.0\n 3.0\n\nnote: Implementation\nsvds(A) is formally equivalent to calling eigs to perform implicitly restarted Lanczos tridiagonalization on the Hermitian matrix beginpmatrix 0  A^prime  A  0 endpmatrix, whose eigenvalues are plus and minus the singular values of A.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.peakflops",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.peakflops",
    "category": "Function",
    "text": "peakflops(n::Integer=2000; parallel::Bool=false)\n\npeakflops computes the peak flop rate of the computer by using double precision gemm!. By default, if no arguments are specified, it multiplies a matrix of size n x n, where n = 2000. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with BLAS.set_num_threads(n).\n\nIf the keyword argument parallel is set to true, peakflops is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument n still refers to the size of the problem that is solved on each processor.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Funciones-Estándar-1",
    "page": "Álgebra Lineal",
    "title": "Funciones Estándar",
    "category": "section",
    "text": "Las funciones de álgebra lineal en Julia están ampliamente implementadas llamando a funciones de LAPACK. Las factorizaciones sparse llaman a funciones de SuiteSparseBase.:*(::AbstractArray, ::AbstractArray)\nBase.:\\(::AbstractArray, ::Any)\nBase.LinAlg.dot\nBase.LinAlg.vecdot\nBase.LinAlg.cross\nBase.LinAlg.factorize\nBase.LinAlg.Diagonal\nBase.LinAlg.Bidiagonal\nBase.LinAlg.SymTridiagonal\nBase.LinAlg.Tridiagonal\nBase.LinAlg.Symmetric\nBase.LinAlg.Hermitian\nBase.LinAlg.LowerTriangular\nBase.LinAlg.UpperTriangular\nBase.LinAlg.lu\nBase.LinAlg.lufact\nBase.LinAlg.lufact!\nBase.LinAlg.chol\nBase.LinAlg.cholfact\nBase.LinAlg.cholfact!\nBase.LinAlg.lowrankupdate\nBase.LinAlg.lowrankdowndate\nBase.LinAlg.lowrankupdate!\nBase.LinAlg.lowrankdowndate!\nBase.LinAlg.ldltfact\nBase.LinAlg.ldltfact!\nBase.LinAlg.qr\nBase.LinAlg.qr!\nBase.LinAlg.qrfact\nBase.LinAlg.qrfact!\nBase.LinAlg.QR\nBase.LinAlg.QRCompactWY\nBase.LinAlg.QRPivoted\nBase.LinAlg.lqfact!\nBase.LinAlg.lqfact\nBase.LinAlg.lq\nBase.LinAlg.bkfact\nBase.LinAlg.bkfact!\nBase.LinAlg.eig\nBase.LinAlg.eigvals\nBase.LinAlg.eigvals!\nBase.LinAlg.eigmax\nBase.LinAlg.eigmin\nBase.LinAlg.eigvecs\nBase.LinAlg.eigfact\nBase.LinAlg.eigfact!\nBase.LinAlg.hessfact\nBase.LinAlg.hessfact!\nBase.LinAlg.schurfact\nBase.LinAlg.schurfact!\nBase.LinAlg.schur\nBase.LinAlg.ordschur\nBase.LinAlg.ordschur!\nBase.LinAlg.svdfact\nBase.LinAlg.svdfact!\nBase.LinAlg.svd\nBase.LinAlg.svdvals\nBase.LinAlg.Givens\nBase.LinAlg.givens\nBase.LinAlg.triu\nBase.LinAlg.triu!\nBase.LinAlg.tril\nBase.LinAlg.tril!\nBase.LinAlg.diagind\nBase.LinAlg.diag\nBase.LinAlg.diagm\nBase.LinAlg.scale!\nBase.LinAlg.rank\nBase.LinAlg.norm\nBase.LinAlg.vecnorm\nBase.LinAlg.normalize!\nBase.LinAlg.normalize\nBase.LinAlg.cond\nBase.LinAlg.condskeel\nBase.LinAlg.trace\nBase.LinAlg.det\nBase.LinAlg.logdet\nBase.LinAlg.logabsdet\nBase.inv\nBase.LinAlg.pinv\nBase.LinAlg.nullspace\nBase.repmat\nBase.repeat\nBase.kron\nBase.SparseArrays.blkdiag\nBase.LinAlg.linreg\nBase.LinAlg.expm\nBase.LinAlg.logm\nBase.LinAlg.sqrtm\nBase.LinAlg.lyap\nBase.LinAlg.sylvester\nBase.LinAlg.issymmetric\nBase.LinAlg.isposdef\nBase.LinAlg.isposdef!\nBase.LinAlg.istril\nBase.LinAlg.istriu\nBase.LinAlg.isdiag\nBase.LinAlg.ishermitian\nBase.LinAlg.RowVector\nBase.LinAlg.ConjArray\nBase.transpose\nBase.transpose!\nBase.ctranspose\nBase.ctranspose!\nBase.LinAlg.eigs(::Any)\nBase.LinAlg.eigs(::Any, ::Any)\nBase.LinAlg.svds\nBase.LinAlg.peakflops"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.A_ldiv_B!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.A_ldiv_B!",
    "category": "Function",
    "text": "A_ldiv_B!([Y,] A, B) -> Y\n\nCompute A \\ B in-place and store the result in Y, returning the result. If only two arguments are passed, then A_ldiv_B!(A, B) overwrites B with the result.\n\nThe argument A should not be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by factorize or cholfact). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., lufact!), and performance-critical situations requiring A_ldiv_B! usually also require fine-grained control over the factorization of A.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.A_ldiv_Bc",
    "page": "Álgebra Lineal",
    "title": "Base.A_ldiv_Bc",
    "category": "Function",
    "text": "A_ldiv_Bc(A, B)\n\nFor matrices or vectors A and B, calculates A \\ B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.A_ldiv_Bt",
    "page": "Álgebra Lineal",
    "title": "Base.A_ldiv_Bt",
    "category": "Function",
    "text": "A_ldiv_Bt(A, B)\n\nFor matrices or vectors A and B, calculates A \\ B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.A_mul_B!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.A_mul_B!",
    "category": "Function",
    "text": "A_mul_B!(Y, A, B) -> Y\n\nCalculates the matrix-matrix or matrix-vector product AB and stores the result in Y, overwriting the existing value of Y. Note that Y must not be aliased with either A or B.\n\nExample\n\njulia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); A_mul_B!(Y, A, B);\n\njulia> Y\n2×2 Array{Float64,2}:\n 3.0  3.0\n 7.0  7.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.A_mul_Bc",
    "page": "Álgebra Lineal",
    "title": "Base.A_mul_Bc",
    "category": "Function",
    "text": "A_mul_Bc(A, B)\n\nFor matrices or vectors A and B, calculates AB.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.A_mul_Bt",
    "page": "Álgebra Lineal",
    "title": "Base.A_mul_Bt",
    "category": "Function",
    "text": "A_mul_Bt(A, B)\n\nFor matrices or vectors A and B, calculates AB.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.A_rdiv_Bc",
    "page": "Álgebra Lineal",
    "title": "Base.A_rdiv_Bc",
    "category": "Function",
    "text": "A_rdiv_Bc(A, B)\n\nFor matrices or vectors A and B, calculates A  B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.A_rdiv_Bt",
    "page": "Álgebra Lineal",
    "title": "Base.A_rdiv_Bt",
    "category": "Function",
    "text": "A_rdiv_Bt(A, B)\n\nFor matrices or vectors A and B, calculates A  B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.Ac_ldiv_B",
    "page": "Álgebra Lineal",
    "title": "Base.Ac_ldiv_B",
    "category": "Function",
    "text": "Ac_ldiv_B(A, B)\n\nFor matrices or vectors A and B, calculates A \\ B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.Ac_ldiv_B!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.Ac_ldiv_B!",
    "category": "Function",
    "text": "Ac_ldiv_B!([Y,] A, B) -> Y\n\nSimilar to A_ldiv_B!, but return A \\ B, computing the result in-place in Y (or overwriting B if Y is not supplied).\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.Ac_ldiv_Bc",
    "page": "Álgebra Lineal",
    "title": "Base.Ac_ldiv_Bc",
    "category": "Function",
    "text": "Ac_ldiv_Bc(A, B)\n\nFor matrices or vectors A and B, calculates A \\ B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.Ac_mul_B",
    "page": "Álgebra Lineal",
    "title": "Base.Ac_mul_B",
    "category": "Function",
    "text": "Ac_mul_B(A, B)\n\nFor matrices or vectors A and B, calculates AB.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.Ac_mul_Bc",
    "page": "Álgebra Lineal",
    "title": "Base.Ac_mul_Bc",
    "category": "Function",
    "text": "Ac_mul_Bc(A, B)\n\nFor matrices or vectors A and B, calculates A B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.Ac_rdiv_B",
    "page": "Álgebra Lineal",
    "title": "Base.Ac_rdiv_B",
    "category": "Function",
    "text": "Ac_rdiv_B(A, B)\n\nFor matrices or vectors A and B, calculates A  B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.Ac_rdiv_Bc",
    "page": "Álgebra Lineal",
    "title": "Base.Ac_rdiv_Bc",
    "category": "Function",
    "text": "Ac_rdiv_Bc(A, B)\n\nFor matrices or vectors A and B, calculates A  B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.At_ldiv_B",
    "page": "Álgebra Lineal",
    "title": "Base.At_ldiv_B",
    "category": "Function",
    "text": "At_ldiv_B(A, B)\n\nFor matrices or vectors A and B, calculates A \\ B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.At_ldiv_B!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.At_ldiv_B!",
    "category": "Function",
    "text": "At_ldiv_B!([Y,] A, B) -> Y\n\nSimilar to A_ldiv_B!, but return A \\ B, computing the result in-place in Y (or overwriting B if Y is not supplied).\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.At_ldiv_Bt",
    "page": "Álgebra Lineal",
    "title": "Base.At_ldiv_Bt",
    "category": "Function",
    "text": "At_ldiv_Bt(A, B)\n\nFor matrices or vectors A and B, calculates A \\ B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.At_mul_B",
    "page": "Álgebra Lineal",
    "title": "Base.At_mul_B",
    "category": "Function",
    "text": "At_mul_B(A, B)\n\nFor matrices or vectors A and B, calculates AB.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.At_mul_Bt",
    "page": "Álgebra Lineal",
    "title": "Base.At_mul_Bt",
    "category": "Function",
    "text": "At_mul_Bt(A, B)\n\nFor matrices or vectors A and B, calculates AB.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.At_rdiv_B",
    "page": "Álgebra Lineal",
    "title": "Base.At_rdiv_B",
    "category": "Function",
    "text": "At_rdiv_B(A, B)\n\nFor matrices or vectors A and B, calculates A  B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.At_rdiv_Bt",
    "page": "Álgebra Lineal",
    "title": "Base.At_rdiv_Bt",
    "category": "Function",
    "text": "At_rdiv_Bt(A, B)\n\nFor matrices or vectors A and B, calculates A  B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Operaciones-matriciales-de-bajo-nivel-1",
    "page": "Álgebra Lineal",
    "title": "Operaciones matriciales de bajo nivel",
    "category": "section",
    "text": "Las operaciones de matrices que involucran operaciones de transposición como A' \\ B son convertidas por el analizador de Julia en llamadas a funciones especialmente nombradas como Ac_ldiv_B. Si desea sobrecargar estas operaciones para sus propios tipos, le será útil conocer los nombres de estas funciones.Además, en muchos casos, hay versiones in situ de operaciones matriciales que le permiten suministrar un vector o matriz de salida preasignada. Esto es útil cuando se optimiza código crítico para evitar la sobrecarga de las asignaciones repetidas. Estas operaciones in situ tienen el sufijo ! a continuación (por ejemplo, A_mul_B!) de acuerdo con la convención habitual de Julia.Base.LinAlg.A_ldiv_B!\nBase.A_ldiv_Bc\nBase.A_ldiv_Bt\nBase.LinAlg.A_mul_B!\nBase.A_mul_Bc\nBase.A_mul_Bt\nBase.A_rdiv_Bc\nBase.A_rdiv_Bt\nBase.Ac_ldiv_B\nBase.LinAlg.Ac_ldiv_B!\nBase.Ac_ldiv_Bc\nBase.Ac_mul_B\nBase.Ac_mul_Bc\nBase.Ac_rdiv_B\nBase.Ac_rdiv_Bc\nBase.At_ldiv_B\nBase.LinAlg.At_ldiv_B!\nBase.At_ldiv_Bt\nBase.At_mul_B\nBase.At_mul_Bt\nBase.At_rdiv_B\nBase.At_rdiv_Bt"
},

{
    "location": "stdlib/linalg.html#Funciones-BLAS-1",
    "page": "Álgebra Lineal",
    "title": "Funciones BLAS",
    "category": "section",
    "text": "En Julia (como en gran parte de la computación científica), las operaciones de álgebra lineal densa se basan en la biblioteca LAPACK, que a su vez se construye sobre bloques de construcción básicos de álgebra lineal conocidos como BLAS. Hay implementaciones altamente optimizadas de BLAS disponibles para cada arquitectura de computadora, y algunas veces en rutinas de álgebra lineal de alto rendimiento, es útil llamar directamente a las funciones de BLAS.Base.LinAlg.BLAS proporciona envoltorios para algunas de las funciones de BLAS. Esas funciones de BLAS que sobrescriben una de las matrices de entrada tienen nombres que terminan en '!'. Normalmente, una función BLAS tiene cuatro métodos definidos, para los arrays Float64, Float32, Complex128 yComplex64."
},

{
    "location": "stdlib/linalg.html#stdlib-blas-chars-1",
    "page": "Álgebra Lineal",
    "title": "Argumentos de tipo carácter en BLAS",
    "category": "section",
    "text": "Muchas funciones BLAS aceptan argumentos que determinan si se debe transponer un argumento (trans), qué triángulo de una matriz referenciar (uplo o ul), si se puede suponer que la diagonal de una matriz triangular está formada por unos (dA) o a qué lado de una multiplicación de matrices pertenece el argumento de entrada (side). Las posibilidades son:"
},

{
    "location": "stdlib/linalg.html#stdlib-blas-side-1",
    "page": "Álgebra Lineal",
    "title": "Orden de Multiplicación",
    "category": "section",
    "text": "side Significado\n'L' El argumento va al lado izquierdo de una operación matriz-matriz.\n'R' El argumento va al lado derecho de una operación matriz-matriz."
},

{
    "location": "stdlib/linalg.html#stdlib-blas-uplo-1",
    "page": "Álgebra Lineal",
    "title": "Referencia sobre el Triángulo",
    "category": "section",
    "text": "uplo/ul Significado\n'U'       Solo se usará el triángulo superior de la matriz.\n'L' Solo se usará el triángulo inferior de la matriz."
},

{
    "location": "stdlib/linalg.html#stdlib-blas-trans-1",
    "page": "Álgebra Lineal",
    "title": "Operación de Transposición",
    "category": "section",
    "text": "trans/tX Significado\n'N' La matriz de entrada X no es transpuesta ni conjugada.\n'T'       La matriz de entrada X será transpuesta.             \n'C'       La matriz de entrada X será conjugada y transpuesta."
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.dotu",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.dotu",
    "category": "Function",
    "text": "dotu(n, X, incx, Y, incy)\n\nDot function for two complex vectors consisting of n elements of array X with stride incx and n elements of array Y with stride incy.\n\nExample:\n\njulia> Base.BLAS.dotu(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)\n-10.0 + 10.0im\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.dotc",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.dotc",
    "category": "Function",
    "text": "dotc(n, X, incx, U, incy)\n\nDot function for two complex vectors, consisting of n elements of array X with stride incx and n elements of array U with stride incy, conjugating the first vector.\n\nExample:\n\njulia> Base.BLAS.dotc(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)\n10.0 - 10.0im\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.blascopy!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.blascopy!",
    "category": "Function",
    "text": "blascopy!(n, X, incx, Y, incy)\n\nCopy n elements of array X with stride incx to array Y with stride incy. Returns Y.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.nrm2",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.nrm2",
    "category": "Function",
    "text": "nrm2(n, X, incx)\n\n2-norm of a vector consisting of n elements of array X with stride incx.\n\nExample:\n\njulia> Base.BLAS.nrm2(4, ones(8), 2)\n2.0\n\njulia> Base.BLAS.nrm2(1, ones(8), 2)\n1.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.asum",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.asum",
    "category": "Function",
    "text": "asum(n, X, incx)\n\nSum of the absolute values of the first n elements of array X with stride incx.\n\nExample:\n\njulia> Base.BLAS.asum(5, im*ones(10), 2)\n5.0\n\njulia> Base.BLAS.asum(2, im*ones(10), 5)\n2.0\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.axpy!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.axpy!",
    "category": "Function",
    "text": "axpy!(a, X, Y)\n\nOverwrite Y with a*X + Y, where a is a scalar. Returns Y.\n\nExample:\n\njulia> x = [1; 2; 3];\n\njulia> y = [4; 5; 6];\n\njulia> Base.BLAS.axpy!(2, x, y)\n3-element Array{Int64,1}:\n  6\n  9\n 12\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.scal!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.scal!",
    "category": "Function",
    "text": "scal!(n, a, X, incx)\n\nOverwrite X with a*X for the first n elements of array X with stride incx. Returns X.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.scal",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.scal",
    "category": "Function",
    "text": "scal(n, a, X, incx)\n\nReturns X scaled by a for the first n elements of array X with stride incx.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.ger!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.ger!",
    "category": "Function",
    "text": "ger!(alpha, x, y, A)\n\nRank-1 update of the matrix A with vectors x and y as alpha*x*y' + A.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.syr!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.syr!",
    "category": "Function",
    "text": "syr!(uplo, alpha, x, A)\n\nRank-1 update of the symmetric matrix A with vector x as alpha*x*x.' + A. uplo controls which triangle of A is updated. Returns A.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.syrk!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.syrk!",
    "category": "Function",
    "text": "syrk!(uplo, trans, alpha, A, beta, C)\n\nRank-k update of the symmetric matrix C as alpha*A*A.' + beta*C or alpha*A.'*A + beta*C according to trans. Only the uplo triangle of C is used. Returns C.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.syrk",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.syrk",
    "category": "Function",
    "text": "syrk(uplo, trans, alpha, A)\n\nReturns either the upper triangle or the lower triangle of A, according to uplo, of alpha*A*A.' or alpha*A.'*A, according to trans.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.her!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.her!",
    "category": "Function",
    "text": "her!(uplo, alpha, x, A)\n\nMethods for complex arrays only. Rank-1 update of the Hermitian matrix A with vector x as alpha*x*x' + A. uplo controls which triangle of A is updated. Returns A.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.herk!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.herk!",
    "category": "Function",
    "text": "herk!(uplo, trans, alpha, A, beta, C)\n\nMethods for complex arrays only. Rank-k update of the Hermitian matrix C as alpha*A*A' + beta*C or alpha*A'*A + beta*C according to trans. Only the uplo triangle of C is updated. Returns C.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.herk",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.herk",
    "category": "Function",
    "text": "herk(uplo, trans, alpha, A)\n\nMethods for complex arrays only. Returns the uplo triangle of alpha*A*A' or alpha*A'*A, according to trans.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.gbmv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.gbmv!",
    "category": "Function",
    "text": "gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)\n\nUpdate vector y as alpha*A*x + beta*y or alpha*A'*x + beta*y according to trans. The matrix A is a general band matrix of dimension m by size(A,2) with kl sub-diagonals and ku super-diagonals. alpha and beta are scalars. Returns the updated y.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.gbmv",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.gbmv",
    "category": "Function",
    "text": "gbmv(trans, m, kl, ku, alpha, A, x)\n\nReturns alpha*A*x or alpha*A'*x according to trans. The matrix A is a general band matrix of dimension m by size(A,2) with kl sub-diagonals and ku super-diagonals, and alpha is a scalar.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.sbmv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.sbmv!",
    "category": "Function",
    "text": "sbmv!(uplo, k, alpha, A, x, beta, y)\n\nUpdate vector y as alpha*A*x + beta*y where A is a a symmetric band matrix of order size(A,2) with k super-diagonals stored in the argument A. The storage layout for A is described the reference BLAS module, level-2 BLAS at http://www.netlib.org/lapack/explore-html/. Only the uplo triangle of A is used.\n\nReturns the updated y.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.sbmv-NTuple{5,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.sbmv",
    "category": "Method",
    "text": "sbmv(uplo, k, alpha, A, x)\n\nReturns alpha*A*x where A is a symmetric band matrix of order size(A,2) with k super-diagonals stored in the argument A. Only the uplo triangle of A is used.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.sbmv-NTuple{4,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.sbmv",
    "category": "Method",
    "text": "sbmv(uplo, k, A, x)\n\nReturns A*x where A is a symmetric band matrix of order size(A,2) with k super-diagonals stored in the argument A. Only the uplo triangle of A is used.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.gemm!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.gemm!",
    "category": "Function",
    "text": "gemm!(tA, tB, alpha, A, B, beta, C)\n\nUpdate C as alpha*A*B + beta*C or the other three variants according to tA and tB. Returns the updated C.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.gemm-NTuple{5,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.gemm",
    "category": "Method",
    "text": "gemm(tA, tB, alpha, A, B)\n\nReturns alpha*A*B or the other three variants according to tA and tB.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.gemm-NTuple{4,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.gemm",
    "category": "Method",
    "text": "gemm(tA, tB, A, B)\n\nReturns A*B or the other three variants according to tA and tB.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.gemv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.gemv!",
    "category": "Function",
    "text": "gemv!(tA, alpha, A, x, beta, y)\n\nUpdate the vector y as alpha*A*x + beta*y or alpha*A'x + beta*y according to tA. alpha and beta are scalars. Returns the updated y.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.gemv-NTuple{4,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.gemv",
    "category": "Method",
    "text": "gemv(tA, alpha, A, x)\n\nReturns alpha*A*x or alpha*A'x according to tA. alpha is a scalar.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.gemv-Tuple{Any,Any,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.gemv",
    "category": "Method",
    "text": "gemv(tA, A, x)\n\nReturns A*x or A'x according to tA.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.symm!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.symm!",
    "category": "Function",
    "text": "symm!(side, ul, alpha, A, B, beta, C)\n\nUpdate C as alpha*A*B + beta*C or alpha*B*A + beta*C according to side. A is assumed to be symmetric. Only the ul triangle of A is used. Returns the updated C.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.symm-NTuple{5,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.symm",
    "category": "Method",
    "text": "symm(side, ul, alpha, A, B)\n\nReturns alpha*A*B or alpha*B*A according to side. A is assumed to be symmetric. Only the ul triangle of A is used.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.symm-NTuple{4,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.symm",
    "category": "Method",
    "text": "symm(side, ul, A, B)\n\nReturns A*B or B*A according to side. A is assumed to be symmetric. Only the ul triangle of A is used.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.symv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.symv!",
    "category": "Function",
    "text": "symv!(ul, alpha, A, x, beta, y)\n\nUpdate the vector y as alpha*A*x + beta*y. A is assumed to be symmetric. Only the ul triangle of A is used. alpha and beta are scalars. Returns the updated y.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.symv-NTuple{4,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.symv",
    "category": "Method",
    "text": "symv(ul, alpha, A, x)\n\nReturns alpha*A*x. A is assumed to be symmetric. Only the ul triangle of A is used. alpha is a scalar.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.symv-Tuple{Any,Any,Any}",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.symv",
    "category": "Method",
    "text": "symv(ul, A, x)\n\nReturns A*x. A is assumed to be symmetric. Only the ul triangle of A is used.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.trmm!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.trmm!",
    "category": "Function",
    "text": "trmm!(side, ul, tA, dA, alpha, A, B)\n\nUpdate B as alpha*A*B or one of the other three variants determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones. Returns the updated B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.trmm",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.trmm",
    "category": "Function",
    "text": "trmm(side, ul, tA, dA, alpha, A, B)\n\nReturns alpha*A*B or one of the other three variants determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.trsm!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.trsm!",
    "category": "Function",
    "text": "trsm!(side, ul, tA, dA, alpha, A, B)\n\nOverwrite B with the solution to A*X = alpha*B or one of the other three variants determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones. Returns the updated B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.trsm",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.trsm",
    "category": "Function",
    "text": "trsm(side, ul, tA, dA, alpha, A, B)\n\nReturns the solution to A*X = alpha*B or one of the other three variants determined by determined by side and tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.trmv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.trmv!",
    "category": "Function",
    "text": "trmv!(ul, tA, dA, A, b)\n\nReturns op(A)*b, where op is determined by tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on b.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.trmv",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.trmv",
    "category": "Function",
    "text": "trmv(ul, tA, dA, A, b)\n\nReturns op(A)*b, where op is determined by tA. Only the ul triangle of A is used. dA determines if the diagonal values are read or are assumed to be all ones.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.trsv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.trsv!",
    "category": "Function",
    "text": "trsv!(ul, tA, dA, A, b)\n\nOverwrite b with the solution to A*x = b or one of the other two variants determined by tA and ul. dA determines if the diagonal values are read or are assumed to be all ones. Returns the updated b.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.trsv",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.trsv",
    "category": "Function",
    "text": "trsv(ul, tA, dA, A, b)\n\nReturns the solution to A*x = b or one of the other two variants determined by tA and ul. dA determines if the diagonal values are read or are assumed to be all ones.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.BLAS.set_num_threads",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.BLAS.set_num_threads",
    "category": "Function",
    "text": "set_num_threads(n)\n\nSet the number of threads the BLAS library should use.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.I",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.I",
    "category": "Constant",
    "text": "I\n\nAn object of type UniformScaling, representing an identity matrix of any size.\n\nExample\n\njulia> ones(5, 6) * I == ones(5, 6)\ntrue\n\njulia> [1 2im 3; 1im 2 3] * I\n2×3 Array{Complex{Int64},2}:\n 1+0im  0+2im  3+0im\n 0+1im  2+0im  3+0im\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#stdlib-blas-diag-1",
    "page": "Álgebra Lineal",
    "title": "Unidades en la Diagonal",
    "category": "section",
    "text": "diag/dX Significado\n'N'       Los valores diagonales de la matriz X serán leídos.\n'U' Se supone que los elementos de la diagonal de la matriz X son todos unos.Base.LinAlg.BLAS.dotu\nBase.LinAlg.BLAS.dotc\nBase.LinAlg.BLAS.blascopy!\nBase.LinAlg.BLAS.nrm2\nBase.LinAlg.BLAS.asum\nBase.LinAlg.axpy!\nBase.LinAlg.BLAS.scal!\nBase.LinAlg.BLAS.scal\nBase.LinAlg.BLAS.ger!\nBase.LinAlg.BLAS.syr!\nBase.LinAlg.BLAS.syrk!\nBase.LinAlg.BLAS.syrk\nBase.LinAlg.BLAS.her!\nBase.LinAlg.BLAS.herk!\nBase.LinAlg.BLAS.herk\nBase.LinAlg.BLAS.gbmv!\nBase.LinAlg.BLAS.gbmv\nBase.LinAlg.BLAS.sbmv!\nBase.LinAlg.BLAS.sbmv(::Any, ::Any, ::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.sbmv(::Any, ::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.gemm!\nBase.LinAlg.BLAS.gemm(::Any, ::Any, ::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.gemm(::Any, ::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.gemv!\nBase.LinAlg.BLAS.gemv(::Any, ::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.gemv(::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.symm!\nBase.LinAlg.BLAS.symm(::Any, ::Any, ::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.symm(::Any, ::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.symv!\nBase.LinAlg.BLAS.symv(::Any, ::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.symv(::Any, ::Any, ::Any)\nBase.LinAlg.BLAS.trmm!\nBase.LinAlg.BLAS.trmm\nBase.LinAlg.BLAS.trsm!\nBase.LinAlg.BLAS.trsm\nBase.LinAlg.BLAS.trmv!\nBase.LinAlg.BLAS.trmv\nBase.LinAlg.BLAS.trsv!\nBase.LinAlg.BLAS.trsv\nBase.LinAlg.BLAS.set_num_threads\nBase.LinAlg.I"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gbtrf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gbtrf!",
    "category": "Function",
    "text": "gbtrf!(kl, ku, m, AB) -> (AB, ipiv)\n\nCompute the LU factorization of a banded matrix AB. kl is the first subdiagonal containing a nonzero band, ku is the last superdiagonal containing one, and m is the first dimension of the matrix AB. Returns the LU factorization in-place and ipiv, the vector of pivots used.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gbtrs!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gbtrs!",
    "category": "Function",
    "text": "gbtrs!(trans, kl, ku, m, AB, ipiv, B)\n\nSolve the equation AB * X = B. trans determines the orientation of AB. It may be N (no transpose), T (transpose), or C (conjugate transpose). kl is the first subdiagonal containing a nonzero band, ku is the last superdiagonal containing one, and m is the first dimension of the matrix AB. ipiv is the vector of pivots returned from gbtrf!. Returns the vector or matrix X, overwriting B in-place.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gebal!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gebal!",
    "category": "Function",
    "text": "gebal!(job, A) -> (ilo, ihi, scale)\n\nBalance the matrix A before computing its eigensystem or Schur factorization. job can be one of N (A will not be permuted or scaled), P (A will only be permuted), S (A will only be scaled), or B (A will be both permuted and scaled). Modifies A in-place and returns ilo, ihi, and scale. If permuting was turned on, A[i,j] = 0 if j > i and 1 < j < ilo or j > ihi. scale contains information about the scaling/permutations performed.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gebak!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gebak!",
    "category": "Function",
    "text": "gebak!(job, side, ilo, ihi, scale, V)\n\nTransform the eigenvectors V of a matrix balanced using gebal! to the unscaled/unpermuted eigenvectors of the original matrix. Modifies V in-place. side can be L (left eigenvectors are transformed) or R (right eigenvectors are transformed).\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gebrd!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gebrd!",
    "category": "Function",
    "text": "gebrd!(A) -> (A, d, e, tauq, taup)\n\nReduce A in-place to bidiagonal form A = QBP'. Returns A, containing the bidiagonal matrix B; d, containing the diagonal elements of B; e, containing the off-diagonal elements of B; tauq, containing the elementary reflectors representing Q; and taup, containing the elementary reflectors representing P.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gelqf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gelqf!",
    "category": "Function",
    "text": "gelqf!(A, tau)\n\nCompute the LQ factorization of A, A = LQ. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\ngelqf!(A) -> (A, tau)\n\nCompute the LQ factorization of A, A = LQ.\n\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.geqlf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.geqlf!",
    "category": "Function",
    "text": "geqlf!(A, tau)\n\nCompute the QL factorization of A, A = QL. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\ngeqlf!(A) -> (A, tau)\n\nCompute the QL factorization of A, A = QL.\n\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.geqrf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.geqrf!",
    "category": "Function",
    "text": "geqrf!(A, tau)\n\nCompute the QR factorization of A, A = QR. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\ngeqrf!(A) -> (A, tau)\n\nCompute the QR factorization of A, A = QR.\n\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.geqp3!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.geqp3!",
    "category": "Function",
    "text": "geqp3!(A, jpvt, tau)\n\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3. P is a pivoting matrix, represented by jpvt. tau stores the elementary reflectors. jpvt must have length length greater than or equal to n if A is an (m x n) matrix. tau must have length greater than or equal to the smallest dimension of A.\n\nA, jpvt, and tau are modified in-place.\n\n\n\ngeqp3!(A, jpvt) -> (A, jpvt, tau)\n\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3. P is a pivoting matrix, represented by jpvt. jpvt must have length greater than or equal to n if A is an (m x n) matrix.\n\nReturns A and jpvt, modified in-place, and tau, which stores the elementary reflectors.\n\n\n\ngeqp3!(A) -> (A, jpvt, tau)\n\nCompute the pivoted QR factorization of A, AP = QR using BLAS level 3.\n\nReturns A, modified in-place, jpvt, which represents the pivoting matrix P, and tau, which stores the elementary reflectors.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gerqf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gerqf!",
    "category": "Function",
    "text": "gerqf!(A, tau)\n\nCompute the RQ factorization of A, A = RQ. tau contains scalars which parameterize the elementary reflectors of the factorization. tau must have length greater than or equal to the smallest dimension of A.\n\nReturns A and tau modified in-place.\n\n\n\ngerqf!(A) -> (A, tau)\n\nCompute the RQ factorization of A, A = RQ.\n\nReturns A, modified in-place, and tau, which contains scalars which parameterize the elementary reflectors of the factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.geqrt!",
    "category": "Function",
    "text": "geqrt!(A, T)\n\nCompute the blocked QR factorization of A, A = QR. T contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of T sets the block size and it must be between 1 and n. The second dimension of T must equal the smallest dimension of A.\n\nReturns A and T modified in-place.\n\n\n\ngeqrt!(A, nb) -> (A, T)\n\nCompute the blocked QR factorization of A, A = QR. nb sets the block size and it must be between 1 and n, the second dimension of A.\n\nReturns A, modified in-place, and T, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.geqrt3!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.geqrt3!",
    "category": "Function",
    "text": "geqrt3!(A, T)\n\nRecursively computes the blocked QR factorization of A, A = QR. T contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of T sets the block size and it must be between 1 and n. The second dimension of T must equal the smallest dimension of A.\n\nReturns A and T modified in-place.\n\n\n\ngeqrt3!(A) -> (A, T)\n\nRecursively computes the blocked QR factorization of A, A = QR.\n\nReturns A, modified in-place, and T, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.getrf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.getrf!",
    "category": "Function",
    "text": "getrf!(A) -> (A, ipiv, info)\n\nCompute the pivoted LU factorization of A, A = LU.\n\nReturns A, modified in-place, ipiv, the pivoting information, and an info code which indicates success (info = 0), a singular value in U (info = i, in which case U[i,i] is singular), or an error code (info < 0).\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.tzrzf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.tzrzf!",
    "category": "Function",
    "text": "tzrzf!(A) -> (A, tau)\n\nTransforms the upper trapezoidal matrix A to upper triangular form in-place. Returns A and tau, the scalar parameters for the elementary reflectors of the transformation.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.ormrz!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.ormrz!",
    "category": "Function",
    "text": "ormrz!(side, trans, A, tau, C)\n\nMultiplies the matrix C by Q from the transformation supplied by tzrzf!. Depending on side or trans the multiplication can be left-sided (side = L, Q*C) or right-sided (side = R, C*Q) and Q can be unmodified (trans = N), transposed (trans = T), or conjugate transposed (trans = C). Returns matrix C which is modified in-place with the result of the multiplication.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gels!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gels!",
    "category": "Function",
    "text": "gels!(trans, A, B) -> (F, B, ssr)\n\nSolves the linear equation A * X = B, A.' * X =B, or A' * X = B using a QR or LQ factorization. Modifies the matrix/vector B in place with the solution. A is overwritten with its QR or LQ factorization. trans may be one of N (no modification), T (transpose), or C (conjugate transpose). gels! searches for the minimum norm/least squares solution. A may be under or over determined. The solution is returned in B.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gesv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gesv!",
    "category": "Function",
    "text": "gesv!(A, B) -> (B, A, ipiv)\n\nSolves the linear equation A * X = B where A is a square matrix using the LU factorization of A. A is overwritten with its LU factorization and B is overwritten with the solution X. ipiv contains the pivoting information for the LU factorization of A.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.getrs!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.getrs!",
    "category": "Function",
    "text": "getrs!(trans, A, ipiv, B)\n\nSolves the linear equation A * X = B, A.' * X =B, or A' * X = B for square A. Modifies the matrix/vector B in place with the solution. A is the LU factorization from getrf!, with ipiv the pivoting information. trans may be one of N (no modification), T (transpose), or C (conjugate transpose).\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.getri!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.getri!",
    "category": "Function",
    "text": "getri!(A, ipiv)\n\nComputes the inverse of A, using its LU factorization found by getrf!. ipiv is the pivot information output and A contains the LU factorization of getrf!. A is overwritten with its inverse.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gesvx!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gesvx!",
    "category": "Function",
    "text": "gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)\n\nSolves the linear equation A * X = B (trans = N), A.' * X =B (trans = T), or A' * X = B (trans = C) using the LU factorization of A. fact may be E, in which case A will be equilibrated and copied to AF; F, in which case AF and ipiv from a previous LU factorization are inputs; or N, in which case A will be copied to AF and then factored. If fact = F, equed may be N, meaning A has not been equilibrated; R, meaning A was multiplied by diagm(R) from the left; C, meaning A was multiplied by diagm(C) from the right; or B, meaning A was multiplied by diagm(R) from the left and diagm(C) from the right. If fact = F and equed = R or B the elements of R must all be positive. If fact = F and equed = C or B the elements of C must all be positive.\n\nReturns the solution X; equed, which is an output if fact is not N, and describes the equilibration that was performed; R, the row equilibration diagonal; C, the column equilibration diagonal; B, which may be overwritten with its equilibrated form diagm(R)*B (if trans = N and equed = R,B) or diagm(C)*B (if trans = T,C and equed = C,B); rcond, the reciprocal condition number of A after equilbrating; ferr, the forward error bound for each solution vector in X; berr, the forward error bound for each solution vector in X; and work, the reciprocal pivot growth factor.\n\n\n\ngesvx!(A, B)\n\nThe no-equilibration, no-transpose simplification of gesvx!.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gelsd!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gelsd!",
    "category": "Function",
    "text": "gelsd!(A, B, rcond) -> (B, rnk)\n\nComputes the least norm solution of A * X = B by finding the SVD factorization of A, then dividing-and-conquering the problem. B is overwritten with the solution X. Singular values below rcond will be treated as zero. Returns the solution in B and the effective rank of A in rnk.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gelsy!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gelsy!",
    "category": "Function",
    "text": "gelsy!(A, B, rcond) -> (B, rnk)\n\nComputes the least norm solution of A * X = B by finding the full QR factorization of A, then dividing-and-conquering the problem. B is overwritten with the solution X. Singular values below rcond will be treated as zero. Returns the solution in B and the effective rank of A in rnk.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gglse!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gglse!",
    "category": "Function",
    "text": "gglse!(A, c, B, d) -> (X,res)\n\nSolves the equation A * x = c where x is subject to the equality constraint B * x = d. Uses the formula ||c - A*x||^2 = 0 to solve. Returns X and the residual sum-of-squares.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.geev!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.geev!",
    "category": "Function",
    "text": "geev!(jobvl, jobvr, A) -> (W, VL, VR)\n\nFinds the eigensystem of A. If jobvl = N, the left eigenvectors of A aren't computed. If jobvr = N, the right eigenvectors of A aren't computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed. Returns the eigenvalues in W, the right eigenvectors in VR, and the left eigenvectors in VL.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gesdd!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gesdd!",
    "category": "Function",
    "text": "gesdd!(job, A) -> (U, S, VT)\n\nFinds the singular value decomposition of A, A = U * S * V', using a divide and conquer approach. If job = A, all the columns of U and the rows of V' are computed. If job = N, no columns of U or rows of V' are computed. If job = O, A is overwritten with the columns of (thin) U and the rows of (thin) V'. If job = S, the columns of (thin) U and the rows of (thin) V' are computed and returned separately.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gesvd!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gesvd!",
    "category": "Function",
    "text": "gesvd!(jobu, jobvt, A) -> (U, S, VT)\n\nFinds the singular value decomposition of A, A = U * S * V'. If jobu = A, all the columns of U are computed. If jobvt = A all the rows of V' are computed. If jobu = N, no columns of U are computed. If jobvt = N no rows of V' are computed. If jobu = O, A is overwritten with the columns of (thin) U. If jobvt = O, A is overwritten with the rows of (thin) V'. If jobu = S, the columns of (thin) U are computed and returned separately. If jobvt = S the rows of (thin) V' are computed and returned separately. jobu and jobvt can't both be O.\n\nReturns U, S, and Vt, where S are the singular values of A.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.ggsvd!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.ggsvd!",
    "category": "Function",
    "text": "ggsvd!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)\n\nFinds the generalized singular value decomposition of A and B, U'*A*Q = D1*R and V'*B*Q = D2*R. D1 has alpha on its diagonal and D2 has beta on its diagonal. If jobu = U, the orthogonal/unitary matrix U is computed. If jobv = V the orthogonal/unitary matrix V is computed. If jobq = Q, the orthogonal/unitary matrix Q is computed. If jobu, jobv or jobq is N, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.ggsvd3!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.ggsvd3!",
    "category": "Function",
    "text": "ggsvd3!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)\n\nFinds the generalized singular value decomposition of A and B, U'*A*Q = D1*R and V'*B*Q = D2*R. D1 has alpha on its diagonal and D2 has beta on its diagonal. If jobu = U, the orthogonal/unitary matrix U is computed. If jobv = V the orthogonal/unitary matrix V is computed. If jobq = Q, the orthogonal/unitary matrix Q is computed. If jobu, jobv, or jobq is N, that matrix is not computed. This function requires LAPACK 3.6.0.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.geevx!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.geevx!",
    "category": "Function",
    "text": "geevx!(balanc, jobvl, jobvr, sense, A) -> (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)\n\nFinds the eigensystem of A with matrix balancing. If jobvl = N, the left eigenvectors of A aren't computed. If jobvr = N, the right eigenvectors of A aren't computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed. If balanc = N, no balancing is performed. If balanc = P, A is permuted but not scaled. If balanc = S, A is scaled but not permuted. If balanc = B, A is permuted and scaled. If sense = N, no reciprocal condition numbers are computed. If sense = E, reciprocal condition numbers are computed for the eigenvalues only. If sense = V, reciprocal condition numbers are computed for the right eigenvectors only. If sense = B, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If sense = E,B, the right and left eigenvectors must be computed.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.ggev!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.ggev!",
    "category": "Function",
    "text": "ggev!(jobvl, jobvr, A, B) -> (alpha, beta, vl, vr)\n\nFinds the generalized eigendecomposition of A and B. If jobvl = N, the left eigenvectors aren't computed. If jobvr = N, the right eigenvectors aren't computed. If jobvl = V or jobvr = V, the corresponding eigenvectors are computed.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gtsv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gtsv!",
    "category": "Function",
    "text": "gtsv!(dl, d, du, B)\n\nSolves the equation A * X = B where A is a tridiagonal matrix with dl on the subdiagonal, d on the diagonal, and du on the superdiagonal.\n\nOverwrites B with the solution X and returns it.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gttrf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gttrf!",
    "category": "Function",
    "text": "gttrf!(dl, d, du) -> (dl, d, du, du2, ipiv)\n\nFinds the LU factorization of a tridiagonal matrix with dl on the subdiagonal, d on the diagonal, and du on the superdiagonal.\n\nModifies dl, d, and du in-place and returns them and the second superdiagonal du2 and the pivoting vector ipiv.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gttrs!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gttrs!",
    "category": "Function",
    "text": "gttrs!(trans, dl, d, du, du2, ipiv, B)\n\nSolves the equation A * X = B (trans = N), A.' * X = B (trans = T), or A' * X = B (trans = C) using the LU factorization computed by gttrf!. B is overwritten with the solution X.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.orglq!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.orglq!",
    "category": "Function",
    "text": "orglq!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a LQ factorization after calling gelqf! on A. Uses the output of gelqf!. A is overwritten by Q.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.orgqr!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.orgqr!",
    "category": "Function",
    "text": "orgqr!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a QR factorization after calling geqrf! on A. Uses the output of geqrf!. A is overwritten by Q.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.orgql!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.orgql!",
    "category": "Function",
    "text": "orgql!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a QL factorization after calling geqlf! on A. Uses the output of geqlf!. A is overwritten by Q.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.orgrq!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.orgrq!",
    "category": "Function",
    "text": "orgrq!(A, tau, k = length(tau))\n\nExplicitly finds the matrix Q of a RQ factorization after calling gerqf! on A. Uses the output of gerqf!. A is overwritten by Q.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.ormlq!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.ormlq!",
    "category": "Function",
    "text": "ormlq!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), Q.' * C (trans = T), Q' * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a LQ factorization of A computed using gelqf!. C is overwritten.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.ormqr!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.ormqr!",
    "category": "Function",
    "text": "ormqr!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), Q.' * C (trans = T), Q' * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QR factorization of A computed using geqrf!. C is overwritten.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.ormql!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.ormql!",
    "category": "Function",
    "text": "ormql!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), Q.' * C (trans = T), Q' * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QL factorization of A computed using geqlf!. C is overwritten.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.ormrq!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.ormrq!",
    "category": "Function",
    "text": "ormrq!(side, trans, A, tau, C)\n\nComputes Q * C (trans = N), Q.' * C (trans = T), Q' * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a RQ factorization of A computed using gerqf!. C is overwritten.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gemqrt!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gemqrt!",
    "category": "Function",
    "text": "gemqrt!(side, trans, V, T, C)\n\nComputes Q * C (trans = N), Q.' * C (trans = T), Q' * C (trans = C) for side = L or the equivalent right-sided multiplication for side = R using Q from a QR factorization of A computed using geqrt!. C is overwritten.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.posv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.posv!",
    "category": "Function",
    "text": "posv!(uplo, A, B) -> (A, B)\n\nFinds the solution to A * X = B where A is a symmetric or Hermitian positive definite matrix. If uplo = U the upper Cholesky decomposition of A is computed. If uplo = L the lower Cholesky decomposition of A is computed. A is overwritten by its Cholesky decomposition. B is overwritten with the solution X.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.potrf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.potrf!",
    "category": "Function",
    "text": "potrf!(uplo, A)\n\nComputes the Cholesky (upper if uplo = U, lower if uplo = L) decomposition of positive-definite matrix A. A is overwritten and returned with an info code.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.potri!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.potri!",
    "category": "Function",
    "text": "potri!(uplo, A)\n\nComputes the inverse of positive-definite matrix A after calling potrf! to find its (upper if uplo = U, lower if uplo = L) Cholesky decomposition.\n\nA is overwritten by its inverse and returned.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.potrs!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.potrs!",
    "category": "Function",
    "text": "potrs!(uplo, A, B)\n\nFinds the solution to A * X = B where A is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by potrf!. If uplo = U the upper Cholesky decomposition of A was computed. If uplo = L the lower Cholesky decomposition of A was computed. B is overwritten with the solution X.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.pstrf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.pstrf!",
    "category": "Function",
    "text": "pstrf!(uplo, A, tol) -> (A, piv, rank, info)\n\nComputes the (upper if uplo = U, lower if uplo = L) pivoted Cholesky decomposition of positive-definite matrix A with a user-set tolerance tol. A is overwritten by its Cholesky decomposition.\n\nReturns A, the pivots piv, the rank of A, and an info code. If info = 0, the factorization succeeded. If info = i > 0, then A is indefinite or rank-deficient.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.ptsv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.ptsv!",
    "category": "Function",
    "text": "ptsv!(D, E, B)\n\nSolves A * X = B for positive-definite tridiagonal A. D is the diagonal of A and E is the off-diagonal. B is overwritten with the solution X and returned.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.pttrf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.pttrf!",
    "category": "Function",
    "text": "pttrf!(D, E)\n\nComputes the LDLt factorization of a positive-definite tridiagonal matrix with D as diagonal and E as off-diagonal. D and E are overwritten and returned.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.pttrs!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.pttrs!",
    "category": "Function",
    "text": "pttrs!(D, E, B)\n\nSolves A * X = B for positive-definite tridiagonal A with diagonal D and off-diagonal E after computing A's LDLt factorization using pttrf!. B is overwritten with the solution X.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.trtri!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.trtri!",
    "category": "Function",
    "text": "trtri!(uplo, diag, A)\n\nFinds the inverse of (upper if uplo = U, lower if uplo = L) triangular matrix A. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. A is overwritten with its inverse.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.trtrs!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.trtrs!",
    "category": "Function",
    "text": "trtrs!(uplo, trans, diag, A, B)\n\nSolves A * X = B (trans = N), A.' * X = B (trans = T), or A' * X = B (trans = C) for (upper if uplo = U, lower if uplo = L) triangular matrix A. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. B is overwritten with the solution X.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.trcon!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.trcon!",
    "category": "Function",
    "text": "trcon!(norm, uplo, diag, A)\n\nFinds the reciprocal condition number of (upper if uplo = U, lower if uplo = L) triangular matrix A. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. If norm = I, the condition number is found in the infinity norm. If norm = O or 1, the condition number is found in the one norm.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.trevc!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.trevc!",
    "category": "Function",
    "text": "trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))\n\nFinds the eigensystem of an upper triangular matrix T. If side = R, the right eigenvectors are computed. If side = L, the left eigenvectors are computed. If side = B, both sets are computed. If howmny = A, all eigenvectors are found. If howmny = B, all eigenvectors are found and backtransformed using VL and VR. If howmny = S, only the eigenvectors corresponding to the values in select are computed.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.trrfs!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.trrfs!",
    "category": "Function",
    "text": "trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -> (Ferr, Berr)\n\nEstimates the error in the solution to A * X = B (trans = N), A.' * X = B (trans = T), A' * X = B (trans = C) for side = L, or the equivalent equations a right-handed side = R X * A after computing X using trtrs!. If uplo = U, A is upper triangular. If uplo = L, A is lower triangular. If diag = N, A has non-unit diagonal elements. If diag = U, all diagonal elements of A are one. Ferr and Berr are optional inputs. Ferr is the forward error and Berr is the backward error, each component-wise.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.stev!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.stev!",
    "category": "Function",
    "text": "stev!(job, dv, ev) -> (dv, Zmat)\n\nComputes the eigensystem for a symmetric tridiagonal matrix with dv as diagonal and ev as off-diagonal. If job = N only the eigenvalues are found and returned in dv. If job = V then the eigenvectors are also found and returned in Zmat.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.stebz!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.stebz!",
    "category": "Function",
    "text": "stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -> (dv, iblock, isplit)\n\nComputes the eigenvalues for a symmetric tridiagonal matrix with dv as diagonal and ev as off-diagonal. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. If order = B, eigvalues are ordered within a block. If order = E, they are ordered across all the blocks. abstol can be set as a tolerance for convergence.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.stegr!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.stegr!",
    "category": "Function",
    "text": "stegr!(jobz, range, dv, ev, vl, vu, il, iu) -> (w, Z)\n\nComputes the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) for a symmetric tridiagonal matrix with dv as diagonal and ev as off-diagonal. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. The eigenvalues are returned in w and the eigenvectors in Z.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.stein!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.stein!",
    "category": "Function",
    "text": "stein!(dv, ev_in, w_in, iblock_in, isplit_in)\n\nComputes the eigenvectors for a symmetric tridiagonal matrix with dv as diagonal and ev_in as off-diagonal. w_in specifies the input eigenvalues for which to find corresponding eigenvectors. iblock_in specifies the submatrices corresponding to the eigenvalues in w_in. isplit_in specifies the splitting points between the submatrix blocks.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.syconv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.syconv!",
    "category": "Function",
    "text": "syconv!(uplo, A, ipiv) -> (A, work)\n\nConverts a symmetric matrix A (which has been factorized into a triangular matrix) into two matrices L and D. If uplo = U, A is upper triangular. If uplo = L, it is lower triangular. ipiv is the pivot vector from the triangular factorization. A is overwritten by L and D.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.sysv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.sysv!",
    "category": "Function",
    "text": "sysv!(uplo, A, B) -> (B, A, ipiv)\n\nFinds the solution to A * X = B for symmetric matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X. A is overwritten by its Bunch-Kaufman factorization. ipiv contains pivoting information about the factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.sytrf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.sytrf!",
    "category": "Function",
    "text": "sytrf!(uplo, A) -> (A, ipiv, info)\n\nComputes the Bunch-Kaufman factorization of a symmetric matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored.\n\nReturns A, overwritten by the factorization, a pivot vector ipiv, and the error code info which is a non-negative integer. If info is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position info.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.sytri!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.sytri!",
    "category": "Function",
    "text": "sytri!(uplo, A, ipiv)\n\nComputes the inverse of a symmetric matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. A is overwritten by its inverse.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.sytrs!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.sytrs!",
    "category": "Function",
    "text": "sytrs!(uplo, A, ipiv, B)\n\nSolves the equation A * X = B for a symmetric matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.hesv!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.hesv!",
    "category": "Function",
    "text": "hesv!(uplo, A, B) -> (B, A, ipiv)\n\nFinds the solution to A * X = B for Hermitian matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X. A is overwritten by its Bunch-Kaufman factorization. ipiv contains pivoting information about the factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.hetrf!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.hetrf!",
    "category": "Function",
    "text": "hetrf!(uplo, A) -> (A, ipiv, info)\n\nComputes the Bunch-Kaufman factorization of a Hermitian matrix A. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored.\n\nReturns A, overwritten by the factorization, a pivot vector ipiv, and the error code info which is a non-negative integer. If info is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position info.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.hetri!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.hetri!",
    "category": "Function",
    "text": "hetri!(uplo, A, ipiv)\n\nComputes the inverse of a Hermitian matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. A is overwritten by its inverse.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.hetrs!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.hetrs!",
    "category": "Function",
    "text": "hetrs!(uplo, A, ipiv, B)\n\nSolves the equation A * X = B for a Hermitian matrix A using the results of sytrf!. If uplo = U, the upper half of A is stored. If uplo = L, the lower half is stored. B is overwritten by the solution X.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.syev!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.syev!",
    "category": "Function",
    "text": "syev!(jobz, uplo, A)\n\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A. If uplo = U, the upper triangle of A is used. If uplo = L, the lower triangle of A is used.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.syevr!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.syevr!",
    "category": "Function",
    "text": "syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -> (W, Z)\n\nFinds the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A. If uplo = U, the upper triangle of A is used. If uplo = L, the lower triangle of A is used. If range = A, all the eigenvalues are found. If range = V, the eigenvalues in the half-open interval (vl, vu] are found. If range = I, the eigenvalues with indices between il and iu are found. abstol can be set as a tolerance for convergence.\n\nThe eigenvalues are returned in W and the eigenvectors in Z.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.sygvd!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.sygvd!",
    "category": "Function",
    "text": "sygvd!(itype, jobz, uplo, A, B) -> (w, A, B)\n\nFinds the generalized eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrix A and symmetric positive-definite matrix B. If uplo = U, the upper triangles of A and B are used. If uplo = L, the lower triangles of A and B are used. If itype = 1, the problem to solve is A * x = lambda * B * x. If itype = 2, the problem to solve is A * B * x = lambda * x. If itype = 3, the problem to solve is B * A * x = lambda * x.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.bdsqr!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.bdsqr!",
    "category": "Function",
    "text": "bdsqr!(uplo, d, e_, Vt, U, C) -> (d, Vt, U, C)\n\nComputes the singular value decomposition of a bidiagonal matrix with d on the diagonal and e_ on the off-diagonal. If uplo = U, e_ is the superdiagonal. If uplo = L, e_ is the subdiagonal. Can optionally also compute the product Q' * C.\n\nReturns the singular values in d, and the matrix C overwritten with Q' * C.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.bdsdc!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.bdsdc!",
    "category": "Function",
    "text": "bdsdc!(uplo, compq, d, e_) -> (d, e, u, vt, q, iq)\n\nComputes the singular value decomposition of a bidiagonal matrix with d on the diagonal and e_ on the off-diagonal using a divide and conqueq method. If uplo = U, e_ is the superdiagonal. If uplo = L, e_ is the subdiagonal. If compq = N, only the singular values are found. If compq = I, the singular values and vectors are found. If compq = P, the singular values and vectors are found in compact form. Only works for real types.\n\nReturns the singular values in d, and if compq = P, the compact singular vectors in iq.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gecon!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gecon!",
    "category": "Function",
    "text": "gecon!(normtype, A, anorm)\n\nFinds the reciprocal condition number of matrix A. If normtype = I, the condition number is found in the infinity norm. If normtype = O or 1, the condition number is found in the one norm. A must be the result of getrf! and anorm is the norm of A in the relevant norm.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gehrd!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gehrd!",
    "category": "Function",
    "text": "gehrd!(ilo, ihi, A) -> (A, tau)\n\nConverts a matrix A to Hessenberg form. If A is balanced with gebal! then ilo and ihi are the outputs of gebal!. Otherwise they should be ilo = 1 and ihi = size(A,2). tau contains the elementary reflectors of the factorization.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.orghr!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.orghr!",
    "category": "Function",
    "text": "orghr!(ilo, ihi, A, tau)\n\nExplicitly finds Q, the orthogonal/unitary matrix from gehrd!. ilo, ihi, A, and tau must correspond to the input/output to gehrd!.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gees!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gees!",
    "category": "Function",
    "text": "gees!(jobvs, A) -> (A, vs, w)\n\nComputes the eigenvalues (jobvs = N) or the eigenvalues and Schur vectors (jobvs = V) of matrix A. A is overwritten by its Schur form.\n\nReturns A, vs containing the Schur vectors, and w, containing the eigenvalues.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.gges!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.gges!",
    "category": "Function",
    "text": "gges!(jobvsl, jobvsr, A, B) -> (A, B, alpha, beta, vsl, vsr)\n\nComputes the generalized eigenvalues, generalized Schur form, left Schur vectors (jobsvl = V), or right Schur vectors (jobvsr = V) of A and B.\n\nThe generalized eigenvalues are returned in alpha and beta. The left Schur vectors are returned in vsl and the right Schur vectors are returned in vsr.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.trexc!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.trexc!",
    "category": "Function",
    "text": "trexc!(compq, ifst, ilst, T, Q) -> (T, Q)\n\nReorder the Schur factorization of a matrix. If compq = V, the Schur vectors Q are reordered. If compq = N they are not modified. ifst and ilst specify the reordering of the vectors.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.trsen!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.trsen!",
    "category": "Function",
    "text": "trsen!(compq, job, select, T, Q) -> (T, Q, w)\n\nReorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If job = N, no condition numbers are found. If job = E, only the condition number for this cluster of eigenvalues is found. If job = V, only the condition number for the invariant subspace is found. If job = B then the condition numbers for the cluster and subspace are found. If compq = V the Schur vectors Q are updated. If compq = N the Schur vectors are not modified. select determines which eigenvalues are in the cluster.\n\nReturns T, Q, and reordered eigenvalues in w.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.tgsen!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.tgsen!",
    "category": "Function",
    "text": "tgsen!(select, S, T, Q, Z) -> (S, T, alpha, beta, Q, Z)\n\nReorders the vectors of a generalized Schur decomposition. select specifices the eigenvalues in each cluster.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Base.LinAlg.LAPACK.trsyl!",
    "page": "Álgebra Lineal",
    "title": "Base.LinAlg.LAPACK.trsyl!",
    "category": "Function",
    "text": "trsyl!(transa, transb, A, B, C, isgn=1) -> (C, scale)\n\nSolves the Sylvester matrix equation A * X +/- X * B = scale*C where A and B are both quasi-upper triangular. If transa = N, A is not modified. If transa = T, A is transposed. If transa = C, A is conjugate transposed. Similarly for transb and B. If isgn = 1, the equation A * X + X * B = scale * C is solved. If isgn = -1, the equation A * X - X * B = scale * C is solved.\n\nReturns X (overwriting C) and scale.\n\n\n\n"
},

{
    "location": "stdlib/linalg.html#Funciones-LAPACK-1",
    "page": "Álgebra Lineal",
    "title": "Funciones LAPACK",
    "category": "section",
    "text": "Base.LinAlg.LAPACK proporciona wrappers para algunas de las funciones LAPACK para álgebra lineal. Las funciones que sobrescriben una de las matrices de entrada tienen nombres que terminan en '!'.Por lo general, una función tiene 4 métodos definidos, uno para los arrays Float64, Float32, Complex128 y Complex64.Tenga en cuenta que la API LAPACK proporcionada por Julia puede y va a cambiar en el futuro. Dado que esta API no está orientada al usuario, no existe el compromiso de admitir/desaprobar este conjunto específico de funciones en futuras versiones.Base.LinAlg.LAPACK.gbtrf!\nBase.LinAlg.LAPACK.gbtrs!\nBase.LinAlg.LAPACK.gebal!\nBase.LinAlg.LAPACK.gebak!\nBase.LinAlg.LAPACK.gebrd!\nBase.LinAlg.LAPACK.gelqf!\nBase.LinAlg.LAPACK.geqlf!\nBase.LinAlg.LAPACK.geqrf!\nBase.LinAlg.LAPACK.geqp3!\nBase.LinAlg.LAPACK.gerqf!\nBase.LinAlg.LAPACK.geqrt!\nBase.LinAlg.LAPACK.geqrt3!\nBase.LinAlg.LAPACK.getrf!\nBase.LinAlg.LAPACK.tzrzf!\nBase.LinAlg.LAPACK.ormrz!\nBase.LinAlg.LAPACK.gels!\nBase.LinAlg.LAPACK.gesv!\nBase.LinAlg.LAPACK.getrs!\nBase.LinAlg.LAPACK.getri!\nBase.LinAlg.LAPACK.gesvx!\nBase.LinAlg.LAPACK.gelsd!\nBase.LinAlg.LAPACK.gelsy!\nBase.LinAlg.LAPACK.gglse!\nBase.LinAlg.LAPACK.geev!\nBase.LinAlg.LAPACK.gesdd!\nBase.LinAlg.LAPACK.gesvd!\nBase.LinAlg.LAPACK.ggsvd!\nBase.LinAlg.LAPACK.ggsvd3!\nBase.LinAlg.LAPACK.geevx!\nBase.LinAlg.LAPACK.ggev!\nBase.LinAlg.LAPACK.gtsv!\nBase.LinAlg.LAPACK.gttrf!\nBase.LinAlg.LAPACK.gttrs!\nBase.LinAlg.LAPACK.orglq!\nBase.LinAlg.LAPACK.orgqr!\nBase.LinAlg.LAPACK.orgql!\nBase.LinAlg.LAPACK.orgrq!\nBase.LinAlg.LAPACK.ormlq!\nBase.LinAlg.LAPACK.ormqr!\nBase.LinAlg.LAPACK.ormql!\nBase.LinAlg.LAPACK.ormrq!\nBase.LinAlg.LAPACK.gemqrt!\nBase.LinAlg.LAPACK.posv!\nBase.LinAlg.LAPACK.potrf!\nBase.LinAlg.LAPACK.potri!\nBase.LinAlg.LAPACK.potrs!\nBase.LinAlg.LAPACK.pstrf!\nBase.LinAlg.LAPACK.ptsv!\nBase.LinAlg.LAPACK.pttrf!\nBase.LinAlg.LAPACK.pttrs!\nBase.LinAlg.LAPACK.trtri!\nBase.LinAlg.LAPACK.trtrs!\nBase.LinAlg.LAPACK.trcon!\nBase.LinAlg.LAPACK.trevc!\nBase.LinAlg.LAPACK.trrfs!\nBase.LinAlg.LAPACK.stev!\nBase.LinAlg.LAPACK.stebz!\nBase.LinAlg.LAPACK.stegr!\nBase.LinAlg.LAPACK.stein!\nBase.LinAlg.LAPACK.syconv!\nBase.LinAlg.LAPACK.sysv!\nBase.LinAlg.LAPACK.sytrf!\nBase.LinAlg.LAPACK.sytri!\nBase.LinAlg.LAPACK.sytrs!\nBase.LinAlg.LAPACK.hesv!\nBase.LinAlg.LAPACK.hetrf!\nBase.LinAlg.LAPACK.hetri!\nBase.LinAlg.LAPACK.hetrs!\nBase.LinAlg.LAPACK.syev!\nBase.LinAlg.LAPACK.syevr!\nBase.LinAlg.LAPACK.sygvd!\nBase.LinAlg.LAPACK.bdsqr!\nBase.LinAlg.LAPACK.bdsdc!\nBase.LinAlg.LAPACK.gecon!\nBase.LinAlg.LAPACK.gehrd!\nBase.LinAlg.LAPACK.orghr!\nBase.LinAlg.LAPACK.gees!\nBase.LinAlg.LAPACK.gges!\nBase.LinAlg.LAPACK.trexc!\nBase.LinAlg.LAPACK.trsen!\nBase.LinAlg.LAPACK.tgsen!\nBase.LinAlg.LAPACK.trsyl!"
},

{
    "location": "stdlib/constants.html#",
    "page": "Constantes",
    "title": "Constantes",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/constants.html#Core.nothing",
    "page": "Constantes",
    "title": "Core.nothing",
    "category": "Constant",
    "text": "nothing\n\nThe singleton instance of type Void, used by convention when there is no value to return (as in a C void function). Can be converted to an empty Nullable value.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.PROGRAM_FILE",
    "page": "Constantes",
    "title": "Base.PROGRAM_FILE",
    "category": "Constant",
    "text": "PROGRAM_FILE\n\nA string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see @__FILE__.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.ARGS",
    "page": "Constantes",
    "title": "Base.ARGS",
    "category": "Constant",
    "text": "ARGS\n\nAn array of the command line arguments passed to Julia, as strings.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.C_NULL",
    "page": "Constantes",
    "title": "Base.C_NULL",
    "category": "Constant",
    "text": "C_NULL\n\nThe C null pointer constant, sometimes used when calling external code.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.VERSION",
    "page": "Constantes",
    "title": "Base.VERSION",
    "category": "Constant",
    "text": "VERSION\n\nA VersionNumber object describing which version of Julia is in use. For details see Version Number Literals.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.LOAD_PATH",
    "page": "Constantes",
    "title": "Base.LOAD_PATH",
    "category": "Constant",
    "text": "LOAD_PATH\n\nAn array of paths as strings or custom loader objects for the require function and using and import statements to consider when loading code. To create a custom loader type, define the type and then add appropriate methods to the Base.load_hook function with the following signature:\n\nBase.load_hook(loader::Loader, name::String, found::Any)\n\nThe loader argument is the current value in LOAD_PATH, name is the name of the module to load, and found is the path of any previously found code to provide name. If no provider has been found earlier in LOAD_PATH then the value of found will be nothing. Custom loader functionality is experimental and may break or change in Julia 1.0.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.JULIA_HOME",
    "page": "Constantes",
    "title": "Base.JULIA_HOME",
    "category": "Constant",
    "text": "JULIA_HOME\n\nA string containing the full path to the directory containing the julia executable.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Core.ANY",
    "page": "Constantes",
    "title": "Core.ANY",
    "category": "Constant",
    "text": "ANY\n\nEquivalent to Any for dispatch purposes, but signals the compiler to skip code generation specialization for that field.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.Sys.CPU_CORES",
    "page": "Constantes",
    "title": "Base.Sys.CPU_CORES",
    "category": "Constant",
    "text": "Sys.CPU_CORES\n\nThe number of logical CPU cores available in the system.\n\nSee the Hwloc.jl package for extended information, including number of physical cores.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.Sys.WORD_SIZE",
    "page": "Constantes",
    "title": "Base.Sys.WORD_SIZE",
    "category": "Constant",
    "text": "Sys.WORD_SIZE\n\nStandard word size on the current machine, in bits.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.Sys.KERNEL",
    "page": "Constantes",
    "title": "Base.Sys.KERNEL",
    "category": "Constant",
    "text": "Sys.KERNEL\n\nA symbol representing the name of the operating system, as returned by uname of the build configuration.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.Sys.ARCH",
    "page": "Constantes",
    "title": "Base.Sys.ARCH",
    "category": "Constant",
    "text": "Sys.ARCH\n\nA symbol representing the architecture of the build configuration.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#Base.Sys.MACHINE",
    "page": "Constantes",
    "title": "Base.Sys.MACHINE",
    "category": "Constant",
    "text": "Sys.MACHINE\n\nA string containing the build triple.\n\n\n\n"
},

{
    "location": "stdlib/constants.html#lib-constants-1",
    "page": "Constantes",
    "title": "Constantes",
    "category": "section",
    "text": "Core.nothing\nBase.PROGRAM_FILE\nBase.ARGS\nBase.C_NULL\nBase.VERSION\nBase.LOAD_PATH\nBase.JULIA_HOME\nCore.ANY\nBase.Sys.CPU_CORES\nBase.Sys.WORD_SIZE\nBase.Sys.KERNEL\nBase.Sys.ARCH\nBase.Sys.MACHINEVer también:STDIN\nSTDOUT\nSTDERR\nENV\nENDIAN_BOM\nLibc.MS_ASYNC\nLibc.MS_INVALIDATE\nLibc.MS_SYNC\nLibdl.DL_LOAD_PATH\nLibdl.RTLD_DEEPBIND\nLibdl.RTLD_LOCAL\nLibdl.RTLD_NOLOAD\nLibdl.RTLD_LAZY\nLibdl.RTLD_NOW\nLibdl.RTLD_GLOBAL\nLibdl.RTLD_NODELETE\nLibdl.RTLD_FIRST"
},

{
    "location": "stdlib/file.html#",
    "page": "Sistema de Ficheros",
    "title": "Sistema de Ficheros",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/file.html#Base.Filesystem.pwd",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.pwd",
    "category": "Function",
    "text": "pwd() -> AbstractString\n\nGet the current working directory.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.cd-Tuple{AbstractString}",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.cd",
    "category": "Method",
    "text": "cd(dir::AbstractString=homedir())\n\nSet the current working directory.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.cd-Tuple{Function}",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.cd",
    "category": "Method",
    "text": "cd(f::Function, dir::AbstractString=homedir())\n\nTemporarily changes the current working directory and applies function f before returning.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.readdir",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.readdir",
    "category": "Function",
    "text": "readdir(dir::AbstractString=\".\") -> Vector{String}\n\nReturns the files and directories in the directory dir (or the current working directory if not given).\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.walkdir",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.walkdir",
    "category": "Function",
    "text": "walkdir(dir; topdown=true, follow_symlinks=false, onerror=throw)\n\nThe walkdir method returns an iterator that walks the directory tree of a directory. The iterator returns a tuple containing (rootpath, dirs, files). The directory tree can be traversed top-down or bottom-up. If walkdir encounters a SystemError it will rethrow the error by default. A custom error handling function can be provided through onerror keyword argument. onerror is called with a SystemError as argument.\n\nfor (root, dirs, files) in walkdir(\".\")\n    println(\"Directories in $root\")\n    for dir in dirs\n        println(joinpath(root, dir)) # path to directories\n    end\n    println(\"Files in $root\")\n    for file in files\n        println(joinpath(root, file)) # path to files\n    end\nend\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.mkdir",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.mkdir",
    "category": "Function",
    "text": "mkdir(path::AbstractString, mode::Unsigned=0o777)\n\nMake a new directory with name path and permissions mode. mode defaults to 0o777, modified by the current file creation mask. This function never creates more than one directory. If the directory already exists, or some intermediate directories do not exist, this function throws an error. See mkpath for a function which creates all required intermediate directories.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.mkpath",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.mkpath",
    "category": "Function",
    "text": "mkpath(path::AbstractString, mode::Unsigned=0o777)\n\nCreate all directories in the given path, with permissions mode. mode defaults to 0o777, modified by the current file creation mask.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.symlink",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.symlink",
    "category": "Function",
    "text": "symlink(target::AbstractString, link::AbstractString)\n\nCreates a symbolic link to target with the name link.\n\nnote: Note\nThis function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.readlink",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.readlink",
    "category": "Function",
    "text": "readlink(path::AbstractString) -> AbstractString\n\nReturns the target location a symbolic link path points to.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.chmod",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.chmod",
    "category": "Function",
    "text": "chmod(path::AbstractString, mode::Integer; recursive::Bool=false)\n\nChange the permissions mode of path to mode. Only integer modes (e.g. 0o777) are currently supported. If recursive=true and the path is a directory all permissions in that directory will be recursively changed.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.chown",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.chown",
    "category": "Function",
    "text": "chown(path::AbstractString, owner::Integer, group::Integer=-1)\n\nChange the owner and/or group of path to owner and/or group. If the value entered for owner or group is -1 the corresponding ID will not change. Only integer owners and groups are currently supported.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.stat",
    "page": "Sistema de Ficheros",
    "title": "Base.stat",
    "category": "Function",
    "text": "stat(file)\n\nReturns a structure whose fields contain information about the file. The fields of the structure are:\n\nName Description\nsize The size (in bytes) of the file\ndevice ID of the device that contains the file\ninode The inode number of the file\nmode The protection mode of the file\nnlink The number of hard links to the file\nuid The user id of the owner of the file\ngid The group id of the file owner\nrdev If this file refers to a device, the ID of the device it refers to\nblksize The file-system preferred block size for the file\nblocks The number of such blocks allocated\nmtime Unix timestamp of when the file was last modified\nctime Unix timestamp of when the file was created\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.lstat",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.lstat",
    "category": "Function",
    "text": "lstat(file)\n\nLike stat, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.ctime",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.ctime",
    "category": "Function",
    "text": "ctime(file)\n\nEquivalent to stat(file).ctime\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.mtime",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.mtime",
    "category": "Function",
    "text": "mtime(file)\n\nEquivalent to stat(file).mtime.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.filemode",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.filemode",
    "category": "Function",
    "text": "filemode(file)\n\nEquivalent to stat(file).mode\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.filesize",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.filesize",
    "category": "Function",
    "text": "filesize(path...)\n\nEquivalent to stat(file).size.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.uperm",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.uperm",
    "category": "Function",
    "text": "uperm(file)\n\nGets the permissions of the owner of the file as a bitfield of\n\nValue Description\n01 Execute Permission\n02 Write Permission\n04 Read Permission\n\nFor allowed arguments, see stat.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.gperm",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.gperm",
    "category": "Function",
    "text": "gperm(file)\n\nLike uperm but gets the permissions of the group owning the file.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.operm",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.operm",
    "category": "Function",
    "text": "operm(file)\n\nLike uperm but gets the permissions for people who neither own the file nor are a member of the group owning the file\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.cp",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.cp",
    "category": "Function",
    "text": "cp(src::AbstractString, dst::AbstractString; remove_destination::Bool=false, follow_symlinks::Bool=false)\n\nCopy the file, link, or directory from src to dest. remove_destination=true will first remove an existing dst.\n\nIf follow_symlinks=false, and src is a symbolic link, dst will be created as a symbolic link. If follow_symlinks=true and src is a symbolic link, dst will be a copy of the file or directory src refers to.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.download",
    "page": "Sistema de Ficheros",
    "title": "Base.download",
    "category": "Function",
    "text": "download(url::AbstractString, [localfile::AbstractString])\n\nDownload a file from the given url, optionally renaming it to the given local file name. Note that this function relies on the availability of external tools such as curl, wget or fetch to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.mv",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.mv",
    "category": "Function",
    "text": "mv(src::AbstractString, dst::AbstractString; remove_destination::Bool=false)\n\nMove the file, link, or directory from src to dst. remove_destination=true will first remove an existing dst.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.rm",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.rm",
    "category": "Function",
    "text": "rm(path::AbstractString; force::Bool=false, recursive::Bool=false)\n\nDelete the file, link, or empty directory at the given path. If force=true is passed, a non-existing path is not treated as error. If recursive=true is passed and the path is a directory, then all contents are removed recursively.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.touch",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.touch",
    "category": "Function",
    "text": "touch(path::AbstractString)\n\nUpdate the last-modified timestamp on a file to the current time.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.tempname",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.tempname",
    "category": "Function",
    "text": "tempname()\n\nGenerate a unique temporary file path.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.tempdir",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.tempdir",
    "category": "Function",
    "text": "tempdir()\n\nObtain the path of a temporary directory (possibly shared with other processes).\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.mktemp-Tuple{Any}",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.mktemp",
    "category": "Method",
    "text": "mktemp(parent=tempdir())\n\nReturns (path, io), where path is the path of a new temporary file in parent and io is an open file object for this path.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.mktemp-Tuple{Function,Any}",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.mktemp",
    "category": "Method",
    "text": "mktemp(f::Function, parent=tempdir())\n\nApply the function f to the result of mktemp(parent) and remove the temporary file upon completion.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.mktempdir-Tuple{Any}",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.mktempdir",
    "category": "Method",
    "text": "mktempdir(parent=tempdir())\n\nCreate a temporary directory in the parent directory and return its path. If parent does not exist, throw an error.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.mktempdir-Tuple{Function,Any}",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.mktempdir",
    "category": "Method",
    "text": "mktempdir(f::Function, parent=tempdir())\n\nApply the function f to the result of mktempdir(parent) and remove the temporary directory upon completion.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.isblockdev",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.isblockdev",
    "category": "Function",
    "text": "isblockdev(path) -> Bool\n\nReturns true if path is a block device, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.ischardev",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.ischardev",
    "category": "Function",
    "text": "ischardev(path) -> Bool\n\nReturns true if path is a character device, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.isdir",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.isdir",
    "category": "Function",
    "text": "isdir(path) -> Bool\n\nReturns true if path is a directory, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.isfifo",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.isfifo",
    "category": "Function",
    "text": "isfifo(path) -> Bool\n\nReturns true if path is a FIFO, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.isfile",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.isfile",
    "category": "Function",
    "text": "isfile(path) -> Bool\n\nReturns true if path is a regular file, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.islink",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.islink",
    "category": "Function",
    "text": "islink(path) -> Bool\n\nReturns true if path is a symbolic link, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.ismount",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.ismount",
    "category": "Function",
    "text": "ismount(path) -> Bool\n\nReturns true if path is a mount point, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.ispath",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.ispath",
    "category": "Function",
    "text": "ispath(path) -> Bool\n\nReturns true if path is a valid filesystem path, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.issetgid",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.issetgid",
    "category": "Function",
    "text": "issetgid(path) -> Bool\n\nReturns true if path has the setgid flag set, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.issetuid",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.issetuid",
    "category": "Function",
    "text": "issetuid(path) -> Bool\n\nReturns true if path has the setuid flag set, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.issocket",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.issocket",
    "category": "Function",
    "text": "issocket(path) -> Bool\n\nReturns true if path is a socket, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.issticky",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.issticky",
    "category": "Function",
    "text": "issticky(path) -> Bool\n\nReturns true if path has the sticky bit set, false otherwise.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.homedir",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.homedir",
    "category": "Function",
    "text": "homedir() -> AbstractString\n\nReturn the current user's home directory.\n\nnote: Note\nhomedir determines the home directory via libuv's uv_os_homedir. For details (for example on how to specify the home directory via environment variables), see the uv_os_homedir documentation.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.dirname",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.dirname",
    "category": "Function",
    "text": "dirname(path::AbstractString) -> AbstractString\n\nGet the directory part of a path.\n\njulia> dirname(\"/home/myuser\")\n\"/home\"\n\nSee also: basename\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.basename",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.basename",
    "category": "Function",
    "text": "basename(path::AbstractString) -> AbstractString\n\nGet the file name part of a path.\n\njulia> basename(\"/home/myuser/example.jl\")\n\"example.jl\"\n\nSee also: dirname\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.@__FILE__",
    "page": "Sistema de Ficheros",
    "title": "Base.@__FILE__",
    "category": "Macro",
    "text": "@__FILE__ -> AbstractString\n\n@__FILE__ expands to a string with the absolute file path of the file containing the macro. Returns nothing if run from a REPL or an empty string if evaluated by julia -e <expr>. Alternatively see PROGRAM_FILE.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.@__DIR__",
    "page": "Sistema de Ficheros",
    "title": "Base.@__DIR__",
    "category": "Macro",
    "text": "@__DIR__ -> AbstractString\n\n@__DIR__ expands to a string with the directory part of the absolute path of the file containing the macro. Returns nothing if run from a REPL or an empty string if evaluated by julia -e <expr>.\n\n\n\n"
},

{
    "location": "stdlib/file.html#@__LINE__",
    "page": "Sistema de Ficheros",
    "title": "@__LINE__",
    "category": "Macro",
    "text": "@__LINE__ -> Int\n\n@__LINE__ expands to the line number of the call-site.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.isabspath",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.isabspath",
    "category": "Function",
    "text": "isabspath(path::AbstractString) -> Bool\n\nDetermines whether a path is absolute (begins at the root directory).\n\njulia> isabspath(\"/home\")\ntrue\n\njulia> isabspath(\"home\")\nfalse\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.isdirpath",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.isdirpath",
    "category": "Function",
    "text": "isdirpath(path::AbstractString) -> Bool\n\nDetermines whether a path refers to a directory (for example, ends with a path separator).\n\njulia> isdirpath(\"/home\")\nfalse\n\njulia> isdirpath(\"/home/\")\ntrue\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.joinpath",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.joinpath",
    "category": "Function",
    "text": "joinpath(parts...) -> AbstractString\n\nJoin path components into a full path. If some argument is an absolute path, then prior components are dropped.\n\njulia> joinpath(\"/home/myuser\",\"example.jl\")\n\"/home/myuser/example.jl\"\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.abspath",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.abspath",
    "category": "Function",
    "text": "abspath(path::AbstractString) -> AbstractString\n\nConvert a path to an absolute path by adding the current directory if necessary.\n\n\n\nabspath(path::AbstractString, paths::AbstractString...) -> AbstractString\n\nConvert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to abspath(joinpath(path, paths...)).\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.normpath",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.normpath",
    "category": "Function",
    "text": "normpath(path::AbstractString) -> AbstractString\n\nNormalize a path, removing \".\" and \"..\" entries.\n\njulia> normpath(\"/home/myuser/../example.jl\")\n\"/home/example.jl\"\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.realpath",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.realpath",
    "category": "Function",
    "text": "realpath(path::AbstractString) -> AbstractString\n\nCanonicalize a path by expanding symbolic links and removing \".\" and \"..\" entries.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.relpath",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.relpath",
    "category": "Function",
    "text": "relpath(path::AbstractString, startpath::AbstractString = \".\") -> AbstractString\n\nReturn a relative filepath to path either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of path or startpath.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.expanduser",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.expanduser",
    "category": "Function",
    "text": "expanduser(path::AbstractString) -> AbstractString\n\nOn Unix systems, replace a tilde character at the start of a path with the current user's home directory.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.splitdir",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.splitdir",
    "category": "Function",
    "text": "splitdir(path::AbstractString) -> (AbstractString, AbstractString)\n\nSplit a path into a tuple of the directory name and file name.\n\njulia> splitdir(\"/home/myuser\")\n(\"/home\", \"myuser\")\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.splitdrive",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.splitdrive",
    "category": "Function",
    "text": "splitdrive(path::AbstractString) -> (AbstractString, AbstractString)\n\nOn Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.\n\n\n\n"
},

{
    "location": "stdlib/file.html#Base.Filesystem.splitext",
    "page": "Sistema de Ficheros",
    "title": "Base.Filesystem.splitext",
    "category": "Function",
    "text": "splitext(path::AbstractString) -> (AbstractString, AbstractString)\n\nIf the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.\n\njulia> splitext(\"/home/myuser/example.jl\")\n(\"/home/myuser/example\", \".jl\")\n\njulia> splitext(\"/home/myuser/example\")\n(\"/home/myuser/example\", \"\")\n\n\n\n"
},

{
    "location": "stdlib/file.html#filesystem-1",
    "page": "Sistema de Ficheros",
    "title": "Sistema de Ficheros",
    "category": "section",
    "text": "Base.Filesystem.pwd\nBase.Filesystem.cd(::AbstractString)\nBase.Filesystem.cd(::Function)\nBase.Filesystem.readdir\nBase.Filesystem.walkdir\nBase.Filesystem.mkdir\nBase.Filesystem.mkpath\nBase.Filesystem.symlink\nBase.Filesystem.readlink\nBase.Filesystem.chmod\nBase.Filesystem.chown\nBase.stat\nBase.Filesystem.lstat\nBase.Filesystem.ctime\nBase.Filesystem.mtime\nBase.Filesystem.filemode\nBase.Filesystem.filesize\nBase.Filesystem.uperm\nBase.Filesystem.gperm\nBase.Filesystem.operm\nBase.Filesystem.cp\nBase.download\nBase.Filesystem.mv\nBase.Filesystem.rm\nBase.Filesystem.touch\nBase.Filesystem.tempname\nBase.Filesystem.tempdir\nBase.Filesystem.mktemp(::Any)\nBase.Filesystem.mktemp(::Function, ::Any)\nBase.Filesystem.mktempdir(::Any)\nBase.Filesystem.mktempdir(::Function, ::Any)\nBase.Filesystem.isblockdev\nBase.Filesystem.ischardev\nBase.Filesystem.isdir\nBase.Filesystem.isfifo\nBase.Filesystem.isfile\nBase.Filesystem.islink\nBase.Filesystem.ismount\nBase.Filesystem.ispath\nBase.Filesystem.issetgid\nBase.Filesystem.issetuid\nBase.Filesystem.issocket\nBase.Filesystem.issticky\nBase.Filesystem.homedir\nBase.Filesystem.dirname\nBase.Filesystem.basename\nBase.@__FILE__\nBase.@__DIR__\n@__LINE__\nBase.Filesystem.isabspath\nBase.Filesystem.isdirpath\nBase.Filesystem.joinpath\nBase.Filesystem.abspath\nBase.Filesystem.normpath\nBase.Filesystem.realpath\nBase.Filesystem.relpath\nBase.Filesystem.expanduser\nBase.Filesystem.splitdir\nBase.Filesystem.splitdrive\nBase.Filesystem.splitext"
},

{
    "location": "stdlib/io-network.html#",
    "page": "E/S y Redes",
    "title": "E/S y Redes",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/io-network.html#io-network-1",
    "page": "E/S y Redes",
    "title": "E/S y Redes",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/io-network.html#Base.STDOUT",
    "page": "E/S y Redes",
    "title": "Base.STDOUT",
    "category": "Constant",
    "text": "STDOUT\n\nGlobal variable referring to the standard out stream.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.STDERR",
    "page": "E/S y Redes",
    "title": "Base.STDERR",
    "category": "Constant",
    "text": "STDERR\n\nGlobal variable referring to the standard error stream.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.STDIN",
    "page": "E/S y Redes",
    "title": "Base.STDIN",
    "category": "Constant",
    "text": "STDIN\n\nGlobal variable referring to the standard input stream.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.open",
    "page": "E/S y Redes",
    "title": "Base.open",
    "category": "Function",
    "text": "open(filename::AbstractString, [read::Bool, write::Bool, create::Bool, truncate::Bool, append::Bool]) -> IOStream\n\nOpen a file in a mode specified by five boolean arguments. The default is to open files for reading only. Returns a stream for accessing the file.\n\n\n\nopen(filename::AbstractString, [mode::AbstractString]) -> IOStream\n\nAlternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of mode correspond to those from fopen(3) or Perl open, and are equivalent to setting the following boolean groups:\n\nMode Description\nr read\nr+ read, write\nw write, create, truncate\nw+ read, write, create, truncate\na write, create, append\na+ read, write, create, append\n\n\n\nopen(f::Function, args...)\n\nApply the function f to the result of open(args...) and close the resulting file descriptor upon completion.\n\nExample: open(readstring, \"file.txt\")\n\n\n\nopen(command, mode::AbstractString=\"r\", stdio=DevNull)\n\nStart running command asynchronously, and return a tuple (stream,process).  If mode is \"r\", then stream reads from the process's standard output and stdio optionally specifies the process's standard input stream.  If mode is \"w\", then stream writes to the process's standard input and stdio optionally specifies the process's standard output stream.\n\n\n\nopen(f::Function, command, mode::AbstractString=\"r\", stdio=DevNull)\n\nSimilar to open(command, mode, stdio), but calls f(stream) on the resulting read or write stream, then closes the stream and waits for the process to complete.  Returns the value returned by f.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.IOBuffer",
    "page": "E/S y Redes",
    "title": "Base.IOBuffer",
    "category": "Type",
    "text": "IOBuffer([data,],[readable::Bool=true, writable::Bool=true, [maxsize::Int=typemax(Int)]])\n\nCreate an IOBuffer, which may optionally operate on a pre-existing array. If the readable/writable arguments are given, they restrict whether or not the buffer may be read from or written to respectively. The last argument optionally specifies a size beyond which the buffer may not be grown.\n\n\n\nIOBuffer() -> IOBuffer\n\nCreate an in-memory I/O stream.\n\n\n\nIOBuffer(size::Int)\n\nCreate a fixed size IOBuffer. The buffer will not grow dynamically.\n\n\n\nIOBuffer(string::String)\n\nCreate a read-only IOBuffer on the data underlying the given string.\n\njulia> io = IOBuffer(\"Haho\");\n\njulia> String(take!(io))\n\"Haho\"\n\njulia> String(take!(io))\n\"Haho\"\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.take!-Tuple{Base.AbstractIOBuffer}",
    "page": "E/S y Redes",
    "title": "Base.take!",
    "category": "Method",
    "text": "take!(b::IOBuffer)\n\nObtain the contents of an IOBuffer as an array, without copying. Afterwards, the IOBuffer is reset to its initial state.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.fdio",
    "page": "E/S y Redes",
    "title": "Base.fdio",
    "category": "Function",
    "text": "fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -> IOStream\n\nCreate an IOStream object from an integer file descriptor. If own is true, closing this object will close the underlying descriptor. By default, an IOStream is closed when it is garbage collected. name allows you to associate the descriptor with a named file.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.flush",
    "page": "E/S y Redes",
    "title": "Base.flush",
    "category": "Function",
    "text": "flush(stream)\n\nCommit all currently buffered writes to the given stream.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.close",
    "page": "E/S y Redes",
    "title": "Base.close",
    "category": "Function",
    "text": "close(stream)\n\nClose an I/O stream. Performs a flush first.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.write",
    "page": "E/S y Redes",
    "title": "Base.write",
    "category": "Function",
    "text": "write(stream::IO, x)\nwrite(filename::AbstractString, x)\n\nWrite the canonical binary representation of a value to the given I/O stream or file. Returns the number of bytes written into the stream.\n\nYou can write multiple values with the same write call. i.e. the following are equivalent:\n\nwrite(stream, x, y...)\nwrite(stream, x) + write(stream, y...)\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.read",
    "page": "E/S y Redes",
    "title": "Base.read",
    "category": "Function",
    "text": "read(filename::AbstractString, args...)\n\nOpen a file and read its contents. args is passed to read: this is equivalent to open(io->read(io, args...), filename).\n\n\n\nread(stream::IO, T, dims)\n\nRead a series of values of type T from stream, in canonical binary representation. dims is either a tuple or a series of integer arguments specifying the size of the Array{T} to return.\n\n\n\nread(s::IO, nb=typemax(Int))\n\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\n\n\n\nread(s::IOStream, nb::Integer; all=true)\n\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\n\nIf all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.\n\n\n\nread(stream::IO, T)\n\nRead a single value of type T from stream, in canonical binary representation.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.read!",
    "page": "E/S y Redes",
    "title": "Base.read!",
    "category": "Function",
    "text": "read!(stream::IO, array::Union{Array, BitArray})\nread!(filename::AbstractString, array::Union{Array, BitArray})\n\nRead binary data from an I/O stream or file, filling in array.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.readbytes!",
    "page": "E/S y Redes",
    "title": "Base.readbytes!",
    "category": "Function",
    "text": "readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))\n\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\n\n\n\nreadbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)\n\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\n\nSee read for a description of the all option.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.unsafe_read",
    "page": "E/S y Redes",
    "title": "Base.unsafe_read",
    "category": "Function",
    "text": "unsafe_read(io::IO, ref, nbytes::UInt)\n\nCopy nbytes from the IO stream object into ref (converted to a pointer).\n\nIt is recommended that subtypes T<:IO override the following method signature to provide more efficient implementations: unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.unsafe_write",
    "page": "E/S y Redes",
    "title": "Base.unsafe_write",
    "category": "Function",
    "text": "unsafe_write(io::IO, ref, nbytes::UInt)\n\nCopy nbytes from ref (converted to a pointer) into the IO object.\n\nIt is recommended that subtypes T<:IO override the following method signature to provide more efficient implementations: unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.position",
    "page": "E/S y Redes",
    "title": "Base.position",
    "category": "Function",
    "text": "position(s)\n\nGet the current position of a stream.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.seek",
    "page": "E/S y Redes",
    "title": "Base.seek",
    "category": "Function",
    "text": "seek(s, pos)\n\nSeek a stream to the given position.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.seekstart",
    "page": "E/S y Redes",
    "title": "Base.seekstart",
    "category": "Function",
    "text": "seekstart(s)\n\nSeek a stream to its beginning.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.seekend",
    "page": "E/S y Redes",
    "title": "Base.seekend",
    "category": "Function",
    "text": "seekend(s)\n\nSeek a stream to its end.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.skip",
    "page": "E/S y Redes",
    "title": "Base.skip",
    "category": "Function",
    "text": "skip(s, offset)\n\nSeek a stream relative to the current position.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.mark",
    "page": "E/S y Redes",
    "title": "Base.mark",
    "category": "Function",
    "text": "mark(s)\n\nAdd a mark at the current position of stream s. Returns the marked position.\n\nSee also unmark, reset, ismarked.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.unmark",
    "page": "E/S y Redes",
    "title": "Base.unmark",
    "category": "Function",
    "text": "unmark(s)\n\nRemove a mark from stream s. Returns true if the stream was marked, false otherwise.\n\nSee also mark, reset, ismarked.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.reset",
    "page": "E/S y Redes",
    "title": "Base.reset",
    "category": "Function",
    "text": "reset(s)\n\nReset a stream s to a previously marked position, and remove the mark. Returns the previously marked position. Throws an error if the stream is not marked.\n\nSee also mark, unmark, ismarked.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.ismarked",
    "page": "E/S y Redes",
    "title": "Base.ismarked",
    "category": "Function",
    "text": "ismarked(s)\n\nReturns true if stream s is marked.\n\nSee also mark, unmark, reset.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.eof",
    "page": "E/S y Redes",
    "title": "Base.eof",
    "category": "Function",
    "text": "eof(stream) -> Bool\n\nTests whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.isreadonly",
    "page": "E/S y Redes",
    "title": "Base.isreadonly",
    "category": "Function",
    "text": "isreadonly(stream) -> Bool\n\nDetermine whether a stream is read-only.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.iswritable",
    "page": "E/S y Redes",
    "title": "Base.iswritable",
    "category": "Function",
    "text": "iswritable(io) -> Bool\n\nReturns true if the specified IO object is writable (if that can be determined).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.isreadable",
    "page": "E/S y Redes",
    "title": "Base.isreadable",
    "category": "Function",
    "text": "isreadable(io) -> Bool\n\nReturns true if the specified IO object is readable (if that can be determined).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.isopen",
    "page": "E/S y Redes",
    "title": "Base.isopen",
    "category": "Function",
    "text": "isopen(object) -> Bool\n\nDetermine whether an object - such as a stream, timer, or mmap – is not yet closed. Once an object is closed, it will never produce a new event. However, a closed stream may still have data to read in its buffer, use eof to check for the ability to read data. Use poll_fd to be notified when a stream might be writable or readable.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Serializer.serialize",
    "page": "E/S y Redes",
    "title": "Base.Serializer.serialize",
    "category": "Function",
    "text": "serialize(stream, value)\n\nWrite an arbitrary value to a stream in an opaque format, such that it can be read back by deserialize. The read-back value will be as identical as possible to the original. In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. Ptr values are serialized as all-zero bit patterns (NULL).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Serializer.deserialize",
    "page": "E/S y Redes",
    "title": "Base.Serializer.deserialize",
    "category": "Function",
    "text": "deserialize(stream)\n\nRead a value written by serialize. deserialize assumes the binary data read from stream is correct and has been serialized by a compatible implementation of serialize. It has been designed with simplicity and performance as a goal and does not validate the data read. Malformed data can result in process termination. The caller has to ensure the integrity and correctness of data read from stream.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Grisu.print_shortest",
    "page": "E/S y Redes",
    "title": "Base.Grisu.print_shortest",
    "category": "Function",
    "text": "print_shortest(io, x)\n\nPrint the shortest possible representation, with the minimum number of consecutive non-zero digits, of number x, ensuring that it would parse to the exact same number.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.fd",
    "page": "E/S y Redes",
    "title": "Base.fd",
    "category": "Function",
    "text": "fd(stream)\n\nReturns the file descriptor backing the stream or file. Note that this function only applies to synchronous File's and IOStream's not to any of the asynchronous streams.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.redirect_stdout",
    "page": "E/S y Redes",
    "title": "Base.redirect_stdout",
    "category": "Function",
    "text": "redirect_stdout([stream]) -> (rd, wr)\n\nCreate a pipe to which all C and Julia level STDOUT output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to STDOUT may now be read from the rd end of the pipe. The wr end is given for convenience in case the old STDOUT object was cached by the user and needs to be replaced elsewhere.\n\nnote: Note\nstream must be a TTY, a Pipe, or a TCPSocket.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.redirect_stdout-Tuple{Function,Any}",
    "page": "E/S y Redes",
    "title": "Base.redirect_stdout",
    "category": "Method",
    "text": "redirect_stdout(f::Function, stream)\n\nRun the function f while redirecting STDOUT to stream. Upon completion, STDOUT is restored to its prior setting.\n\nnote: Note\nstream must be a TTY, a Pipe, or a TCPSocket.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.redirect_stderr",
    "page": "E/S y Redes",
    "title": "Base.redirect_stderr",
    "category": "Function",
    "text": "redirect_stderr([stream]) -> (rd, wr)\n\nLike redirect_stdout, but for STDERR.\n\nnote: Note\nstream must be a TTY, a Pipe, or a TCPSocket.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.redirect_stderr-Tuple{Function,Any}",
    "page": "E/S y Redes",
    "title": "Base.redirect_stderr",
    "category": "Method",
    "text": "redirect_stderr(f::Function, stream)\n\nRun the function f while redirecting STDERR to stream. Upon completion, STDERR is restored to its prior setting.\n\nnote: Note\nstream must be a TTY, a Pipe, or a TCPSocket.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.redirect_stdin",
    "page": "E/S y Redes",
    "title": "Base.redirect_stdin",
    "category": "Function",
    "text": "redirect_stdin([stream]) -> (rd, wr)\n\nLike redirect_stdout, but for STDIN. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from STDIN may be written to wr.\n\nnote: Note\nstream must be a TTY, a Pipe, or a TCPSocket.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.redirect_stdin-Tuple{Function,Any}",
    "page": "E/S y Redes",
    "title": "Base.redirect_stdin",
    "category": "Method",
    "text": "redirect_stdin(f::Function, stream)\n\nRun the function f while redirecting STDIN to stream. Upon completion, STDIN is restored to its prior setting.\n\nnote: Note\nstream must be a TTY, a Pipe, or a TCPSocket.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.readchomp",
    "page": "E/S y Redes",
    "title": "Base.readchomp",
    "category": "Function",
    "text": "readchomp(x)\n\nRead the entirety of x as a string and remove a single trailing newline. Equivalent to chomp!(readstring(x)).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.truncate",
    "page": "E/S y Redes",
    "title": "Base.truncate",
    "category": "Function",
    "text": "truncate(file,n)\n\nResize the file or buffer given by the first argument to exactly n bytes, filling previously unallocated space with '\\0' if the file or buffer is grown.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.skipchars",
    "page": "E/S y Redes",
    "title": "Base.skipchars",
    "category": "Function",
    "text": "skipchars(stream, predicate; linecomment::Char)\n\nAdvance the stream until before the first character for which predicate returns false. For example skipchars(stream, isspace) will skip all whitespace. If keyword argument linecomment is specified, characters from that character through the end of a line will also be skipped.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.countlines",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.countlines",
    "category": "Function",
    "text": "countlines(io::IO, eol::Char='\\n')\n\nRead io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\\n' are supported by passing them as the second argument.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.PipeBuffer",
    "page": "E/S y Redes",
    "title": "Base.PipeBuffer",
    "category": "Function",
    "text": "PipeBuffer(data::Vector{UInt8}=UInt8[],[maxsize::Int=typemax(Int)])\n\nAn IOBuffer that allows reading and performs writes by appending. Seeking and truncating are not supported. See IOBuffer for the available constructors. If data is given, creates a PipeBuffer to operate on a data vector, optionally specifying a size beyond which the underlying Array may not be grown.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.readavailable",
    "page": "E/S y Redes",
    "title": "Base.readavailable",
    "category": "Function",
    "text": "readavailable(stream)\n\nRead all available data on the stream, blocking the task only if no data is available. The result is a Vector{UInt8,1}.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.IOContext",
    "page": "E/S y Redes",
    "title": "Base.IOContext",
    "category": "Type",
    "text": "IOContext\n\nIOContext provides a mechanism for passing output configuration settings among show methods.\n\nIn short, it is an immutable dictionary that is a subclass of IO. It supports standard dictionary operations such as getindex, and can also be used as an I/O stream.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.IOContext-Tuple{IO,Pair}",
    "page": "E/S y Redes",
    "title": "Base.IOContext",
    "category": "Method",
    "text": "IOContext(io::IO, KV::Pair)\n\nCreate an IOContext that wraps a given stream, adding the specified key=>value pair to the properties of that stream (note that io can itself be an IOContext).\n\nuse (key => value) in dict to see if this particular combination is in the properties set\nuse get(dict, key, default) to retrieve the most recent value for a particular key\n\nThe following properties are in common use:\n\n:compact: Boolean specifying that small values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements.\n:limit: Boolean specifying that containers should be truncated, e.g. showing … in place of most elements.\n:displaysize: A Tuple{Int,Int} giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the displaysize function.\n\njulia> function f(io::IO)\n           if get(io, :short, false)\n               print(io, \"short\")\n           else\n               print(io, \"loooooong\")\n           end\n       end\nf (generic function with 1 method)\n\njulia> f(STDOUT)\nloooooong\njulia> f(IOContext(STDOUT, :short => true))\nshort\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.IOContext-Tuple{IO,IOContext}",
    "page": "E/S y Redes",
    "title": "Base.IOContext",
    "category": "Method",
    "text": "IOContext(io::IO, context::IOContext)\n\nCreate an IOContext that wraps an alternate IO but inherits the properties of context.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#E/S-General-1",
    "page": "E/S y Redes",
    "title": "E/S General",
    "category": "section",
    "text": "Base.STDOUT\nBase.STDERR\nBase.STDIN\nBase.open\nBase.IOBuffer\nBase.take!(::Base.AbstractIOBuffer)\nBase.fdio\nBase.flush\nBase.close\nBase.write\nBase.read\nBase.read!\nBase.readbytes!\nBase.unsafe_read\nBase.unsafe_write\nBase.position\nBase.seek\nBase.seekstart\nBase.seekend\nBase.skip\nBase.mark\nBase.unmark\nBase.reset\nBase.ismarked\nBase.eof\nBase.isreadonly\nBase.iswritable\nBase.isreadable\nBase.isopen\nBase.Serializer.serialize\nBase.Serializer.deserialize\nBase.Grisu.print_shortest\nBase.fd\nBase.redirect_stdout\nBase.redirect_stdout(::Function, ::Any)\nBase.redirect_stderr\nBase.redirect_stderr(::Function, ::Any)\nBase.redirect_stdin\nBase.redirect_stdin(::Function, ::Any)\nBase.readchomp\nBase.truncate\nBase.skipchars\nBase.DataFmt.countlines\nBase.PipeBuffer\nBase.readavailable\nBase.IOContext\nBase.IOContext(::IO, ::Pair)\nBase.IOContext(::IO, ::IOContext)"
},

{
    "location": "stdlib/io-network.html#Base.show-Tuple{Any}",
    "page": "E/S y Redes",
    "title": "Base.show",
    "category": "Method",
    "text": "show(x)\n\nWrite an informative text representation of a value to the current output stream. New types should overload show(io, x) where the first argument is a stream. The representation used by show generally includes Julia-specific formatting and type information.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.showcompact",
    "page": "E/S y Redes",
    "title": "Base.showcompact",
    "category": "Function",
    "text": "showcompact(x)\n\nShow a compact representation of a value.\n\nThis is used for printing array elements without repeating type information (which would be redundant with that printed once for the whole array), and without line breaks inside the representation of an element.\n\nTo offer a compact representation different from its standard one, a custom type should test get(io, :compact, false) in its normal show method.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.showall",
    "page": "E/S y Redes",
    "title": "Base.showall",
    "category": "Function",
    "text": "showall(x)\n\nSimilar to show, except shows all elements of arrays.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.summary",
    "page": "E/S y Redes",
    "title": "Base.summary",
    "category": "Function",
    "text": "summary(x)\n\nReturn a string giving a brief description of a value. By default returns string(typeof(x)), e.g. Int64.\n\nFor arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}.\n\njulia> summary(1)\n\"Int64\"\n\njulia> summary(zeros(2))\n\"2-element Array{Float64,1}\"\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.print",
    "page": "E/S y Redes",
    "title": "Base.print",
    "category": "Function",
    "text": "print(io::IO, x)\n\nWrite to io (or to the default output stream STDOUT if io is not given) a canonical (un-decorated) text representation of a value if there is one, otherwise call show. The representation used by print includes minimal formatting and tries to avoid Julia-specific details.\n\njulia> print(\"Hello World!\")\nHello World!\njulia> io = IOBuffer();\n\njulia> print(io, \"Hello World!\")\n\njulia> String(take!(io))\n\"Hello World!\"\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.println",
    "page": "E/S y Redes",
    "title": "Base.println",
    "category": "Function",
    "text": "println(io::IO, xs...)\n\nPrint (using print) xs followed by a newline. If io is not supplied, prints to STDOUT.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.print_with_color",
    "page": "E/S y Redes",
    "title": "Base.print_with_color",
    "category": "Function",
    "text": "print_with_color(color::Union{Symbol, Int}, [io], xs...; bold::Bool = false)\n\nPrint xs in a color specified as a symbol.\n\ncolor may take any of the values :normal, :default, :bold, :black, :blue, :cyan, :green, :light_black, :light_blue, :light_cyan, :light_green, :light_magenta, :light_red, :light_yellow, :magenta, :nothing, :red, :white, or  :yellow or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword bold is given as true, the result will be printed in bold.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.info",
    "page": "E/S y Redes",
    "title": "Base.info",
    "category": "Function",
    "text": "info([io, ] msg..., [prefix=\"INFO: \"])\n\nDisplay an informational message. Argument msg is a string describing the information to be displayed. The prefix keyword argument can be used to override the default prepending of msg.\n\njulia> info(\"hello world\")\nINFO: hello world\n\njulia> info(\"hello world\"; prefix=\"MY INFO: \")\nMY INFO: hello world\n\nSee also logging.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.warn",
    "page": "E/S y Redes",
    "title": "Base.warn",
    "category": "Function",
    "text": "warn([io, ] msg..., [prefix=\"WARNING: \", once=false, key=nothing, bt=nothing, filename=nothing, lineno::Int=0])\n\nDisplay a warning. Argument msg is a string describing the warning to be displayed.  Set once to true and specify a key to only display msg the first time warn is called.  If bt is not nothing a backtrace is displayed. If filename is not nothing both it and lineno are displayed.\n\nSee also logging.\n\n\n\nwarn(msg)\n\nDisplay a warning. Argument msg is a string describing the warning to be displayed.\n\njulia> warn(\"Beep Beep\")\nWARNING: Beep Beep\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.logging",
    "page": "E/S y Redes",
    "title": "Base.logging",
    "category": "Function",
    "text": "logging(io [, m [, f]][; kind=:all])\nlogging([; kind=:all])\n\nStream output of informational, warning, and/or error messages to io, overriding what was otherwise specified.  Optionally, divert stream only for module m, or specifically function f within m.  kind can be :all (the default), :info, :warn, or :error.  See Base.log_{info,warn,error}_to for the current set of redirections.  Call logging with no arguments (or just the kind) to reset everything.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Printf.@printf",
    "page": "E/S y Redes",
    "title": "Base.Printf.@printf",
    "category": "Macro",
    "text": "@printf([io::IOStream], \"%Fmt\", args...)\n\nPrint args using C printf() style format specification string, with some caveats: Inf and NaN are printed consistently as Inf and NaN for flags %a, %A, %e, %E, %f, %F, %g, and %G. Furthermore, if a floating point number is equally close to the numeric values of two possible output strings, the output string further away from zero is chosen.\n\nOptionally, an IOStream may be passed as the first argument to redirect output.\n\nExamples\n\njulia> @printf(\"%f %F %f %F\\n\", Inf, Inf, NaN, NaN)\nInf Inf NaN NaN\n\n\njulia> @printf \"%.0f %.1f %f\\n\" 0.5 0.025 -0.0078125\n1 0.0 -0.007813\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Printf.@sprintf",
    "page": "E/S y Redes",
    "title": "Base.Printf.@sprintf",
    "category": "Macro",
    "text": "@sprintf(\"%Fmt\", args...)\n\nReturn @printf formatted output as string.\n\nExamples\n\njulia> s = @sprintf \"this is a %s %15.1f\" \"test\" 34.567;\n\njulia> println(s)\nthis is a test            34.6\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.sprint",
    "page": "E/S y Redes",
    "title": "Base.sprint",
    "category": "Function",
    "text": "sprint(f::Function, args...)\n\nCall the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string.\n\njulia> sprint(showcompact, 66.66666)\n\"66.6667\"\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.showerror",
    "page": "E/S y Redes",
    "title": "Base.showerror",
    "category": "Function",
    "text": "showerror(io, e)\n\nShow a descriptive representation of an exception object.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.dump",
    "page": "E/S y Redes",
    "title": "Base.dump",
    "category": "Function",
    "text": "dump(x)\n\nShow every part of the representation of a value.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.readstring",
    "page": "E/S y Redes",
    "title": "Base.readstring",
    "category": "Function",
    "text": "readstring(stream::IO)\nreadstring(filename::AbstractString)\n\nRead the entire contents of an I/O stream or a file as a string. The text is assumed to be encoded in UTF-8.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.readline",
    "page": "E/S y Redes",
    "title": "Base.readline",
    "category": "Function",
    "text": "readline(stream::IO=STDIN; chomp::Bool=true)\nreadline(filename::AbstractString; chomp::Bool=true)\n\nRead a single line of text from the given I/O stream or file (defaults to STDIN). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with '\\n' or \"\\r\\n\" or the end of an input stream. When chomp is true (as it is by default), these trailing newline characters are removed from the line before it is returned. When chomp is false, they are returned as part of the line.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.readuntil",
    "page": "E/S y Redes",
    "title": "Base.readuntil",
    "category": "Function",
    "text": "readuntil(stream::IO, delim)\nreaduntil(filename::AbstractString, delim)\n\nRead a string from an I/O stream or a file, up to and including the given delimiter byte. The text is assumed to be encoded in UTF-8.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.readlines",
    "page": "E/S y Redes",
    "title": "Base.readlines",
    "category": "Function",
    "text": "readlines(stream::IO=STDIN; chomp::Bool=true)\nreadlines(filename::AbstractString; chomp::Bool=true)\n\nRead all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading readline repeatedly with the same arguments and saving the resulting lines as a vector of strings.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.eachline",
    "page": "E/S y Redes",
    "title": "Base.eachline",
    "category": "Function",
    "text": "eachline(stream::IO=STDIN; chomp::Bool=true)\neachline(filename::AbstractString; chomp::Bool=true)\n\nCreate an iterable EachLine object that will yield each line from an I/O stream or a file. Iteration calls readline on the stream argument repeatedly with chomp passed through, determining whether trailing end-of-line characters are removed. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the EachLine object is garbage collected.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.readdlm-Tuple{Any,Char,Type,Char}",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.readdlm",
    "category": "Method",
    "text": "readdlm(source, delim::Char, T::Type, eol::Char; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=true, comment_char='#')\n\nRead a matrix from the source where each line (separated by eol) gives one row, with elements separated by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.\n\nIf T is a numeric type, the result is an array of that type, with any non-numeric elements as NaN for floating-point types, or zero. Other useful values of T include String, AbstractString, and Any.\n\nIf header is true, the first row of data will be read as header and the tuple (data_cells, header_cells) is returned instead of only data_cells.\n\nSpecifying skipstart will ignore the corresponding number of initial lines from the input.\n\nIf skipblanks is true, blank lines in the input will be ignored.\n\nIf use_mmap is true, the file specified by source is memory mapped for potential speedups. Default is true except on Windows. On Windows, you may want to specify true if the file is large, and is only read once and not written to.\n\nIf quotes is true, columns enclosed within double-quote (\") characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.  Specifying dims as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files.  If comments is true, lines beginning with comment_char and text following comment_char in any line are ignored.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.readdlm-Tuple{Any,Char,Char}",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.readdlm",
    "category": "Method",
    "text": "readdlm(source, delim::Char, eol::Char; options...)\n\nIf all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.readdlm-Tuple{Any,Char,Type}",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.readdlm",
    "category": "Method",
    "text": "readdlm(source, delim::Char, T::Type; options...)\n\nThe end of line delimiter is taken as \\n.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.readdlm-Tuple{Any,Char}",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.readdlm",
    "category": "Method",
    "text": "readdlm(source, delim::Char; options...)\n\nThe end of line delimiter is taken as \\n. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.readdlm-Tuple{Any,Type}",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.readdlm",
    "category": "Method",
    "text": "readdlm(source, T::Type; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \\n.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.readdlm-Tuple{Any}",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.readdlm",
    "category": "Method",
    "text": "readdlm(source; options...)\n\nThe columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \\n. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.writedlm",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.writedlm",
    "category": "Function",
    "text": "writedlm(f, A, delim='\\t'; opts)\n\nWrite A (a vector, matrix, or an iterable collection of iterable rows) as text to f (either a filename string or an IO stream) using the given delimiter delim (which defaults to tab, but can be any printable Julia object, typically a Char or AbstractString).\n\nFor example, two vectors x and y of the same length can be written as two columns of tab-delimited text to f by either writedlm(f, [x y]) or by writedlm(f, zip(x, y)).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.readcsv",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.readcsv",
    "category": "Function",
    "text": "readcsv(source, [T::Type]; options...)\n\nEquivalent to readdlm with delim set to comma, and type optionally defined by T.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.DataFmt.writecsv",
    "page": "E/S y Redes",
    "title": "Base.DataFmt.writecsv",
    "category": "Function",
    "text": "writecsv(filename, A; opts)\n\nEquivalent to writedlm with delim set to comma.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Base64.Base64EncodePipe",
    "page": "E/S y Redes",
    "title": "Base.Base64.Base64EncodePipe",
    "category": "Type",
    "text": "Base64EncodePipe(ostream)\n\nReturns a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes written to ostream. Calling close on the Base64EncodePipe stream is necessary to complete the encoding (but does not close ostream).\n\njulia> io = IOBuffer();\n\njulia> iob64_encode = Base64EncodePipe(io);\n\njulia> write(iob64_encode, \"Hello!\")\n6\n\njulia> close(iob64_encode);\n\njulia> str = String(take!(io))\n\"SGVsbG8h\"\n\njulia> String(base64decode(str))\n\"Hello!\"\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Base64.Base64DecodePipe",
    "page": "E/S y Redes",
    "title": "Base.Base64.Base64DecodePipe",
    "category": "Type",
    "text": "Base64DecodePipe(istream)\n\nReturns a new read-only I/O stream, which decodes base64-encoded data read from istream.\n\njulia> io = IOBuffer();\n\njulia> iob64_decode = Base64DecodePipe(io);\n\njulia> write(io, \"SGVsbG8h\")\n8\n\njulia> seekstart(io);\n\njulia> String(read(iob64_decode))\n\"Hello!\"\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Base64.base64encode",
    "page": "E/S y Redes",
    "title": "Base.Base64.base64encode",
    "category": "Function",
    "text": "base64encode(writefunc, args...)\nbase64encode(args...)\n\nGiven a write-like function writefunc, which takes an I/O stream as its first argument, base64encode(writefunc, args...) calls writefunc to write args... to a base64-encoded string, and returns the string. base64encode(args...) is equivalent to base64encode(write, args...): it converts its arguments into bytes using the standard write functions and returns the base64-encoded string.\n\nSee also base64decode.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Base64.base64decode",
    "page": "E/S y Redes",
    "title": "Base.Base64.base64decode",
    "category": "Function",
    "text": "base64decode(string)\n\nDecodes the base64-encoded string and returns a Vector{UInt8} of the decoded bytes.\n\nSee also base64encode\n\njulia> b = base64decode(\"SGVsbG8h\")\n6-element Array{UInt8,1}:\n 0x48\n 0x65\n 0x6c\n 0x6c\n 0x6f\n 0x21\n\njulia> String(b)\n\"Hello!\"\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.displaysize",
    "page": "E/S y Redes",
    "title": "Base.displaysize",
    "category": "Function",
    "text": "displaysize(io) -> (lines, columns)\n\nReturn the nominal size of the screen that may be used for rendering output to this io object\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#E/S-Texto-1",
    "page": "E/S y Redes",
    "title": "E/S Texto",
    "category": "section",
    "text": "Base.show(::Any)\nBase.showcompact\nBase.showall\nBase.summary\nBase.print\nBase.println\nBase.print_with_color\nBase.info\nBase.warn\nBase.logging\nBase.Printf.@printf\nBase.Printf.@sprintf\nBase.sprint\nBase.showerror\nBase.dump\nBase.readstring\nBase.readline\nBase.readuntil\nBase.readlines\nBase.eachline\nBase.DataFmt.readdlm(::Any, ::Char, ::Type, ::Char)\nBase.DataFmt.readdlm(::Any, ::Char, ::Char)\nBase.DataFmt.readdlm(::Any, ::Char, ::Type)\nBase.DataFmt.readdlm(::Any, ::Char)\nBase.DataFmt.readdlm(::Any, ::Type)\nBase.DataFmt.readdlm(::Any)\nBase.DataFmt.writedlm\nBase.DataFmt.readcsv\nBase.DataFmt.writecsv\nBase.Base64.Base64EncodePipe\nBase.Base64.Base64DecodePipe\nBase.Base64.base64encode\nBase.Base64.base64decode\nBase.displaysize"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.display",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.display",
    "category": "Function",
    "text": "display(x)\ndisplay(d::Display, x)\ndisplay(mime, x)\ndisplay(d::Display, mime, x)\n\nDisplay x using the topmost applicable display in the display stack, typically using the richest supported multimedia output for x, with plain-text STDOUT output as a fallback. The display(d, x) variant attempts to display x on the given display d only, throwing a MethodError if d cannot display objects of this type.\n\nThere are also two variants with a mime argument (a MIME type string, such as \"image/png\"), which attempt to display x using the requested MIME type only, throwing a MethodError if this type is not supported by either the display(s) or by x. With these variants, one can also supply the \"raw\" data in the requested MIME type by passing x::AbstractString (for MIME types with text-based storage, such as text/html or application/postscript) or x::Vector{UInt8} (for binary MIME types).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.redisplay",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.redisplay",
    "category": "Function",
    "text": "redisplay(x)\nredisplay(d::Display, x)\nredisplay(mime, x)\nredisplay(d::Display, mime, x)\n\nBy default, the redisplay functions simply call display. However, some display backends may override redisplay to modify an existing display of x (if any). Using redisplay is also a hint to the backend that x may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.displayable",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.displayable",
    "category": "Function",
    "text": "displayable(mime) -> Bool\ndisplayable(d::Display, mime) -> Bool\n\nReturns a boolean value indicating whether the given mime type (string) is displayable by any of the displays in the current display stack, or specifically by the display d in the second variant.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.show-Tuple{Any,Any,Any}",
    "page": "E/S y Redes",
    "title": "Base.show",
    "category": "Method",
    "text": "show(stream, mime, x)\n\nThe display functions ultimately call show in order to write an object x as a given mime type to a given I/O stream (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type T, it is only necessary to define a new show method for T, via: show(stream, ::MIME\"mime\", x::T) = ..., where mime is a MIME-type string and the function body calls write (or similar) to write that representation of x to stream. (Note that the MIME\"\" notation only supports literal strings; to construct MIME types in a more flexible manner use MIME{Symbol(\"\")}.)\n\nFor example, if you define a MyImage type and know how to write it to a PNG file, you could define a function show(stream, ::MIME\"image/png\", x::MyImage) = ... to allow your images to be displayed on any PNG-capable Display (such as IJulia). As usual, be sure to import Base.show in order to add new methods to the built-in Julia function show.\n\nThe default MIME type is MIME\"text/plain\". There is a fallback definition for text/plain output that calls show with 2 arguments. Therefore, this case should be handled by defining a 2-argument show(stream::IO, x::MyType) method.\n\nTechnically, the MIME\"mime\" macro defines a singleton type for the given mime string, which allows us to exploit Julia's dispatch mechanisms in determining how to display objects of any given type.\n\nThe first argument to show can be an IOContext specifying output format properties. See IOContext for details.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.mimewritable",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.mimewritable",
    "category": "Function",
    "text": "mimewritable(mime, x)\n\nReturns a boolean value indicating whether or not the object x can be written as the given mime type. (By default, this is determined automatically by the existence of the corresponding show method for typeof(x).)\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.reprmime",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.reprmime",
    "category": "Function",
    "text": "reprmime(mime, x)\n\nReturns an AbstractString or Vector{UInt8} containing the representation of x in the requested mime type, as written by show (throwing a MethodError if no appropriate show is available). An AbstractString is returned for MIME types with textual representations (such as \"text/html\" or \"application/postscript\"), whereas binary data is returned as Vector{UInt8}. (The function istextmime(mime) returns whether or not Julia treats a given mime type as text.)\n\nAs a special case, if x is an AbstractString (for textual MIME types) or a Vector{UInt8} (for binary MIME types), the reprmime function assumes that x is already in the requested mime format and simply returns x. This special case does not apply to the \"text/plain\" MIME type. This is useful so that raw data can be passed to display(m::MIME, x).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.stringmime",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.stringmime",
    "category": "Function",
    "text": "stringmime(mime, x)\n\nReturns an AbstractString containing the representation of x in the requested mime type. This is similar to reprmime except that binary data is base64-encoded as an ASCII string.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.pushdisplay",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.pushdisplay",
    "category": "Function",
    "text": "pushdisplay(d::Display)\n\nPushes a new display d on top of the global display-backend stack. Calling display(x) or display(mime, x) will display x on the topmost compatible backend in the stack (i.e., the topmost backend that does not throw a MethodError).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.popdisplay",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.popdisplay",
    "category": "Function",
    "text": "popdisplay()\npopdisplay(d::Display)\n\nPop the topmost backend off of the display-backend stack, or the topmost copy of d in the second variant.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.TextDisplay",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.TextDisplay",
    "category": "Type",
    "text": "TextDisplay(io::IO)\n\nReturns a TextDisplay <: Display, which displays any object as the text/plain MIME type (by default), writing the text representation to the given I/O stream. (This is how objects are printed in the Julia REPL.)\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Multimedia.istextmime",
    "page": "E/S y Redes",
    "title": "Base.Multimedia.istextmime",
    "category": "Function",
    "text": "istextmime(m::MIME)\n\nDetermine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#multimedia-io-1",
    "page": "E/S y Redes",
    "title": "E/S Multimedia",
    "category": "section",
    "text": "Del mismo modo que la salida de texto se realiza mediante print y los tipos definidos por el usuario pueden indicar su representación textual sobrecargando show, Julia proporciona un mecanismo estandarizado para una salida multimedia enriquecida (como imágenes, texto formateado, o incluso audio y video), que consta de tres partes:Una función display(x) para solicitar la visualización multimedia más completa disponible de un objeto Julia x (con una reserva de texto sin formato).\nSobrecargar show permite indicar representaciones multimedia arbitrarias (codificadas mediante tipos MIME estándar) de tipos definidos por el usuario.\nPueden registrarse backends de visualización con capacidad multimedia subclasificando un tipo genérico de Display y poniéndolos en una pila de backends de visualización mediante pushdisplay.El tiempo de ejecución base de Julia solo proporciona visualización de texto sin formato, pero las pantallas más ricas pueden habilitarse cargando módulos externos o utilizando entornos gráficos de Julia (como el notebook IJulia, basado en IPython).Base.Multimedia.display\nBase.Multimedia.redisplay\nBase.Multimedia.displayable\nBase.show(::Any, ::Any, ::Any)\nBase.Multimedia.mimewritable\nBase.Multimedia.reprmime\nBase.Multimedia.stringmimeComo se mencionó anteriormente, también se pueden definir nuevos backends de pantalla. Por ejemplo, un módulo que puede mostrar imágenes PNG en una ventana puede registrar esta capacidad con Julia, de modo que al llamar a display(x) en tipos con representaciones PNG, se mostrará automáticamente la imagen usando la ventana del módulo.Para definir un nuevo backend de pantalla, primero se debe crear un subtipo D de la clase abstracta Display. Luego, para cada tipo MIME (cadena mime) que se puede mostrar en D, se debe definir una función display(d::D, ::MIME\"mime\", x) = ... que muestra x como ese tipo MIME, generalmente llamando a reprmime(mime, x). Se debe lanzar un MethodError si x no se puede mostrar como ese tipo MIME; esto es automático si se llama a reprmime. Finalmente, se debe definir una función display(d::D, x) que consulte mimewritable(mime,x) para los tipos mime soportados por D y muestre el \"mejor\"; debe lanzarse un MethodError si no se encuentran tipos MIME soportados para x. Del mismo modo, algunos subtipos pueden sobreescribir redisplay(d::D, ...). (De nuevo, se debe hacer import Base.display para agregar nuevos métodos a display.) Los valores de retorno de estas funciones dependen de la implementación (ya que en algunos casos puede ser útil devolver un \"manejador\" handle de visualización de algún tipo). Las funciones de visualización para D se pueden llamar directamente, pero también se pueden invocar automáticamente desde display(x) simplemente presionando una nueva pantalla en la pila display-backend con:Base.Multimedia.pushdisplay\nBase.Multimedia.popdisplay\nBase.Multimedia.TextDisplay\nBase.Multimedia.istextmime"
},

{
    "location": "stdlib/io-network.html#Base.Mmap.Anonymous",
    "page": "E/S y Redes",
    "title": "Base.Mmap.Anonymous",
    "category": "Type",
    "text": "Mmap.Anonymous(name, readonly, create)\n\nCreate an IO-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in Mmap.mmap. Used by SharedArray for creating shared memory arrays.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Mmap.mmap-Tuple{Any,Type,Any,Any}",
    "page": "E/S y Redes",
    "title": "Base.Mmap.mmap",
    "category": "Method",
    "text": "Mmap.mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)\n       Mmap.mmap(type::Type{Array{T,N}}, dims)\n\nCreate an Array whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer's memory.\n\nThe type is an Array{T,N} with a bits-type element of T and dimension N that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).\n\ndims is a tuple or single Integer specifying the size or length of the array.\n\nThe file is passed via the stream argument, either as an open IOStream or filename string. When you initialize the stream, use \"r\" for a \"read-only\" array, and \"w+\" to create a new array used to write values to disk.\n\nIf no type argument is specified, the default is Vector{UInt8}.\n\nOptionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an IOStream.\n\nThe grow keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is < requested array size). Write privileges are required to grow the file.\n\nThe shared keyword argument specifies whether the resulting Array and changes made to it will be visible to other processes mapping the same file.\n\nFor example, the following code\n\n# Create a file for mmapping\n# (you could alternatively use mmap to do this step, too)\nA = rand(1:20, 5, 30)\ns = open(\"/tmp/mmap.bin\", \"w+\")\n# We'll write the dimensions of the array as the first two Ints in the file\nwrite(s, size(A,1))\nwrite(s, size(A,2))\n# Now write the data\nwrite(s, A)\nclose(s)\n\n# Test by reading it back in\ns = open(\"/tmp/mmap.bin\")   # default is read-only\nm = read(s, Int)\nn = read(s, Int)\nA2 = Mmap.mmap(s, Matrix{Int}, (m,n))\n\ncreates a m-by-n Matrix{Int}, linked to the file associated with stream s.\n\nA more portable file would need to encode the word size – 32 bit or 64 bit – and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Mmap.mmap-Tuple{Any,BitArray,Any,Any}",
    "page": "E/S y Redes",
    "title": "Base.Mmap.mmap",
    "category": "Method",
    "text": "Mmap.mmap(io, BitArray, [dims, offset])\n\nCreate a BitArray whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as mmap, but the byte representation is different.\n\nExample: B = Mmap.mmap(s, BitArray, (25,30000))\n\nThis would create a 25-by-30000 BitArray, linked to the file associated with stream s.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Mmap.sync!",
    "page": "E/S y Redes",
    "title": "Base.Mmap.sync!",
    "category": "Function",
    "text": "Mmap.sync!(array)\n\nForces synchronization between the in-memory version of a memory-mapped Array or BitArray and the on-disk version.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#E/S-Mapeada-en-Memoria-1",
    "page": "E/S y Redes",
    "title": "E/S Mapeada en Memoria",
    "category": "section",
    "text": "Base.Mmap.Anonymous\nBase.Mmap.mmap(::Any, ::Type, ::Any, ::Any)\nBase.Mmap.mmap(::Any, ::BitArray, ::Any, ::Any)\nBase.Mmap.sync!"
},

{
    "location": "stdlib/io-network.html#Base.connect-Tuple{TCPSocket,Integer}",
    "page": "E/S y Redes",
    "title": "Base.connect",
    "category": "Method",
    "text": "connect([host], port::Integer) -> TCPSocket\n\nConnect to the host host on port port.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.connect-Tuple{AbstractString}",
    "page": "E/S y Redes",
    "title": "Base.connect",
    "category": "Method",
    "text": "connect(path::AbstractString) -> PipeEndpoint\n\nConnect to the named pipe / UNIX domain socket at path.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.listen-Tuple{Any}",
    "page": "E/S y Redes",
    "title": "Base.listen",
    "category": "Method",
    "text": "listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -> TCPServer\n\nListen on port on the address specified by addr. By default this listens on localhost only. To listen on all interfaces pass IPv4(0) or IPv6(0) as appropriate. backlog determines how many connections can be pending (not having called accept) before the server will begin to reject them. The default value of backlog is 511.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.listen-Tuple{AbstractString}",
    "page": "E/S y Redes",
    "title": "Base.listen",
    "category": "Method",
    "text": "listen(path::AbstractString) -> PipeServer\n\nCreate and listen on a named pipe / UNIX domain socket.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.getaddrinfo",
    "page": "E/S y Redes",
    "title": "Base.getaddrinfo",
    "category": "Function",
    "text": "getaddrinfo(host::AbstractString) -> IPAddr\n\nGets the IP address of the host (may have to do a DNS lookup)\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.getsockname",
    "page": "E/S y Redes",
    "title": "Base.getsockname",
    "category": "Function",
    "text": "getsockname(sock::Union{TCPServer, TCPSocket}) -> (IPAddr, UInt16)\n\nGet the IP address and the port that the given TCPSocket is connected to (or bound to, in the case of TCPServer).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.IPv4",
    "page": "E/S y Redes",
    "title": "Base.IPv4",
    "category": "Type",
    "text": "IPv4(host::Integer) -> IPv4\n\nReturns an IPv4 object from ip address host formatted as an Integer.\n\njulia> IPv4(3223256218)\nip\"192.30.252.154\"\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.IPv6",
    "page": "E/S y Redes",
    "title": "Base.IPv6",
    "category": "Type",
    "text": "IPv6(host::Integer) -> IPv6\n\nReturns an IPv6 object from ip address host formatted as an Integer.\n\njulia> IPv6(3223256218)\nip\"::c01e:fc9a\"\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.nb_available",
    "page": "E/S y Redes",
    "title": "Base.nb_available",
    "category": "Function",
    "text": "nb_available(stream)\n\nReturns the number of bytes available for reading before a read from this stream or buffer will block.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.accept",
    "page": "E/S y Redes",
    "title": "Base.accept",
    "category": "Function",
    "text": "accept(server[,client])\n\nAccepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.listenany",
    "page": "E/S y Redes",
    "title": "Base.listenany",
    "category": "Function",
    "text": "listenany([host::IPAddr,] port_hint) -> (UInt16, TCPServer)\n\nCreate a TCPServer on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Filesystem.poll_fd",
    "page": "E/S y Redes",
    "title": "Base.Filesystem.poll_fd",
    "category": "Function",
    "text": "poll_fd(fd, timeout_s::Real=-1; readable=false, writable=false)\n\nMonitor a file descriptor fd for changes in the read or write availability, and with a timeout given by timeout_s seconds.\n\nThe keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to true.\n\nThe returned value is an object with boolean fields readable, writable, and timedout, giving the result of the polling.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Filesystem.poll_file",
    "page": "E/S y Redes",
    "title": "Base.Filesystem.poll_file",
    "category": "Function",
    "text": "poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -> (previous::StatStruct, current::StatStruct)\n\nMonitor a file for changes by polling every interval_s seconds until a change occurs or timeout_s seconds have elapsed. The interval_s should be a long period; the default is 5.007 seconds.\n\nReturns a pair of StatStruct objects (previous, current) when a change is detected.\n\nTo determine when a file was modified, compare mtime(prev) != mtime(current) to detect notification of changes. However, using watch_file for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.Filesystem.watch_file",
    "page": "E/S y Redes",
    "title": "Base.Filesystem.watch_file",
    "category": "Function",
    "text": "watch_file(path::AbstractString, timeout_s::Real=-1)\n\nWatch file or directory path for changes until a change occurs or timeout_s seconds have elapsed.\n\nThe returned value is an object with boolean fields changed, renamed, and timedout, giving the result of watching the file.\n\nThis behavior of this function varies slightly across platforms. See https://nodejs.org/api/fs.html#fs_caveats for more detailed information.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.bind",
    "page": "E/S y Redes",
    "title": "Base.bind",
    "category": "Function",
    "text": "bind(socket::Union{UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false, reuseaddr=false, kws...)\n\nBind socket to the given host:port. Note that 0.0.0.0 will listen on all devices.\n\nThe ipv6only parameter disables dual stack mode. If ipv6only=true, only an IPv6 stack is created.\nIf reuseaddr=true, multiple threads or processes can bind to the same address without error if they all set reuseaddr=true, but only the last to bind will receive any traffic.\n\n\n\nbind(chnl::Channel, task::Task)\n\nAssociates the lifetime of chnl with a task. Channel chnl is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on chnl.\n\nThe chnl object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.\n\nWhen a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.\n\njulia> c = Channel(0);\n\njulia> task = @schedule foreach(i->put!(c, i), 1:4);\n\njulia> bind(c,task);\n\njulia> for i in c\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\njulia> isopen(c)\nfalse\n\njulia> c = Channel(0);\n\njulia> task = @schedule (put!(c,1);error(\"foo\"));\n\njulia> bind(c,task);\n\njulia> take!(c)\n1\n\njulia> put!(c,1);\nERROR: foo\nStacktrace:\n [1] check_channel_state(::Channel{Any}) at ./channels.jl:131\n [2] put!(::Channel{Any}, ::Int64) at ./channels.jl:261\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.send",
    "page": "E/S y Redes",
    "title": "Base.send",
    "category": "Function",
    "text": "send(socket::UDPSocket, host, port::Integer, msg)\n\nSend msg over socket to host:port.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.recv",
    "page": "E/S y Redes",
    "title": "Base.recv",
    "category": "Function",
    "text": "recv(socket::UDPSocket)\n\nRead a UDP packet from the specified socket, and return the bytes received. This call blocks.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.recvfrom",
    "page": "E/S y Redes",
    "title": "Base.recvfrom",
    "category": "Function",
    "text": "recvfrom(socket::UDPSocket) -> (address, data)\n\nRead a UDP packet from the specified socket, returning a tuple of (address, data), where address will be either IPv4 or IPv6 as appropriate.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.setopt",
    "page": "E/S y Redes",
    "title": "Base.setopt",
    "category": "Function",
    "text": "setopt(sock::UDPSocket; multicast_loop = nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)\n\nSet UDP socket options.\n\nmulticast_loop: loopback for multicast packets (default: true).\nmulticast_ttl: TTL for multicast packets (default: nothing).\nenable_broadcast: flag must be set to true if socket will be used for broadcast messages, or else the UDP system will return an access error (default: false).\nttl: Time-to-live of packets sent on the socket (default: nothing).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.ntoh",
    "page": "E/S y Redes",
    "title": "Base.ntoh",
    "category": "Function",
    "text": "ntoh(x)\n\nConverts the endianness of a value from Network byte order (big-endian) to that used by the Host.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.hton",
    "page": "E/S y Redes",
    "title": "Base.hton",
    "category": "Function",
    "text": "hton(x)\n\nConverts the endianness of a value from that used by the Host to Network byte order (big-endian).\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.ltoh",
    "page": "E/S y Redes",
    "title": "Base.ltoh",
    "category": "Function",
    "text": "ltoh(x)\n\nConverts the endianness of a value from Little-endian to that used by the Host.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.htol",
    "page": "E/S y Redes",
    "title": "Base.htol",
    "category": "Function",
    "text": "htol(x)\n\nConverts the endianness of a value from that used by the Host to Little-endian.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#Base.ENDIAN_BOM",
    "page": "E/S y Redes",
    "title": "Base.ENDIAN_BOM",
    "category": "Constant",
    "text": "ENDIAN_BOM\n\nThe 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value 0x04030201. Big-endian machines will contain the value 0x01020304.\n\n\n\n"
},

{
    "location": "stdlib/io-network.html#E/S-por-Red-1",
    "page": "E/S y Redes",
    "title": "E/S por Red",
    "category": "section",
    "text": "Base.connect(::TCPSocket, ::Integer)\nBase.connect(::AbstractString)\nBase.listen(::Any)\nBase.listen(::AbstractString)\nBase.getaddrinfo\nBase.getsockname\nBase.IPv4\nBase.IPv6\nBase.nb_available\nBase.accept\nBase.listenany\nBase.Filesystem.poll_fd\nBase.Filesystem.poll_file\nBase.Filesystem.watch_file\nBase.bind\nBase.send\nBase.recv\nBase.recvfrom\nBase.setopt\nBase.ntoh\nBase.hton\nBase.ltoh\nBase.htol\nBase.ENDIAN_BOM"
},

{
    "location": "stdlib/punctuation.html#",
    "page": "Puntuación",
    "title": "Puntuación",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/punctuation.html#punctuation-1",
    "page": "Puntuación",
    "title": "Puntuación",
    "category": "section",
    "text": "Puede encontrar documentación extendida sobre símbolos y funciones matemáticas aquí.Símbolo Significado\n@m Invoca la macro m; seguido de expresiones separadas por espacios\n! Operador \"not\" prefijo\na!( )     Al final de un nombre de función, ! indica que la función modifica su(s) argumento(s)    \n#         Inicio de un comentario de una sola línea                                                 \n#= Inicio de un comentario multilínea (pueden ser anidados)\n=# Final de un comentario multilínea\n$         Interpolación de cadena y expresión                                                       \n% Operador resto\n^ Operador exponenente\n&         Operador and bit-a-bit                                                                     \n&& Operador and booleano (en corto-circuito)\n| Operador or bit-a-bit\n|| Operador or booleano (en corto-circuito)\n⊻ Operador xor bit-a-bit\n*         Multiplicación o producto matricial                                                         \n()       Tupla vacía                                                                            \n~ Operador not bit-a-bit\n\\ Operador backslash\n' Operador transpuesto complejo Aᴴ\na[]       Indexación de array                                                                       \n[,]       Concatenación vertical                                                                    \n[;]       Concatenación vertical (también)                                                          \n[    ]   Con expresiones separadas por espacios, concatenación horizontal                          \nT{ }     Instanciación de tipo paramétrico                                                          \n; Separador de instrucciones\n,         Separador de argumentos de función o de componentes de una tupla                          \n? Operador condicional ternario (conditional ? if_true : if_false)\n\"\" Delimitador de literales cadena\n''       Delimitador de literales carácter                                                          \n` ` Delimitador de especificaciones de proceso externo (mandato)\n... Une argumentos en una llamada a función o declara una función o tipo varargs\n.         Acceso nombrado a campos en objectos/módulos, también llamadas a operadores/funciones vectorizadas\na:b Rango a, a+1, a+2, ..., b\na:s:b Rango a, a+s, a+2s, ..., b\n:         Indexa una dimensión entera (1:final)                                                      \n::       Anotación de tipo, dependiendo del contexto                                                \n:( )     Expresión citada                                                                          \n:a       Símbolo a                                                                                 \n<: subtype operator\n>: supertype operator (contrario al anterior)\n=== egal comparison operator"
},

{
    "location": "stdlib/sort.html#",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Ordenación y Funciones Relacionadas",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/sort.html#sort-1",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Ordenación y Funciones Relacionadas",
    "category": "section",
    "text": "Julia tiene una API amplia y flexible para ordenar e interactuar con matrices de valores ya ordenados. Por defecto, Julia selecciona algoritmos y ordenaciones razonables en orden ascendente estándar:julia> sort([2,3,1])\n3-element Array{Int64,1}:\n 1\n 2\n 3También se puede ordenar en orden inverso:julia> sort([2,3,1], rev=true)\n3-element Array{Int64,1}:\n 3\n 2\n 1Para ordenar un array sobre sí mismo, use la versión con admiración de la función de ordenación:julia> a = [2,3,1];\n\njulia> sort!(a);\n\njulia> a\n3-element Array{Int64,1}:\n 1\n 2\n 3En lugar de ordenar un array directamente, podemos computar una permutación de los índices del array que ponen el array en un orden determinado:julia> v = randn(5)\n5-element Array{Float64,1}:\n  0.297288\n  0.382396\n -0.597634\n -0.0104452\n -0.839027\n\njulia> p = sortperm(v)\n5-element Array{Int64,1}:\n 5\n 3\n 4\n 1\n 2\n\njulia> v[p]\n5-element Array{Float64,1}:\n -0.839027\n -0.597634\n -0.0104452\n  0.297288\n  0.382396Los arrays pueden ser ordenados fácilmente de acuerdo a una transformación arbitraria de sus valores:julia> sort(v, by=abs)\n5-element Array{Float64,1}:\n -0.0104452\n  0.297288\n  0.382396\n -0.597634\n -0.839027O en orden reverso mediante una transformación:julia> sort(v, by=abs, rev=true)\n5-element Array{Float64,1}:\n -0.839027\n -0.597634\n  0.382396\n  0.297288\n -0.0104452Si es necesario, puede elegirse el algoritmo de ordenación:julia> sort(v, alg=InsertionSort)\n5-element Array{Float64,1}:\n -0.839027\n -0.597634\n -0.0104452\n  0.297288\n  0.382396Todas las funciones de ordenación y relacionadas con el orden se basan en una relación \"menor que\" que define un orden total sobre los valores que van a manipularse. La función isless es la invocada por defecto, pero la relación puede ser especificada mediante la palabra clave lt."
},

{
    "location": "stdlib/sort.html#Base.sort!",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.sort!",
    "category": "Function",
    "text": "sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort the vector v in place. QuickSort is used by default for numeric arrays while MergeSort is used for other arrays. You can specify an algorithm to use via the alg keyword (see Sorting Algorithms for available algorithms). The by keyword lets you provide a function that will be applied to each element before comparison; the lt keyword allows providing a custom \"less than\" function; use rev=true to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both by and lt are specified, the lt function is applied to the result of the by function; rev=true reverses whatever ordering specified via the by and lt keywords.\n\nExamples\n\njulia> v = [3, 1, 2]; sort!(v); v\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> v = [3, 1, 2]; sort!(v, rev = true); v\n3-element Array{Int64,1}:\n 3\n 2\n 1\n\njulia> v = [(1, \"c\"), (3, \"a\"), (2, \"b\")]; sort!(v, by = x -> x[1]); v\n3-element Array{Tuple{Int64,String},1}:\n (1, \"c\")\n (2, \"b\")\n (3, \"a\")\n\njulia> v = [(1, \"c\"), (3, \"a\"), (2, \"b\")]; sort!(v, by = x -> x[2]); v\n3-element Array{Tuple{Int64,String},1}:\n (3, \"a\")\n (2, \"b\")\n (1, \"c\")\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.sort",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.sort",
    "category": "Function",
    "text": "sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nVariant of sort! that returns a sorted copy of v leaving v itself unmodified.\n\nExamples\n\njulia> v = [3, 1, 2];\n\njulia> sort(v)\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> v\n3-element Array{Int64,1}:\n 3\n 1\n 2\n\n\n\nsort(A, dim::Integer; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)\n\nSort a multidimensional array A along the given dimension. See sort! for a description of possible keyword arguments.\n\nExamples\n\njulia> A = [4 3; 1 2]\n2×2 Array{Int64,2}:\n 4  3\n 1  2\n\njulia> sort(A, 1)\n2×2 Array{Int64,2}:\n 1  2\n 4  3\n\njulia> sort(A, 2)\n2×2 Array{Int64,2}:\n 3  4\n 1  2\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.sortperm",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.sortperm",
    "category": "Function",
    "text": "sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nReturn a permutation vector of indices of v that puts it in sorted order. Specify alg to choose a particular sorting algorithm (see Sorting Algorithms). MergeSort is used by default, and since it is stable, the resulting permutation will be the lexicographically first one that puts the input array into sorted order – i.e. indices of equal elements appear in ascending order. If you choose a non-stable sorting algorithm such as QuickSort, a different permutation that puts the array into order may be returned. The order is specified using the same keywords as sort!.\n\nSee also sortperm!.\n\nExamples\n\njulia> v = [3, 1, 2];\n\njulia> p = sortperm(v)\n3-element Array{Int64,1}:\n 2\n 3\n 1\n\njulia> v[p]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.sortperm!",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.sortperm!",
    "category": "Function",
    "text": "sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)\n\nLike sortperm, but accepts a preallocated index vector ix.  If initialized is false (the default), ix is initialized to contain the values 1:length(v).\n\nExamples\n\njulia> v = [3, 1, 2]; p = zeros(Int, 3);\n\njulia> sortperm!(p, v); p\n3-element Array{Int64,1}:\n 2\n 3\n 1\n\njulia> v[p]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.sortrows",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.sortrows",
    "category": "Function",
    "text": "sortrows(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort the rows of matrix A lexicographically. See sort! for a description of possible keyword arguments.\n\nExamples\n\njulia> sortrows([7 3 5; -1 6 4; 9 -2 8])\n3×3 Array{Int64,2}:\n -1   6  4\n  7   3  5\n  9  -2  8\n\njulia> sortrows([7 3 5; -1 6 4; 9 -2 8], lt=(x,y)->isless(x[2],y[2]))\n3×3 Array{Int64,2}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\njulia> sortrows([7 3 5; -1 6 4; 9 -2 8], rev=true)\n3×3 Array{Int64,2}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.sortcols",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.sortcols",
    "category": "Function",
    "text": "sortcols(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort the columns of matrix A lexicographically. See sort! for a description of possible keyword arguments.\n\nExamples\n\njulia> sortcols([7 3 5; 6 -1 -4; 9 -2 8])\n3×3 Array{Int64,2}:\n  3   5  7\n -1  -4  6\n -2   8  9\n\njulia> sortcols([7 3 5; 6 -1 -4; 9 -2 8], alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))\n3×3 Array{Int64,2}:\n  5   3  7\n -4  -1  6\n  8  -2  9\n\njulia> sortcols([7 3 5; 6 -1 -4; 9 -2 8], rev=true)\n3×3 Array{Int64,2}:\n 7   5   3\n 6  -4  -1\n 9   8  -2\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Funciones-de-Ordenación-1",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Funciones de Ordenación",
    "category": "section",
    "text": "Base.sort!\nBase.sort\nBase.sortperm\nBase.Sort.sortperm!\nBase.Sort.sortrows\nBase.Sort.sortcols"
},

{
    "location": "stdlib/sort.html#Base.issorted",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.issorted",
    "category": "Function",
    "text": "issorted(v, lt=isless, by=identity, rev:Bool=false, order::Ordering=Forward)\n\nTest whether a vector is in sorted order. The lt, by and rev keywords modify what order is considered to be sorted just as they do for sort.\n\nExamples\n\njulia> issorted([1, 2, 3])\ntrue\n\njulia> issorted([(1, \"b\"), (2, \"a\")], by = x -> x[1])\ntrue\n\njulia> issorted([(1, \"b\"), (2, \"a\")], by = x -> x[2])\nfalse\n\njulia> issorted([(1, \"b\"), (2, \"a\")], by = x -> x[2], rev=true)\ntrue\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.searchsorted",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.searchsorted",
    "category": "Function",
    "text": "searchsorted(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nReturns the range of indices of a which compare as equal to x (using binary search) according to the order specified by the by, lt and rev keywords, assuming that a is already sorted in that order. Returns an empty range located at the insertion point if a does not contain values equal to x.\n\nExamples\n\njulia> a = [4, 3, 2, 1]\n4-element Array{Int64,1}:\n 4\n 3\n 2\n 1\n\njulia> searchsorted(a, 4)\n5:4\n\njulia> searchsorted(a, 4, rev=true)\n1:1\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.searchsortedfirst",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.searchsortedfirst",
    "category": "Function",
    "text": "searchsortedfirst(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nReturns the index of the first value in a greater than or equal to x, according to the specified order. Returns length(a)+1 if x is greater than all values in a. a is assumed to be sorted.\n\nExamples\n\njulia> searchsortedfirst([1, 2, 4, 5, 14], 4)\n3\n\njulia> searchsortedfirst([1, 2, 4, 5, 14], 4, rev=true)\n1\n\njulia> searchsortedfirst([1, 2, 4, 5, 14], 15)\n6\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.searchsortedlast",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.searchsortedlast",
    "category": "Function",
    "text": "searchsortedlast(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nReturns the index of the last value in a less than or equal to x, according to the specified order. Returns 0 if x is less than all values in a. a is assumed to be sorted.\n\nExamples\n\njulia> searchsortedlast([1, 2, 4, 5, 14], 4)\n3\n\njulia> searchsortedlast([1, 2, 4, 5, 14], 4, rev=true)\n5\n\njulia> searchsortedlast([1, 2, 4, 5, 14], -1)\n0\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.select!",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.select!",
    "category": "Function",
    "text": "select!(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nPartially sort the vector v in place, according to the order specified by by, lt and rev so that the value at index k (or range of adjacent values if k is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If k is a single index, that value is returned; if k is a range, an array of values at those indices is returned. Note that select! does not fully sort the input array.\n\nExamples\n\njulia> a = [1, 2, 4, 3, 4]\n5-element Array{Int64,1}:\n 1\n 2\n 4\n 3\n 4\n\njulia> select!(a, 4)\n4\n\njulia> a\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 4\n\njulia> a = [1, 2, 4, 3, 4]\n5-element Array{Int64,1}:\n 1\n 2\n 4\n 3\n 4\n\njulia> select!(a, 4, rev=true)\n2\n\njulia> a\n5-element Array{Int64,1}:\n 4\n 4\n 3\n 2\n 1\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.select",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.select",
    "category": "Function",
    "text": "select(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nVariant of select! which copies v before partially sorting it, thereby returning the same thing as select! but leaving v unmodified.\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.selectperm",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.selectperm",
    "category": "Function",
    "text": "selectperm(v, k, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])\n\nReturn a partial permutation of the vector v, according to the order specified by by, lt and rev, so that v[output] returns the first k (or range of adjacent values if k is a range) values of a fully sorted version of v. If k is a single index (Integer), an array of the first k indices is returned; if k is a range, an array of those indices is returned. Note that the handling of integer values for k is different from select in that it returns a vector of k elements instead of just the k th element. Also note that this is equivalent to, but more efficient than, calling sortperm(...)[k].\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Base.Sort.selectperm!",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Base.Sort.selectperm!",
    "category": "Function",
    "text": "selectperm!(ix, v, k, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false,] [initialized=false])\n\nLike selectperm, but accepts a preallocated index vector ix. If initialized is false (the default), ix is initialized to contain the values 1:length(ix).\n\n\n\n"
},

{
    "location": "stdlib/sort.html#Funciones-Relacionadas-con-Orden-1",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Funciones Relacionadas con Orden",
    "category": "section",
    "text": "Base.issorted\nBase.Sort.searchsorted\nBase.Sort.searchsortedfirst\nBase.Sort.searchsortedlast\nBase.Sort.select!\nBase.Sort.select\nBase.Sort.selectperm\nBase.Sort.selectperm!"
},

{
    "location": "stdlib/sort.html#Algoritmos-de-Ordenación-1",
    "page": "Ordenación y Funciones Relacionadas",
    "title": "Algoritmos de Ordenación",
    "category": "section",
    "text": "Actualmente hay cuatro algoritmos de ordenación disponibles en Julia base:InsertionSort\nQuickSort\nPartialQuickSort(k)\nMergeSortInsertionSort es un algoritmo de ordenación estable cuyo coste es O(n^2). Es eficiente para n muy pequeños, y es usado internamente por QuickSort.QuickSort es un algoritmo de ordenación que es in-place muy rápido pero no estable (es decir, los elementos que son considerados iguales no permanecerán en el mismo orden en que se encontraban originalmente en el array antes de ser ordenados). Su coste computacional es O(n log n). QuickSort es el algoritmo por defecto para valores numéricos, incluyendo enteros y punto flotante.PartialQuickSort(k) es similar a QuickSort, pero el array de salida es sólo ordenado hasta el índice  k si k es un entero, o en el rango de k si k es un OrdinalRange. Por ejemplo:x = rand(1:500, 100)\nk = 50\nk2 = 50:100\ns = sort(x; alg=QuickSort)\nps = sort(x; alg=PartialQuickSort(k))\nqs = sort(x; alg=PartialQuickSort(k2))\nmap(issorted, (s, ps, qs))             # => (true, false, false)\nmap(x->issorted(x[1:k]), (s, ps, qs))  # => (true, true, false)\nmap(x->issorted(x[k2]), (s, ps, qs))   # => (true, false, true)\ns[1:k] == ps[1:k]                      # => true\ns[k2] == qs[k2]                        # => trueMergeSort es un algoritmo de ordenación estable, pero no in-place (requiere un array temporal de la mitad del tamaño del array de entrada), de coste O(n log n) y no suele ser tan rapido como QuickSort. Es el algoritmo por defecto para datos no numéricos.Los algoritmos de ordenación por defecto se eligen sobre la base de que son rápidos y estables, o parezcan serlo. Para los tipos numéricos, de hecho, se selecciona QuickSort ya que es más rápido e indistinguible en este caso de un tipo estable (a menos que la matriz registre sus mutaciones de alguna manera). La propiedad de estabilidad tiene un coste no despreciable, por lo que si no la necesita, puede especificar explícitamente su algoritmo preferido, p. sort!(v, alg=QuickSort).El mecanismo por el cual Julia selecciona los algoritmos de ordenación predeterminados se implementa a través de la función Base.Sort.defalg. Permite que un algoritmo particular se registre como el predeterminado en todas las funciones de ordenación para arrays específicos. Por ejemplo, aquí están los dos métodos predeterminados de sort.jl:defalg(v::AbstractArray) = MergeSort\ndefalg{T<:Number}(v::AbstractArray{T}) = QuickSortEn cuanto a los arrays numéricos, la elección de un algoritmo predeterminado no estable para los tipos de array para los cuales la noción de ordenación estable no tiene sentido (es decir, cuando dos valores que comparan iguales no se pueden distinguir) puede tener sentido."
},

{
    "location": "stdlib/pkg.html#",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Funciones del Administrador de Paquetes",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/pkg.html#Base.Pkg.dir",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.dir",
    "category": "Function",
    "text": "dir() -> AbstractString\n\nReturns the absolute path of the package directory. This defaults to joinpath(homedir(),\".julia\",\"v$(VERSION.major).$(VERSION.minor)\") on all platforms (i.e. ~/.julia/v0.6 in UNIX shell syntax). If the JULIA_PKGDIR environment variable is set, then that path is used in the returned value as joinpath(ENV[\"JULIA_PKGDIR\"],\"v$(VERSION.major).$(VERSION.minor)\"). If JULIA_PKGDIR is a relative path, it is interpreted relative to whatever the current working directory is.\n\n\n\ndir(names...) -> AbstractString\n\nEquivalent to normpath(Pkg.dir(),names...) – i.e. it appends path components to the package directory and normalizes the resulting path. In particular, Pkg.dir(pkg) returns the path to the package pkg.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.init",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.init",
    "category": "Function",
    "text": "init(meta::AbstractString=DEFAULT_META, branch::AbstractString=META_BRANCH)\n\nInitialize Pkg.dir() as a package directory. This will be done automatically when the JULIA_PKGDIR is not set and Pkg.dir() uses its default value. As part of this process, clones a local METADATA git repository from the site and branch specified by its arguments, which are typically not provided. Explicit (non-default) arguments can be used to support a custom METADATA setup.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.resolve",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.resolve",
    "category": "Function",
    "text": "resolve()\n\nDetermines an optimal, consistent set of package versions to install or upgrade to. The optimal set of package versions is based on the contents of Pkg.dir(\"REQUIRE\") and the state of installed packages in Pkg.dir(), Packages that are no longer required are moved into Pkg.dir(\".trash\").\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.edit",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.edit",
    "category": "Function",
    "text": "edit()\n\nOpens Pkg.dir(\"REQUIRE\") in the editor specified by the VISUAL or EDITOR environment variables; when the editor command returns, it runs Pkg.resolve() to determine and install a new optimal set of installed package versions.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.add",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.add",
    "category": "Function",
    "text": "add(pkg, vers...)\n\nAdd a requirement entry for pkg to Pkg.dir(\"REQUIRE\") and call Pkg.resolve(). If vers are given, they must be VersionNumber objects and they specify acceptable version intervals for pkg.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.rm",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.rm",
    "category": "Function",
    "text": "rm(pkg)\n\nRemove all requirement entries for pkg from Pkg.dir(\"REQUIRE\") and call Pkg.resolve().\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.clone",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.clone",
    "category": "Function",
    "text": "clone(pkg)\n\nIf pkg has a URL registered in Pkg.dir(\"METADATA\"), clone it from that URL on the default branch. The package does not need to have any registered versions.\n\n\n\nclone(url, [pkg])\n\nClone a package directly from the git URL url. The package does not need to be registered in Pkg.dir(\"METADATA\"). The package repo is cloned by the name pkg if provided; if not provided, pkg is determined automatically from url.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.setprotocol!",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.setprotocol!",
    "category": "Function",
    "text": "setprotocol!(proto)\n\nSet the protocol used to access GitHub-hosted packages. Defaults to 'https', with a blank proto delegating the choice to the package developer.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.available",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.available",
    "category": "Function",
    "text": "available() -> Vector{String}\n\nReturns the names of available packages.\n\n\n\navailable(pkg) -> Vector{VersionNumber}\n\nReturns the version numbers available for package pkg.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.installed",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.installed",
    "category": "Function",
    "text": "installed() -> Dict{String,VersionNumber}\n\nReturns a dictionary mapping installed package names to the installed version number of each package.\n\n\n\ninstalled(pkg) -> Void | VersionNumber\n\nIf pkg is installed, return the installed version number. If pkg is registered, but not installed, return nothing.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.status",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.status",
    "category": "Function",
    "text": "status()\n\nPrints out a summary of what packages are installed and what version and state they're in.\n\n\n\nstatus(pkg)\n\nPrints out a summary of what version and state pkg, specifically, is in.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.update",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.update",
    "category": "Function",
    "text": "update(pkgs...)\n\nUpdate the metadata repo – kept in Pkg.dir(\"METADATA\") – then update any fixed packages that can safely be pulled from their origin; then call Pkg.resolve() to determine a new optimal set of packages versions.\n\nWithout arguments, updates all installed packages. When one or more package names are provided as arguments, only those packages and their dependencies are updated.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.checkout",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.checkout",
    "category": "Function",
    "text": "checkout(pkg, [branch=\"master\"]; merge=true, pull=true)\n\nCheckout the Pkg.dir(pkg) repo to the branch branch. Defaults to checking out the \"master\" branch. To go back to using the newest compatible released version, use Pkg.free(pkg). Changes are merged (fast-forward only) if the keyword argument merge == true, and the latest version is pulled from the upstream repo if pull == true.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.pin",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.pin",
    "category": "Function",
    "text": "pin(pkg)\n\nPin pkg at the current version. To go back to using the newest compatible released version, use Pkg.free(pkg)\n\n\n\npin(pkg, version)\n\nPin pkg at registered version version.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.free",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.free",
    "category": "Function",
    "text": "free(pkg)\n\nFree the package pkg to be managed by the package manager again. It calls Pkg.resolve() to determine optimal package versions after. This is an inverse for both Pkg.checkout and Pkg.pin.\n\nYou can also supply an iterable collection of package names, e.g., Pkg.free((\"Pkg1\", \"Pkg2\")) to free multiple packages at once.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.build",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.build",
    "category": "Function",
    "text": "build()\n\nRun the build scripts for all installed packages in depth-first recursive order.\n\n\n\nbuild(pkgs...)\n\nRun the build script in deps/build.jl for each package in pkgs and all of their dependencies in depth-first recursive order. This is called automatically by Pkg.resolve() on all installed or updated packages.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.test",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.test",
    "category": "Function",
    "text": "test(; coverage=false)\n\nRun the tests for all installed packages ensuring that each package's test dependencies are installed for the duration of the test. A package is tested by running its test/runtests.jl file and test dependencies are specified in test/REQUIRE. Coverage statistics for the packages may be generated by passing coverage=true. The default behavior is not to run coverage.\n\n\n\ntest(pkgs...; coverage=false)\n\nRun the tests for each package in pkgs ensuring that each package's test dependencies are installed for the duration of the test. A package is tested by running its test/runtests.jl file and test dependencies are specified in test/REQUIRE. Coverage statistics for the packages may be generated by passing coverage=true. The default behavior is not to run coverage.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#Base.Pkg.dependents",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Base.Pkg.dependents",
    "category": "Function",
    "text": "dependents(pkg)\n\nList the packages that have pkg as a dependency.\n\n\n\n"
},

{
    "location": "stdlib/pkg.html#pkg-1",
    "page": "Funciones del Administrador de Paquetes",
    "title": "Funciones del Administrador de Paquetes",
    "category": "section",
    "text": "Todas las funciones del administrador de paquetes están definidas en el módulo Pkg. Ninguna de las funciones del módulo Pkg están exportadas. Por tanto, para usarlas, necesitamos prefijar cada llamada a función con un Pkg. explícito, por ejemplo Pkg.status() o Pkg.dir().Las funciones para el desarrollo de paquetes (por ejemplo, tag, publish, etc.) se han movido al paquete PkgDev. Ver PkgDev README para la documentación de estas funciones.Base.Pkg.dir\nBase.Pkg.init\nBase.Pkg.resolve\nBase.Pkg.edit\nBase.Pkg.add\nBase.Pkg.rm\nBase.Pkg.clone\nBase.Pkg.setprotocol!\nBase.Pkg.available\nBase.Pkg.installed\nBase.Pkg.status\nBase.Pkg.update\nBase.Pkg.checkout\nBase.Pkg.pin\nBase.Pkg.free\nBase.Pkg.build\nBase.Pkg.test\nBase.Pkg.dependents"
},

{
    "location": "stdlib/dates.html#",
    "page": "Fechas y  Tiempo",
    "title": "Fechas y  Tiempo",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/dates.html#stdlib-dates-1",
    "page": "Fechas y  Tiempo",
    "title": "Fechas y  Tiempo",
    "category": "section",
    "text": ""
},

{
    "location": "stdlib/dates.html#Base.Dates.Period",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Period",
    "category": "Type",
    "text": "Period\nYear\nMonth\nWeek\nDay\nHour\nMinute\nSecond\nMillisecond\nMicrosecond\nNanosecond\n\nPeriod types represent discrete, human representations of time.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.CompoundPeriod",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.CompoundPeriod",
    "category": "Type",
    "text": "CompoundPeriod\n\nA CompoundPeriod is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, \"a year and a  day\" is not a fixed number of days, but can be expressed using a CompoundPeriod. In fact, a CompoundPeriod is automatically generated by addition of different period types, e.g. Year(1) + Day(1) produces a CompoundPeriod result.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Instant",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Instant",
    "category": "Type",
    "text": "Instant\n\nInstant types represent integer-based, machine representations of time as continuous timelines starting from an epoch.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.UTInstant",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.UTInstant",
    "category": "Type",
    "text": "UTInstant{T}\n\nThe UTInstant represents a machine timeline based on UT time (1 day = one revolution of the earth). The T is a Period parameter that indicates the resolution or precision of the instant.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.TimeType",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.TimeType",
    "category": "Type",
    "text": "TimeType\n\nTimeType types wrap Instant machine instances to provide human representations of the machine instant. Time, DateTime and Date are subtypes of TimeType.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.DateTime",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.DateTime",
    "category": "Type",
    "text": "DateTime\n\nDateTime wraps a UTInstant{Millisecond} and interprets it according to the proleptic Gregorian calendar.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Date",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Date",
    "category": "Type",
    "text": "Date\n\nDate wraps a UTInstant{Day} and interprets it according to the proleptic Gregorian calendar.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Time",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Time",
    "category": "Type",
    "text": "Time\n\nTime wraps a Nanosecond and represents a specific moment in a 24-hour day.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Tipos-para-Fechas-y-Tiempo-1",
    "page": "Fechas y  Tiempo",
    "title": "Tipos para Fechas y Tiempo",
    "category": "section",
    "text": "Base.Dates.Period\nBase.Dates.CompoundPeriod\nBase.Dates.Instant\nBase.Dates.UTInstant\nBase.Dates.TimeType\nBase.Dates.DateTime\nBase.Dates.Date\nBase.Dates.Time"
},

{
    "location": "stdlib/dates.html#Base.Dates.DateTime-NTuple{7,Int64}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.DateTime",
    "category": "Method",
    "text": "DateTime(y, [m, d, h, mi, s, ms]) -> DateTime\n\nConstruct a DateTime type by parts. Arguments must be convertible to Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.DateTime-Tuple{Vararg{Base.Dates.Period,N} where N}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.DateTime",
    "category": "Method",
    "text": "DateTime(periods::Period...) -> DateTime\n\nConstruct a DateTime type by Period type parts. Arguments may be in any order. DateTime parts not provided will default to the value of Dates.default(period).\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.DateTime-Tuple{Function,Vararg{Any,N} where N}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.DateTime",
    "category": "Method",
    "text": "DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), limit=10000) -> DateTime\n\nCreate a DateTime through the adjuster API. The starting point will be constructed from the provided y, m, d... arguments, and will be adjusted until f::Function returns true. The step size in adjusting can be provided manually through the step keyword. limit provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that f::Function is never satisfied).\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.DateTime-Tuple{Base.Dates.TimeType}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.DateTime",
    "category": "Method",
    "text": "DateTime(dt::Date) -> DateTime\n\nConverts a Date to a DateTime. The hour, minute, second, and millisecond parts of the new DateTime are assumed to be zero.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.DateTime-Tuple{AbstractString,AbstractString}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.DateTime",
    "category": "Method",
    "text": "DateTime(dt::AbstractString, format::AbstractString; locale=\"english\") -> DateTime\n\nConstruct a DateTime by parsing the dt date string following the pattern given in the format string.\n\nThis method creates a DateFormat object each time it is called. If you are parsing many date strings of the same format, consider creating a DateFormat object once and using that as the second argument instead.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.format-Tuple{Base.Dates.TimeType,AbstractString}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.format",
    "category": "Method",
    "text": "format(dt::TimeType, format::AbstractString; locale=\"english\") -> AbstractString\n\nConstruct a string by using a TimeType object and applying the provided format. The following character codes can be used to construct the format string:\n\nCode Examples Comment\ny 6 Numeric year with a fixed width\nY 1996 Numeric year with a minimum width\nm 1, 12 Numeric month with a minimum width\nu Jan Month name shortened to 3-chars according to the locale\nU January Full month name according to the locale keyword\nd 1, 31 Day of the month with a minimum width\nH 0, 23 Hour (24-hour clock) with a minimum width\nM 0, 59 Minute with a minimum width\nS 0, 59 Second with a minimum width\ns 000, 500 Millisecond with a minimum width of 3\ne Mon, Tue Abbreviated days of the week\nE Monday Full day of week name\n\nThe number of sequential code characters indicate the width of the code. A format of yyyy-mm specifies that the code y should have a width of four while m a width of two. Codes that yield numeric digits have an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros when it is shorter than the specified width and truncates the value when longer. Minimum-width mode works the same as fixed-width except that it does not truncate values longer than the width.\n\nWhen creating a format you can use any non-code characters as a separator. For example to generate the string \"1996-01-15T00:00:00\" you could use format: \"yyyy-mm-ddTHH:MM:SS\". Note that if you need to use a code character as a literal you can use the escape character backslash. The string \"1996y01m\" can be produced with the format \"yyyy\\ymm\\m\".\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.DateFormat",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.DateFormat",
    "category": "Type",
    "text": "DateFormat(format::AbstractString, locale=\"english\") -> DateFormat\n\nConstruct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the format string:\n\nCode Matches Comment\ny 1996, 96 Returns year of 1996, 0096\nY 1996, 96 Returns year of 1996, 0096. Equivalent to y\nm 1, 01 Matches 1 or 2-digit months\nu Jan Matches abbreviated months according to the locale keyword\nU January Matches full month names according to the locale keyword\nd 1, 01 Matches 1 or 2-digit days\nH 00 Matches hours\nM 00 Matches minutes\nS 00 Matches seconds\ns .500 Matches milliseconds\ne Mon, Tues Matches abbreviated days of the week\nE Monday Matches full name days of the week\nyyyymmdd 19960101 Matches fixed-width year, month, and day\n\nCharacters not listed above are normally treated as delimiters between date and time slots. For example a dt string of \"1996-01-15T00:00:00.0\" would have a format string like \"y-m-dTH:M:S.s\". If you need to use a code character as a delimiter you can escape it using backslash. The date \"1995y01m\" would have the format \"y\\ym\\m\".\n\nCreating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the dateformat\"\" string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see @dateformat_str.\n\nSee DateTime and format for how to use a DateFormat object to parse and write Date strings respectively.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.@dateformat_str",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.@dateformat_str",
    "category": "Macro",
    "text": "dateformat\"Y-m-d H:M:S\"\n\nCreate a DateFormat object. Similar to DateFormat(\"Y-m-d H:M:S\") but creates the DateFormat object once during macro expansion.\n\nSee DateFormat for details about format specifiers.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.DateTime-Tuple{AbstractString,DateFormat}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.DateTime",
    "category": "Method",
    "text": "DateTime(dt::AbstractString, df::DateFormat) -> DateTime\n\nConstruct a DateTime by parsing the dt date string following the pattern given in the DateFormat object. Similar to DateTime(::AbstractString, ::AbstractString) but more efficient when repeatedly parsing similarly formatted date strings with a pre-created DateFormat object.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Date-Tuple{Int64,Int64,Int64}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Date",
    "category": "Method",
    "text": "Date(y, [m, d]) -> Date\n\nConstruct a Date type by parts. Arguments must be convertible to Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Date-Tuple{Vararg{Base.Dates.Period,N} where N}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Date",
    "category": "Method",
    "text": "Date(period::Period...) -> Date\n\nConstruct a Date type by Period type parts. Arguments may be in any order. Date parts not provided will default to the value of Dates.default(period).\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Date-Tuple{Function,Any,Any,Any}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Date",
    "category": "Method",
    "text": "Date(f::Function, y[, m, d]; step=Day(1), limit=10000) -> Date\n\nCreate a Date through the adjuster API. The starting point will be constructed from the provided y, m, d arguments, and will be adjusted until f::Function returns true. The step size in adjusting can be provided manually through the step keyword. limit provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that f::Function is never satisfied).\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Date-Tuple{Base.Dates.TimeType}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Date",
    "category": "Method",
    "text": "Date(dt::DateTime) -> Date\n\nConverts a DateTime to a Date. The hour, minute, second, and millisecond parts of the DateTime are truncated, so only the year, month and day parts are used in construction.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Date-Tuple{AbstractString,AbstractString}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Date",
    "category": "Method",
    "text": "Date(dt::AbstractString, format::AbstractString; locale=\"english\") -> Date\n\nConstruct a Date object by parsing a dt date string following the pattern given in the format string. Follows the same conventions as DateTime(::AbstractString, ::AbstractString).\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Date-Tuple{AbstractString,DateFormat}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Date",
    "category": "Method",
    "text": "Date(dt::AbstractString, df::DateFormat) -> Date\n\nParse a date from a date string dt using a DateFormat object df.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Time-NTuple{5,Int64}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Time",
    "category": "Method",
    "text": "Time(h, [mi, s, ms, us, ns]) -> Time\n\nConstruct a Time type by parts. Arguments must be convertible to Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Time-Tuple{Vararg{Base.Dates.TimePeriod,N} where N}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Time",
    "category": "Method",
    "text": "Time(period::TimePeriod...) -> Time\n\nConstruct a Time type by Period type parts. Arguments may be in any order. Time parts not provided will default to the value of Dates.default(period).\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Time-Tuple{Function,Vararg{Any,N} where N}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Time",
    "category": "Method",
    "text": "Time(f::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)\nTime(f::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)\nTime(f::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)\nTime(f::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)\n\nCreate a Time through the adjuster API. The starting point will be constructed from the provided h, mi, s, ms, us arguments, and will be adjusted until f::Function returns true. The step size in adjusting can be provided manually through the step keyword. limit provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that f::Function is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be Millisecond(1) instead of Second(1).\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Time-Tuple{DateTime}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Time",
    "category": "Method",
    "text": "Time(dt::DateTime) -> Time\n\nConverts a DateTime to a Time. The hour, minute, second, and millisecond parts of the DateTime are used to create the new Time. Microsecond and nanoseconds are zero by default.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.now-Tuple{}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.now",
    "category": "Method",
    "text": "now() -> DateTime\n\nReturns a DateTime corresponding to the user's system time including the system timezone locale.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.now-Tuple{Type{Base.Dates.UTC}}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.now",
    "category": "Method",
    "text": "now(::Type{UTC}) -> DateTime\n\nReturns a DateTime corresponding to the user's system time as UTC/GMT.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.eps",
    "page": "Fechas y  Tiempo",
    "title": "Base.eps",
    "category": "Function",
    "text": "eps(::DateTime) -> Millisecond\neps(::Date) -> Day\neps(::Time) -> Nanosecond\n\nReturns Millisecond(1) for DateTime values, Day(1) for Date values, and Nanosecond(1) for Time values.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Funciones-para-Fechas-1",
    "page": "Fechas y  Tiempo",
    "title": "Funciones para Fechas",
    "category": "section",
    "text": "Todas las funciones para fechas están definidas en el módulo Dates; nótese que solo se han exportado las funciones Date, DateTime y now; para usar el resto de funciones de Dates, es necesario prefijar cada llamada a función con Dates., por ejemplo,Dates.dayofweek(dt). Alternativamente, se puede escribir using Base.Dates para llevar todas las funciones exportadas a Main y que sean usadas sin el prefijo Dates.Base.Dates.DateTime(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\nBase.Dates.DateTime(::Base.Dates.Period...)\nBase.Dates.DateTime(::Function, ::Any...)\nBase.Dates.DateTime(::Base.Dates.TimeType)\nBase.Dates.DateTime(::AbstractString, ::AbstractString)\nBase.Dates.format(::Base.Dates.TimeType, ::AbstractString)\nBase.Dates.DateFormat\nBase.Dates.@dateformat_str\nBase.Dates.DateTime(::AbstractString, ::Base.Dates.DateFormat)\nBase.Dates.Date(::Int64, ::Int64, ::Int64)\nBase.Dates.Date(::Base.Dates.Period...)\nBase.Dates.Date(::Function, ::Any, ::Any, ::Any)\nBase.Dates.Date(::Base.Dates.TimeType)\nBase.Dates.Date(::AbstractString, ::AbstractString)\nBase.Dates.Date(::AbstractString, ::Base.Dates.DateFormat)\nBase.Dates.Time(::Int64::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\nBase.Dates.Time(::Base.Dates.TimePeriod...)\nBase.Dates.Time(::Function, ::Any...)\nBase.Dates.Time(::Base.Dates.DateTime)\nBase.Dates.now()\nBase.Dates.now(::Type{Base.Dates.UTC})\nBase.eps"
},

{
    "location": "stdlib/dates.html#Base.Dates.year",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.year",
    "category": "Function",
    "text": "year(dt::TimeType) -> Int64\n\nThe year of a Date or DateTime as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.month",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.month",
    "category": "Function",
    "text": "month(dt::TimeType) -> Int64\n\nThe month of a Date or DateTime as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.week",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.week",
    "category": "Function",
    "text": "week(dt::TimeType) -> Int64\n\nReturn the ISO week date of a Date or DateTime as an Int64. Note that the first week of a year is the week that contains the first Thursday of the year which can result in dates prior to January 4th being in the last week of the previous year. For example week(Date(2005,1,1)) is the 53rd week of 2004.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.day",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.day",
    "category": "Function",
    "text": "day(dt::TimeType) -> Int64\n\nThe day of month of a Date or DateTime as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.hour",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.hour",
    "category": "Function",
    "text": "hour(dt::DateTime) -> Int64\n\nThe hour of day of a DateTime as an Int64.\n\n\n\nhour(t::Time) -> Int64\n\nThe hour of a Time as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.minute",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.minute",
    "category": "Function",
    "text": "minute(dt::DateTime) -> Int64\n\nThe minute of a DateTime as an Int64.\n\n\n\nminute(t::Time) -> Int64\n\nThe minute of a Time as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.second",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.second",
    "category": "Function",
    "text": "second(dt::DateTime) -> Int64\n\nThe second of a DateTime as an Int64.\n\n\n\nsecond(t::Time) -> Int64\n\nThe second of a Time as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.millisecond",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.millisecond",
    "category": "Function",
    "text": "millisecond(dt::DateTime) -> Int64\n\nThe millisecond of a DateTime as an Int64.\n\n\n\nmillisecond(t::Time) -> Int64\n\nThe millisecond of a Time as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.microsecond",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.microsecond",
    "category": "Function",
    "text": "microsecond(t::Time) -> Int64\n\nThe microsecond of a Time as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.nanosecond",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.nanosecond",
    "category": "Function",
    "text": "nanosecond(t::Time) -> Int64\n\nThe nanosecond of a Time as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Year-Tuple{Base.Dates.TimeType}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Year",
    "category": "Method",
    "text": "Year(v)\n\nConstruct a Year object with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Month-Tuple{Base.Dates.TimeType}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Month",
    "category": "Method",
    "text": "Month(v)\n\nConstruct a Month object with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Week-Tuple{Base.Dates.TimeType}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Week",
    "category": "Method",
    "text": "Week(v)\n\nConstruct a Week object with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Day-Tuple{Base.Dates.TimeType}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Day",
    "category": "Method",
    "text": "Day(v)\n\nConstruct a Day object with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Hour-Tuple{DateTime}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Hour",
    "category": "Method",
    "text": "Hour(dt::DateTime) -> Hour\n\nThe hour part of a DateTime as a Hour.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Minute-Tuple{DateTime}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Minute",
    "category": "Method",
    "text": "Minute(dt::DateTime) -> Minute\n\nThe minute part of a DateTime as a Minute.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Second-Tuple{DateTime}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Second",
    "category": "Method",
    "text": "Second(dt::DateTime) -> Second\n\nThe second part of a DateTime as a Second.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Millisecond-Tuple{DateTime}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Millisecond",
    "category": "Method",
    "text": "Millisecond(dt::DateTime) -> Millisecond\n\nThe millisecond part of a DateTime as a Millisecond.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Microsecond-Tuple{Base.Dates.Time}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Microsecond",
    "category": "Method",
    "text": "Microsecond(dt::Time) -> Microsecond\n\nThe microsecond part of a Time as a Microsecond.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.Nanosecond-Tuple{Base.Dates.Time}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Nanosecond",
    "category": "Method",
    "text": "Nanosecond(dt::Time) -> Nanosecond\n\nThe nanosecond part of a Time as a Nanosecond.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.yearmonth",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.yearmonth",
    "category": "Function",
    "text": "yearmonth(dt::TimeType) -> (Int64, Int64)\n\nSimultaneously return the year and month parts of a Date or DateTime.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.monthday",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.monthday",
    "category": "Function",
    "text": "monthday(dt::TimeType) -> (Int64, Int64)\n\nSimultaneously return the month and day parts of a Date or DateTime.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.yearmonthday",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.yearmonthday",
    "category": "Function",
    "text": "yearmonthday(dt::TimeType) -> (Int64, Int64, Int64)\n\nSimultaneously return the year, month and day parts of a Date or DateTime.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Funciones-de-Acceso-1",
    "page": "Fechas y  Tiempo",
    "title": "Funciones de Acceso",
    "category": "section",
    "text": "Base.Dates.year\nBase.Dates.month\nBase.Dates.week\nBase.Dates.day\nBase.Dates.hour\nBase.Dates.minute\nBase.Dates.second\nBase.Dates.millisecond\nBase.Dates.microsecond\nBase.Dates.nanosecond\nBase.Dates.Year(::Base.Dates.TimeType)\nBase.Dates.Month(::Base.Dates.TimeType)\nBase.Dates.Week(::Base.Dates.TimeType)\nBase.Dates.Day(::Base.Dates.TimeType)\nBase.Dates.Hour(::DateTime)\nBase.Dates.Minute(::DateTime)\nBase.Dates.Second(::DateTime)\nBase.Dates.Millisecond(::DateTime)\nBase.Dates.Microsecond(::Dates.Time)\nBase.Dates.Nanosecond(::Dates.Time)\nBase.Dates.yearmonth\nBase.Dates.monthday\nBase.Dates.yearmonthday"
},

{
    "location": "stdlib/dates.html#Base.Dates.dayname",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.dayname",
    "category": "Function",
    "text": "dayname(dt::TimeType; locale=\"english\") -> AbstractString\n\nReturn the full day name corresponding to the day of the week of the Date or DateTime in the given locale.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.dayabbr",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.dayabbr",
    "category": "Function",
    "text": "dayabbr(dt::TimeType; locale=\"english\") -> AbstractString\n\nReturn the abbreviated name corresponding to the day of the week of the Date or DateTime in the given locale.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.dayofweek",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.dayofweek",
    "category": "Function",
    "text": "dayofweek(dt::TimeType) -> Int64\n\nReturns the day of the week as an Int64 with 1 = Monday, 2 = Tuesday, etc..\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.dayofmonth",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.dayofmonth",
    "category": "Function",
    "text": "dayofmonth(dt::TimeType) -> Int64\n\nThe day of month of a Date or DateTime as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.dayofweekofmonth",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.dayofweekofmonth",
    "category": "Function",
    "text": "dayofweekofmonth(dt::TimeType) -> Int\n\nFor the day of week of dt, returns which number it is in dt's month. So if the day of the week of dt is Monday, then 1 = First Monday of the month, 2 = Second Monday of the month, etc. In the range 1:5.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.daysofweekinmonth",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.daysofweekinmonth",
    "category": "Function",
    "text": "daysofweekinmonth(dt::TimeType) -> Int\n\nFor the day of week of dt, returns the total number of that day of the week in dt's month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including dayofweekofmonth(dt) == daysofweekinmonth(dt) in the adjuster function.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.monthname",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.monthname",
    "category": "Function",
    "text": "monthname(dt::TimeType; locale=\"english\") -> AbstractString\n\nReturn the full name of the month of the Date or DateTime in the given locale.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.monthabbr",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.monthabbr",
    "category": "Function",
    "text": "monthabbr(dt::TimeType; locale=\"english\") -> AbstractString\n\nReturn the abbreviated month name of the Date or DateTime in the given locale.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.daysinmonth",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.daysinmonth",
    "category": "Function",
    "text": "daysinmonth(dt::TimeType) -> Int\n\nReturns the number of days in the month of dt. Value will be 28, 29, 30, or 31.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.isleapyear",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.isleapyear",
    "category": "Function",
    "text": "isleapyear(dt::TimeType) -> Bool\n\nReturns true if the year of dt is a leap year.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.dayofyear",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.dayofyear",
    "category": "Function",
    "text": "dayofyear(dt::TimeType) -> Int\n\nReturns the day of the year for dt with January 1st being day 1.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.daysinyear",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.daysinyear",
    "category": "Function",
    "text": "daysinyear(dt::TimeType) -> Int\n\nReturns 366 if the year of dt is a leap year, otherwise returns 365.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.quarterofyear",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.quarterofyear",
    "category": "Function",
    "text": "quarterofyear(dt::TimeType) -> Int\n\nReturns the quarter that dt resides in. Range of value is 1:4.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.dayofquarter",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.dayofquarter",
    "category": "Function",
    "text": "dayofquarter(dt::TimeType) -> Int\n\nReturns the day of the current quarter of dt. Range of value is 1:92.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Funciones-de-Consulta-1",
    "page": "Fechas y  Tiempo",
    "title": "Funciones de Consulta",
    "category": "section",
    "text": "Base.Dates.dayname\nBase.Dates.dayabbr\nBase.Dates.dayofweek\nBase.Dates.dayofmonth\nBase.Dates.dayofweekofmonth\nBase.Dates.daysofweekinmonth\nBase.Dates.monthname\nBase.Dates.monthabbr\nBase.Dates.daysinmonth\nBase.Dates.isleapyear\nBase.Dates.dayofyear\nBase.Dates.daysinyear\nBase.Dates.quarterofyear\nBase.Dates.dayofquarter"
},

{
    "location": "stdlib/dates.html#Base.trunc-Tuple{Base.Dates.TimeType,Type{Base.Dates.Period}}",
    "page": "Fechas y  Tiempo",
    "title": "Base.trunc",
    "category": "Method",
    "text": "trunc(dt::TimeType, ::Type{Period}) -> TimeType\n\nTruncates the value of dt according to the provided Period type. E.g. if dt is 1996-01-01T12:30:00, then trunc(dt,Day) == 1996-01-01T00:00:00.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.firstdayofweek",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.firstdayofweek",
    "category": "Function",
    "text": "firstdayofweek(dt::TimeType) -> TimeType\n\nAdjusts dt to the Monday of its week.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.lastdayofweek",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.lastdayofweek",
    "category": "Function",
    "text": "lastdayofweek(dt::TimeType) -> TimeType\n\nAdjusts dt to the Sunday of its week.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.firstdayofmonth",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.firstdayofmonth",
    "category": "Function",
    "text": "firstdayofmonth(dt::TimeType) -> TimeType\n\nAdjusts dt to the first day of its month.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.lastdayofmonth",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.lastdayofmonth",
    "category": "Function",
    "text": "lastdayofmonth(dt::TimeType) -> TimeType\n\nAdjusts dt to the last day of its month.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.firstdayofyear",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.firstdayofyear",
    "category": "Function",
    "text": "firstdayofyear(dt::TimeType) -> TimeType\n\nAdjusts dt to the first day of its year.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.lastdayofyear",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.lastdayofyear",
    "category": "Function",
    "text": "lastdayofyear(dt::TimeType) -> TimeType\n\nAdjusts dt to the last day of its year.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.firstdayofquarter",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.firstdayofquarter",
    "category": "Function",
    "text": "firstdayofquarter(dt::TimeType) -> TimeType\n\nAdjusts dt to the first day of its quarter.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.lastdayofquarter",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.lastdayofquarter",
    "category": "Function",
    "text": "lastdayofquarter(dt::TimeType) -> TimeType\n\nAdjusts dt to the last day of its quarter.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.tonext-Tuple{Base.Dates.TimeType,Int64}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.tonext",
    "category": "Method",
    "text": "tonext(dt::TimeType, dow::Int; same::Bool=false) -> TimeType\n\nAdjusts dt to the next day of week corresponding to dow with 1 = Monday, 2 = Tuesday, etc. Setting same=true allows the current dt to be considered as the next dow, allowing for no adjustment to occur.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.toprev-Tuple{Base.Dates.TimeType,Int64}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.toprev",
    "category": "Method",
    "text": "toprev(dt::TimeType, dow::Int; same::Bool=false) -> TimeType\n\nAdjusts dt to the previous day of week corresponding to dow with 1 = Monday, 2 = Tuesday, etc. Setting same=true allows the current dt to be considered as the previous dow, allowing for no adjustment to occur.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.tofirst",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.tofirst",
    "category": "Function",
    "text": "tofirst(dt::TimeType, dow::Int; of=Month) -> TimeType\n\nAdjusts dt to the first dow of its month. Alternatively, of=Year will adjust to the first dow of the year.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.tolast",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.tolast",
    "category": "Function",
    "text": "tolast(dt::TimeType, dow::Int; of=Month) -> TimeType\n\nAdjusts dt to the last dow of its month. Alternatively, of=Year will adjust to the last dow of the year.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.tonext-Tuple{Function,Base.Dates.TimeType}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.tonext",
    "category": "Method",
    "text": "tonext(func::Function, dt::TimeType; step=Day(1), limit=10000, same=false) -> TimeType\n\nAdjusts dt by iterating at most limit iterations by step increments until func returns true. func must take a single TimeType argument and return a Bool. same allows dt to be considered in satisfying func.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.toprev-Tuple{Function,Base.Dates.TimeType}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.toprev",
    "category": "Method",
    "text": "toprev(func::Function, dt::TimeType; step=Day(-1), limit=10000, same=false) -> TimeType\n\nAdjusts dt by iterating at most limit iterations by step increments until func returns true. func must take a single TimeType argument and return a Bool. same allows dt to be considered in satisfying func.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Funciones-de-Ajuste-1",
    "page": "Fechas y  Tiempo",
    "title": "Funciones de Ajuste",
    "category": "section",
    "text": "Base.trunc(::Base.Dates.TimeType, ::Type{Base.Dates.Period})\nBase.Dates.firstdayofweek\nBase.Dates.lastdayofweek\nBase.Dates.firstdayofmonth\nBase.Dates.lastdayofmonth\nBase.Dates.firstdayofyear\nBase.Dates.lastdayofyear\nBase.Dates.firstdayofquarter\nBase.Dates.lastdayofquarter\nBase.Dates.tonext(::Base.Dates.TimeType, ::Int)\nBase.Dates.toprev(::Base.Dates.TimeType, ::Int)\nBase.Dates.tofirst\nBase.Dates.tolast\nBase.Dates.tonext(::Function, ::Base.Dates.TimeType)\nBase.Dates.toprev(::Function, ::Base.Dates.TimeType)"
},

{
    "location": "stdlib/dates.html#Base.Dates.Period-Tuple{Any}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.Period",
    "category": "Method",
    "text": "Year(v)\nMonth(v)\nWeek(v)\nDay(v)\nHour(v)\nMinute(v)\nSecond(v)\nMillisecond(v)\nMicrosecond(v)\nNanosecond(v)\n\nConstruct a Period type with the given v value. Input must be losslessly convertible to an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.CompoundPeriod-Tuple{Array{#s27,1} where #s27<:Base.Dates.Period}",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.CompoundPeriod",
    "category": "Method",
    "text": "CompoundPeriod(periods) -> CompoundPeriod\n\nConstruct a CompoundPeriod from a Vector of Periods. All Periods of the same type will be added together.\n\nExamples\n\njulia> Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))\n25 hours\n\njulia> Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))\n-1 hour, 1 minute\n\njulia> Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))\n1 month, -2 weeks\n\njulia> Dates.CompoundPeriod(Dates.Minute(50000))\n50000 minutes\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.default",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.default",
    "category": "Function",
    "text": "default(p::Period) -> Period\n\nReturns a sensible \"default\" value for the input Period by returning T(1) for Year, Month, and Day, and T(0) for Hour, Minute, Second, and Millisecond.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Períodos-1",
    "page": "Fechas y  Tiempo",
    "title": "Períodos",
    "category": "section",
    "text": "Base.Dates.Period(::Any)\nBase.Dates.CompoundPeriod(::Vector{<:Base.Dates.Period})\nBase.Dates.default"
},

{
    "location": "stdlib/dates.html#Base.floor-Tuple{Base.Dates.TimeType,Base.Dates.Period}",
    "page": "Fechas y  Tiempo",
    "title": "Base.floor",
    "category": "Method",
    "text": "floor(dt::TimeType, p::Period) -> TimeType\n\nReturns the nearest Date or DateTime less than or equal to dt at resolution p.\n\nFor convenience, p may be a type instead of a value: floor(dt, Dates.Hour) is a shortcut for floor(dt, Dates.Hour(1)).\n\njulia> floor(Date(1985, 8, 16), Dates.Month)\n1985-08-01\n\njulia> floor(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n2013-02-13T00:30:00\n\njulia> floor(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)\n2016-08-06T00:00:00\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.ceil-Tuple{Base.Dates.TimeType,Base.Dates.Period}",
    "page": "Fechas y  Tiempo",
    "title": "Base.ceil",
    "category": "Method",
    "text": "ceil(dt::TimeType, p::Period) -> TimeType\n\nReturns the nearest Date or DateTime greater than or equal to dt at resolution p.\n\nFor convenience, p may be a type instead of a value: ceil(dt, Dates.Hour) is a shortcut for ceil(dt, Dates.Hour(1)).\n\njulia> ceil(Date(1985, 8, 16), Dates.Month)\n1985-09-01\n\njulia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n2013-02-13T00:45:00\n\njulia> ceil(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)\n2016-08-07T00:00:00\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.round-Tuple{Base.Dates.TimeType,Base.Dates.Period,RoundingMode{:NearestTiesUp}}",
    "page": "Fechas y  Tiempo",
    "title": "Base.round",
    "category": "Method",
    "text": "round(dt::TimeType, p::Period, [r::RoundingMode]) -> TimeType\n\nReturns the Date or DateTime nearest to dt at resolution p. By default (RoundNearestTiesUp), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.\n\nFor convenience, p may be a type instead of a value: round(dt, Dates.Hour) is a shortcut for round(dt, Dates.Hour(1)).\n\njulia> round(Date(1985, 8, 16), Dates.Month)\n1985-08-01\n\njulia> round(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))\n2013-02-13T00:30:00\n\njulia> round(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)\n2016-08-07T00:00:00\n\nValid rounding modes for round(::TimeType, ::Period, ::RoundingMode) are RoundNearestTiesUp (default), RoundDown (floor), and RoundUp (ceil).\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.floorceil",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.floorceil",
    "category": "Function",
    "text": "floorceil(dt::TimeType, p::Period) -> (TimeType, TimeType)\n\nSimultaneously return the floor and ceil of a Date or DateTime at resolution p. More efficient than calling both floor and ceil individually.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.epochdays2date",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.epochdays2date",
    "category": "Function",
    "text": "epochdays2date(days) -> Date\n\nTakes the number of days since the rounding epoch (0000-01-01T00:00:00) and returns the corresponding Date.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.epochms2datetime",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.epochms2datetime",
    "category": "Function",
    "text": "epochms2datetime(milliseconds) -> DateTime\n\nTakes the number of milliseconds since the rounding epoch (0000-01-01T00:00:00) and returns the corresponding DateTime.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.date2epochdays",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.date2epochdays",
    "category": "Function",
    "text": "date2epochdays(dt::Date) -> Int64\n\nTakes the given Date and returns the number of days since the rounding epoch (0000-01-01T00:00:00) as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.datetime2epochms",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.datetime2epochms",
    "category": "Function",
    "text": "datetime2epochms(dt::DateTime) -> Int64\n\nTakes the given DateTime and returns the number of milliseconds since the rounding epoch (0000-01-01T00:00:00) as an Int64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Funciones-de-Redondeo-1",
    "page": "Fechas y  Tiempo",
    "title": "Funciones de Redondeo",
    "category": "section",
    "text": "Los valores Date y DateTime pueden ser redondeados a una precisión especificada (por ejemplo, 1 mes o 15 minutos) con floor, ceil, o round.Base.floor(::Base.Dates.TimeType, ::Base.Dates.Period)\nBase.ceil(::Base.Dates.TimeType, ::Base.Dates.Period)\nBase.round(::Base.Dates.TimeType, ::Base.Dates.Period, ::RoundingMode{:NearestTiesUp})Las siguientes funciones no están exportadas:Base.Dates.floorceil\nBase.Dates.epochdays2date\nBase.Dates.epochms2datetime\nBase.Dates.date2epochdays\nBase.Dates.datetime2epochms"
},

{
    "location": "stdlib/dates.html#Base.Dates.today",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.today",
    "category": "Function",
    "text": "today() -> Date\n\nReturns the date portion of now().\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.unix2datetime",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.unix2datetime",
    "category": "Function",
    "text": "unix2datetime(x) -> DateTime\n\nTakes the number of seconds since unix epoch 1970-01-01T00:00:00 and converts to the corresponding DateTime.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.datetime2unix",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.datetime2unix",
    "category": "Function",
    "text": "datetime2unix(dt::DateTime) -> Float64\n\nTakes the given DateTime and returns the number of seconds since the unix epoch 1970-01-01T00:00:00 as a Float64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.julian2datetime",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.julian2datetime",
    "category": "Function",
    "text": "julian2datetime(julian_days) -> DateTime\n\nTakes the number of Julian calendar days since epoch -4713-11-24T12:00:00 and returns the corresponding DateTime.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.datetime2julian",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.datetime2julian",
    "category": "Function",
    "text": "datetime2julian(dt::DateTime) -> Float64\n\nTakes the given DateTime and returns the number of Julian calendar days since the julian epoch -4713-11-24T12:00:00 as a Float64.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.rata2datetime",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.rata2datetime",
    "category": "Function",
    "text": "rata2datetime(days) -> DateTime\n\nTakes the number of Rata Die days since epoch 0000-12-31T00:00:00 and returns the corresponding DateTime.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Base.Dates.datetime2rata",
    "page": "Fechas y  Tiempo",
    "title": "Base.Dates.datetime2rata",
    "category": "Function",
    "text": "datetime2rata(dt::TimeType) -> Int64\n\nReturns the number of Rata Die days since epoch from the given Date or DateTime.\n\n\n\n"
},

{
    "location": "stdlib/dates.html#Funciones-de-Conversión-1",
    "page": "Fechas y  Tiempo",
    "title": "Funciones de Conversión",
    "category": "section",
    "text": "Base.Dates.today\nBase.Dates.unix2datetime\nBase.Dates.datetime2unix\nBase.Dates.julian2datetime\nBase.Dates.datetime2julian\nBase.Dates.rata2datetime\nBase.Dates.datetime2rata"
},

{
    "location": "stdlib/dates.html#Constantes-1",
    "page": "Fechas y  Tiempo",
    "title": "Constantes",
    "category": "section",
    "text": "Días de la Semana:Variable Abbr. Value (Int)\nMonday Mon 1\nTuesday Tue 2\nWednesday Wed 3\nThursday Thu 4\nFriday Fri 5\nSaturday Sat 6\nSunday Sun 7Meses del Año:Variable Abbr. Value (Int)\nJanuary Jan 1\nFebruary Feb 2\nMarch Mar 3\nApril Apr 4\nMay May 5\nJune Jun 6\nJuly Jul 7\nAugust Aug 8\nSeptember Sep 9\nOctober Oct 10\nNovember Nov 11\nDecember Dec 12"
},

{
    "location": "stdlib/iterators.html#",
    "page": "Utilidades para Iteración",
    "title": "Utilidades para Iteración",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/iterators.html#Base.Iterators.zip",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.zip",
    "category": "Function",
    "text": "zip(iters...)\n\nFor a set of iterable objects, returns an iterable of tuples, where the ith tuple contains the ith component of each input iterable.\n\nNote that zip is its own inverse: collect(zip(zip(a...)...)) == collect(a).\n\nExample\n\njulia> a = 1:5\n1:5\n\njulia> b = [\"e\",\"d\",\"b\",\"c\",\"a\"]\n5-element Array{String,1}:\n \"e\"\n \"d\"\n \"b\"\n \"c\"\n \"a\"\n\njulia> c = zip(a,b)\nBase.Iterators.Zip2{UnitRange{Int64},Array{String,1}}(1:5, String[\"e\", \"d\", \"b\", \"c\", \"a\"])\n\njulia> length(c)\n5\n\njulia> first(c)\n(1, \"e\")\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.enumerate",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.enumerate",
    "category": "Function",
    "text": "enumerate(iter)\n\nAn iterator that yields (i, x) where i is a counter starting at 1, and x is the ith value from the given iterator. It's useful when you need not only the values x over which you are iterating, but also the number of iterations so far. Note that i may not be valid for indexing iter; it's also possible that x != iter[i], if iter has indices that do not start at 1. See the enumerate(IndexLinear(), iter) method if you want to ensure that i is an index.\n\nExample\n\njulia> a = [\"a\", \"b\", \"c\"];\n\njulia> for (index, value) in enumerate(a)\n           println(\"$index $value\")\n       end\n1 a\n2 b\n3 c\n\n\n\nenumerate(IndexLinear(), A)\nenumerate(IndexCartesian(), A)\nenumerate(IndexStyle(A), A)\n\nAn iterator that accesses each element of the array A, returning (i, x), where i is the index for the element and x = A[i].  This is similar to enumerate(A), except i will always be a valid index for A.\n\nSpecifying IndexLinear() ensures that i will be an integer; specifying IndexCartesian() ensures that i will be a CartesianIndex; specifying IndexStyle(A) chooses whichever has been defined as the native indexing style for array A.\n\nExamples\n\njulia> A = [\"a\" \"d\"; \"b\" \"e\"; \"c\" \"f\"];\n\njulia> for (index, value) in enumerate(IndexStyle(A), A)\n           println(\"$index $value\")\n       end\n1 a\n2 b\n3 c\n4 d\n5 e\n6 f\n\njulia> S = view(A, 1:2, :);\n\njulia> for (index, value) in enumerate(IndexStyle(S), S)\n           println(\"$index $value\")\n       end\nCartesianIndex{2}((1, 1)) a\nCartesianIndex{2}((2, 1)) b\nCartesianIndex{2}((1, 2)) d\nCartesianIndex{2}((2, 2)) e\n\nNote that enumerate(A) returns i as a counter (always starting at 1), whereas enumerate(IndexLinear(), A) returns i as an index (starting at the first linear index of A, which may or may not be 1).\n\nSee also: IndexStyle, indices.\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.rest",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.rest",
    "category": "Function",
    "text": "rest(iter, state)\n\nAn iterator that yields the same elements as iter, but starting at the given state.\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.countfrom",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.countfrom",
    "category": "Function",
    "text": "countfrom(start=1, step=1)\n\nAn iterator that counts forever, starting at start and incrementing by step.\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.take",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.take",
    "category": "Function",
    "text": "take(iter, n)\n\nAn iterator that generates at most the first n elements of iter.\n\nExample\n\njulia> a = 1:2:11\n1:2:11\n\njulia> collect(a)\n6-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> collect(Iterators.take(a,3))\n3-element Array{Int64,1}:\n 1\n 3\n 5\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.drop",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.drop",
    "category": "Function",
    "text": "drop(iter, n)\n\nAn iterator that generates all but the first n elements of iter.\n\nExample\n\njulia> a = 1:2:11\n1:2:11\n\njulia> collect(a)\n6-element Array{Int64,1}:\n  1\n  3\n  5\n  7\n  9\n 11\n\njulia> collect(Iterators.drop(a,4))\n2-element Array{Int64,1}:\n  9\n 11\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.cycle",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.cycle",
    "category": "Function",
    "text": "cycle(iter)\n\nAn iterator that cycles through iter forever.\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.repeated",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.repeated",
    "category": "Function",
    "text": "repeated(x[, n::Int])\n\nAn iterator that generates the value x forever. If n is specified, generates x that many times (equivalent to take(repeated(x), n)).\n\nExample\n\njulia> a = Iterators.repeated([1 2], 4);\n\njulia> collect(a)\n4-element Array{Array{Int64,2},1}:\n [1 2]\n [1 2]\n [1 2]\n [1 2]\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.product",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.product",
    "category": "Function",
    "text": "product(iters...)\n\nReturns an iterator over the product of several iterators. Each generated element is a tuple whose ith element comes from the ith argument iterator. The first iterator changes the fastest. Example:\n\nExample\n\njulia> collect(Iterators.product(1:2,3:5))\n2×3 Array{Tuple{Int64,Int64},2}:\n (1, 3)  (1, 4)  (1, 5)\n (2, 3)  (2, 4)  (2, 5)\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.flatten",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.flatten",
    "category": "Function",
    "text": "flatten(iter)\n\nGiven an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.\n\nExample\n\njulia> collect(Iterators.flatten((1:2, 8:9)))\n4-element Array{Int64,1}:\n 1\n 2\n 8\n 9\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#Base.Iterators.partition",
    "page": "Utilidades para Iteración",
    "title": "Base.Iterators.partition",
    "category": "Function",
    "text": "partition(collection, n)\n\nIterate over a collection n elements at a time.\n\nExample\n\njulia> collect(Iterators.partition([1,2,3,4,5], 2))\n3-element Array{Array{Int64,1},1}:\n [1, 2]\n [3, 4]\n [5]\n\n\n\n"
},

{
    "location": "stdlib/iterators.html#iterators-1",
    "page": "Utilidades para Iteración",
    "title": "Utilidades para Iteración",
    "category": "section",
    "text": "Base.Iterators.zip\nBase.Iterators.enumerate\nBase.Iterators.rest\nBase.Iterators.countfrom\nBase.Iterators.take\nBase.Iterators.drop\nBase.Iterators.cycle\nBase.Iterators.repeated\nBase.Iterators.product\nBase.Iterators.flatten\nBase.Iterators.partition"
},

{
    "location": "stdlib/test.html#",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Haciendo Pruebas Unitarias",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/test.html#test-1",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Haciendo Pruebas Unitarias",
    "category": "section",
    "text": "DocTestSetup = quote\n    using Base.Test\nend"
},

{
    "location": "stdlib/test.html#Base.runtests",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.runtests",
    "category": "Function",
    "text": "runtests([tests=[\"all\"] [, numcores=ceil(Int, Sys.CPU_CORES / 2) ]])\n\nRun the Julia unit tests listed in tests, which can be either a string or an array of strings, using numcores processors. (not exported)\n\n\n\n"
},

{
    "location": "stdlib/test.html#Probando-Julia-Base-1",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Probando Julia Base",
    "category": "section",
    "text": "Julia está en rápido desarrollo y cuenta con un amplio conjunto de pruebas para verificar su funcionalidad en múltiples plataformas. Si compila Julia desde el origen, puede ejecutar este conjunto de pruebas con make test. En una instalación binaria, puede ejecutar el conjunto de pruebas utilizando Base.runtests().Base.runtests"
},

{
    "location": "stdlib/test.html#Base.Test.@test",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.@test",
    "category": "Macro",
    "text": "@test ex\n@test f(args...) key=val ...\n\nTests that the expression ex evaluates to true. Returns a Pass Result if it does, a Fail Result if it is false, and an Error Result if it could not be evaluated.\n\nThe @test f(args...) key=val... form is equivalent to writing @test f(args..., key=val...) which can be useful when the expression is a call using infix syntax such as approximate comparisons:\n\n@test a ≈ b atol=ε\n\nThis is equivalent to the uglier test @test ≈(a, b, atol=ε). It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (k=v).\n\n\n\n"
},

{
    "location": "stdlib/test.html#Base.Test.@test_throws",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.@test_throws",
    "category": "Macro",
    "text": "@test_throws extype ex\n\nTests that the expression ex throws an exception of type extype. Note that @test_throws does not support a trailing keyword form.\n\n\n\n"
},

{
    "location": "stdlib/test.html#Pruebas-Unitarias-Básicas-1",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Pruebas Unitarias Básicas",
    "category": "section",
    "text": "El módulo Base.Test proporciona una funcionalidad simple de realización de pruebas unitarias. Las pruebas unitarias son una forma de ver si su código es correcto al verificar que los resultados sean los esperados. Puede ser útil asegurarse de que su código aún funcione después de realizar los cambios, y se puede usar al desarrollar como una forma de especificar los comportamientos que su código debería tener cuando se complete.Se pueden realizar pruebas unitarias simples con las macros @test () y @test_throws ():Base.Test.@test\nBase.Test.@test_throwsPor ejemplo, supongamos que queremos comprobar que nuestra nueva función foo(x) funciona como se esperaba:julia> using Base.Test\n\njulia> foo(x) = length(x)^2\nfoo (función genérica con 1 método)Si la condición es cierta, se devuelve un Pass:julia> @test foo(\"bar\") == 9\nTest Passed\n\njulia> @test foo(\"fizz\") >= 10\nTest PassedSi la condición es falsa, se devuelve un Fail y se lanza una excepción:julia> @test foo(\"f\") == 20\nTest Failed\n  Expression: foo(\"f\") == 20\n   Evaluated: 1 == 20\nERROR: There was an error during testingSi la condición no pudo ser evaluada porque se lanzó una excepción, lo que ocurre en este caso porque length() no está definido para símbolos, se devuelve un objeto Error y se lanza una excepción:julia> @test foo(:cat) == 1\nError During Test\n  Test threw an exception of type MethodError\n  Expression: foo(:cat) == 1\n  MethodError: no method matching length(::Symbol)\n  Closest candidates are:\n    length(::SimpleVector) at essentials.jl:256\n    length(::Base.MethodList) at reflection.jl:521\n    length(::MethodTable) at reflection.jl:597\n    ...\n  Stacktrace:\n   [...]\nERROR: There was an error during testingSi esperamos que al evaluar una expresión debería lanzarse una excepción, entonces podemos usar @test_throws() para comprobar que esto es lo que ocurre:julia> @test_throws MethodError foo(:cat)\nTest Passed\n      Thrown: MethodError"
},

{
    "location": "stdlib/test.html#Base.Test.@testset",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.@testset",
    "category": "Macro",
    "text": "@testset [CustomTestSet] [option=val  ...] [\"description\"] begin ... end\n@testset [CustomTestSet] [option=val  ...] [\"description $v\"] for v in (...) ... end\n@testset [CustomTestSet] [option=val  ...] [\"description $v, $w\"] for v in (...), w in (...) ... end\n\nStarts a new test set, or multiple test sets if a for loop is provided.\n\nIf no custom testset type is given it defaults to creating a DefaultTestSet. DefaultTestSet records all the results and, if there are any Fails or Errors, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.\n\nAny custom testset type (subtype of AbstractTestSet) can be given and it will also be used for any nested @testset invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.\n\nThe description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.\n\nBy default the @testset macro will return the testset object itself, though this behavior can be customized in other testset types. If a for loop is used then the macro collects and returns a list of the return values of the finish method, which by default will return a list of the testset objects used in each iteration.\n\n\n\n"
},

{
    "location": "stdlib/test.html#Trabajando-con-Conjuntos-de-Test-1",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Trabajando con Conjuntos de Test",
    "category": "section",
    "text": "Normalmente, se utiliza una gran cantidad de pruebas para garantizar que las funciones trabajan correctamente sobre distintas entradas. En el caso de que una prueba falle, el comportamiento predeterminado es lanzar una excepción de inmediato. Sin embargo, normalmente es preferible ejecutar el resto de las pruebas primero para obtener una mejor idea de cuántos errores hay en el código que se prueba.La macro @testset() se puede usar para agrupar las pruebas en conjuntos. En un conjunto de pruebas, se ejecutarán varias y al final de su realización se imprimirá un resumen. Si alguna de las pruebas falla o no se puede evaluar debido a un error, el conjunto de prueba arrojará una TestSetException.Base.Test.@testsetPodemos poner nuestras pruebas para la función foo(x) en un conjuntos de pruebas:julia> @testset \"Foo Tests\" begin\n           @test foo(\"a\")   == 1\n           @test foo(\"ab\")  == 4\n           @test foo(\"abc\") == 9\n       end;\nTest Summary: | Pass  Total\nFoo Tests     |    3      3Los conjuntos de pruebas también pueden anidarse:julia> @testset \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @test foo(\"cat\") == 9\n               @test foo(\"dog\") == foo(\"cat\")\n           end\n           @testset \"Arrays $i\" for i in 1:3\n               @test foo(zeros(i)) == i^2\n               @test foo(ones(i)) == i^2\n           end\n       end;\nTest Summary: | Pass  Total\nFoo Tests     |    8      8En el caso de que un conjunto de pruebas anidado no tenga fallos, como pasa aquí, se ocultará en el resumen. Si tenemos una prueba que falle, sólo se mostrarán los detalles para este conjunto de pruebas que ha fallado:julia> @testset \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @testset \"Felines\" begin\n                   @test foo(\"cat\") == 9\n               end\n               @testset \"Canines\" begin\n                   @test foo(\"dog\") == 9\n               end\n           end\n           @testset \"Arrays\" begin\n               @test foo(zeros(2)) == 4\n               @test foo(ones(4)) == 15\n           end\n       end\n\nArrays: Test Failed\n  Expression: foo(ones(4)) == 15\n   Evaluated: 16 == 15\nStacktrace:\n    [...]\nTest Summary: | Pass  Fail  Total\nFoo Tests     |    3     1      4\n  Animals     |    2            2\n  Arrays      |    1     1      2\nERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken."
},

{
    "location": "stdlib/test.html#Base.Test.@inferred",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.@inferred",
    "category": "Macro",
    "text": "@inferred f(x)\n\nTests that the call expression f(x) returns a value of the same type inferred by the compiler. It is useful to check for type stability.\n\nf(x) can be any call expression. Returns the result of f(x) if the types match, and an Error Result if it finds different types.\n\njulia> using Base.Test\n\njulia> f(a,b,c) = b > 1 ? 1 : 1.0\nf (generic function with 1 method)\n\njulia> typeof(f(1,2,3))\nInt64\n\njulia> @code_warntype f(1,2,3)\nVariables:\n  #self# <optimized out>\n  a <optimized out>\n  b::Int64\n  c <optimized out>\n\nBody:\n  begin\n      unless (Base.slt_int)(1, b::Int64)::Bool goto 3\n      return 1\n      3:\n      return 1.0\n  end::UNION{FLOAT64, INT64}\n\njulia> @inferred f(1,2,3)\nERROR: return type Int64 does not match inferred return type Union{Float64, Int64}\nStacktrace:\n [1] error(::String) at ./error.jl:21\n\njulia> @inferred max(1,2)\n2\n\n\n\n"
},

{
    "location": "stdlib/test.html#Base.Test.@test_warn",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.@test_warn",
    "category": "Macro",
    "text": "@test_warn msg expr\n\nTest whether evaluating expr results in STDERR output that contains the msg string or matches the msg regular expression.  If msg is a boolean function, tests whether msg(output) returns true.  If msg is a tuple or array, checks that the error output contains/matches each item in msg. Returns the result of evaluating expr.\n\nSee also @test_nowarn to check for the absence of error output.\n\n\n\n"
},

{
    "location": "stdlib/test.html#Base.Test.@test_nowarn",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.@test_nowarn",
    "category": "Macro",
    "text": "@test_nowarn expr\n\nTest whether evaluating expr results in empty STDERR output (no warnings or other messages).  Returns the result of evaluating expr.\n\n\n\n"
},

{
    "location": "stdlib/test.html#Otras-Macros-para-Pruebas-1",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Otras Macros para Pruebas",
    "category": "section",
    "text": "Como los cálculos sobre valores en punto flotane pueden ser imprecisos, podemos realizar comprobaciones de igualdad aproximada usando @test a ≈ b (donde ≈, se obtiene mediante terminación con tabulador de \\approx, es la función isapprox()) o usar directamente isapprox().julia> @test 1 ≈ 0.999999999\nTest Passed\n\njulia> @test 1 ≈ 0.999999\nTest Failed\n  Expression: 1 ≈ 0.999999\n   Evaluated: 1 ≈ 0.999999\nERROR: There was an error during testingBase.Test.@inferred\nBase.Test.@test_warn\nBase.Test.@test_nowarn"
},

{
    "location": "stdlib/test.html#Base.Test.@test_broken",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.@test_broken",
    "category": "Macro",
    "text": "@test_broken ex\n@test_broken f(args...) key=val ...\n\nIndicates a test that should pass but currently consistently fails. Tests that the expression ex evaluates to false or causes an exception. Returns a Broken Result if it does, or an Error Result if the expression evaluates to true.\n\nThe @test_broken f(args...) key=val... form works as for the @test macro.\n\n\n\n"
},

{
    "location": "stdlib/test.html#Base.Test.@test_skip",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.@test_skip",
    "category": "Macro",
    "text": "@test_skip ex\n@test_skip f(args...) key=val ...\n\nMarks a test that should not be executed but should be included in test summary reporting as Broken. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.\n\nThe @test_skip f(args...) key=val... form works as for the @test macro.\n\n\n\n"
},

{
    "location": "stdlib/test.html#Pruebas-Rotas-1",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Pruebas Rotas",
    "category": "section",
    "text": "Si una prueba falla consistentemente, puede ser cambiada para utilizar la macro @test_broken(). Esto denotará la prueba como Rota (Broken) si la prueba continúa fallando y alerta al usuario a través de un Error si la prueba tiene éxito.Base.Test.@test_broken@test_skip() está también disponible para obviar una prueba sin evaluación, pero contabilizarla en el informe del conjunto de pruebas. La prueba no se ejecutará pero dará un Broken Result.Base.Test.@test_skip"
},

{
    "location": "stdlib/test.html#Base.Test.record",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.record",
    "category": "Function",
    "text": "record(ts::AbstractTestSet, res::Result)\n\nRecord a result to a testset. This function is called by the @testset infrastructure each time a contained @test macro completes, and is given the test result (which could be an Error). This will also be called with an Error if an exception is thrown inside the test block but outside of a @test context.\n\n\n\n"
},

{
    "location": "stdlib/test.html#Base.Test.finish",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.finish",
    "category": "Function",
    "text": "finish(ts::AbstractTestSet)\n\nDo any final processing necessary for the given testset. This is called by the @testset infrastructure after a test block executes. One common use for this function is to record the testset to the parent's results list, using get_testset.\n\n\n\n"
},

{
    "location": "stdlib/test.html#Base.Test.get_testset",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.get_testset",
    "category": "Function",
    "text": "get_testset()\n\nRetrieve the active test set from the task's local storage. If no test set is active, use the fallback default test set.\n\n\n\n"
},

{
    "location": "stdlib/test.html#Base.Test.get_testset_depth",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Base.Test.get_testset_depth",
    "category": "Function",
    "text": "get_testset_depth()\n\nReturns the number of active test sets, not including the defaut test set\n\n\n\n"
},

{
    "location": "stdlib/test.html#Creando-Tipos-AbstractTestSet-Personalizados-1",
    "page": "Haciendo Pruebas Unitarias",
    "title": "Creando Tipos AbstractTestSet Personalizados",
    "category": "section",
    "text": "Los paquetes pueden crear sus propios subtipos AbstractTestSet implementando los métodos record y finish. El subtipo debe tener un constructor de un argumento que tome una cadena de descripción, con todas las opciones pasadas como argumentos de tipo keyword.Base.Test.record\nBase.Test.finishBase.Test asume la responsabilidad de mantener una pila de conjuntos de pruebas anidados a medida que se ejecutan, pero cualquier acumulación de resultados es responsabilidad del subtipoAbstractTestSet. Puede acceder a esta pila con los métodos get_testset yget_testset_depth. Tenga en cuenta que estas funciones no se exportan.Base.Test.get_testset\nBase.Test.get_testset_depthBase.Test también se asegura de que las invocaciones @testset anidadas utilicen el mismo subtipo AbstractTestSet que sus padres, a menos que se establezca explícitamente. No propaga ninguna propiedad del conjunto de pruebas. El comportamiento de herencia de opciones se puede implementar mediante paquetes que usan la infraestructura de pila que proporciona Base.Test.La definición de un subtipo básico de 'AbstractTestSet` podría verse así:import Base.Test: record, finish\nusing Base.Test: AbstractTestSet, Result, Pass, Fail, Error\nusing Base.Test: get_testset_depth, get_testset\nstruct CustomTestSet <: Base.Test.AbstractTestSet\n    description::AbstractString\n    foo::Int\n    results::Vector\n    # constructor takes a description string and options keyword arguments\n    CustomTestSet(desc; foo=1) = new(desc, foo, [])\nend\n\nrecord(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)\nrecord(ts::CustomTestSet, res::Result) = push!(ts.results, res)\nfunction finish(ts::CustomTestSet)\n    # just record if we're not the top-level parent\n    if get_testset_depth() > 0\n        record(get_testset(), ts)\n    end\n    ts\nendY usar este conjunto de prueba tiene el siguiente aspecto:@testset CustomTestSet foo=4 \"custom testset inner 2\" begin\n    # this testset should inherit the type, but not the argument.\n    @testset \"custom testset inner\" begin\n        @test true\n    end\nendDocTestSetup = nothing"
},

{
    "location": "stdlib/c.html#",
    "page": "Interfaz C",
    "title": "Interfaz C",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/c.html#ccall",
    "page": "Interfaz C",
    "title": "ccall",
    "category": "Keyword",
    "text": "ccall((symbol, library) or function_pointer, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\nCall function in C-exported shared library, specified by (function name, library) tuple, where each component is a string or symbol.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression. Alternatively, ccall may also be used to call a function pointer, such as one returned by dlsym.\n\nEach ArgumentValue to the ccall will be converted to the corresponding ArgumentType, by automatic insertion of calls to unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue)). (See also the documentation for each of these functions for further details.) In most cases, this simply results in a call to convert(ArgumentType, ArgumentValue).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Core.Intrinsics.cglobal",
    "page": "Interfaz C",
    "title": "Core.Intrinsics.cglobal",
    "category": "Function",
    "text": "cglobal((symbol, library) [, type=Void])\n\nObtain a pointer to a global variable in a C-exported shared library, specified exactly as in ccall. Returns a Ptr{Type}, defaulting to Ptr{Void} if no Type argument is supplied. The values can be read or written by unsafe_load or unsafe_store!, respectively.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.cfunction",
    "page": "Interfaz C",
    "title": "Base.cfunction",
    "category": "Function",
    "text": "cfunction(function::Function, ReturnType::Type, ArgumentTypes::Type)\n\nGenerate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.\n\nExamples\n\njulia> function foo(x::Int, y::Int)\n           return x + y\n       end\n\njulia> cfunction(foo, Int, Tuple{Int,Int})\nPtr{Void} @0x000000001b82fcd0\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.unsafe_convert",
    "page": "Interfaz C",
    "title": "Base.unsafe_convert",
    "category": "Function",
    "text": "unsafe_convert(T,x)\n\nConvert x to a value of type T\n\nIn cases where convert would need to take a Julia object and turn it into a Ptr, this function should be used to define and perform that conversion.\n\nBe careful to ensure that a Julia reference to x exists as long as the result of this function will be used. Accordingly, the argument x to this function should never be an expression, only a variable name or field reference. For example, x=a.b.c is acceptable, but x=[a,b,c] is not.\n\nThe unsafe prefix on this function indicates that using the result of this function after the x argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.cconvert",
    "page": "Interfaz C",
    "title": "Base.cconvert",
    "category": "Function",
    "text": "cconvert(T,x)\n\nConvert x to a value of type T, typically by calling convert(T,x)\n\nIn cases where x cannot be safely converted to T, unlike convert, cconvert may return an object of a type different from T, which however is suitable for unsafe_convert to handle.\n\nNeither convert nor cconvert should take a Julia object and turn it into a Ptr.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.unsafe_load",
    "page": "Interfaz C",
    "title": "Base.unsafe_load",
    "category": "Function",
    "text": "unsafe_load(p::Ptr{T}, i::Integer=1)\n\nLoad a value of type T from the address of the ith element (1-indexed) starting at p. This is equivalent to the C expression p[i-1].\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointer p to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.unsafe_store!",
    "page": "Interfaz C",
    "title": "Base.unsafe_store!",
    "category": "Function",
    "text": "unsafe_store!(p::Ptr{T}, x, i::Integer=1)\n\nStore a value of type T to the address of the ith element (1-indexed) starting at p. This is equivalent to the C expression p[i-1] = x.\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointer p to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.unsafe_copy!-Union{Tuple{Ptr{T},Ptr{T},Any}, Tuple{T}} where T",
    "page": "Interfaz C",
    "title": "Base.unsafe_copy!",
    "category": "Method",
    "text": "unsafe_copy!(dest::Ptr{T}, src::Ptr{T}, N)\n\nCopy N elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointers dest and src to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.unsafe_copy!-Tuple{Array,Any,Array,Any,Any}",
    "page": "Interfaz C",
    "title": "Base.unsafe_copy!",
    "category": "Method",
    "text": "unsafe_copy!(dest::Array, do, src::Array, so, N)\n\nCopy N elements from a source array to a destination, starting at offset so in the source and do in the destination (1-indexed).\n\nThe unsafe prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.copy!-Tuple{Any,Any}",
    "page": "Interfaz C",
    "title": "Base.copy!",
    "category": "Method",
    "text": "copy!(dest, src) -> dest\n\nCopy all elements from collection src to array dest.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.copy!-NTuple{5,Any}",
    "page": "Interfaz C",
    "title": "Base.copy!",
    "category": "Method",
    "text": "copy!(dest, do, src, so, N)\n\nCopy N elements from collection src starting at offset so, to array dest starting at offset do. Returns dest.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.pointer",
    "page": "Interfaz C",
    "title": "Base.pointer",
    "category": "Function",
    "text": "pointer(array [, index])\n\nGet the native address of an array or string element. Be careful to ensure that a Julia reference to a exists as long as this pointer will be used. This function is \"unsafe\" like unsafe_convert.\n\nCalling Ref(array[, index]) is generally preferable to this function.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array{T,N} where N}, Type{Array{T,N}}, Type{Array}},Ptr{T},Tuple{Vararg{Int64,N}}}} where N where T",
    "page": "Interfaz C",
    "title": "Base.unsafe_wrap",
    "category": "Method",
    "text": "unsafe_wrap(Array, pointer::Ptr{T}, dims, own=false)\n\nWrap a Julia Array object around the data at the address given by pointer, without making a copy.  The pointer element type T determines the array element type. dims is either an integer (for a 1d array) or a tuple of the array dimensions. own optionally specifies whether Julia should take ownership of the memory, calling free on the pointer when the array is no longer referenced.\n\nThis function is labelled \"unsafe\" because it will crash if pointer is not a valid memory address to data of the requested length.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.pointer_from_objref",
    "page": "Interfaz C",
    "title": "Base.pointer_from_objref",
    "category": "Function",
    "text": "pointer_from_objref(x)\n\nGet the memory address of a Julia object as a Ptr. The existence of the resulting Ptr will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the Ptr will be used.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.unsafe_pointer_to_objref",
    "page": "Interfaz C",
    "title": "Base.unsafe_pointer_to_objref",
    "category": "Function",
    "text": "unsafe_pointer_to_objref(p::Ptr)\n\nConvert a Ptr to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered \"unsafe\" and should be used with care.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.disable_sigint",
    "page": "Interfaz C",
    "title": "Base.disable_sigint",
    "category": "Function",
    "text": "disable_sigint(f::Function)\n\nDisable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using do block syntax as follows:\n\ndisable_sigint() do\n    # interrupt-unsafe code\n    ...\nend\n\nThis is not needed on worker threads (Threads.threadid() != 1) since the InterruptException will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.reenable_sigint",
    "page": "Interfaz C",
    "title": "Base.reenable_sigint",
    "category": "Function",
    "text": "reenable_sigint(f::Function)\n\nRe-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of disable_sigint.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.systemerror",
    "page": "Interfaz C",
    "title": "Base.systemerror",
    "category": "Function",
    "text": "systemerror(sysfunc, iftrue)\n\nRaises a SystemError for errno with the descriptive string sysfunc if iftrue is true\n\n\n\n"
},

{
    "location": "stdlib/c.html#Core.Ptr",
    "page": "Interfaz C",
    "title": "Core.Ptr",
    "category": "Type",
    "text": "Ptr{T}\n\nA memory address referring to data of type T.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Core.Ref",
    "page": "Interfaz C",
    "title": "Core.Ref",
    "category": "Type",
    "text": "Ref{T}\n\nAn object that safely references data of type T. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the Ref itself is referenced.\n\nWhen passed as a ccall argument (either as a Ptr or Ref type), a Ref object will be converted to a native pointer to the data it references.\n\nThere is no invalid (NULL) Ref.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cchar",
    "page": "Interfaz C",
    "title": "Base.Cchar",
    "category": "Type",
    "text": "Cchar\n\nEquivalent to the native char c-type.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cuchar",
    "page": "Interfaz C",
    "title": "Base.Cuchar",
    "category": "Type",
    "text": "Cuchar\n\nEquivalent to the native unsigned char c-type (UInt8).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cshort",
    "page": "Interfaz C",
    "title": "Base.Cshort",
    "category": "Type",
    "text": "Cshort\n\nEquivalent to the native signed short c-type (Int16).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cushort",
    "page": "Interfaz C",
    "title": "Base.Cushort",
    "category": "Type",
    "text": "Cushort\n\nEquivalent to the native unsigned short c-type (UInt16).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cint",
    "page": "Interfaz C",
    "title": "Base.Cint",
    "category": "Type",
    "text": "Cint\n\nEquivalent to the native signed int c-type (Int32).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cuint",
    "page": "Interfaz C",
    "title": "Base.Cuint",
    "category": "Type",
    "text": "Cuint\n\nEquivalent to the native unsigned int c-type (UInt32).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Clong",
    "page": "Interfaz C",
    "title": "Base.Clong",
    "category": "Type",
    "text": "Clong\n\nEquivalent to the native signed long c-type.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Culong",
    "page": "Interfaz C",
    "title": "Base.Culong",
    "category": "Type",
    "text": "Culong\n\nEquivalent to the native unsigned long c-type.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Clonglong",
    "page": "Interfaz C",
    "title": "Base.Clonglong",
    "category": "Type",
    "text": "Clonglong\n\nEquivalent to the native signed long long c-type (Int64).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Culonglong",
    "page": "Interfaz C",
    "title": "Base.Culonglong",
    "category": "Type",
    "text": "Culonglong\n\nEquivalent to the native unsigned long long c-type (UInt64).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cintmax_t",
    "page": "Interfaz C",
    "title": "Base.Cintmax_t",
    "category": "Type",
    "text": "Cintmax_t\n\nEquivalent to the native intmax_t c-type (Int64).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cuintmax_t",
    "page": "Interfaz C",
    "title": "Base.Cuintmax_t",
    "category": "Type",
    "text": "Cuintmax_t\n\nEquivalent to the native uintmax_t c-type (UInt64).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Csize_t",
    "page": "Interfaz C",
    "title": "Base.Csize_t",
    "category": "Type",
    "text": "Csize_t\n\nEquivalent to the native size_t c-type (UInt).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cssize_t",
    "page": "Interfaz C",
    "title": "Base.Cssize_t",
    "category": "Type",
    "text": "Cssize_t\n\nEquivalent to the native ssize_t c-type.\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cptrdiff_t",
    "page": "Interfaz C",
    "title": "Base.Cptrdiff_t",
    "category": "Type",
    "text": "Cptrdiff_t\n\nEquivalent to the native ptrdiff_t c-type (Int).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cwchar_t",
    "page": "Interfaz C",
    "title": "Base.Cwchar_t",
    "category": "Type",
    "text": "Cwchar_t\n\nEquivalent to the native wchar_t c-type (Int32).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cfloat",
    "page": "Interfaz C",
    "title": "Base.Cfloat",
    "category": "Type",
    "text": "Cfloat\n\nEquivalent to the native float c-type (Float32).\n\n\n\n"
},

{
    "location": "stdlib/c.html#Base.Cdouble",
    "page": "Interfaz C",
    "title": "Base.Cdouble",
    "category": "Type",
    "text": "Cdouble\n\nEquivalent to the native double c-type (Float64).\n\n\n\n"
},

{
    "location": "stdlib/c.html#c-1",
    "page": "Interfaz C",
    "title": "Interfaz C",
    "category": "section",
    "text": "ccall\nCore.Intrinsics.cglobal\nBase.cfunction\nBase.unsafe_convert\nBase.cconvert\nBase.unsafe_load\nBase.unsafe_store!\nBase.unsafe_copy!{T}(::Ptr{T}, ::Ptr{T}, ::Any)\nBase.unsafe_copy!(::Array, ::Any, ::Array, ::Any, ::Any)\nBase.copy!(::Any, ::Any)\nBase.copy!(::Any, ::Any, ::Any, ::Any, ::Any)\nBase.pointer\nBase.unsafe_wrap{T,N}(::Union{Type{Array},Type{Array{T}},Type{Array{T,N}}}, ::Ptr{T}, ::NTuple{N,Int})\nBase.pointer_from_objref\nBase.unsafe_pointer_to_objref\nBase.disable_sigint\nBase.reenable_sigint\nBase.systemerror\nCore.Ptr\nCore.Ref\nBase.Cchar\nBase.Cuchar\nBase.Cshort\nBase.Cushort\nBase.Cint\nBase.Cuint\nBase.Clong\nBase.Culong\nBase.Clonglong\nBase.Culonglong\nBase.Cintmax_t\nBase.Cuintmax_t\nBase.Csize_t\nBase.Cssize_t\nBase.Cptrdiff_t\nBase.Cwchar_t\nBase.Cfloat\nBase.Cdouble"
},

{
    "location": "stdlib/c.html#Core.Intrinsics.llvmcall",
    "page": "Interfaz C",
    "title": "Core.Intrinsics.llvmcall",
    "category": "Function",
    "text": "llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\nllvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)\n\nCall LLVM IR string in the first argument. Similar to an LLVM function define block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).\n\nThe optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.\n\nEach ArgumentValue to llvmcall will be converted to the corresponding ArgumentType, by automatic insertion of calls to unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue)). (see also the documentation for each of these functions for further details). In most cases, this simply results in a call to convert(ArgumentType, ArgumentValue).\n\nSee test/llvmcall.jl for usage examples.\n\n\n\n"
},

{
    "location": "stdlib/c.html#llvm-interface-1",
    "page": "Interfaz C",
    "title": "Interfaz LLVM",
    "category": "section",
    "text": "Core.Intrinsics.llvmcall"
},

{
    "location": "stdlib/libc.html#",
    "page": "Librería Estándar C",
    "title": "Librería Estándar C",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/libc.html#Base.Libc.malloc",
    "page": "Librería Estándar C",
    "title": "Base.Libc.malloc",
    "category": "Function",
    "text": "malloc(size::Integer) -> Ptr{Void}\n\nCall malloc from the C standard library.\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.calloc",
    "page": "Librería Estándar C",
    "title": "Base.Libc.calloc",
    "category": "Function",
    "text": "calloc(num::Integer, size::Integer) -> Ptr{Void}\n\nCall calloc from the C standard library.\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.realloc",
    "page": "Librería Estándar C",
    "title": "Base.Libc.realloc",
    "category": "Function",
    "text": "realloc(addr::Ptr, size::Integer) -> Ptr{Void}\n\nCall realloc from the C standard library.\n\nSee warning in the documentation for free regarding only using this on memory originally obtained from malloc.\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.free",
    "page": "Librería Estándar C",
    "title": "Base.Libc.free",
    "category": "Function",
    "text": "free(addr::Ptr)\n\nCall free from the C standard library. Only use this on memory obtained from malloc, not on pointers retrieved from other C libraries. Ptr objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple libc libraries exist on the system.\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.errno",
    "page": "Librería Estándar C",
    "title": "Base.Libc.errno",
    "category": "Function",
    "text": "errno([code])\n\nGet the value of the C library's errno. If an argument is specified, it is used to set the value of errno.\n\nThe value of errno is only valid immediately after a ccall to a C library routine that sets it. Specifically, you cannot call errno at the next prompt in a REPL, because lots of code is executed between prompts.\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.strerror",
    "page": "Librería Estándar C",
    "title": "Base.Libc.strerror",
    "category": "Function",
    "text": "strerror(n=errno())\n\nConvert a system call error code to a descriptive string\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.GetLastError",
    "page": "Librería Estándar C",
    "title": "Base.Libc.GetLastError",
    "category": "Function",
    "text": "GetLastError()\n\nCall the Win32 GetLastError function [only available on Windows].\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.FormatMessage",
    "page": "Librería Estándar C",
    "title": "Base.Libc.FormatMessage",
    "category": "Function",
    "text": "FormatMessage(n=GetLastError())\n\nConvert a Win32 system call error code to a descriptive string [only available on Windows].\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.time-Tuple{Base.Libc.TmStruct}",
    "page": "Librería Estándar C",
    "title": "Base.Libc.time",
    "category": "Method",
    "text": "time(t::TmStruct)\n\nConverts a TmStruct struct to a number of seconds since the epoch.\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.strftime",
    "page": "Librería Estándar C",
    "title": "Base.Libc.strftime",
    "category": "Function",
    "text": "strftime([format], time)\n\nConvert time, given as a number of seconds since the epoch or a TmStruct, to a formatted string using the given format. Supported formats are the same as those in the standard C library.\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.strptime",
    "page": "Librería Estándar C",
    "title": "Base.Libc.strptime",
    "category": "Function",
    "text": "strptime([format], timestr)\n\nParse a formatted time string into a TmStruct giving the seconds, minute, hour, date, etc. Supported formats are the same as those in the standard C library. On some platforms, timezones will not be parsed correctly. If the result of this function will be passed to time to convert it to seconds since the epoch, the isdst field should be filled in manually. Setting it to -1 will tell the C library to use the current system settings to determine the timezone.\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.TmStruct",
    "page": "Librería Estándar C",
    "title": "Base.Libc.TmStruct",
    "category": "Type",
    "text": "TmStruct([seconds])\n\nConvert a number of seconds since the epoch to broken-down format, with fields sec, min, hour, mday, month, year, wday, yday, and isdst.\n\n\n\n"
},

{
    "location": "stdlib/libc.html#Base.Libc.flush_cstdio",
    "page": "Librería Estándar C",
    "title": "Base.Libc.flush_cstdio",
    "category": "Function",
    "text": "flush_cstdio()\n\nFlushes the C stdout and stderr streams (which may have been written to by external C code).\n\n\n\n"
},

{
    "location": "stdlib/libc.html#libc-1",
    "page": "Librería Estándar C",
    "title": "Librería Estándar C",
    "category": "section",
    "text": "Base.Libc.malloc\nBase.Libc.calloc\nBase.Libc.realloc\nBase.Libc.free\nBase.Libc.errno\nBase.Libc.strerror\nBase.Libc.GetLastError\nBase.Libc.FormatMessage\nBase.Libc.time(::Base.Libc.TmStruct)\nBase.Libc.strftime\nBase.Libc.strptime\nBase.Libc.TmStruct\nBase.Libc.flush_cstdio"
},

{
    "location": "stdlib/libdl.html#",
    "page": "Enlazador Dinámico",
    "title": "Enlazador Dinámico",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/libdl.html#Base.Libdl.dlopen",
    "page": "Enlazador Dinámico",
    "title": "Base.Libdl.dlopen",
    "category": "Function",
    "text": "dlopen(libfile::AbstractString [, flags::Integer])\n\nLoad a shared library, returning an opaque handle.\n\nThe extension given by the constant dlext (.so, .dll, or .dylib) can be omitted from the libfile string, as it is automatically appended if needed.   If libfile is not an absolute path name, then the paths in the array DL_LOAD_PATH are searched for libfile, followed by the system load path.\n\nThe optional flags argument is a bitwise-or of zero or more of RTLD_LOCAL, RTLD_GLOBAL, RTLD_LAZY, RTLD_NOW, RTLD_NODELETE, RTLD_NOLOAD, RTLD_DEEPBIND, and RTLD_FIRST. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default dlopen flags are RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL while on other platforms the defaults are RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.\n\n\n\n"
},

{
    "location": "stdlib/libdl.html#Base.Libdl.dlopen_e",
    "page": "Enlazador Dinámico",
    "title": "Base.Libdl.dlopen_e",
    "category": "Function",
    "text": "dlopen_e(libfile::AbstractString [, flags::Integer])\n\nSimilar to dlopen, except returns a NULL pointer instead of raising errors.\n\n\n\n"
},

{
    "location": "stdlib/libdl.html#Base.Libdl.RTLD_NOW",
    "page": "Enlazador Dinámico",
    "title": "Base.Libdl.RTLD_NOW",
    "category": "Constant",
    "text": "RTLD_DEEPBIND\nRTLD_FIRST\nRTLD_GLOBAL\nRTLD_LAZY\nRTLD_LOCAL\nRTLD_NODELETE\nRTLD_NOLOAD\nRTLD_NOW\n\nEnum constant for dlopen. See your platform man page for details, if applicable.\n\n\n\n"
},

{
    "location": "stdlib/libdl.html#Base.Libdl.dlsym",
    "page": "Enlazador Dinámico",
    "title": "Base.Libdl.dlsym",
    "category": "Function",
    "text": "dlsym(handle, sym)\n\nLook up a symbol from a shared library handle, return callable function pointer on success.\n\n\n\n"
},

{
    "location": "stdlib/libdl.html#Base.Libdl.dlsym_e",
    "page": "Enlazador Dinámico",
    "title": "Base.Libdl.dlsym_e",
    "category": "Function",
    "text": "dlsym_e(handle, sym)\n\nLook up a symbol from a shared library handle, silently return NULL pointer on lookup failure.\n\n\n\n"
},

{
    "location": "stdlib/libdl.html#Base.Libdl.dlclose",
    "page": "Enlazador Dinámico",
    "title": "Base.Libdl.dlclose",
    "category": "Function",
    "text": "dlclose(handle)\n\nClose shared library referenced by handle.\n\n\n\n"
},

{
    "location": "stdlib/libdl.html#Base.Libdl.dlext",
    "page": "Enlazador Dinámico",
    "title": "Base.Libdl.dlext",
    "category": "Constant",
    "text": "dlext\n\nFile extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.\n\n\n\n"
},

{
    "location": "stdlib/libdl.html#Base.Libdl.find_library",
    "page": "Enlazador Dinámico",
    "title": "Base.Libdl.find_library",
    "category": "Function",
    "text": "find_library(names, locations)\n\nSearches for the first library in names in the paths in the locations list, DL_LOAD_PATH, or system library paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a global const and used as the library name in future ccall's. On failure, it returns the empty string.\n\n\n\n"
},

{
    "location": "stdlib/libdl.html#Base.Libdl.DL_LOAD_PATH",
    "page": "Enlazador Dinámico",
    "title": "Base.Libdl.DL_LOAD_PATH",
    "category": "Constant",
    "text": "DL_LOAD_PATH\n\nWhen calling dlopen, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.\n\n\n\n"
},

{
    "location": "stdlib/libdl.html#dynamic-linker-1",
    "page": "Enlazador Dinámico",
    "title": "Enlazador Dinámico",
    "category": "section",
    "text": "Los nombres en Base.Libdl no son exportados y necesitan ser llamados como, por ejemplo, Libdl.dlopen().Base.Libdl.dlopen\nBase.Libdl.dlopen_e\nBase.Libdl.RTLD_NOW\nBase.Libdl.dlsym\nBase.Libdl.dlsym_e\nBase.Libdl.dlclose\nBase.Libdl.dlext\nBase.Libdl.find_library\nBase.Libdl.DL_LOAD_PATH"
},

{
    "location": "stdlib/profile.html#",
    "page": "Profiling",
    "title": "Profiling",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/profile.html#Base.Profile.@profile",
    "page": "Profiling",
    "title": "Base.Profile.@profile",
    "category": "Macro",
    "text": "@profile\n\n@profile <expression> runs your expression while taking periodic backtraces. These are appended to an internal buffer of backtraces.\n\n\n\n"
},

{
    "location": "stdlib/profile.html#Base.Profile.clear",
    "page": "Profiling",
    "title": "Base.Profile.clear",
    "category": "Function",
    "text": "clear()\n\nClear any existing backtraces from the internal buffer.\n\n\n\n"
},

{
    "location": "stdlib/profile.html#Base.Profile.print",
    "page": "Profiling",
    "title": "Base.Profile.print",
    "category": "Function",
    "text": "print([io::IO = STDOUT,] [data::Vector]; kwargs...)\n\nPrints profiling results to io (by default, STDOUT). If you do not supply a data vector, the internal buffer of accumulated backtraces will be used.\n\nThe keyword arguments can be any combination of:\n\nformat – Determines whether backtraces are printed with (default, :tree) or without (:flat) indentation indicating tree structure.\nC – If true, backtraces from C and Fortran code are shown (normally they are excluded).\ncombine – If true (default), instruction pointers are merged that correspond to the same line of code.\nmaxdepth – Limits the depth higher than maxdepth in the :tree format.\nsortedby – Controls the order in :flat format. :filefuncline (default) sorts by the source  line, whereas :count sorts in order of number of collected samples.\nnoisefloor – Limits frames that exceed the heuristic noise floor of the sample (only applies to format :tree).  A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which n <= noisefloor * √N,  where n is the number of samples on this line, and N is the number of samples for the callee.\nmincount – Limits the printout to only those lines with at least mincount occurrences.\n\n\n\nprint([io::IO = STDOUT,] data::Vector, lidict::LineInfoDict; kwargs...)\n\nPrints profiling results to io. This variant is used to examine results exported by a previous call to retrieve. Supply the vector data of backtraces and a dictionary lidict of line information.\n\nSee Profile.print([io], data) for an explanation of the valid keyword arguments.\n\n\n\n"
},

{
    "location": "stdlib/profile.html#Base.Profile.init",
    "page": "Profiling",
    "title": "Base.Profile.init",
    "category": "Function",
    "text": "init(; n::Integer, delay::Float64)\n\nConfigure the delay between backtraces (measured in seconds), and the number n of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order (n, delay).\n\n\n\n"
},

{
    "location": "stdlib/profile.html#Base.Profile.fetch",
    "page": "Profiling",
    "title": "Base.Profile.fetch",
    "category": "Function",
    "text": "fetch() -> data\n\nReturns a reference to the internal buffer of backtraces. Note that subsequent operations, like clear, can affect data unless you first make a copy. Note that the values in data have meaning only on this machine in the current session, because it depends on the exact memory addresses used in JIT-compiling. This function is primarily for internal use; retrieve may be a better choice for most users.\n\n\n\n"
},

{
    "location": "stdlib/profile.html#Base.Profile.retrieve",
    "page": "Profiling",
    "title": "Base.Profile.retrieve",
    "category": "Function",
    "text": "retrieve() -> data, lidict\n\n\"Exports\" profiling results in a portable format, returning the set of all backtraces (data) and a dictionary that maps the (session-specific) instruction pointers in data to LineInfo values that store the file name, function name, and line number. This function allows you to save profiling results for future analysis.\n\n\n\n"
},

{
    "location": "stdlib/profile.html#Base.Profile.callers",
    "page": "Profiling",
    "title": "Base.Profile.callers",
    "category": "Function",
    "text": "callers(funcname, [data, lidict], [filename=<filename>], [linerange=<start:stop>]) -> Vector{Tuple{count, lineinfo}}\n\nGiven a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace data obtained from retrieve; otherwise, the current internal profile buffer is used.\n\n\n\n"
},

{
    "location": "stdlib/profile.html#Base.Profile.clear_malloc_data",
    "page": "Profiling",
    "title": "Base.Profile.clear_malloc_data",
    "category": "Function",
    "text": "clear_malloc_data()\n\nClears any stored memory allocation data when running julia with --track-allocation. Execute the command(s) you want to test (to force JIT-compilation), then call clear_malloc_data. Then execute your command(s) again, quit Julia, and examine the resulting *.mem files.\n\n\n\n"
},

{
    "location": "stdlib/profile.html#lib-profiling-1",
    "page": "Profiling",
    "title": "Profiling",
    "category": "section",
    "text": "Base.Profile.@profileLos métodos en Base.Profile no son exportados y necesitan ser llamados como, por ejemplo, Profile.print().Base.Profile.clear\nBase.Profile.print\nBase.Profile.init\nBase.Profile.fetch\nBase.Profile.retrieve\nBase.Profile.callers\nBase.Profile.clear_malloc_data"
},

{
    "location": "stdlib/stacktraces.html#",
    "page": "StackTraces",
    "title": "StackTraces",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/stacktraces.html#Base.StackTraces.StackFrame",
    "page": "StackTraces",
    "title": "Base.StackTraces.StackFrame",
    "category": "Type",
    "text": "StackFrame\n\nStack information representing execution context, with the following fields:\n\nfunc::Symbol\nThe name of the function containing the execution context.\nlinfo::Nullable{Core.MethodInstance}\nThe MethodInstance containing the execution context (if it could be found).\nfile::Symbol\nThe path to the file containing the execution context.\nline::Int\nThe line number in the file containing the execution context.\nfrom_c::Bool\nTrue if the code is from C.\ninlined::Bool\nTrue if the code is from an inlined frame.\npointer::UInt64\nRepresentation of the pointer to the execution context as returned by backtrace.\n\n\n\n"
},

{
    "location": "stdlib/stacktraces.html#Base.StackTraces.StackTrace",
    "page": "StackTraces",
    "title": "Base.StackTraces.StackTrace",
    "category": "Type",
    "text": "StackTrace\n\nAn alias for Vector{StackFrame} provided for convenience; returned by calls to stacktrace and catch_stacktrace.\n\n\n\n"
},

{
    "location": "stdlib/stacktraces.html#Base.StackTraces.stacktrace",
    "page": "StackTraces",
    "title": "Base.StackTraces.stacktrace",
    "category": "Function",
    "text": "stacktrace([trace::Vector{Ptr{Void}},] [c_funcs::Bool=false]) -> StackTrace\n\nReturns a stack trace in the form of a vector of StackFrames. (By default stacktrace doesn't return C functions, but this can be enabled.) When called without specifying a trace, stacktrace first calls backtrace.\n\n\n\n"
},

{
    "location": "stdlib/stacktraces.html#Base.StackTraces.catch_stacktrace",
    "page": "StackTraces",
    "title": "Base.StackTraces.catch_stacktrace",
    "category": "Function",
    "text": "catch_stacktrace([c_funcs::Bool=false]) -> StackTrace\n\nReturns the stack trace for the most recent error thrown, rather than the current execution context.\n\n\n\n"
},

{
    "location": "stdlib/stacktraces.html#Base.StackTraces.lookup",
    "page": "StackTraces",
    "title": "Base.StackTraces.lookup",
    "category": "Function",
    "text": "lookup(pointer::Union{Ptr{Void}, UInt}) -> Vector{StackFrame}\n\nGiven a pointer to an execution context (usually generated by a call to backtrace), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.\n\n\n\n"
},

{
    "location": "stdlib/stacktraces.html#Base.StackTraces.remove_frames!",
    "page": "StackTraces",
    "title": "Base.StackTraces.remove_frames!",
    "category": "Function",
    "text": "remove_frames!(stack::StackTrace, name::Symbol)\n\nTakes a StackTrace (a vector of StackFrames) and a function name (a Symbol) and removes the StackFrame specified by the function name from the StackTrace (also removing all frames above the specified function). Primarily used to remove StackTraces functions from the StackTrace prior to returning it.\n\n\n\nremove_frames!(stack::StackTrace, m::Module)\n\nReturns the StackTrace with all StackFrames from the provided Module removed.\n\n\n\n"
},

{
    "location": "stdlib/stacktraces.html#lib-stacktraces-1",
    "page": "StackTraces",
    "title": "StackTraces",
    "category": "section",
    "text": "Base.StackTraces.StackFrame\nBase.StackTraces.StackTrace\nBase.StackTraces.stacktrace\nBase.StackTraces.catch_stacktraceLos siguientes métodos y tipos de Base.StackTraces no son exportados y, por tanto, deben ser prefijados en sus invocaciones. Por ejemplo, StackTraces.lookup(ptr).Base.StackTraces.lookup\nBase.StackTraces.remove_frames!"
},

{
    "location": "stdlib/simd-types.html#",
    "page": "Soporte SIMD",
    "title": "Soporte SIMD",
    "category": "page",
    "text": ""
},

{
    "location": "stdlib/simd-types.html#simd-support-1",
    "page": "Soporte SIMD",
    "title": "Soporte SIMD",
    "category": "section",
    "text": "El tipo VecElement{T} está pensado para construir librerías de operaciones SIMD. Su uso práctico requiere usar llvmcall. El tipo está definido como:struct VecElement{T}\n    value::T\nendTiene una regla de compilación especial: una tupla homogénea de VecElement{T} se corresponde con un tipo vector LLVM cuando T es un tipo de bits primitivo y la longitud de la tupla está en el conjunto {2-6,8-10,16}.En -O3, el compilador podría vectorizar operaciones sobre tales tuplas automáticamente. Por ejemplo, el siguiente programa, cuando se compila con julia -O3 genera dos instrucciones de adición SIMD (addps) sobre los sistemas x86:const m128 = NTuple{4,VecElement{Float32}}\n\nfunction add(a::m128, b::m128)\n    (VecElement(a[1].value+b[1].value),\n     VecElement(a[2].value+b[2].value),\n     VecElement(a[3].value+b[3].value),\n     VecElement(a[4].value+b[4].value))\nend\n\ntriple(c::m128) = add(add(c,c),c)\n\ncode_native(triple,(m128,))Sin embargo, dado que no se puede confiar en la vectorización automática, el uso futuro se realizará principalmente a través de bibliotecas que usen llvmcall."
},

{
    "location": "devdocs/reflection.html#",
    "page": "Reflection and introspection",
    "title": "Reflection and introspection",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/reflection.html#reflection-and-introspection-1",
    "page": "Reflection and introspection",
    "title": "Reflection and introspection",
    "category": "section",
    "text": "Julia provides a variety of runtime reflection capabilities."
},

{
    "location": "devdocs/reflection.html#Module-bindings-1",
    "page": "Reflection and introspection",
    "title": "Module bindings",
    "category": "section",
    "text": "The exported names for a Module are available using names(m::Module), which will return an array of Symbol elements representing the exported bindings. names(m::Module, true) returns symbols for all bindings in m, regardless of export status."
},

{
    "location": "devdocs/reflection.html#DataType-fields-1",
    "page": "Reflection and introspection",
    "title": "DataType fields",
    "category": "section",
    "text": "The names of DataType fields may be interrogated using fieldnames(). For example, given the following type, fieldnames(Point) returns an arrays of Symbol elements representing the field names:julia> struct Point\n           x::Int\n           y\n       end\n\njulia> fieldnames(Point)\n2-element Array{Symbol,1}:\n :x\n :yThe type of each field in a Point object is stored in the types field of the Point variable itself:julia> Point.types\nsvec(Int64, Any)While x is annotated as an Int, y was unannotated in the type definition, therefore y defaults to the Any type.Types are themselves represented as a structure called DataType:julia> typeof(Point)\nDataTypeNote that fieldnames(DataType) gives the names for each field of DataType itself, and one of these fields is the types field observed in the example above."
},

{
    "location": "devdocs/reflection.html#Subtypes-1",
    "page": "Reflection and introspection",
    "title": "Subtypes",
    "category": "section",
    "text": "The direct subtypes of any DataType may be listed using subtypes(). For example, the abstract DataType AbstractFloat has four (concrete) subtypes:julia> subtypes(AbstractFloat)\n4-element Array{Union{DataType, UnionAll},1}:\n BigFloat\n Float16\n Float32\n Float64Any abstract subtype will also be included in this list, but further subtypes thereof will not; recursive application of subtypes() may be used to inspect the full type tree."
},

{
    "location": "devdocs/reflection.html#DataType-layout-1",
    "page": "Reflection and introspection",
    "title": "DataType layout",
    "category": "section",
    "text": "The internal representation of a DataType is critically important when interfacing with C code and several functions are available to inspect these details. isbits(T::DataType) returns true if T is stored with C-compatible alignment. fieldoffset(T::DataType, i::Integer) returns the (byte) offset for field i relative to the start of the type."
},

{
    "location": "devdocs/reflection.html#Function-methods-1",
    "page": "Reflection and introspection",
    "title": "Function methods",
    "category": "section",
    "text": "The methods of any generic function may be listed using methods(). The method dispatch table may be searched for methods accepting a given type using methodswith()."
},

{
    "location": "devdocs/reflection.html#Expansion-and-lowering-1",
    "page": "Reflection and introspection",
    "title": "Expansion and lowering",
    "category": "section",
    "text": "As discussed in the Metaprogramming section, the macroexpand() function gives the unquoted and interpolated expression (Expr) form for a given macro. To use macroexpand, quote the expression block itself (otherwise, the macro will be evaluated and the result will be passed instead!). For example:julia> macroexpand( :(@edit println(\"\")) )\n:((Base.edit)(println, (Base.typesof)(\"\")))The functions Base.Meta.show_sexpr() and dump() are used to display S-expr style views and depth-nested detail views for any expression.Finally, the expand() function gives the lowered form of any expression and is of particular interest for understanding both macros and top-level statements such as function declarations and variable assignments:julia> expand( :(f() = 1) )\n:(begin\n        $(Expr(:method, :f))\n        $(Expr(:method, :f, :((Core.svec)((Core.svec)((Core.Typeof)(f)), (Core.svec)())), CodeInfo(:(begin  # none, line 1:\n        return 1\n    end)), false))\n        return f\n    end)"
},

{
    "location": "devdocs/reflection.html#Intermediate-and-compiled-representations-1",
    "page": "Reflection and introspection",
    "title": "Intermediate and compiled representations",
    "category": "section",
    "text": "Inspecting the lowered form for functions requires selection of the specific method to display, because generic functions may have many methods with different type signatures. For this purpose, method-specific code-lowering is available using code_lowered(f::Function, (Argtypes...)), and the type-inferred form is available using code_typed(f::Function, (Argtypes...)). code_warntype(f::Function, (Argtypes...)) adds highlighting to the output of code_typed() (see @code_warntype).Closer to the machine, the LLVM intermediate representation of a function may be printed using by code_llvm(f::Function, (Argtypes...)), and finally the compiled machine code is available using code_native(f::Function, (Argtypes...)) (this will trigger JIT compilation/code generation for any function which has not previously been called).For convenience, there are macro versions of the above functions which take standard function calls and expand argument types automatically:julia> @code_llvm +(1,1)\n\n; Function Attrs: sspreq\ndefine i64 @\"julia_+_130862\"(i64, i64) #0 {\ntop:\n    %2 = add i64 %1, %0, !dbg !8\n    ret i64 %2, !dbg !8\n}(likewise @code_typed, @code_warntype, @code_lowered, and @code_native)"
},

{
    "location": "devdocs/init.html#",
    "page": "Initialization of the Julia runtime",
    "title": "Initialization of the Julia runtime",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/init.html#init-1",
    "page": "Initialization of the Julia runtime",
    "title": "Initialization of the Julia runtime",
    "category": "section",
    "text": "How does the Julia runtime execute julia -e 'println(\"Hello World!\")' ?"
},

{
    "location": "devdocs/init.html#main()-1",
    "page": "Initialization of the Julia runtime",
    "title": "main()",
    "category": "section",
    "text": "Execution starts at main() in ui/repl.c.main() calls libsupport_init() to set the C library locale and to initialize the \"ios\" library (see ios_init_stdstreams() and Legacy ios.c library).Next parse_opts() is called to process command line options. Note that parse_opts() only deals with options that affect code generation or early initialization. Other options are handled later by process_options() in base/client.jl.parse_opts() stores command line options in the global jl_options struct."
},

{
    "location": "devdocs/init.html#julia_init()-1",
    "page": "Initialization of the Julia runtime",
    "title": "julia_init()",
    "category": "section",
    "text": "julia_init() in task.c is called by main() and calls _julia_init() in init.c._julia_init() begins by calling libsupport_init() again (it does nothing the second time).restore_signals() is called to zero the signal handler mask.jl_resolve_sysimg_location() searches configured paths for the base system image. See Building the Julia system image.jl_gc_init() sets up allocation pools and lists for weak refs, preserved values and finalization.jl_init_frontend() loads and initializes a pre-compiled femtolisp image containing the scanner/parser.jl_init_types() creates jl_datatype_t type description objects for the built-in types defined in julia.h. e.g.jl_any_type = jl_new_abstracttype(jl_symbol(\"Any\"), NULL, jl_null);\njl_any_type->super = jl_any_type;\n\njl_type_type = jl_new_abstracttype(jl_symbol(\"Type\"), jl_any_type, jl_null);\n\njl_int32_type = jl_new_bitstype(jl_symbol(\"Int32\"),\n                                jl_any_type, jl_null, 32);jl_init_tasks() creates the jl_datatype_t* jl_task_type object; initializes the global jl_root_task struct; and sets jl_current_task to the root task.jl_init_codegen() initializes the LLVM library.jl_init_serializer() initializes 8-bit serialization tags for 256 frequently used jl_value_t values. The serialization mechanism uses these tags as shorthand (in lieu of storing whole objects) to save storage space.If there is no sysimg file (!jl_options.image_file) then the Core and Main modules are created and boot.jl is evaluated:jl_core_module = jl_new_module(jl_symbol(\"Core\")) creates the Julia Core module.jl_init_intrinsic_functions() creates a new Julia module Intrinsics containing constant jl_intrinsic_type symbols. These define an integer code for each intrinsic function. emit_intrinsic() translates these symbols into LLVM instructions during code generation.jl_init_primitives() hooks C functions up to Julia function symbols. e.g. the symbol Base.is() is bound to C function pointer jl_f_is() by calling add_builtin_func(\"eval\", jl_f_top_eval).jl_new_main_module() creates the global \"Main\" module and sets jl_current_task->current_module = jl_main_module.Note: _julia_init() then sets jl_root_task->current_module = jl_core_module. jl_root_task is an alias of jl_current_task at this point, so the current_module set by jl_new_main_module() above is overwritten.jl_load(\"boot.jl\", sizeof(\"boot.jl\")) calls jl_parse_eval_all which repeatedly calls jl_toplevel_eval_flex() to execute boot.jl. <!– TODO – drill down into eval? –>jl_get_builtin_hooks() initializes global C pointers to Julia globals defined in boot.jl.jl_init_box_caches() pre-allocates global boxed integer value objects for values up to 1024. This speeds up allocation of boxed ints later on. e.g.:jl_value_t *jl_box_uint8(uint32_t x)\n{\n    return boxed_uint8_cache[(uint8_t)x];\n}_julia_init() iterates over the jl_core_module->bindings.table looking for jl_datatype_t values and sets the type name's module prefix to jl_core_module.jl_add_standard_imports(jl_main_module) does \"using Base\" in the \"Main\" module.Note: _julia_init() now reverts to jl_root_task->current_module = jl_main_module as it was before being set to jl_core_module above.Platform specific signal handlers are initialized for SIGSEGV (OSX, Linux), and SIGFPE (Windows).Other signals (SIGINFO, SIGBUS, SIGILL, SIGTERM, SIGABRT, SIGQUIT, SIGSYS and SIGPIPE) are hooked up to sigdie_handler() which prints a backtrace.jl_init_restored_modules() calls jl_module_run_initializer() for each deserialized module to run the __init__() function.Finally sigint_handler() is hooked up to SIGINT and calls jl_throw(jl_interrupt_exception)._julia_init() then returns back to main() in ui/repl.c and main() calls true_main(argc, (char**)argv).sidebar: sysimg\nIf there is a sysimg file, it contains a pre-cooked image of the Core and Main modules (and whatever else is created by boot.jl). See Building the Julia system image.jl_restore_system_image() deserializes the saved sysimg into the current Julia runtime environment and initialization continues after jl_init_box_caches() below...Note: jl_restore_system_image() (and dump.c in general) uses the Legacy ios.c library."
},

{
    "location": "devdocs/init.html#true_main()-1",
    "page": "Initialization of the Julia runtime",
    "title": "true_main()",
    "category": "section",
    "text": "true_main() loads the contents of argv[] into Base.ARGS.If a .jl \"program\" file was supplied on the command line, then exec_program() calls jl_load(program,len) which calls jl_parse_eval_all which repeatedly calls jl_toplevel_eval_flex() to execute the program.However, in our example (julia -e 'println(\"Hello World!\")'), jl_get_global(jl_base_module, jl_symbol(\"_start\")) looks up Base._start and jl_apply() executes it."
},

{
    "location": "devdocs/init.html#Base._start-1",
    "page": "Initialization of the Julia runtime",
    "title": "Base._start",
    "category": "section",
    "text": "Base._start calls Base.process_options which calls jl_parse_input_line(\"println(\"Hello World!\")\") to create an expression object and Base.eval() to execute it."
},

{
    "location": "devdocs/init.html#Base.eval-1",
    "page": "Initialization of the Julia runtime",
    "title": "Base.eval",
    "category": "section",
    "text": "Base.eval() was mapped to jl_f_top_eval by jl_init_primitives().jl_f_top_eval() calls jl_toplevel_eval_in(jl_main_module, ex), where ex is the parsed expression println(\"Hello World!\").jl_toplevel_eval_in() calls jl_toplevel_eval_flex() which calls eval() in interpreter.c.The stack dump below shows how the interpreter works its way through various methods of Base.println() and Base.print() before arriving at write(s::IO, a::Array{T}) where T  which does ccall(jl_uv_write()).jl_uv_write() calls uv_write() to write \"Hello World!\" to JL_STDOUT. See Libuv wrappers for stdio.:Hello World!Stack frame Source code Notes\njl_uv_write() jl_uv.c called though ccall\njulia_write_282942 stream.jl function write!(s::IO, a::Array{T}) where T\njulia_print_284639 ascii.jl print(io::IO, s::String) = (write(io, s); nothing)\njlcall_print_284639    \njl_apply() julia.h  \njl_trampoline() builtins.c  \njl_apply() julia.h  \njl_apply_generic() gf.c Base.print(Base.TTY, String)\njl_apply() julia.h  \njl_trampoline() builtins.c  \njl_apply() julia.h  \njl_apply_generic() gf.c Base.print(Base.TTY, String, Char, Char...)\njl_apply() julia.h  \njl_f_apply() builtins.c  \njl_apply() julia.h  \njl_trampoline() builtins.c  \njl_apply() julia.h  \njl_apply_generic() gf.c Base.println(Base.TTY, String, String...)\njl_apply() julia.h  \njl_trampoline() builtins.c  \njl_apply() julia.h  \njl_apply_generic() gf.c Base.println(String,)\njl_apply() julia.h  \ndo_call() interpreter.c  \neval() interpreter.c  \njl_interpret_toplevel_expr() interpreter.c  \njl_toplevel_eval_flex() toplevel.c  \njl_toplevel_eval() toplevel.c  \njl_toplevel_eval_in() builtins.c  \njl_f_top_eval() builtins.c  Since our example has just one function call, which has done its job of printing \"Hello World!\", the stack now rapidly unwinds back to main()."
},

{
    "location": "devdocs/init.html#jl_atexit_hook()-1",
    "page": "Initialization of the Julia runtime",
    "title": "jl_atexit_hook()",
    "category": "section",
    "text": "main() calls jl_atexit_hook(). This calls _atexit for each module, then calls jl_gc_run_all_finalizers() and cleans up libuv handles."
},

{
    "location": "devdocs/init.html#julia_save()-1",
    "page": "Initialization of the Julia runtime",
    "title": "julia_save()",
    "category": "section",
    "text": "Finally, main() calls julia_save(), which if requested on the command line, saves the runtime state to a new system image. See jl_compile_all() and jl_save_system_image()."
},

{
    "location": "devdocs/ast.html#",
    "page": "Julia ASTs",
    "title": "Julia ASTs",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/ast.html#ast-1",
    "page": "Julia ASTs",
    "title": "Julia ASTs",
    "category": "section",
    "text": "Julia has two representations of code. First there is a surface syntax AST returned by the parser (e.g. the parse() function), and manipulated by macros. It is a structured representation of code as it is written, constructed by julia-parser.scm from a character stream. Next there is a lowered form, or IR (intermediate representation), which is used by type inference and code generation. In the lowered form there are fewer types of nodes, all macros are expanded, and all control flow is converted to explicit branches and sequences of statements. The lowered form is constructed by julia-syntax.scm.First we will focus on the lowered form, since it is more important to the compiler. It is also less obvious to the human, since it results from a significant rearrangement of the input syntax."
},

{
    "location": "devdocs/ast.html#Lowered-form-1",
    "page": "Julia ASTs",
    "title": "Lowered form",
    "category": "section",
    "text": "The following data types exist in lowered form:Expr\nHas a node type indicated by the head field, and an args field which is a Vector{Any} of subexpressions.\nSlot\nIdentifies arguments and local variables by consecutive numbering. Slot is an abstract type with subtypes SlotNumber and TypedSlot. Both types have an integer-valued id field giving the slot index. Most slots have the same type at all uses, and so are represented with SlotNumber. The types of these slots are found in the slottypes field of their MethodInstance object. Slots that require per-use type annotations are represented with TypedSlot, which has a typ field.\nCodeInfo\nWraps the IR of a method.\nLineNumberNode\nContains a single number, specifying the line number the next statement came from.\nLabelNode\nBranch target, a consecutively-numbered integer starting at 0.\nGotoNode\nUnconditional branch.\nQuoteNode\nWraps an arbitrary value to reference as data. For example, the function f() = :a contains a QuoteNode whose value field is the symbol a, in order to return the symbol itself instead of evaluating it.\nGlobalRef\nRefers to global variable name in module mod.\nSSAValue\nRefers to a consecutively-numbered (starting at 0) static single assignment (SSA) variable inserted by the compiler.\nNewvarNode\nMarks a point where a variable is created. This has the effect of resetting a variable to undefined."
},

{
    "location": "devdocs/ast.html#Expr-types-1",
    "page": "Julia ASTs",
    "title": "Expr types",
    "category": "section",
    "text": "These symbols appear in the head field of Exprs in lowered form.call\nFunction call (dynamic dispatch). args[1] is the function to call, args[2:end] are the arguments.\ninvoke\nFunction call (static dispatch). args[1] is the MethodInstance to call, args[2:end] are the arguments (including the function that is being called, at args[2]).\nstatic_parameter\nReference a static parameter by index.\nline\nLine number and file name metadata. Unlike a LineNumberNode, can also contain a file name.\ngotoifnot\nConditional branch. If args[1] is false, goes to label identified in args[2].\n=\nAssignment.\nmethod\nAdds a method to a generic function and assigns the result if necessary.\nHas a 1-argument form and a 4-argument form. The 1-argument form arises from the syntax function foo end. In the 1-argument form, the argument is a symbol. If this symbol already names a function in the current scope, nothing happens. If the symbol is undefined, a new function is created and assigned to the identifier specified by the symbol. If the symbol is defined but names a non-function, an error is raised. The definition of \"names a function\" is that the binding is constant, and refers to an object of singleton type. The rationale for this is that an instance of a singleton type uniquely identifies the type to add the method to. When the type has fields, it wouldn't be clear whether the method was being added to the instance or its type.\nThe 4-argument form has the following arguments:\nargs[1]\nA function name, or false if unknown. If a symbol, then the expression first behaves like the 1-argument form above. This argument is ignored from then on. When this is false, it means a method is being added strictly by type, (::T)(x) = x.\nargs[2]\nA SimpleVector of argument type data. args[2][1] is a SimpleVector of the argument types, and args[2][2] is a SimpleVector of type variables corresponding to the method's static parameters.\nargs[3]\nA CodeInfo of the method itself. For \"out of scope\" method definitions (adding a method to a function that also has methods defined in different scopes) this is an expression that evaluates to a :lambda expression.\nargs[4]\ntrue or false, identifying whether the method is staged (@generated function).\nconst\nDeclares a (global) variable as constant.\nnull\nHas no arguments; simply yields the value nothing.\nnew\nAllocates a new struct-like object. First argument is the type. The new pseudo-function is lowered to this, and the type is always inserted by the compiler.  This is very much an internal-only feature, and does no checking. Evaluating arbitrary new expressions can easily segfault.\nreturn\nReturns its argument as the value of the enclosing function.\nthe_exception\nYields the caught exception inside a catch block. This is the value of the run time system variable jl_exception_in_transit.\nenter\nEnters an exception handler (setjmp). args[1] is the label of the catch block to jump to on error.\nleave\nPop exception handlers. args[1] is the number of handlers to pop.\ninbounds\nControls turning bounds checks on or off. A stack is maintained; if the first argument of this expression is true or false (true means bounds checks are disabled), it is pushed onto the stack. If the first argument is :pop, the stack is popped.\nboundscheck\nIndicates the beginning or end of a section of code that performs a bounds check. Like inbounds, a stack is maintained, and the second argument can be one of: true, false, or :pop.\ncopyast\nPart of the implementation of quasi-quote. The argument is a surface syntax AST that is simply copied recursively and returned at run time.\nmeta\nMetadata. args[1] is typically a symbol specifying the kind of metadata, and the rest of the arguments are free-form. The following kinds of metadata are commonly used:\n:inline and :noinline: Inlining hints.\n:push_loc: enters a sequence of statements from a specified source location.\nargs[2] specifies a filename, as a symbol.\nargs[3] optionally specifies the name of an (inlined) function that originally contained the code.\n:pop_loc: returns to the source location before the matching :push_loc."
},

{
    "location": "devdocs/ast.html#Method-1",
    "page": "Julia ASTs",
    "title": "Method",
    "category": "section",
    "text": "A unique'd container describing the shared metadata for a single method.name, module, file, line, sig\nMetadata to uniquely identify the method for the computer and the human.\nambig\nCache of other methods that may be ambiguous with this one.\nspecializations\nCache of all MethodInstance ever created for this Method, used to ensure uniqueness. Uniqueness is required for efficiency, especially for incremental precompile and tracking of method invalidation.\nsource\nThe original source code (usually compressed).\nroots\nPointers to non-AST things that have been interpolated into the AST, required by compression of the AST, type-inference, or the generation of native code.\nnargs, isva, called, isstaged, pure\nDescriptive bit-fields for the source code of this Method.\nmin_world / max_world\nThe range of world ages for which this method is visible to dispatch."
},

{
    "location": "devdocs/ast.html#MethodInstance-1",
    "page": "Julia ASTs",
    "title": "MethodInstance",
    "category": "section",
    "text": "A unique'd container describing a single callable signature for a Method. See especially Proper maintenance and care of multi-threading locks for important details on how to modify these fields safely.specTypes\nThe primary key for this MethodInstance. Uniqueness is guaranteed through a def.specializations lookup.\ndef\nThe Method that this function describes a specialization of. Or #undef, if this is a top-level Lambda that is not part of a Method.\nsparam_vals\nThe values of the static parameters in specTypes indexed by def.sparam_syms. For the MethodInstance at Method.unspecialized, this is the empty SimpleVector. But for a runtime MethodInstance from the MethodTable cache, this will always be defined and indexable.\nrettype\nThe inferred return type for the specFunctionObject field, which (in most cases) is also the computed return type for the function in general.\ninferred\nMay contain a cache of the inferred source for this function, or other information about the inference result such as a constant return value may be put here (if jlcall_api == 2), or it could be set to nothing to just indicate rettype is inferred.\nftpr\nThe generic jlcall entry point.\njlcall_api\nThe ABI to use when calling fptr. Some significant ones include:\n0 - Not compiled yet\n1 - JL_CALLABLE jl_value_t *(*)(jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)\n2 - Constant (value stored in inferred)\n3 - With Static-parameters forwarded jl_value_t *(*)(jl_svec_t *sparams, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)\n4 - Run in interpreter jl_value_t *(*)(jl_method_instance_t *meth, jl_function_t *f, jl_value_t *args[nargs], uint32_t nargs)\nmin_world / max_world\nThe range of world ages for which this method instance is valid to be called."
},

{
    "location": "devdocs/ast.html#CodeInfo-1",
    "page": "Julia ASTs",
    "title": "CodeInfo",
    "category": "section",
    "text": "A temporary container for holding lowered source code.code\nAn Any array of statements\nslotnames\nAn array of symbols giving the name of each slot (argument or local variable).\nslottypes\nAn array of types for the slots.\nslotflags\nA UInt8 array of slot properties, represented as bit flags:\n2  - assigned (only false if there are no assignment statements with this var on the left)\n8  - const (currently unused for local variables)\n16 - statically assigned once\n32 - might be used before assigned. This flag is only valid after type inference.\nssavaluetypes\nEither an array or an Int.\nIf an Int, it gives the number of compiler-inserted temporary locations in the function. If an array, specifies a type for each location.Boolean properties:inferred\nWhether this has been produced by type inference.\ninlineable\nWhether this should be inlined.\npropagate_inbounds\nWhether this should should propagate @inbounds when inlined for the purpose of eliding @boundscheck blocks.\npure\nWhether this is known to be a pure function of its arguments, without respect to the state of the method caches or other mutable global state."
},

{
    "location": "devdocs/ast.html#Surface-syntax-AST-1",
    "page": "Julia ASTs",
    "title": "Surface syntax AST",
    "category": "section",
    "text": "Front end ASTs consist entirely of Exprs and atoms (e.g. symbols, numbers). There is generally a different expression head for each visually distinct syntactic form. Examples will be given in s-expression syntax. Each parenthesized list corresponds to an Expr, where the first element is the head. For example (call f x) corresponds to Expr(:call, :f, :x) in Julia."
},

{
    "location": "devdocs/ast.html#Calls-1",
    "page": "Julia ASTs",
    "title": "Calls",
    "category": "section",
    "text": "Input AST\nf(x) (call f x)\nf(x, y=1, z=2) (call f x (kw y 1) (kw z 2))\nf(x; y=1) (call f (parameters (kw y 1)) x)\nf(x...) (call f (... x))do syntax:f(x) do a,b\n    body\nendparses as (call f (-> (tuple a b) (block body)) x)."
},

{
    "location": "devdocs/ast.html#Operators-1",
    "page": "Julia ASTs",
    "title": "Operators",
    "category": "section",
    "text": "Most uses of operators are just function calls, so they are parsed with the head call. However some operators are special forms (not necessarily function calls), and in those cases the operator itself is the expression head. In julia-parser.scm these are referred to as \"syntactic operators\". Some operators (+ and *) use N-ary parsing; chained calls are parsed as a single N-argument call. Finally, chains of comparisons have their own special expression structure.Input AST\nx+y (call + x y)\na+b+c+d (call + a b c d)\n2x (call * 2 x)\na&&b (&& a b)\nx += 1 (+= x 1)\na ? 1 : 2 (if a 1 2)\na:b (: a b)\na:b:c (: a b c)\na,b (tuple a b)\na==b (call == a b)\n1<i<=n (comparison 1 < i <= n)\na.b (. a (quote b))\na.(b) (. a b)"
},

{
    "location": "devdocs/ast.html#Bracketed-forms-1",
    "page": "Julia ASTs",
    "title": "Bracketed forms",
    "category": "section",
    "text": "Input AST\na[i] (ref a i)\nt[i;j] (typed_vcat t i j)\nt[i j] (typed_hcat t i j)\nt[a b; c d] (typed_vcat t (row a b) (row c d))\na{b} (curly a b)\na{b;c} (curly a (parameters c) b)\n[x] (vect x)\n[x,y] (vect x y)\n[x;y] (vcat x y)\n[x y] (hcat x y)\n[x y; z t] (vcat (row x y) (row z t))\n[x for y in z, a in b] (comprehension x (= y z) (= a b))\nT[x for y in z] (typed_comprehension T x (= y z))\n(a, b, c) (tuple a b c)\n(a; b; c) (block a (block b c))"
},

{
    "location": "devdocs/ast.html#Macros-1",
    "page": "Julia ASTs",
    "title": "Macros",
    "category": "section",
    "text": "Input AST\n@m x y (macrocall @m x y)\nBase.@m x y (macrocall (. Base (quote @m)) x y)\n@Base.m x y (macrocall (. Base (quote @m)) x y)"
},

{
    "location": "devdocs/ast.html#Strings-1",
    "page": "Julia ASTs",
    "title": "Strings",
    "category": "section",
    "text": "Input AST\n\"a\" \"a\"\nx\"y\" (macrocall @x_str \"y\")\nx\"y\"z (macrocall @x_str \"y\" \"z\")\n\"x = $x\" (string \"x = \" x)\n`a b c` (macrocall @cmd \"a b c\")Doc string syntax:\"some docs\"\nf(x) = xparses as (macrocall (|.| Core '@doc) \"some docs\" (= (call f x) (block x)))."
},

{
    "location": "devdocs/ast.html#Imports-and-such-1",
    "page": "Julia ASTs",
    "title": "Imports and such",
    "category": "section",
    "text": "Input AST\nimport a (import a)\nimport a.b.c (import a b c)\nimport ...a (import . . . a)\nimport a.b, c.d (toplevel (import a b) (import c d))\nimport Base: x (import Base x)\nimport Base: x, y (toplevel (import Base x) (import Base y))\nexport a, b (export a b)"
},

{
    "location": "devdocs/ast.html#Numbers-1",
    "page": "Julia ASTs",
    "title": "Numbers",
    "category": "section",
    "text": "Julia supports more number types than many scheme implementations, so not all numbers are represented directly as scheme numbers in the AST.Input AST\n11111111111111111111 (macrocall @int128_str \"11111111111111111111\")\n0xfffffffffffffffff (macrocall @uint128_str \"0xfffffffffffffffff\")\n1111...many digits... (macrocall @big_str \"1111....\")"
},

{
    "location": "devdocs/ast.html#Block-forms-1",
    "page": "Julia ASTs",
    "title": "Block forms",
    "category": "section",
    "text": "A block of statements is parsed as (block stmt1 stmt2 ...).If statement:if a\n    b\nelseif c\n    d\nelse e\n    f\nendparses as:(if a (block (line 2) b)\n    (block (line 3) (if c (block (line 4) d)\n                        (block (line 5) e (line 6) f))))A while loop parses as (while condition body).A for loop parses as (for (= var iter) body). If there is more than one iteration specification, they are parsed as a block: (for (block (= v1 iter1) (= v2 iter2)) body).break and continue are parsed as 0-argument expressions (break) and (continue).let is parsed as (let body (= var1 val1) (= var2 val2) ...).A basic function definition is parsed as (function (call f x) body). A more complex example:function f{T}(x::T; k = 1)\n    return x+1\nendparses as:(function (call (curly f T) (parameters (kw k 1))\n                (:: x T))\n          (block (line 2 file.jl) (return (call + x 1))))Type definition:mutable struct Foo{T<:S}\n    x::T\nendparses as:(type #t (curly Foo (<: T S))\n      (block (line 2 none) (:: x T)))The first argument is a boolean telling whether the type is mutable.try blocks parse as (try try_block var catch_block finally_block). If no variable is present after catch, var is #f. If there is no finally clause, then the last argument is not present."
},

{
    "location": "devdocs/types.html#",
    "page": "Más sobre tipos",
    "title": "Más sobre tipos",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/types.html#types-1",
    "page": "Más sobre tipos",
    "title": "Más sobre tipos",
    "category": "section",
    "text": "Si ha usado Julia durante un tiempo, comprenderá el papel fundamental que juegan los tipos. Aquí intentamos meternos debajo del capó, centrándonos fundamentalmente en los Tipos Paramétricos."
},

{
    "location": "devdocs/types.html#Tipos-y-conjuntos-(y-Any-y-Union{}/Bottom)-1",
    "page": "Más sobre tipos",
    "title": "Tipos y conjuntos (y Any y Union{}/Bottom)",
    "category": "section",
    "text": "Tal vez sea ms sencillo concebir el sistema de tipos de Julia en términos de conjuntos. Aunque los programas pueden manipular los valores individuales, un tipo se refiere a un conjunto de valores. Esto no es la misma cosa que una colección; por ejemplo, un Set de valores es en sí mismo un solo valor de tipo Set. En lugar de ello, un tipo describe un conjunto de  posible valores, expresando incertidumbre sobre qué valor tenemos.Un tipo concreto T describe el conjunto de valores cuya etiqueta directa, tal y como es obtenida por la función typeof es T. Un tipo abstracto describe un conjunto de valores posiblemente más grande.Any describe el universo completo de valores posibles. Integer es un subconjunto de Any que incluye Int, Int8, y otros tipos concretos. Internamente, Julia también hace un uso intensivo de otro tipo conocido como  Bottom, que puede también ser escrito como Union{}. Esto corresponde al conjunto vacío.Los tipos de Julia soportan las operaciones estándar de la teora de conjuntos: uno puede preguntar si T1 es un \"subconjunto\" de T2 con T1 <: T2. Análogamente, uno intersecta dos tipos usando typeintersect, realiza su unión con Union, y calcula un tipo que contiene su unión con typejoin:julia> typeintersect(Int, Float64)\nUnion{}\n\njulia> Union{Int, Float64}\nUnion{Float64, Int64}\n\njulia> typejoin(Int, Float64)\nReal\n\njulia> typeintersect(Signed, Union{UInt8, Int8})\nInt8\n\njulia> Union{Signed, Union{UInt8, Int8}}\nUnion{Signed, UInt8}\n\njulia> typejoin(Signed, Union{UInt8, Int8})\nInteger\n\njulia> typeintersect(Tuple{Integer,Float64}, Tuple{Int,Real})\nTuple{Int64,Float64}\n\njulia> Union{Tuple{Integer,Float64}, Tuple{Int,Real}}\nUnion{Tuple{Int64,Real}, Tuple{Integer,Float64}}\n\njulia> typejoin(Tuple{Integer,Float64}, Tuple{Int,Real})\nTuple{Integer,Real}While these operations may seem abstract, they lie at the heart of Julia.  For example, method dispatch is implemented by stepping through the items in a method list until reaching one for which the type of the argument tuple is a subtype of the method signature. For this algorithm to work, it's important that methods be sorted by their specificity, and that the search begins with the most specific methods. Consequently, Julia also implements a partial order on types; this is achieved by functionality that is similar to <:, but with differences that will be discussed below."
},

{
    "location": "devdocs/types.html#UnionAll-types-1",
    "page": "Más sobre tipos",
    "title": "UnionAll types",
    "category": "section",
    "text": "Julia's type system can also express an iterated union of types: a union of types over all values of some variable. This is needed to describe parametric types where the values of some parameters are not known.For example, :obj:Array has two parameters as in Array{Int,2}. If we did not know the element type, we could write Array{T,2} where T, which is the union of Array{T,2} for all values of T: Union{Array{Int8,2}, Array{Int16,2}, ...}.Such a type is represented by a UnionAll object, which contains a variable (T in this example, of type TypeVar), and a wrapped type (Array{T,2} in this example).Consider the following methods:f1(A::Array) = 1\nf2(A::Array{Int}) = 2\nf3(A::Array{T}) where {T<:Any} = 3\nf4(A::Array{Any}) = 4The signature of f3 is a UnionAll type wrapping a tuple type. All but f4 can be called with a = [1,2]; all but f2 can be called with b = Any[1,2].Let's look at these types a little more closely:julia> dump(Array)\nUnionAll\n  var: TypeVar\n    name: Symbol T\n    lb: Core.TypeofBottom Union{}\n    ub: Any\n  body: UnionAll\n    var: TypeVar\n      name: Symbol N\n      lb: Core.TypeofBottom Union{}\n      ub: Any\n    body: Array{T,N} <: DenseArray{T,N}This indicates that Array actually names a UnionAll type. There is one UnionAll type for each parameter, nested. The syntax Array{Int,2} is equivalent to Array{Int}{2}; internally each UnionAll is instantiated with a particular variable value, one at a time, outermost-first. This gives a natural meaning to the omission of trailing type parameters; Array{Int} gives a type equivalent to Array{Int,N} where N.A TypeVar is not itself a type, but rather should be considered part of the structure of a UnionAll type. Type variables have lower and upper bounds on their values (in the fields lb and ub). The symbol name is purely cosmetic. Internally, TypeVars are compared by address, so they are defined as mutable types to ensure that \"different\" type variables can be distinguished. However, by convention they should not be mutated.One can construct TypeVars manually:julia> TypeVar(:V, Signed, Real)\nSigned<:V<:RealThere are convenience versions that allow you to omit any of these arguments except the name symbol.The syntax Array{T} where T<:Integer is lowered tolet T = TypeVar(:T,Integer)\n    UnionAll(T, Array{T})\nendso it is seldom necessary to construct a TypeVar manually (indeed, this is to be avoided)."
},

{
    "location": "devdocs/types.html#Free-variables-1",
    "page": "Más sobre tipos",
    "title": "Free variables",
    "category": "section",
    "text": "The concept of a free type variable is extremely important in the type system. We say that a variable V is free in type T if T does not contain the UnionAll that introduces variable V. For example, the type Array{Array{V} where V<:Integer} has no free variables, but the Array{V} part inside of it does have a free variable, V.A type with free variables is, in some sense, not really a type at all. Consider the type Array{Array{T}} where T, which refers to all homogeneous arrays of arrays. The inner type Array{T}, seen by itself, might seem to refer to any kind of array. However, every element of the outer array must have the same array type, so Array{T} cannot refer to just any old array. One could say that Array{T} effectively \"occurs\" multiple times, and T must have the same value each \"time\".For this reason, the function jl_has_free_typevars in the C API is very important. Types for which it returns true will not give meaningful answers in subtyping and other type functions."
},

{
    "location": "devdocs/types.html#TypeNames-1",
    "page": "Más sobre tipos",
    "title": "TypeNames",
    "category": "section",
    "text": "The following two Array types are functionally equivalent, yet print differently:julia> TV, NV = TypeVar(:T), TypeVar(:N)\n(T, N)\n\njulia> Array\nArray\n\njulia> Array{TV,NV}\nArray{T,N}These can be distinguished by examining the name field of the type, which is an object of type TypeName:julia> dump(Array{Int,1}.name)\nTypeName\n  name: Symbol Array\n  module: Module Core\n  names: empty SimpleVector\n  wrapper: UnionAll\n    var: TypeVar\n      name: Symbol T\n      lb: Core.TypeofBottom Union{}\n      ub: Any\n    body: UnionAll\n      var: TypeVar\n        name: Symbol N\n        lb: Core.TypeofBottom Union{}\n        ub: Any\n      body: Array{T,N} <: DenseArray{T,N}\n  cache: SimpleVector\n    ...\n\n  linearcache: SimpleVector\n    ...\n\n  hash: Int64 -7900426068641098781\n  mt: MethodTable\n    name: Symbol Array\n    defs: Void nothing\n    cache: Void nothing\n    max_args: Int64 0\n    kwsorter: #undef\n    module: Module Core\n    : Int64 0\n    : Int64 0In this case, the relevant field is wrapper, which holds a reference to the top-level type used to make new Array types.julia> pointer_from_objref(Array)\nPtr{Void} @0x00007fcc7de64850\n\njulia> pointer_from_objref(Array.body.body.name.wrapper)\nPtr{Void} @0x00007fcc7de64850\n\njulia> pointer_from_objref(Array{TV,NV})\nPtr{Void} @0x00007fcc80c4d930\n\njulia> pointer_from_objref(Array{TV,NV}.name.wrapper)\nPtr{Void} @0x00007fcc7de64850The wrapper field of Array points to itself, but for Array{TV,NV} it points back to the original definition of the type.What about the other fields? hash assigns an integer to each type.  To examine the cache field, it's helpful to pick a type that is less heavily used than Array. Let's first create our own type:julia> struct MyType{T,N} end\n\njulia> MyType{Int,2}\nMyType{Int64,2}\n\njulia> MyType{Float32, 5}\nMyType{Float32,5}\n\njulia> MyType.body.body.name.cache\nsvec(MyType{Float32,5}, MyType{Int64,2}, #undef, #undef, #undef, #undef, #undef, #undef)(The cache is pre-allocated to have length 8, but only the first two entries are populated.) Consequently, when you instantiate a parametric type, each concrete type gets saved in a type cache.  However, instances containing free type variables are not cached."
},

{
    "location": "devdocs/types.html#Tuple-types-1",
    "page": "Más sobre tipos",
    "title": "Tuple types",
    "category": "section",
    "text": "Tuple types constitute an interesting special case.  For dispatch to work on declarations like x::Tuple, the type has to be able to accommodate any tuple.  Let's check the parameters:julia> Tuple\nTuple\n\njulia> Tuple.parameters\nsvec(Vararg{Any,N} where N)Unlike other types, tuple types are covariant in their parameters, so this definition permits Tuple to match any type of tuple:julia> typeintersect(Tuple, Tuple{Int,Float64})\nTuple{Int64,Float64}\n\njulia> typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})\nTuple{Int64,Float64}However, if a variadic (Vararg) tuple type has free variables it can describe different kinds of tuples:julia> typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})\nTuple{Int64,Float64}\n\njulia> typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})\nUnion{}Notice that when T is free with respect to the Tuple type (i.e. its binding UnionAll type is outside the Tuple type), only one T value must work over the whole type. Therefore a heterogeneous tuple does not match.Finally, it's worth noting that Tuple{} is distinct:julia> Tuple{}\nTuple{}\n\njulia> Tuple{}.parameters\nsvec()\n\njulia> typeintersect(Tuple{}, Tuple{Int})\nUnion{}What is the \"primary\" tuple-type?julia> pointer_from_objref(Tuple)\nPtr{Void} @0x00007f5998a04370\n\njulia> pointer_from_objref(Tuple{})\nPtr{Void} @0x00007f5998a570d0\n\njulia> pointer_from_objref(Tuple.name.wrapper)\nPtr{Void} @0x00007f5998a04370\n\njulia> pointer_from_objref(Tuple{}.name.wrapper)\nPtr{Void} @0x00007f5998a04370so Tuple == Tuple{Vararg{Any}} is indeed the primary type."
},

{
    "location": "devdocs/types.html#Diagonal-types-1",
    "page": "Más sobre tipos",
    "title": "Diagonal types",
    "category": "section",
    "text": "Consider the type Tuple{T,T} where T. A method with this signature would look like:f(x::T, y::T) where {T} = ...According to the usual interpretation of a UnionAll type, this T ranges over all types, including Any, so this type should be equivalent to Tuple{Any,Any}. However, this interpretation causes some practical problems.First, a value of T needs to be available inside the method definition. For a call like f(1, 1.0), it's not clear what T should be. It could be Union{Int,Float64}, or perhaps Real. Intuitively, we expect the declaration x::T to mean T === typeof(x). To make sure that invariant holds, we need typeof(x) === typeof(y) === T in this method. That implies the method should only be called for arguments of the exact same type.It turns out that being able to dispatch on whether two values have the same type is very useful (this is used by the promotion system for example), so we have multiple reasons to want a different interpretation of Tuple{T,T} where T. To make this work we add the following rule to subtyping: if a variable occurs more than once in covariant position, it is restricted to ranging over only concrete types. (\"Covariant position\" means that only Tuple and Union types occur between an occurrence of a variable and the UnionAll type that introduces it.) Such variables are called \"diagonal variables\" or \"concrete variables\".So for example, Tuple{T,T} where T can be seen as Union{Tuple{Int8,Int8}, Tuple{Int16,Int16}, ...}, where T ranges over all concrete types. This gives rise to some interesting subtyping results. For example Tuple{Real,Real} is not a subtype of Tuple{T,T} where T, because it includes some types like Tuple{Int8,Int16} where the two elements have different types. Tuple{Real,Real} and Tuple{T,T} where T have the non-trivial intersection Tuple{T,T} where T<:Real. However, Tuple{Real} is a subtype of Tuple{T} where T, because in that case T occurs only once and so is not diagonal.Next consider a signature like the following:f(a::Array{T}, x::T, y::T) where {T} = ...In this case, T occurs in invariant position inside Array{T}. That means whatever type of array is passed unambiguously determines the value of T –- we say T has an equality constraint on it. Therefore in this case the diagonal rule is not really necessary, since the array determines T and we can then allow x and y to be of any subtypes of T. So variables that occur in invariant position are never considered diagonal. This choice of behavior is slightly controversial –- some feel this definition should be written asf(a::Array{T}, x::S, y::S) where {T, S<:T} = ...to clarify whether x and y need to have the same type. In this version of the signature they would, or we could introduce a third variable for the type of y if x and y can have different types.The next complication is the interaction of unions and diagonal variables, e.g.f(x::Union{Void,T}, y::T) where {T} = ...Consider what this declaration means. y has type T. x then can have either the same type T, or else be of type Void. So all of the following calls should match:f(1, 1)\nf(\"\", \"\")\nf(2.0, 2.0)\nf(nothing, 1)\nf(nothing, \"\")\nf(nothing, 2.0)These examples are telling us something: when x is nothing::Void, there are no extra constraints on y. It is as if the method signature had y::Any. This means that whether a variable is diagonal is not a static property based on where it appears in a type. Rather, it depends on where a variable appears when the subtyping algorithm uses it. When x has type Void, we don't need to use the T in Union{Void,T}, so T does not \"occur\". Indeed, we have the following type equivalence:(Tuple{Union{Void,T},T} where T) == Union{Tuple{Void,Any}, Tuple{T,T} where T}"
},

{
    "location": "devdocs/types.html#Subtyping-diagonal-variables-1",
    "page": "Más sobre tipos",
    "title": "Subtyping diagonal variables",
    "category": "section",
    "text": "The subtyping algorithm for diagonal variables has two components: (1) identifying variable occurrences, and (2) ensuring that diagonal variables range over concrete types only.The first task is accomplished by keeping counters occurs_inv and occurs_cov (in src/subtype.c) for each variable in the environment, tracking the number of invariant and covariant occurrences, respectively. A variable is diagonal when occurs_inv == 0 && occurs_cov > 1.The second task is accomplished by imposing a condition on a variable's lower bound. As the subtyping algorithm runs, it narrows the bounds of each variable (raising lower bounds and lowering upper bounds) to keep track of the range of variable values for which the subtype relation would hold. When we are done evaluating the body of a UnionAll type whose variable is diagonal, we look at the final values of the bounds. Since the variable must be concrete, a contradiction occurs if its lower bound could not be a subtype of a concrete type. For example, an abstract type like AbstractArray cannot be a subtype of a concrete type, but a concrete type like Int can be, and the empty type Bottom can be as well. If a lower bound fails this test the algorithm stops with the answer false.For example, in the problem Tuple{Int,String} <: Tuple{T,T} where T, we derive that this would be true if T were a supertype of Union{Int,String}. However, Union{Int,String} is an abstract type, so the relation does not hold.This concreteness test is done by the function is_leaf_bound. Note that this test is slightly different from jl_is_leaf_type, since it also returns true for Bottom. Currently this function is heuristic, and does not catch all possible concrete types. The difficulty is that whether a lower bound is concrete might depend on the values of other type variable bounds. For example, Vector{T} is equivalent to the concrete type Vector{Int} only if both the upper and lower bounds of T equal Int. We have not yet worked out a complete algorithm for this."
},

{
    "location": "devdocs/types.html#Introduction-to-the-internal-machinery-1",
    "page": "Más sobre tipos",
    "title": "Introduction to the internal machinery",
    "category": "section",
    "text": "Most operations for dealing with types are found in the files jltypes.c and subtype.c. A good way to start is to watch subtyping in action. Build Julia with make debug and fire up Julia within a debugger. gdb debugging tips has some tips which may be useful.Because the subtyping code is used heavily in the REPL itself–and hence breakpoints in this code get triggered often–it will be easiest if you make the following definition:julia> function mysubtype(a,b)\n           ccall(:jl_breakpoint, Void, (Any,), nothing)\n           issubtype(a, b)\n       endand then set a breakpoint in jl_breakpoint.  Once this breakpoint gets triggered, you can set breakpoints in other functions.As a warm-up, try the following:mysubtype(Tuple{Int,Float64}, Tuple{Integer,Real})We can make it more interesting by trying a more complex case:mysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)"
},

{
    "location": "devdocs/types.html#Subtyping-and-method-sorting-1",
    "page": "Más sobre tipos",
    "title": "Subtyping and method sorting",
    "category": "section",
    "text": "The type_morespecific functions are used for imposing a partial order on functions in method tables (from most-to-least specific). Specificity is strict; if a is more specific than b, then a does not equal b and b is not more specific than a.If a is a strict subtype of b, then it is automatically considered more specific. From there, type_morespecific employs some less formal rules. For example, subtype is sensitive to the number of arguments, but type_morespecific may not be. In particular, Tuple{Int,AbstractFloat} is more specific than Tuple{Integer}, even though it is not a subtype.  (Of Tuple{Int,AbstractFloat} and Tuple{Integer,Float64}, neither is more specific than the other.)  Likewise, Tuple{Int,Vararg{Int}} is not a subtype of Tuple{Integer}, but it is considered more specific. However, morespecific does get a bonus for length: in particular, Tuple{Int,Int} is more specific than Tuple{Int,Vararg{Int}}.If you're debugging how methods get sorted, it can be convenient to define the function:type_morespecific(a, b) = ccall(:jl_type_morespecific, Cint, (Any,Any), a, b)which allows you to test whether tuple type a is more specific than tuple type b."
},

{
    "location": "devdocs/object.html#",
    "page": "Memory layout of Julia Objects",
    "title": "Memory layout of Julia Objects",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/object.html#object-1",
    "page": "Memory layout of Julia Objects",
    "title": "Memory layout of Julia Objects",
    "category": "section",
    "text": ""
},

{
    "location": "devdocs/object.html#Object-layout-(jl_value_t)-1",
    "page": "Memory layout of Julia Objects",
    "title": "Object layout (jl_value_t)",
    "category": "section",
    "text": "The jl_value_t struct is the name for a block of memory owned by the Julia Garbage Collector, representing the data associated with a Julia object in memory. Absent any type information, it is simply an opaque pointer:typedef struct jl_value_t* jl_pvalue_t;Each jl_value_t struct is contained in a jl_typetag_t struct that contains metadata information about the Julia object, such as its type and garbage collector (gc) reachability:typedef struct {\n    opaque metadata;\n    jl_value_t value;\n} jl_typetag_t;The type of any Julia object is an instance of a leaf jl_datatype_t object. The jl_typeof() function can be used to query for it:jl_value_t *jl_typeof(jl_value_t *v);The layout of the object depends on its type. Reflection methods can be used to inspect that layout. A field can be accessed by calling one of the get-field methods:jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\njl_value_t *jl_get_field(jl_value_t *o, char *fld);If the field types are known, a priori, to be all pointers, the values can also be extracted directly as an array access:jl_value_t *v = value->fieldptr[n];As an example, a \"boxed\" uint16_t is stored as follows:struct {\n    opaque metadata;\n    struct {\n        uint16_t data;        // -- 2 bytes\n    } jl_value_t;\n};This object is created by jl_box_uint16(). Note that the jl_value_t pointer references the data portion, not the metadata at the top of the struct.A value may be stored \"unboxed\" in many circumstances (just the data, without the metadata, and possibly not even stored but just kept in registers), so it is unsafe to assume that the address of a box is a unique identifier. The \"egal\" test (corresponding to the === function in Julia), should instead be used to compare two unknown objects for equivalence:int jl_egal(jl_value_t *a, jl_value_t *b);This optimization should be relatively transparent to the API, since the object will be \"boxed\" on-demand, whenever a jl_value_t pointer is needed.Note that modification of a jl_value_t pointer in memory is permitted only if the object is mutable. Otherwise, modification of the value may corrupt the program and the result will be undefined. The mutability property of a value can be queried for with:int jl_is_mutable(jl_value_t *v);If the object being stored is a jl_value_t, the Julia garbage collector must be notified also:void jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);However, the Embedding Julia section of the manual is also required reading at this point, for covering other details of boxing and unboxing various types, and understanding the gc interactions.Mirror structs for some of the built-in types are defined in julia.h. The corresponding global jl_datatype_t objects are created by jl_init_types in jltypes.c."
},

{
    "location": "devdocs/object.html#Garbage-collector-mark-bits-1",
    "page": "Memory layout of Julia Objects",
    "title": "Garbage collector mark bits",
    "category": "section",
    "text": "The garbage collector uses several bits from the metadata portion of the jl_typetag_t to track each object in the system. Further details about this algorithm can be found in the comments of the garbage collector implementation in gc.c."
},

{
    "location": "devdocs/object.html#Object-allocation-1",
    "page": "Memory layout of Julia Objects",
    "title": "Object allocation",
    "category": "section",
    "text": "Most new objects are allocated by jl_new_structv():jl_value_t *jl_new_struct(jl_datatype_t *type, ...);\njl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);Although, isbits objects can be also constructed directly from memory:jl_value_t *jl_new_bits(jl_value_t *bt, void *data)And some objects have special constructors that must be used instead of the above functions:Types:jl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);\njl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);\njl_uniontype_t *jl_new_uniontype(jl_tuple_t *types);While these are the most commonly used options, there are more low-level constructors too, which you can find declared in julia.h. These are used in jl_init_types() to create the initial types needed to bootstrap the creation of the Julia system image.Tuples:jl_tuple_t *jl_tuple(size_t n, ...);\njl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);\njl_tuple_t *jl_alloc_tuple(size_t n);The representation of tuples is highly unique in the Julia object representation ecosystem. In some cases, a Base.tuple() object may be an array of pointers to the objects contained by the tuple equivalent to:typedef struct {\n    size_t length;\n    jl_value_t *data[length];\n} jl_tuple_t;However, in other cases, the tuple may be converted to an anonymous isbits type and stored unboxed, or it may not stored at all (if it is not being used in a generic context as a jl_value_t*).Symbols:jl_sym_t *jl_symbol(const char *str);Functions and MethodInstance:jl_function_t *jl_new_generic_function(jl_sym_t *name);\njl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);Arrays:jl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);\njl_array_t *jl_new_arrayv(jl_value_t *atype, ...);\njl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\njl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr, size_t nc);\njl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr, size_t nc, size_t z);\njl_array_t *jl_alloc_vec_any(size_t n);Note that many of these have alternative allocation functions for various special-purposes. The list here reflects the more common usages, but a more complete list can be found by reading the julia.h header file.Internal to Julia, storage is typically allocated by newstruct() (or newobj() for the special types):jl_value_t *newstruct(jl_value_t *type);\njl_value_t *newobj(jl_value_t *type, size_t nfields);And at the lowest level, memory is getting allocated by a call to the garbage collector (in gc.c), then tagged with its type:jl_value_t *jl_gc_allocobj(size_t nbytes);\nvoid jl_set_typeof(jl_value_t *v, jl_datatype_t *type);Note that all objects are allocated in multiples of 4 bytes and aligned to the platform pointer size. Memory is allocated from a pool for smaller objects, or directly with malloc() for large objects.sidebar: Singleton Types\nSingleton types have only one instance and no data fields. Singleton instances have a size of 0 bytes, and consist only of their metadata. e.g. nothing::Void.See Singleton Types and Nothingness and missing values"
},

{
    "location": "devdocs/eval.html#",
    "page": "Eval of Julia code",
    "title": "Eval of Julia code",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/eval.html#eval-1",
    "page": "Eval of Julia code",
    "title": "Eval of Julia code",
    "category": "section",
    "text": "One of the hardest parts about learning how the Julia Language runs code is learning how all of the pieces work together to execute a block of code.Each chunk of code typically makes a trip through many steps with potentially unfamiliar names, such as (in no particular order): flisp, AST, C++, LLVM, eval, typeinf, macroexpand, sysimg (or system image), bootstrapping, compile, parse, execute, JIT, interpret, box, unbox, intrinsic function, and primitive function, before turning into the desired result (hopefully).sidebar: Definitions\nREPL\nREPL stands for Read-Eval-Print Loop. It's just what we call the command line environment for short.\nAST\nAbstract Syntax Tree The AST is the digital representation of the code structure. In this form the code has been tokenized for meaning so that it is more suitable for manipulation and execution."
},

{
    "location": "devdocs/eval.html#Julia-Execution-1",
    "page": "Eval of Julia code",
    "title": "Julia Execution",
    "category": "section",
    "text": "The 10,000 foot view of the whole process is as follows:The user starts julia.\nThe C function main() from ui/repl.c gets called. This function processes the command line arguments, filling in the jl_options struct and setting the variable ARGS. It then initializes Julia (by calling julia_init in task.c, which may load a previously compiled sysimg). Finally, it passes off control to Julia by calling Base._start().\nWhen _start() takes over control, the subsequent sequence of commands depends on the command line arguments given. For example, if a filename was supplied, it will proceed to execute that file. Otherwise, it will start an interactive REPL.\nSkipping the details about how the REPL interacts with the user, let's just say the program ends up with a block of code that it wants to run.\nIf the block of code to run is in a file, jl_load(char *filename) gets invoked to load the file and parse it. Each fragment of code is then passed to eval to execute.\nEach fragment of code (or AST), is handed off to eval() to turn into results.\neval() takes each code fragment and tries to run it in jl_toplevel_eval_flex().\njl_toplevel_eval_flex() decides whether the code is a \"toplevel\" action (such as using or module), which would be invalid inside a function. If so, it passes off the code to the toplevel interpreter.\njl_toplevel_eval_flex() then expands the code to eliminate any macros and to \"lower\" the AST to make it simpler to execute.\njl_toplevel_eval_flex() then uses some simple heuristics to decide whether to JIT compiler the  AST or to interpret it directly.\nThe bulk of the work to interpret code is handled by eval in interpreter.c.\nIf instead, the code is compiled, the bulk of the work is handled by codegen.cpp. Whenever a  Julia function is called for the first time with a given set of argument types, type inference  will be run on that function. This information is used by the codegen step to generate  faster code.\nEventually, the user quits the REPL, or the end of the program is reached, and the _start()  method returns.\nJust before exiting, main() calls jl_atexit_hook(exit_code).  This calls Base._atexit() (which calls any functions registered to atexit() inside  Julia). Then it calls jl_gc_run_all_finalizers().  Finally, it gracefully cleans up all libuv handles and waits for them to flush and close."
},

{
    "location": "devdocs/eval.html#dev-parsing-1",
    "page": "Eval of Julia code",
    "title": "Parsing",
    "category": "section",
    "text": "The Julia parser is a small lisp program written in femtolisp, the source-code for which is distributed inside Julia in src/flisp.The interface functions for this are primarily defined in jlfrontend.scm. The code in ast.c handles this handoff on the Julia side.The other relevant files at this stage are julia-parser.scm, which handles tokenizing Julia code and turning it into an AST, and julia-syntax.scm, which handles transforming complex AST representations into simpler, \"lowered\" AST representations which are more suitable for analysis and execution."
},

{
    "location": "devdocs/eval.html#dev-macro-expansion-1",
    "page": "Eval of Julia code",
    "title": "Macro Expansion",
    "category": "section",
    "text": "When eval() encounters a macro, it expands that AST node before attempting to evaluate the expression. Macro expansion involves a handoff from eval() (in Julia), to the parser function jl_macroexpand() (written in flisp) to the Julia macro itself (written in - what else - Julia) via fl_invoke_julia_macro(), and back.Typically, macro expansion is invoked as a first step during a call to expand()/jl_expand(), although it can also be invoked directly by a call to macroexpand()/jl_macroexpand()."
},

{
    "location": "devdocs/eval.html#dev-type-inference-1",
    "page": "Eval of Julia code",
    "title": "Type Inference",
    "category": "section",
    "text": "Type inference is implemented in Julia by typeinf() in inference.jl. Type inference is the process of examining a Julia function and determining bounds for the types of each of its variables, as well as bounds on the type of the return value from the function. This enables many future optimizations, such as unboxing of known immutable values, and compile-time hoisting of various run-time operations such as computing field offsets and function pointers. Type inference may also include other steps such as constant propagation and inlining.sidebar: More Definitions\nJIT\nJust-In-Time Compilation The process of generating native-machine code into memory right when it is needed.\nLLVM\nLow-Level Virtual Machine (a compiler) The Julia JIT compiler is a program/library called libLLVM. Codegen in Julia refers both to the process of taking a Julia AST and turning it into LLVM instructions, and the process of LLVM optimizing that and turning it into native assembly instructions.\nC++\nThe programming language that LLVM is implemented in, which means that codegen is also implemented in this language. The rest of Julia's library is implemented in C, in part because its smaller feature set makes it more usable as a cross-language interface layer.\nbox\nThis term is used to describe the process of taking a value and allocating a wrapper around the data that is tracked by the garbage collector (gc) and is tagged with the object's type.\nunbox\nThe reverse of boxing a value. This operation enables more efficient manipulation of data when the type of that data is fully known at compile-time (through type inference).\ngeneric function\nA Julia function composed of multiple \"methods\" that are selected for dynamic dispatch based on the argument type-signature\nanonymous function or \"method\"\nA Julia function without a name and without type-dispatch capabilities\nprimitive function\nA function implemented in C but exposed in Julia as a named function \"method\" (albeit without generic function dispatch capabilities, similar to a anonymous function)\nintrinsic function\nA low-level operation exposed as a function in Julia. These pseudo-functions implement operations on raw bits such as add and sign extend that cannot be expressed directly in any other way. Since they operate on bits directly, they must be compiled into a function and surrounded by a call to Core.Intrinsics.box(T, ...) to reassign type information to the value."
},

{
    "location": "devdocs/eval.html#dev-codegen-1",
    "page": "Eval of Julia code",
    "title": "JIT Code Generation",
    "category": "section",
    "text": "Codegen is the process of turning a Julia AST into native machine code.The JIT environment is initialized by an early call to jl_init_codegen in codegen.cpp.On demand, a Julia method is converted into a native function by the function emit_function(jl_method_instance_t*). (note, when using the MCJIT (in LLVM v3.4+), each function must be JIT into a new module.) This function recursively calls emit_expr() until the entire function has been emitted.Much of the remaining bulk of this file is devoted to various manual optimizations of specific code patterns. For example, emit_known_call() knows how to inline many of the primitive functions (defined in builtins.c) for various combinations of argument types.Other parts of codegen are handled by various helper files:debuginfo.cpp\nHandles backtraces for JIT functions\nccall.cpp\nHandles the ccall and llvmcall FFI, along with various abi_*.cpp files\nintrinsics.cpp\nHandles the emission of various low-level intrinsic functionssidebar: Bootstrapping\nThe process of creating a new system image is called \"bootstrapping\".The etymology of this word comes from the phrase \"pulling oneself up by the bootstraps\", and refers to the idea of starting from a very limited set of available functions and definitions and ending with the creation of a full-featured environment."
},

{
    "location": "devdocs/eval.html#dev-sysimg-1",
    "page": "Eval of Julia code",
    "title": "System Image",
    "category": "section",
    "text": "The system image is a precompiled archive of a set of Julia files. The sys.ji file distributed with Julia is one such system image, generated by executing the file sysimg.jl, and serializing the resulting environment (including Types, Functions, Modules, and all other defined values) into a file. Therefore, it contains a frozen version of the Main, Core, and Base modules (and whatever else was in the environment at the end of bootstrapping). This serializer/deserializer is implemented by jl_save_system_image/jl_restore_system_image in dump.c.If there is no sysimg file (jl_options.image_file == NULL), this also implies that --build was given on the command line, so the final result should be a new sysimg file. During Julia initialization, minimal Core and Main modules are created. Then a file named boot.jl is evaluated from the current directory. Julia then evaluates any file given as a command line argument until it reaches the end. Finally, it saves the resulting environment to a \"sysimg\" file for use as a starting point for a future Julia run."
},

{
    "location": "devdocs/callconv.html#",
    "page": "Calling Conventions",
    "title": "Calling Conventions",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/callconv.html#callconv-1",
    "page": "Calling Conventions",
    "title": "Calling Conventions",
    "category": "section",
    "text": "Julia uses three calling conventions for four distinct purposes:Name Prefix Purpose\nNative julia_ Speed via specialized signatures\nJL Call jlcall_ Wrapper for generic calls\nJL Call jl_ Builtins\nC ABI jlcapi_ Wrapper callable from C"
},

{
    "location": "devdocs/callconv.html#Julia-Native-Calling-Convention-1",
    "page": "Calling Conventions",
    "title": "Julia Native Calling Convention",
    "category": "section",
    "text": "The native calling convention is designed for fast non-generic calls. It usually uses a specialized signature.LLVM ghosts (zero-length types) are omitted.\nLLVM scalars and vectors are passed by value.\nLLVM aggregates (arrays and structs) are passed by reference.A small return values is returned as LLVM return values. A large return values is returned via the \"structure return\" (sret) convention, where the caller provides a pointer to a return slot.An argument or return values thta is a homogeneous tuple is sometimes represented as an LLVM vector instead of an LLVM array."
},

{
    "location": "devdocs/callconv.html#JL-Call-Convention-1",
    "page": "Calling Conventions",
    "title": "JL Call Convention",
    "category": "section",
    "text": "The JL Call convention is for builtins and generic dispatch. Hand-written functions using this convention are declared via the macro JL_CALLABLE. The convention uses exactly 3 parameters:F  - Julia representation of function that is being applied\nargs - pointer to array of pointers to boxes\nnargs - length of the arrayThe return value is a pointer to a box."
},

{
    "location": "devdocs/callconv.html#C-ABI-1",
    "page": "Calling Conventions",
    "title": "C ABI",
    "category": "section",
    "text": "C ABI wrappers enable calling Julia from C. The wrapper calls a function using the native calling convention.Tuples are always represented as C arrays."
},

{
    "location": "devdocs/compiler.html#",
    "page": "High-level Overview of the Native-Code Generation Process",
    "title": "High-level Overview of the Native-Code Generation Process",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/compiler.html#compiler-1",
    "page": "High-level Overview of the Native-Code Generation Process",
    "title": "High-level Overview of the Native-Code Generation Process",
    "category": "section",
    "text": ""
},

{
    "location": "devdocs/compiler.html#Representation-of-Pointers-1",
    "page": "High-level Overview of the Native-Code Generation Process",
    "title": "Representation of Pointers",
    "category": "section",
    "text": "When emitting code to an object file, pointers will be emitted as relocations. The deserialization code will ensure any object that pointed to one of these constants gets recreated and contains the right runtime pointer.Otherwise, they will be emitted as literal constants.To emit one of these objects, call literal_pointer_val. It'll handle tracking the Julia value and the LLVM global, ensuring they are valid both for the current runtime and after deserialization.When emitted into the object file, these globals are stored as references in a large gvals table. This allows the deserializer to reference them by index, and implement a custom manual mechanism similar to a Global Offset Table (GOT) to restore them.Function pointers are handled similarly. They are stored as values in a large fvals table. Like globals, this allows the deserializer to reference them by index.Note that extern functions are handled separately, with names, via the usual symbol resolution mechanism in the linker.Note too that ccall functions are also handled separately, via a manual GOT and Procedure Linkage Table (PLT)."
},

{
    "location": "devdocs/compiler.html#Representation-of-Intermediate-Values-1",
    "page": "High-level Overview of the Native-Code Generation Process",
    "title": "Representation of Intermediate Values",
    "category": "section",
    "text": "Values are passed around in a jl_cgval_t struct. This represents an R-value, and includes enough information to determine how to assign or pass it somewhere.They are created via one of the helper constructors, usually: mark_julia_type (for immediate values) and mark_julia_slot (for pointers to values).The function convert_julia_type can transform between any two types. It returns an R-value with cgval.typ set to typ. It'll cast the object to the requested representation, making heap boxes, allocating stack copies, and computing tagged unions as needed to change the representation.By contrast update_julia_type will change cgval.typ to typ, only if it can be done at zero-cost (i.e. without emitting any code)."
},

{
    "location": "devdocs/compiler.html#Union-representation-1",
    "page": "High-level Overview of the Native-Code Generation Process",
    "title": "Union representation",
    "category": "section",
    "text": "Inferred union types may be stack allocated via a tagged type representation.The primitive routines that need to be able to handle tagged unions are:mark-type\nload-local\nstore-local\nisa\nis\nemit_typeof\nemit_sizeof\nboxed\nunbox\nspecialized cc-retEverything else should be possible to handle in inference by using these primitives to implement union-splitting.The representation of the tagged-union is as a pair of < void* union, byte selector >. The selector is fixed-size as byte & 0x7f, and will union-tag the first 126 isbits. It records the one-based depth-first count into the type-union of the isbits objects inside. An index of zero indicates that the union* is actually a tagged heap-allocated jl_value_t*, and needs to be treated as normal for a boxed object rather than as a tagged union.The high bit of the selector (byte & 0x80) can be tested to determine if the void* is actually a heap-allocated (jl_value_t*) box, thus avoiding the cost of re-allocating a box, while maintaining the ability to efficiently handle union-splitting based on the low bits.It is guaranteed that byte & 0x7f is an exact test for the type, if the value can be represented by a tag – it will never be marked byte = 0x80. It is not necessary to also test the type-tag when testing isa.The union* memory region may be allocated at any size. The only constraint is that it is big enough to contain the data currently specified by selector. It might not be big enough to contain the union of all types that could be stored there according to the associated Union type field. Use appropriate care when copying."
},

{
    "location": "devdocs/compiler.html#Specialized-Calling-Convention-Signature-Representation-1",
    "page": "High-level Overview of the Native-Code Generation Process",
    "title": "Specialized Calling Convention Signature Representation",
    "category": "section",
    "text": "A jl_returninfo_t object describes the calling convention details of any callable.If any of the arguments or return type of a method can be represented unboxed, and the method is not varargs, it'll be given an optimized calling convention signature based on its specTypes and rettype fields.The general principles are that:Primitive types get passed in int/float registers.\nTuples of VecElement types get passed in vector registers.\nStructs get passed on the stack.\nReturn values are handle similarly to arguments, with a size-cutoff at which they will instead be returned via a hidden sret argument.The total logic for this is implemented by get_specsig_function and deserves_sret.Additionally, if the return type is a union, it may be returned as a pair of values (a pointer and a tag). If the union values can be stack-allocated, then sufficient space to store them will also be passed as a hidden first argument. It is up to the callee whether the returned pointer will point to this space, a boxed object, or even other constant memory."
},

{
    "location": "devdocs/functions.html#",
    "page": "Julia Functions",
    "title": "Julia Functions",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/functions.html#julia-functions-1",
    "page": "Julia Functions",
    "title": "Julia Functions",
    "category": "section",
    "text": "This document will explain how functions, method definitions, and method tables work."
},

{
    "location": "devdocs/functions.html#Method-Tables-1",
    "page": "Julia Functions",
    "title": "Method Tables",
    "category": "section",
    "text": "Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of many definitions, or methods. The methods of a generic function are stored in a method table. Method tables (type MethodTable) are associated with TypeNames. A TypeName describes a family of parameterized types. For example Complex{Float32} and Complex{Float64} share the same Complex type name object.All objects in Julia are potentially callable, because every object has a type, which in turn has a TypeName."
},

{
    "location": "devdocs/functions.html#Function-calls-1",
    "page": "Julia Functions",
    "title": "Function calls",
    "category": "section",
    "text": "Given the call f(x,y), the following steps are performed: first, the method table to use is accessed as typeof(f).name.mt. Second, an argument tuple type is formed, Tuple{typeof(f), typeof(x), typeof(y)}. Note that the type of the function itself is the first element. This is because the type might have parameters, and so needs to take part in dispatch. This tuple type is looked up in the method table.This dispatch process is performed by jl_apply_generic, which takes two arguments: a pointer to an array of the values f, x, and y, and the number of values (in this case 3).Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept the function and arguments separately, and those that accept a single argument structure. In the first kind of API, the \"arguments\" part does not contain information about the function, since that is passed separately. In the second kind of API, the function is the first element of the argument structure.For example, the following function for performing a call accepts just an args pointer, so the first element of the args array will be the function to call:jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)This entry point for the same functionality accepts the function separately, so the args array does not contain the function:jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);"
},

{
    "location": "devdocs/functions.html#Adding-methods-1",
    "page": "Julia Functions",
    "title": "Adding methods",
    "category": "section",
    "text": "Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the method. jl_method_def implements this operation. jl_first_argument_datatype is called to extract the relevant method table from what would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument tuple type might be abstract. For example, we can define:(::Union{Foo{Int},Foo{Int8}})(x) = 0which works since all possible matching methods would belong to the same method table."
},

{
    "location": "devdocs/functions.html#Creating-generic-functions-1",
    "page": "Julia Functions",
    "title": "Creating generic functions",
    "category": "section",
    "text": "Since every object is callable, nothing special is needed to create a generic function. Therefore jl_new_generic_function simply creates a new singleton (0 size) subtype of Function and returns its instance. A function can have a mnemonic \"display name\" which is used in debug info and when printing objects. For example the name of Base.sin is sin. By convention, the name of the created type is the same as the function name, with a # prepended. So typeof(sin) is Base.#sin."
},

{
    "location": "devdocs/functions.html#Closures-1",
    "page": "Julia Functions",
    "title": "Closures",
    "category": "section",
    "text": "A closure is simply a callable object with field names corresponding to captured variables. For example, the following code:function adder(x)\n    return y->x+y\nendis lowered to (roughly):struct ##1{T}\n    x::T\nend\n\n(_::##1)(y) = _.x + y\n\nfunction adder(x)\n    return ##1(x)\nend"
},

{
    "location": "devdocs/functions.html#Constructors-1",
    "page": "Julia Functions",
    "title": "Constructors",
    "category": "section",
    "text": "A constructor call is just a call to a type. The type of most types is DataType, so the method table for DataType contains most constructor definitions. One wrinkle is the fallback definition that makes all types callable via convert:(::Type{T}){T}(args...) = convert(T, args...)::TIn this definition the function type is abstract, which is not normally supported. To make this work, all subtypes of Type (Type, UnionAll, Union, and DataType) currently share a method table via special arrangement."
},

{
    "location": "devdocs/functions.html#Builtins-1",
    "page": "Julia Functions",
    "title": "Builtins",
    "category": "section",
    "text": "The \"builtin\" functions, defined in the Core module, are:=== typeof sizeof issubtype isa typeassert throw tuple getfield setfield! fieldtype\nnfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply\n_expr svecThese are all singleton objects whose types are subtypes of Builtin, which is a subtype of Function. Their purpose is to expose entry points in the run time that use the \"jlcall\" calling convention:jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)The method tables of builtins are empty. Instead, they have a single catch-all method cache entry (Tuple{Vararg{Any}}) whose jlcall fptr points to the correct function. This is kind of a hack but works reasonably well."
},

{
    "location": "devdocs/functions.html#Keyword-arguments-1",
    "page": "Julia Functions",
    "title": "Keyword arguments",
    "category": "section",
    "text": "Keyword arguments work by associating a special, hidden function object with each method table that has definitions with keyword arguments. This function is called the \"keyword argument sorter\" or \"keyword sorter\", or \"kwsorter\", and is stored in the kwsorter field of MethodTable objects. Every definition in the kwsorter function has the same arguments as some definition in the normal method table, except with a single Array argument prepended. This array contains alternating symbols and values that represent the passed keyword arguments. The kwsorter's job is to move keyword arguments into their canonical positions based on name, plus evaluate and substite any needed default value expressions. The result is a normal positional argument list, which is then passed to yet another function.The easiest way to understand the process is to look at how a keyword argument method definition is lowered. The code:function circle(center, radius; color = black, fill::Bool = true, options...)\n    # draw\nendactually produces three method definitions. The first is a function that accepts all arguments (including keywords) as positional arguments, and includes the code for the method body. It has an auto-generated name:function #circle#1(color, fill::Bool, options, circle, center, radius)\n    # draw\nendThe second method is an ordinary definition for the original circle function, which handles the case where no keyword arguments are passed:function circle(center, radius)\n    #circle#1(black, true, Any[], circle, center, radius)\nendThis simply dispatches to the first method, passing along default values. Finally there is the kwsorter definition:function (::Core.kwftype(typeof(circle)))(kw::Array, circle, center, radius)\n    options = Any[]\n    color = arg associated with :color, or black if not found\n    fill = arg associated with :fill, or true if not found\n    # push remaining elements of kw into options array\n    #circle#1(color, fill, options, circle, center, radius)\nendThe front end generates code to loop over the kw array and pick out arguments in the right order, evaluating default expressions when an argument is not found.The function Core.kwftype(t) fetches (and creates, if necessary) the field t.name.mt.kwsorter.This design has the feature that call sites that don't use keyword arguments require no special handling; everything works as if they were not part of the language at all. Call sites that do use keyword arguments are dispatched directly to the called function's kwsorter. For example the call:circle((0,0), 1.0, color = red; other...)is lowered to:kwfunc(circle)(Any[:color,red,other...], circle, (0,0), 1.0)The unpacking procedure represented here as other... actually further unpacks each element of other, expecting each one to contain two values (a symbol and a value). kwfunc (also in Core) fetches the kwsorter for the called function. Notice that the original circle function is passed through, to handle closures."
},

{
    "location": "devdocs/functions.html#Compiler-efficiency-issues-1",
    "page": "Julia Functions",
    "title": "Compiler efficiency issues",
    "category": "section",
    "text": "Generating a new type for every function has potentially serious consequences for compiler resource use when combined with Julia's \"specialize on all arguments by default\" design. Indeed, the initial implementation of this design suffered from much longer build and test times, higher memory use, and a system image nearly 2x larger than the baseline. In a naive implementation, the problem is bad enough to make the system nearly unusable. Several significant optimizations were needed to make the design practical.The first issue is excessive specialization of functions for different values of function-valued arguments. Many functions simply \"pass through\" an argument to somewhere else, e.g. to another function or to a storage location. Such functions do not need to be specialized for every closure that might be passed in. Fortunately this case is easy to distinguish by simply considering whether a function calls one of its arguments (i.e. the argument appears in \"head position\" somewhere). Performance-critical higher-order functions like map certainly call their argument function and so will still be specialized as expected. This optimization is implemented by recording which arguments are called during the analyze-variables pass in the front end. When cache_method sees an argument in the Function type hierarchy passed to a slot declared as Any or Function, it pretends the slot was declared as ANY (the \"don't specialize\" hint). This heuristic seems to be extremely effective in practice.The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast majority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases can be resolved by considering only the first argument. (Aside: proponents of single dispatch would not be surprised by this at all. However, this argument means \"multiple dispatch is easy to optimize in practice\", and that we should therefore use it, not \"we should use single dispatch\"!) So the method cache uses the type of the first argument as its primary key. Note, however, that this corresponds to the second element of the tuple type for a function call (the first element being the type of the function itself). Typically, type variation in head position is extremely low – indeed, the majority of functions belong to singleton types with no parameters. However, this is not the case for constructors, where a single method table holds constructors for every type. Therefore the Type method table is special-cased to use the first tuple type element instead of the second.The front end generates type declarations for all closures. Initially, this was implemented by generating normal type declarations. However, this produced an extremely large number of constructors, all of which were trivial (simply passing all arguments through to new). Since methods are partially ordered, inserting all of these methods is O(n^2), plus there are just too many of them to keep around. This was optimized by generating composite_type expressions directly (bypassing default constructor generation), and using new directly to create closure instances. Not the prettiest thing ever, but you do what you gotta do.The next problem was the @test macro, which generated a 0-argument closure for each test case. This is not really necessary, since each test case is simply run once in place. Therefore I modified @test to expand to a try-catch block that records the test result (true, false, or exception raised) and calls the test suite handler on it.However this caused a new problem. When many tests are grouped together in a single function, e.g. a single top level expression, or some other test grouping function, that function could have a very large number of exception handlers. This triggered a kind of dataflow analysis worst case, where type inference spun around for minutes enumerating possible paths through the forest of handlers. This was fixed by simply bailing out of type inference when it encounters more than some number of handlers (currently 25). Presumably no performance-critical function will have more than 25 exception handlers. If one ever does, I'm willing to raise the limit to 26.A minor issue occurs during the bootstrap process due to storing all constructors in a single method table. In the second bootstrap step, where inference.ji is compiled using inference0.ji, constructors for inference0's types remain in the table, so there are still references to the old inference module and inference.ji is 2x the size it should be. This was fixed in dump.c by filtering definitions from \"replaced modules\" out of method tables and caches before saving a system image. A \"replaced module\" is one that satisfies the condition m != jl_get_global(m->parent, m->name) – in other words, some newer module has taken its name and place.Another type inference worst case was triggered by the following code from the QuadGK.jl package, formerly part of Base:function do_quadgk(f, s, n, ::Type{Tw}, abstol, reltol, maxevals, nrm) where Tw\n    if eltype(s) <: Real # check for infinite or semi-infinite intervals\n        s1 = s[1]; s2 = s[end]; inf1 = isinf(s1); inf2 = isinf(s2)\n        if inf1 || inf2\n            if inf1 && inf2 # x = t/(1-t^2) coordinate transformation\n                return do_quadgk(t -> begin t2 = t*t; den = 1 / (1 - t2);\n                                            f(t*den) * (1+t2)*den*den; end,\n                                 map(x -> isinf(x) ? copysign(one(x), x) : 2x / (1+hypot(1,2x)), s),\n                                 n, Tw, abstol, reltol, maxevals, nrm)\n            end\n            s0,si = inf1 ? (s2,s1) : (s1,s2)\n            if si < 0 # x = s0 - t/(1-t)\n                return do_quadgk(t -> begin den = 1 / (1 - t);\n                                            f(s0 - t*den) * den*den; end,\n                                 reverse!(map(x -> 1 / (1 + 1 / (s0 - x)), s)),\n                                 n, Tw, abstol, reltol, maxevals, nrm)\n            else # x = s0 + t/(1-t)\n                return do_quadgk(t -> begin den = 1 / (1 - t);\n                                            f(s0 + t*den) * den*den; end,\n                                 map(x -> 1 / (1 + 1 / (x - s0)), s),\n                                 n, Tw, abstol, reltol, maxevals, nrm)\n            end\n        end\n    endThis code has a 3-way tail recursion, where each call wraps the current function argument f in a different new closure. Inference must consider 3^n (where n is the call depth) possible signatures. This blows up way too quickly, so logic was added to typeinf_uncached to immediately widen any argument that is a subtype of Function and that grows in depth down the stack."
},

{
    "location": "devdocs/cartesian.html#",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/cartesian.html#cartesian-1",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian",
    "category": "section",
    "text": "El módulo Cartesian (no exportado) proporciona macros que facilitan escribir algoritmos multidimensionales. Es deseable que, a largo plazo, este módulo Cartesian no sea necesario; sin embargo, en la actualidad es una de las pocas formas de escribir código multidimensional compacto y con rendimiento."
},

{
    "location": "devdocs/cartesian.html#Principios-de-uso-1",
    "page": "Base.Cartesian",
    "title": "Principios de uso",
    "category": "section",
    "text": "Un ejemplo de uso simple podría ser:@nloops 3 i A begin\n    s += @nref 3 A i\nendque genera el siguiente código:for i_3 = 1:size(A,3)\n    for i_2 = 1:size(A,2)\n        for i_1 = 1:size(A,1)\n            s += A[i_1,i_2,i_3]\n        end\n    end\nendEn general, Cartesian permitirá escribir código que contiene elementos repetitivos, como los bucles anidados de este ejemplo. Otras aplicaciones incluyen expresiones repetidas (por ejemplo, desenrollado de bucles) o crear llamadas a función con números variables de argumentos sin usar la construcción \"splat\" (i...)."
},

{
    "location": "devdocs/cartesian.html#Sintaxis-Básica-1",
    "page": "Base.Cartesian",
    "title": "Sintaxis Básica",
    "category": "section",
    "text": "La sintaxis básica de @nloops es la siguiente: * El primer argumento debe ser un entero (no una variable) que especifica el número de bucles.   * El segundo argumento es el prefijo simbólico que se utilizará para la variable iteradora. De este modo, en el ejemplo anterior usamos i, y se generaron las variables  i_1, i_2, i_3.   * El tercer argumento especifica el rango para cada variable iteradora. Si se usa una variable (símbolo) aquí, es considerado como 1:size(A,dim). De forma más flexible, se puede usar la sintaxis de expresiones basadas en funciones anónimas que se decribe más adelante.   * El último argumento es el cuerpo del bucle. En el ejemplo anterior, lo que aparece entre begin...end.Hay otras características adicionales de @nloops descritas en la sección de referencia.@nref sigue un patrn similar, generando A[i_1,i_2,i_3] a partir de @nref 3 A i. La práctica general es leer de izquierda a derecha, por lo que @nloops es @nloops 3 i A expr (como en el bucle for i_2 = 1:size(A,2), donde i_2 está a la izquierda y el rango a la derecha) mientras que @nref es @nref 3 A i (como en A[i_1,i_2,i_3], donde el array va primero).Si ests desarrollando código con Cartesian, puedes encontrar que depurar es más sencillo cuando examinas el código generado, usando macroexpand:DocTestSetup = quote\n    import Base.Cartesian: @nref\nendjulia> macroexpand(:(@nref 2 A i))\n:(A[i_1, i_2])DocTestSetup = nothing"
},

{
    "location": "devdocs/cartesian.html#Proporcionando-el-número-de-expresiones-1",
    "page": "Base.Cartesian",
    "title": "Proporcionando el número de expresiones",
    "category": "section",
    "text": "El primer argumentos de estas dos macros es el número de expresiones, que debe ser un entero. Cuando estás escribiendo una funcin que pretendes que trabaje en múltiples dimensiones, esto puede no ser algo que desees codificar. Si estás escribiendo código que necesitas que trabaje con versiones antiguas de Julia, deberías usar la macro @ngenerate descrita en una versión más antigua de esta documentación.Empezando en Julia 0.4-pre, el enfoque recomendado es usar una @generated function.  He aquí un ejemplo:@generated function mysum(A::Array{T,N}) where {T,N}\n    quote\n        s = zero(T)\n        @nloops $N i A begin\n            s += @nref $N A i\n        end\n        s\n    end\nendNaturalmente, también podemos preparar expresiones o realizar cálculos antes del bloque quote."
},

{
    "location": "devdocs/cartesian.html#Expresiones-función-anónima-como-argumentos-de-macros-1",
    "page": "Base.Cartesian",
    "title": "Expresiones función anónima como argumentos de macros",
    "category": "section",
    "text": "Quizás la característica más potente de Cartesian es la capacidad de proporcionar expresiones función-anónima que son evaluadas en tiempo de análisis sintáctico. Consideremos un ejemplo sencillo:@nexprs 2 j->(i_j = 1)@nexprs genera n expresiones que siguen un patrón. Este código generaría las siguientes instrucciones:i_1 = 1\ni_2 = 1En cada instrucción generada un j aislado (la variable de la función anónima) es reemplazada por valores en el rango 1:2. Hablando de forma general, Cartesian emplea una sintaxis parecida a LaTeX. Esto te permite hacer operaciones sobre el índice j.  He aquí un ejemplo que calcula los pasos de un array:s_1 = 1\n@nexprs 3 j->(s_{j+1} = s_j * size(A, j))generará las expresioness_1 = 1\ns_2 = s_1 * size(A, 1)\ns_3 = s_2 * size(A, 2)\ns_4 = s_3 * size(A, 3)Las expresiones función anónima tienen muchos usos en la práctica."
},

{
    "location": "devdocs/cartesian.html#Base.Cartesian.@nloops",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian.@nloops",
    "category": "Macro",
    "text": "@nloops N itersym rangeexpr bodyexpr\n@nloops N itersym rangeexpr preexpr bodyexpr\n@nloops N itersym rangeexpr preexpr postexpr bodyexpr\n\nGenerate N nested loops, using itersym as the prefix for the iteration variables. rangeexpr may be an anonymous-function expression, or a simple symbol var in which case the range is indices(var, d) for dimension d.\n\nOptionally, you can provide \"pre\" and \"post\" expressions. These get executed first and last, respectively, in the body of each loop. For example:\n\n@nloops 2 i A d -> j_d = min(i_d, 5) begin\n    s += @nref 2 A j\nend\n\nwould generate:\n\nfor i_2 = indices(A, 2)\n    j_2 = min(i_2, 5)\n    for i_1 = indices(A, 1)\n        j_1 = min(i_1, 5)\n        s += A[j_1, j_2]\n    end\nend\n\nIf you want just a post-expression, supply nothing for the pre-expression. Using parentheses and semicolons, you can supply multi-statement expressions.\n\n\n\n"
},

{
    "location": "devdocs/cartesian.html#Base.Cartesian.@nref",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian.@nref",
    "category": "Macro",
    "text": "@nref N A indexexpr\n\nGenerate expressions like A[i_1, i_2, ...]. indexexpr can either be an iteration-symbol prefix, or an anonymous-function expression.\n\njulia> @macroexpand Base.Cartesian.@nref 3 A i\n:(A[i_1, i_2, i_3])\n\n\n\n"
},

{
    "location": "devdocs/cartesian.html#Base.Cartesian.@nextract",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian.@nextract",
    "category": "Macro",
    "text": "@nextract N esym isym\n\nGenerate N variables esym_1, esym_2, ..., esym_N to extract values from isym. isym can be either a Symbol or anonymous-function expression.\n\n@nextract 2 x y would generate\n\nx_1 = y[1]\nx_2 = y[2]\n\nwhile @nextract 3 x d->y[2d-1] yields\n\nx_1 = y[1]\nx_2 = y[3]\nx_3 = y[5]\n\n\n\n"
},

{
    "location": "devdocs/cartesian.html#Base.Cartesian.@nexprs",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian.@nexprs",
    "category": "Macro",
    "text": "@nexprs N expr\n\nGenerate N expressions. expr should be an anonymous-function expression.\n\njulia> @macroexpand Base.Cartesian.@nexprs 4 i -> y[i] = A[i+j]\nquote\n    y[1] = A[1 + j]\n    y[2] = A[2 + j]\n    y[3] = A[3 + j]\n    y[4] = A[4 + j]\nend\n\n\n\n"
},

{
    "location": "devdocs/cartesian.html#Base.Cartesian.@ncall",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian.@ncall",
    "category": "Macro",
    "text": "@ncall N f sym...\n\nGenerate a function call expression. sym represents any number of function arguments, the last of which may be an anonymous-function expression and is expanded into N arguments.\n\nFor example @ncall 3 func a generates\n\nfunc(a_1, a_2, a_3)\n\nwhile @ncall 2 func a b i->c[i] yields\n\nfunc(a, b, c[1], c[2])\n\n\n\n"
},

{
    "location": "devdocs/cartesian.html#Base.Cartesian.@ntuple",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian.@ntuple",
    "category": "Macro",
    "text": "@ntuple N expr\n\nGenerates an N-tuple. @ntuple 2 i would generate (i_1, i_2), and @ntuple 2 k->k+1 would generate (2,3).\n\n\n\n"
},

{
    "location": "devdocs/cartesian.html#Base.Cartesian.@nall",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian.@nall",
    "category": "Macro",
    "text": "@nall N expr\n\nCheck whether all of the expressions generated by the anonymous-function expression expr evaluate to true.\n\n@nall 3 d->(i_d > 1) would generate the expression (i_1 > 1 && i_2 > 1 && i_3 > 1). This can be convenient for bounds-checking.\n\n\n\n"
},

{
    "location": "devdocs/cartesian.html#Base.Cartesian.@nany",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian.@nany",
    "category": "Macro",
    "text": "@nany N expr\n\nCheck whether any of the expressions generated by the anonymous-function expression expr evaluate to true.\n\n@nany 3 d->(i_d > 1) would generate the expression (i_1 > 1 || i_2 > 1 || i_3 > 1).\n\n\n\n"
},

{
    "location": "devdocs/cartesian.html#Base.Cartesian.@nif",
    "page": "Base.Cartesian",
    "title": "Base.Cartesian.@nif",
    "category": "Macro",
    "text": "@nif N conditionexpr expr\n@nif N conditionexpr expr elseexpr\n\nGenerates a sequence of if ... elseif ... else ... end statements. For example:\n\n@nif 3 d->(i_d >= size(A,d)) d->(error(\"Dimension \", d, \" too big\")) d->println(\"All OK\")\n\nwould generate:\n\nif i_1 > size(A, 1)\n    error(\"Dimension \", 1, \" too big\")\nelseif i_2 > size(A, 2)\n    error(\"Dimension \", 2, \" too big\")\nelse\n    println(\"All OK\")\nend\n\n\n\n"
},

{
    "location": "devdocs/cartesian.html#dev-cartesian-reference-1",
    "page": "Base.Cartesian",
    "title": "Referencia de las Macros",
    "category": "section",
    "text": "Base.Cartesian.@nloops\nBase.Cartesian.@nref\nBase.Cartesian.@nextract\nBase.Cartesian.@nexprs\nBase.Cartesian.@ncall\nBase.Cartesian.@ntuple\nBase.Cartesian.@nall\nBase.Cartesian.@nany\nBase.Cartesian.@nif"
},

{
    "location": "devdocs/meta.html#",
    "page": "Talking to the compiler (the :meta mechanism)",
    "title": "Talking to the compiler (the :meta mechanism)",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/meta.html#meta-1",
    "page": "Talking to the compiler (the :meta mechanism)",
    "title": "Talking to the compiler (the :meta mechanism)",
    "category": "section",
    "text": "In some circumstances, one might wish to provide hints or instructions that a given block of code has special properties: you might always want to inline it, or you might want to turn on special compiler optimization passes.  Starting with version 0.4, Julia has a convention that these instructions can be placed inside a :meta expression, which is typically (but not necessarily) the first expression in the body of a function.:meta expressions are created with macros. As an example, consider the implementation of the @inline macro:macro inline(ex)\n    esc(isa(ex, Expr) ? pushmeta!(ex, :inline) : ex)\nendHere, ex is expected to be an expression defining a function. A statement like this:@inline function myfunction(x)\n    x*(x+3)\nendgets turned into an expression like this:quote\n    function myfunction(x)\n        Expr(:meta, :inline)\n        x*(x+3)\n    end\nendBase.pushmeta!(ex, :symbol, args...) appends :symbol to the end of the :meta expression, creating a new :meta expression if necessary. If args is specified, a nested expression containing :symbol and these arguments is appended instead, which can be used to specify additional information.To use the metadata, you have to parse these :meta expressions. If your implementation can be performed within Julia, Base.popmeta! is very handy: Base.popmeta!(body, :symbol) will scan a function body expression (one without the function signature) for the first :meta expression containing :symbol, extract any arguments, and return a tuple (found::Bool, args::Array{Any}). If the metadata did not have any arguments, or :symbol was not found, the args array will be empty.Not yet provided is a convenient infrastructure for parsing :meta expressions from C++."
},

{
    "location": "devdocs/subarrays.html#",
    "page": "SubArrays",
    "title": "SubArrays",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/subarrays.html#subarrays-1",
    "page": "SubArrays",
    "title": "SubArrays",
    "category": "section",
    "text": "El tipo SubArray de Julia es un contenedor que codifica una \"vista\" de un AbstractArray padre.  Esta pagina documenta algunos de los principios de diseño e implementación de SubArray."
},

{
    "location": "devdocs/subarrays.html#Indexación:-indexación-cartesiana-vs.-lineal-1",
    "page": "SubArrays",
    "title": "Indexación: indexación cartesiana vs. lineal",
    "category": "section",
    "text": "Ampliamente hablando, hay dos formas principales de acceder a los datos en un array. La primera, frecuentemente llamada indexación cartesiana, usa N índices para un AbstractArray N -dimensional. Por ejemlo, una matriz A (bidimensional) puede ser indexada en estilo cartesiano como A[i,j]. El segundo método de indexación, denominado indexación lineal, usa un solo índice incluso para objetos de mayor dimensión. Por ejemplo si A = reshape(1:12, 3, 4), la expresión A[5] devuelve el valor 5. Julia nos permite combinar estos estilos de indexación: por ejemplo, un array 3d A3 puede ser indexado como A3[i,j], en cuyo caso i es interpretado como un índice cartesiano para la primera dimensión, y j es un índice lineal sobre las dimensiones 2 y 3.Para los Arrays, la indexación lineal apela al formato subyacente de almacenamiento: un array se presenta como un bloque contiguo de memoria, y por tanto el índice lineal es justo el desplazamiento (+1) de la correspondiente entrada relativa al principio del array. Sin embargo, esto no es cierto para muchos otros tipos AbstractArray: ejemplos de ello incluyen SparseMatrixCSC, unos arrays que requieren alguna clase de cálculo (tal como interpolación), y el tipo bajo discusión aquí, SubArray. Para estos tipos, la información subyacente es descrita más naturalmente en términos de índices cartesianos. Uno puede convertir manualmente un índice cartesiano a uno lineal con sub2ind, y viceversa usando ìnd2sub. Las funcionesgetindexandsetindex!de los tiposAbstractArray` puden incluir operaciones similares.Aunque convertir de un índice cartesiano a uno lineal es rápido (es justo una multiplicación y una suma), convertir de un índice lineal a uno cartesiano es muy lento: se basa en la operación div, que es una de las operacions de bajo nivel más lentas que uno puede realizar con una CPU. Por esta razón, cualquier código que trate con tipos AbstractArray está mejor diseñado en términos de indexación cartesiana en lugar de lineal."
},

{
    "location": "devdocs/subarrays.html#Reemplazo-de-Índices-1",
    "page": "SubArrays",
    "title": "Reemplazo de Índices",
    "category": "section",
    "text": "Considere hacer rebanadas bidimensionales de un array tridimensional:S1 = view(A, :, 5, 2:6)\nS2 = view(A, 5, :, 2:6)view elimina las dimensiones \"singleton\" (las que están especificadas por un Int), por lo que tanto S1 como S2 son SubArrays bidimensionales. En consecuencia, el camino natural para indexar esto es con S1[i,j]. Para extraer el valor del array padre A, el enfoque natural es reemplazar S1[i,j] con A[i,5,(2:6)[j]] y S2[i,j] con A[5,i,(2:6)[j]].La característica clave del diseño de SubArrays es que este reemplazo de índices puede realizarse sin ninguna sobrecarga en tiempo de ejecución."
},

{
    "location": "devdocs/subarrays.html#Diseño-de-SubArray's-1",
    "page": "SubArrays",
    "title": "Diseño de SubArray's",
    "category": "section",
    "text": ""
},

{
    "location": "devdocs/subarrays.html#Parámetros-de-Tipo-y-Campos-1",
    "page": "SubArrays",
    "title": "Parámetros de Tipo y Campos",
    "category": "section",
    "text": "La estrategia adoptada está expresada en la definición del tipo:struct SubArray{T,N,P,I,L} <: AbstractArray{T,N}\n    parent::P\n    indexes::I\n    offset1::Int       # for linear indexing and pointer, only valid when L==true\n    stride1::Int       # used only for linear indexing\n    ...\nendSubArray tiene cinco parámetros de tipo. Los dos primeros son el tipo de elemento estándar y la dimensionalidad. La siguiente es el tipo del AbstractArray padre. El usado más intensamente es el cuarto parámetro, una Tuple de los tipos de los índices para cada dimensión. El final, L,  es sólo proporcionado como una conveniencia para el despacho; es un valor booleano que representa si los tipos del índice soportan indexacion lineal rápida. Más sobre este tema después.  Si en nuestro ejemplo de arriba A es un Array{Float64, 3}, nuestro caso S1 sería un  SubArray{Int64,2,Array{Int64,3},Tuple{Colon,Int64,UnitRange{Int64}},false}. Note en particular el parámetro tupla, que almacena los tipos de los índices usados para crear S1.  Igualmente,julia> S1.indexes\n(Colon(),5,2:6)Almacenar estos valores permite el reemplzao de índices, y tener los tipos codificados como parámetros permite a uno despachar a eficientes algoritmos."
},

{
    "location": "devdocs/subarrays.html#Traducción-de-Índices-1",
    "page": "SubArrays",
    "title": "Traducción de Índices",
    "category": "section",
    "text": "Realizar la traducción de índices requiere que uno haga diferentes cosas para diferentes tipos concretos de SubArray. Por ejemplo, para S1 uno necesita aplicar los índices i,j a las dimensiones primera y tercera del array padre, mientras que para S2 uno necesita aplicarlas a la segunda y la tercera. El enfoque más sencillo a indexar sería hacer el análisis de tipos en tiempo de ejecución:parentindexes = Array{Any}(0)\nfor thisindex in S.indexes\n    ...\n    if isa(thisindex, Int)\n        # Don't consume one of the input indexes\n        push!(parentindexes, thisindex)\n    elseif isa(thisindex, AbstractVector)\n        # Consume an input index\n        push!(parentindexes, thisindex[inputindex[j]])\n        j += 1\n    elseif isa(thisindex, AbstractMatrix)\n        # Consume two input indices\n        push!(parentindexes, thisindex[inputindex[j], inputindex[j+1]])\n        j += 2\n    elseif ...\nend\nS.parent[parentindexes...]Desgraciadamente, esto sería desastroso en términos de rendimiento: cada acceso a elemento asignaría memoria, e implicaría la ejecución de un montón de código pobremente tipado.El mejor enfoque es despachar a métodos específicos para manejar cada tipo de índice almacenado. Esto es lo que hace reindex: él despacha sobre el tipo del primer índice almacenado y consume el número apropiado de índices de entrada, y entonces recurre sobre los índices restantes. En el caso de S1, esto expande aBase.reindex(S1, S1.indexes, (i, j)) == (i, S1.indexes[2], S1.indexes[3][j])para cualquier par de índices (i,j) (excepto CartesianIndexs and arrays de este tipo, ver abajo).Este es el núcleo de un SubArray; los métodos de indexación se basan en reindex para hacer esta traducción de índices. Sin embargo, algunas veces, podemos evitar la indirección y hacerlo incluso más rápido."
},

{
    "location": "devdocs/subarrays.html#Indexación-Lineal-1",
    "page": "SubArrays",
    "title": "Indexación Lineal",
    "category": "section",
    "text": "La indexación lineal puede implementarse de forma eficiente cuando el array completo tiene un solo paso que separe elementos sucesivos, empezando desde cierto desplazamiento. Esto significa que nosotros pre-computamos estos valores y representamos la indexación lineal simplemente como una adición y multiplicación, evitando la indirección de reindex y (lo que es más importante) la computación lenta de las coordenadas cartesianas por completo.Para los tipos SubArray, la disponibilidad de una indexación lineal eficiente está basada puramente en los tipos de los índices, y no depende de valores como el tamaño de array padre. Uno puede preguntar si un cnjunto de índices dado soporta indexación lineal rápida con la función interna Base.viewindexing:julia> Base.viewindexing(S1.indexes)\nIndexCartesian()\n\njulia> Base.viewindexing(S2.indexes)\nIndexLinear()Esto se calcula durante la construcción del SubArray y se almacena en el parámetro de tipo L como un boolean que codifica soporte de indexación lineal rápido. Aunque n oes estrictamente necesario, esto significa qeu podemos definir despacho directamente sobre SubArray{T,N,A,I,true} sin intermediarios.Como esta computación no depende de valores en tiempo de ejecución, puede perder algunos casos en los que el paso sea uniforme:julia> A = reshape(1:4*2, 4, 2)\n4×2 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> diff(A[2:2:4,:][:])\n3-element Array{Int64,1}:\n 2\n 2\n 2Una vista construída como view(A, 2:2:4, :) tiene un paso uniforme y, por tanto la indexación lineal podría llevarse a cabo eficientemente. Sin embargo, el éxito en este caso depende del tamaño del array: Si, a diferencia del caso anterior, la primera dimensión fuera impar,julia> A = reshape(1:5*2, 5, 2)\n5×2 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:\n 1   6\n 2   7\n 3   8\n 4   9\n 5  10\n\njulia> diff(A[2:2:4,:][:])\n3-element Array{Int64,1}:\n 2\n 3\n 2entonces A[2:2:4,:] no tiene un paso uniforme, por lo que no podemos garantizar indexación lineal eficiente. Como tenemos que basar esta decisión puramente en los tipos codificados en los parámetros del SubArray, S = view(A, 2:2:4, :) no puede implementar una indexación lienal eficiente."
},

{
    "location": "devdocs/subarrays.html#Unos-pocos-detalles-1",
    "page": "SubArrays",
    "title": "Unos pocos detalles",
    "category": "section",
    "text": "Note que la función Base.reindex es agnóstica a los tipos de los índices de entrada; ella simplemente determina como y donde deberían reindexarse los indices almacenados. Ella no solo soporta indices enteros, sino que también soporta indexación no escalar. Esto significa que las vistas de vistas no necesitan dos    niveles de indirección; ellas pueden simplemente recomputar los índices en el array padre original.  Es de esperar que a estas alturas esté bastante claro que soportar rebanadas en arrays significa que la dimensionalidad, dada por el parámetro N, no es necesariamente igual a la dimensionalidad del array padre o la longitud de la tupla indexes. Tampoco los índices proporcionados por el usuario se alinean necesariamente con las entradas en la tupla indexes (por ejemplo, el segundo índice proporcionado por el usuario puede corresponder a la tercera dimensión de la matriz padre, y el tercer elemento en la tupla indexes).\nLo que podría ser menos obvio es que la dimensionalidad del array padre almacenado sea igual al número de  índices efectivos en la tupla indexes. Algunos ejemplos:\nA = reshape(1:35, 5, 7) # A 2d parent Array\nS = view(A, 2:7)         # A 1d view created by linear indexing\nS = view(A, :, :, 1:1)   # Appending extra indices is supported\nIngenuamente, uno pensaría que podría simplemente establecer S.parent = A yS.indexes = (:,:, 1: 1),  pero el hecho de soportar esto complica dramáticamente el proceso de reindexación, especialmente para  vistas de vistas. No solo se necesita despachar los tipos de los índices almacenados, sino que se debe  examinar si un índice dado es el último y \"fusionar\" los índices almacenados restantes. Esto no es una  tarea fácil, y aún peor: es lenta ya que depende implícitamente de la indexación lineal.\nAfortunadamente, este es precisamente el cálculo que 'ReshapedArray' realiza, y lo hace linealmente si es posible. En consecuencia, view asegura que el array padre es la dimensionalidad adecuada para los  índices dados mediante reformateo (reshaping) si es necesario. El constructor interno SubArray  asegura que este invariante esté satisfecha.\nCartesianIndex y sus matrices retuercen de una forma desagradable el esquema reindex. Recuerde  que reindex simplemente despacha sobre el tipo de índices almacenados para determinar cuántos  índices pasados deberían usarse y a dónde deberían ir. Pero con CartesianIndex, ya no hay una  correspondencia uno a uno entre la cantidad de argumentos pasados y la cantidad de dimensiones en  las que indexan. Si volvemos al ejemplo anterior de Base.reindex(S1, S1.indexes, (i, j)), puede  ver que la expansión es incorrecta para i, j = CartesianIndex (), CartesianIndex (2,1 ). Él  debería salta el CartesianIndex() por completo y devolver:\n(CartesianIndex(2,1)[1], S1.indexes[2], S1.indexes[3][CartesianIndex(2,1)[2]])\nY si embargo, lo que devuelve es:\n(CartesianIndex(), S1.indexes[2], S1.indexes[3][CartesianIndex(2,1)])\nHacer esto correctamente requeriría el envío combinado en los índices almacenados y pasados en  todas las combinaciones de dimensionalidades de una manera intratable. Como tal, reindex nunca  debe invocarse con índices CartesianIndex. Afortunadamente, el caso escalar se maneja fácilmente  aplanando primero los argumentos CartesianIndex a enteros simples. Sin embargo, las matrices de  CartesianIndex no se pueden dividir en piezas ortogonales tan fácilmente. Antes de intentar usar  reindex,view debe garantizar que no haya matrices de CartesianIndex en la lista de argumentos.  Si los hay, simplemente puede \"puntualizar\" evitando por completo el cálculo de 'reindex', construyendo  un SubArray anidado con dos niveles de indirección en su lugar."
},

{
    "location": "devdocs/sysimg.html#",
    "page": "System Image Building",
    "title": "System Image Building",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/sysimg.html#sysimg-1",
    "page": "System Image Building",
    "title": "System Image Building",
    "category": "section",
    "text": ""
},

{
    "location": "devdocs/sysimg.html#BuildSysImg.build_sysimg",
    "page": "System Image Building",
    "title": "BuildSysImg.build_sysimg",
    "category": "Function",
    "text": "build_sysimg(sysimg_path=default_sysimg_path(), cpu_target=\"native\", userimg_path=nothing; force=false)\n\nRebuild the system image. Store it in sysimg_path, which defaults to a file named sys.ji that sits in the same folder as libjulia.{so,dylib}, except on Windows where it defaults to JULIA_HOME/../lib/julia/sys.ji.  Use the cpu instruction set given by cpu_target. Valid CPU targets are the same as for the -C option to julia, or the -march option to gcc.  Defaults to native, which means to use all CPU instructions available on the current processor. Include the user image file given by userimg_path, which should contain directives such as using MyPackage to include that package in the new system image. New system image will not replace an older image unless force is set to true.\n\n\n\n"
},

{
    "location": "devdocs/sysimg.html#building-julia-system-image-1",
    "page": "System Image Building",
    "title": "Building the Julia system image",
    "category": "section",
    "text": "Julia ships with a preparsed system image containing the contents of the Base module, named sys.ji.  This file is also precompiled into a shared library called sys.{so,dll,dylib} on as many platforms as possible, so as to give vastly improved startup times.  On systems that do not ship with a precompiled system image file, one can be generated from the source files shipped in Julia's DATAROOTDIR/julia/base folder.This operation is useful for multiple reasons.  A user may:Build a precompiled shared library system image on a platform that did not ship with one, thereby improving startup times.\nModify Base, rebuild the system image and use the new Base next time Julia is started.\nInclude a userimg.jl file that includes packages into the system image, thereby creating a system image that has packages embedded into the startup environment.Julia now ships with a script that automates the tasks of building the system image, wittingly named build_sysimg.jl that lives in DATAROOTDIR/julia/.  That is, to include it into a current Julia session, type:include(joinpath(JULIA_HOME, Base.DATAROOTDIR, \"julia\", \"build_sysimg.jl\"))This will include a build_sysimg() function:BuildSysImg.build_sysimgNote that this file can also be run as a script itself, with command line arguments taking the place of arguments passed to the build_sysimg function.  For example, to build a system image in /tmp/sys.{so,dll,dylib}, with the core2 CPU instruction set, a user image of ~/userimg.jl and force set to true, one would execute:julia build_sysimg.jl /tmp/sys core2 ~/userimg.jl --force"
},

{
    "location": "devdocs/llvm.html#",
    "page": "Working with LLVM",
    "title": "Working with LLVM",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/llvm.html#llvm-1",
    "page": "Working with LLVM",
    "title": "Working with LLVM",
    "category": "section",
    "text": "This is not a replacement for the LLVM documentation, but a collection of tips for working on LLVM for Julia."
},

{
    "location": "devdocs/llvm.html#Overview-of-Julia-to-LLVM-Interface-1",
    "page": "Working with LLVM",
    "title": "Overview of Julia to LLVM Interface",
    "category": "section",
    "text": "Julia statically links in LLVM by default. Build with USE_LLVM_SHLIB=1 to link dynamically.The code for lowering Julia AST to LLVM IR or interpreting it directly is in directory src/.File Description\nbuiltins.c Builtin functions\nccall.cpp Lowering ccall\ncgutils.cpp Lowering utilities, notably for array and tuple accesses\ncodegen.cpp Top-level of code generation, pass list, lowering builtins\ndebuginfo.cpp Tracks debug information for JIT code\ndisasm.cpp Handles native object file and JIT code diassembly\ngf.c Generic functions\nintrinsics.cpp Lowering intrinsics\nllvm-simdloop.cpp Custom LLVM pass for @simd\nsys.c I/O and operating system utility functionsSome of the .cpp files form a group that compile to a single object.The difference between an intrinsic and a builtin is that a builtin is a first class function that can be used like any other Julia function.  An intrinsic can operate only on unboxed data, and therefore its arguments must be statically typed."
},

{
    "location": "devdocs/llvm.html#Alias-Analysis-1",
    "page": "Working with LLVM",
    "title": "Alias Analysis",
    "category": "section",
    "text": "Julia currently uses LLVM's Type Based Alias Analysis. To find the comments that document the inclusion relationships, look for static MDNode* in src/codegen.cpp.The -O option enables LLVM's Basic Alias Analysis."
},

{
    "location": "devdocs/llvm.html#Building-Julia-with-a-different-version-of-LLVM-1",
    "page": "Working with LLVM",
    "title": "Building Julia with a different version of LLVM",
    "category": "section",
    "text": "The default version of LLVM is specified in deps/Versions.make. You can override it by creating a file called Make.user in the top-level directory and adding a line to it such as:LLVM_VER = 3.5.0Besides the LLVM release numerals, you can also use LLVM_VER = svn to bulid against the latest development version of LLVM."
},

{
    "location": "devdocs/llvm.html#Passing-options-to-LLVM-1",
    "page": "Working with LLVM",
    "title": "Passing options to LLVM",
    "category": "section",
    "text": "You can pass options to LLVM using debug builds of Julia.  To create a debug build, run make debug.  The resulting executable is usr/bin/julia-debug. You can pass LLVM options to this executable via the environment variable JULIA_LLVM_ARGS. Here are example settings using bash syntax:export JULIA_LLVM_ARGS = -print-after-all dumps IR after each pass.\nexport JULIA_LLVM_ARGS = -debug-only=loop-vectorize dumps LLVM DEBUG(...) diagnostics for loop vectorizer if you built Julia with LLVM_ASSERTIONS=1. Otherwise you will get warnings about \"Unknown command line argument\". Counter-intuitively, building Julia with LLVM_DEBUG=1 is not enough to dump DEBUG diagnostics from a pass."
},

{
    "location": "devdocs/llvm.html#Improving-LLVM-optimizations-for-Julia-1",
    "page": "Working with LLVM",
    "title": "Improving LLVM optimizations for Julia",
    "category": "section",
    "text": "Improving LLVM code generation usually involves either changing Julia lowering to be more friendly to LLVM's passes, or improving a pass.If you are planning to improve a pass, be sure to read the LLVM developer policy. The best strategy is to create a code example in a form where you can use LLVM's opt tool to study it and the pass of interest in isolation.Create an example Julia code of interest.\nUse JULIA_LLVM_ARGS = -print-after-all to dump the IR.\nPick out the IR at the point just before the pass of interest runs.\nStrip the debug metadata and fix up the TBAA metadata by hand.The last step is labor intensive.  Suggestions on a better way would be appreciated."
},

{
    "location": "devdocs/stdio.html#",
    "page": "printf() and stdio in the Julia runtime",
    "title": "printf() and stdio in the Julia runtime",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/stdio.html#stdio-1",
    "page": "printf() and stdio in the Julia runtime",
    "title": "printf() and stdio in the Julia runtime",
    "category": "section",
    "text": ""
},

{
    "location": "devdocs/stdio.html#libuv-wrappers-stdio-1",
    "page": "printf() and stdio in the Julia runtime",
    "title": "Libuv wrappers for stdio",
    "category": "section",
    "text": "julia.h defines libuv wrappers for the stdio.h streams:uv_stream_t *JL_STDIN;\nuv_stream_t *JL_STDOUT;\nuv_stream_t *JL_STDERR;... and corresponding output functions:int jl_printf(uv_stream_t *s, const char *format, ...);\nint jl_vprintf(uv_stream_t *s, const char *format, va_list args);These printf functions are used by the .c files in the src/ and ui/ directories wherever stdio is needed to ensure that output buffering is handled in a unified way.In special cases, like signal handlers, where the full libuv infrastructure is too heavy, jl_safe_printf() can be used to write(2) directly to STDERR_FILENO:void jl_safe_printf(const char *str, ...);"
},

{
    "location": "devdocs/stdio.html#Interface-between-JL_STD*-and-Julia-code-1",
    "page": "printf() and stdio in the Julia runtime",
    "title": "Interface between JL_STD* and Julia code",
    "category": "section",
    "text": "Base.STDIN, Base.STDOUT and Base.STDERR are bound to the JL_STD* libuv streams defined in the runtime.Julia's __init__() function (in base/sysimg.jl) calls reinit_stdio() (in base/stream.jl) to create Julia objects for Base.STDIN, Base.STDOUT and Base.STDERR.reinit_stdio() uses ccall to retrieve pointers to JL_STD* and calls jl_uv_handle_type() to inspect the type of each stream.  It then creates a Julia Base.IOStream, Base.TTY or Base.PipeEndpoint object to represent each stream, e.g.:$ julia -e 'println(typeof((STDIN, STDOUT, STDERR)))'\nTuple{Base.TTY,Base.TTY,Base.TTY}\n\n$ julia -e 'println(typeof((STDIN, STDOUT, STDERR)))' < /dev/null 2>/dev/null\nTuple{IOStream,Base.TTY,IOStream}\n\n$ echo hello | julia -e 'println(typeof((STDIN, STDOUT, STDERR)))' | cat\nTuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}The Base.read() and Base.write() methods for these streams use ccall to call libuv wrappers in src/jl_uv.c, e.g.:stream.jl: function write(s::IO, p::Ptr, nb::Integer)\n               -> ccall(:jl_uv_write, ...)\n  jl_uv.c:          -> int jl_uv_write(uv_stream_t *stream, ...)\n                        -> uv_write(uvw, stream, buf, ...)"
},

{
    "location": "devdocs/stdio.html#printf()-during-initialization-1",
    "page": "printf() and stdio in the Julia runtime",
    "title": "printf() during initialization",
    "category": "section",
    "text": "The libuv streams relied upon by jl_printf() etc., are not available until midway through initialization of the runtime (see init.c, init_stdio()).  Error messages or warnings that need to be printed before this are routed to the standard C library fwrite() function by the following mechanism:In sys.c, the JL_STD* stream pointers are statically initialized to integer constants: STD*_FILENO (0, 1 and 2). In jl_uv.c the jl_uv_puts() function checks its uv_stream_t* stream argument and calls fwrite() if stream is set to STDOUT_FILENO or STDERR_FILENO.This allows for uniform use of jl_printf() throughout the runtime regardless of whether or not any particular piece of code is reachable before initialization is complete."
},

{
    "location": "devdocs/stdio.html#legacy-ios-library-1",
    "page": "printf() and stdio in the Julia runtime",
    "title": "Legacy ios.c library",
    "category": "section",
    "text": "The src/support/ios.c library is inherited from femtolisp. It provides cross-platform buffered file IO and in-memory temporary buffers.ios.c is still used by:src/flisp/*.c\nsrc/dump.c – for serialization file IO and for memory buffers.\nbase/iostream.jl – for file IO (see base/fs.jl for libuv equivalent).Use of ios.c in these modules is mostly self-contained and separated from the libuv I/O system. However, there is one place where femtolisp calls through to jl_printf() with a legacy ios_t stream.There is a hack in ios.h that makes the ios_t.bm field line up with the uv_stream_t.type and ensures that the values used for ios_t.bm to not overlap with valid UV_HANDLE_TYPE values.  This allows uv_stream_t pointers to point to ios_t streams.This is needed because jl_printf() caller jl_static_show() is passed an ios_t stream by femtolisp's fl_print() function. Julia's jl_uv_puts() function has special handling for this:if (stream->type > UV_HANDLE_TYPE_MAX) {\n    return ios_write((ios_t*)stream, str, n);\n}"
},

{
    "location": "devdocs/boundscheck.html#",
    "page": "Bounds checking",
    "title": "Bounds checking",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/boundscheck.html#boundscheck-1",
    "page": "Bounds checking",
    "title": "Bounds checking",
    "category": "section",
    "text": "Like many modern programming languages, Julia uses bounds checking to ensure program safety when accessing arrays. In tight inner loops or other performance critical situations, you may wish to skip these bounds checks to improve runtime performance. For instance, in order to emit vectorized (SIMD) instructions, your loop body cannot contain branches, and thus cannot contain bounds checks. Consequently, Julia includes an @inbounds(...) macro to tell the compiler to skip such bounds checks within the given block. For the built-in Array type, the magic happens inside the arrayref and arrayset intrinsics. User-defined array types instead use the @boundscheck(...) macro to achieve context-sensitive code selection."
},

{
    "location": "devdocs/boundscheck.html#Eliding-bounds-checks-1",
    "page": "Bounds checking",
    "title": "Eliding bounds checks",
    "category": "section",
    "text": "The @boundscheck(...) macro marks blocks of code that perform bounds checking. When such blocks appear inside of an @inbounds(...) block, the compiler removes these blocks. When the @boundscheck(...) is nested inside of a calling function containing an @inbounds(...), the compiler will remove the @boundscheck block only if it is inlined into the calling function. For example, you might write the method sum as:function sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i = 1:length(A)\n        @inbounds r += A[i]\n    end\n    return r\nendWith a custom array-like type MyArray having:@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A,i); A.data[to_index(i)])Then when getindex is inlined into sum, the call to checkbounds(A,i) will be elided. If your function contains multiple layers of inlining, only @boundscheck blocks at most one level of inlining deeper are eliminated. The rule prevents unintended changes in program behavior from code further up the stack."
},

{
    "location": "devdocs/boundscheck.html#Propagating-inbounds-1",
    "page": "Bounds checking",
    "title": "Propagating inbounds",
    "category": "section",
    "text": "There may be certain scenarios where for code-organization reasons you want more than one layer between the @inbounds and @boundscheck declarations. For instance, the default getindex methods have the chain getindex(A::AbstractArray, i::Real) calls getindex(IndexStyle(A), A, i) calls _getindex(::IndexLinear, A, i).To override the \"one layer of inlining\" rule, a function may be marked with @propagate_inbounds to propagate an inbounds context (or out of bounds context) through one additional layer of inlining."
},

{
    "location": "devdocs/boundscheck.html#The-bounds-checking-call-hierarchy-1",
    "page": "Bounds checking",
    "title": "The bounds checking call hierarchy",
    "category": "section",
    "text": "The overall hierarchy is:checkbounds(A, I...) which calls\ncheckbounds(Bool, A, I...) which calls\ncheckbounds_indices(Bool, indices(A), I) which recursively calls\ncheckindex for each dimensionHere A is the array, and I contains the \"requested\" indices. indices(A) returns a tuple of \"permitted\" indices of A.checkbounds(A, I...) throws an error if the indices are invalid, whereas checkbounds(Bool, A, I...) returns false in that circumstance.  checkbounds_indices discards any information about the array other than its indices tuple, and performs a pure indices-vs-indices comparison: this allows relatively few compiled methods to serve a huge variety of array types. Indices are specified as tuples, and are usually compared in a 1-1 fashion with individual dimensions handled by calling another important function, checkindex: typically,checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\n                                                      checkbounds_indices(Bool, IA, I)so checkindex checks a single dimension.  All of these functions, including the unexported checkbounds_indices have docstrings accessible with ? .If you have to customize bounds checking for a specific array type, you should specialize checkbounds(Bool, A, I...). However, in most cases you should be able to rely on checkbounds_indices as long as you supply useful indices for your array type.If you have novel index types, first consider specializing checkindex, which handles a single index for a particular dimension of an array.  If you have a custom multidimensional index type (similar to CartesianIndex), then you may have to consider specializing checkbounds_indices.Note this hierarchy has been designed to reduce the likelihood of method ambiguities.  We try to make checkbounds the place to specialize on array type, and try to avoid specializations on index types; conversely, checkindex is intended to be specialized only on index type (especially, the last argument)."
},

{
    "location": "devdocs/locks.html#",
    "page": "Proper maintenance and care of multi-threading locks",
    "title": "Proper maintenance and care of multi-threading locks",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/locks.html#locks-1",
    "page": "Proper maintenance and care of multi-threading locks",
    "title": "Proper maintenance and care of multi-threading locks",
    "category": "section",
    "text": "The following strategies are used to ensure that the code is dead-lock free (generally by addressing the 4th Coffman condition: circular wait).structure code such that only one lock will need to be acquired at a time\nalways acquire shared locks in the same order, as given by the table below\navoid constructs that expect to need unrestricted recursion"
},

{
    "location": "devdocs/locks.html#Locks-1",
    "page": "Proper maintenance and care of multi-threading locks",
    "title": "Locks",
    "category": "section",
    "text": "Below are all of the locks that exist in the system and the mechanisms for using them that avoid the potential for deadlocks (no Ostrich algorithm allowed here):The following are definitely leaf locks (level 1), and must not try to acquire any other lock:safepoint\nNote that this lock is acquired implicitly by JL_LOCK and JL_UNLOCK. use the _NOGC variants to avoid that for level 1 locks.While holding this lock, the code must not do any allocation or hit any safepoints. Note that there are safepoints when doing allocation, enabling / disabling GC, entering / restoring exception frames, and taking / releasing locks.\nshared_map\nfinalizers\npagealloc\ngc_perm_lock\nflisp\nflisp itself is already threadsafe, this lock only protects the jl_ast_context_list_t poolThe following is a leaf lock (level 2), and only acquires level 1 locks (safepoint) internally:typecacheThe following is a level 3 lock, which can only acquire level 1 or level 2 locks internally:Method->writelockThe following is a level 4 lock, which can only recurse to acquire level 1, 2, or 3 locks:MethodTable->writelockNo Julia code may be called while holding a lock above this point.The following is a level 6 lock, which can only recurse to acquire locks at lower levels:codegenThe following is an almost root lock (level end-1), meaning only the root look may be held when trying to acquire it:typeinf\nthis one is perhaps one of the most tricky ones, since type-inference can be invoked from many pointscurrently the lock is merged with the codegen lock, since they call each other recursivelyThe following is the root lock, meaning no other lock shall be held when trying to acquire it:toplevel\nthis should be held while attempting a top-level action (such as making a new type or defining a new method): trying to obtain this lock inside a staged function will cause a deadlock condition!additionally, it's unclear if any code can safely run in parallel with an arbitrary toplevel expression, so it may require all threads to get to a safepoint first"
},

{
    "location": "devdocs/locks.html#Broken-Locks-1",
    "page": "Proper maintenance and care of multi-threading locks",
    "title": "Broken Locks",
    "category": "section",
    "text": "The following locks are broken:toplevel\ndoesn't exist right nowfix: create it"
},

{
    "location": "devdocs/locks.html#Shared-Global-Data-Structures-1",
    "page": "Proper maintenance and care of multi-threading locks",
    "title": "Shared Global Data Structures",
    "category": "section",
    "text": "These data structures each need locks due to being shared mutable global state. It is the inverse list for the above lock priority list. This list does not include level 1 leaf resources due to their simplicity.MethodTable modifications (def, cache, kwsorter type) : MethodTable->writelockType declarations : toplevel lockType application : typecache lockModule serializer : toplevel lockJIT & type-inference : codegen lockMethodInstance updates : codegen lockThese fields are generally lazy initialized, using the test-and-test-and-set pattern.\nThese are set at construction and immutable:\nspecTypes\nsparam_vals\ndef\nThese are set by jl_type_infer (while holding codegen lock):\nrettype\ninferred\nthese can also be reset, see jl_set_lambda_rettype for that logic as it needs to keep functionObjectsDecls in sync\ninInference flag:\noptimization to quickly avoid recurring into jl_type_infer while it is already running\nactual state (of setting inferred, then fptr) is protected by codegen lock\nFunction pointers (jlcall_api and fptr, unspecialized_ducttape):\nthese transition once, from NULL to a value, while the codegen lock is held\nCode-generator cache (the contents of functionObjectsDecls):\nthese can transition multiple times, but only while the codegen lock is held\nit is valid to use old version of this, or block for new versions of this, so races are benign, as long as the code is careful not to reference other data in the method instance (such as rettype) and assume it is coordinated, unless also holding the codegen lock\ncompile_traced flag:\nunknownLLVMContext : codegen lockMethod : Method->writelockroots array (serializer and codegen)\ninvoke / specializations / tfunc modifications"
},

{
    "location": "devdocs/offset-arrays.html#",
    "page": "Arrays with custom indices",
    "title": "Arrays with custom indices",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/offset-arrays.html#offset-arrays-1",
    "page": "Arrays with custom indices",
    "title": "Arrays with custom indices",
    "category": "section",
    "text": "Julia 0.5 adds experimental support for arrays with arbitrary indices. Conventionally, Julia's arrays are indexed starting at 1, whereas some other languages start numbering at 0, and yet others (e.g., Fortran) allow you to specify arbitrary starting indices.  While there is much merit in picking a standard (i.e., 1 for Julia), there are some algorithms which simplify considerably if you can index outside the range 1:size(A,d) (and not just 0:size(A,d)-1, either). Such array types are expected to be supplied through packages.The purpose of this page is to address the question, \"what do I have to do to support such arrays in my own code?\"  First, let's address the simplest case: if you know that your code will never need to handle arrays with unconventional indexing, hopefully the answer is \"nothing.\" Old code, on conventional arrays, should function essentially without alteration as long as it was using the exported interfaces of Julia."
},

{
    "location": "devdocs/offset-arrays.html#Generalizing-existing-code-1",
    "page": "Arrays with custom indices",
    "title": "Generalizing existing code",
    "category": "section",
    "text": "As an overview, the steps are:replace many uses of size with indices\nreplace 1:length(A) with linearindices(A), and length(A) with length(linearindices(A))\nreplace explicit allocations like Array{Int}(size(B)) with similar(Array{Int}, indices(B))These are described in more detail below."
},

{
    "location": "devdocs/offset-arrays.html#Background-1",
    "page": "Arrays with custom indices",
    "title": "Background",
    "category": "section",
    "text": "Because unconventional indexing breaks deeply-held assumptions throughout the Julia ecosystem, early adopters running code that has not been updated are likely to experience errors.  The most frustrating bugs would be incorrect results or segfaults (total crashes of Julia).  For example, consider the following function:function mycopy!(dest::AbstractVector, src::AbstractVector)\n    length(dest) == length(src) || throw(DimensionMismatch(\"vectors must match\"))\n    # OK, now we're safe to use @inbounds, right? (not anymore!)\n    for i = 1:length(src)\n        @inbounds dest[i] = src[i]\n    end\n    dest\nendThis code implicitly assumes that vectors are indexed from 1. Previously that was a safe assumption, so this code was fine, but (depending on what types the user passes to this function) it may no longer be safe.  If this code continued to work when passed a vector with non-1 indices, it would either produce an incorrect answer or it would segfault.  (If you do get segfaults, to help locate the cause try running julia with the option --check-bounds=yes.)To ensure that such errors are caught, in Julia 0.5 both length and sizeshould throw an error when passed an array with non-1 indexing.  This is designed to force users of such arrays to check the code, and inspect it for whether it needs to be generalized."
},

{
    "location": "devdocs/offset-arrays.html#Using-indices-for-bounds-checks-and-loop-iteration-1",
    "page": "Arrays with custom indices",
    "title": "Using indices for bounds checks and loop iteration",
    "category": "section",
    "text": "indices(A) (reminiscent of size(A)) returns a tuple of AbstractUnitRange objects, specifying the range of valid indices along each dimension of A.  When A has unconventional indexing, the ranges may not start at 1.  If you just want the range for a particular dimension d, there is indices(A, d).Base implements a custom range type, OneTo, where OneTo(n) means the same thing as 1:n but in a form that guarantees (via the type system) that the lower index is 1. For any new AbstractArray type, this is the default returned by indices, and it indicates that this array type uses \"conventional\" 1-based indexing.  Note that if you don't want to be bothered supporting arrays with non-1 indexing, you can add the following line:@assert all(x->isa(x, Base.OneTo), indices(A))at the top of any function.For bounds checking, note that there are dedicated functions checkbounds and checkindex which can sometimes simplify such tests."
},

{
    "location": "devdocs/offset-arrays.html#Linear-indexing-(linearindices)-1",
    "page": "Arrays with custom indices",
    "title": "Linear indexing (linearindices)",
    "category": "section",
    "text": "Some algorithms are most conveniently (or efficiently) written in terms of a single linear index, A[i] even if A is multi-dimensional.  In \"true\" linear indexing, the indices always range from 1:length(A). However, this raises an ambiguity for one-dimensional arrays (a.k.a., AbstractVector): does v[i] mean linear indexing, or Cartesian indexing with the array's native indices?For this reason, if you want to use linear indexing in an algorithm, your best option is to get the index range by calling linearindices(A).  This will return indices(A, 1) if A is an AbstractVector, and the equivalent of 1:length(A) otherwise.In a sense, one can say that 1-dimensional arrays always use Cartesian indexing. To help enforce this, it's worth noting that sub2ind(shape, i...) and ind2sub(shape, ind) will throw an error if shape indicates a 1-dimensional array with unconventional indexing (i.e., is a Tuple{UnitRange} rather than a tuple of OneTo).  For arrays with conventional indexing, these functions continue to work the same as always.Using indices and linearindices, here is one way you could rewrite mycopy!:function mycopy!(dest::AbstractVector, src::AbstractVector)\n    indices(dest) == indices(src) || throw(DimensionMismatch(\"vectors must match\"))\n    for i in linearindices(src)\n        @inbounds dest[i] = src[i]\n    end\n    dest\nend"
},

{
    "location": "devdocs/offset-arrays.html#Allocating-storage-using-generalizations-of-similar-1",
    "page": "Arrays with custom indices",
    "title": "Allocating storage using generalizations of similar",
    "category": "section",
    "text": "Storage is often allocated with Array{Int}(dims) or similar(A, args...). When the result needs to match the indices of some other array, this may not always suffice. The generic replacement for such patterns is to use similar(storagetype, shape).  storagetype indicates the kind of underlying \"conventional\" behavior you'd like, e.g., Array{Int} or BitArray or even dims->zeros(Float32, dims) (which would allocate an all-zeros array). shape is a tuple of Integer or AbstractUnitRange values, specifying the indices that you want the result to use.Let's walk through a couple of explicit examples. First, if A has conventional indices, then similar(Array{Int}, indices(A)) would end up calling Array{Int}(size(A)), and thus return an array.  If A is an AbstractArray type with unconventional indexing, then similar(Array{Int}, indices(A)) should return something that \"behaves like\" an Array{Int} but with a shape (including indices) that matches A.  (The most obvious implementation is to allocate an Array{Int}(size(A)) and then \"wrap\" it in a type that shifts the indices.)Note also that similar(Array{Int}, (indices(A, 2),)) would allocate an AbstractVector{Int} (i.e., 1-dimensional array) that matches the indices of the columns of A."
},

{
    "location": "devdocs/offset-arrays.html#Deprecations-1",
    "page": "Arrays with custom indices",
    "title": "Deprecations",
    "category": "section",
    "text": "In generalizing Julia's code base, at least one deprecation was unavoidable: earlier versions of Julia defined first(::Colon) = 1, meaning that the first index along a dimension indexed by : is 1. This definition can no longer be justified, so it was deprecated. There is no provided replacement, because the proper replacement depends on what you are doing and might need to know more about the array. However, it appears that many uses of first(::Colon) are really about computing an index offset; when that is the case, a candidate replacement is:indexoffset(r::AbstractVector) = first(r) - 1\nindexoffset(::Colon) = 0In other words, while first(:) does not itself make sense, in general you can say that the offset associated with a colon-index is zero."
},

{
    "location": "devdocs/offset-arrays.html#Writing-custom-array-types-with-non-1-indexing-1",
    "page": "Arrays with custom indices",
    "title": "Writing custom array types with non-1 indexing",
    "category": "section",
    "text": "Most of the methods you'll need to define are standard for any AbstractArray type, see Abstract Arrays. This page focuses on the steps needed to define unconventional indexing."
},

{
    "location": "devdocs/offset-arrays.html#Do-**not**-implement-size-or-length-1",
    "page": "Arrays with custom indices",
    "title": "Do not implement size or length",
    "category": "section",
    "text": "Perhaps the majority of pre-existing code that uses size will not work properly for arrays with non-1 indices.  For that reason, it is much better to avoid implementing these methods, and use the resulting MethodError to identify code that needs to be audited and perhaps generalized."
},

{
    "location": "devdocs/offset-arrays.html#Do-**not**-annotate-bounds-checks-1",
    "page": "Arrays with custom indices",
    "title": "Do not annotate bounds checks",
    "category": "section",
    "text": "Julia 0.5 includes @boundscheck to annotate code that can be removed for callers that exploit @inbounds. Initially, it seems far preferable to run with bounds checking always enabled (i.e., omit the @boundscheck annotation so the check always runs)."
},

{
    "location": "devdocs/offset-arrays.html#Custom-AbstractUnitRange-types-1",
    "page": "Arrays with custom indices",
    "title": "Custom AbstractUnitRange types",
    "category": "section",
    "text": "If you're writing a non-1 indexed array type, you will want to specialize indices so it returns a UnitRange, or (perhaps better) a custom AbstractUnitRange.  The advantage of a custom type is that it \"signals\" the allocation type for functions like similar. If we're writing an array type for which indexing will start at 0, we likely want to begin by creating a new AbstractUnitRange, ZeroRange, where ZeroRange(n) is equivalent to 0:n-1.In general, you should probably not export ZeroRange from your package: there may be other packages that implement their own ZeroRange, and having multiple distinct ZeroRange types is (perhaps counterintuitively) an advantage: ModuleA.ZeroRange indicates that similar should create a ModuleA.ZeroArray, whereas ModuleB.ZeroRange indicates a ModuleB.ZeroArray type.  This design allows peaceful coexistence among many different custom array types.Note that the Julia package CustomUnitRanges.jl can sometimes be used to avoid the need to write your own ZeroRange type."
},

{
    "location": "devdocs/offset-arrays.html#Specializing-indices-1",
    "page": "Arrays with custom indices",
    "title": "Specializing indices",
    "category": "section",
    "text": "Once you have your AbstractUnitRange type, then specialize indices:Base.indices(A::ZeroArray) = map(n->ZeroRange(n), A.size)where here we imagine that ZeroArray has a field called size (there would be other ways to implement this).In some cases, the fallback definition for indices(A, d):indices(A::AbstractArray{T,N}, d) where {T,N} = d <= N ? indices(A)[d] : OneTo(1)may not be what you want: you may need to specialize it to return something other than OneTo(1) when d > ndims(A).  Likewise, in Base there is a dedicated function indices1 which is equivalent to indices(A, 1) but which avoids checking (at runtime) whether ndims(A) > 0. (This is purely a performance optimization.)  It is defined as:indices1(A::AbstractArray{T,0}) where {T} = OneTo(1)\nindices1(A::AbstractArray) = indices(A)[1]If the first of these (the zero-dimensional case) is problematic for your custom array type, be sure to specialize it appropriately."
},

{
    "location": "devdocs/offset-arrays.html#Specializing-similar-1",
    "page": "Arrays with custom indices",
    "title": "Specializing similar",
    "category": "section",
    "text": "Given your custom ZeroRange type, then you should also add the following two specializations for similar:function Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n    # body\nend\n\nfunction Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n    # body\nendBoth of these should allocate your custom array type."
},

{
    "location": "devdocs/offset-arrays.html#Specializing-reshape-1",
    "page": "Arrays with custom indices",
    "title": "Specializing reshape",
    "category": "section",
    "text": "Optionally, define a methodBase.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...and you can reshape an array so that the result has custom indices."
},

{
    "location": "devdocs/offset-arrays.html#Summary-1",
    "page": "Arrays with custom indices",
    "title": "Summary",
    "category": "section",
    "text": "Writing code that doesn't make assumptions about indexing requires a few extra abstractions, but hopefully the necessary changes are relatively straightforward.As a reminder, this support is still experimental. While much of Julia's base code has been updated to support unconventional indexing, without a doubt there are many omissions that will be discovered only through usage.  Moreover, at the time of this writing, most packages do not support unconventional indexing.  As a consequence, early adopters should be prepared to identify and/or fix bugs.  On the other hand, only through practical usage will it become clear whether this experimental feature should be retained in future versions of Julia; consequently, interested parties are encouraged to accept some ownership for putting it through its paces."
},

{
    "location": "devdocs/libgit2.html#",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/libgit2.html#libgit2-1",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2",
    "category": "section",
    "text": "The LibGit2 module provides bindings to libgit2, a portable C library that implements core functionality for the Git version control system. These bindings are currently used to power Julia's package manager. It is expected that this module will eventually be moved into a separate package."
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.AbstractCredentials",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.AbstractCredentials",
    "category": "Type",
    "text": "Abstract credentials payload\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.Buffer",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.Buffer",
    "category": "Type",
    "text": "LibGit2.Buffer\n\nA data buffer for exporting data from libgit2. Matches the git_buf struct.\n\nWhen fetching data from LibGit2, a typical usage would look like:\n\nbuf_ref = Ref(Buffer())\n@check ccall(..., (Ptr{Buffer},), buf_ref)\n# operation on buf_ref\nfree(buf_ref)\n\nIn particular, note that LibGit2.free should be called afterward on the Ref object.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.CachedCredentials",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.CachedCredentials",
    "category": "Type",
    "text": "Credentials that support caching\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.CheckoutOptions",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.CheckoutOptions",
    "category": "Type",
    "text": "LibGit2.CheckoutOptions\n\nMatches the git_checkout_options struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.CloneOptions",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.CloneOptions",
    "category": "Type",
    "text": "LibGit2.CloneOptions\n\nMatches the git_clone_options struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.DiffDelta",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.DiffDelta",
    "category": "Type",
    "text": "LibGit2.DiffDelta\n\nDescription of changes to one entry. Matches the git_diff_delta struct.\n\nThe fields represent:\n\nstatus: One of Consts.DELTA_STATUS, indicating whether the file has been added/modified/deleted.\nflags: Flags for the delta and the objects on each side. Determines whether to treat the file(s)  as binary/text, whether they exist on each side of the diff, and whether the object ids are known  to be correct.\nsimilarity: Used to indicate if a file has been renamed or copied.\nnfiles: The number of files in the delta (for instance, if the delta  was run on a submodule commit id, it may contain more than one file).\nold_file: A DiffFile containing information about the file(s) before the changes.\nnew_file: A DiffFile containing information about the file(s) after the changes.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.DiffFile",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.DiffFile",
    "category": "Type",
    "text": "LibGit2.DiffFile\n\nDescription of one side of a delta. Matches the git_diff_file struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.DiffOptionsStruct",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.DiffOptionsStruct",
    "category": "Type",
    "text": "LibGit2.DiffOptionsStruct\n\nMatches the git_diff_options struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.FetchHead",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.FetchHead",
    "category": "Type",
    "text": "LibGit2.FetchHead\n\nContains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.FetchOptions",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.FetchOptions",
    "category": "Type",
    "text": "LibGit2.FetchOptions\n\nMatches the git_fetch_options struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitBlob",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitBlob",
    "category": "Type",
    "text": "GitBlob(repo::GitRepo, hash::AbstractGitHash)\nGitBlob(repo::GitRepo, spec::AbstractString)\n\nReturn a GitBlob object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitCommit",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitCommit",
    "category": "Type",
    "text": "GitCommit(repo::GitRepo, hash::AbstractGitHash)\nGitCommit(repo::GitRepo, spec::AbstractString)\n\nReturn a GitCommit object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitHash",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitHash",
    "category": "Type",
    "text": "GitHash\n\nA git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a GitObject in a repository.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitObject",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitObject",
    "category": "Type",
    "text": "GitObject(repo::GitRepo, hash::AbstractGitHash)\nGitObject(repo::GitRepo, spec::AbstractString)\n\nReturn the specified object (GitCommit, GitBlob, GitTree or GitTag) from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitRemote",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitRemote",
    "category": "Type",
    "text": "GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString) -> GitRemote\n\nLook up a remote git repository using its name and URL. Uses the default fetch refspec.\n\nExample\n\nrepo = LibGit2.init(repo_path)\nremote = LibGit2.GitRemote(repo, \"upstream\", repo_url)\n\n\n\nGitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString) -> GitRemote\n\nLook up a remote git repository using the repository's name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).\n\nExample\n\nrepo = LibGit2.init(repo_path)\nrefspec = \"+refs/heads/mybranch:refs/remotes/origin/mybranch\"\nremote = LibGit2.GitRemote(repo, \"upstream\", repo_url, refspec)\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitRemoteAnon",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitRemoteAnon",
    "category": "Function",
    "text": "GitRemoteAnon(repo::GitRepo, url::AbstractString) -> GitRemote\n\nLook up a remote git repository using only its URL, not its name.\n\nExample\n\nrepo = LibGit2.init(repo_path)\nremote = LibGit2.GitRemoteAnon(repo, repo_url)\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitRepo",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitRepo",
    "category": "Type",
    "text": "LibGit2.GitRepo(path::AbstractString)\n\nOpens a git repository at path.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitRepoExt",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitRepoExt",
    "category": "Function",
    "text": "LibGit2.GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))\n\nOpens a git repository at path with extended controls (for instance, if the current user must be a member of a special access group to read path).\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitShortHash",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitShortHash",
    "category": "Type",
    "text": "GitShortHash\n\nThis is a shortened form of GitHash, which can be used to identify a git object when it is unique.\n\nInternally it is stored as two fields: a full-size GitHash (hash) and a length (len). Only the initial len hex digits of hash are used.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitSignature",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitSignature",
    "category": "Type",
    "text": "LibGit2.GitSignature\n\nThis is a Julia wrapper around a pointer to a git_signature object.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitStatus",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitStatus",
    "category": "Type",
    "text": "LibGit2.GitStatus(repo::GitRepo; status_opts=StatusOptions())\n\nCollect information about the status of each file in the git repository repo (e.g. is the file modified, staged, etc.). status_opts can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitTag",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitTag",
    "category": "Type",
    "text": "GitTag(repo::GitRepo, hash::AbstractGitHash)\nGitTag(repo::GitRepo, spec::AbstractString)\n\nReturn a GitTag object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.GitTree",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.GitTree",
    "category": "Type",
    "text": "GitTree(repo::GitRepo, hash::AbstractGitHash)\nGitTree(repo::GitRepo, spec::AbstractString)\n\nReturn a GitTree object from repo specified by hash/spec.\n\nhash is a full (GitHash) or partial (GitShortHash) hash.\nspec is a textual specification: see the git docs for a full list.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.IndexEntry",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.IndexEntry",
    "category": "Type",
    "text": "LibGit2.IndexEntry\n\nIn-memory representation of a file entry in the index. Matches the git_index_entry struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.IndexTime",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.IndexTime",
    "category": "Type",
    "text": "LibGit2.IndexTime\n\nMatches the git_index_time struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.MergeOptions",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.MergeOptions",
    "category": "Type",
    "text": "LibGit2.MergeOptions\n\nMatches the git_merge_options struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.ProxyOptions",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.ProxyOptions",
    "category": "Type",
    "text": "LibGit2.ProxyOptions\n\nOptions for connecting through a proxy.\n\nMatches the git_proxy_options struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.PushOptions",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.PushOptions",
    "category": "Type",
    "text": "LibGit2.PushOptions\n\nMatches the git_push_options struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.RebaseOperation",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.RebaseOperation",
    "category": "Type",
    "text": "LibGit2.RebaseOperation\n\nDescribes a single instruction/operation to be performed during the rebase. Matches the git_rebase_operation struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.RebaseOptions",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.RebaseOptions",
    "category": "Type",
    "text": "LibGit2.RebaseOptions\n\nMatches the git_rebase_options struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.RemoteCallbacks",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.RemoteCallbacks",
    "category": "Type",
    "text": "LibGit2.RemoteCallbacks\n\nCallback settings. Matches the git_remote_callbacks struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.SSHCredentials",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.SSHCredentials",
    "category": "Type",
    "text": "SSH credentials type\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.SignatureStruct",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.SignatureStruct",
    "category": "Type",
    "text": "LibGit2.SignatureStruct\n\nAn action signature (e.g. for committers, taggers, etc). Matches the git_signature struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.StatusEntry",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.StatusEntry",
    "category": "Type",
    "text": "LibGit2.StatusEntry\n\nProviding the differences between the file as it exists in HEAD and the index, and providing the differences between the index and the working directory. Matches the git_status_entry struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.StatusOptions",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.StatusOptions",
    "category": "Type",
    "text": "LibGit2.StatusOptions\n\nOptions to control how git_status_foreach_ext() will issue callbacks. Matches the git_status_opt_t struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.StrArrayStruct",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.StrArrayStruct",
    "category": "Type",
    "text": "LibGit2.StrArrayStruct\n\nA LibGit2 representation of an array of strings. Matches the git_strarray struct.\n\nWhen fetching data from LibGit2, a typical usage would look like:\n\nsa_ref = Ref(StrArrayStruct())\n@check ccall(..., (Ptr{StrArrayStruct},), sa_ref)\nres = convert(Vector{String}, sa_ref[])\nfree(sa_ref)\n\nIn particular, note that LibGit2.free should be called afterward on the Ref object.\n\nConversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:\n\nstrs = String[...]\n@check ccall(..., (Ptr{StrArrayStruct},), strs)\n\nNote that no call to free is required as the data is allocated by Julia.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.TimeStruct",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.TimeStruct",
    "category": "Type",
    "text": "LibGit2.TimeStruct\n\nTime in a signature. Matches the git_time struct.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.UserPasswordCredentials",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.UserPasswordCredentials",
    "category": "Type",
    "text": "Credentials that support only user and password parameters\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.add_fetch!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.add_fetch!",
    "category": "Function",
    "text": "add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)\n\nAdd a fetch refspec for the specified rmt. This refspec will contain information about which branch(es) to fetch from.\n\nExample\n\njulia> LibGit2.add_fetch!(repo, remote, \"upstream\");\n\njulia> LibGit2.fetch_refspecs(remote)\nString[\"+refs/heads/*:refs/remotes/upstream/*\"]\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.add_push!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.add_push!",
    "category": "Function",
    "text": "add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)\n\nAdd a push refspec for the specified rmt. This refspec will contain information about which branch(es) to push to.\n\nExample\n\njulia> LibGit2.add_push!(repo, remote, \"refs/heads/master\");\n\njulia> remote = LibGit2.get(LibGit2.GitRemote, repo, branch);\n\njulia> LibGit2.push_refspecs(remote)\nString[\"refs/heads/master\"]\n\nnote: Note\nYou may need to close and reopen the GitRemote in question after updating its push refspecs in order for the change to take effect and for calls to push to work.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.addblob!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.addblob!",
    "category": "Function",
    "text": "LibGit2.addblob!(repo::GitRepo, path::AbstractString)\n\nReads the file at path and adds it to the object database of repo as a loose blob. Returns the GitHash of the resulting blob.\n\nExample\n\nhash_str = hex(commit_oid)\nblob_file = joinpath(repo_path, \".git\", \"objects\", hash_str[1:2], hash_str[3:end])\nid = LibGit2.addblob!(repo, blob_file)\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.authors",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.authors",
    "category": "Function",
    "text": "authors(repo::GitRepo) -> Vector{Signature}\n\nReturns all authors of commits to the repo repository.\n\nExample\n\nrepo = LibGit2.GitRepo(repo_path)\nrepo_file = open(joinpath(repo_path, test_file), \"a\")\n\nprintln(repo_file, commit_msg)\nflush(repo_file)\nLibGit2.add!(repo, test_file)\nsig = LibGit2.Signature(\"TEST\", \"TEST@TEST.COM\", round(time(), 0), 0)\ncommit_oid1 = LibGit2.commit(repo, \"commit1\"; author=sig, committer=sig)\nprintln(repo_file, randstring(10))\nflush(repo_file)\nLibGit2.add!(repo, test_file)\ncommit_oid2 = LibGit2.commit(repo, \"commit2\"; author=sig, committer=sig)\n\n# will be a Vector of [sig, sig]\nauths = LibGit2.authors(repo)\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.branch",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.branch",
    "category": "Function",
    "text": "branch(repo::GitRepo)\n\nEquivalent to git branch. Create a new branch from the current HEAD.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.branch!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.branch!",
    "category": "Function",
    "text": "branch!(repo::GitRepo, branch_name::AbstractString, commit::AbstractString=\"\"; kwargs...)\n\nCheckout a new git branch in the repo repository. commit is the GitHash, in string form, which will be the start of the new branch. If commit is an empty string, the current HEAD will be used.\n\nThe keyword arguments are:\n\ntrack::AbstractString=\"\": the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.\nforce::Bool=false: if true, branch creation will be forced.\nset_head::Bool=true: if true, after the branch creation finishes the branch head will be set as the HEAD of repo.\n\nEquivalent to git checkout [-b|-B] <branch_name> [<commit>] [--track <track>].\n\nExample\n\nrepo = LibGit2.GitRepo(repo_path)\nLibGit2.branch!(repo, \"new_branch\", set_head=false)\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.checkout!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.checkout!",
    "category": "Function",
    "text": "checkout!(repo::GitRepo, commit::AbstractString=\"\"; force::Bool=true)\n\nEquivalent to git checkout [-f] --detach <commit>. Checkout the git commit commit (a GitHash in string form) in repo. If force is true, force the checkout and discard any current changes. Note that this detaches the current HEAD.\n\nExample\n\nrepo = LibGit2.init(repo_path)\nopen(joinpath(LibGit2.path(repo), \"file1\"), \"w\") do f\n    write(f, \"111\n\")\nend\nLibGit2.add!(repo, \"file1\")\ncommit_oid = LibGit2.commit(repo, \"add file1\")\nopen(joinpath(LibGit2.path(repo), \"file1\"), \"w\") do f\n    write(f, \"112\n\")\nend\n# would fail without the force=true\n# since there are modifications to the file\nLibGit2.checkout!(repo, string(commit_oid), force=true)\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.checkused!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.checkused!",
    "category": "Function",
    "text": "Checks if credentials were used\n\n\n\nChecks if credentials were used or failed authentication, see LibGit2.credentials_callback\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.clone",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.clone",
    "category": "Function",
    "text": "clone(repo_url::AbstractString, repo_path::AbstractString; kwargs...)\n\nClone a remote repository located at repo_url to the local filesystem location repo_path.\n\nThe keyword arguments are:\n\nbranch::AbstractString=\"\": which branch of the remote to clone, if not the default repository branch (usually master).\nisbare::Bool=false: if true, clone the remote as a bare repository, which will make repo_path itself the git directory instead of repo_path/.git. This means that a working tree cannot be checked out. Plays the role of the git CLI argument --bare.\nremote_cb::Ptr{Void}=C_NULL: a callback which will be used to create the remote before it is cloned. If C_NULL (the default), no attempt will be made to create the remote - it will be assumed to already exist.\npayload::Nullable{P<:AbstractCredentials}=Nullable{AbstractCredentials}(): provides credentials if necessary, for instance if the remote is a private repository.\n\nEquivalent to git clone [-b <branch>] [--bare] <repo_url> <repo_path>.\n\nExamples\n\nrepo_url = \"https://github.com/JuliaLang/Example.jl\"\nrepo1 = LibGit2.clone(repo_url, \"test_path\")\nrepo2 = LibGit2.clone(repo_url, \"test_path\", isbare=true)\njulia_url = \"https://github.com/JuliaLang/julia\"\njulia_repo = LibGit2.clone(julia_url, \"julia_path\", branch=\"release-0.6\")\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.commit",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.commit",
    "category": "Function",
    "text": "Wrapper around git_commit_create \n\n\n\nCommit changes to repository\n\n\n\nLibGit2.commit(rb::GitRebase, sig::GitSignature)\n\nCommits the current patch to the rebase rb, using sig as the committer. Is silent if the commit has already been applied.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.create_branch",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.create_branch",
    "category": "Function",
    "text": "LibGit2.create_branch(repo::GitRepo, bname::AbstractString, commit_obj::GitCommit; force::Bool=false)\n\nCreate a new branch in the repository repo with name bname, which points to commit commit_obj (which has to be part of repo). If force is true, overwrite an existing branch named bname if it exists. If force is false and a branch already exists named bname, this function will throw an error.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.credentials_callback",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.credentials_callback",
    "category": "Function",
    "text": "Credentials callback function\n\nFunction provides different credential acquisition functionality w.r.t. a connection protocol. If a payload is provided then payload_ptr should contain a LibGit2.AbstractCredentials object.\n\nFor LibGit2.Consts.CREDTYPE_USERPASS_PLAINTEXT type, if the payload contains fields: user & pass, they are used to create authentication credentials. Empty user name and password trigger an authentication error.\n\nFor LibGit2.Consts.CREDTYPE_SSH_KEY type, if the payload contains fields: user, prvkey, pubkey & pass, they are used to create authentication credentials. Empty user name triggers an authentication error.\n\nCredentials are checked in the following order (if supported):\n\nssh key pair (ssh-agent if specified in payload's usesshagent field)\nplain text\n\nNote: Due to the specifics of the libgit2 authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, the checkused! function can be called. This function returns true if the credentials were used. Using credentials triggers a user prompt for (re)entering required information. UserPasswordCredentials and CachedCredentials are implemented using a call counting strategy that prevents repeated usage of faulty credentials.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.credentials_cb",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.credentials_cb",
    "category": "Function",
    "text": "C function pointer for credentials_callback\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.default_signature",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.default_signature",
    "category": "Function",
    "text": "Return signature object. Free it after use.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.delete_branch",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.delete_branch",
    "category": "Function",
    "text": "LibGit2.delete_branch(branch::GitReference)\n\nDelete the branch pointed to by branch.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.diff_files",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.diff_files",
    "category": "Function",
    "text": "diff_files(repo::GitRepo, branch1::AbstractString, branch2::AbstractString; kwarg...) -> Vector{AbstractString}\n\nShow which files have changed in the git repository repo between branches branch1 and branch2.\n\nThe keyword argument is:\n\nfilter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED])), and it sets options for the diff. The default is to show files added, modified, or deleted.\n\nReturns only the names of the files which have changed, not their contents.\n\nExample\n\nLibGit2.branch!(repo, \"branch/a\")\nLibGit2.branch!(repo, \"branch/b\")\n# add a file to repo\nopen(joinpath(LibGit2.path(repo),\"file\"),\"w\") do f\n    write(f, \"hello repo\n\")\nend\nLibGit2.add!(repo, \"file\")\nLibGit2.commit(repo, \"add file\")\n# returns [\"file\"]\nfilt = Set([LibGit2.Consts.DELTA_ADDED])\nfiles = LibGit2.diff_files(repo, \"branch/a\", \"branch/b\", filter=filt)\n# returns [] because existing files weren't modified\nfilt = Set([LibGit2.Consts.DELTA_MODIFIED])\nfiles = LibGit2.diff_files(repo, \"branch/a\", \"branch/b\", filter=filt)\n\nEquivalent to git diff --name-only --diff-filter=<filter> <branch1> <branch2>.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.fetch",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.fetch",
    "category": "Function",
    "text": "fetch(rmt::GitRemote, refspecs; options::FetchOptions=FetchOptions(), msg=\"\")\n\nFetch from the specified rmt remote git repository, using refspecs to determine which remote branch(es) to fetch. The keyword arguments are:\n\noptions: determines the options for the fetch, e.g. whether to prune afterwards.\nmsg: a message to insert into the reflogs.\n\n\n\nfetch(repo::GitRepo; kwargs...)\n\nFetches updates from an upstream of the repository repo.\n\nThe keyword arguments are:\n\nremote::AbstractString=\"origin\": which remote, specified by name, of repo to fetch from. If this is empty, the URL will be used to construct an anonymous remote.\nremoteurl::AbstractString=\"\": the URL of remote. If not specified, will be assumed based on the given name of remote.\nrefspecs=AbstractString[]: determines properties of the fetch.\npayload=Nullable{AbstractCredentials}(): provides credentials, if necessary, for instance if remote is a private repository.\n\nEquivalent to git fetch [<remoteurl>|<repo>] [<refspecs>].\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.fetch_refspecs",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.fetch_refspecs",
    "category": "Function",
    "text": "fetch_refspecs(rmt::GitRemote) -> Vector{String}\n\nGet the fetch refspecs for the specified rmt. These refspecs contain information about which branch(es) to fetch from.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.fetchhead_foreach_cb",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.fetchhead_foreach_cb",
    "category": "Function",
    "text": "C function pointer for fetchhead_foreach_callback\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.ffmerge!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.ffmerge!",
    "category": "Function",
    "text": "Fastforward merge changes into current head \n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.fullname",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.fullname",
    "category": "Function",
    "text": "LibGit2.fullname(ref::GitReference)\n\nReturn the name of the reference pointed to by the symbolic reference ref. If ref is not a symbolic reference, returns an empty string.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.get_creds!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.get_creds!",
    "category": "Function",
    "text": "Obtain the cached credentials for the given host+protocol (credid), or return and store the default if not found\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.gitdir",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.gitdir",
    "category": "Function",
    "text": "LibGit2.gitdir(repo::GitRepo)\n\nReturns the location of the \"git\" files of repo:\n\nfor normal repositories, this is the location of the .git folder.\nfor bare repositories, this is the location of the repository itself.\n\nSee also workdir, path.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.head",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.head",
    "category": "Function",
    "text": "LibGit2.head(repo::GitRepo) -> GitReference\n\nReturns a GitReference to the current HEAD of repo.\n\n\n\nhead(pkg::AbstractString) -> String\n\nReturn current HEAD GitHash of the pkg repo as a string.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.head!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.head!",
    "category": "Function",
    "text": "LibGit2.head!(repo::GitRepo, ref::GitReference) -> GitReference\n\nSet the HEAD of repo to the object pointed to by ref.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.head_oid",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.head_oid",
    "category": "Function",
    "text": "LibGit2.head_oid(repo::GitRepo) -> GitHash\n\nLookup the object id of the current HEAD of git repository repo.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.headname",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.headname",
    "category": "Function",
    "text": "LibGit2.headname(repo::GitRepo)\n\nLookup the name of the current HEAD of git repository repo. If repo is currently detached, returns the name of the HEAD it's detached from.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.init",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.init",
    "category": "Function",
    "text": "LibGit2.init(path::AbstractString, bare::Bool=false) -> GitRepo\n\nOpens a new git repository at path. If bare is false, the working tree will be created in path/.git. If bare is true, no working directory will be created.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.is_ancestor_of",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.is_ancestor_of",
    "category": "Function",
    "text": "is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo) -> Bool\n\nReturns true if a, a GitHash in string form, is an ancestor of b, a GitHash in string form.\n\nExample\n\njulia> repo = LibGit2.GitRepo(repo_path);\n\njulia> LibGit2.add!(repo, test_file1);\n\njulia> commit_oid1 = LibGit2.commit(repo, \"commit1\");\n\njulia> LibGit2.add!(repo, test_file2);\n\njulia> commit_oid2 = LibGit2.commit(repo, \"commit2\");\n\njulia> LibGit2.is_ancestor_of(string(commit_oid1), string(commit_oid2), repo)\ntrue\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.isbinary",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.isbinary",
    "category": "Function",
    "text": "Use a heuristic to guess if a file is binary: searching for NULL bytes and looking for a reasonable ratio of printable to non-printable characters among the first 8000 bytes.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.iscommit",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.iscommit",
    "category": "Function",
    "text": "iscommit(id::AbstractString, repo::GitRepo) -> Bool\n\nChecks if commit id (which is a GitHash in string form) is in the repository.\n\nExample\n\njulia> repo = LibGit2.GitRepo(repo_path);\n\njulia> LibGit2.add!(repo, test_file);\n\njulia> commit_oid = LibGit2.commit(repo, \"add test_file\");\n\njulia> LibGit2.iscommit(string(commit_oid), repo)\ntrue\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.isdiff",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.isdiff",
    "category": "Function",
    "text": "LibGit2.isdiff(repo::GitRepo, treeish::AbstractString, pathspecs::AbstractString=\"\"; cached::Bool=false)\n\nChecks if there are any differences between the tree specified by treeish and the tracked files in the working tree (if cached=false) or the index (if cached=true). pathspecs are the specifications for options for the diff.\n\nExample\n\nrepo = LibGit2.GitRepo(repo_path)\nLibGit2.isdiff(repo, \"HEAD\") # should be false\nopen(joinpath(repo_path, new_file), \"a\") do f\n    println(f, \"here's my cool new file\")\nend\nLibGit2.isdiff(repo, \"HEAD\") # now true\n\nEquivalent to git diff-index <treeish> [-- <pathspecs>].\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.isdirty",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.isdirty",
    "category": "Function",
    "text": "LibGit2.isdirty(repo::GitRepo, pathspecs::AbstractString=\"\"; cached::Bool=false) -> Bool\n\nChecks if there have been any changes to tracked files in the working tree (if cached=false) or the index (if cached=true). pathspecs are the specifications for options for the diff.\n\nExample\n\nrepo = LibGit2.GitRepo(repo_path)\nLibGit2.isdirty(repo) # should be false\nopen(joinpath(repo_path, new_file), \"a\") do f\n    println(f, \"here's my cool new file\")\nend\nLibGit2.isdirty(repo) # now true\nLibGit2.isdirty(repo, new_file) # now true\n\nEquivalent to git diff-index HEAD [-- <pathspecs>].\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.isorphan",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.isorphan",
    "category": "Function",
    "text": "LibGit2.isorphan(repo::GitRepo)\n\nChecks if the current branch is an \"orphan\" branch, i.e. has no commits. The first commit to this branch will have no parents.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.lookup_branch",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.lookup_branch",
    "category": "Function",
    "text": "lookup_branch(repo::GitRepo, branch_name::AbstractString, remote::Bool=false) -> Nullable{GitReference}\n\nDetermine if the branch specified by branch_name exists in the repository repo. If remote is true, repo is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.\n\nlookup_branch returns a Nullable, which will be null if the requested branch does not exist yet. If the branch does exist, the Nullable contains a GitReference to the branch.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.mirror_callback",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.mirror_callback",
    "category": "Function",
    "text": "Mirror callback function\n\nFunction sets +refs/*:refs/* refspecs and mirror flag for remote reference.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.mirror_cb",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.mirror_cb",
    "category": "Function",
    "text": "C function pointer for mirror_callback\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.name",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.name",
    "category": "Function",
    "text": "LibGit2.name(ref::GitReference)\n\nReturn the full name of ref.\n\n\n\nname(rmt::GitRemote)\n\nGet the name of a remote repository, for instance \"origin\". If the remote is anonymous (see GitRemoteAnon) the name will be an empty string \"\".\n\nExample\n\njulia> repo_url = \"https://github.com/JuliaLang/Example.jl\";\n\njulia> repo = LibGit2.clone(cache_repo, \"test_directory\");\n\njulia> remote = LibGit2.GitRemote(repo, \"origin\", repo_url);\n\njulia> name(remote)\n\"origin\"\n\n\n\nLibGit2.name(tag::GitTag)\n\nThe name of tag (e.g. \"v0.5\").\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.need_update",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.need_update",
    "category": "Function",
    "text": "need_update(repo::GitRepo)\n\nEquivalent to git update-index. Returns true if repo needs updating.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.objtype",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.objtype",
    "category": "Function",
    "text": "objtype(obj_type::Consts.OBJECT)\n\nReturns the type corresponding to the enum value.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.path",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.path",
    "category": "Function",
    "text": "LibGit2.path(repo::GitRepo)\n\nThe base file path of the repository repo.\n\nfor normal repositories, this will typically be the parent directory of the \".git\" directory (note: this may be different than the working directory, see workdir for more details).\nfor bare repositories, this is the location of the \"git\" files.\n\nSee also gitdir, workdir.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.peel",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.peel",
    "category": "Function",
    "text": "peel([T,] ref::GitReference)\n\nRecursively peel ref until an object of type T is obtained. If no T is provided, then ref will be peeled until an object other than a GitTag is obtained.\n\nA GitTag will be peeled to the object it references.\nA GitCommit will be peeled to a GitTree.\n\nnote: Note\nOnly annotated tags can be peeled to GitTag objects. Lightweight tags (the default) are references under refs/tags/ which point directly to GitCommit objects.\n\n\n\npeel([T,] obj::GitObject)\n\nRecursively peel obj until an object of type T is obtained. If no T is provided, then obj will be peeled until the type changes.\n\nA GitTag will be peeled to the object it references.\nA GitCommit will be peeled to a GitTree.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.posixpath",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.posixpath",
    "category": "Function",
    "text": "LibGit2.posixpath(path)\n\nStandardise the path string path to use POSIX separators.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.push",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.push",
    "category": "Function",
    "text": "push(rmt::GitRemote, refspecs; force::Bool=false, options::PushOptions=PushOptions())\n\nPush to the specified rmt remote git repository, using refspecs to determine which remote branch(es) to push to. The keyword arguments are:\n\nforce: if true, a force-push will occur, disregarding conflicts.\noptions: determines the options for the push, e.g. which proxy headers to use.\n\nnote: Note\nYou can add information about the push refspecs in two other ways: by setting an option in the repository's GitConfig (with push.default as the key) or by calling add_push!. Otherwise you will need to explicitly specify a push refspec in the call to push for it to have any effect, like so: LibGit2.push(repo, refspecs=[\"refs/heads/master\"]).\n\n\n\npush(repo::GitRepo; kwargs...)\n\nPushes updates to an upstream of repo.\n\nThe keyword arguments are:\n\nremote::AbstractString=\"origin\": the name of the upstream remote to push to.\nremoteurl::AbstractString=\"\": the URL of remote.\nrefspecs=AbstractString[]: determines properties of the push.\nforce::Bool=false: determines if the push will be a force push,  overwriting the remote branch.\npayload=Nullable{AbstractCredentials}(): provides credentials, if necessary, for instance if remote is a private repository.\n\nEquivalent to git push [<remoteurl>|<repo>] [<refspecs>].\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.push_refspecs",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.push_refspecs",
    "category": "Function",
    "text": "push_refspecs(rmt::GitRemote) -> Vector{String}\n\nGet the push refspecs for the specified rmt. These refspecs contain information about which branch(es) to push to.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.read_tree!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.read_tree!",
    "category": "Function",
    "text": "LibGit2.read_tree!(idx::GitIndex, tree::GitTree)\nLibGit2.read_tree!(idx::GitIndex, treehash::AbstractGitHash)\n\nRead the tree tree (or the tree pointed to by treehash in the repository owned by idx) into the index idx. The current index contents will be replaced.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.rebase!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.rebase!",
    "category": "Function",
    "text": "LibGit2.rebase!(repo::GitRepo, upstream::AbstractString=\"\", newbase::AbstractString=\"\")\n\nAttempt an automatic merge rebase of the current branch, from upstream if provided, or otherwise from the upstream tracking branch. newbase is the branch to rebase onto. By default this is upstream.\n\nIf any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a GitError. This is roughly equivalent to the following command line statement:\n\ngit rebase --merge [<upstream>]\nif [ -d \".git/rebase-merge\" ]; then\n    git rebase --abort\nfi\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.ref_list",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.ref_list",
    "category": "Function",
    "text": "LibGit2.ref_list(repo::GitRepo) -> Vector{String}\n\nGet a list of all reference names in the repo repository.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.reftype",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.reftype",
    "category": "Function",
    "text": "LibGit2.reftype(ref::GitReference) -> Cint\n\nReturns a Cint corresponding to the type of ref:\n\n0 if the reference is invalid\n1 if the reference is an object id\n2 if the reference is symbolic\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.remotes",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.remotes",
    "category": "Function",
    "text": "LibGit2.remotes(repo::GitRepo)\n\nReturns a vector of the names of the remotes of repo.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.reset!",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.reset!",
    "category": "Function",
    "text": "Resets credentials for another use\n\n\n\nUpdates some entries, determined by the pathspecs, in the index from the target commit tree.\n\n\n\nSets the current head to the specified commit oid and optionally resets the index and working tree to match.\n\n\n\ngit reset [<committish>] [–] <pathspecs>... \n\n\n\nreset!(repo::GitRepo, id::GitHash, mode::Cint = Consts.RESET_MIXED)\n\nReset the repository repo to its state at id, using one of three modes set by mode:\n\nConsts.RESET_SOFT - move HEAD to id.\nConsts.RESET_MIXED - default, move HEAD to id and reset the index to id.\nConsts.RESET_HARD - move HEAD to id, reset the index to id, and discard all working changes.\n\nEquivalent to git reset [--soft | --mixed | --hard] <id>.\n\nExample\n\nrepo = LibGit2.GitRepo(repo_path)\nhead_oid = LibGit2.head_oid(repo)\nopen(joinpath(repo_path, \"file1\"), \"w\") do f\n    write(f, \"111\n\")\nend\nLibGit2.add!(repo, \"file1\")\nmode = LibGit2.Consts.RESET_HARD\n# will discard the changes to file1\n# and unstage it\nnew_head = LibGit2.reset!(repo, head_oid, mode)\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.restore",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.restore",
    "category": "Function",
    "text": "restore(s::State, repo::GitRepo)\n\nReturn a repository repo to a previous State s, for example the HEAD of a branch before a merge attempt. s can be generated using the snapshot function.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.revcount",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.revcount",
    "category": "Function",
    "text": "LibGit2.revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)\n\nList the number of revisions between commit1 and commit2 (committish OIDs in string form). Since commit1 and commit2 may be on different branches, revcount performs a \"left-right\" revision list (and count), returning a tuple of Ints - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.\n\nEquivalent to git rev-list --left-right --count <commit1> <commit2>.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.set_remote_url",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.set_remote_url",
    "category": "Function",
    "text": "set_remote_url(repo::GitRepo, url::AbstractString; remote::AbstractString=\"origin\")\n\nSet the url for remote for the git repository repo. The default name of the remote is \"origin\".\n\nExamples\n\nrepo_path = joinpath(\"test_directory\", \"Example\")\nrepo = LibGit2.init(repo_path)\nurl1 = \"https://github.com/JuliaLang/Example.jl\"\nLibGit2.set_remote_url(repo, url1, remote=\"upstream\")\nurl2 = \"https://github.com/JuliaLang/Example2.jl\"\nLibGit2.set_remote_url(repo_path, url2, remote=\"upstream2\")\n\n\n\nset_remote_url(path::AbstractString, url::AbstractString; remote::AbstractString=\"origin\")\n\nSet the url for remote for the git repository located at path. The default name of the remote is \"origin\".\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.shortname",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.shortname",
    "category": "Function",
    "text": "LibGit2.shortname(ref::GitReference)\n\nReturns a shortened version of the name of ref that's \"human-readable\".\n\njulia> repo = LibGit2.GitRepo(path_to_repo);\n\njulia> branch_ref = LibGit2.head(repo);\n\njulia> LibGit2.name(branch_ref)\n\"refs/heads/master\"\n\njulia> LibGit2.shortname(branch_ref)\n\"master\"\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.snapshot",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.snapshot",
    "category": "Function",
    "text": "snapshot(repo::GitRepo) -> State\n\nTake a snapshot of the current state of the repository repo, storing the current HEAD, index, and any uncommitted work. The output State can be used later during a call to restore to return the repository to the snapshotted state.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.status",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.status",
    "category": "Function",
    "text": "LibGit2.status(repo::GitRepo, path::String)\n\nLookup the status of the file at path in the git repository repo. For instance, this can be used to check if the file at path has been modified and needs to be staged and committed.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.tag_create",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.tag_create",
    "category": "Function",
    "text": "LibGit2.tag_create(repo::GitRepo, tag::AbstractString, commit; kwargs...)\n\nCreate a new git tag tag (e.g. \"v0.5\") in the repository repo, at the commit commit.\n\nThe keyword arguments are:\n\nmsg::AbstractString=\"\": the message for the tag.\nforce::Bool=false: if true, existing references will be overwritten.\nsig::Signature=Signature(repo): the tagger's signature.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.tag_delete",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.tag_delete",
    "category": "Function",
    "text": "LibGit2.tag_delete(repo::GitRepo, tag::AbstractString)\n\nRemove the git tag tag from the repository repo.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.tag_list",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.tag_list",
    "category": "Function",
    "text": "LibGit2.tag_list(repo::GitRepo) -> Vector{String}\n\nGet a list of all tags in the git repository repo.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.target",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.target",
    "category": "Function",
    "text": "LibGit2.target(tag::GitTag)\n\nThe GitHash of the target object of tag.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.treewalk",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.treewalk",
    "category": "Function",
    "text": "Traverse the entries in a tree and its subtrees in post or pre order.\n\nFunction parameter should have following signature:\n\n(Cstring, Ptr{Void}, Ptr{Void}) -> Cint\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.upstream",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.upstream",
    "category": "Function",
    "text": "upstream(ref::GitReference) -> Nullable{GitReference}\n\nDetermine if the branch containing ref has a specified upstream branch.\n\nupstream returns a Nullable, which will be null if the requested branch does not have an upstream counterpart. If the upstream branch does exist, the Nullable contains a GitReference to the upstream branch.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.url",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.url",
    "category": "Function",
    "text": "url(rmt::GitRemote)\n\nGet the fetch URL of a remote git repository.\n\nExample\n\njulia> repo_url = \"https://github.com/JuliaLang/Example.jl\";\n\njulia> repo = LibGit2.init(mktempdir());\n\njulia> remote = LibGit2.GitRemote(repo, \"origin\", repo_url);\n\njulia> LibGit2.url(remote)\n\"https://github.com/JuliaLang/Example.jl\"\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.with",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.with",
    "category": "Function",
    "text": "Resource management helper function\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Base.LibGit2.workdir",
    "page": "Base.LibGit2",
    "title": "Base.LibGit2.workdir",
    "category": "Function",
    "text": "LibGit2.workdir(repo::GitRepo)\n\nThe location of the working directory of repo. This will throw an error for bare repositories.\n\nnote: Note\nThis will typically be the parent directory of gitdir(repo), but can be different in some cases: e.g. if either the core.worktree configuration variable or the GIT_WORK_TREE environment variable is set.\n\nSee also gitdir, path.\n\n\n\n"
},

{
    "location": "devdocs/libgit2.html#Functionality-1",
    "page": "Base.LibGit2",
    "title": "Functionality",
    "category": "section",
    "text": "Some of this documentation assumes some prior knowledge of the libgit2 API. For more information on some of the objects and methods referenced here, consult the upstream libgit2 API reference.Base.LibGit2.AbstractCredentials\nBase.LibGit2.Buffer\nBase.LibGit2.CachedCredentials\nBase.LibGit2.CheckoutOptions\nBase.LibGit2.CloneOptions\nBase.LibGit2.DiffDelta\nBase.LibGit2.DiffFile\nBase.LibGit2.DiffOptionsStruct\nBase.LibGit2.FetchHead\nBase.LibGit2.FetchOptions\nBase.LibGit2.GitBlob\nBase.LibGit2.GitCommit\nBase.LibGit2.GitHash\nBase.LibGit2.GitObject\nBase.LibGit2.GitRemote\nBase.LibGit2.GitRemoteAnon\nBase.LibGit2.GitRepo\nBase.LibGit2.GitRepoExt\nBase.LibGit2.GitShortHash\nBase.LibGit2.GitSignature\nBase.LibGit2.GitStatus\nBase.LibGit2.GitTag\nBase.LibGit2.GitTree\nBase.LibGit2.IndexEntry\nBase.LibGit2.IndexTime\nBase.LibGit2.MergeOptions\nBase.LibGit2.ProxyOptions\nBase.LibGit2.PushOptions\nBase.LibGit2.RebaseOperation\nBase.LibGit2.RebaseOptions\nBase.LibGit2.RemoteCallbacks\nBase.LibGit2.SSHCredentials\nBase.LibGit2.SignatureStruct\nBase.LibGit2.StatusEntry\nBase.LibGit2.StatusOptions\nBase.LibGit2.StrArrayStruct\nBase.LibGit2.TimeStruct\nBase.LibGit2.UserPasswordCredentials\nBase.LibGit2.add_fetch!\nBase.LibGit2.add_push!\nBase.LibGit2.addblob!\nBase.LibGit2.authors\nBase.LibGit2.branch\nBase.LibGit2.branch!\nBase.LibGit2.checkout!\nBase.LibGit2.checkused!\nBase.LibGit2.clone\nBase.LibGit2.commit\nBase.LibGit2.create_branch\nBase.LibGit2.credentials_callback\nBase.LibGit2.credentials_cb\nBase.LibGit2.default_signature\nBase.LibGit2.delete_branch\nBase.LibGit2.diff_files\nBase.LibGit2.fetch\nBase.LibGit2.fetch_refspecs\nBase.LibGit2.fetchhead_foreach_cb\nBase.LibGit2.ffmerge!\nBase.LibGit2.fullname\nBase.LibGit2.get_creds!\nBase.LibGit2.gitdir\nBase.LibGit2.head\nBase.LibGit2.head!\nBase.LibGit2.head_oid\nBase.LibGit2.headname\nBase.LibGit2.init\nBase.LibGit2.is_ancestor_of\nBase.LibGit2.isbinary\nBase.LibGit2.iscommit\nBase.LibGit2.isdiff\nBase.LibGit2.isdirty\nBase.LibGit2.isorphan\nBase.LibGit2.lookup_branch\nBase.LibGit2.mirror_callback\nBase.LibGit2.mirror_cb\nBase.LibGit2.name\nBase.LibGit2.need_update\nBase.LibGit2.objtype\nBase.LibGit2.path\nBase.LibGit2.peel\nBase.LibGit2.posixpath\nBase.LibGit2.push\nBase.LibGit2.push_refspecs\nBase.LibGit2.read_tree!\nBase.LibGit2.rebase!\nBase.LibGit2.ref_list\nBase.LibGit2.reftype\nBase.LibGit2.remotes\nBase.LibGit2.reset!\nBase.LibGit2.restore\nBase.LibGit2.revcount\nBase.LibGit2.set_remote_url\nBase.LibGit2.shortname\nBase.LibGit2.snapshot\nBase.LibGit2.status\nBase.LibGit2.tag_create\nBase.LibGit2.tag_delete\nBase.LibGit2.tag_list\nBase.LibGit2.target\nBase.LibGit2.treewalk\nBase.LibGit2.upstream\nBase.LibGit2.url\nBase.LibGit2.with\nBase.LibGit2.workdir"
},

{
    "location": "devdocs/require.html#",
    "page": "Module loading",
    "title": "Module loading",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/require.html#require-1",
    "page": "Module loading",
    "title": "Module loading",
    "category": "section",
    "text": "Base.require[@ref] is responsible for loading modules and it also manages the precompilation cache. It is the implementation of the import statement."
},

{
    "location": "devdocs/require.html#Experimental-features-1",
    "page": "Module loading",
    "title": "Experimental features",
    "category": "section",
    "text": "The features below are experimental and not part of the stable Julia API. Before building upon them inform yourself about the current thinking and whether they might change soon."
},

{
    "location": "devdocs/require.html#Module-loading-callbacks-1",
    "page": "Module loading",
    "title": "Module loading callbacks",
    "category": "section",
    "text": "It is possible to listen to the modules loaded by Base.require, by registering a callback.loaded_packages = Channel{Symbol}()\ncallback = (mod::Symbol) -> put!(loaded_packages, mod)\npush!(Base.package_callbacks, callback)Please note that the symbol given to the callback is a non-unique identifier and it is the responsibility of the callback provider to walk the module chain to determine the fully qualified name of the loaded binding.The callback below is an example of how to do that:# Get the fully-qualified name of a module.\nfunction module_fqn(name::Symbol)\n    fqn = Symbol[name]\n    mod = getfield(Main, name)\n    parent = Base.module_parent(mod)\n    while parent !== Main\n        push!(fqn, Base.module_name(parent))\n        parent = Base.module_parent(parent)\n    end\n    fqn = reverse!(fqn)\n    return join(fqn, '.')\nend"
},

{
    "location": "devdocs/backtraces.html#",
    "page": "Reporting and analyzing crashes (segfaults)",
    "title": "Reporting and analyzing crashes (segfaults)",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/backtraces.html#backtraces-1",
    "page": "Reporting and analyzing crashes (segfaults)",
    "title": "Reporting and analyzing crashes (segfaults)",
    "category": "section",
    "text": "So you managed to break Julia.  Congratulations!  Collected here are some general procedures you can undergo for common symptoms encountered when something goes awry.  Including the information from these debugging steps can greatly help the maintainers when tracking down a segfault or trying to figure out why your script is running slower than expected.If you've been directed to this page, find the symptom that best matches what you're experiencing and follow the instructions to generate the debugging information requested.  Table of symptoms:Segfaults during bootstrap (sysimg.jl)\nSegfaults when running a script\nErrors during Julia startup"
},

{
    "location": "devdocs/backtraces.html#dev-version-info-1",
    "page": "Reporting and analyzing crashes (segfaults)",
    "title": "Version/Environment info",
    "category": "section",
    "text": "No matter the error, we will always need to know what version of Julia you are running. When Julia first starts up, a header is printed out with a version number and date.  If your version is 0.2.0 or higher, please include the output of versioninfo() in any report you create:versioninfo()"
},

{
    "location": "devdocs/backtraces.html#segfaults-bootstrap-1",
    "page": "Reporting and analyzing crashes (segfaults)",
    "title": "Segfaults during bootstrap (sysimg.jl)",
    "category": "section",
    "text": "Segfaults toward the end of the make process of building Julia are a common symptom of something going wrong while Julia is preparsing the corpus of code in the base/ folder.  Many factors can contribute toward this process dying unexpectedly, however it is as often as not due to an error in the C-code portion of Julia, and as such must typically be debugged with a debug build inside of gdb.  Explicitly:Create a debug build of Julia:$ cd <julia_root>\n$ make debugNote that this process will likely fail with the same error as a normal make incantation, however this will create a debug executable that will offer gdb the debugging symbols needed to get accurate backtraces.  Next, manually run the bootstrap process inside of gdb:$ cd base/\n$ gdb -x ../contrib/debug_bootstrap.gdbThis will start gdb, attempt to run the bootstrap process using the debug build of Julia, and print out a backtrace if (when) it segfaults.  You may need to hit <enter> a few times to get the full backtrace.  Create a gist with the backtrace, the version info, and any other pertinent information you can think of and open a new issue on Github with a link to the gist."
},

{
    "location": "devdocs/backtraces.html#segfaults-script-1",
    "page": "Reporting and analyzing crashes (segfaults)",
    "title": "Segfaults when running a script",
    "category": "section",
    "text": "The procedure is very similar to Segfaults during bootstrap (sysimg.jl).  Create a debug build of Julia, and run your script inside of a debugged Julia process:$ cd <julia_root>\n$ make debug\n$ gdb --args usr/bin/julia-debug <path_to_your_script>Note that gdb will sit there, waiting for instructions.  Type r to run the process, and bt to generate a backtrace once it segfaults:(gdb) r\nStarting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl\n...\n(gdb) btCreate a gist with the backtrace, the version info, and any other pertinent information you can think of and open a new issue on Github with a link to the gist."
},

{
    "location": "devdocs/backtraces.html#errors-startup-1",
    "page": "Reporting and analyzing crashes (segfaults)",
    "title": "Errors during Julia startup",
    "category": "section",
    "text": "Occasionally errors occur during Julia's startup process (especially when using binary distributions, as opposed to compiling from source) such as the following:$ julia\nexec: error -5These errors typically indicate something is not getting loaded properly very early on in the bootup phase, and our best bet in determining what's going wrong is to use external tools to audit the disk activity of the julia process:On Linux, use strace:\n$ strace julia\nOn OSX, use dtruss:\n$ dtruss -f juliaCreate a gist with the strace/ dtruss ouput, the version info, and any other pertinent information and open a new issue on Github with a link to the gist."
},

{
    "location": "devdocs/backtraces.html#Glossary-1",
    "page": "Reporting and analyzing crashes (segfaults)",
    "title": "Glossary",
    "category": "section",
    "text": "A few terms have been used as shorthand in this guide:<julia_root> refers to the root directory of the Julia source tree; e.g. it should contain folders such as base, deps, src, test, etc....."
},

{
    "location": "devdocs/debuggingtips.html#",
    "page": "gdb debugging tips",
    "title": "gdb debugging tips",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/debuggingtips.html#debuggingtips-1",
    "page": "gdb debugging tips",
    "title": "gdb debugging tips",
    "category": "section",
    "text": ""
},

{
    "location": "devdocs/debuggingtips.html#Displaying-Julia-variables-1",
    "page": "gdb debugging tips",
    "title": "Displaying Julia variables",
    "category": "section",
    "text": "Within gdb, any jl_value_t* object obj can be displayed using(gdb) call jl_(obj)The object will be displayed in the julia session, not in the gdb session. This is a useful way to discover the types and values of objects being manipulated by Julia's C code.Similarly, if you're debugging some of Julia's internals (e.g., inference.jl), you can print obj usingccall(:jl_, Void, (Any,), obj)This is a good way to circumvent problems that arise from the order in which julia's output streams are initialized.Julia's flisp interpreter uses value_t objects; these can be displayed with call fl_print(fl_ctx, ios_stdout, obj)."
},

{
    "location": "devdocs/debuggingtips.html#Useful-Julia-variables-for-Inspecting-1",
    "page": "gdb debugging tips",
    "title": "Useful Julia variables for Inspecting",
    "category": "section",
    "text": "While the addresses of many variables, like singletons, can be be useful to print for many failures, there are a number of additional variables (see julia.h for a complete list) that are even more useful.(when in jl_apply_generic) mfunc and jl_uncompress_ast(mfunc->def, mfunc->code) :: for figuring out a bit about the call-stack\njl_lineno and jl_filename :: for figuring out what line in a test to go start debugging from (or figure out how far into a file has been parsed)\n$1 :: not really a variable, but still a useful shorthand for referring to the result of the last gdb command (such as print)\njl_options :: sometimes useful, since it lists all of the command line options that were successfully parsed\njl_uv_stderr :: because who doesn't like to be able to interact with stdio"
},

{
    "location": "devdocs/debuggingtips.html#Useful-Julia-functions-for-Inspecting-those-variables-1",
    "page": "gdb debugging tips",
    "title": "Useful Julia functions for Inspecting those variables",
    "category": "section",
    "text": "jl_gdblookup($rip) :: For looking up the current function and line. (use $eip on i686 platforms)\njlbacktrace() :: For dumping the current Julia backtrace stack to stderr. Only usable after record_backtrace() has been called.\njl_dump_llvm_value(Value*) :: For invoking Value->dump() in gdb, where it doesn't work natively. For example, f->linfo->functionObject, f->linfo->specFunctionObject, and to_function(f->linfo).\nType->dump() :: only works in lldb. Note: add something like ;1 to prevent lldb from printing its prompt over the output\njl_eval_string(\"expr\") :: for invoking side-effects to modify the current state or to lookup symbols\njl_typeof(jl_value_t*) :: for extracting the type tag of a Julia value (in gdb, call macro define jl_typeof jl_typeof first, or pick something short like ty for the first arg to define a shorthand)"
},

{
    "location": "devdocs/debuggingtips.html#Inserting-breakpoints-for-inspection-from-gdb-1",
    "page": "gdb debugging tips",
    "title": "Inserting breakpoints for inspection from gdb",
    "category": "section",
    "text": "In your gdb session, set a breakpoint in jl_breakpoint like so:(gdb) break jl_breakpointThen within your Julia code, insert a call to jl_breakpoint by addingccall(:jl_breakpoint, Void, (Any,), obj)where obj can be any variable or tuple you want to be accessible in the breakpoint.It's particularly helpful to back up to the jl_apply frame, from which you can display the arguments to a function using, e.g.,(gdb) call jl_(args[0])Another useful frame is to_function(jl_method_instance_t *li, bool cstyle). The jl_method_instance_t* argument is a struct with a reference to the final AST sent into the compiler. However, the AST at this point will usually be compressed; to view the AST, call jl_uncompress_ast and then pass the result to jl_:#2  0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584\n584          abort();\n(gdb) p jl_(jl_uncompress_ast(li, li->ast))"
},

{
    "location": "devdocs/debuggingtips.html#Inserting-breakpoints-upon-certain-conditions-1",
    "page": "gdb debugging tips",
    "title": "Inserting breakpoints upon certain conditions",
    "category": "section",
    "text": ""
},

{
    "location": "devdocs/debuggingtips.html#Loading-a-particular-file-1",
    "page": "gdb debugging tips",
    "title": "Loading a particular file",
    "category": "section",
    "text": "Let's say the file is sysimg.jl:(gdb) break jl_load if strcmp(fname, \"sysimg.jl\")==0"
},

{
    "location": "devdocs/debuggingtips.html#Calling-a-particular-method-1",
    "page": "gdb debugging tips",
    "title": "Calling a particular method",
    "category": "section",
    "text": "(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), \"method_to_break\")==0Since this function is used for every call, you will make everything 1000x slower if you do this."
},

{
    "location": "devdocs/debuggingtips.html#Dealing-with-signals-1",
    "page": "gdb debugging tips",
    "title": "Dealing with signals",
    "category": "section",
    "text": "Julia requires a few signal to function property. The profiler uses SIGUSR2 for sampling and the garbage collector uses SIGSEGV for threads synchronization. If you are debugging some code that uses the profiler or multiple threads, you may want to let the debugger ignore these signals since they can be triggered very often during normal operations. The command to do this in GDB is (replace SIGSEGV with SIGUSRS or other signals you want to ignore):(gdb) handle SIGSEGV noprint nostop passThe corresponding LLDB command is (after the process is started):(lldb) pro hand -p true -s false -n false SIGSEGVIf you are debugging a segfault with threaded code, you can set a breakpoint on jl_critical_error (sigdie_handler should also work on Linux and BSD) in order to only catch the actual segfault rather than the GC synchronization points."
},

{
    "location": "devdocs/debuggingtips.html#Debugging-during-Julia's-build-process-(bootstrap)-1",
    "page": "gdb debugging tips",
    "title": "Debugging during Julia's build process (bootstrap)",
    "category": "section",
    "text": "Errors that occur during make need special handling. Julia is built in two stages, constructing sys0 and sys.ji. To see what commands are running at the time of failure, use make VERBOSE=1.At the time of this writing, you can debug build errors during the sys0 phase from the base directory using:julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jlYou might need to delete all the files in usr/lib/julia/ to get this to work.You can debug the sys.ji phase using:julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jlBy default, any errors will cause Julia to exit, even under gdb. To catch an error \"in the act\", set a breakpoint in jl_error (there are several other useful spots, for specific kinds of failures, including: jl_too_few_args, jl_too_many_args, and jl_throw).Once an error is caught, a useful technique is to walk up the stack and examine the function by inspecting the related call to jl_apply. To take a real-world example:Breakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802\n802 {\n(gdb) p jl_(e)\nErrorException(\"auto_unbox: unable to determine argument type\")\n$2 = void\n(gdb) bt 10\n#0  jl_throw (e=0x7ffdf42de400) at task.c:802\n#1  0x00007ffff65412fe in jl_error (str=0x7ffde56be000 <_j_str267> \"auto_unbox:\n   unable to determine argument type\")\n   at builtins.c:39\n#2  0x00007ffde56bd01a in julia_convert_16886 ()\n#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\n...The most recent jl_apply is at frame #3, so we can go back there and look at the AST for the function julia_convert_16886. This is the uniqued name for some method of convert. f in this frame is a jl_function_t*, so we can look at the type signature, if any, from the specTypes field:(gdb) f 3\n#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281\n1281            return f->fptr((jl_value_t*)f, args, nargs);\n(gdb) p f->linfo->specTypes\n$4 = (jl_tupletype_t *) 0x7ffdf39b1030\n(gdb) p jl_( f->linfo->specTypes )\nTuple{Type{Float32}, Float64}           # <-- type signature for julia_convert_16886Then, we can look at the AST for this function:(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )\nExpr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any, 1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,\nExpr(:line, 90, :float.jl)::Any,\nExpr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any)::AnyFinally, and perhaps most usefully, we can force the function to be recompiled in order to step through the codegen process. To do this, clear the cached functionObject from the jl_lamdbda_info_t*:(gdb) p f->linfo->functionObject\n$8 = (void *) 0x1289d070\n(gdb) set f->linfo->functionObject = NULLThen, set a breakpoint somewhere useful (e.g. emit_function, emit_expr, emit_call, etc.), and run codegen:(gdb) p jl_compile(f)\n... # your breakpoint here"
},

{
    "location": "devdocs/debuggingtips.html#Debugging-precompilation-errors-1",
    "page": "gdb debugging tips",
    "title": "Debugging precompilation errors",
    "category": "section",
    "text": "Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint or catching failures in a precompile worker requires attaching a debugger to the worker. The easiest approach is to set the debugger watch for new process launches matching a given name. For example:(gdb) attach -w -n julia-debugor:(lldb) process attach -w -n julia-debugThen run a script/command to start precompilation. As described earlier, use conditional breakpoints in the parent process to catch specific file-loading events and narrow the debugging window. (some operating systems may require alternative approaches, such as following each fork from the parent process)"
},

{
    "location": "devdocs/debuggingtips.html#Mozilla's-Record-and-Replay-Framework-(rr)-1",
    "page": "gdb debugging tips",
    "title": "Mozilla's Record and Replay Framework (rr)",
    "category": "section",
    "text": "Julia now works out of the box with rr, the lightweight recording and deterministic debugging framework from Mozilla. This allows you to replay the trace of an execution deterministically.  The replayed execution's address spaces, register contents, syscall data etc are exactly the same in every run.A recent version of rr (3.1.0 or higher) is required."
},

{
    "location": "devdocs/valgrind.html#",
    "page": "Usando Valgrind con Julia",
    "title": "Usando Valgrind con Julia",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/valgrind.html#valgrind-1",
    "page": "Usando Valgrind con Julia",
    "title": "Usando Valgrind con Julia",
    "category": "section",
    "text": "Valgrind es una herramienta para deputación de memoria, deteccin de fallos de página y creación de perfiles. Esta sección describe cosas a tner en cuenta cuando se usa Valgrind para depurar cuestiones de memoria con Julia."
},

{
    "location": "devdocs/valgrind.html#Consideraciones-Generales-1",
    "page": "Usando Valgrind con Julia",
    "title": "Consideraciones Generales",
    "category": "section",
    "text": "Por defecto, Valgrind asume que no hay código automodificador en el programa que está ejecutando. Esta suposición trabaja bien en la mayoría de las instancias, pero falla miserablemente para un compilador JIT como julia. Por esta razón es crucial pasar --smc-check=all-non-file a valgrind, si no el código puede bloquearse o comportarse de forma inesperada (frecuentemente de una forma sutil).En algunos casos, para detectar mejor errores de memoria usando Valgrind puede ayudar compilar julia con los pools de memoria dehabilitados. El flag de tiempo de compilación MEMDEBUG desabilita los pools de memoria en Julia y el flag MEMDEBUG2 deshabilita los pools de memoria en FemtoLisp. Para construir julia con ambos flags, añada la siguiente línea a Make.user:CFLAGS = -DMEMDEBUG -DMEMDEBUG2Otra cosa a notar: si nuestros programa usa múltiples procesos workers, es probable que queramos que todos esos procesos worker se ejecuten bajo Valgrind, no sólo bajo el proceso padre. Para hacer esto, pasaremos --trace-children=yes a valgrind."
},

{
    "location": "devdocs/valgrind.html#Supresiones-1",
    "page": "Usando Valgrind con Julia",
    "title": "Supresiones",
    "category": "section",
    "text": "Valgrind tipicamente mostrará avisos falsos mientras se ejecuta. Para reducir el número de tales avisos, ayuda proporcionar un fichero supresiones a Valgrind. Un fichero supresiones de ejemplo se incluye en la distribución fuente de Julia en contrib/valgrind-julia.supp.El fichero de supresiones puede ser usado desde el directorio fuente julia/ de la siguiente manera:$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jlAny memory errors that are displayed should either be reported as bugs or contributed as additional suppressions.  Note that some versions of Valgrind are shipped with insufficient default suppressions, so that may be one thing to consider before submitting any bugs."
},

{
    "location": "devdocs/valgrind.html#Running-the-Julia-test-suite-under-Valgrind-1",
    "page": "Usando Valgrind con Julia",
    "title": "Running the Julia test suite under Valgrind",
    "category": "section",
    "text": "It is possible to run the entire Julia test suite under Valgrind, but it does take quite some time (typically several hours).  To do so, run the following command from the julia/test/ directory:valgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia.supp ../julia runtests.jl allIf you would like to see a report of \"definite\" memory leaks, pass the flags --leak-check=full --show-leak-kinds=definite to valgrind as well."
},

{
    "location": "devdocs/valgrind.html#Caveats-1",
    "page": "Usando Valgrind con Julia",
    "title": "Caveats",
    "category": "section",
    "text": "Valgrind currently does not support multiple rounding modes, so code that adjusts the rounding mode will behave differently when run under Valgrind.In general, if after setting --smc-check=all-non-file you find that your program behaves differently when run under Valgrind, it may help to pass --tool=none to valgrind as you investigate further.  This will enable the minimal Valgrind machinery but will also run much faster than when the full memory checker is enabled."
},

{
    "location": "devdocs/sanitizers.html#",
    "page": "Sanitizer support",
    "title": "Sanitizer support",
    "category": "page",
    "text": ""
},

{
    "location": "devdocs/sanitizers.html#sanitizers-1",
    "page": "Sanitizer support",
    "title": "Sanitizer support",
    "category": "section",
    "text": ""
},

{
    "location": "devdocs/sanitizers.html#General-considerations-1",
    "page": "Sanitizer support",
    "title": "General considerations",
    "category": "section",
    "text": "Using Clang's sanitizers obviously require you to use Clang (USECLANG=1), but there's another catch: most sanitizers require a run-time library, provided by the host compiler, while the instrumented code generated by Julia's JIT relies on functionality from that library. This implies that the LLVM version of your host compiler matches that of the LLVM library used within Julia.An easy solution is to have an dedicated build folder for providing a matching toolchain, by building with BUILD_LLVM_CLANG=1 and overriding LLVM_USE_CMAKE=1 (Autotool-based builds are incompatible with ASAN). You can then refer to this toolchain from another build folder by specifying USECLANG=1 while overriding the CC and CXX variables."
},

{
    "location": "devdocs/sanitizers.html#Address-Sanitizer-(ASAN)-1",
    "page": "Sanitizer support",
    "title": "Address Sanitizer (ASAN)",
    "category": "section",
    "text": "For detecting or debugging memory bugs, you can use Clang's address sanitizer (ASAN). By compiling with SANITIZE=1 you enable ASAN for the Julia compiler and its generated code. In addition, you can specify LLVM_SANITIZE=1 to sanitize the LLVM library as well. Note that these options incur a high performance and memory cost. For example, using ASAN for Julia and LLVM makes testall1 takes 8-10 times as long while using 20 times as much memory (this can be reduced to respectively a factor of 3 and 4 by using the options described below).By default, Julia sets the allow_user_segv_handler=1 ASAN flag, which is required for signal delivery to work properly. You can define other options using the ASAN_OPTIONS environment flag, in which case you'll need to repeat the default option mentioned before. For example, memory usage can be reduced by specifying fast_unwind_on_malloc=0 and malloc_context_size=2, at the cost of backtrace accuracy. For now, Julia also sets detect_leaks=0, but this should be removed in the future."
},

{
    "location": "devdocs/sanitizers.html#Memory-Sanitizer-(MSAN)-1",
    "page": "Sanitizer support",
    "title": "Memory Sanitizer (MSAN)",
    "category": "section",
    "text": "For detecting use of uninitialized memory, you can use Clang's memory sanitizer (MSAN) by compiling with SANITIZE_MEMORY=1."
},

]}
