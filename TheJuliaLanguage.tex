\documentclass{memoir}

\usepackage{./documenter}
\usepackage{./custom}

\title{The Julia Language}
\author{The Julia Project}

\begin{document}

\frontmatter
\maketitle
\tableofcontents

\mainmatter



\part{Home}


\hypertarget{12349185756005454033}{}


\part{Julia Documentation}



\hypertarget{2114739140119154945}{}


\chapter{Manual}



\begin{itemize}
\item \hyperlink{3498245216777255645}{Introducción}


\item \hyperlink{15293760641260152025}{Empezando}


\item \hyperlink{15778663368769739431}{Variables}


\item \hyperlink{17453309092420764607}{Números Enteros y en Punto Flotante}


\item \hyperlink{16655087771805204817}{Operaciones Matemáticas y Funciones Elementales}


\item \hyperlink{57238021523210895}{Números Complejos y Racionales}


\item \hyperlink{3772396547767597421}{Cadenas}


\item \hyperlink{11836327794581856778}{Functions}


\item \hyperlink{8710711813610225279}{Control Flow}


\item \hyperlink{14993622729045334657}{Scope of Variables}


\item \hyperlink{2141690262982725665}{Types}


\item \hyperlink{15216268953652766477}{Methods}


\item \hyperlink{17317810227993044854}{Constructors}


\item \hyperlink{10686378388163930476}{Conversion and Promotion}


\item \hyperlink{6589646210931807616}{Interfaces}


\item \hyperlink{10438697863683890874}{Modules}


\item \hyperlink{12287408952024800641}{Documentation}


\item \hyperlink{15444528597476882531}{Metaprogramming}


\item \hyperlink{12380164357355707963}{Multi-dimensional Arrays}


\item \hyperlink{11547352483373884762}{Linear Algebra}


\item \hyperlink{12120385195625176605}{Networking and Streams}


\item \hyperlink{3649475918943763834}{Parallel Computing}


\item \hyperlink{14708268282391318496}{Date and DateTime}


\item \hyperlink{11862922961978750349}{Running External Programs}


\item \hyperlink{17572913146419880234}{Calling C and Fortran Code}


\item \hyperlink{4478407192401635368}{Handling Operating System Variation}


\item \hyperlink{1581416507643810205}{Environment Variables}


\item \hyperlink{9220662049678686366}{Interacting With Julia}


\item \hyperlink{7688715278401899796}{Embedding Julia}


\item \hyperlink{9952244917530713055}{Packages}


\item \hyperlink{13874102823603666739}{Profiling}


\item \hyperlink{12400320882474083416}{Stack Traces}


\item \hyperlink{3908315974291496321}{Performance Tips}


\item \hyperlink{14117620934191882930}{Workflow Tips}


\item \hyperlink{17403906501138262503}{Style Guide}


\item \hyperlink{2735091372912754285}{Frequently Asked Questions}


\item \hyperlink{16083606765476288441}{Noteworthy Differences from other Languages}


\item \hyperlink{7696893994298815226}{Unicode Input}

\end{itemize}


\hypertarget{17926080325083127169}{}


\chapter{Standard Library}



\begin{itemize}
\item \hyperlink{4709349624826687157}{Essentials}


\item \hyperlink{4056407506084571511}{Collections and Data Structures}


\item \hyperlink{8551667013795262933}{Mathematics}


\item \hyperlink{856545484690558276}{Numbers}


\item \hyperlink{7104946044181754749}{Strings}


\item \hyperlink{14629781252390713372}{Arrays}


\item \hyperlink{10924396624761136101}{Tasks and Parallel Computing}


\item \hyperlink{2892037563719910727}{Linear Algebra}


\item \hyperlink{4380185033557519432}{Constants}


\item \hyperlink{2712977310167057511}{Filesystem}


\item \hyperlink{4334683019621329817}{I/O and Network}


\item \hyperlink{15930311186113323480}{Punctuation}


\item \hyperlink{7484837696332142133}{Sorting and Related Functions}


\item \hyperlink{4492327721069002863}{Package Manager Functions}


\item \hyperlink{11995623453970199783}{Dates and Time}


\item \hyperlink{2381796939793458375}{Iteration utilities}


\item \hyperlink{6239948001455396291}{Unit Testing}


\item \hyperlink{6196042923468033404}{C Interface}


\item \hyperlink{346568585257401697}{C Standard Library}


\item \hyperlink{13427841325685013289}{Dynamic Linker}


\item \hyperlink{13446659783021526147}{Profiling}


\item \hyperlink{5903382401809839120}{StackTraces}


\item \hyperlink{13586267588072234536}{SIMD Support}

\end{itemize}


\hypertarget{14908561293801473695}{}


\chapter{Developer Documentation}



\begin{itemize}
\item \hyperlink{6456620051738632536}{Reflection and introspection}


\item Documentation of Julia{\textquotesingle}s Internals

\begin{itemize}
\item \hyperlink{1567551262556259173}{Initialization of the Julia runtime}


\item \hyperlink{92289363194562983}{Julia ASTs}


\item \hyperlink{7872161424372847354}{More about types}


\item \hyperlink{11666441878855849549}{Memory layout of Julia Objects}


\item \hyperlink{2565512592221324751}{Eval of Julia code}


\item \hyperlink{3417049897160160290}{Calling Conventions}


\item \hyperlink{2265182675689203812}{High-level Overview of the Native-Code Generation Process}


\item \hyperlink{8538207326577378342}{Julia Functions}


\item \hyperlink{10117343183210038440}{Base.Cartesian}


\item \hyperlink{11367980138716686905}{Talking to the compiler (the \texttt{:meta} mechanism)}


\item \hyperlink{2417900207528599820}{SubArrays}


\item \hyperlink{4435767086673027446}{System Image Building}


\item \hyperlink{15676237889045834434}{Working with LLVM}


\item \hyperlink{15255383527079538908}{printf() and stdio in the Julia runtime}


\item \hyperlink{15203641602433735164}{Bounds checking}


\item \hyperlink{16029610522337323518}{Proper maintenance and care of multi-threading locks}


\item \hyperlink{12792533311031776054}{Arrays with custom indices}


\item \hyperlink{8108834884169454679}{Base.LibGit2}


\item \hyperlink{4726389115529362401}{Module loading}

\end{itemize}

\item Developing/debugging Julia{\textquotesingle}s C code

\begin{itemize}
\item \hyperlink{2099627245904836713}{Reporting and analyzing crashes (segfaults)}


\item \hyperlink{10298426124440583682}{gdb debugging tips}


\item \hyperlink{13430054895263354316}{Using Valgrind with Julia}


\item \hyperlink{7492492303482218484}{Sanitizer support}

\end{itemize}
\end{itemize}


\part{Manual}


\hypertarget{3498245216777255645}{}


\chapter{Introducción}



La computación científica ha requerido tradicionalmente el máximo rendimiento, aunque los expertos de los distintos dominios se hayan movido en gran parte a los lenguajes dinámicos, más lentos, para el trabajo diario. Creemos que hay muchas buenas razones para preferir lenguajes dinámicos para estas aplicaciones, y no esperamos que su uso disminuya. Afortunadamente, el diseño de lenguajes y las técnicas de compilación modernos permiten casi eliminar el compromiso del rendimiento y proporcionar un solo entorno suficientemente productivo para la creación de prototipos y suficientemente eficiente para implementar aplicaciones de alto rendimiento. El lenguaje de programación de Julia cumple este papel: es un lenguaje dinámico y flexible, apropiado para la computación científica y numérica, con un rendimiento comparable al de los lenguajes tradicionales de tipo estático.



Debido a que el compilador de Julia es diferente de los intérpretes utilizados para lenguajes como Python o R, podría parecer al principio que el rendimiento de Julia no es intuitivo. Si encuentra que algo es lento, le recomendamos que lea la sección \hyperlink{3908315974291496321}{Consejos de Rendimiento} antes de intentar otra cosa. Una vez que entienda cómo funciona Julia, será fácil escribir código casi tan rápido como el código C.



Julia ofrece tipado opcional, despacho múltiple, y buen desempeño, logrado usando inferencia de tipos y \href{https://en.wikipedia.org/wiki/Just-in-time\_compilation}{compilación \emph{just-in-time} (JIT)}, implementada usando \href{https://en.wikipedia.org/wiki/Low\_Level\_Virtual\_Machine}{LLVM}. Es multi-paradigma, combinando características de programación imperativa, funcional y orientada a objetos. Julia proporciona facilidad y expresividad para la computación numérica de alto nivel, de la misma manera que idiomas como R, MATLAB y Python, pero también soporta la programación general. Para conseguirlo, Julia se basa en el linaje de los lenguajes de programación matemáticos, pero también toma prestado mucho de los lenguajes dinámicos populares, incluyendo \href{https://en.wikipedia.org/wiki/Lisp\_(programming\_language)}{Lisp}, \href{https://en.wikipedia.org/wiki/Perl\_(programming\_language)}{Perl}, \href{https://en.wikipedia.org/wiki/Python\_(programming\_language)}{Python}, \href{https://en.wikipedia.org/wiki/Lua\_(programming\_language)}{Lua}, y \href{https://en.wikipedia.org/wiki/Ruby\_(programming\_language)}{Ruby}.



Las diferencias más significativas de Julia de los lenguajes dinámicos típicos son:



\begin{itemize}
\item El lenguaje básico impone muy poco; La biblioteca estándar se ha escrito en el propio Julia, incluyendo operaciones primitivas como la aritmética entera.


\item Un lenguaje enriquecido de tipos para construir y describir objetos, que también se puede utilizar opcionalmente para hacer declaraciones de tipo.


\item La capacidad de definir el comportamiento de la función a través de muchas combinaciones de tipos de argumentos mediante el \href{https://en.wikipedia.org/wiki/Multiple\_dispatch}{despacho múltiple}.


\item Generación automática de código eficiente y especializado para diferentes tipos de argumentos.


\item Buen rendimiento, aproximándose al de los lenguajes compilados estáticamente como C.

\end{itemize}


Aunque a veces se dice de los lenguajes dinámicos que son lenguajes {\textquotedbl}sin tipo{\textquotedbl}, ésto no es cierto en absoluto: cada objeto, ya sea primitivo o definido por el usuario, tiene un tipo. La falta de declaraciones de tipos en la mayoría de los lenguajes dinámicos, sin embargo, significa que uno no puede instruir al compilador acerca de los tipos de valores y, a menudo, no puede hablar explícitamente de tipos en absoluto. En lenguajes estáticos, por otro lado, aunque uno puede -y normalmente debe- anotar tipos para el compilador, los tipos sólo existen en tiempo de compilación y no pueden ser manipulados o expresados en tiempo de ejecución. En Julia, los tipos son objetos en tiempo de ejecución y también se pueden utilizar para transmitir información al compilador.



Aunque el programador casual no necesita usar explícitamente los tipos o el despacho múltiple, ellas son las características centrales unificadoras de Julia: las funciones se definen en diferentes combinaciones de tipos de argumentos y se aplican despachando a la definición concordante más específica. Este modelo se ajusta bien a la programación matemática, donde no es natural que el primer argumento {\textquotedbl}posea{\textquotedbl} una operación como en la programación orientada a objetos tradicional. Los operadores son sólo funciones con notación especial - para ampliar la adición a nuevos tipos de datos definidos por el usuario, se definen nuevos métodos para la función +. El código existente se aplica sin problemas a los nuevos tipos de datos.



En parte debido a la inferencia de tipo en tiempo de ejecución (aumentada por anotaciones de tipos opcionales), y en parte debido a enfoque muy basado en el rendimiento desde el inicio del proyecto, la eficiencia computacional de Julia supera la de otros lenguajes dinámicos e incluso rivaliza con la de lenguajes de compilación estática. Para los problemas numéricos a gran escala, la velocidad siempre ha sido, continúa siendo, y probablemente siempre será crucial: la cantidad de datos procesados se ha mantenido fácilmente al ritmo de la Ley de Moore durante las últimas décadas.



Julia tiene como objetivo crear una combinación sin precedentes de facilidad de uso, potencia y eficiencia en un solo lenguaje de programación. Además de lo anterior, algunas ventajas de Julia sobre sistemas comparables son:



\begin{itemize}
\item Libre y de código abierto (\href{https://github.com/JuliaLang/julia/blob/master/LICENSE.md}{con licencia MIT})


\item Los tipos definidos por el usuario son tan rápidos y compactos como los predefinidos.


\item No hay necesidad de vectorizar código para el rendimiento; el código devectorizado es rápido


\item Diseñado para el paralelismo y la computación distribuida.


\item Hilos {\textquotedbl}verdes{\textquotedbl} de peso ligero (\href{https://en.wikipedia.org/wiki/Coroutine}{coroutinas}).


\item Sistema de tipos discreto pero potente.


\item Conversiones y promociones elegantes y extensibles para números y otros tipos.


\item Soporte eficiente para \href{https://en.wikipedia.org/wiki/Unicode}{Unicode}, incluyendo pero no 

\end{itemize}


limitado a \href{https://en.wikipedia.org/wiki/UTF-8}{UTF-8}



\begin{itemize}
\item Llamada a las funciones C directamente (no se necesitan envolturas o API especiales).


\item Poderosas capacidades tipo shell para administrar otros procesos.


\item Macros similares a Lisp y otras instalaciones de metaprogramación.

\end{itemize}


\hypertarget{15293760641260152025}{}


\chapter{Empezando}



La instalación de Julia es sencilla, ya sea utilizando binarios precompilados o compilando desde la fuente. Descargue e instale Julia siguiendo las instrucciones disponibles en \href{https://julialang.org/downloads/}{https://julialang.org/downloads/}.



La forma más fácil de aprender y experimentar con Julia es iniciando una sesión interactiva (también conocida como \emph{read-eval-print loop} o {\textquotedbl}REPL{\textquotedbl}) haciendo doble clic en el ejecutable de Julia o ejecutando \texttt{julia} desde la línea de mandatos:




\begin{lstlisting}
$ julia
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org
   _ _   _| |_  __ _   |  Type "?help" for help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 0.5.0-dev+2440 (2016-02-01 02:22 UTC)
 _/ |\__'_|_|_|\__'_|  |  Commit 2bb94d6 (11 days old master)
|__/                   |  x86_64-apple-darwin13.1.0

julia> 1 + 2
3

julia> ans
3
\end{lstlisting}



Para salir de la sesión interactiva, escriba \texttt{{\textasciicircum}D} (la tecla de control junto con la tecla \texttt{D}) o escriba \texttt{quit()}. Cuando se ejecuta en modo interactivo, Julia muestra un banner y solicita al usuario la entrada.  Una vez que el usuario ha introducido una expresión completa, como \texttt{1 + 2}, y pulsa \emph{Enter}, la sesión  interactiva evalúa la expresión y muestra su valor. Si se introduce una expresión en una sesión interactiva  con un punto y coma al final, no se muestra su valor. La variable \texttt{ans} está enlazada al valor de la última  expresión evaluada, sea mostrada o no. La variable \texttt{ans} sólo está enlazada a las sesiones interactivas,  no cuando el código Julia se ejecuta de otras maneras.



Para evaluar expresiones escritas en un archivo de origen \texttt{file.jl}, escriba \texttt{include ({\textquotedbl}file.jl{\textquotedbl})}.



Para ejecutar código en un archivo de forma no interactiva, puede darlo como el primer argumento al mandato Julia:




\begin{lstlisting}
$ julia script.jl arg1 arg2...
\end{lstlisting}



Como indica el ejemplo, los siguientes argumentos de línea de mandatos de Julia se toman como argumentos de  línea de mandatos al programa \texttt{script.jl} del programa, pasados a través de la constante global \texttt{ARGS}. El  nombre del propio \emph{script} se pasa como la variable global \texttt{PROGRAM\_FILE}. Tenga en cuenta que \texttt{ARGS}  también se establece cuando se da el código de script usando la opción \texttt{-e} en la línea de órdenes (vea  la salida de ayuda de \texttt{julia} más abajo) pero \texttt{PROGRAM\_FILE} estará vacío. Por ejemplo, para imprimir  los argumentos que se le dan a un script, puede hacer esto:




\begin{lstlisting}
$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar

foo
bar
\end{lstlisting}



O puede poner ese código en un script y ejecutarlo:




\begin{lstlisting}
$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl
$ julia script.jl foo bar
script.jl
foo
bar
\end{lstlisting}



El delimitador \texttt{--} puede usarse para separar argumentos en línea de mandatos al fichero del  \emph{script} a los argumentos de Julia:




\begin{lstlisting}
$ julia --color=yes -O -- foo.jl arg1 arg2..
\end{lstlisting}



Julia se puede iniciar en modo paralelo con las opciones \texttt{-p} o \texttt{--machinefile}. \texttt{-p n} pondrá en marcha un \texttt{n} procesos \emph{worker} adicionales, mientras que \texttt{--machinefile archivo} iniciará un \emph{worker} para cada línea en el archivo de archivo. Las máquinas definidas en el archivo deben ser accesibles a través de un login ssh sin contraseña, con Julia instalado en la misma ubicación que el \emph{host} actual. Cada definición de máquina toma la forma \texttt{[count *] [user @] host [: port] [bind\_addr [: port]]}. El valor por defecto de \texttt{user} es el usuario actual, y el de \texttt{port} el puerto ssh estándar. Las variables opcionales \texttt{bind\_to} \texttt{bind\_addr} \texttt{[: port]} especifican la dirección IP y el puerto que otros \emph{workers} deberían usar para conectarse a este \emph{worker}.



Si tiene código que desea ejecutar cada vez que Julia se inicia, puede ponerlo en \texttt{{\textasciitilde}/.juliarc.jl}:




\begin{lstlisting}
$ echo 'println("Greetings! 你好! 안녕하세요?")' > ~/.juliarc.jl
$ julia
Greetings! 你好! 안녕하세요?

...
\end{lstlisting}



Hay varias formas de ejecutar el código Julia y proporcionar opciones, similares a las disponibles para los programas \texttt{perl} y `ruby:




\begin{lstlisting}
julia [switches] -- [programfile] [args...]
 -v, --version             Display version information
 -h, --help                Print this message

 -J, --sysimage <file>     Start up with the given system image file
 --precompiled={yes|no}    Use precompiled code from system image if available
 --compilecache={yes|no}   Enable/disable incremental precompilation of modules
 -H, --home <dir>          Set location of `julia` executable
 --startup-file={yes|no}   Load ~/.juliarc.jl
 --handle-signals={yes|no} Enable or disable Julia's default signal handlers

 -e, --eval <expr>         Evaluate <expr>
 -E, --print <expr>        Evaluate and show <expr>
 -L, --load <file>         Load <file> immediately on all processors

 -p, --procs {N|auto}      Integer value N launches N additional local worker processes
                           "auto" launches as many workers as the number of local cores
 --machinefile <file>      Run processes on hosts listed in <file>

 -i                        Interactive mode; REPL runs and isinteractive() is true
 -q, --quiet               Quiet startup (no banner)
 --color={yes|no}          Enable or disable color text
 --history-file={yes|no}   Load or save history

 --compile={yes|no|all|min}Enable or disable JIT compiler, or request exhaustive compilation
 -C, --cpu-target <target> Limit usage of cpu features up to <target>
 -O, --optimize={0,1,2,3}  Set the optimization level (default is 2 if unspecified or 3 if specified as -O)
 -g, -g <level>            Enable / Set the level of debug info generation (default is 1 if unspecified or 2 if specified as -g)
 --inline={yes|no}         Control whether inlining is permitted (overrides functions declared as @inline)
 --check-bounds={yes|no}   Emit bounds checks always or never (ignoring declarations)
 --math-mode={ieee,fast}   Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)

 --depwarn={yes|no|error}  Enable or disable syntax and method deprecation warnings ("error" turns warnings into errors)

 --output-o name           Generate an object file (including system image data)
 --output-ji name          Generate a system image data file (.ji)
 --output-bc name          Generate LLVM bitcode (.bc)
 --output-incremental=no   Generate an incremental output file (rather than complete)

 --code-coverage={none|user|all}, --code-coverage
                           Count executions of source lines (omitting setting is equivalent to "user")
 --track-allocation={none|user|all}, --track-allocation
                           Count bytes allocated by each source line
\end{lstlisting}



\hypertarget{106098538461341329}{}


\section{Resources}



Además de este manual, hay otros recursos que pueden ayudar a los usuarios nuevos cuanto empiezan con Julia:



\begin{itemize}
\item \href{http://math.mit.edu/{\textasciitilde}stevenj/Julia-cheatsheet.pdf}{Julia and IJulia cheatsheet}


\item \href{https://learnxinyminutes.com/docs/julia/}{Learn Julia in a few minutes}


\item \href{https://github.com/chrisvoncsefalvay/learn-julia-the-hard-way}{Learn Julia the Hard Way}


\item \href{http://samuelcolvin.github.io/JuliaByExample/}{Julia by Example}


\item \href{https://github.com/dpsanders/hands\_on\_julia}{Hands-on Julia}


\item \href{http://homerreid.dyndns.org/teaching/18.330/JuliaProgramming.shtml}{Tutorial for Homer Reid{\textquotesingle}s numerical analysis class}


\item \href{https://raw.githubusercontent.com/ViralBShah/julia-presentations/master/Fifth-Elephant-2013/Fifth-Elephant-2013.pdf}{An introductory presentation}


\item \href{https://julialang.org/blog/2013/03/julia-tutorial-MIT}{Videos from the Julia tutorial at MIT}


\item \href{https://www.youtube.com/user/JuliaLanguage/playlists}{YouTube videos from the JuliaCons}

\end{itemize}


\hypertarget{15778663368769739431}{}


\chapter{Variables}



Una variable en Julia es un nombre asociado a un valor. Esto es útil cuando pretendemos almacenar un valor (como el que obtenemos después de un cálculo) para un uso posterior. Por ejemplo:




\begin{minted}{jlcon}
# Assign the value 10 to the variable x
julia> x = 10
10

# Doing math with x's value
julia> x + 1
11

# Reassign x's value
julia> x = 1 + 1
2

# You can assign values of other types, like strings of text
julia> x = "Hello World!"
"Hello World!"
\end{minted}



Julia proporciona un sistema muy flexible para nombrar las variables. Los nombres de variable son sensibles a las mayúsculas, y no tienen significado semántico (es decir, que el lenguaje no trata de modo distinto  a las variables basándose en sus nombres).




\begin{minted}{jlcon}
julia> x = 1.0
1.0

julia> y = -3
-3

julia> Z = "My string"
"My string"

julia> customary_phrase = "Hello world!"
"Hello world!"

julia> UniversalDeclarationOfHumanRightsStart = "人人生而自由，在尊严和权利上一律平等。"
"人人生而自由，在尊严和权利上一律平等。"
\end{minted}



Los nombres Unicode (usando codificación UTF-8) están permitidos:




\begin{minted}{jlcon}
julia> δ = 0.00001
1.0e-5

julia> 안녕하세요 = "Hello"
"Hello"
\end{minted}



En el REPL y otros entornos de edición Julia se pueden introducir símbolos matemáticos Unicode usando la notación de \emph{Latex} precedido de backslash y seguido de un tabulador. Por ejemplo, podemos crear el nombre de variable \texttt{δ} tecleando \texttt{{\textbackslash}delta}-\emph{tab}, o incluso el nombre \texttt{α̂₂} tecleando \texttt{{\textbackslash}alpha}-\emph{tab}-\texttt{{\textbackslash}hat}- \emph{tab}-\texttt{{\textbackslash}\_2}-\emph{tab}. (Si encuentras un símbolo en algun sitio, como por ejemplo en el código de alguien, y no sabes como escribirlo, el REPL te ayudará: solamente teclea \texttt{?} y luego pega el símbolo.)



Julia también permite redefinir constantes predefinidas su fuera necesario:




\begin{minted}{jlcon}
julia> pi
π = 3.1415926535897...

julia> pi = 3
WARNING: imported binding for pi overwritten in module Main
3

julia> pi
3

julia> sqrt(100)
10.0

julia> sqrt = 4
WARNING: imported binding for sqrt overwritten in module Main
4
\end{minted}



Sin embargo, esto no se recomienta para evitar una potencial confusión.



\hypertarget{16226997356321536460}{}


\section{Nombres de Variables Permitidos}



Los nombres de variable deben comenzar con una letra (\texttt{A}-\texttt{Z} o \texttt{a}-\texttt{z}), símblo de subrayado, o un subconjunto de puntos Unicode mayores que \texttt{00A0}. En particular, se permiten las \href{http://www.fileformat.info/info/unicode/category/index.htm}{categorías de caracteres Unicode} Lu/Ll/Lt/Lm/Lo/Nl (letras), Sc/So (monedas y otros símbolos), y otros pocos caracteres (por ejemplo, un subconjunto de los símbolos matemáticos Sm). Entre los caracteres subsecuentes se pueden también incluir \texttt{!} y los dígitos (\texttt{0}-\texttt{9} y otros caracteres en las categorías Nd/No), así como otros puntos de código Unicode: diacríticas y otras marcas de modificación (categorías Mn/Mc/Me/Sk), algunos conectores de puntuación (category Pc),  primos, y otros cuantos caracteres.



Los operadores como \texttt{+} son también identificadores válidos, pero son analizados sintácticamente de un modo especial. En algunos contextos, los operadores pueden ser usados justo como variables; por ejemplo \texttt{(+)} se refiere a la función de suma, y \texttt{(+) = f} la reasignará. La mayoría de los operadores infijos Unicode (en la categoría Sm), tal como \texttt{⊕}, son analizados como operadores infijos y están disponibles para métodos definidos por el usuario (por ejemplo, podemos usar \texttt{const ⊗ = kron} para definir \texttt{⊗} como un operador infijo producto de Kronecker).



Los únicos nombres específicamente prohibidos para nombres de variables son los nombres de las instrucciones predefinidas:




\begin{minted}{jlcon}
julia> else = false
ERROR: syntax: unexpected "else"

julia> try = "No"
ERROR: syntax: unexpected "="
\end{minted}



Algunos caracteres Unicode son considerados equivalentes en identificadores. Las distintas formas de introducir caracteres que combinan en Unicode (por ejemplo, acentos) son tratadas como equivalentes (específicamente los identificadores Julia son normalizados NFC). Los caracteres Unicode \texttt{ɛ} (U+025B: Latin small letter open e) y \texttt{µ} (U+00B5: micro sign) son tratados como las letras griegas correspondientes, debido que las primeras son más fácilmente accesibles via alguos métodos de entrada.



\hypertarget{3934387976884252479}{}


\section{Convenciones de Estilo}



Aunque Julia impone pocas restricciones a los nombres válidos, se ha vuelto útil adoptar las  siguientes convenciones:



\begin{itemize}
\item Los nombres de variable van en minúsculas.


\item La separación enre palabras puede indicarse mediante el símbolo de guión bajo, aunque se desaconseja  su uso a menos que los símbolos sean difíciles de leer.


\item Los nombres de tipos y módulos comienzan con mayúscula y la separación entre palabras se representa  con el formato \emph{camel case}.


\item Los nombres de funciones y macros van en minúscula, sin símbolos de guión bajo.


\item Las funciones que escriben en sus argumentos tienen nombres que finalizan con el símbolo de admiración \texttt{!}. Estas suelen ser llamadas funciones {\textquotedbl}mutadoras{\textquotedbl} o funciones {\textquotedbl}\emph{in-place}{\textquotedbl} debido a que pretenden producir 

\end{itemize}


 cambios en sus argumentos después de que la función sea invocada, no solo devolver un valor.



Para más información sobre convenciones de estilo, ver la \hyperlink{17403906501138262503}{Guía de Estilo}.



\hypertarget{17453309092420764607}{}


\chapter{Números enteros y en punto flotante}



Los valores enteros y punto flotante son los bloques constructivos básicos de la aritmética y la computación. Las representaciones predefinidas para estos valores se denominan \emph{tipos primitivos}, mientras que las reprentaciones de números enteros y en punto flotante como valores inmediatos en código se conocen como \emph{literales numéricos}. Por ejemplo, \texttt{1} es un literal entero, mientras que \texttt{1.0} es un literal en punto flotante; sus representaciones binarias en memoria como objetos son los tipos primitivos.



Julia proporciona un amplio rango de tipos primitivos numéricos, y un complemento complemento de operadores aritméticos y de bits así como funciones matemáticas estándar definidas sobre ellos. Los operadores establecen una correspondencia enre los tipos numéricos y las operaciones que son soportadas de forma nativa sobre los ordenadores modernos, permitiendo a Julia sacar plena ventaja de los recursos computacionales. Además, Julia proporciona soporte software para \emph{aritmética de precisión arbitraria} que puede manejar operaciones sobre valores numéricos que no puede ser representada de forma efectiva en representaciones hardware nativas, pero al coste de un rendimiento relativamente menor.



Los tipos primitivos de Julia son los siguientes:



\begin{itemize}
\item \textbf{Tipos enteros:}

\end{itemize}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
Tipo             & Signo? & Número de bits & Valor más pequeño & Valor más grande \\
\hline
\hyperlink{5857518405103968275}{\texttt{Int8}} & ✓ & 8 & -2{\textasciicircum}7 & 2{\textasciicircum}7 - 1 \\
\hline
\hyperlink{6609065134969660118}{\texttt{UInt8}} &   & 8 & 0 & 2{\textasciicircum}8 - 1 \\
\hline
\hyperlink{6667287249103968645}{\texttt{Int16}} & ✓ & 16 & -2{\textasciicircum}15 & 2{\textasciicircum}15 - 1 \\
\hline
\hyperlink{7018610346698168012}{\texttt{UInt16}} &   & 16 & 0 & 2{\textasciicircum}16 - 1 \\
\hline
\hyperlink{10103694114785108551}{\texttt{Int32}} & ✓ & 32 & -2{\textasciicircum}31 & 2{\textasciicircum}31 - 1 \\
\hline
\hyperlink{8690996847580776341}{\texttt{UInt32}} &   & 32 & 0 & 2{\textasciicircum}32 - 1 \\
\hline
\hyperlink{7720564657383125058}{\texttt{Int64}} & ✓ & 64 & -2{\textasciicircum}63 & 2{\textasciicircum}63 - 1 \\
\hline
\hyperlink{5500998675195555601}{\texttt{UInt64}} &   & 64 & 0 & 2{\textasciicircum}64 - 1 \\
\hline
\hyperlink{8012327724714767060}{\texttt{Int128}} & ✓ & 128 & -2{\textasciicircum}127 & 2{\textasciicircum}127 - 1 \\
\hline
\hyperlink{14811222188335428522}{\texttt{UInt128}} &   & 128 & 0 & 2{\textasciicircum}128 - 1 \\
\hline
\hyperlink{46725311238864537}{\texttt{Bool}} & N/A & 8 & \texttt{false} (0) & \texttt{true} (1) \\
\hline
\end{tabulary}

\end{table}



\begin{itemize}
\item \textbf{Tipos en punto flotante:}

\end{itemize}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Tipo             & Precisión                                                                       & Número de bits \\
\hline
\hyperlink{2727296760866702904}{\texttt{Float16}} & \href{https://en.wikipedia.org/wiki/Half-precision\_floating-point\_format}{media} & 16 \\
\hline
\hyperlink{8101639384272933082}{\texttt{Float32}} & \href{https://en.wikipedia.org/wiki/Single\_precision\_floating-point\_format}{sencilla} & 32 \\
\hline
\hyperlink{5027751419500983000}{\texttt{Float64}} & \href{https://en.wikipedia.org/wiki/Double\_precision\_floating-point\_format}{doble} & 64 \\
\hline
\end{tabulary}

\end{table}



Adicionalmente, se ha construído un soporte completo para \hyperlink{57238021523210895}{Números Complejos y Racionales} encima de estos tipos primitivos. Todos los tipos primitivos interoperan de forma natural sin tener que realizar conversiones específicas, gracias a un \hyperlink{10686378388163930476}{sistema de promoción de tipos} flexible y extensible por el usuario.



\hypertarget{13973154041881077585}{}


\section{Enteros}



Los literales enteros se representan del modo estándar:




\begin{minted}{jlcon}
julia> 1
1

julia> 1234
1234
\end{minted}



El tipo por defecto para un literal entero depende de si el sistema de trabajo tiene una aquitectura de 32 o de 64 bits:




\begin{minted}{jlcon}
# 32-bit system:
julia> typeof(1)
Int32

# 64-bit system:
julia> typeof(1)
Int64
\end{minted}



La variable interna de Julia \hyperlink{6553323097149877235}{\texttt{Sys.WORD\_SIZE}} indica si el sistema en el que trabajamos es de 32 bits o de 64 bits:




\begin{minted}{jlcon}
# 32-bit system:
julia> Sys.WORD_SIZE
32

# 64-bit system:
julia> Sys.WORD_SIZE
64
\end{minted}



Julia también define los tipos \texttt{Int} y \texttt{UInt}, que son aliases para los tipos enteros nativos del sistema con y sin signo:




\begin{minted}{jlcon}
# 32-bit system:
julia> Int
Int32
julia> UInt
UInt32

# 64-bit system:
julia> Int
Int64
julia> UInt
UInt64
\end{minted}



Los literales enteros mayores que no pueden ser representados usando sólo 32 bits pero pueden ser representados en 64 bits se crean como enteros de 64 bits, independientemente del tipo que tenga el sistema por defecto:




\begin{minted}{jlcon}
# 32-bit or 64-bit system:
julia> typeof(3000000000)
Int64
\end{minted}



Los enteros sin signo se introducen y se muestran usando el prefijo \texttt{0x} y los dígitos hexadecimales \texttt{0-9a-f} (los dígitos capitalizados \texttt{A-F} también funcionan para la entrada). El tamaño de un valor sin signo está determinado por el número de dígitos hexadecimales usados:




\begin{minted}{jlcon}
julia> 0x1
0x01

julia> typeof(ans)
UInt8

julia> 0x123
0x0123

julia> typeof(ans)
UInt16

julia> 0x1234567
0x01234567

julia> typeof(ans)
UInt32

julia> 0x123456789abcdef
0x0123456789abcdef

julia> typeof(ans)
UInt64
\end{minted}



Este comportamiento está basado en la observación de que cuando uno usa literales hexadecimales sin signo para valores enteros, se los suele utilizar para representar una secuencia de bytes numéricos fijos en lugar de un valor entero.



Recuerde que la variable \hyperlink{11288188119698492222}{\texttt{ans}} contiene el valor de la última expresión evaluada en una sesión interactiva. Esto no ocurre cuando el código Julia se ejecuta de otra forma.



Los literales binarios y octales también están soportados:




\begin{minted}{jlcon}
julia> 0b10
0x02

julia> typeof(ans)
UInt8

julia> 0o10
0x08

julia> typeof(ans)
UInt8
\end{minted}



Los valores máximo y mínimo de tipos primitivos numéricos representables como enteros vienen dados por las funciones  \hyperlink{3613894539247233488}{\texttt{typemin()}} y \hyperlink{17760305803764597758}{\texttt{typemax()}}:




\begin{minted}{jlcon}
julia> (typemin(Int32), typemax(Int32))
(-2147483648, 2147483647)

julia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
           println("$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]")
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]
\end{minted}



Los valores devueltos por \hyperlink{3613894539247233488}{\texttt{typemin()}} y \hyperlink{17760305803764597758}{\texttt{typemax()}} siempre son del tipo de argumento dado. (La expresión anterior utiliza varias características que todavía tenemos que introducir, incluyendo \hyperlink{6800841505698205300}{bucles for}, \hyperlink{3772396547767597421}{Cadenas}, e \hyperlink{12583298261221600612}{Interpolación}, pero debería ser lo suficientemente fácil de entender para los usuarios con cierta experiencia en programación).)



\hypertarget{14418936038439856847}{}


\subsection{Comportamiento ante el Desbordamiento}



En Julia, superar el valor máximo representable de un tipo dado da como resultado un comportamiento envolvente:




\begin{minted}{jlcon}
julia> x = typemax(Int64)
9223372036854775807

julia> x + 1
-9223372036854775808

julia> x + 1 == typemin(Int64)
true
\end{minted}



Así, la aritmética con enteros de Julia es en realidad una forma de \href{https://en.wikipedia.org/wiki/Modular\_arithmetic}{aritmética modular}. Esto refleja las características de la aritmética subyacente de números enteros tal como se implementa en las computadoras modernas. En aplicaciones donde es posible el desbordamiento, es esencial comprobar explícitamente el envolvente producido por el desbordamiento. De lo contrario, se recomienda el tipo \hyperlink{423405808990690832}{\texttt{BigInt}} en \hyperlink{6835190037951372309}{Aritmética de Precisión Arbitraria}.



\hypertarget{7076833061560514546}{}


\subsection{Errores de división}



La división entera (la función \texttt{div}) tiene dos casos excepcionales: división por cero, y dividir el número  negativo más bajo  (\hyperlink{3613894539247233488}{\texttt{typemin()}}) por -1. Ambos casos lanzan un \hyperlink{4168463413201806292}{\texttt{DivideError}}. El resto y las funciones de módulo (\texttt{rem} y \texttt{mod}) lanzan un  \hyperlink{4168463413201806292}{\texttt{DivideError}} cuando su segundo argumento es cero.



\hypertarget{12894353147008502563}{}


\section{Números en Punto Flotante}



Los literales de números en punto flotante son representados en las formas estándar:




\begin{minted}{jlcon}
julia> 1.0
1.0

julia> 1.
1.0

julia> 0.5
0.5

julia> .5
0.5

julia> -1.23
-1.23

julia> 1e10
1.0e10

julia> 2.5e-4
0.00025
\end{minted}



Los resultados anteriores son todos valores \hyperlink{5027751419500983000}{\texttt{Float64}}. Los valores literales \hyperlink{8101639384272933082}{\texttt{Float32}} pueden introducirse escribiendo \texttt{f} en lugar de \texttt{e}:




\begin{minted}{jlcon}
julia> 0.5f0
0.5f0

julia> typeof(ans)
Float32

julia> 2.5f-4
0.00025f0
\end{minted}



Los valores pueden ser convertidos a \hyperlink{8101639384272933082}{\texttt{Float32}} fácilmente:




\begin{minted}{jlcon}
julia> Float32(-1.5)
-1.5f0

julia> typeof(ans)
Float32
\end{minted}



También son válidos los literales de punto flotante en formato hexadecimal, pero sólo como valores \hyperlink{5027751419500983000}{\texttt{Float64}}:




\begin{minted}{jlcon}
julia> 0x1p0
1.0

julia> 0x1.8p3
12.0

julia> 0x.4p-1
0.125

julia> typeof(ans)
Float64
\end{minted}



También esta soportados los números en punto flotante de media precisión (\hyperlink{2727296760866702904}{\texttt{Float16}}), pero ellos están implementados en software y usan \hyperlink{8101639384272933082}{\texttt{Float32}} para los cálculos.




\begin{minted}{jlcon}
julia> sizeof(Float16(4.))
2

julia> 2*Float16(4.)
Float16(8.0)
\end{minted}



El guión bajo (\emph{underscore}) puede usarse como separador de dígitos:




\begin{minted}{jlcon}
julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010
(10000, 5.0e-9, 0xdeadbeef, 0xb2)
\end{minted}



\hypertarget{4698204145764212123}{}


\subsection{Cero en punto flotante}



Los números en punto flotante tienen \href{https://en.wikipedia.org/wiki/Signed\_zero}{dos ceros}, positivo y negativo. Ellos son iguales entre sí, pero tienen distintas representaciones, como puede verse si usamos la función \texttt{bits}:




\begin{minted}{jlcon}
julia> 0.0 == -0.0
true

julia> bits(0.0)
"0000000000000000000000000000000000000000000000000000000000000000"

julia> bits(-0.0)
"1000000000000000000000000000000000000000000000000000000000000000"
\end{minted}



\hypertarget{8368313158411015136}{}


\subsection{Valores especiales en punto flotante}



Hay tres valores especificados en el estándar de punto flotante para valores que no se corresponden  con ningún punto en la línea de números reales:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\texttt{Float16} & \texttt{Float32} & \texttt{Float64} & Name & Description \\
\hline
\texttt{Inf16} & \texttt{Inf32} & \texttt{Inf} & Infinito positivo & Un valor mayor que todos los valores finitos de punto flotante \\
\hline
\texttt{-Inf16} & \texttt{-Inf32} & \texttt{-Inf} & Infinito negativo & Un valor menos que todos los valores finitos de punto flotante \\
\hline
\texttt{NaN16}   & \texttt{NaN32}   & \texttt{NaN}     & \emph{not a number}   & Un valor no \texttt{==} a otro valor en punto flotante (incluido el mismo) \\
\hline
\end{tabulary}

\end{table}



Para más información sobre cómo estos valores de punto flotante no finitos están ordenados entre sí y otros flotantes, vea \hyperlink{10761683973495993636}{Comparaciones Numéricas}. Mediante el \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{estándar IEEE 754}, estos valores de punto flotante son el resultado de ciertas operaciones aritméticas:




\begin{minted}{jlcon}
julia> 1/Inf
0.0

julia> 1/0
Inf

julia> -5/0
-Inf

julia> 0.000001/0
Inf

julia> 0/0
NaN

julia> 500 + Inf
Inf

julia> 500 - Inf
-Inf

julia> Inf + Inf
Inf

julia> Inf - Inf
NaN

julia> Inf * Inf
Inf

julia> Inf / Inf
NaN

julia> 0 * Inf
NaN
\end{minted}



Las funciones \hyperlink{3613894539247233488}{\texttt{typemin()}} y \hyperlink{17760305803764597758}{\texttt{typemax()}} también se aplican a los tipos en punto flotante:




\begin{minted}{jlcon}
julia> (typemin(Float16),typemax(Float16))
(-Inf16, Inf16)

julia> (typemin(Float32),typemax(Float32))
(-Inf32, Inf32)

julia> (typemin(Float64),typemax(Float64))
(-Inf, Inf)
\end{minted}



\hypertarget{15354049390111744640}{}


\subsection{Epsilon de máquina}



La mayoría de los números reales no pueden representarse exactamente con números de coma flotante, por lo que para muchos propósitos es importante conocer la distancia entre dos números de punto flotante representables adyacentes, lo que a menudo se conoce como \href{https://en.wikipedia.org/wiki/Machine\_epsilon}{epsilon de máquina}.



Julia proporciona \hyperlink{4594213520310841636}{\texttt{eps()}}, que da la distancia entre 1,0 y el siguiente valor de punto flotante representable más grande:




\begin{minted}{jlcon}
julia> eps(Float32)
1.1920929f-7

julia> eps(Float64)
2.220446049250313e-16

julia> eps() # same as eps(Float64)
2.220446049250313e-16
\end{minted}



Estos valores son \texttt{2.0{\textasciicircum}-23} y \texttt{2.0{\textasciicircum}-52} como valores \hyperlink{8101639384272933082}{\texttt{Float32}} y \hyperlink{5027751419500983000}{\texttt{Float64}}, respectivamente. La función \hyperlink{4594213520310841636}{\texttt{eps()}} también puede tomar un valor de punto flotante como un argumento y da la diferencia absoluta entre ese valor y el siguiente valor de punto flotante representable. Es decir, \texttt{eps(x)} produce un valor del mismo tipo que \texttt{x} tal que \texttt{x} + \texttt{eps(x)} es el siguiente valor de punto flotante representable mayor que \texttt{x}:




\begin{minted}{jlcon}
julia> eps(1.0)
2.220446049250313e-16

julia> eps(1000.)
1.1368683772161603e-13

julia> eps(1e-27)
1.793662034335766e-43

julia> eps(0.0)
5.0e-324
\end{minted}



La distancia entre dos números de punto flotante representables adyacentes no es constante, pero es menor para valores más pequeños y mayor para valores mayores. En otras palabras, los números de punto flotante representables son más densos en la línea de números reales cerca de cero, y crecen exponencialmente dispersos a medida que uno se aleja de cero. Por definición, \texttt{eps(1.0)} es el mismo que \texttt{eps(Float64)} ya que \texttt{1.0} es un valor de coma flotante de 64 bits.



Julia también proporciona las funciones \hyperlink{8339500090035450608}{\texttt{nextfloat()}} y \hyperlink{14035790731013288499}{\texttt{prevfloat()}} que devuelven el siguiente número de punto flotante representable más grande o más pequeño al argumento, respectivamente:




\begin{minted}{jlcon}
julia> x = 1.25f0
1.25f0

julia> nextfloat(x)
1.2500001f0

julia> prevfloat(x)
1.2499999f0

julia> bits(prevfloat(x))
"00111111100111111111111111111111"

julia> bits(x)
"00111111101000000000000000000000"

julia> bits(nextfloat(x))
"00111111101000000000000000000001"
\end{minted}



Este ejemplo resalta el principio general de que los números de punto flotante representables adyacentes también tienen representaciones binarias enteras adyacentes.



\hypertarget{9332804486077942939}{}


\subsection{Modos de Redondeo}



Si un número no tiene una representación de punto flotante exacta, debe redondearse a un valor representable apropiado. Sin embargo, si se desea, la forma en que se realiza este redondeo puede cambiarse de acuerdo con los modos de redondeo presentados en el \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{estándar IEEE 754}.




\begin{minted}{jlcon}
julia> x = 1.1; y = 0.1;

julia> x + y
1.2000000000000002

julia> setrounding(Float64,RoundDown) do
           x + y
       end
1.2
\end{minted}



El modo predeterminado utilizado siempre es \hyperlink{868115654703135309}{\texttt{RoundNearest}}, , que redondea al valor representable  más cercano, con arcos redondeados hacia el valor más cercano con un bit menos significativo.



\begin{quote}
\textbf{Warning}

El redondeo generalmente sólo es correcto para las funciones aritméticas básicas (\hyperlink{3677358729494553841}{\texttt{+()}},  \hyperlink{8228207173393714756}{\texttt{-()}}, \hyperlink{8486205126068439173}{\texttt{*()}}, \hyperlink{4103478871488785445}{\texttt{/()}} and \hyperlink{4178506499510800909}{\texttt{sqrt()}}) y las operaciones de conversión  de tipos. Muchas otras funciones asumen que el modo por defecto \hyperlink{868115654703135309}{\texttt{RoundNearest}} está  establecido y pueden dar resultados erróneos al operar bajo otros modos de redondeo.

\end{quote}


\hypertarget{91373173144523224}{}


\subsection{Antecedentes y referencias}



La aritmética de punto flotante supone muchas sutilezas que pueden sorprender a los usuarios que no  están familiarizados con los detalles de implementación de bajo nivel. Sin embargo, estas sutilezas  se describen en detalle en la mayoría de los libros sobre computación científica, y también en las  siguientes referencias:



\begin{itemize}
\item La guía definitiva para la aritmética de coma flotante es el estándar [IEEE 754-2008 (http://standards.ieee.org/findstds/standard/754-2008.html); Sin embargo, no está disponible 

\end{itemize}


en línea gratis.



\begin{itemize}
\item Para una presentación breve pero lúcida de cómo los números de punto flotante están 

\end{itemize}


 representados, vea el \href{https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/}{artículo de John D. Cook} sobre el tema, así como su \href{https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/}{introducción} a algunas de las cuestiones que surgen de cómo esta representación difiere en el comportamiento de la abstracción idealizada de números reales.   * También se recomienda la serie de \href{https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/}{publicaciones de Bruce Dawson sobre números en punto flotante}.



\begin{itemize}
\item Para un excelente y profundo análisis de los números de punto flotante y los problemas de precisión numérica encontrados al calcular con ellos, vea el artículo de David Goldberg \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768\&rep=rep1\&type=pdf}{What Every Computer Scientist Should Know About Floating-Point Arithmetic}.


\item Para una documentación aún más extensa de la historia de, la razón y las cuestiones con los números de punto flotante, así como la discusión de muchos otros temas en la computación numérica, ver los \href{https://people.eecs.berkeley.edu/{\textasciitilde}wkahan/}{escritos recolectados} de \href{https://en.wikipedia.org/wiki/William\_Kahan}{William Kahan}, comúnmente conocido como el {\textquotedbl}padre de punto flotante{\textquotedbl}. De interés particular puede ser \href{https://people.eecs.berkeley.edu/{\textasciitilde}wkahan/ieee754status/754story.html}{An Interview with the Old Man of Floating-Point}.

\end{itemize}


\hypertarget{6835190037951372309}{}


\section{Aritmética de Precisión Arbitraria}



Para permitir cálculos con enteros y números de coma flotante de precisión arbitraria, Julia envuelve la \href{https://gmplib.org}{Biblioteca Aritmética de Precisión Múltiple GNU (GMP)} y la \href{http://www.mpfr.org}{biblioteca GNU MPFR}, respectivamente. Los tipos \hyperlink{423405808990690832}{\texttt{BigInt}} y \hyperlink{749816618809421837}{\texttt{BigFloat}} están disponibles en Julia para números enteros de precisión arbitraria y números de coma flotante, respectivamente.



Existen constructores para crear estos tipos de tipos numéricos primitivos, y podemos también utilizar \hyperlink{13108503824143481717}{\texttt{parse()}} para construirlos a partir de \texttt{AbstractString}s.  Una vez creados, participan en la aritmética con todos los demás tipos numéricos gracias al \hyperlink{10686378388163930476}{mecanismo de promotion y conversion de tipos} de Julia:




\begin{minted}{jlcon}
julia> BigInt(typemax(Int64)) + 1
9223372036854775808

julia> parse(BigInt, "123456789012345678901234567890") + 1
123456789012345678901234567891

julia> parse(BigFloat, "1.23456789012345678901")
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia> BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia> factorial(BigInt(40))
815915283247897734345611269596115894272000000000
\end{minted}



Sin embargo, la promoción de tipos entre los tipos primitivos ya vistos y \hyperlink{423405808990690832}{\texttt{BigInt}}/\hyperlink{749816618809421837}{\texttt{BigFloat}} no es automática y debe ser establecida explícitamente: 




\begin{minted}{jlcon}
julia> x = typemin(Int64)
-9223372036854775808

julia> x = x - 1
9223372036854775807

julia> typeof(x)
Int64

julia> y = BigInt(typemin(Int64))
-9223372036854775808

julia> y = y - 1
-9223372036854775809

julia> typeof(y)
BigInt
\end{minted}



La precisión predeterminada (en número de bits del significado) y el modo de redondeo de las operaciones de \hyperlink{749816618809421837}{\texttt{BigFloat}} pueden cambiarse globalmente llamando \hyperlink{3543074496498234209}{\texttt{setprecision()}} and \hyperlink{12025922235501343815}{\texttt{setrounding()}}, y todos los cálculos adicionales tomarán en cuenta estos cambios. Alternativamente, la precisión o el redondeo se puede cambiar dentro sólo de la ejecución de un bloque particular de código utilizando las mismas funciones dentro de un bloque \texttt{do}:




\begin{minted}{jlcon}
julia> setrounding(BigFloat, RoundUp) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia> setrounding(BigFloat, RoundDown) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia> setprecision(40) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.1000000000004
\end{minted}



\hypertarget{14058350023597195643}{}


\section{Coeficientes Literales Numéricos}



Para hacer más claras fórmulas numéricas y expresiones, Julia permite que las variables sean precedidas inmediatamente por un literal numérico, implicando la multiplicación. Esto hace que la escritura de las expresiones polinómicas sea mucho más limpias:




\begin{lstlisting}
julia> x = 3
3

julia> 2x^2 - 3x + 1
10

julia> 1.5x^2 - .5x + 1
13.0
\end{lstlisting}



También hace que escribir funciones exponenciales sea más elegante:




\begin{lstlisting}
julia> 2^2x
64
\end{lstlisting}



La precedencia de los coeficientes literales numéricos es la misma que la de los operadores unarios como la negación. Así que \texttt{2{\textasciicircum}3x} se analiza como \texttt{2{\textasciicircum}(3x)}, y \texttt{2x{\textasciicircum}3} se analiza como \texttt{2*(x {\textasciicircum} 3)}.



Los literales numéricos también funcionan como coeficientes de las expresiones entre paréntesis:




\begin{lstlisting}
julia> 2(x-1)^2 - 3(x-1) + 1
3
\end{lstlisting}



\begin{quote}
\textbf{Note}

\end{quote}


   La precedencia de coeficientes literales numéricos usada para multiplicación      implícita es mayor que otros operadores binarios tales como la multiplicación     (\texttt{*}), y división (\texttt{/}, \texttt{{\textbackslash}}, and \texttt{//}).  Esto significa, por ejemplo, que      \texttt{1 / 2im} es igual a \texttt{-0.5im} y \texttt{6 // 2(2 + 1)} es igual a \texttt{1 // 1}.



Además, las expresiones entre paréntesis se pueden utilizar como coeficientes a las variables, lo que implica la multiplicación de la expresión por la variable:




\begin{lstlisting}
julia> (x-1)x
6
\end{lstlisting}



Sin embargo, ni la yuxtaposición de dos expresiones entre paréntesis, ni la colocación de una variable antes de una expresión entre paréntesis puede ser usada para implicar multiplicación:




\begin{lstlisting}
julia> (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable

julia> x(x+1)
ERROR: MethodError: objects of type Int64 are not callable
\end{lstlisting}



Ambas expresiones se interpretan como la aplicación de una función: cualquier expresión que no sea un literal numérico, inmediatamente seguida de una entre paréntesis, se interpreta como una función aplicada a los valores entre paréntesis (ver \hyperlink{8538207326577378342}{Funciones} para más información sobre las funciones). Por lo tanto, en ambos casos, se produce un error, ya que el valor de la izquierda no es una función.



Las mejoras sintácticas anteriores reducen significativamente el ruido visual producido al escribir fórmulas matemáticas comunes. Obsérvese que ningún espacio en blanco puede encontrarse entre un coeficiente literal numérico y el identificador o la expresión entre paréntesis que multiplica.



\hypertarget{11622936377746394723}{}


\subsection{Conflictos de Sintaxis}



La sintaxis de los coeficientes literales yuxtapuestos puede entrar en conflicto con dos sintaxis numéricas literales: literales enteros hexadecimales y notación ingenieril para literales de punto flotante. Aquí hay algunas situaciones donde surgen conflictos sintácticos:



\begin{itemize}
\item La expresión literal de enteros hexadecimales \texttt{0xff} podría interpretarse como el literal numérico \texttt{0} multiplicado por la variable \texttt{xff}.


\item La expresión literal de punto flotante \texttt{1e10} podría interpretarse como el literal numérico \texttt{1} multiplicado por la variable \texttt{e10}, e igualmente con la forma \texttt{E} equivalente

\end{itemize}


En ambos casos, resolvemos la ambigüedad a favor de la interpretación como literales numéricos:



\begin{itemize}
\item Las expresiones que comienzan con \texttt{0x} siempre son literales hexadecimales.


\item Las expresiones que empiezan con un literal numérico seguido por e o E siempre son literales de coma flotante.

\end{itemize}


\hypertarget{13462049852775366895}{}


\section{Literales cero and uno}



Julia proporciona funciones que devuelven los literales \texttt{0} y \texttt{1} correspondientes a un tipo especificado o al tipo de una variable dada.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\hyperlink{240596739242881814}{\texttt{zero(x)}} & Literal cero del tipo \texttt{x} o del tipo de la variable \texttt{x} \\
\hline
\hyperlink{11395333326208453101}{\texttt{one(x)}} & Literal uno del tipo \texttt{x} o del tipo de la variable \texttt{x} \\
\hline
\end{tabulary}

\end{table}



Estas funciones son útiles en \hyperlink{10761683973495993636}{comparaciones numéricas} para evitar la sobrecarga de una \hyperlink{10686378388163930476}{conversión de tipo} innecesaria.



Ejemplos:




\begin{minted}{jlcon}
julia> zero(Float32)
0.0f0

julia> zero(1.0)
0.0

julia> one(Int32)
1

julia> one(BigFloat)
1.000000000000000000000000000000000000000000000000000000000000000000000000000000
\end{minted}



\hypertarget{16655087771805204817}{}


\chapter{Mathematical Operations and Elementary Functions}



Julia proporciona una colección completa de operadores aritméticos básicos y de operadores de bits para todos sus tipos numéricos primitivos, así como implementaciones portables y eficientes de una colección comprensiva de funciones matemática estándar.



\hypertarget{13157736738924759674}{}


\section{Operadores Aritméticos}



Los siguientes \href{https://en.wikipedia.org/wiki/Arithmetic\#Arithmetic\_operations}{operadores aritméticos} están soportados sobre todos los tipos primitivos:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Expression & Name & Description \\
\hline
\texttt{+x}       & más unario       & Operación identidad                    \\
\hline
\texttt{-x}       & menos unario     & Inverso matemático de un número \\
\hline
\texttt{x + y} & suma binaria & suma \\
\hline
\texttt{x - y} & menos binario & resta \\
\hline
\texttt{x * y}   & producto         & multiplicación               \\
\hline
\texttt{x / y}   & división         & división                     \\
\hline
\texttt{x {\textbackslash} y}   & división inversa & Equivalente a \texttt{y / x}                 \\
\hline
\texttt{x {\textasciicircum} y}   & potencia         & eleva \texttt{x} a la \texttt{y}-ésima potencia \\
\hline
\texttt{x \% y} & resto & Equivalente a \texttt{rem(x,y)} \\
\hline
\end{tabulary}

\end{table}



así como la negación sobre tipos \hyperlink{46725311238864537}{\texttt{Bool}}:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Expression & Name & Description \\
\hline
\texttt{!x}       & negación & Cambia \texttt{true} a \texttt{false} y viceversa \\
\hline
\end{tabulary}

\end{table}



El sistema de promoción de Julia hace que las operaciones aritméticas sobre mezclas de tipos de argumentos funcione de forma natural y automáticamente. Ver \hyperlink{10686378388163930476}{Conversión y Promoción} para los detalles del sistema de promoción.



He aquí algunos ejemplos simples de usar operadores aritméticos:




\begin{minted}{jlcon}
julia> 1 + 2 + 3
6

julia> 1 - 2
-1

julia> 3*2/12
0.5
\end{minted}



(Por convención, tendemos a separar con menos distancia los operadores cuando se aplican antes de otros operadores cercanos. Por ejemplo, generalmente escribimos \texttt{-x + 2} para reflejar que \texttt{x} primero se niega y, a continuación, \texttt{2} se agrega a ese resultado.)



\hypertarget{12563952200129302862}{}


\section{Operadores bit a bit}



Los siguientes \href{https://en.wikipedia.org/wiki/Bitwise\_operation\#Bitwise\_operators}{operadores bit a bit} son soportados sobre todos los tipos enteros primitivos:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Expression & Name \\
\hline
\texttt{{\textasciitilde}x}       & Negación bit a bit                                                     \\
\hline
\texttt{x \& y}   & Conjunción (\emph{and}) bit a bit                                           \\
\hline
\texttt{x | y}   & Disyunción (\emph{or}) bit a bit                                              \\
\hline
\texttt{x ⊻ y} & \emph{Or} exclusivo bit a bit (\emph{xor}) \\
\hline
\texttt{x >>> y} & \href{https://en.wikipedia.org/wiki/Logical\_shift}{Desplazamiento lógico} hacia la derecha       \\
\hline
\texttt{x >> y}   & \href{https://en.wikipedia.org/wiki/Arithmetic\_shift}{Desplazamiento aritmético} hacia la derecha \\
\hline
\texttt{x << y}   & Desplazamiento hacia la izquierda lógico/aritmético                                         \\
\hline
\end{tabulary}

\end{table}



He aquí algunos ejemplos de uso de operadores bit a bit:




\begin{minted}{jlcon}
julia> ~123
-124

julia> 123 & 234
106

julia> 123 | 234
251

julia> 123 ⊻ 234
145

julia> xor(123, 234)
145

julia> ~UInt32(123)
0xffffff84

julia> ~UInt8(123)
0x84
\end{minted}



\hypertarget{16299219603229115867}{}


\section{Operaciones de actualización}



Cada operador binario aritmético y bit a bit también tiene una versión de actualización que asigna el resultado de la operación de nuevo a su operando izquierdo. La versión de actualización del operador binario se forma colocando a = inmediatamente después del operador. Por ejemplo, escribir \texttt{x += 3} es equivalente a escribir \texttt{x = x + 3}:




\begin{minted}{jlcon}
julia> x = 1
1

julia> x += 3
4

julia> x
4
\end{minted}



Las versiones de actualización de todos los operadores binarios, aritméticos de bits son:




\begin{lstlisting}
+=  -=  *=  /=  \=  ÷=  %=  ^=  &=  |=  ⊻=  >>>=  >>=  <<=
\end{lstlisting}



\begin{quote}
\textbf{Note}

Un operador de actualización reasigna la variable sobre la parte izquierda de la ecuación. Como  resultado, el tipo de la variable puede cambiar:


\begin{minted}{jlcon}
julia> x = 0x01; typeof(x)
UInt8

julia> x *= 2 # Same as x = x * 2
2

julia> typeof(x)
Int64
\end{minted}

\end{quote}


\hypertarget{6173297391052343261}{}


\section{Operadores vectorizados con {\textquotedbl}punto{\textquotedbl}}



Para cada operación binaria como \texttt{{\textasciicircum}} hay su correspondiente operación {\textquotedbl}con punto{\textquotedbl} \texttt{.{\textasciicircum}} que se define \emph{automáticamente} para realizar la operación \texttt{{\textasciicircum}} elemento a elemento sobre arrays. Por ejemplo, la operación \texttt{[1, 2, 3]{\textasciicircum}3} no está definidia, porque no hay un significado matemático estándar para calcular el cubo de un array, pero \texttt{[1, 2, 3].{\textasciicircum}3} si lo está como el cálculo de la operación cubo elemento a elemento (o vectorizada) \texttt{[1{\textasciicircum}3, 2{\textasciicircum}3, 3{\textasciicircum}3]}. Lo mismo puede decirse para operadores unarios tales como \texttt{!} o \texttt{√}, que existe el correspondiente operador vectorizado \texttt{.√} que aplica el operador elemento a elemento.




\begin{minted}{jlcon}
julia> [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27
\end{minted}



Más específicamente, \texttt{a .{\textasciicircum} b} es analizado como la \hyperlink{13590013989415065742}{llamada punto} \texttt{({\textasciicircum}).(a,b)}, que realiza una operación de \hyperlink{6411237952146762090}{retransmisión (\emph{broadcast})}: ella puede combinar arrays y escalares, arrays del mismo tamaño (realizando la operación elemento a elemento), o incluso arrays de diferentes formas (por ejemplo, combinar vectores fila y columna para producir una matriz). Además, como todas las {\textquotedbl}llamadas punto{\textquotedbl}, estos {\textquotedbl}operadores punto{\textquotedbl} están \emph{fusionados}. Por ejemplo, si calculamos \texttt{2 .* A.{\textasciicircum}2 .+ sin.(A)} (o, equivalentemente \texttt{@. 2A{\textasciicircum}2 + sin(A)}, usando la macro \hyperlink{16688502228717894452}{\texttt{@.}}) para un array \texttt{A}, se realiza un \emph{único} bucle sobre \texttt{A}, computando \texttt{2a{\textasciicircum}2 + sin(a)} para cada elemento de \texttt{A}. En particular, las llamadas vectorizadas anidadas como \texttt{f.(g.(x))} están \emph{fusionadas}, y los operadores binarios adyacentes como \texttt{x .+ 3 .* x.{\textasciicircum}2} son equivalentes a llamadas vectorizadas anidadas \texttt{(+).(x, (*).(3, ({\textasciicircum}).(x, 2)))}.



Además, los operadores de actualización {\textquotedbl}vectorizados{\textquotedbl} como \texttt{a .+= b} (o \texttt{@. a += b}) son transformados en \texttt{a .= a .+ b}, donde \texttt{.=} es un operador de asignación \emph{fusionado} \emph{in-place} (ver la \hyperlink{13590013989415065742}{documentación de la sintaxis vectorizada}).



Nótese que la sintaxis de punto es también aplicable a operadores definidos por el usuario. Por ejemplo, si definimos el operador \texttt{⊗(A,B) = kron(A,B)} para dar una sintaxis infija \texttt{A ⊗ B} al producto de Kronecker (\hyperlink{14153417388267953812}{\texttt{kron}}), entonces \texttt{[A,B] .⊗ [C,D]} calculará  \texttt{[A⊗C, B⊗D]} sin ninguna codificación adicional.



\hypertarget{10761683973495993636}{}


\section{Comparaciones Numéricas}



Los operadores de comparación estándar están definidos para todos los tipos numéricos primitivos:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Operador & Nombre \\
\hline
\hyperlink{15143149452920304570}{\texttt{==}} & Igualdad \\
\hline
\hyperlink{3046079188653285114}{\texttt{!=}}, \hyperlink{3046079188653285114}{\texttt{≠}} & Desigualdad \\
\hline
\hyperlink{702782232449268329}{\texttt{<}} & Menor que \\
\hline
\hyperlink{11411050964021316526}{\texttt{<=}}, \hyperlink{11411050964021316526}{\texttt{≤}} & Menor o igual que \\
\hline
\hyperlink{8677991761303191103}{\texttt{>}} & Mayor que \\
\hline
\hyperlink{7019639580556993898}{\texttt{>=}}, \hyperlink{7019639580556993898}{\texttt{≥}} & Mayor o igual que \\
\hline
\end{tabulary}

\end{table}



He aquí algunos ejemplos:




\begin{minted}{jlcon}
julia> 1 == 1
true

julia> 1 == 2
false

julia> 1 != 2
true

julia> 1 == 1.0
true

julia> 1 < 2
true

julia> 1.0 > 3
false

julia> 1 >= 1.0
true

julia> -1 <= 1
true

julia> -1 <= -1
true

julia> -1 <= -2
false

julia> 3 < -0.5
false
\end{minted}



Los enteros se comparan de un modo estándar, mediante comparación de bits. Los números de punto flotante se comparan de acuerdo al \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{estándar IEEE 754}:



\begin{itemize}
\item Los números finitos son ordenados del modo habitual.


\item El cero positivo es igual pero no mayor que el cero negativo.


\item \texttt{Inf} es igual a si mismo y mayor que todo excepto \texttt{NaN}


\item \texttt{-Inf} es igual a si mismo y menor que todo excepto \texttt{NaN}


\item \texttt{NaN} no es igual, mayor o menor a nadie, excepto a sí mismo.

\end{itemize}


Este último punto es potencialmente sorprendente y, por tanto, vale la pena señalar que:




\begin{minted}{jlcon}
julia> NaN == NaN
false

julia> NaN != NaN
true

julia> NaN < NaN
false

julia> NaN > NaN
false
\end{minted}



y puede causar dolores de cabeza especiales con \hyperlink{15299817005323384893}{Arrays}:




\begin{minted}{jlcon}
julia> [1 NaN] == [1 NaN]
false
\end{minted}



Julia proporciona funciones adicionales para comprobar números para valores especiales, lo cuál pueden ser útil en situaciones como las comparaciones de claves hash:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Tests if \\
\hline
\hyperlink{12829995639916057841}{\texttt{isequal(x, y)}} & \texttt{x} e \texttt{y} son idénticos \\
\hline
\hyperlink{2906021895910968108}{\texttt{isfinite(x)}}   & \texttt{x} es un número finito \\
\hline
\hyperlink{4492113908831448207}{\texttt{isinf(x)}} & \texttt{x} es infinito \\
\hline
\hyperlink{6770390199496851634}{\texttt{isnan(x)}}     & \texttt{x} no es un número \\
\hline
\end{tabulary}

\end{table}



\hyperlink{12829995639916057841}{\texttt{isequal()}} considera los \texttt{NaN}s iguales entre sí:




\begin{minted}{jlcon}
julia> isequal(NaN, NaN)
true

julia> isequal([1 NaN], [1 NaN])
true

julia> isequal(NaN, NaN32)
true
\end{minted}



\texttt{isequal()} también puede usarse para distinguir los ceros con signo:




\begin{minted}{jlcon}
julia> -0.0 == 0.0
true

julia> isequal(-0.0, 0.0)
false
\end{minted}



Las comparaciones de tipos mezclados entre enteros con signo, enteros sin signo y valores en punto flotante pueden ser complicadas. Se ha tomado mucho cuidado para asegurarse de que Julia las realiza correctamente.



Para otros tipos, \texttt{isequal()} llama por defecto a \hyperlink{15143149452920304570}{\texttt{==()}}, así que si uno quiere definir la igualdad para sus propios tipos, solo tiene que agregar un método \hyperlink{15143149452920304570}{\texttt{==()}}.  Si uno define suu propia función de igualdad, probablemente deba definir un método \hyperlink{13797072367283572032}{\texttt{hash()}} correspondiente para asegurar de que \texttt{isequal(x,y)} implica \texttt{hash(x) == hash(y)}.



\hypertarget{266289900573141417}{}


\subsection{Comparaciones Encadenadas}



A diferencia de la mayoría de los idiomas, \href{https://en.wikipedia.org/wiki/Python\_syntax\_and\_semantics\#Comparison\_operators}{con la notable excepción de Python}, las comparaciones pueden encadenarse arbitrariamente:




\begin{minted}{jlcon}
julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
true
\end{minted}



El encadenamiento de comparaciones suele ser bastante conveniente en el código numérico. Las comparaciones encadenadas utilizan el operador \texttt{\&\&} para comparaciones escalares y el operador \hyperlink{1494761116451616317}{\texttt{\&}} para comparaciones elemento a elemento, lo que les permite trabajar sobre arrays. Por ejemplo, \texttt{0 .< A .< 1} da un array booleano cuyas entradas son \texttt{true} en posiciones en las que los elementos correspondientes de A están entre 0 y 1.



Nótese el comportamiento de evaluación de las comparaciones encadenadas:




\begin{minted}{jlcon}
julia> v(x) = (println(x); x)
v (generic function with 1 method)

julia> v(1) < v(2) <= v(3)
2
1
3
true

julia> v(1) > v(2) <= v(3)
2
1
false
\end{minted}



La expresión del medio sólo se evalúa una vez, en lugar de dos veces como lo sería si la expresión se escribiera como \texttt{v(1) < v(2) \&\& v(2) <= v(3)}. Sin embargo, el orden de las evaluaciones en una comparación encadenada no está definido. Se recomienda encarecidamente no utilizar expresiones que puedan tener efectos secundarios (como la impresión) en comparaciones encadenadas. Si se requieren efectos secundarios, se debe utilizar explícitamente el operador de cortocircuito \texttt{\&\&} (ver \hyperlink{10787134294480612893}{Evaluación en cortocircuito}).



\hypertarget{17395527405393843522}{}


\subsection{Funciones Elementales}



Julia proporciona una colección completa de funciones matemáticas y operadores. Estas operaciones matemáticas se definen sobre una clase de valores numéricos suficientemente amplia como para permitir definiciones apropiadas para enteros, números de punto flotante, racionales y complejos, dondequiera que tales definiciones tengan sentido.



Además, estas funciones (como cualquier función de Julia) se pueden aplicar de manera {\textquotedbl}vectorizada{\textquotedbl} a matrices y otras colecciones con la \hyperlink{13590013989415065742}{sintaxis vectorizada} \texttt{f.(A)}, por ejemplo, sin.(A) calculará el seno de cada elemento de una matriz \texttt{A}. 



\hypertarget{7500087798079418771}{}


\section{Precedencia de Operadores}



Julia applies the following order of operations, from highest precedence to lowest:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Categorí       & Operadores                                                                                        \\
\hline
Syntax & \texttt{.} seguido por \texttt{::} \\
\hline
Exponentiation & \texttt{{\textasciicircum}} \\
\hline
Fractions & \texttt{//} \\
\hline
Multiplication & \texttt{* / \% \& {\textbackslash}} \\
\hline
Bitshifts & \texttt{<< >> >>>} \\
\hline
Addition & \texttt{+ - | ⊻} \\
\hline
Syntax & \texttt{: ..} seguido por \texttt{|>} \\
\hline
Comparisons & \texttt{> < >= <= == === != !== <:} \\
\hline
Control flow & \texttt{\&\&} seguido por \texttt{||} seguido por \texttt{?} \\
\hline
Assignments & \texttt{= += -= *= /= //= {\textbackslash}= {\textasciicircum}= ÷= \%= |= \&= ⊻= <<= >>= >>>=} \\
\hline
\end{tabulary}

\end{table}



Para una lista completa de cada una de las precedencias de operadores de Julia, consultar el fichero \href{https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm}{\texttt{src/julia-parser.scm}}



También puede encontrarse la precedencia numérica pra cualquier operación dada mediante la función intrínseca \texttt{Base.operator\_precedence} donde el número mayor corresponde a la operación con mayor precedencia.




\begin{minted}{jlcon}
julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(9, 11, 15)

julia> Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(1, 1)
\end{minted}



\hypertarget{6654486840782085972}{}


\section{Conversiones Numéricas}



Julia soporta tres formas de conversión numérica, que difieren en su manejo de las conversiones inexactas.



\begin{itemize}
\item La notación \texttt{T(x)} o \texttt{convert(T,x)} convierte \texttt{x} a un valor de tipo \texttt{T}.

\begin{itemize}
\item Si \texttt{T} es un tipo en punto flotante, el resultado es el valor más cercano representable, que podría ser infinito positivo o negativo.


\item Si \texttt{T} es un tipo entero, se lanzará un \texttt{InexactError} si \texttt{x}no es representable por \texttt{T}.

\end{itemize}

\item \texttt{x \% T}convierte un entero \texttt{x} a un valor de un tipo entero \texttt{T} congruente a \texttt{x} modulo \texttt{2{\textasciicircum}n}, donde \texttt{n} es el número de bits en \texttt{T}. En otras palabras, la representación binaria es truncada para ajustarse.


\item Las \hyperlink{7716310024856559840}{Funciones de Redondeo} toman un tipo \texttt{T} como argumento opcional. Por ejemplo, \texttt{round(Int,x)} es una abreviatura de \texttt{Int(round(x))}.

\end{itemize}


Los siguientes ejemplos muestran las siguientes formas:




\begin{minted}{jlcon}
julia> Int8(127)
127

julia> Int8(128)
ERROR: InexactError()
Stacktrace:
 [1] Int8(::Int64) at ./sysimg.jl:77

julia> Int8(127.0)
127

julia> Int8(3.14)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int8}, ::Float64) at ./float.jl:658
 [2] Int8(::Float64) at ./sysimg.jl:77

julia> Int8(128.0)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int8}, ::Float64) at ./float.jl:658
 [2] Int8(::Float64) at ./sysimg.jl:77

julia> 127 % Int8
127

julia> 128 % Int8
-128

julia> round(Int8,127.4)
127

julia> round(Int8,127.6)
ERROR: InexactError()
Stacktrace:
 [1] trunc(::Type{Int8}, ::Float64) at ./float.jl:651
 [2] round(::Type{Int8}, ::Float64) at ./float.jl:337
\end{minted}



Ver \hyperlink{10686378388163930476}{Conversión y Promoción} para ver cómo definir tus propias conversiones y promociones.



\hypertarget{7716310024856559840}{}


\subsection{Funciones de Redondeo}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Función              & Descripción                       & Tipo devuelto \\
\hline
\hyperlink{7894166454005036294}{\texttt{round(x)}} & Redondea \texttt{x} al entero más cercano & \texttt{typeof(x)} \\
\hline
\hyperlink{7894166454005036294}{\texttt{round(T, x)}} & Redondea \texttt{x} al entero más cercano & \texttt{T} \\
\hline
\hyperlink{13948277906659863497}{\texttt{floor(x)}} & Redondea \texttt{x} hacia \texttt{-Inf} & \texttt{typeof(x)} \\
\hline
\hyperlink{13948277906659863497}{\texttt{floor(T, x)}} & Redondea \texttt{x} hacia \texttt{-Inf} & \texttt{T} \\
\hline
\hyperlink{11509984064218511874}{\texttt{ceil(x)}} & Redondea \texttt{x} hacia \texttt{+Inf} & \texttt{typeof(x)} \\
\hline
\hyperlink{11509984064218511874}{\texttt{ceil(T, x)}} & Redondea \texttt{x} hacia \texttt{+Inf} & \texttt{T} \\
\hline
\hyperlink{7412479111462927551}{\texttt{trunc(x)}} & Redondea \texttt{x} hacia cero & \texttt{typeof(x)} \\
\hline
\hyperlink{7412479111462927551}{\texttt{trunc(T, x)}} & Redondea \texttt{x} hacia cero & \texttt{T} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{3212114314897108312}{}


\subsection{Funciones de División}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Función              & Descripción                                                                                        \\
\hline
\hyperlink{8020976424566491334}{\texttt{div(x,y)}} & División truncada; cociente redondeado hacia cero \\
\hline
\hyperlink{15067916827074788527}{\texttt{fld(x,y)}} & División \emph{floored}; cociente redondeado hacia \texttt{-Inf} \\
\hline
\hyperlink{7922388465305816555}{\texttt{cld(x,y)}} & División \emph{ceiling}; cociente redondeado hacia \texttt{+Inf} \\
\hline
\hyperlink{3827563084771191385}{\texttt{rem(x,y)}}   & Resto; satisface \texttt{x == div(x,y)*y + rem(x,y)}; el signo se corresponde con el de \texttt{x}               \\
\hline
\hyperlink{2082041235715276573}{\texttt{mod(x,y)}} & Módulo; satisface \texttt{x == fld(x,y)*y + mod(x,y)}; el signo se corresponde con el de \texttt{y} \\
\hline
\hyperlink{13778479217547823795}{\texttt{mod1(x,y)}} & Módulo con un desplazamiento de 1; devuelve \texttt{r∈(0,y]} para \texttt{y>0} o \texttt{r∈[y,0)} para \texttt{y<0}, donde \texttt{mod(r, y) == mod(x, y)} \\
\hline
\hyperlink{15322754370885673769}{\texttt{mod2pi(x)}} & Módulo con respecto a 2pi; \texttt{0 <= mod2pi(x)  < 2pi} \\
\hline
\hyperlink{6106909621813654214}{\texttt{divrem(x,y)}} & Devuelve \texttt{(div(x,y),rem(x,y))} \\
\hline
\hyperlink{2806360720034558325}{\texttt{fldmod(x,y)}} & Devuelve \texttt{(fld(x,y),mod(x,y))} \\
\hline
\hyperlink{15906911311436241979}{\texttt{gcd(x,y...)}} & Máximo común divisor positivo de \texttt{x}, \texttt{y},... \\
\hline
\hyperlink{12975400110924105221}{\texttt{lcm(x,y...)}} & Mínimo común múltiplo positivo de \texttt{x}, \texttt{y},... \\
\hline
\end{tabulary}

\end{table}



\hypertarget{13638006402813685584}{}


\subsection{Funciones de signo y valor absoluto}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Función                & Descripción                                               \\
\hline
\hyperlink{9614495866226399167}{\texttt{abs(x)}} & Un valor positivo con la magnitud de \texttt{x} \\
\hline
\hyperlink{15686257922156163743}{\texttt{abs2(x)}} & El cuadrado de la magnitud de \texttt{x} \\
\hline
\hyperlink{14349105033929355161}{\texttt{sign(x)}} & Indica el signo de \texttt{x}, devolviendo -1, 0, o +1 \\
\hline
\hyperlink{9457038569823603490}{\texttt{signbit(x)}} & Indica que si el bit de signo está en \textbf{on} (\texttt{true}) o en \textbf{off} (\texttt{false}) \\
\hline
\hyperlink{6024566200716053110}{\texttt{copysign(x,y)}} & Indica un valor con la magnitud de \texttt{x} y el signo de \texttt{y}   \\
\hline
\hyperlink{2689022981470151558}{\texttt{flipsign(x,y)}} & Indica un valor con la magnitud de \texttt{x} y el signo de \texttt{x*y} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12769978340812816097}{}


\subsection{Potencias, logaritmos y raíces}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Función & Descripción \\
\hline
\hyperlink{4178506499510800909}{\texttt{sqrt(x)}}, \texttt{√x} & Raíz cuadrada de \texttt{x}                                                      \\
\hline
\hyperlink{15104025502404840355}{\texttt{cbrt(x)}}, \texttt{∛x} & Raíz cúbica de \texttt{x}                                                         \\
\hline
\hyperlink{18304489571285447949}{\texttt{hypot(x,y)}} & Hipotenusa del triángulo rectángulo cuyos catetos son de longitudes \texttt{x} e \texttt{y} \\
\hline
\hyperlink{5754159997488499390}{\texttt{exp(x)}}         & Función exponencial natural sobre \texttt{x}                                     \\
\hline
\hyperlink{4939309737829480377}{\texttt{expm1(x)}} & Valor exacto de \texttt{exp(x)-1} para  \texttt{x} cercano a zero \\
\hline
\hyperlink{14721177606508229464}{\texttt{ldexp(x,n)}} & \texttt{x*2{\textasciicircum}n} calculado eficientemente para valores enteros de \texttt{n} \\
\hline
\hyperlink{8009828793607756367}{\texttt{log(x)}} & Logaritmo neperiano de \texttt{x} \\
\hline
\hyperlink{8009828793607756367}{\texttt{log(b,x)}} & Logaritmo en base \texttt{b} de \texttt{x} \\
\hline
\hyperlink{18341149201477905713}{\texttt{log2(x)}} & Logaritmo en base 2 de \texttt{x} \\
\hline
\hyperlink{3481560771470480868}{\texttt{log10(x)}} & Logaritmo decimal de \texttt{x} \\
\hline
\hyperlink{5533050447473188877}{\texttt{log1p(x)}} & Valor exacto de \texttt{log(1+x)} para \texttt{x} cercano a cero \\
\hline
\hyperlink{39736318364195845}{\texttt{exponent(x)}} & Exponente binario de  \texttt{x} \\
\hline
\hyperlink{11312242195671521747}{\texttt{significand(x)}} & Significando binario (alias \emph{mantisa}) de un número en punto flotante \texttt{x} \\
\hline
\end{tabulary}

\end{table}



Para una explicación de por qué son necesarias funciones como \hyperlink{18304489571285447949}{\texttt{hypot()}}, \hyperlink{4939309737829480377}{\texttt{expm1()}}, and \hyperlink{5533050447473188877}{\texttt{log1p()}}, véase el excelente par de artículos en el blog de John D. Cook{\textquotesingle}s sobre el tema: \href{https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/}{expm1, log1p, erfc}, e \href{https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/}{hypot}.



\hypertarget{15332949081998190776}{}


\subsection{Funciones Trigonométricas e Hiperbólicas}



Todas las funciones trigonométricas e hiperbólicas estándar están también definidas:




\begin{lstlisting}
sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc   atan2
\end{lstlisting}



Son todas funciones de un solo argumento, con la excepción de  \href{https://en.wikipedia.org/wiki/Atan2}{atan2}, que da el ángulo en \href{https://en.wikipedia.org/wiki/Radian}{radians} entre el eje \emph{x} y el punto especificado por sus argumentos, interpretado como sus coordenadas \emph{x} e \emph{y}.



Adicionalmente, se proporcionan \hyperlink{16554510911661822298}{\texttt{sinpi(x)}} e \hyperlink{2974547424856180253}{\texttt{cospi(x)}} para cálculos más exactos de \hyperlink{1413692256182243634}{\texttt{sin(pi*x)}} y \hyperlink{3839439755891439510}{\texttt{cos(pi*x)}} respectivamente.



Para computar funciones trigonométricas con grados en lugar de con rdianes, añada al nombre de la función el sufijo \texttt{d}. Por ejemplo, \hyperlink{38337471195460170}{\texttt{sind(x)}} calcula el seno de \texttt{x}, donde \texttt{x} se especifica en grados. La lista completa de funciones trigonométricas con variantes grados es:




\begin{lstlisting}
sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd
\end{lstlisting}



\hypertarget{2071051749003726620}{}


\subsection{Funciones Especiales}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Función               & Descripción \\
\hline
\hyperlink{12101057483100859108}{\texttt{gamma(x)}}   & \href{https://en.wikipedia.org/wiki/Gamma\_function}{Función gamma} en \texttt{x} \\
\hline
\hyperlink{16944460120463679422}{\texttt{lgamma(x)}} & Valor exacto de \texttt{log(gamma(x))} para valores grandes de \texttt{x} \\
\hline
\hyperlink{15642673718348524569}{\texttt{lfact(x)}} & Valor exacto de  \texttt{log(factorial(x))} para valores grandes de  \texttt{x}; igual que \texttt{lgamma(x+1)} para \texttt{x > 1}, cero en otros caso \\
\hline
\hyperlink{3070115649335374621}{\texttt{beta(x,y)}}   & \href{https://en.wikipedia.org/wiki/Beta\_function}{Función beta} en \texttt{x,y} \\
\hline
\hyperlink{15599420217619146595}{\texttt{lbeta(x,y)}} & Valor exacto de  \texttt{log(beta(x,y))} para valores grandes de \texttt{x} o \texttt{y} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{57238021523210895}{}


\chapter{Números Racionales y Complejos}



Julia se distribuye con tipos predefinidos que representan números complejos y racionales, y soporta todas las \hyperlink{16655087771805204817}{Operaciones Matemáticas y Funciones Elementales} estándar sobre ellos. Se han definido \hyperlink{10686378388163930476}{conversiones y promociones} de modo que las operaciones con cualquier combinación de tipos numéricos predefinidos, primitivos o compuestos, se comporten como se esperaba.



como se esperaba.



\hypertarget{17137958748126161191}{}


\section{Números Complejos}



La constante global \hyperlink{15097910740298861288}{\texttt{im}} está ligada al número complejo \emph{i}, que representa la raíz cuadrada principal de -1. Se consideró nocivo para co-optar el nombre \texttt{i} para una constante global, ya que es un nombre de variable de índice popular. Como Julia permite que los literales numéricos se \hyperlink{14058350023597195643}{yuxtapongan con identificadores como coeficientes}, esta unión es suficiente para proporcionar sintaxis conveniente para números complejos, similar a la notación matemática tradicional:




\begin{minted}{jlcon}
julia> 1 + 2im
1 + 2im
\end{minted}



Podemos realizar todas las operaciones aritméticas estándar con los números complejos:




\begin{minted}{jlcon}
julia> (1 + 2im)*(2 - 3im)
8 + 1im

julia> (1 + 2im)/(1 - 2im)
-0.6 + 0.8im

julia> (1 + 2im) + (1 - 2im)
2 + 0im

julia> (-3 + 2im) - (5 - 1im)
-8 + 3im

julia> (-1 + 2im)^2
-3 - 4im

julia> (-1 + 2im)^2.5
2.7296244647840084 - 6.960664459571898im

julia> (-1 + 2im)^(1 + 1im)
-0.27910381075826657 + 0.08708053414102428im

julia> 3(2 - 5im)
6 - 15im

julia> 3(2 - 5im)^2
-63 - 60im

julia> 3(2 - 5im)^-1.0
0.20689655172413796 + 0.5172413793103449im
\end{minted}



El mecanismo de promoción asegura qur las combinaciones de operandos de distintos tipos funcionarán:




\begin{minted}{jlcon}
julia> 2(1 - 1im)
2 - 2im

julia> (2 + 3im) - 1
1 + 3im

julia> (1 + 2im) + 0.5
1.5 + 2.0im

julia> (2 + 3im) - 0.5im
2.0 + 2.5im

julia> 0.75(1 + 2im)
0.75 + 1.5im

julia> (2 + 3im) / 2
1.0 + 1.5im

julia> (1 - 3im) / (2 + 2im)
-0.5 - 1.0im

julia> 2im^2
-2 + 0im

julia> 1 + 3/4im
1.0 - 0.75im
\end{minted}



Nótese que \texttt{3/4im == 3/(4*im) == -(3/4*im)}, ya que un coeficiente literal se enlaza más fuerte que la división.



También se proporcionan las funciones estándar para manipular valores complejos:




\begin{minted}{jlcon}
julia> z = 1 + 2im
1 + 2im

julia> real(1 + 2im) # real part of z
1

julia> imag(1 + 2im) # imaginary part of z
2

julia> conj(1 + 2im) # complex conjugate of z
1 - 2im

julia> abs(1 + 2im) # absolute value of z
2.23606797749979

julia> abs2(1 + 2im) # squared absolute value
5

julia> angle(1 + 2im) # phase angle in radians
1.1071487177940904
\end{minted}



Como de costumbre, el valor absoluto (\hyperlink{9614495866226399167}{\texttt{abs()}}) de un número complejo es su distancia a cero. \hyperlink{15686257922156163743}{\texttt{abs2()}} da el cuadrado del valor absoluto, y es de uso particular para los números complejos donde se evita tomar una raíz cuadrada. \hyperlink{9465547375318501186}{\texttt{angle()}} devuelve el ángulo de fase en radianes (también conocido como \emph{argumento} o función \emph{arg}). La gama completa de otras \hyperlink{17395527405393843522}{funciones elementales} está también definida para los números complejos:




\begin{minted}{jlcon}
julia> sqrt(1im)
0.7071067811865476 + 0.7071067811865475im

julia> sqrt(1 + 2im)
1.272019649514069 + 0.7861513777574233im

julia> cos(1 + 2im)
2.0327230070196656 - 3.0518977991518im

julia> exp(1 + 2im)
-1.1312043837568135 + 2.4717266720048188im

julia> sinh(1 + 2im)
-0.4890562590412937 + 1.4031192506220405im
\end{minted}



Tenga en cuenta que las funciones matemáticas normalmente devuelven valores reales cuando se aplican a números reales y valores complejos cuando se aplican a números complejos. Por ejemplo, \hyperlink{4178506499510800909}{\texttt{sqrt()}} se comporta de forma diferente cuando se aplica a \texttt{-1} que cuanso se aplica sobre \texttt{-1 + 0im}, aunque \texttt{-1 == -1 + 0im}:




\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Int64) at ./math.jl:434

julia> sqrt(-1 + 0im)
0.0 + 1.0im
\end{minted}



La \hyperlink{14058350023597195643}{notación de coeficiente numérico literal} no funciona cuando se construye un número complejo a partir de variables. En su lugar, la multiplicación debe expresarse explícitamente:




\begin{minted}{jlcon}
julia> a = 1; b = 2; a + b*im
1 + 2im
\end{minted}



Sin embargo, esto no es lo recomendable; En su lugar, utilice la función \hyperlink{16014240202095271744}{\texttt{complex()}} para construir un valor complejo directamente de sus partes real e imaginaria:




\begin{minted}{jlcon}
julia> a = 1; b = 2; complex(a, b)
1 + 2im
\end{minted}



Esta construcción evita las operaciones de multiplicación y adición.



\hyperlink{1907914141659611007}{\texttt{Inf}} y \hyperlink{11449618129446476597}{\texttt{NaN}} se propagan a través de números complejos en las partes real e imaginaria de un número complejo como se describe en la sección \hyperlink{8368313158411015136}{valores especiales en punto flotante} section:




\begin{minted}{jlcon}
julia> 1 + Inf*im
1.0 + Inf*im

julia> 1 + NaN*im
1.0 + NaN*im
\end{minted}



\hypertarget{12093481009248886258}{}


\section{Números Racionales}



Julia tiene un tipo numérico racional para representar razones exactas de enteros. Los racionales se construyen usando el operador \hyperlink{17539582191808611917}{\texttt{//}}:




\begin{minted}{jlcon}
julia> 2//3
2//3
\end{minted}



Si el numerador y el denominador de un racional tienen factores comunes, ellos son reducidos a los términos mínimos tales que el denominador sea no negativo:




\begin{minted}{jlcon}
julia> 6//9
2//3

julia> -4//8
-1//2

julia> 5//-15
-1//3

julia> -4//-12
1//3
\end{minted}



Esta forma normalizada para una razón de enteros es única, por lo que la igualdad de valores racionales puede ser testada comprobando la igualdad del numerador y el denominador. El numerador estandarizado y el denominador de un valor racional pueden ser extraídos usando las funciones \hyperlink{7885506453580572157}{\texttt{numerator()}} y \hyperlink{12407209279719593434}{\texttt{denominator()}}:




\begin{minted}{jlcon}
julia> numerator(2//3)
2

julia> denominator(2//3)
3
\end{minted}



La comparación directa de numerador y denominador no suele ser necesaria, ya que la aritmetica  estándar y las operaciones de comparación están definidas para los valores racionales:




\begin{minted}{jlcon}
julia> 2//3 == 6//9
true

julia> 2//3 == 9//27
false

julia> 3//7 < 1//2
true

julia> 3//4 > 2//3
true

julia> 2//4 + 1//6
2//3

julia> 5//12 - 1//4
1//6

julia> 5//8 * 3//12
5//32

julia> 6//5 / 10//7
21//25
\end{minted}



Los racionales pueden convertirse fácilmente en número en punto flotante:




\begin{minted}{jlcon}
julia> float(3//4)
0.75
\end{minted}



La conversión de racional a punto flotante respeta la siguiente identidad para dos valores enteros cualesquiera \texttt{a} y \texttt{b}, con las excepciones de los casos \texttt{a == 0} and \texttt{b == 0}:




\begin{minted}{jlcon}
julia> a = 1; b = 2;

julia> isequal(float(a//b), a/b)
true
\end{minted}



Construir valores racionales infinitos es aceptable:




\begin{minted}{jlcon}
julia> 5//0
1//0

julia> -3//0
-1//0

julia> typeof(ans)
Rational{Int64}
\end{minted}



Sin embargo, no lo es tratar de construir un valor NaN \hyperlink{11449618129446476597}{\texttt{NaN}} racional:




\begin{minted}{jlcon}
julia> 0//0
ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)
Stacktrace:
 [1] Rational{Int64}(::Int64, ::Int64) at ./rational.jl:13
 [2] //(::Int64, ::Int64) at ./rational.jl:40
\end{minted}



Como es natural, el sistema de promoción hace que las interacciones con otros tipos numéricos se hagan sin esfuerzo alguno:




\begin{minted}{jlcon}
julia> 3//5 + 1
8//5

julia> 3//5 - 0.5
0.09999999999999998

julia> 2//7 * (1 + 2im)
2//7 + 4//7*im

julia> 2//7 * (1.5 + 2im)
0.42857142857142855 + 0.5714285714285714im

julia> 3//2 / (1 + 2im)
3//10 - 3//5*im

julia> 1//2 + 2im
1//2 + 2//1*im

julia> 1 + 2//3im
1//1 - 2//3*im

julia> 0.5 == 1//2
true

julia> 0.33 == 1//3
false

julia> 0.33 < 1//3
true

julia> 1//3 - 0.33
0.0033333333333332993
\end{minted}



\hypertarget{3772396547767597421}{}


\chapter{Strings}



Las cadenas son secuencias finitas de caracteres. Por supuesto, el verdadero problema viene cuando uno se pregunta qué es un carácter. Los caracteres con los que están familiarizados con los hablantes de inglés son las letras \texttt{A}, \texttt{B}, \texttt{C}, etc., junto con los números y los símbolos de puntuación comunes. Estos caracteres se estandarizan junto con una correspondencia a valores enteros entre 0 y 127 a través del estándar ASCII. Hay, por supuesto, muchos otros caracteres utilizados en lenguas no  inglesas, incluyendo variantes de los caracteres ASCII con acentos y otras modificaciones, escrituras relacionadas como cirílico y griego, y escrituras no relacionadas en abosluto con ASCII o inglés, entre los que se incluyen árabe, chino, Hebreo, hindi, japonés y coreano. El estándar \href{https://en.wikipedia.org/wiki/Unicode}{Unicode} aborda las complejidades de lo que es exactamente un carácter, y es generalmente aceptado como el estándar definitivo que aborda este problema. Dependiendo de tus necesidades, puedes ignorar estas complejidades por completo y fingir que sólo existen caracteres ASCII, o puedes escribir código que pueda manejar cualquiera de los caracteres o codificaciones que se pueden encontrar al manejar texto no ASCII. Julia hace que el manejo de texto ASCII sencillo sea simple y eficiente, y el manejo de Unicode tan simple y eficiente como sea posible. En particular, puedes escribir código de cadenas con estilo C para procesar cadenas ASCII y funcionarán como se esperaba, tanto en términos de rendimiento como de semántica. Si dicho código encuentra texto no ASCII, fallará  graciosamente con un mensaje de error claro, en lugar de introducir en silencio resultados corruptos. Cuando esto sucede, modificar el código para manejar datos no ASCII es sencillo.



Hay algunas características destacadas de alto nivel sobre las cadenas de caracteres en Julia:



\begin{itemize}
\item El tipo de concreto incorporado utilizado para cadenas (y literales de cadena) en Julia es \hyperlink{2825695355940841177}{\texttt{String}}. Esto soporta el rango completo de caracteres  \href{https://en.wikipedia.org/wiki/Unicode}{Unicode} a través de  la codificación \href{https://en.wikipedia.org/wiki/UTF-8}{UTF-8}. (se proporciona una función \hyperlink{11147209877072452260}{\texttt{transcode()}}   para convertir a/desde otras codificaciones Unicode).


\item Todos los tipos de cadenas son subtipos del tipo abstracto \texttt{AbstractString} y los paquetes  externos definen subtipos \texttt{AbstractString} adicionales (por ejemplo, para otras codificaciones).  Si define una función que espera un argumento de cadena, debe declarar el tipo como  \texttt{AbstractString} para aceptar cualquier tipo de cadena.


\item Como C y Java, pero a diferencia de la mayoría de los lenguajes dinámicos, Julia tiene un tipo  de primera clase que representa un solo carácter, llamado \texttt{Char}. Esto es sólo un tipo especial  de bits de 32 bits cuyo valor numérico representa un punto de código Unicode.


\item Como en Java, las cadenas son inmutables: el valor de un objeto \texttt{AbstractString} no se puede  cambiar. Para construir un valor de cadena diferente, se construye una nueva cadena de partes  de otras cadenas.


\item Conceptualmente, una cadena es una \emph{función parcial} de índices a caracteres: para algunos  valores de índice, no se devuelve ningún valor de carácter y, en su lugar, se genera una  excepción. Esto permite una indexación eficiente en cadenas por el índice de bytes de una  representación codificada en lugar de por un índice de caracteres, que no se puede implementar  de manera eficiente y sencilla para encodificaciones de anchura variable de cadenas Unicode.

\end{itemize}


\hypertarget{11743000381881707413}{}


\section{Caracteres}



Un valor \texttt{Char} representa un solo carácter: es sólo un \emph{bitstype} de 32 bits con una representación literal especial y comportamientos aritméticos apropiados, cuyo valor numérico se interpreta como un \href{https://en.wikipedia.org/wiki/Code\_point}{punto de código Unicode}. Aquí se muestra cómo se introducen y se muestran los valores \texttt{Char}:




\begin{minted}{jlcon}
julia> 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> typeof(ans)
Char
\end{minted}



Podemos convertir un \texttt{Char} a su valor entero (su punto de código) fácilmente:




\begin{minted}{jlcon}
julia> Int('x')
120

julia> typeof(ans)
Int64
\end{minted}



En arquitecturas de 32 bits,  \hyperlink{13440452181855594120}{\texttt{typeof(ans)}} será \hyperlink{10103694114785108551}{\texttt{Int32}}. Puede convertir un valor entero de nuevo a un \texttt{Char} fácilmente:




\begin{minted}{jlcon}
julia> Char(120)
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
\end{minted}



No todos los valores enteros son puntos de código Unicode válidos, pero por una cuestión de  rendimiento, la conversión \texttt{Char()} no comprueba que cada valor de carácter sea válido. Si desea comprobar que cada valor convertido es un punto de código válido, utilice la función \hyperlink{9678448882095016755}{\texttt{isvalid()}}:




\begin{minted}{jlcon}
julia> Char(0x110000)
'\U110000': Unicode U+110000 (category Cn: Other, not assigned)

julia> isvalid(Char, 0x110000)
false
\end{minted}



A partir de este momento, los puntos de código Unicode válidos son \texttt{U+00} a \texttt{U+d7ff} y \texttt{U+e000} a \texttt{U+10ffff}. A estos no se les han asignado todavía significados inteligibles, ni son necesariamente interpretables por las aplicaciones, pero todos ellos se consideran caracteres Unicode válidos.



Puede introducir cualquier carácter Unicode entre comillas simples utilizando \texttt{{\textbackslash}u} seguido de hasta cuatro dígitos hexadecimales o \texttt{{\textbackslash}U} seguido de hasta ocho dígitos hexadecimales (el valor válido más largo sólo requiere seis):




\begin{minted}{jlcon}
julia> '\u0'
'\0': ASCII/Unicode U+0000 (category Cc: Other, control)

julia> '\u78'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> '\u2200'
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia> '\U10ffff'
'\U10ffff': Unicode U+10ffff (category Cn: Other, not assigned)
\end{minted}



Julia utiliza la configuración regional y de idioma de tu sistema para determinar qué caracteres se pueden imprimir tal cual y cuáles se deben imprimir utilizando las formas de entrada genéricas, escapadas con \texttt{{\textbackslash}u} o \texttt{{\textbackslash}U}. Además de estas formas de escape de Unicode, también se pueden usar todas las \href{https://en.wikipedia.org/wiki/C\_syntax\#Backslash\_escapes}{formas de entrada de escape tradicionales de C}:




\begin{minted}{jlcon}
julia> Int('\0')
0

julia> Int('\t')
9

julia> Int('\n')
10

julia> Int('\e')
27

julia> Int('\x7f')
127

julia> Int('\177')
127

julia> Int('\xff')
255
\end{minted}



Puedes hacer comparaciones y una cantidad limitada de aritmética con los valores \texttt{Char}:




\begin{minted}{jlcon}
julia> 'A' < 'a'
true

julia> 'A' <= 'a' <= 'Z'
false

julia> 'A' <= 'X' <= 'Z'
true

julia> 'x' - 'a'
23

julia> 'A' + 1
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)
\end{minted}



\hypertarget{5982376778832702050}{}


\section{Fundamentos de Cadenas}



Los literales de cadenas están delimitados por comillas dobles o comillas dobles triples:




\begin{lstlisting}
julia> str = "Hello, world.\n"
"Hello, world.\n"

julia> """Contains "quote" characters"""
"Contains \"quote\" characters"
\end{lstlisting}



Si desea extraer un carácter de una cadena, indéxelo:




\begin{lstlisting}
julia> str[1]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia> str[6]
',': ASCII/Unicode U+002c (category Po: Punctuation, other)

julia> str[end]
'\n': ASCII/Unicode U+000a (category Cc: Other, control)
\end{lstlisting}



Toda la indexación en Julia está basada en 1: el primer elemento de cualquier objeto indexado medidante enteros se encuentra en el índice \texttt{1}, y el último elemento se encuentra en el índice \texttt{n}, cuando la cadena tiene una longitud de \texttt{n}.



En cualquier expresión de indexación, puede usarse la palabra clave \texttt{end} como una abreviatura para el último índice (calculado mediante \hyperlink{7288835006555308491}{\texttt{endof(str)}}). Puede realizar operaciones aritméticas y otras con \texttt{end}, como si de un valor normal se tratara:




\begin{lstlisting}
julia> str[end-1]
'.': ASCII/Unicode U+002e (category Po: Punctuation, other)

julia> str[end÷2]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
\end{lstlisting}



Usar un índice menor que 1 o mayor que \texttt{end} lanza un error:




\begin{lstlisting}
julia> str[0]
ERROR: BoundsError: attempt to access "Hello, world.\n"
  at index [0]
[...]

julia> str[end+1]
ERROR: BoundsError: attempt to access "Hello, world.\n"
  at index [15]
[...]
\end{lstlisting}



También puedes extraer una subcadena usando indexación mediante un rango:




\begin{lstlisting}
julia> str[4:9]
"lo, wo"
\end{lstlisting}



Nótese que las expresiones \texttt{str[k]} y \texttt{str[k:k]} no dan el mismo resultado:




\begin{lstlisting}
julia> str[6]
',': ASCII/Unicode U+002c (category Po: Punctuation, other)

julia> str[6:6]
","
\end{lstlisting}



La primera es un valor carácter de tipo \texttt{Char}, mientras que la segunda es un valor cadena que tiene un único carácter. En Julia se trata de cosas muy diferentes.



\hypertarget{535290508865367512}{}


\section{Unicode y UTF-8}



Julia soporta totalmente caracteres y cadenas Unicode. Como se ha \hyperlink{11743000381881707413}{comentado anteriormente}, en literales de caracteres, los puntos de código Unicode se pueden representar usando las secuencias de escape Unicode \texttt{{\textbackslash}u} y \texttt{{\textbackslash}U}, así como todas las secuencias de escape C estándar. Éstos también se pueden utilizar para escribir literales de cadena:




\begin{lstlisting}
julia> s = "\u2200 x \u2203 y"
"∀ x ∃ y"
\end{lstlisting}



Si estos caracteres Unicode se muestran como escapes o se muestran como caracteres especiales depende de la configuración regional de tu terminal y su compatibilidad con Unicode. Los literales de cadena se codifican utilizando la codificación UTF-8. UTF-8 es una codificación de ancho variable, lo que significa que no todos los caracteres están codificados en el mismo número de bytes. En UTF-8, los caracteres ASCII -es decir, aquellos con puntos de código inferiores a 0x80 (128) - están codificados como lo están en ASCII, usando un solo byte, mientras que los puntos de código 0x80 y superiores se codifican utilizando múltiples bytes (hasta cuatro por carácter). Esto significa que no todos los índices de bytes en una cadena UTF-8 es necesariamente un índice válido para un carácter. Si indexas una cadena en un índice de bytes no válido, se genera un error:




\begin{lstlisting}
julia> s[1]
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia> s[2]
ERROR: UnicodeError: invalid character index
[...]

julia> s[3]
ERROR: UnicodeError: invalid character index
[...]

julia> s[4]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
\end{lstlisting}



En este caso, el carácter \texttt{∀} es un carácter de tres bytes, por lo que los índices 2 y 3 no son válidos y el índice del siguiente carácter es 4; este siguiente índice válido puede ser calculado con \hyperlink{7455293228649070526}{\texttt{nextind(s,1)}}, y el siguiente índice después de éste con \texttt{nextind(s,4)} y así sucesivamente.



Debido a las codificaciones de longitud variable, el número de caracteres de una cadena (dada por \hyperlink{4781133548011803693}{\texttt{length(s)}}) no siempre lo mismo que el último índice. Si se itera a través de los índices 1 hasta \hyperlink{7288835006555308491}{\texttt{endof(s)}} y se indexa en \texttt{s}, la secuencia de caracteres devueltos cuando no se lanzan errores es la secuencia de caracteres que contiene la cadena \texttt{s}. Por tanto, tenemos la identidad de que \texttt{length(s) <= endof(s)}, ya que cada carácter en una cadena debe tener su propio índice. La siguiente es una forma ineficaz y verbosa de iterar a través de los caracteres de \texttt{s}:




\begin{lstlisting}
julia> for i = 1:endof(s)
           try
               println(s[i])
           catch
               # ignore the index error
           end
       end
∀

x

∃

y
\end{lstlisting}



Las líneas en blanco en realidad tienen espacios en ellos. Afortunadamente, el idioma anterior incómodo es innecesario para iterar a través de los caracteres de una cadena, ya que se puede utilizar la cadena como un objeto iterable, sin que se requiera el manejo de excepciones:




\begin{lstlisting}
julia> for c in s
           println(c)
       end
∀

x

∃

y
\end{lstlisting}



Julia utiliza la codificación UTF-8 de forma predeterminada y el soporte para nuevas codificaciones puede agregarse mediante paquetes. Por ejemplo, el paquete \href{https://github.com/JuliaArchive/LegacyStrings.jl}{LegacyStrings.jl} implementa los tipos \texttt{UTF16String} y \texttt{UTF32String}. Una mayor discusión sobre otras codificaciones y cómo implementar el soporte para ellas está más allá del alcance de este documento por el momento. Para más información sobre los problemas de codificación UTF-8, consulte la sección siguiente sobre \hyperlink{14271532611053373881}{literales byte array}. La función \hyperlink{11147209877072452260}{\texttt{transcode()}} se proporciona para convertir datos entre las distintas codificaciones UTF-xx, principalmente para trabajar con datos y bibliotecas externas.



\hypertarget{15471840748923719409}{}


\section{Concatenación}



Una de las operaciones de cadena más comunes y útiles es la concatenación:




\begin{lstlisting}
julia> greet = "Hello"
"Hello"

julia> whom = "world"
"world"

julia> string(greet, ", ", whom, ".\n")
"Hello, world.\n"
\end{lstlisting}



Julia también proporciona el operador \texttt{*} para concatenar cadenas:




\begin{lstlisting}
julia> greet * ", " * whom * ".\n"
"Hello, world.\n"
\end{lstlisting}



Aunque \texttt{*} puede parecer una elección sorprendente a los usuarios de lenguajes que proporcionan \texttt{+} para concatenación de cadenas, este uso de \texttt{*}tiene precedentes en matemáticas, particularmente en álgebra abstracta.



En matemáticas, \texttt{+} suele denotar una operación \emph{conmutativa}, donde el orden de los operandos no importa. Un ejemplo de esto es la suma de matrices, donde \texttt{A + B == B + A} para dos matrices cualesquiera \texttt{A} y \texttt{B} que tengan la misma forma. En contraste, \texttt{*} suele denotar una operación no conmutativa, donde el orden de los operandos \emph{importa}. Un ejemplo de esto es la multiplicación de matrices donde, en general, \texttt{A * B != B * A}. Como con la multiplicación de matrices, la concatenación es no conmutativa: \texttt{greet * whom != whom * greet}. Por tanto, \texttt{*} es una elección más natural para el operador infijo de concatenación, consistente con el uso matemático común.



Más precisamente, el conjunto de todas las cadenas \emph{S} de longitud finita junto con el operador de concatenación \texttt{*} forman un \href{https://en.wikipedia.org/wiki/Free\_monoid}{monoide libre} (S, \texttt{*}). El elemento identidad de este conjunto es la cadena vacía {\textquotedbl}{\textquotedbl}. Siempre que un monoide libre es no conmutativo, la operación suele ser representada por \texttt{{\textbackslash}cdot}, \texttt{*}, o un símbolo similar, en luga de con \texttt{+} que implica conmutatividad.



\hypertarget{12583298261221600612}{}


\section{Interpolación}



Construir cadenas mediante concatenación puede llegar a ser un poco engorroso, sin embargo. Para reducir la necesidad de estas llamadas verbosas a \hyperlink{7919678712989769360}{\texttt{string()}} o multiplicaciones repetidas, Julia permite la interpolación en literales de cadena usando \texttt{\$}, como en Perl:




\begin{lstlisting}
julia> "$greet, $whom.\n"
"Hello, world.\n"
\end{lstlisting}



Esto es más legible y conveniente, y equivalente a la concatenación de cadena anterior – el sistema rescribe este aparente literal de cadena única en una concatenación de literales de cadena con variables.



La expresión completa más corta después de \texttt{\$} se toma como la expresión cuyo valor debe ser interpolado en la cadena. Por lo tanto, puede interpolar cualquier expresión en una cadena usando paréntesis:




\begin{minted}{jlcon}
julia> "1 + 2 = $(1 + 2)"
"1 + 2 = 3"
\end{minted}



Tanto la concatenación como la interpolación de cadena llaman a \hyperlink{7919678712989769360}{\texttt{string()}} para convertir objetos al formato de cadena. La mayoría de los objetos que no son \texttt{AbstractString} se convierten en cadenas que se corresponden estrechamente con la forma en que se introducen como expresiones literales:




\begin{minted}{jlcon}
julia> v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> "v: $v"
"v: [1, 2, 3]"
\end{minted}



\hyperlink{7919678712989769360}{\texttt{string()}} es la identidad para los valores \texttt{AbstractString} y \texttt{Char} values, por lo que estos se interpolan en cadenas como ellos mismos, sin entrecomillar y sin escapar:




\begin{minted}{jlcon}
julia> c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> "hi, $c"
"hi, x"
\end{minted}



Para incluir un literal \texttt{\$} en una cadena, lo escaparemos con un backslash:




\begin{minted}{jlcon}
julia> print("I have \$100 in my account.\n")
I have $100 in my account.
\end{minted}



\hypertarget{13286845120092268894}{}


\section{Literales cadena con triples comillas}



Cuando las cadenas se crean utilizando comillas triples (\texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}...{\textquotedbl}{\textquotedbl}{\textquotedbl}}) tienen un comportamiento especial que puede ser útil para crear bloques de texto más largos. En primer lugar, si la apertura {\textquotedbl}{\textquotedbl}{\textquotedbl} es seguida por una nueva línea, la nueva línea se quita de la cadena resultante:




\begin{minted}{julia}
"""hello"""
\end{minted}



es equivalente a




\begin{minted}{julia}
"""
hello"""
\end{minted}



pero




\begin{minted}{julia}
"""

hello"""
\end{minted}



contendrá un literal \emph{new line} al principio. Los espacios en blanco no se modifican. Pueden contener símbolos \texttt{{\textquotedbl}} sin escapar. Las cadenas de triple comilla también se dedican al nivel de la línea menos indentada. Esto es útil para definir cadenas dentro del código que está sangrado Por ejemplo:




\begin{minted}{jlcon}
julia> str = """
           Hello,
           world.
         """
"  Hello,\n  world.\n"
\end{minted}



En este caso la línea final (vacía) antes del cierre \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} establece el nivel de indentación.



Tenga en cuenta que las saltos de línea en cadenas literales, sean de una sola o triple comilla, resultan en un carácter de línea nueva (LF) \texttt{{\textbackslash}n} en la cadena, incluso si su editor usa una combinación de retorno de carro (CR) o CRLF para finalizar líneas. Para incluir un CR en una cadena, utilice un escape explícito \texttt{{\textbackslash}r}; Por ejemplo, puede introducir la cadena literal \texttt{{\textquotedbl}una línea CRLF que termina {\textbackslash}r {\textbackslash}n{\textquotedbl}}.



\hypertarget{6221518812491707138}{}


\section{Operaciones Comunes}



Podemos comparar cadenas lexicográficamente usando los operadores de comparación estandard:




\begin{minted}{jlcon}
julia> "abracadabra" < "xylophone"
true

julia> "abracadabra" == "xylophone"
false

julia> "Hello, world." != "Goodbye, world."
true

julia> "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
true
\end{minted}



La función \hyperlink{10006050288379145945}{\texttt{search()}} permite buscar el índice de una carácter en una cadena:




\begin{minted}{jlcon}
julia> search("xylophone", 'x')
1

julia> search("xylophone", 'p')
5

julia> search("xylophone", 'z')
0
\end{minted}



Y se puede arrancar la búsqueda de un carácter a partir de un desplazamiento proporcionado por un tercer argumento:




\begin{minted}{jlcon}
julia> search("xylophone", 'o')
4

julia> search("xylophone", 'o', 5)
7

julia> search("xylophone", 'o', 8)
0
\end{minted}



La función \hyperlink{16229508745643032859}{\texttt{contains()}} se usa para comprobar si una subcadena está contenida en una cadena:




\begin{minted}{jlcon}
julia> contains("Hello, world.", "world")
true

julia> contains("Xylophon", "o")
true

julia> contains("Xylophon", "a")
false

julia> contains("Xylophon", 'o')
ERROR: MethodError: no method matching contains(::String, ::Char)
Closest candidates are:
  contains(!Matched::Function, ::Any, !Matched::Any) at reduce.jl:664
  contains(::AbstractString, !Matched::AbstractString) at strings/search.jl:378
\end{minted}



Este último error es debido a que {\textquotesingle}o{\textquotesingle}  es un literal carácter, y \hyperlink{16229508745643032859}{\texttt{contains()}} es una función genérica que busca subsecuencias. Para buscar un elemento en una secuencia, debemos usar la función \hyperlink{17277603976666670638}{\texttt{in()}} en lugra de la anterior.



\hyperlink{15426606278434194584}{\texttt{repeat()}} y \hyperlink{18064910688022011979}{\texttt{join()}} son otras dos funciones de cadena muy útiles:




\begin{minted}{jlcon}
julia> repeat(".:Z:.", 10)
".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."

julia> join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"
\end{minted}



Algunas otras funciones útiles son:



\begin{itemize}
\item \hyperlink{7288835006555308491}{\texttt{endof(str)}} el índice máximo (byte) que se puede utilizar para indexar en \texttt{str}.


\item \hyperlink{4781133548011803693}{\texttt{length(str)}} el número de caracteres en \texttt{str}.

\end{itemize}


 * \hyperlink{1075601569170970796}{\texttt{i = start(str)}} da el primer índice válido en el que se puede encontrar un carácter en `str (típicamente 1).



\begin{itemize}
\item \hyperlink{11903630693622759236}{\texttt{c, j = next(str,i)}} devuelve el carácter siguiente en o después del índice \texttt{i} y el siguiente índice de carácter válido que sigue a éste. Con \hyperlink{1075601569170970796}{\texttt{start()}} y \hyperlink{7288835006555308491}{\texttt{endof()}}, se puede utilizar para iterar a través de los caracteres en str`.


\item \hyperlink{6392662344610705448}{\texttt{ind2chr(str,i)}} da el número de caracteres en \texttt{str} hasta e incluyendo cualquiera en el índice \texttt{i}.


\item \hyperlink{3998544168504071055}{\texttt{chr2ind(str,j)}} da el índice en el cual ocurre el carácter \texttt{j}-ésimo en \texttt{str}.

\end{itemize}


\hypertarget{16709477590855265963}{}


\section{Literales cadena no estándar}



Hay situaciones en las que se desea construir una cadena o utilizar semántica de cadenas, pero el comportamiento de la construcción de cadena estándar no es lo que se necesita. Para este tipo de situaciones, Julia proporciona \hyperlink{16709477590855265963}{literales cadena no estándar}. Un literal de cadena no estándar es como una cadena literal normal de doble comilla, pero va inmediatamente precedido de un identificador y no se comporta como un literal de cadena normal. El convenio es que los literales no estándar con prefijos en mayúsculas producen objetos cadena reales, mientras que aquellos con prefijos en minúsculas producen objetos que no cadena, como arrays de bytes o expresiones regulares compiladas. Las expresiones regulares, literales arrays de bytes y literales de números de versión, como se describe a continuación, son algunos ejemplos de literales de cadena no estándar. Otros ejemplos se dan en la sección \hyperlink{15444528597476882531}{Metaprogramación}.



\hypertarget{3647388628009050906}{}


\section{Expresiones Regulares}



Julia tiene expresiones regulares compatibles con Perl (expresiones regulares), tal y como las proporciona la biblioteca \href{http://www.pcre.org/}{PCRE}. Las expresiones regulares se relacionan con las cadenas de dos maneras: la conexión obvia es que las expresiones regulares se utilizan para encontrar patrones regulares en cadenas; La otra conexión es que las expresiones regulares se introducen ellas mismas como cadenas, que se analizan en una máquina de estado que puede utilizarse para buscar patrones en cadenas de forma eficiente. En Julia, las expresiones regulares se introducen usando literales de cadena no estándar prefijados con varios identificadores comenzando por \texttt{r}. El literal de expresión regular más básico sin ninguna opción activada sólo utiliza \texttt{r{\textquotedbl}...{\textquotedbl}}:




\begin{minted}{jlcon}
julia> r"^\s*(?:#|$)"
r"^\s*(?:#|$)"

julia> typeof(ans)
Regex
\end{minted}



Para comprobar si una \emph{regex} se corresponde con una cadena, se utiliza  \hyperlink{12183734646641519159}{\texttt{ismatch()}}:




\begin{minted}{jlcon}
julia> ismatch(r"^\s*(?:#|$)", "not a comment")
false

julia> ismatch(r"^\s*(?:#|$)", "# a comment")
true
\end{minted}



Como puede verse aquí, \hyperlink{12183734646641519159}{\texttt{ismatch()}} simplemente devuelve \texttt{true} o \texttt{false}, indicando si la \emph{regex} dada coincide o no con la cadena. Es común, sin embargo, que uno quiera saber no sólo si una cadena coincide, sino también \emph{cómo} coincide. Para capturar esta información sobre una coincidencia, se utiliza la función \hyperlink{2695862412477105800}{\texttt{match()}}:




\begin{minted}{jlcon}
julia> match(r"^\s*(?:#|$)", "not a comment")

julia> match(r"^\s*(?:#|$)", "# a comment")
RegexMatch("#")
\end{minted}



Si la expresión regular no coincide con la cadena dada, \hyperlink{2695862412477105800}{\texttt{match()}} devuelve \texttt{nothing} – un valor especial que no imprime nada en el indicador interactivo. Aparte de no imprimir, es un valor completamente normal, como podemos comprobar en el siguiente código:




\begin{minted}{julia}
m = match(r"^\s*(?:#|$)", line)
if m === nothing
    println("not a comment")
else
    println("blank or comment")
end
\end{minted}



Si la expresión regular coincide, el valor devuelto por \hyperlink{2695862412477105800}{\texttt{match()}}  es un objeto \texttt{RegexMatch}. Estos objetos registran cómo coincide la expresión, incluyendo la subcadena que coincide con el patrón y cualquier subcadena capturada, si la hay. Este ejemplo sólo captura la parte de la subcadena que coincide, pero tal vez quisiéramos capturar cualquier texto no en blanco después del carácter de comentario. Podríamos hacer lo siguiente:




\begin{minted}{jlcon}
julia> m = match(r"^\s*(?:#\s*(.*?)\s*$|$)", "# a comment ")
RegexMatch("# a comment ", 1="a comment")
\end{minted}



Al invocar a \hyperlink{2695862412477105800}{\texttt{match()}}, tenemos la opción de especificar un índice en el que iniciar la búsqueda. Por ejemplo:




\begin{minted}{jlcon}
julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",1)
RegexMatch("1")

julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",6)
RegexMatch("2")

julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",11)
RegexMatch("3")
\end{minted}



Puede extraer la siguiente información de un objeto \texttt{RegexMatch}:



\begin{itemize}
\item La totalidad de la subcadena emparejada: \texttt{m.match}


\item Las subcadenas capturadas como una matriz de cadenas: \texttt{m.captures}


\item El desplazamiento en el que comienza la coincidencia del patrón: \texttt{m.offset}


\item Los desplazamientos de las subcadenas capturadas como un vector: \texttt{m.offsets}

\end{itemize}


Para cuando una captura no coincide, en lugar de una subcadena, \texttt{m.captures} no contiene nada en esa posición, y \texttt{m.offsets} tiene un desplazamiento de cero (recuerde que los índices en Julia son \emph{1-based}, por lo que un desplazamiento de cero en una cadena es inválido). Aquí hay un par de ejemplos algo artificiales:




\begin{lstlisting}
julia> m = match(r"(a|b)(c)?(d)", "acd")
RegexMatch("acd", 1="a", 2="c", 3="d")

julia> m.match
"acd"

julia> m.captures
3-element Array{Union{SubString{String}, Void},1}:
 "a"
 "c"
 "d"

julia> m.offset
1

julia> m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia> m = match(r"(a|b)(c)?(d)", "ad")
RegexMatch("ad", 1="a", 2=nothing, 3="d")

julia> m.match
"ad"

julia> m.captures
3-element Array{Union{SubString{String}, Void},1}:
 "a"
 nothing
 "d"

julia> m.offset
1

julia> m.offsets
3-element Array{Int64,1}:
 1
 0
 2
\end{lstlisting}



Es conveniente que las capturas sean retornadas como un array para que uno pueda usar la sintaxis de desestructurante para enlazarlas a variables locales: 




\begin{lstlisting}
julia> first, second, third = m.captures; first
"a"
\end{lstlisting}



Las capturas también está accesibles indexando el objeto \texttt{RegexMatch} con el número o nombre del grupo captura:




\begin{minted}{jlcon}
julia> m=match(r"(?<hour>\d+):(?<minute>\d+)","12:45")
RegexMatch("12:45", hour="12", minute="45")

julia> m[:minute]
"45"

julia> m[2]
"45"
\end{minted}



Las capturas pueden referenciarse en una cadena de sustitución cuando se utiliza \hyperlink{1718748356383062256}{\texttt{replace()}} utilizando \texttt{{\textbackslash}n} para referirse al grupo de captura \texttt{n}-ésimo y prefijando la cadena de subsitución con \texttt{s}. El grupo de captura \texttt{0} se refiere a todo el objeto de coincidencia. Los grupos de captura nombrados se pueden hacer referencia en la sustitución con g<groupname>. Por ejemplo:




\begin{minted}{jlcon}
julia> replace("first second", r"(\w+) (?<agroup>\w+)", s"\g<agroup> \1")
"second first"
\end{minted}



Los grupos de captura numerados pueden también ser referenciados como \texttt{{\textbackslash}g<n>} para evitar ambigüedad, como en:




\begin{minted}{jlcon}
julia> replace("a", r".", s"\g<0>1")
"a1"
\end{minted}



Puedes modificar el comportamiento de las expresiones regulares mediante una combinación de los flags \texttt{i}, \texttt{m}, \texttt{s} y \texttt{x} después de la marca de comillas dobles de cierre. Estas banderas tienen el mismo significado que en Perl, tal y como se describe en este fragmento de la [página de manual del referencia de Perl(http://perldoc.perl.org/perlre.html\#Modifiers):




\begin{lstlisting}
i   Do case-insensitive pattern matching.

    If locale matching rules are in effect, the case map is taken
    from the current locale for code points less than 255, and
    from Unicode rules for larger code points. However, matches
    that would cross the Unicode rules/non-Unicode rules boundary
    (ords 255/256) will not succeed.

m   Treat string as multiple lines.  That is, change "^" and "$"
    from matching the start or end of the string to matching the
    start or end of any line anywhere within the string.

s   Treat string as single line.  That is, change "." to match any
    character whatsoever, even a newline, which normally it would
    not match.

    Used together, as r""ms, they let the "." match any character
    whatsoever, while still allowing "^" and "$" to match,
    respectively, just after and just before newlines within the
    string.

x   Tells the regular expression parser to ignore most whitespace
    that is neither backslashed nor within a character class. You
    can use this to break up your regular expression into
    (slightly) more readable parts. The '#' character is also
    treated as a metacharacter introducing a comment, just as in
    ordinary code.
\end{lstlisting}



Por ejemplo, la siguiente regex tiene activados los tres \emph{flags}:




\begin{minted}{jlcon}
julia> r"a+.*b+.*?d$"ism
r"a+.*b+.*?d$"ims

julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
\end{minted}



Las cadenas \emph{regex} con triples comillas, de la forma \texttt{r{\textquotedbl}{\textquotedbl}{\textquotedbl}...{\textquotedbl}{\textquotedbl}{\textquotedbl}} están también soportadas (y puede ser conveniente para expresiones regulares que contengan comillas o caracteres de salto de línea).



\hypertarget{14271532611053373881}{}


\section{Byte Array Literals}



Otro literal de cadena no estándar útil es el literal de cadena de bytes: \texttt{b {\textquotedbl}...{\textquotedbl}}. Esta forma nos permite usar la notación de cadena para expresar arrays de bytes literales, es decir, arrays de valores \hyperlink{6609065134969660118}{\texttt{UInt8}}. Las reglas para los literales de arrays de bytes son las siguientes:



\begin{itemize}
\item Los caracteres ASCII y los escapes ASCII producen un solo byte.


\item \texttt{{\textbackslash}x} y las secuencias de escape octales producen el \emph{byte} correspondiente al valor de escape.


\item Las secuencias de escape Unicode producen una secuencia de bytes que codifican ese punto de código en UTF-8.

\end{itemize}


Hay una cierta superposición entre estas reglas ya que el comportamiento de \texttt{{\textbackslash}x} y escapes octales menores de \texttt{0x80} (128) están cubiertos por las dos primeras reglas, pero aquí estas reglas están de acuerdo. Juntas, estas reglas permiten usar fácilmente caracteres ASCII, valores arbitrarios de bytes y secuencias UTF-8 para producir matrices de bytes. Aquí hay un ejemplo usando los tres:




\begin{minted}{jlcon}
julia> b"DATA\xff\u2200"
8-element Array{UInt8,1}:
 0x44
 0x41
 0x54
 0x41
 0xff
 0xe2
 0x88
 0x80
\end{minted}



La secuencia ASCII {\textquotedbl}DATA{\textquotedbl} corresponde a los bytes 68, 65, 84, 65. \texttt{{\textbackslash}xff} produce el byte simple 255. El escape Unicode \texttt{{\textbackslash}u2200} está codificado en UTF-8 como los tres bytes 226, 136, 128. Nótese que la matriz de bytes resultante no corresponde a una cadena UTF-8 válida - si intenta utilizar esto como una cadena literal normal, obtendrá un error de sintaxis:




\begin{minted}{jlcon}
julia> "DATA\xff\u2200"
ERROR: syntax: invalid UTF-8 sequence
\end{minted}



Observe también la distinción significativa entre \texttt{{\textbackslash}xff} y \texttt{{\textbackslash}uff}: la secuencia de escape anterior codifica el \emph{byte 255}, mientras que la última secuencia de escape representa el \emph{punto de código 255}, que se codifica como dos bytes en UTF-8:




\begin{minted}{jlcon}
julia> b"\xff"
1-element Array{UInt8,1}:
 0xff

julia> b"\uff"
2-element Array{UInt8,1}:
 0xc3
 0xbf
\end{minted}



En los literales de caracteres, esta distinción se pasa por alto y \texttt{{\textbackslash}xff} está autorizado a  representar el punto de código 255, porque los caracteres \emph{siempre} representan puntos de código. En las cadenas, sin embargo, los escapes \texttt{{\textbackslash}x} siempre representan bytes, no puntos de código, mientras que los escapes \texttt{{\textbackslash}u} y \texttt{{\textbackslash}U} siempre representan puntos de código, que están codificados en uno o más bytes. Para los puntos de código inferiores a \texttt{{\textbackslash}u80}, ocurre que la codificación UTF-8 de cada punto de código es sólo el byte producido por el escape \texttt{{\textbackslash}x} correspondiente, por lo que la distinción puede ignorarse con seguridad. Sin embargo, para los escapes \texttt{{\textbackslash}x80} a \texttt{{\textbackslash}xff} en comparación con \texttt{{\textbackslash}u80} a \texttt{{\textbackslash}uff}, existe una diferencia importante: el primero escapa a todos los bytes sencillos de codificación, los cuales -a menos que sean seguidos por bytes de continuación muy específicos- no forman UTF-8 válido, mientras que los últimos escapes representan puntos de código Unicode con codificaciones de dos bytes.



Si todo esto es muy confuso, intente leer \href{https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/}{{\textquotedbl}The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets{\textquotedbl}}. Es una excelente introducción a Unicode y UTF-8, y puede ayudar a aliviar cierta confusión sobre el asunto.



\hypertarget{10038787961375920908}{}


\section{Literales Número de Versión}



Los números de versión se pueden expresar fácilmente con literales de cadena no estándar del forma \texttt{v{\textquotedbl}...{\textquotedbl}}. Los literales de número de versión crean objetos \texttt{VersionNumber} que siguen las especificaciones del \href{http://semver.org/}{control de versiones semánticas} y, por lo tanto, se componen de valores numéricos mayor, menor y de parche, seguidos de anotaciones alfanuméricas de pre-liberación y construcción. Por ejemplo, \texttt{v {\textquotedbl}0.2.1-rc1 + win64{\textquotedbl}} se divide en versión principal \texttt{0}, versión secundaria \texttt{2}, versión de revisión \texttt{1}, \texttt{rc1} de pre-lanzamiento y construcción \texttt{win64}. Al introducir una versión literal, todo excepto el número de versión principal es opcional, por ejemplo, \texttt{v{\textquotedbl}0.2{\textquotedbl}} es equivalente a \texttt{v{\textquotedbl}0.2.0{\textquotedbl}} (con anotaciones previas / de compilación vacías), \texttt{v{\textquotedbl}2{\textquotedbl}} equivale a \texttt{v{\textquotedbl}2.0.0{\textquotedbl}}, y así sucesivamente.



Los objetos \texttt{VersionNumber} son en su mayoría útiles para comparar fácilmente y correctamente dos (o más) versiones. Por ejemplo, la constante \texttt{VERSION} contiene el número de versión de Julia como un objeto \texttt{VersionNumber} y, por lo tanto, se puede definir algún comportamiento específico de la versión utilizando declaraciones simples como:




\begin{minted}{julia}
if v"0.2" <= VERSION < v"0.3-"
    # do something specific to 0.2 release series
end
\end{minted}



Obsérvese que en el ejemplo anterior se utiliza el número de versión no estándar \texttt{v{\textquotedbl}0.3-{\textquotedbl}}, con un guión \texttt{-} en cola: esta notación es una extensión Julia del estándar, y se usa para indicar una versión que es más baja que cualquier versión \texttt{0.3}, Incluyendo todas sus pre-lanzamientos. Por lo tanto, en el ejemplo anterior, el código sólo se ejecuta con versiones estable \texttt{0.2} y excluye las versiones \texttt{v{\textquotedbl}0.3.0-rc1{\textquotedbl}}. Para permitir también versiones \texttt{0.2} inestables (es decir, pre-liberación), la verificación del límite inferior debería modificarse de la siguiente manera: \texttt{v{\textquotedbl}0.2-{\textquotedbl} <= VERSION}.



Otra extensión de especificación de versión no estándar permite usar un \texttt{+} de cola para expresar un límite superior en las versiones de compilación, por ej. \texttt{VERSIÓN> v {\textquotedbl}0.2-rc1 +{\textquotedbl}} se puede utilizar para significar cualquier versión por encima de \texttt{0.2-rc1} y cualquiera de sus compilaciones: devolverá \texttt{false} para la versión \texttt{v{\textquotedbl}0.2-rc1+win64{\textquotedbl}} y \texttt{true} para \texttt{v{\textquotedbl}0.2-rc2{\textquotedbl}}.



Es una buena práctica utilizar estas versiones especiales en comparaciones (en particular, el valor \texttt{-}de cola siempre debe utilizarse en los límites superiores a menos que haya una buena razón para no hacerlo), pero no deben utilizarse como el número de versión real de nada, ya que son inválidos en el esquema de versiones semánticas.



Además de ser utilizados por la constante \hyperlink{12605722316331458198}{\texttt{VERSION}}, los objetos \texttt{VersionNumber} son ampliamente utilizados en el módulo \texttt{Pkg}, para especificar las versiones de paquetes y sus dependencias.



\hypertarget{5096496368362976040}{}


\section{Raw String Literals}



Las cadenas en bruto (\emph{raw}) sin interpolación o \emph{unescaping} pueden ser expresadas con literales cadena no estándar de la forma \texttt{raw{\textquotedbl}...{\textquotedbl}}. Los literales cadena en bruto crean objetos \texttt{String} ordinarios que contienen los contenidos encerrados exactamente como entrados sin interpolación ni separación. Esto es útil para cadenas que contiene código o marcado en otros idiomas que usan \texttt{\$} o \texttt{{\textbackslash}} como caracteres especiales. La excepción son las comillas que aún deben ser escapadas, por ejemplo,  \texttt{raw{\textquotedbl} {\textbackslash} {\textquotedbl}{\textquotedbl}}es equivalente a\texttt{{\textquotedbl}{\textbackslash}{\textquotedbl} {\textquotedbl}}.



\hypertarget{11836327794581856778}{}


\chapter{Functions}



In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:




\begin{minted}{jlcon}
julia> function f(x,y)
           x + y
       end
f (generic function with 1 method)
\end{minted}



There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is equivalent to the following compact {\textquotedbl}assignment form{\textquotedbl}:




\begin{lstlisting}
julia> f(x,y) = x + y
f (generic function with 1 method)
\end{lstlisting}



In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see \hyperlink{16096814372489430927}{Compound Expressions}). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.



A function is called using the traditional parenthesis syntax:




\begin{lstlisting}
julia> f(2,3)
5
\end{lstlisting}



Without parentheses, the expression \texttt{f} refers to the function object, and can be passed around like any value:




\begin{lstlisting}
julia> g = f;

julia> g(2,3)
5
\end{lstlisting}



As with variables, Unicode can also be used for function names:




\begin{minted}{jlcon}
julia> ∑(x,y) = x + y
∑ (generic function with 1 method)

julia> ∑(2, 3)
5
\end{minted}



\hypertarget{7104112718421175158}{}


\section{Argument Passing Behavior}



Julia function arguments follow a convention sometimes called {\textquotedbl}pass-by-sharing{\textquotedbl}, which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable \emph{bindings} (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as \texttt{Array}s) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.



\hypertarget{1093175794875601028}{}


\section{The \texttt{return} Keyword}



The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, \texttt{f}, from the previous section this is the value of the expression \texttt{x + y}. As in C and most other imperative or functional languages, the \texttt{return} keyword causes a function to return immediately, providing an expression whose value is returned:




\begin{minted}{julia}
function g(x,y)
    return x * y
    x + y
end
\end{minted}



Since function definitions can be entered into interactive sessions, it is easy to compare these definitions:




\begin{minted}{jlcon}
julia> f(x,y) = x + y
f (generic function with 1 method)

julia> function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia> f(2,3)
5

julia> g(2,3)
6
\end{minted}



Of course, in a purely linear function body like \texttt{g}, the usage of \texttt{return} is pointless since the expression \texttt{x + y} is never evaluated and we could simply make \texttt{x * y} the last expression in the function and omit the \texttt{return}. In conjunction with other control flow, however, \texttt{return} is of real use. Here, for example, is a function that computes the hypotenuse length of a right triangle with sides of length \texttt{x} and \texttt{y}, avoiding overflow:




\begin{minted}{jlcon}
julia> function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x > y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia> hypot(3, 4)
5.0
\end{minted}



There are three possible points of return from this function, returning the values of three different expressions, depending on the values of \texttt{x} and \texttt{y}. The \texttt{return} on the last line could be omitted since it is the last expression.



\hypertarget{2796907390397954205}{}


\section{Operators Are Functions}



In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like \texttt{\&\&} and \texttt{||}. These operators cannot be functions since \hyperlink{10787134294480612893}{Short-Circuit Evaluation} requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:




\begin{minted}{jlcon}
julia> 1 + 2 + 3
6

julia> +(1,2,3)
6
\end{minted}



The infix form is exactly equivalent to the function application form – in fact the former is parsed to produce the function call internally. This also means that you can assign and pass around operators such as \hyperlink{3677358729494553841}{\texttt{+()}} and \hyperlink{8486205126068439173}{\texttt{*()}} just like you would with other function values:




\begin{minted}{jlcon}
julia> f = +;

julia> f(1,2,3)
6
\end{minted}



Under the name \texttt{f}, the function does not support infix notation, however.



\hypertarget{6542689851684250423}{}


\section{Operators With Special Names}



A few special expressions correspond to calls to functions with non-obvious names. These are:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Expression & Calls \\
\hline
\texttt{[A B C ...]} & \hyperlink{8862791894748483563}{\texttt{hcat()}} \\
\hline
\texttt{[A; B; C; ...]} & \hyperlink{14691815416955507876}{\texttt{vcat()}} \\
\hline
\texttt{[A B; C D; ...]} & \hyperlink{16279083053557795116}{\texttt{hvcat()}} \\
\hline
\texttt{A{\textquotesingle}} & \hyperlink{5848887074375173050}{\texttt{ctranspose()}} \\
\hline
\texttt{A.{\textquotesingle}} & \hyperlink{12700837529519091997}{\texttt{transpose()}} \\
\hline
\texttt{1:n} & \hyperlink{8118178594303305099}{\texttt{colon()}} \\
\hline
\texttt{A[i]} & \hyperlink{2839226020402435013}{\texttt{getindex()}} \\
\hline
\texttt{A[i]=x} & \hyperlink{17903591429492118749}{\texttt{setindex!()}} \\
\hline
\end{tabulary}

\end{table}



These functions are included in the \texttt{Base.Operators} module even though they do not have operator-like names.



\hypertarget{8300730259363458305}{}


\section{Anonymous Functions}



Functions in Julia are \href{https://en.wikipedia.org/wiki/First-class\_citizen}{first-class objects}: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:




\begin{minted}{jlcon}
julia> x -> x^2 + 2x - 1
(::#1) (generic function with 1 method)

julia> function (x)
           x^2 + 2x - 1
       end
(::#3) (generic function with 1 method)
\end{minted}



This creates a function taking one argument \texttt{x} and returning the value of the polynomial \texttt{x{\textasciicircum}2 + 2x - 1} at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.



The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is \hyperlink{11483231213869150535}{\texttt{map()}}, which applies a function to each value of an array and returns a new array containing the resulting values:




\begin{minted}{jlcon}
julia> map(round, [1.2,3.5,1.7])
3-element Array{Float64,1}:
 1.0
 4.0
 2.0
\end{minted}



This is fine if a named function effecting the transform one wants already exists to pass as the first argument to \hyperlink{11483231213869150535}{\texttt{map()}}. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:




\begin{minted}{jlcon}
julia> map(x -> x^2 + 2x - 1, [1,3,-1])
3-element Array{Int64,1}:
  2
 14
 -2
\end{minted}



An anonymous function accepting multiple arguments can be written using the syntax \texttt{(x,y,z)->2x+y-z}. A zero-argument anonymous function is written as \texttt{()->3}. The idea of a function with no arguments may seem strange, but is useful for {\textquotedbl}delaying{\textquotedbl} a computation. In this usage, a block of code is wrapped in a zero-argument function, which is later invoked by calling it as \texttt{f()}.



\hypertarget{14431400296470163139}{}


\section{Multiple Return Values}



In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:




\begin{lstlisting}
julia> function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)
\end{lstlisting}



If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:




\begin{lstlisting}
julia> foo(2,3)
(5, 6)
\end{lstlisting}



A typical usage of such a pair of return values, however, extracts each value into a variable. Julia supports simple tuple {\textquotedbl}destructuring{\textquotedbl} that facilitates this:




\begin{lstlisting}
julia> x, y = foo(2,3)
(5, 6)

julia> x
5

julia> y
6
\end{lstlisting}



You can also return multiple values via an explicit usage of the \texttt{return} keyword:




\begin{minted}{julia}
function foo(a,b)
    return a+b, a*b
end
\end{minted}



This has the exact same effect as the previous definition of \texttt{foo}.



\hypertarget{17618471192037406942}{}


\section{Varargs Functions}



It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as {\textquotedbl}varargs{\textquotedbl} functions, which is short for {\textquotedbl}variable number of arguments{\textquotedbl}. You can define a varargs function by following the last argument with an ellipsis:




\begin{lstlisting}
julia> bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)
\end{lstlisting}



The variables \texttt{a} and \texttt{b} are bound to the first two argument values as usual, and the variable \texttt{x} is bound to an iterable collection of the zero or more values passed to \texttt{bar} after its first two arguments:




\begin{lstlisting}
julia> bar(1,2)
(1, 2, ())

julia> bar(1,2,3)
(1, 2, (3,))

julia> bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia> bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))
\end{lstlisting}



In all these cases, \texttt{x} is bound to a tuple of the trailing values passed to \texttt{bar}.



It is possible to constrain the number of values passed as a variable argument; this will be discussed later in \hyperlink{291060050167532995}{Parametrically-constrained Varargs methods}.



On the flip side, it is often handy to {\textquotedbl}splice{\textquotedbl} the values contained in an iterable collection into a function call as individual arguments. To do this, one also uses \texttt{...} but in the function call instead:




\begin{lstlisting}
julia> x = (3, 4)
(3, 4)

julia> bar(1,2,x...)
(1, 2, (3, 4))
\end{lstlisting}



In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:




\begin{lstlisting}
julia> x = (2, 3, 4)
(2, 3, 4)

julia> bar(1,x...)
(1, 2, (3, 4))

julia> x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia> bar(x...)
(1, 2, (3, 4))
\end{lstlisting}



Furthermore, the iterable object spliced into a function call need not be a tuple:




\begin{lstlisting}
julia> x = [3,4]
2-element Array{Int64,1}:
 3
 4

julia> bar(1,2,x...)
(1, 2, (3, 4))

julia> x = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> bar(x...)
(1, 2, (3, 4))
\end{lstlisting}



Also, the function that arguments are spliced into need not be a varargs function (although it often is):




\begin{minted}{jlcon}
julia> baz(a,b) = a + b;

julia> args = [1,2]
2-element Array{Int64,1}:
 1
 2

julia> baz(args...)
3

julia> args = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
  baz(::Any, ::Any) at none:1
\end{minted}



As you can see, if the wrong number of elements are in the spliced container, then the function call will fail, just as it would if too many arguments were given explicitly.



\hypertarget{4299945348658494207}{}


\section{Optional Arguments}



In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the library function \hyperlink{13108503824143481717}{\texttt{parse(T, num, base)}} interprets a string as a number in some base. The \texttt{base} argument defaults to \texttt{10}. This behavior can be expressed concisely as:




\begin{minted}{julia}
function parse(T, num, base=10)
    ###
end
\end{minted}



With this definition, the function can be called with either two or three arguments, and \texttt{10} is automatically passed when a third argument is not specified:




\begin{minted}{jlcon}
julia> parse(Int,"12",10)
12

julia> parse(Int,"12",3)
5

julia> parse(Int,"12")
12
\end{minted}



Optional arguments are actually just a convenient syntax for writing multiple method definitions with different numbers of arguments (see \hyperlink{9349182470212981411}{Note on Optional and keyword Arguments}).



\hypertarget{10931992094969625097}{}


\section{Keyword Arguments}



Some functions need a large number of arguments, or have a large number of behaviors. Remembering how to call such functions can be difficult. Keyword arguments can make these complex interfaces easier to use and extend by allowing arguments to be identified by name instead of only by position.



For example, consider a function \texttt{plot} that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like \texttt{plot(x, y, width=2)}, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.



Functions with keyword arguments are defined using a semicolon in the signature:




\begin{minted}{julia}
function plot(x, y; style="solid", width=1, color="black")
    ###
end
\end{minted}



When the function is called, the semicolon is optional: one can either call \texttt{plot(x, y, width=2)} or \texttt{plot(x, y; width=2)}, but the former style is more common. An explicit semicolon is required only for passing varargs or computed keywords as described below.



Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.



The types of keyword arguments can be made explicit as follows:




\begin{minted}{julia}
function f(;x::Int64=1)
    ###
end
\end{minted}



Extra keyword arguments can be collected using \texttt{...}, as in varargs functions:




\begin{minted}{julia}
function f(x; y=0, kwargs...)
    ###
end
\end{minted}



Inside \texttt{f}, \texttt{kwargs} will be a collection of \texttt{(key,value)} tuples, where each \texttt{key} is a symbol. Such collections can be passed as keyword arguments using a semicolon in a call, e.g. \texttt{f(x, z=1; kwargs...)}. Dictionaries can also be used for this purpose.



One can also pass \texttt{(key,value)} tuples, or any iterable expression (such as a \texttt{=>} pair) that can be assigned to such a tuple, explicitly after a semicolon. For example, \texttt{plot(x, y; (:width,2))} and \texttt{plot(x, y; :width => 2)} are equivalent to \texttt{plot(x, y, width=2)}. This is useful in situations where the keyword name is computed at runtime.



The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call \texttt{plot(x, y; options..., width=2)} it is possible that the \texttt{options} structure also contains a value for \texttt{width}. In such a case the rightmost occurrence takes precedence; in this example, \texttt{width} is certain to have the value \texttt{2}.



\hypertarget{14058881424538826697}{}


\section{Evaluation Scope of Default Values}



Optional and keyword arguments differ slightly in how their default values are evaluated. When optional argument default expressions are evaluated, only \emph{previous} arguments are in scope. In contrast, \emph{all} the arguments are in scope when keyword arguments default expressions are evaluated. For example, given this definition:




\begin{minted}{julia}
function f(x, a=b, b=1)
    ###
end
\end{minted}



the \texttt{b} in \texttt{a=b} refers to a \texttt{b} in an outer scope, not the subsequent argument \texttt{b}. However, if \texttt{a} and \texttt{b} were keyword arguments instead, then both would be created in the same scope and the \texttt{b} in \texttt{a=b} would refer to the subsequent argument \texttt{b} (shadowing any \texttt{b} in an outer scope), which would result in an undefined variable error (since the default expressions are evaluated left-to-right, and \texttt{b} has not been assigned yet).



\hypertarget{1892968097837414739}{}


\section{Do-Block Syntax for Function Arguments}



Passing functions as arguments to other functions is a powerful technique, but the syntax for it is not always convenient. Such calls are especially awkward to write when the function argument requires multiple lines. As an example, consider calling \hyperlink{11483231213869150535}{\texttt{map()}} on a function with several cases:




\begin{minted}{julia}
map(x->begin
           if x < 0 && iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])
\end{minted}



Julia provides a reserved word \texttt{do} for rewriting this code more clearly:




\begin{minted}{julia}
map([A, B, C]) do x
    if x < 0 && iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end
\end{minted}



The \texttt{do x} syntax creates an anonymous function with argument \texttt{x} and passes it as the first argument to \hyperlink{11483231213869150535}{\texttt{map()}}. Similarly, \texttt{do a,b} would create a two-argument anonymous function, and a plain \texttt{do} would declare that what follows is an anonymous function of the form \texttt{() -> ...}.



How these arguments are initialized depends on the {\textquotedbl}outer{\textquotedbl} function; here, \hyperlink{11483231213869150535}{\texttt{map()}} will sequentially set \texttt{x} to \texttt{A}, \texttt{B}, \texttt{C}, calling the anonymous function on each, just as would happen in the syntax \texttt{map(func, [A, B, C])}.



This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from \hyperlink{11483231213869150535}{\texttt{map()}}, such as managing system state. For example, there is a version of \hyperlink{300818094931158296}{\texttt{open()}} that runs code ensuring that the opened file is eventually closed:




\begin{minted}{julia}
open("outfile", "w") do io
    write(io, data)
end
\end{minted}



This is accomplished by the following definition:




\begin{minted}{julia}
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
\end{minted}



Here, \hyperlink{300818094931158296}{\texttt{open()}} first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the \texttt{do ... end} block. After your function exits, \hyperlink{300818094931158296}{\texttt{open()}} will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The \texttt{try/finally} construct will be described in \hyperlink{8710711813610225279}{Control Flow}.)



With the \texttt{do} block syntax, it helps to check the documentation or implementation to know how the arguments of the user function are initialized.



\hypertarget{13590013989415065742}{}


\section{Dot Syntax for Vectorizing Functions}



In technical-computing languages, it is common to have {\textquotedbl}vectorized{\textquotedbl} versions of functions, which simply apply a given function \texttt{f(x)} to each element of an array \texttt{A} to yield a new array via \texttt{f(A)}. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the {\textquotedbl}vectorized{\textquotedbl} version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are \emph{not} required for performance, and indeed it is often beneficial to write your own loops (see \hyperlink{3908315974291496321}{Performance Tips}), but they can still be convenient. Therefore, \emph{any} Julia function \texttt{f} can be applied elementwise to any array (or other collection) with the syntax \texttt{f.(A)}. For example \texttt{sin} can be applied to all elements in the vector \texttt{A}, like so:




\begin{minted}{jlcon}
julia> A = [1.0, 2.0, 3.0]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0

julia> sin.(A)
3-element Array{Float64,1}:
 0.841471
 0.909297
 0.14112
\end{minted}



Of course, you can omit the dot if you write a specialized {\textquotedbl}vector{\textquotedbl} method of \texttt{f}, e.g. via \texttt{f(A::AbstractArray) = map(f, A)}, and this is just as efficient as \texttt{f.(A)}. But that approach requires you to decide in advance which functions you want to vectorize.



More generally, \texttt{f.(args...)} is actually equivalent to \texttt{broadcast(f, args...)}, which allows you to operate on multiple arrays (even of different shapes), or a mix of arrays and scalars (see \hyperlink{6411237952146762090}{Broadcasting}). For example, if you have \texttt{f(x,y) = 3x + 4y}, then \texttt{f.(pi,A)} will return a new array consisting of \texttt{f(pi,a)} for each \texttt{a} in \texttt{A}, and \texttt{f.(vector1,vector2)} will return a new vector consisting of \texttt{f(vector1[i],vector2[i])} for each index \texttt{i} (throwing an exception if the vectors have different length).




\begin{minted}{jlcon}
julia> f(x,y) = 3x + 4y;

julia> A = [1.0, 2.0, 3.0];

julia> B = [4.0, 5.0, 6.0];

julia> f.(pi, A)
3-element Array{Float64,1}:
 13.4248
 17.4248
 21.4248

julia> f.(A, B)
3-element Array{Float64,1}:
 19.0
 26.0
 33.0
\end{minted}



Moreover, \emph{nested} \texttt{f.(args...)} calls are \emph{fused} into a single \texttt{broadcast} loop. For example, \texttt{sin.(cos.(X))} is equivalent to \texttt{broadcast(x -> sin(cos(x)), X)}, similar to \texttt{[sin(cos(x)) for x in X]}: there is only a single loop over \texttt{X}, and a single array is allocated for the result. [In contrast, \texttt{sin(cos(X))} in a typical {\textquotedbl}vectorized{\textquotedbl} language would first allocate one temporary array for \texttt{tmp=cos(X)}, and then compute \texttt{sin(tmp)} in a separate loop, allocating a second array.] This loop fusion is not a compiler optimization that may or may not occur, it is a \emph{syntactic guarantee} whenever nested \texttt{f.(args...)} calls are encountered. Technically, the fusion stops as soon as a {\textquotedbl}non-dot{\textquotedbl} function call is encountered; for example, in \texttt{sin.(sort(cos.(X)))} the \texttt{sin} and \texttt{cos} loops cannot be merged because of the intervening \texttt{sort} function.



Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is \emph{pre-allocated}, so that repeated calls do not allocate new arrays over and over again for the results (\hyperlink{9465526813695170184}{Pre-allocating outputs}:). A convenient syntax for this is \texttt{X .= ...}, which is equivalent to \texttt{broadcast!(identity, X, ...)} except that, as above, the \texttt{broadcast!} loop is fused with any nested {\textquotedbl}dot{\textquotedbl} calls. For example, \texttt{X .= sin.(Y)} is equivalent to \texttt{broadcast!(sin, X, Y)}, overwriting \texttt{X} with \texttt{sin.(Y)} in-place. If the left-hand side is an array-indexing expression, e.g. \texttt{X[2:end] .= sin.(Y)}, then it translates to \texttt{broadcast!} on a \texttt{view}, e.g. \texttt{broadcast!(sin, view(X, 2:endof(X)), Y)}, so that the left-hand side is updated in-place.



Since adding dots to many operations and function calls in an expression can be tedious and lead to code that is difficult to read, the macro \hyperlink{16688502228717894452}{\texttt{@.}} is provided to convert \emph{every} function call, operation, and assignment in an expression into the {\textquotedbl}dotted{\textquotedbl} version.




\begin{minted}{jlcon}
julia> Y = [1.0, 2.0, 3.0, 4.0];

julia> X = similar(Y); # pre-allocate output array

julia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))
4-element Array{Float64,1}:
  0.514395
 -0.404239
 -0.836022
 -0.608083
\end{minted}



Binary (or unary) operators like \texttt{.+} are handled with the same mechanism: they are equivalent to \texttt{broadcast} calls and are fused with other nested {\textquotedbl}dot{\textquotedbl} calls.  \texttt{X .+= Y} etcetera is equivalent to \texttt{X .= X .+ Y} and results in a fused in-place assignment;  see also \hyperlink{6173297391052343261}{dot operators}.



\hypertarget{4446020845392914527}{}


\section{Further Reading}



We should mention here that this is far from a complete picture of defining functions. Julia has a sophisticated type system and allows multiple dispatch on argument types. None of the examples given here provide any type annotations on their arguments, meaning that they are applicable to all types of arguments. The type system is described in \hyperlink{2141690262982725665}{Types} and defining a function in terms of methods chosen by multiple dispatch on run-time argument types is described in \hyperlink{15216268953652766477}{Methods}.



\hypertarget{8710711813610225279}{}


\chapter{Control Flow}



Julia provides a variety of control flow constructs:



\begin{itemize}
\item \hyperlink{16096814372489430927}{Compound Expressions}: \texttt{begin} and \texttt{(;)}.


\item \hyperlink{9876835618453764646}{Conditional Evaluation}: \texttt{if}-\texttt{elseif}-\texttt{else} and \texttt{?:} (ternary operator).


\item \hyperlink{10787134294480612893}{Short-Circuit Evaluation}: \texttt{\&\&}, \texttt{||} and chained comparisons.


\item \hyperlink{6800841505698205300}{Repeated Evaluation: Loops}: \texttt{while} and \texttt{for}.


\item \hyperlink{1427814905527776703}{Exception Handling}: \texttt{try}-\texttt{catch}, \hyperlink{17992125292605951734}{\texttt{error()}} and \hyperlink{16410366672587017456}{\texttt{throw()}}.


\item \hyperlink{15038256797533490288}{Tasks (aka Coroutines)}: \hyperlink{4920987536368477483}{\texttt{yieldto()}}.

\end{itemize}


The first five control flow mechanisms are standard to high-level programming languages. \hyperlink{7131243650304654155}{\texttt{Task}}s are not so standard: they provide non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems can be solved much more easily by using tasks.



\hypertarget{16096814372489430927}{}


\section{Compound Expressions}



Sometimes it is convenient to have a single expression which evaluates several subexpressions in order, returning the value of the last subexpression as its value. There are two Julia constructs that accomplish this: \texttt{begin} blocks and \texttt{(;)} chains. The value of both compound expression constructs is that of the last subexpression. Here{\textquotesingle}s an example of a \texttt{begin} block:




\begin{minted}{jlcon}
julia> z = begin
           x = 1
           y = 2
           x + y
       end
3
\end{minted}



Since these are fairly small, simple expressions, they could easily be placed onto a single line, which is where the \texttt{(;)} chain syntax comes in handy:




\begin{minted}{jlcon}
julia> z = (x = 1; y = 2; x + y)
3
\end{minted}



This syntax is particularly useful with the terse single-line function definition form introduced in \hyperlink{1675991399371562561}{Functions}. Although it is typical, there is no requirement that \texttt{begin} blocks be multiline or that \texttt{(;)} chains be single-line:




\begin{minted}{jlcon}
julia> begin x = 1; y = 2; x + y end
3

julia> (x = 1;
        y = 2;
        x + y)
3
\end{minted}



\hypertarget{9876835618453764646}{}


\section{Conditional Evaluation}



Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the \texttt{if}-\texttt{elseif}-\texttt{else} conditional syntax:




\begin{minted}{julia}
if x < y
    println("x is less than y")
elseif x > y
    println("x is greater than y")
else
    println("x is equal to y")
end
\end{minted}



If the condition expression \texttt{x < y} is \texttt{true}, then the corresponding block is evaluated; otherwise the condition expression \texttt{x > y} is evaluated, and if it is \texttt{true}, the corresponding block is evaluated; if neither expression is true, the \texttt{else} block is evaluated. Here it is in action:




\begin{minted}{jlcon}
julia> function test(x, y)
           if x < y
               println("x is less than y")
           elseif x > y
               println("x is greater than y")
           else
               println("x is equal to y")
           end
       end
test (generic function with 1 method)

julia> test(1, 2)
x is less than y

julia> test(2, 1)
x is greater than y

julia> test(1, 1)
x is equal to y
\end{minted}



The \texttt{elseif} and \texttt{else} blocks are optional, and as many \texttt{elseif} blocks as desired can be used. The condition expressions in the \texttt{if}-\texttt{elseif}-\texttt{else} construct are evaluated until the first one evaluates to \texttt{true}, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.



\texttt{if} blocks are {\textquotedbl}leaky{\textquotedbl}, i.e. they do not introduce a local scope. This means that new variables defined inside the \texttt{if} clauses can be used after the \texttt{if} block, even if they weren{\textquotesingle}t defined before. So, we could have defined the \texttt{test} function above as




\begin{minted}{jlcon}
julia> function test(x,y)
           if x < y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           else
               relation = "greater than"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia> test(2, 1)
x is greater than y.
\end{minted}



The variable \texttt{relation} is declared inside the \texttt{if} block, but used outside. However, when depending on this behavior, make sure all possible code paths define a value for the variable. The following change to the above function results in a runtime error




\begin{minted}{jlcon}
julia> function test(x,y)
           if x < y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia> test(1,2)
x is less than y.

julia> test(2,1)
ERROR: UndefVarError: relation not defined
Stacktrace:
 [1] test(::Int64, ::Int64) at ./none:7
\end{minted}



\texttt{if} blocks also return a value, which may seem unintuitive to users coming from many other languages. This value is simply the return value of the last executed statement in the branch that was chosen, so




\begin{minted}{jlcon}
julia> x = 3
3

julia> if x > 0
           "positive!"
       else
           "negative..."
       end
"positive!"
\end{minted}



Note that very short conditional statements (one-liners) are frequently expressed using Short-Circuit Evaluation in Julia, as outlined in the next section.



Unlike C, MATLAB, Perl, Python, and Ruby – but like Java, and a few other stricter, typed languages – it is an error if the value of a conditional expression is anything but \texttt{true} or \texttt{false}:




\begin{minted}{jlcon}
julia> if 1
           println("true")
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context
\end{minted}



This error indicates that the conditional was of the wrong type: \hyperlink{7720564657383125058}{\texttt{Int64}} rather than the required \hyperlink{46725311238864537}{\texttt{Bool}}.



The so-called {\textquotedbl}ternary operator{\textquotedbl}, \texttt{?:}, is closely related to the \texttt{if}-\texttt{elseif}-\texttt{else} syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:




\begin{minted}{julia}
a ? b : c
\end{minted}



The expression \texttt{a}, before the \texttt{?}, is a condition expression, and the ternary operation evaluates the expression \texttt{b}, before the \texttt{:}, if the condition \texttt{a} is \texttt{true} or the expression \texttt{c}, after the \texttt{:}, if it is \texttt{false}.



The easiest way to understand this behavior is to see an example. In the previous example, the \texttt{println} call is shared by all three branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the sake of clarity, let{\textquotesingle}s try a two-way version first:




\begin{minted}{jlcon}
julia> x = 1; y = 2;

julia> println(x < y ? "less than" : "not less than")
less than

julia> x = 1; y = 0;

julia> println(x < y ? "less than" : "not less than")
not less than
\end{minted}



If the expression \texttt{x < y} is true, the entire ternary operator expression evaluates to the string \texttt{{\textquotedbl}less than{\textquotedbl}} and otherwise it evaluates to the string \texttt{{\textquotedbl}not less than{\textquotedbl}}. The original three-way example requires chaining multiple uses of the ternary operator together:




\begin{minted}{jlcon}
julia> test(x, y) = println(x < y ? "x is less than y"    :
                            x > y ? "x is greater than y" : "x is equal to y")
test (generic function with 1 method)

julia> test(1, 2)
x is less than y

julia> test(2, 1)
x is greater than y

julia> test(1, 1)
x is equal to y
\end{minted}



To facilitate chaining, the operator associates from right to left.



It is significant that like \texttt{if}-\texttt{elseif}-\texttt{else}, the expressions before and after the \texttt{:} are only evaluated if the condition expression evaluates to \texttt{true} or \texttt{false}, respectively:




\begin{minted}{jlcon}
julia> v(x) = (println(x); x)
v (generic function with 1 method)

julia> 1 < 2 ? v("yes") : v("no")
yes
"yes"

julia> 1 > 2 ? v("yes") : v("no")
no
"no"
\end{minted}



\hypertarget{10787134294480612893}{}


\section{Short-Circuit Evaluation}



Short-circuit evaluation is quite similar to conditional evaluation. The behavior is found in most imperative programming languages having the \texttt{\&\&} and \texttt{||} boolean operators: in a series of boolean expressions connected by these operators, only the minimum number of expressions are evaluated as are necessary to determine the final boolean value of the entire chain. Explicitly, this means that:



\begin{itemize}
\item In the expression \texttt{a \&\& b}, the subexpression \texttt{b} is only evaluated if \texttt{a} evaluates to \texttt{true}.


\item In the expression \texttt{a || b}, the subexpression \texttt{b} is only evaluated if \texttt{a} evaluates to \texttt{false}.

\end{itemize}


The reasoning is that \texttt{a \&\& b} must be \texttt{false} if \texttt{a} is \texttt{false}, regardless of the value of \texttt{b}, and likewise, the value of \texttt{a || b} must be true if \texttt{a} is \texttt{true}, regardless of the value of \texttt{b}. Both \texttt{\&\&} and \texttt{||} associate to the right, but \texttt{\&\&} has higher precedence than \texttt{||} does. It{\textquotesingle}s easy to experiment with this behavior:




\begin{lstlisting}
julia> t(x) = (println(x); true)
t (generic function with 1 method)

julia> f(x) = (println(x); false)
f (generic function with 1 method)

julia> t(1) && t(2)
1
2
true

julia> t(1) && f(2)
1
2
false

julia> f(1) && t(2)
1
false

julia> f(1) && f(2)
1
false

julia> t(1) || t(2)
1
true

julia> t(1) || f(2)
1
true

julia> f(1) || t(2)
1
2
true

julia> f(1) || f(2)
1
2
false
\end{lstlisting}



You can easily experiment in the same way with the associativity and precedence of various combinations of \texttt{\&\&} and \texttt{||} operators.



This behavior is frequently used in Julia to form an alternative to very short \texttt{if} statements. Instead of \texttt{if <cond> <statement> end}, one can write \texttt{<cond> \&\& <statement>} (which could be read as: <cond> \emph{and then} <statement>). Similarly, instead of \texttt{if ! <cond> <statement> end}, one can write \texttt{<cond> || <statement>} (which could be read as: <cond> \emph{or else} <statement>).



For example, a recursive factorial routine could be defined like this:




\begin{minted}{jlcon}
julia> function fact(n::Int)
           n >= 0 || error("n must be non-negative")
           n == 0 && return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia> fact(5)
120

julia> fact(0)
1

julia> fact(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] fact(::Int64) at ./none:2
\end{minted}



Boolean operations \emph{without} short-circuit evaluation can be done with the bitwise boolean operators introduced in \hyperlink{16655087771805204817}{Mathematical Operations and Elementary Functions}: \texttt{\&} and \texttt{|}. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:




\begin{lstlisting}
julia> f(1) & t(2)
1
2
false

julia> t(1) | t(2)
1
2
true
\end{lstlisting}



Just like condition expressions used in \texttt{if}, \texttt{elseif} or the ternary operator, the operands of \texttt{\&\&} or \texttt{||} must be boolean values (\texttt{true} or \texttt{false}). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:




\begin{minted}{jlcon}
julia> 1 && true
ERROR: TypeError: non-boolean (Int64) used in boolean context
\end{minted}



On the other hand, any type of expression can be used at the end of a conditional chain. It will be evaluated and returned depending on the preceding conditionals:




\begin{minted}{jlcon}
julia> true && (x = (1, 2, 3))
(1, 2, 3)

julia> false && (x = (1, 2, 3))
false
\end{minted}



\hypertarget{6800841505698205300}{}


\section{Repeated Evaluation: Loops}



There are two constructs for repeated evaluation of expressions: the \texttt{while} loop and the \texttt{for} loop. Here is an example of a \texttt{while} loop:




\begin{minted}{jlcon}
julia> i = 1;

julia> while i <= 5
           println(i)
           i += 1
       end
1
2
3
4
5
\end{minted}



The \texttt{while} loop evaluates the condition expression (\texttt{i <= 5} in this case), and as long it remains \texttt{true}, keeps also evaluating the body of the \texttt{while} loop. If the condition expression is \texttt{false} when the \texttt{while} loop is first reached, the body is never evaluated.



The \texttt{for} loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above \texttt{while} loop does is so common, it can be expressed more concisely with a \texttt{for} loop:




\begin{minted}{jlcon}
julia> for i = 1:5
           println(i)
       end
1
2
3
4
5
\end{minted}



Here the \texttt{1:5} is a \texttt{Range} object, representing the sequence of numbers 1, 2, 3, 4, 5. The \texttt{for} loop iterates through these values, assigning each one in turn to the variable \texttt{i}. One rather important distinction between the previous \texttt{while} loop form and the \texttt{for} loop form is the scope during which the variable is visible. If the variable \texttt{i} has not been introduced in an other scope, in the \texttt{for} loop form, it is visible only inside of the \texttt{for} loop, and not afterwards. You{\textquotesingle}ll either need a new interactive session instance or a different variable name to test this:




\begin{minted}{jlcon}
julia> for j = 1:5
           println(j)
       end
1
2
3
4
5

julia> j
ERROR: UndefVarError: j not defined
\end{minted}



See \hyperlink{14993622729045334657}{Scope of Variables} for a detailed explanation of variable scope and how it works in Julia.



In general, the \texttt{for} loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword \texttt{in} or \texttt{∈} is typically used instead of \texttt{=}, since it makes the code read more clearly:




\begin{minted}{jlcon}
julia> for i in [1,4,0]
           println(i)
       end
1
4
0

julia> for s ∈ ["foo","bar","baz"]
           println(s)
       end
foo
bar
baz
\end{minted}



Various types of iterable containers will be introduced and discussed in later sections of the manual (see, e.g., \hyperlink{12380164357355707963}{Multi-dimensional Arrays}).



It is sometimes convenient to terminate the repetition of a \texttt{while} before the test condition is falsified or stop iterating in a \texttt{for} loop before the end of the iterable object is reached. This can be accomplished with the \texttt{break} keyword:




\begin{minted}{jlcon}
julia> i = 1;

julia> while true
           println(i)
           if i >= 5
               break
           end
           i += 1
       end
1
2
3
4
5

julia> for i = 1:1000
           println(i)
           if i >= 5
               break
           end
       end
1
2
3
4
5
\end{minted}



Without the \texttt{break} keyword, the above \texttt{while} loop would never terminate on its own, and the \texttt{for} loop would iterate up to 1000. These loops are both exited early by using \texttt{break}.



In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The \texttt{continue} keyword accomplishes this:




\begin{minted}{jlcon}
julia> for i = 1:10
           if i % 3 != 0
               continue
           end
           println(i)
       end
3
6
9
\end{minted}



This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the \texttt{println} call inside the \texttt{if} block. In realistic usage there is more code to be evaluated after the \texttt{continue}, and often there are multiple points from which one calls \texttt{continue}.



Multiple nested \texttt{for} loops can be combined into a single outer loop, forming the cartesian product of its iterables:




\begin{minted}{jlcon}
julia> for i = 1:2, j = 3:4
           println((i, j))
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)
\end{minted}



A \texttt{break} statement inside such a loop exits the entire nest of loops, not just the inner one.



\hypertarget{1427814905527776703}{}


\section{Exception Handling}



When an unexpected condition occurs, a function may be unable to return a reasonable value to its caller. In such cases, it may be best for the exceptional condition to either terminate the program, printing a diagnostic error message, or if the programmer has provided code to handle such exceptional circumstances, allow that code to take the appropriate action.



\hypertarget{9578283257624714046}{}


\subsection{Built-in \texttt{Exception}s}



\texttt{Exception}s are thrown when an unexpected condition has occurred. The built-in \texttt{Exception}s listed below all interrupt the normal flow of control.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|}
\hline
\texttt{Exception} \\
\hline
\hyperlink{1600362634474051736}{\texttt{ArgumentError}} \\
\hline
\hyperlink{9731558909100893938}{\texttt{BoundsError}} \\
\hline
\texttt{CompositeException} \\
\hline
\hyperlink{4168463413201806292}{\texttt{DivideError}} \\
\hline
\hyperlink{14085880504701688639}{\texttt{DomainError}} \\
\hline
\hyperlink{2683611566077490148}{\texttt{EOFError}} \\
\hline
\hyperlink{12102596058483452470}{\texttt{ErrorException}} \\
\hline
\hyperlink{5399118524830636312}{\texttt{InexactError}} \\
\hline
\hyperlink{9529417803286937185}{\texttt{InitError}} \\
\hline
\hyperlink{11255134339055983338}{\texttt{InterruptException}} \\
\hline
\texttt{InvalidStateException} \\
\hline
\hyperlink{12862287453053981792}{\texttt{KeyError}} \\
\hline
\hyperlink{943337379161919670}{\texttt{LoadError}} \\
\hline
\hyperlink{9656432107553099418}{\texttt{OutOfMemoryError}} \\
\hline
\hyperlink{5617183776424836760}{\texttt{ReadOnlyMemoryError}} \\
\hline
\hyperlink{13592793980665725371}{\texttt{RemoteException}} \\
\hline
\hyperlink{14644228586476494020}{\texttt{MethodError}} \\
\hline
\hyperlink{10461069697702909970}{\texttt{OverflowError}} \\
\hline
\hyperlink{17891414672434519487}{\texttt{ParseError}} \\
\hline
\hyperlink{16303515589950241655}{\texttt{SystemError}} \\
\hline
\hyperlink{2622693721821893139}{\texttt{TypeError}} \\
\hline
\hyperlink{7764749529861419421}{\texttt{UndefRefError}} \\
\hline
\hyperlink{4452889246677411554}{\texttt{UndefVarError}} \\
\hline
\texttt{UnicodeError} \\
\hline
\end{tabulary}

\end{table}



For example, the \hyperlink{4178506499510800909}{\texttt{sqrt()}} function throws a \hyperlink{14085880504701688639}{\texttt{DomainError}} if applied to a negative real value:




\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Int64) at ./math.jl:434
\end{minted}



You may define your own exceptions in the following way:




\begin{minted}{jlcon}
julia> struct MyCustomException <: Exception end
\end{minted}



\hypertarget{8737430308551931442}{}


\subsection{The \texttt{throw()} function}



Exceptions can be created explicitly with \hyperlink{16410366672587017456}{\texttt{throw()}}. For example, a function defined only for nonnegative numbers could be written to \hyperlink{16410366672587017456}{\texttt{throw()}} a \hyperlink{14085880504701688639}{\texttt{DomainError}} if the argument is negative:




\begin{minted}{jlcon}
julia> f(x) = x>=0 ? exp(-x) : throw(DomainError())
f (generic function with 1 method)

julia> f(1)
0.36787944117144233

julia> f(-1)
ERROR: DomainError:
Stacktrace:
 [1] f(::Int64) at ./none:1
\end{minted}



Note that \hyperlink{14085880504701688639}{\texttt{DomainError}} without parentheses is not an exception, but a type of exception. It needs to be called to obtain an \texttt{Exception} object:




\begin{minted}{jlcon}
julia> typeof(DomainError()) <: Exception
true

julia> typeof(DomainError) <: Exception
false
\end{minted}



Additionally, some exception types take one or more arguments that are used for error reporting:




\begin{minted}{jlcon}
julia> throw(UndefVarError(:x))
ERROR: UndefVarError: x not defined
\end{minted}



This mechanism can be implemented easily by custom exception types following the way \hyperlink{4452889246677411554}{\texttt{UndefVarError}} is written:




\begin{minted}{jlcon}
julia> struct MyUndefVarError <: Exception
           var::Symbol
       end

julia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, " not defined")
\end{minted}



\begin{quote}
\textbf{Note}

When writing an error message, it is preferred to make the first word lowercase. For example, \texttt{size(A) == size(B) || throw(DimensionMismatch({\textquotedbl}size of A not equal to size of B{\textquotedbl}))}

is preferred over

\texttt{size(A) == size(B) || throw(DimensionMismatch({\textquotedbl}Size of A not equal to size of B{\textquotedbl}))}.

However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: \texttt{size(A,1) == size(B,2) || throw(DimensionMismatch({\textquotedbl}A has first dimension...{\textquotedbl}))}.

\end{quote}


\hypertarget{7115517658733019231}{}


\subsection{Errors}



The \hyperlink{17992125292605951734}{\texttt{error()}} function is used to produce an \hyperlink{12102596058483452470}{\texttt{ErrorException}} that interrupts the normal flow of control.



Suppose we want to stop execution immediately if the square root of a negative number is taken. To do this, we can define a fussy version of the \hyperlink{4178506499510800909}{\texttt{sqrt()}} function that raises an error if its argument is negative:




\begin{lstlisting}
julia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error("negative x not allowed")
fussy_sqrt (generic function with 1 method)

julia> fussy_sqrt(2)
1.4142135623730951

julia> fussy_sqrt(-1)
ERROR: negative x not allowed
Stacktrace:
 [1] fussy_sqrt(::Int64) at ./none:1
\end{lstlisting}



If \texttt{fussy\_sqrt} is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:




\begin{lstlisting}
julia> function verbose_fussy_sqrt(x)
           println("before fussy_sqrt")
           r = fussy_sqrt(x)
           println("after fussy_sqrt")
           return r
       end
verbose_fussy_sqrt (generic function with 1 method)

julia> verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951

julia> verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
Stacktrace:
 [1] fussy_sqrt at ./none:1 [inlined]
 [2] verbose_fussy_sqrt(::Int64) at ./none:3
\end{lstlisting}



\hypertarget{5767558908291866908}{}


\subsection{Warnings and informational messages}



Julia also provides other functions that write messages to the standard error I/O, but do not throw any \texttt{Exception}s and hence do not interrupt execution:




\begin{minted}{jlcon}
julia> info("Hi"); 1+1
INFO: Hi
2

julia> warn("Hi"); 1+1
WARNING: Hi
2

julia> error("Hi"); 1+1
ERROR: Hi
Stacktrace:
 [1] error(::String) at ./error.jl:21
\end{minted}



\hypertarget{1660695554487462928}{}


\subsection{The \texttt{try/catch} statement}



The \texttt{try/catch} statement allows for \texttt{Exception}s to be tested for. For example, a customized square root function can be written to automatically call either the real or complex square root method on demand using \texttt{Exception}s :




\begin{minted}{jlcon}
julia> f(x) = try
           sqrt(x)
       catch
           sqrt(complex(x, 0))
       end
f (generic function with 1 method)

julia> f(1)
1.0

julia> f(-1)
0.0 + 1.0im
\end{minted}



It is important to note that in real code computing this function, one would compare \texttt{x} to zero instead of catching an exception. The exception is much slower than simply comparing and branching.



\texttt{try/catch} statements also allow the \texttt{Exception} to be saved in a variable. In this contrived example, the following example calculates the square root of the second element of \texttt{x} if \texttt{x} is indexable, otherwise assumes \texttt{x} is a real number and returns its square root:




\begin{minted}{jlcon}
julia> sqrt_second(x) = try
           sqrt(x[2])
       catch y
           if isa(y, DomainError)
               sqrt(complex(x[2], 0))
           elseif isa(y, BoundsError)
               sqrt(x)
           end
       end
sqrt_second (generic function with 1 method)

julia> sqrt_second([1 4])
2.0

julia> sqrt_second([1 -4])
0.0 + 2.0im

julia> sqrt_second(9)
3.0

julia> sqrt_second(-9)
ERROR: DomainError:
Stacktrace:
 [1] sqrt_second(::Int64) at ./none:7
\end{minted}



Note that the symbol following \texttt{catch} will always be interpreted as a name for the exception, so care is needed when writing \texttt{try/catch} expressions on a single line. The following code will \emph{not} work to return the value of \texttt{x} in case of an error:




\begin{minted}{julia}
try bad() catch x end
\end{minted}



Instead, use a semicolon or insert a line break after \texttt{catch}:




\begin{minted}{julia}
try bad() catch; x end

try bad()
catch
    x
end
\end{minted}



The \texttt{catch} clause is not strictly necessary; when omitted, the default return value is \texttt{nothing}.




\begin{minted}{jlcon}
julia> try error() end # Returns nothing
\end{minted}



The power of the \texttt{try/catch} construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions. There are situations where no error has occurred, but the ability to unwind the stack and pass a value to a higher level is desirable. Julia provides the \hyperlink{2102349972401293064}{\texttt{rethrow()}}, \hyperlink{6187626674327343338}{\texttt{backtrace()}} and \hyperlink{98342946516168163}{\texttt{catch\_backtrace()}} functions for more advanced error handling.



\hypertarget{5930775685484561908}{}


\subsection{\texttt{finally} Clauses}



In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The \texttt{finally} keyword provides a way to run some code when a given block of code exits, regardless of how it exits.



For example, here is how we can guarantee that an opened file is closed:




\begin{minted}{julia}
f = open("file")
try
    # operate on file f
finally
    close(f)
end
\end{minted}



When control leaves the \texttt{try} block (for example due to a \texttt{return}, or just finishing normally), \texttt{close(f)} will be executed. If the \texttt{try} block exits due to an exception, the exception will continue propagating. A \texttt{catch} block may be combined with \texttt{try} and \texttt{finally} as well. In this case the \texttt{finally} block will run after \texttt{catch} has handled the error.



\hypertarget{15038256797533490288}{}


\section{Tasks (aka Coroutines)}



Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. This feature is sometimes called by other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations.



When a piece of computing work (in practice, executing a particular function) is designated as a \hyperlink{7131243650304654155}{\texttt{Task}}, it becomes possible to interrupt it by switching to another \hyperlink{7131243650304654155}{\texttt{Task}}. The original \hyperlink{7131243650304654155}{\texttt{Task}} can later be resumed, at which point it will pick up right where it left off. At first, this may seem similar to a function call. However there are two key differences. First, switching tasks does not use any space, so any number of task switches can occur without consuming the call stack. Second, switching among tasks can occur in any order, unlike function calls, where the called function must finish executing before control returns to the calling function.



This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious {\textquotedbl}caller{\textquotedbl} or {\textquotedbl}callee{\textquotedbl} among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.



Julia provides a \hyperlink{12548845729684045604}{\texttt{Channel}} mechanism for solving this problem. A \hyperlink{12548845729684045604}{\texttt{Channel}} is a waitable first-in first-out queue which can have multiple tasks reading from and writing to it.



Let{\textquotesingle}s define a producer task, which produces values via the \hyperlink{12719543094136814100}{\texttt{put!}} call. To consume values, we need to schedule the producer to run in a new task. A special \hyperlink{12548845729684045604}{\texttt{Channel}} constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel. We can then \hyperlink{4360129174058888556}{\texttt{take!()}} values repeatedly from the channel object:




\begin{lstlisting}
julia> function producer(c::Channel)
           put!(c, "start")
           for n=1:4
               put!(c, 2n)
           end
           put!(c, "stop")
       end;

julia> chnl = Channel(producer);

julia> take!(chnl)
"start"

julia> take!(chnl)
2

julia> take!(chnl)
4

julia> take!(chnl)
6

julia> take!(chnl)
8

julia> take!(chnl)
"stop"
\end{lstlisting}



One way to think of this behavior is that \texttt{producer} was able to return multiple times. Between calls to \hyperlink{12719543094136814100}{\texttt{put!()}}, the producer{\textquotesingle}s execution is suspended and the consumer has control.



The returned \hyperlink{12548845729684045604}{\texttt{Channel}} can be used as an iterable object in a \texttt{for} loop, in which case the loop variable takes on all the produced values. The loop is terminated when the channel is closed.




\begin{lstlisting}
julia> for x in Channel(producer)
           println(x)
       end
start
2
4
6
8
stop
\end{lstlisting}



Note that we did not have to explicitly close the channel in the producer. This is because the act of binding a \hyperlink{12548845729684045604}{\texttt{Channel}} to a \hyperlink{7131243650304654155}{\texttt{Task()}} associates the open lifetime of a channel with that of the bound task. The channel object is closed automatically when the task terminates. Multiple channels can be bound to a task, and vice-versa.



While the \hyperlink{7131243650304654155}{\texttt{Task()}} constructor expects a 0-argument function, the \hyperlink{12548845729684045604}{\texttt{Channel()}} method which creates a channel bound task expects a function that accepts a single argument of type \hyperlink{12548845729684045604}{\texttt{Channel}}. A common pattern is for the producer to be parameterized, in which case a partial function application is needed to create a 0 or 1 argument \hyperlink{8300730259363458305}{anonymous function}.



For \hyperlink{7131243650304654155}{\texttt{Task()}} objects this can be done either directly or by use of a convenience macro:




\begin{minted}{julia}
function mytask(myarg)
    ...
end

taskHdl = Task(() -> mytask(7))
# or, equivalently
taskHdl = @task mytask(7)
\end{minted}



To orchestrate more advanced work distribution patterns, \hyperlink{13811388816704022260}{\texttt{bind()}} and \hyperlink{9185853093207176818}{\texttt{schedule()}} can be used in conjunction with \hyperlink{7131243650304654155}{\texttt{Task()}} and \hyperlink{12548845729684045604}{\texttt{Channel()}} constructors to explicitly link a set of channels with a set of producer/consumer tasks.



Note that currently Julia tasks are not scheduled to run on separate CPU cores. True kernel threads are discussed under the topic of \hyperlink{3649475918943763834}{Parallel Computing}.



\hypertarget{3944538576580102071}{}


\subsection{Core task operations}



Let us explore the low level construct \hyperlink{4920987536368477483}{\texttt{yieldto()}} to underestand how task switching works. \texttt{yieldto(task,value)} suspends the current task, switches to the specified \texttt{task}, and causes that task{\textquotesingle}s last \hyperlink{4920987536368477483}{\texttt{yieldto()}} call to return the specified \texttt{value}. Notice that \hyperlink{4920987536368477483}{\texttt{yieldto()}} is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called {\textquotedbl}symmetric coroutines{\textquotedbl}; each task is switched to and from using the same mechanism.



\hyperlink{4920987536368477483}{\texttt{yieldto()}} is powerful, but most uses of tasks do not invoke it directly. Consider why this might be. If you switch away from the current task, you will probably want to switch back to it at some point, but knowing when to switch back, and knowing which task has the responsibility of switching back, can require considerable coordination. For example, \hyperlink{12719543094136814100}{\texttt{put!()}} and \hyperlink{4360129174058888556}{\texttt{take!()}} are blocking operations, which, when used in the context of channels maintain state to remember who the consumers are. Not needing to manually keep track of the consuming task is what makes \hyperlink{12719543094136814100}{\texttt{put!()}} easier to use than the low-level \hyperlink{4920987536368477483}{\texttt{yieldto()}}.



In addition to \hyperlink{4920987536368477483}{\texttt{yieldto()}}, a few other basic functions are needed to use tasks effectively.



\begin{itemize}
\item \hyperlink{12929971401717674174}{\texttt{current\_task()}} gets a reference to the currently-running task.


\item \hyperlink{7432450399685996831}{\texttt{istaskdone()}} queries whether a task has exited.


\item \hyperlink{188637489024602838}{\texttt{istaskstarted()}} queries whether a task has run yet.


\item \hyperlink{8292907206163344794}{\texttt{task\_local\_storage()}} manipulates a key-value store specific to the current task.

\end{itemize}


\hypertarget{18178825981656293848}{}


\subsection{Tasks and events}



Most task switches occur as a result of waiting for events such as I/O requests, and are performed by a scheduler included in the standard library. The scheduler maintains a queue of runnable tasks, and executes an event loop that restarts tasks based on external events such as message arrival.



The basic function for waiting for an event is \hyperlink{13761789780433862250}{\texttt{wait()}}. Several objects implement \hyperlink{13761789780433862250}{\texttt{wait()}}; for example, given a \texttt{Process} object, \hyperlink{13761789780433862250}{\texttt{wait()}} will wait for it to exit. \hyperlink{13761789780433862250}{\texttt{wait()}} is often implicit; for example, a \hyperlink{13761789780433862250}{\texttt{wait()}} can happen inside a call to \hyperlink{8104134490906192097}{\texttt{read()}} to wait for data to be available.



In all of these cases, \hyperlink{13761789780433862250}{\texttt{wait()}} ultimately operates on a \hyperlink{286351753995469758}{\texttt{Condition}} object, which is in charge of queueing and restarting tasks. When a task calls \hyperlink{13761789780433862250}{\texttt{wait()}} on a \hyperlink{286351753995469758}{\texttt{Condition}}, the task is marked as non-runnable, added to the condition{\textquotesingle}s queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call \hyperlink{2865179286002578885}{\texttt{notify()}} on the condition, which causes tasks waiting for that condition to become runnable again.



A task created explicitly by calling \hyperlink{7131243650304654155}{\texttt{Task}} is initially not known to the scheduler. This allows you to manage tasks manually using \hyperlink{4920987536368477483}{\texttt{yieldto()}} if you wish. However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect. It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling \hyperlink{9185853093207176818}{\texttt{schedule()}}, or using the \hyperlink{15186286520310132839}{\texttt{@schedule}} or \hyperlink{10770947021537241619}{\texttt{@async}} macros (see \hyperlink{3649475918943763834}{Parallel Computing} for more details).



\hypertarget{9519113228374501589}{}


\subsection{Task states}



Tasks have a \texttt{state} field that describes their execution status. A \hyperlink{7131243650304654155}{\texttt{Task}} \texttt{state} is one of the following symbols:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Symbol & Meaning \\
\hline
\texttt{:runnable} & Currently running, or available to be switched to \\
\hline
\texttt{:waiting} & Blocked waiting for a specific event \\
\hline
\texttt{:queued} & In the scheduler{\textquotesingle}s run queue about to be restarted \\
\hline
\texttt{:done} & Successfully finished executing \\
\hline
\texttt{:failed} & Finished with an uncaught exception \\
\hline
\end{tabulary}

\end{table}



\hypertarget{14993622729045334657}{}


\chapter{Scope of Variables}



The \emph{scope} of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called \texttt{x} without the two \texttt{x}{\textquotesingle}s referring to the same thing. Similarly there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn{\textquotesingle}t refer to the same thing are called scope rules; this section spells them out in detail.



Certain constructs in the language introduce \emph{scope blocks}, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, \emph{global scope} and \emph{local scope}, the latter can be nested. The constructs introducing scope blocks are:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Scope name & block/construct introducing this kind of scope \\
\hline
\hyperlink{1579695877498494307}{Global Scope} & \texttt{module}, \texttt{baremodule}, at interactive prompt (REPL) \\
\hline
\hyperlink{9696494911619820682}{Local Scope} & \hyperlink{1067480096854414457}{Soft Local Scope}: \texttt{for}, \texttt{while}, comprehensions, try-catch-finally, \texttt{let} \\
\hline
\hyperlink{9696494911619820682}{Local Scope} & \hyperlink{2878080290330580157}{Hard Local Scope}: functions (either syntax, anonymous \& do-blocks), \texttt{struct}, \texttt{macro} \\
\hline
\end{tabulary}

\end{table}



Notably missing from this table are \hyperlink{16096814372489430927}{begin blocks} and \hyperlink{9876835618453764646}{if blocks}, which do \emph{not} introduce new scope blocks. All three types of scopes follow somewhat different rules which will be explained below as well as some extra rules for certain blocks.



Julia uses \href{https://en.wikipedia.org/wiki/Scope\_\%28computer\_science\%29\#Lexical\_scoping\_vs.\_dynamic\_scoping}{lexical scoping}, meaning that a function{\textquotesingle}s scope does not inherit from its caller{\textquotesingle}s scope, but from the scope in which the function was defined. For example, in the following code the \texttt{x} inside \texttt{foo} refers to the \texttt{x} in the global scope of its module \texttt{Bar}:




\begin{lstlisting}
julia> module Bar
           x = 1
           foo() = x
       end;
\end{lstlisting}



and not a \texttt{x} in the scope where \texttt{foo} is used:




\begin{lstlisting}
julia> import .Bar

julia> x = -1;

julia> Bar.foo()
1
\end{lstlisting}



Thus \emph{lexical scope} means that the scope of variables can be inferred from the source code alone.



\hypertarget{1579695877498494307}{}


\section{Global Scope}



\emph{Each module introduces a new global scope}, separate from the global scope of all other modules; there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the \hyperlink{10438697863683890874}{using or import} statements or through qualified access using the dot-notation, i.e. each module is a so-called \emph{namespace}. Note that variable bindings can only be changed within their global scope and not from an outside module.




\begin{minted}{jlcon}
julia> module A
           a = 1 # a global in A's scope
       end;

julia> module B
           module C
               c = 2
           end
           b = C.c    # can access the namespace of a nested global scope
                      # through a qualified access
           import ..A # makes module A available
           d = A.a
       end;

julia> module D
           b = a # errors as D's global scope is separate from A's
       end;
ERROR: UndefVarError: a not defined

julia> module E
           import ..A # make module A available
           A.a = 2    # throws below error
       end;
ERROR: cannot assign variables in other modules
\end{minted}



Note that the interactive prompt (aka REPL) is in the global scope of the module \texttt{Main}.



\hypertarget{9696494911619820682}{}


\section{Local Scope}



A new local scope is introduced by most code-blocks, see above table for a complete list.  A local scope \emph{usually} inherits all the variables from its parent scope, both for reading and writing. There are two subtypes of local scopes, hard and soft, with slightly different rules concerning what variables are inherited. Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.



The following rules and examples pertain to both hard and soft local scopes. A newly introduced variable in a local scope does not back-propagate to its parent scope. For example, here the \texttt{z} is not introduced into the top-level scope:




\begin{minted}{jlcon}
julia> for i = 1:10
           z = i
       end

julia> z
ERROR: UndefVarError: z not defined
\end{minted}



(Note, in this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.)



Inside a local scope a variable can be forced to be a local variable using the \texttt{local} keyword:




\begin{minted}{jlcon}
julia> x = 0;

julia> for i = 1:10
           local x
           x = i + 1
       end

julia> x
0
\end{minted}



Inside a local scope a new global variable can be defined using the keyword \texttt{global}:




\begin{minted}{jlcon}
julia> for i = 1:10
           global z
           z = i
       end

julia> z
10
\end{minted}



The location of both the \texttt{local} and \texttt{global} keywords within the scope block is irrelevant. The following is equivalent to the last example (although stylistically worse):




\begin{minted}{jlcon}
julia> for i = 1:10
           z = i
           global z
       end

julia> z
10
\end{minted}



\hypertarget{1067480096854414457}{}


\subsection{Soft Local Scope}



\begin{quote}
In a soft local scope, all variables are inherited from its parent scope unless a variable is specifically marked with the keyword \texttt{local}.

\end{quote}


Soft local scopes are introduced by for-loops, while-loops, comprehensions, try-catch-finally-blocks, and let-blocks. There are some extra rules for \hyperlink{17888603710983697952}{Let Blocks} and for \hyperlink{7901208257228524319}{For Loops and Comprehensions}.



In the following example the \texttt{x} and \texttt{y} refer always to the same variables as the soft local scope inherits both read and write variables:




\begin{minted}{jlcon}
julia> x, y = 0, 1;

julia> for i = 1:10
           x = i + y + 1
       end

julia> x
12
\end{minted}



Within soft scopes, the \emph{global} keyword is never necessary, although allowed. The only case when it would change the semantics is (currently) a syntax error:




\begin{minted}{jlcon}
julia> let
           local j = 2
           let
               global j = 3
           end
       end
ERROR: syntax: `global j`: j is local variable in the enclosing scope
\end{minted}



\hypertarget{2878080290330580157}{}


\subsection{Hard Local Scope}



Hard local scopes are introduced by function definitions (in all their forms), struct type definition blocks, and macro-definitions.



\begin{quote}
In a hard local scope, all variables are inherited from its parent scope unless:

\begin{itemize}
\item an assignment would result in a modified \emph{global} variable, or


\item a variable is specifically marked with the keyword \texttt{local}.

\end{itemize}
\end{quote}


Thus global variables are only inherited for reading but not for writing:




\begin{minted}{jlcon}
julia> x, y = 1, 2;

julia> function foo()
           x = 2        # assignment introduces a new local
           return x + y # y refers to the global
       end;

julia> foo()
4

julia> x
1
\end{minted}



An explicit \texttt{global} is needed to assign to a global variable:




\begin{minted}{jlcon}
julia> x = 1;

julia> function foobar()
           global x = 2
       end;

julia> foobar();

julia> x
2
\end{minted}



Note that \emph{nested functions} can behave differently to functions defined in the global scope as they can modify their parent scope{\textquotesingle}s \emph{local} variables:




\begin{minted}{jlcon}
julia> x, y = 1, 2;

julia> function baz()
           x = 2 # introduces a new local
           function bar()
               x = 10       # modifies the parent's x
               return x + y # y is global
           end
           return bar() + x # 12 + 10 (x is modified in call of bar())
       end;

julia> baz()
22

julia> x, y
(1, 2)
\end{minted}



The distinction between inheriting global and local variables for assignment can lead to some slight differences between functions defined in local vs. global scopes. Consider the modification of the last example by moving \texttt{bar} to the global scope:




\begin{minted}{jlcon}
julia> x, y = 1, 2;

julia> function bar()
           x = 10 # local
           return x + y
       end;

julia> function quz()
           x = 2 # local
           return bar() + x # 12 + 2 (x is not modified)
       end;

julia> quz()
14

julia> x, y
(1, 2)
\end{minted}



Note that above subtlety does not pertain to type and macro definitions as they can only appear at the global scope. There are special scoping rules concerning the evaluation of default and keyword function arguments which are described in the \hyperlink{11836327794581856778}{Function section}.



An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:




\begin{minted}{jlcon}
julia> f = y -> y + a
(::#1) (generic function with 1 method)

julia> f(3)
ERROR: UndefVarError: a not defined
Stacktrace:
 [1] (::##1#2)(::Int64) at ./none:1

julia> a = 1
1

julia> f(3)
4
\end{minted}



This behavior may seem slightly odd for a normal variable, but allows for named functions – which are just normal variables holding function objects – to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:




\begin{minted}{jlcon}
julia> even(n) = n == 0 ? true : odd(n-1);

julia> odd(n) = n == 0 ? false : even(n-1);

julia> even(3)
false

julia> odd(3)
true
\end{minted}



Julia provides built-in, efficient functions to test for oddness and evenness called \hyperlink{6755629456808693979}{\texttt{iseven()}} and \hyperlink{2288006657111547854}{\texttt{isodd()}} so the above definitions should only be taken as examples.



\hypertarget{10504791923115890480}{}


\subsection{Hard vs. Soft Local Scope}



Blocks which introduce a soft local scope, such as loops, are generally used to manipulate the variables in their parent scope. Thus their default is to fully access all variables in their parent scope.



Conversely, the code inside blocks which introduce a hard local scope (function, type, and macro definitions) can be executed at any place in a program. Remotely changing the state of global variables in other modules should be done with care and thus this is an opt-in feature requiring the \texttt{global} keyword.



The reason to allow \emph{modifying local} variables of parent scopes in nested functions is to allow constructing \href{https://en.wikipedia.org/wiki/Closure\_\%28computer\_programming\%29}{closures} which have a private state, for instance the \texttt{state} variable in the following example:




\begin{minted}{jlcon}
julia> let
           state = 0
           global counter
           counter() = state += 1
       end;

julia> counter()
1

julia> counter()
2
\end{minted}



See also the closures in the examples in the next two sections.



\hypertarget{17888603710983697952}{}


\subsection{Let Blocks}



Unlike assignments to local variables, \texttt{let} statements allocate new variable bindings each time they run. An assignment modifies an existing value location, and \texttt{let} creates new locations. This difference is usually not important, and is only detectable in the case of variables that outlive their scope via closures. The \texttt{let} syntax accepts a comma-separated series of assignments and variable names:




\begin{minted}{jlcon}
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           println("x: $x, y: $y") # x is local variable, y the global
           println("z: $z") # errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: z not defined
\end{minted}



The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like \texttt{let x = x} since the two \texttt{x} variables are distinct and have separate storage. Here is an example where the behavior of \texttt{let} is needed:




\begin{minted}{jlcon}
julia> Fs = Array{Any}(2); i = 1;

julia> while i <= 2
           Fs[i] = ()->i
           i += 1
       end

julia> Fs[1]()
3

julia> Fs[2]()
3
\end{minted}



Here we create and store two closures that return variable \texttt{i}. However, it is always the same variable \texttt{i}, so the two closures behave identically. We can use \texttt{let} to create a new binding for \texttt{i}:




\begin{minted}{jlcon}
julia> Fs = Array{Any}(2); i = 1;

julia> while i <= 2
           let i = i
               Fs[i] = ()->i
           end
           i += 1
       end

julia> Fs[1]()
1

julia> Fs[2]()
2
\end{minted}



Since the \texttt{begin} construct does not introduce a new scope, it can be useful to use a zero-argument \texttt{let} to just introduce a new scope block without creating any new bindings:




\begin{minted}{jlcon}
julia> let
           local x = 1
           let
               local x = 2
           end
           x
       end
1
\end{minted}



Since \texttt{let} introduces a new scope block, the inner local \texttt{x} is a different variable than the outer local \texttt{x}.



\hypertarget{7901208257228524319}{}


\subsection{For Loops and Comprehensions}



\texttt{for} loops and \hyperlink{10712284114727773149}{Comprehensions} have the following behavior: any new variables introduced in their body scopes are freshly allocated for each loop iteration. This is in contrast to \texttt{while} loops which reuse the variables for all iterations. Therefore these constructs are similar to \texttt{while} loops with \texttt{let} blocks inside:




\begin{minted}{jlcon}
julia> Fs = Array{Any}(2);

julia> for j = 1:2
           Fs[j] = ()->j
       end

julia> Fs[1]()
1

julia> Fs[2]()
2
\end{minted}



\texttt{for} loops will reuse existing variables for its iteration variable:




\begin{minted}{jlcon}
julia> i = 0;

julia> for i = 1:3
       end

julia> i
3
\end{minted}



However, comprehensions do not do this, and always freshly allocate their iteration variables:




\begin{minted}{jlcon}
julia> x = 0;

julia> [ x for x = 1:3 ];

julia> x
0
\end{minted}



\hypertarget{15375320667239362911}{}


\section{Constants}



A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the \texttt{const} keyword:




\begin{minted}{jlcon}
julia> const e  = 2.71828182845904523536;

julia> const pi = 3.14159265358979323846;
\end{minted}



The \texttt{const} declaration is allowed on both global and local variables, but is especially useful for globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a \texttt{const} declaration solves this performance problem.



Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary for performance purposes.



Special top-level assignments, such as those performed by the \texttt{function} and \texttt{struct} keywords, are constant by default.



Note that \texttt{const} only affects the variable binding; the variable may be bound to a mutable object (such as an array), and that object may still be modified.



\hypertarget{2141690262982725665}{}


\chapter{Types}



Type systems have traditionally fallen into two quite different camps: static type systems, where every program expression must have a type computable before the execution of the program, and dynamic type systems, where nothing is known about types until run time, when the actual values manipulated by the program are available. Object orientation allows some flexibility in statically typed languages by letting code be written without the precise types of values being known at compile time. The ability to write code that can operate on different types is called polymorphism. All code in classic dynamically typed languages is polymorphic: only by explicitly checking types, or when objects fail to support operations at run-time, are the types of any values ever restricted.



Julia{\textquotesingle}s type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in \hyperlink{15216268953652766477}{Methods}, but is rooted in the type system presented here.



The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia programs without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously {\textquotedbl}untyped{\textquotedbl} code. Doing so will typically increase both the performance and robustness of these systems, and perhaps somewhat counterintuitively, often significantly simplify them.



Describing Julia in the lingo of \href{https://en.wikipedia.org/wiki/Type\_system}{type systems}, it is: dynamic, nominative and parametric. Generic types can be parameterized, and the hierarchical relationships between types are \href{https://en.wikipedia.org/wiki/Nominal\_type\_system}{explicitly declared}, rather than \href{https://en.wikipedia.org/wiki/Structural\_type\_system}{implied by compatible structure}. One particularly distinctive feature of Julia{\textquotesingle}s type system is that concrete types may not subtype each other: all concrete types are final and may only have abstract types as their supertypes. While this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly few drawbacks. It turns out that being able to inherit behavior is much more important than being able to inherit structure, and inheriting both causes significant difficulties in traditional object-oriented languages. Other high-level aspects of Julia{\textquotesingle}s type system that should be mentioned up front are:



\begin{itemize}
\item There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.


\item There is no meaningful concept of a {\textquotedbl}compile-time type{\textquotedbl}: the only type a value has is its actual type when the program is running. This is called a {\textquotedbl}run-time type{\textquotedbl} in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.


\item Only values, not variables, have types – variables are simply names bound to values.


\item Both abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for which \hyperlink{12980593021531333073}{\texttt{isbits()}} returns true (essentially, things like numbers and bools that are stored like C types or structs with no pointers to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted.

\end{itemize}


Julia{\textquotesingle}s type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.



\hypertarget{5748457847765867392}{}


\section{Type Declarations}



The \texttt{::} operator can be used to attach type annotations to expressions and variables in programs. There are two primary reasons to do this:



\begin{itemize}
\item[1. ] As an assertion to help confirm that your program works the way you expect,


\item[2. ] To provide extra type information to the compiler, which can then improve performance in some cases

\end{itemize}


When appended to an expression computing a value, the \texttt{::} operator is read as {\textquotedbl}is an instance of{\textquotedbl}. It can be used anywhere to assert that the value of the expression on the left is an instance of the type on the right. When the type on the right is concrete, the value on the left must have that type as its implementation – recall that all concrete types are final, so no implementation is a subtype of any other. When the type is abstract, it suffices for the value to be implemented by a concrete type that is a subtype of the abstract type. If the type assertion is not true, an exception is thrown, otherwise, the left-hand value is returned:




\begin{minted}{jlcon}
julia> (1+2)::AbstractFloat
ERROR: TypeError: typeassert: expected AbstractFloat, got Int64

julia> (1+2)::Int
3
\end{minted}



This allows a type assertion to be attached to any expression in-place.



When appended to a variable on the left-hand side of an assignment, or as part of a \texttt{local} declaration, the \texttt{::} operator means something a bit different: it declares the variable to always have the specified type, like a type declaration in a statically-typed language such as C. Every value assigned to the variable will be converted to the declared type using \hyperlink{1846942650946171605}{\texttt{convert()}}:




\begin{minted}{jlcon}
julia> function foo()
           x::Int8 = 100
           x
       end
foo (generic function with 1 method)

julia> foo()
100

julia> typeof(ans)
Int8
\end{minted}



This feature is useful for avoiding performance {\textquotedbl}gotchas{\textquotedbl} that could occur if one of the assignments to a variable changed its type unexpectedly.



This {\textquotedbl}declaration{\textquotedbl} behavior only occurs in specific contexts:




\begin{minted}{julia}
local x::Int8  # in a local declaration
x::Int8 = 10   # as the left-hand side of an assignment
\end{minted}



and applies to the whole current scope, even before the declaration. Currently, type declarations cannot be used in global scope, e.g. in the REPL, since Julia does not yet have constant-type globals.



Declarations can also be attached to function definitions:




\begin{minted}{julia}
function sinc(x)::Float64
    if x == 0
        return 1
    end
    return sin(pi*x)/(pi*x)
end
\end{minted}



Returning from this function behaves just like an assignment to a variable with a declared type: the value is always converted to \texttt{Float64}.



\hypertarget{6557251968716577908}{}


\section{Abstract Types}



Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia{\textquotesingle}s type system more than just a collection of object implementations.



Recall that in \hyperlink{17453309092420764607}{Integers and Floating-Point Numbers}, we introduced a variety of concrete types of numeric values: \hyperlink{5857518405103968275}{\texttt{Int8}}, \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{6667287249103968645}{\texttt{Int16}}, \hyperlink{7018610346698168012}{\texttt{UInt16}}, \hyperlink{10103694114785108551}{\texttt{Int32}}, \hyperlink{8690996847580776341}{\texttt{UInt32}}, \hyperlink{7720564657383125058}{\texttt{Int64}}, \hyperlink{5500998675195555601}{\texttt{UInt64}}, \hyperlink{8012327724714767060}{\texttt{Int128}}, \hyperlink{14811222188335428522}{\texttt{UInt128}}, \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}}. Although they have different representation sizes, \texttt{Int8}, \texttt{Int16}, \texttt{Int32}, \texttt{Int64} and \texttt{Int128} all have in common that they are signed integer types. Likewise \texttt{UInt8}, \texttt{UInt16}, \texttt{UInt32}, \texttt{UInt64} and \texttt{UInt128} are all unsigned integer types, while \texttt{Float16}, \texttt{Float32} and \texttt{Float64} are distinct in being floating-point types rather than integers. It is common for a piece of code to make sense, for example, only if its arguments are some kind of integer, but not really depend on what particular \emph{kind} of integer. For example, the greatest common denominator algorithm works for all kinds of integers, but will not work for floating-point numbers. Abstract types allow the construction of a hierarchy of types, providing a context into which concrete types can fit. This allows you, for example, to easily program to any type that is an integer, without restricting an algorithm to a specific type of integer.



Abstract types are declared using the \texttt{abstract type} keyword. The general syntaxes for declaring an abstract type are:




\begin{lstlisting}
abstract type «name» end
abstract type «name» <: «supertype» end
\end{lstlisting}



The \texttt{abstract type} keyword introduces a new abstract type, whose name is given by \texttt{«name»}. This name can be optionally followed by \texttt{<:} and an already-existing type, indicating that the newly declared abstract type is a subtype of this {\textquotedbl}parent{\textquotedbl} type.



When no supertype is given, the default supertype is \texttt{Any} – a predefined abstract type that all objects are instances of and all types are subtypes of. In type theory, \texttt{Any} is commonly called {\textquotedbl}top{\textquotedbl} because it is at the apex of the type graph. Julia also has a predefined abstract {\textquotedbl}bottom{\textquotedbl} type, at the nadir of the type graph, which is written as \texttt{Union\{\}}. It is the exact opposite of \texttt{Any}: no object is an instance of \texttt{Union\{\}} and all types are supertypes of \texttt{Union\{\}}.



Let{\textquotesingle}s consider some of the abstract types that make up Julia{\textquotesingle}s numerical hierarchy:




\begin{minted}{julia}
abstract type Number end
abstract type Real     <: Number end
abstract type AbstractFloat <: Real end
abstract type Integer  <: Real end
abstract type Signed   <: Integer end
abstract type Unsigned <: Integer end
\end{minted}



The \hyperlink{1990584313715697055}{\texttt{Number}} type is a direct child type of \texttt{Any}, and \hyperlink{6175959395021454412}{\texttt{Real}} is its child. In turn, \texttt{Real} has two children (it has more, but only two are shown here; we{\textquotesingle}ll get to the others later): \hyperlink{8469131683393450448}{\texttt{Integer}} and \hyperlink{11465394427882483091}{\texttt{AbstractFloat}}, separating the world into representations of integers and representations of real numbers. Representations of real numbers include, of course, floating-point types, but also include other types, such as rationals. Hence, \texttt{AbstractFloat} is a proper subtype of \texttt{Real}, including only floating-point representations of real numbers. Integers are further subdivided into \hyperlink{14154866400772377486}{\texttt{Signed}} and \hyperlink{4780971278803506664}{\texttt{Unsigned}} varieties.



The \texttt{<:} operator in general means {\textquotedbl}is a subtype of{\textquotedbl}, and, used in declarations like this, declares the right-hand type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype operator which returns \texttt{true} when its left operand is a subtype of its right operand:




\begin{minted}{jlcon}
julia> Integer <: Number
true

julia> Integer <: AbstractFloat
false
\end{minted}



An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:




\begin{minted}{julia}
function myplus(x,y)
    x+y
end
\end{minted}



The first thing to note is that the above argument declarations are equivalent to \texttt{x::Any} and \texttt{y::Any}. When this function is invoked, say as \texttt{myplus(2,5)}, the dispatcher chooses the most specific method named \texttt{myplus} that matches the given arguments. (See \hyperlink{15216268953652766477}{Methods} for more information on multiple dispatch.)



Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called \texttt{myplus} specifically for two \texttt{Int} arguments based on the generic function given above, i.e., it implicitly defines and compiles:




\begin{minted}{julia}
function myplus(x::Int,y::Int)
    x+y
end
\end{minted}



and finally, it invokes this specific method.



Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.



An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see \hyperlink{3908315974291496321}{Performance Tips}.)



\hypertarget{9262821145239033459}{}


\section{Primitive Types}



A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:




\begin{minted}{julia}
primitive type Float16 <: AbstractFloat 16 end
primitive type Float32 <: AbstractFloat 32 end
primitive type Float64 <: AbstractFloat 64 end

primitive type Bool <: Integer 8 end
primitive type Char 32 end

primitive type Int8    <: Signed   8 end
primitive type UInt8   <: Unsigned 8 end
primitive type Int16   <: Signed   16 end
primitive type UInt16  <: Unsigned 16 end
primitive type Int32   <: Signed   32 end
primitive type UInt32  <: Unsigned 32 end
primitive type Int64   <: Signed   64 end
primitive type UInt64  <: Unsigned 64 end
primitive type Int128  <: Signed   128 end
primitive type UInt128 <: Unsigned 128 end
\end{minted}



The general syntaxes for declaring a primitive type are:




\begin{lstlisting}
primitive type «name» «bits» end
primitive type «name» <: «supertype» «bits» end
\end{lstlisting}



The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having \texttt{Any} as its immediate supertype. The declaration of \hyperlink{46725311238864537}{\texttt{Bool}} above therefore means that a boolean value takes eight bits to store, and has \hyperlink{8469131683393450448}{\texttt{Integer}} as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.



The types \hyperlink{46725311238864537}{\texttt{Bool}}, \hyperlink{5857518405103968275}{\texttt{Int8}} and \hyperlink{6609065134969660118}{\texttt{UInt8}} all have identical representations: they are eight-bit chunks of memory. Since Julia{\textquotesingle}s type system is nominative, however, they are not interchangeable despite having identical structure. A fundamental difference between them is that they have different supertypes: \hyperlink{46725311238864537}{\texttt{Bool}}{\textquotesingle}s direct supertype is \hyperlink{8469131683393450448}{\texttt{Integer}}, \hyperlink{5857518405103968275}{\texttt{Int8}}{\textquotesingle}s is \hyperlink{14154866400772377486}{\texttt{Signed}}, and \hyperlink{6609065134969660118}{\texttt{UInt8}}{\textquotesingle}s is \hyperlink{4780971278803506664}{\texttt{Unsigned}}. All other differences between \hyperlink{46725311238864537}{\texttt{Bool}}, \hyperlink{5857518405103968275}{\texttt{Int8}}, and \hyperlink{6609065134969660118}{\texttt{UInt8}} are matters of behavior – the way functions are defined to act when given objects of these types as arguments. This is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make \hyperlink{46725311238864537}{\texttt{Bool}} behave any differently than \hyperlink{5857518405103968275}{\texttt{Int8}} or \hyperlink{6609065134969660118}{\texttt{UInt8}}.



\hypertarget{7447321282005802875}{}


\section{Composite Types}



\href{https://en.wikipedia.org/wiki/Composite\_data\_type}{Composite types} are called records, structs, or objects in various languages. A composite type is a collection of named fields, an instance of which can be treated as a single value. In many languages, composite types are the only kind of user-definable type, and they are by far the most commonly used user-defined type in Julia as well.



In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an {\textquotedbl}object{\textquotedbl}. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of \emph{all} of a function{\textquotesingle}s arguments are considered when selecting a method, rather than just the first one (see \hyperlink{15216268953652766477}{Methods} for more information on methods and dispatch). Thus, it would be inappropriate for functions to {\textquotedbl}belong{\textquotedbl} to only their first argument. Organizing methods into function objects rather than having named bags of methods {\textquotedbl}inside{\textquotedbl} each object ends up being a highly beneficial aspect of the language design.



Composite types are introduced with the \texttt{struct} keyword followed by a block of field names, optionally annotated with types using the \texttt{::} operator:




\begin{lstlisting}
julia> struct Foo
           bar
           baz::Int
           qux::Float64
       end
\end{lstlisting}



Fields with no type annotation default to \texttt{Any}, and can accordingly hold any type of value.



New objects of type \texttt{Foo} are created by applying the \texttt{Foo} type object like a function to values for its fields:




\begin{lstlisting}
julia> foo = Foo("Hello, world.", 23, 1.5)
Foo("Hello, world.", 23, 1.5)

julia> typeof(foo)
Foo
\end{lstlisting}



When a type is applied like a function it is called a \emph{constructor}. Two constructors are generated automatically (these are called \emph{default constructors}). One accepts any arguments and calls \hyperlink{1846942650946171605}{\texttt{convert()}} to convert them to the types of the fields, and the other accepts arguments that match the field types exactly. The reason both of these are generated is that this makes it easier to add new definitions without inadvertently replacing a default constructor.



Since the \texttt{bar} field is unconstrained in type, any value will do. However, the value for \texttt{baz} must be convertible to \texttt{Int}:




\begin{lstlisting}
julia> Foo((), 23.5, 1)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int64}, ::Float64) at ./float.jl:679
 [2] Foo(::Tuple{}, ::Float64, ::Int64) at ./none:2
\end{lstlisting}



You may find a list of field names using the \texttt{fieldnames} function.




\begin{lstlisting}
julia> fieldnames(foo)
3-element Array{Symbol,1}:
 :bar
 :baz
 :qux
\end{lstlisting}



You can access the field values of a composite object using the traditional \texttt{foo.bar} notation:




\begin{lstlisting}
julia> foo.bar
"Hello, world."

julia> foo.baz
23

julia> foo.qux
1.5
\end{lstlisting}



Composite objects declared with \texttt{struct} are \emph{immutable}; they cannot be modified after construction. This may seem odd at first, but it has several advantages:



\begin{itemize}
\item It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.


\item It is not possible to violate the invariants provided by the type{\textquotesingle}s constructors.


\item Code using immutable objects can be easier to reason about.

\end{itemize}


An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.



Where required, mutable composite objects can be declared with the keyword \texttt{mutable struct}, to be discussed in the next section.



Composite types with no fields are singletons; there can be only one instance of such types:




\begin{minted}{jlcon}
julia> struct NoFields
       end

julia> NoFields() === NoFields()
true
\end{minted}



The \texttt{===} function confirms that the {\textquotedbl}two{\textquotedbl} constructed instances of \texttt{NoFields} are actually one and the same. Singleton types are described in further detail \hyperlink{647919389478144252}{below}.



There is much more to say about how instances of composite types are created, but that discussion depends on both \hyperlink{15542027490314302254}{Parametric Types} and on \hyperlink{15216268953652766477}{Methods}, and is sufficiently important to be addressed in its own section: \hyperlink{17317810227993044854}{Constructors}.



\hypertarget{15660711504809541251}{}


\section{Mutable Composite Types}



If a composite type is declared with \texttt{mutable struct} instead of \texttt{struct}, then instances of it can be modified:




\begin{lstlisting}
julia> mutable struct Bar
           baz
           qux::Float64
       end

julia> bar = Bar("Hello", 1.5);

julia> bar.qux = 2.0
2.0

julia> bar.baz = 1//2
1//2
\end{lstlisting}



In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values –- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.



To recap, two essential properties define immutability in Julia:



\begin{itemize}
\item An object with an immutable type is passed around (both in assignment statements and in function calls) by copying, whereas a mutable type is passed around by reference.


\item It is not permitted to modify the fields of a composite immutable type.

\end{itemize}


It is instructive, particularly for readers whose background is C/C++, to consider why these two properties go hand in hand.  If they were separated, i.e., if the fields of objects passed around by copying could be modified, then it would become more difficult to reason about certain instances of generic code.  For example, suppose \texttt{x} is a function argument of an abstract type, and suppose that the function changes a field: \texttt{x.isprocessed = true}.  Depending on whether \texttt{x} is passed by copying or by reference, this statement may or may not alter the actual argument in the calling routine.  Julia sidesteps the possibility of creating functions with unknown effects in this scenario by forbidding modification of fields of objects passed around by copying.



\hypertarget{16251238064611233}{}


\section{Declared Types}



The three kinds of types discussed in the previous three sections are actually all closely related. They share the same key properties:



\begin{itemize}
\item They are explicitly declared.


\item They have names.


\item They have explicitly declared supertypes.


\item They may have parameters.

\end{itemize}


Because of these shared properties, these types are internally represented as instances of the same concept, \texttt{DataType}, which is the type of any of these types:




\begin{minted}{jlcon}
julia> typeof(Real)
DataType

julia> typeof(Int)
DataType
\end{minted}



A \texttt{DataType} may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a bits type is a \texttt{DataType} with nonzero size, but no field names. A composite type is a \texttt{DataType} that has field names or is empty (zero size).



Every concrete value in the system is an instance of some \texttt{DataType}.



\hypertarget{14349410932971039661}{}


\section{Type Unions}



A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special \texttt{Union} function:




\begin{minted}{jlcon}
julia> IntOrString = Union{Int,AbstractString}
Union{AbstractString, Int64}

julia> 1 :: IntOrString
1

julia> "Hello!" :: IntOrString
"Hello!"

julia> 1.0 :: IntOrString
ERROR: TypeError: typeassert: expected Union{AbstractString, Int64}, got Float64
\end{minted}



The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer.



\hypertarget{15542027490314302254}{}


\section{Parametric Types}



An important and powerful feature of Julia{\textquotesingle}s type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types – one for each possible combination of parameter values. There are many languages that support some version of \href{https://en.wikipedia.org/wiki/Generic\_programming}{generic programming}, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C\#, F\#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won{\textquotesingle}t even attempt to compare Julia{\textquotesingle}s parametric types to other languages, but will instead focus on explaining Julia{\textquotesingle}s system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn{\textquotesingle}t need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.



All declared types (the \texttt{DataType} variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric bits types.



\hypertarget{7380966005300475368}{}


\subsection{Parametric Composite Types}



Type parameters are introduced immediately after the type name, surrounded by curly braces:




\begin{lstlisting}
julia> struct Point{T}
           x::T
           y::T
       end
\end{lstlisting}



This declaration defines a new parametric type, \texttt{Point\{T\}}, holding two {\textquotedbl}coordinates{\textquotedbl} of type \texttt{T}. What, one may ask, is \texttt{T}? Well, that{\textquotesingle}s precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it{\textquotesingle}s clearly used as a type). \texttt{Point\{Float64\}} is a concrete type equivalent to the type defined by replacing \texttt{T} in the definition of \texttt{Point} with \hyperlink{5027751419500983000}{\texttt{Float64}}. Thus, this single declaration actually declares an unlimited number of types: \texttt{Point\{Float64\}}, \texttt{Point\{AbstractString\}}, \texttt{Point\{Int64\}}, etc. Each of these is now a usable concrete type:




\begin{lstlisting}
julia> Point{Float64}
Point{Float64}

julia> Point{AbstractString}
Point{AbstractString}
\end{lstlisting}



The type \texttt{Point\{Float64\}} is a point whose coordinates are 64-bit floating-point values, while the type \texttt{Point\{AbstractString\}} is a {\textquotedbl}point{\textquotedbl} whose {\textquotedbl}coordinates{\textquotedbl} are string objects (see \hyperlink{5278796056388981234}{Strings}).



\texttt{Point} itself is also a valid type object, containing all instances \texttt{Point\{Float64\}}, \texttt{Point\{AbstractString\}}, etc. as subtypes:




\begin{lstlisting}
julia> Point{Float64} <: Point
true

julia> Point{AbstractString} <: Point
true
\end{lstlisting}



Other types, of course, are not subtypes of it:




\begin{lstlisting}
julia> Float64 <: Point
false

julia> AbstractString <: Point
false
\end{lstlisting}



Concrete \texttt{Point} types with different values of \texttt{T} are never subtypes of each other:




\begin{lstlisting}
julia> Point{Float64} <: Point{Int64}
false

julia> Point{Float64} <: Point{Real}
false
\end{lstlisting}



\begin{quote}
\textbf{Warning}

This last point is \emph{very} important: even though \texttt{Float64 <: Real} we \textbf{DO NOT} have \texttt{Point\{Float64\} <: Point\{Real\}}.

\end{quote}


In other words, in the parlance of type theory, Julia{\textquotesingle}s type parameters are \emph{invariant}, rather than being \href{https://en.wikipedia.org/wiki/Covariance\_and\_contravariance\_\%28computer\_science\%29}{covariant (or even contravariant)}. This is for practical reasons: while any instance of \texttt{Point\{Float64\}} may conceptually be like an instance of \texttt{Point\{Real\}} as well, the two types have different representations in memory:



\begin{itemize}
\item An instance of \texttt{Point\{Float64\}} can be represented compactly and efficiently as an immediate pair of 64-bit values;


\item An instance of \texttt{Point\{Real\}} must be able to hold any pair of instances of \hyperlink{6175959395021454412}{\texttt{Real}}. Since objects that are instances of \texttt{Real} can be of arbitrary size and structure, in practice an instance of \texttt{Point\{Real\}} must be represented as a pair of pointers to individually allocated \texttt{Real} objects.

\end{itemize}


The efficiency gained by being able to store \texttt{Point\{Float64\}} objects with immediate values is magnified enormously in the case of arrays: an \texttt{Array\{Float64\}} can be stored as a contiguous memory block of 64-bit floating-point values, whereas an \texttt{Array\{Real\}} must be an array of pointers to individually allocated \hyperlink{6175959395021454412}{\texttt{Real}} objects – which may well be \href{https://en.wikipedia.org/wiki/Object\_type\_\%28object-oriented\_programming\%29\#Boxing}{boxed} 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the \texttt{Real} abstract type.



Since \texttt{Point\{Float64\}} is not a subtype of \texttt{Point\{Real\}}, the following method can{\textquotesingle}t be applied to arguments of type \texttt{Point\{Float64\}}:




\begin{minted}{julia}
function norm(p::Point{Real})
    sqrt(p.x^2 + p.y^2)
end
\end{minted}



A correct way to define a method that accepts all arguments of type \texttt{Point\{T\}} where \texttt{T} is a subtype of \hyperlink{6175959395021454412}{\texttt{Real}} is:




\begin{minted}{julia}
function norm(p::Point{<:Real})
    sqrt(p.x^2 + p.y^2)
end
\end{minted}



(Equivalently, one could define \texttt{function norm\{T<:Real\}(p::Point\{T\})} or \texttt{function norm(p::Point\{T\} where T<:Real)}; see \hyperlink{16945289962829222266}{UnionAll Types}.)



More examples will be discussed later in \hyperlink{15216268953652766477}{Methods}.



How does one construct a \texttt{Point} object? It is possible to define custom constructors for composite types, which will be discussed in detail in \hyperlink{17317810227993044854}{Constructors}, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.



Since the type \texttt{Point\{Float64\}} is a concrete type equivalent to \texttt{Point} declared with \hyperlink{5027751419500983000}{\texttt{Float64}} in place of \texttt{T}, it can be applied as a constructor accordingly:




\begin{lstlisting}
julia> Point{Float64}(1.0, 2.0)
Point{Float64}(1.0, 2.0)

julia> typeof(ans)
Point{Float64}
\end{lstlisting}



For the default constructor, exactly one argument must be supplied for each field:




\begin{lstlisting}
julia> Point{Float64}(1.0)
ERROR: MethodError: Cannot `convert` an object of type Float64 to an object of type Point{Float64}
This may have arisen from a call to the constructor Point{Float64}(...),
since type constructors fall back to convert methods.
Stacktrace:
 [1] Point{Float64}(::Float64) at ./sysimg.jl:77

julia> Point{Float64}(1.0,2.0,3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
\end{lstlisting}



Only one default constructor is generated for parametric types, since overriding it is not possible. This constructor accepts any arguments and converts them to the field types.



In many cases, it is redundant to provide the type of \texttt{Point} object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply \texttt{Point} itself as a constructor, provided that the implied value of the parameter type \texttt{T} is unambiguous:




\begin{lstlisting}
julia> Point(1.0,2.0)
Point{Float64}(1.0, 2.0)

julia> typeof(ans)
Point{Float64}

julia> Point(1,2)
Point{Int64}(1, 2)

julia> typeof(ans)
Point{Int64}
\end{lstlisting}



In the case of \texttt{Point}, the type of \texttt{T} is unambiguously implied if and only if the two arguments to \texttt{Point} have the same type. When this isn{\textquotesingle}t the case, the constructor will fail with a \hyperlink{14644228586476494020}{\texttt{MethodError}}:




\begin{lstlisting}
julia> Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T at none:2
\end{lstlisting}



Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in \hyperlink{17317810227993044854}{Constructors}.



\hypertarget{11537930345213041339}{}


\subsection{Parametric Abstract Types}



Parametric abstract type declarations declare a collection of abstract types, in much the same way:




\begin{lstlisting}
julia> abstract type Pointy{T} end
\end{lstlisting}



With this declaration, \texttt{Pointy\{T\}} is a distinct abstract type for each type or integer value of \texttt{T}. As with parametric composite types, each such instance is a subtype of \texttt{Pointy}:




\begin{lstlisting}
julia> Pointy{Int64} <: Pointy
true

julia> Pointy{1} <: Pointy
true
\end{lstlisting}



Parametric abstract types are invariant, much as parametric composite types are:




\begin{lstlisting}
julia> Pointy{Float64} <: Pointy{Real}
false

julia> Pointy{Real} <: Pointy{Float64}
false
\end{lstlisting}



The notation \texttt{Pointy\{<:Real\}} can be used to express the Julia analogue of a \emph{covariant} type, while \texttt{Pointy\{>:Int\}} the analogue of a \emph{contravariant} type, but technically these represent \emph{sets} of types (see \hyperlink{16945289962829222266}{UnionAll Types}).




\begin{lstlisting}
julia> Pointy{Float64} <: Pointy{<:Real}
true

julia> Pointy{Real} <: Pointy{>:Int}
true
\end{lstlisting}



Much as plain old abstract types serve to create a useful hierarchy of types over concrete types, parametric abstract types serve the same purpose with respect to parametric composite types. We could, for example, have declared \texttt{Point\{T\}} to be a subtype of \texttt{Pointy\{T\}} as follows:




\begin{lstlisting}
julia> struct Point{T} <: Pointy{T}
           x::T
           y::T
       end
\end{lstlisting}



Given such a declaration, for each choice of \texttt{T}, we have \texttt{Point\{T\}} as a subtype of \texttt{Pointy\{T\}}:




\begin{lstlisting}
julia> Point{Float64} <: Pointy{Float64}
true

julia> Point{Real} <: Pointy{Real}
true

julia> Point{AbstractString} <: Pointy{AbstractString}
true
\end{lstlisting}



This relationship is also invariant:




\begin{lstlisting}
julia> Point{Float64} <: Pointy{Real}
false

julia> Point{Float64} <: Pointy{<:Real}
true
\end{lstlisting}



What purpose do parametric abstract types like \texttt{Pointy} serve? Consider if we create a point-like implementation that only requires a single coordinate because the point is on the diagonal line \emph{x = y}:




\begin{lstlisting}
julia> struct DiagPoint{T} <: Pointy{T}
           x::T
       end
\end{lstlisting}



Now both \texttt{Point\{Float64\}} and \texttt{DiagPoint\{Float64\}} are implementations of the \texttt{Pointy\{Float64\}} abstraction, and similarly for every other possible choice of type \texttt{T}. This allows programming to a common interface shared by all \texttt{Pointy} objects, implemented for both \texttt{Point} and \texttt{DiagPoint}. This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, \hyperlink{15216268953652766477}{Methods}.



There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of \texttt{T} like so:




\begin{lstlisting}
julia> abstract type Pointy{T<:Real} end
\end{lstlisting}



With such a declaration, it is acceptable to use any type that is a subtype of \hyperlink{6175959395021454412}{\texttt{Real}} in place of \texttt{T}, but not types that are not subtypes of \texttt{Real}:




\begin{lstlisting}
julia> Pointy{Float64}
Pointy{Float64}

julia> Pointy{Real}
Pointy{Real}

julia> Pointy{AbstractString}
ERROR: TypeError: Pointy: in T, expected T<:Real, got Type{AbstractString}

julia> Pointy{1}
ERROR: TypeError: Pointy: in T, expected T<:Real, got Int64
\end{lstlisting}



Type parameters for parametric composite types can be restricted in the same manner:




\begin{minted}{julia}
struct Point{T<:Real} <: Pointy{T}
    x::T
    y::T
end
\end{minted}



To give a real-world example of how all this parametric type machinery can be useful, here is the actual definition of Julia{\textquotesingle}s \hyperlink{8304566144531167610}{\texttt{Rational}} immutable type (except that we omit the constructor here for simplicity), representing an exact ratio of integers:




\begin{minted}{julia}
struct Rational{T<:Integer} <: Real
    num::T
    den::T
end
\end{minted}



It only makes sense to take ratios of integer values, so the parameter type \texttt{T} is restricted to being a subtype of \hyperlink{8469131683393450448}{\texttt{Integer}}, and a ratio of integers represents a value on the real number line, so any \hyperlink{8304566144531167610}{\texttt{Rational}} is an instance of the \hyperlink{6175959395021454412}{\texttt{Real}} abstraction.



\hypertarget{3224205729672658846}{}


\subsection{Tuple Types}



Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function{\textquotesingle}s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. For example, a 2-element tuple type resembles the following immutable type:




\begin{minted}{julia}
struct Tuple2{A,B}
    a::A
    b::B
end
\end{minted}



However, there are three key differences:



\begin{itemize}
\item Tuple types may have any number of parameters.


\item Tuple types are \emph{covariant} in their parameters: \texttt{Tuple\{Int\}} is a subtype of \texttt{Tuple\{Any\}}. Therefore \texttt{Tuple\{Any\}} is considered an abstract type, and tuple types are only concrete if their parameters are.


\item Tuples do not have field names; fields are only accessed by index.

\end{itemize}


Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple type is generated on demand:




\begin{minted}{jlcon}
julia> typeof((1,"foo",2.5))
Tuple{Int64,String,Float64}
\end{minted}



Note the implications of covariance:




\begin{minted}{jlcon}
julia> Tuple{Int,AbstractString} <: Tuple{Real,Any}
true

julia> Tuple{Int,AbstractString} <: Tuple{Real,Real}
false

julia> Tuple{Int,AbstractString} <: Tuple{Real,}
false
\end{minted}



Intuitively, this corresponds to the type of a function{\textquotesingle}s arguments being a subtype of the function{\textquotesingle}s signature (when the signature matches).



\hypertarget{8240485352112613618}{}


\subsection{Vararg Tuple Types}



The last parameter of a tuple type can be the special type \texttt{Vararg}, which denotes any number of trailing elements:




\begin{minted}{jlcon}
julia> mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia> isa(("1",), mytupletype)
true

julia> isa(("1",1), mytupletype)
true

julia> isa(("1",1,2), mytupletype)
true

julia> isa(("1",1,2,3.0), mytupletype)
false
\end{minted}



Notice that \texttt{Vararg\{T\}} corresponds to zero or more elements of type \texttt{T}. Vararg tuple types are used to represent the arguments accepted by varargs methods (see \hyperlink{17618471192037406942}{Varargs Functions}).



The type \texttt{Vararg\{T,N\}} corresponds to exactly \texttt{N} elements of type \texttt{T}.  \texttt{NTuple\{N,T\}} is a convenient alias for \texttt{Tuple\{Vararg\{T,N\}\}}, i.e. a tuple type containing exactly \texttt{N} elements of type \texttt{T}.



\hypertarget{647919389478144252}{}


\subsubsection{Singleton Types}



There is a special kind of abstract parametric type that must be mentioned here: singleton types. For each type, \texttt{T}, the {\textquotedbl}singleton type{\textquotedbl} \texttt{Type\{T\}} is an abstract type whose only instance is the object \texttt{T}. Since the definition is a little difficult to parse, let{\textquotesingle}s look at some examples:




\begin{minted}{jlcon}
julia> isa(Float64, Type{Float64})
true

julia> isa(Real, Type{Float64})
false

julia> isa(Real, Type{Real})
true

julia> isa(Float64, Type{Real})
false
\end{minted}



In other words, \hyperlink{7066325108767373297}{\texttt{isa(A,Type\{B\})}} is true if and only if \texttt{A} and \texttt{B} are the same object and that object is a type. Without the parameter, \texttt{Type} is simply an abstract type which has all type objects as its instances, including, of course, singleton types:




\begin{minted}{jlcon}
julia> isa(Type{Float64}, Type)
true

julia> isa(Float64, Type)
true

julia> isa(Real, Type)
true
\end{minted}



Any object that is not a type is not an instance of \texttt{Type}:




\begin{minted}{jlcon}
julia> isa(1, Type)
false

julia> isa("foo", Type)
false
\end{minted}



Until we discuss \hyperlink{14674719184591985798}{Parametric Methods} and \hyperlink{10686378388163930476}{conversions}, it is difficult to explain the utility of the singleton type construct, but in short, it allows one to specialize function behavior on specific type \emph{values}. This is useful for writing methods (especially parametric ones) whose behavior depends on a type that is given as an explicit argument rather than implied by the type of one of its arguments.



A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term {\textquotedbl}singleton type{\textquotedbl} refers to a type whose only instance is a single value. This meaning applies to Julia{\textquotesingle}s singleton types, but with that caveat that only type objects have singleton types.



\hypertarget{7574903190768693591}{}


\subsection{Parametric Primitive Types}



Primitive types can also be declared parametrically. For example, pointers are represented as primitive types which would be declared in Julia like this:




\begin{minted}{julia}
# 32-bit system:
primitive type Ptr{T} 32 end

# 64-bit system:
primitive type Ptr{T} 64 end
\end{minted}



The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter \texttt{T} is not used in the definition of the type itself – it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, \texttt{Ptr\{Float64\}} and \texttt{Ptr\{Int64\}} are distinct types, even though they have identical representations. And of course, all specific pointer types are subtypes of the umbrella \texttt{Ptr} type:




\begin{minted}{jlcon}
julia> Ptr{Float64} <: Ptr
true

julia> Ptr{Int64} <: Ptr
true
\end{minted}



\hypertarget{16945289962829222266}{}


\section{UnionAll Types}



We have said that a parametric type like \texttt{Ptr} acts as a supertype of all its instances (\texttt{Ptr\{Int64\}} etc.). How does this work? \texttt{Ptr} itself cannot be a normal data type, since without knowing the type of the referenced data the type clearly cannot be used for memory operations. The answer is that \texttt{Ptr} (or other parametric types like \texttt{Array}) is a different kind of type called a \texttt{UnionAll} type. Such a type expresses the \emph{iterated union} of types for all values of some parameter.



\texttt{UnionAll} types are usually written using the keyword \texttt{where}. For example \texttt{Ptr} could be more accurately written as \texttt{Ptr\{T\} where T}, meaning all values whose type is \texttt{Ptr\{T\}} for some value of \texttt{T}. In this context, the parameter \texttt{T} is also often called a {\textquotedbl}type variable{\textquotedbl} since it is like a variable that ranges over types. Each \texttt{where} introduces a single type variable, so these expressions are nested for types with multiple parameters, for example \texttt{Array\{T,N\} where N where T}.



The type application syntax \texttt{A\{B,C\}} requires \texttt{A} to be a \texttt{UnionAll} type, and first substitutes \texttt{B} for the outermost type variable in \texttt{A}. The result is expected to be another \texttt{UnionAll} type, into which \texttt{C} is then substituted. So \texttt{A\{B,C\}} is equivalent to \texttt{A\{B\}\{C\}}. This explains why it is possible to partially instantiate a type, as in \texttt{Array\{Float64\}}: the first parameter value has been fixed, but the second still ranges over all possible values. Using explicit \texttt{where} syntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional arrays can be written as \texttt{Array\{T,1\} where T}.



Type variables can be restricted with subtype relations. \texttt{Array\{T\} where T<:Integer} refers to all arrays whose element type is some kind of \hyperlink{8469131683393450448}{\texttt{Integer}}. The syntax \texttt{Array\{<:Integer\}} is a convenient shorthand for \texttt{Array\{T\} where T<:Integer}. Type variables can have both lower and upper bounds. \texttt{Array\{T\} where Int<:T<:Number} refers to all arrays of \hyperlink{1990584313715697055}{\texttt{Number}}s that are able to contain \texttt{Int}s (since \texttt{T} must be at least as big as \texttt{Int}). The syntax \texttt{where T>:Int} also works to specify only the lower bound of a type variable, and \texttt{Array\{>:Int\}} is equivalent to \texttt{Array\{T\} where T>:Int}.



Since \texttt{where} expressions nest, type variable bounds can refer to outer type variables. For example \texttt{Tuple\{T,Array\{S\}\} where S<:AbstractArray\{T\} where T<:Real} refers to 2-tuples whose first element is some \hyperlink{6175959395021454412}{\texttt{Real}}, and whose second element is an \texttt{Array} of any kind of array whose element type contains the type of the first tuple element.



The \texttt{where} keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following declarations:




\begin{minted}{jlcon}
julia> const T1 = Array{Array{T,1} where T, 1}
Array{Array{T,1} where T,1}

julia> const T2 = Array{Array{T,1}, 1} where T
Array{Array{T,1},1} where T
\end{minted}



Type \texttt{T1} defines a 1-dimensional array of 1-dimensional arrays; each of the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next. On the other hand, type \texttt{T2} defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the same type.  Note that \texttt{T2} is an abstract type, e.g., \texttt{Array\{Array\{Int,1\},1\} <: T2}, whereas \texttt{T1} is a concrete type. As a consequence, \texttt{T1} can be constructed with a zero-argument constructor \texttt{a=T1()} but \texttt{T2} cannot.



There is a convenient syntax for naming such types, similar to the short form of function definition syntax:




\begin{minted}{julia}
Vector{T} = Array{T,1}
\end{minted}



This is equivalent to \texttt{const Vector = Array\{T,1\} where T}. Writing \texttt{Vector\{Float64\}} is equivalent to writing \texttt{Array\{Float64,1\}}, and the umbrella type \texttt{Vector} has as instances all \texttt{Array} objects where the second parameter – the number of array dimensions – is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just \texttt{Vector} for the abstract type including all one-dimensional dense arrays of any element type.



\hypertarget{2472802030828160697}{}


\section{Type Aliases}



Sometimes it is convenient to introduce a new name for an already expressible type. This can be done with a simple assignment statement. For example, \texttt{UInt} is aliased to either \hyperlink{8690996847580776341}{\texttt{UInt32}} or \hyperlink{5500998675195555601}{\texttt{UInt64}} as is appropriate for the size of pointers on the system:




\begin{minted}{jlcon}
# 32-bit system:
julia> UInt
UInt32

# 64-bit system:
julia> UInt
UInt64
\end{minted}



This is accomplished via the following code in \texttt{base/boot.jl}:




\begin{minted}{julia}
if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end
\end{minted}



Of course, this depends on what \texttt{Int} is aliased to – but that is predefined to be the correct type – either \hyperlink{10103694114785108551}{\texttt{Int32}} or \hyperlink{7720564657383125058}{\texttt{Int64}}.



(Note that unlike \texttt{Int}, \texttt{Float} does not exist as a type alias for a specific sized \hyperlink{11465394427882483091}{\texttt{AbstractFloat}}. Unlike with integer registers, the floating point register sizes are specified by the IEEE-754 standard. Whereas the size of \texttt{Int} reflects the size of a native pointer on that machine.)



\hypertarget{15333983107825586958}{}


\section{Operations on Types}



Since types in Julia are themselves objects, ordinary functions can operate on them. Some functions that are particularly useful for working with or exploring types have already been introduced, such as the \texttt{<:} operator, which indicates whether its left hand operand is a subtype of its right hand operand.



The \hyperlink{7066325108767373297}{\texttt{isa}} function tests if an object is of a given type and returns true or false:




\begin{minted}{jlcon}
julia> isa(1, Int)
true

julia> isa(1, AbstractFloat)
false
\end{minted}



The \hyperlink{13440452181855594120}{\texttt{typeof()}} function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:




\begin{minted}{jlcon}
julia> typeof(Rational{Int})
DataType

julia> typeof(Union{Real,Float64,Rational})
DataType

julia> typeof(Union{Real,String})
Union
\end{minted}



What if we repeat the process? What is the type of a type of a type? As it happens, types are all composite values and thus all have a type of \texttt{DataType}:




\begin{minted}{jlcon}
julia> typeof(DataType)
DataType

julia> typeof(Union)
DataType
\end{minted}



\texttt{DataType} is its own type.



Another operation that applies to some types is \hyperlink{12192788431675298651}{\texttt{supertype()}}, which reveals a type{\textquotesingle}s supertype. Only declared types (\texttt{DataType}) have unambiguous supertypes:




\begin{minted}{jlcon}
julia> supertype(Float64)
AbstractFloat

julia> supertype(Number)
Any

julia> supertype(AbstractString)
Any

julia> supertype(Any)
Any
\end{minted}



If you apply \hyperlink{12192788431675298651}{\texttt{supertype()}} to other type objects (or non-type objects), a \hyperlink{14644228586476494020}{\texttt{MethodError}} is raised:




\begin{minted}{jlcon}
julia> supertype(Union{Float64,Int64})
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
Closest candidates are:
  supertype(!Matched::DataType) at operators.jl:41
  supertype(!Matched::UnionAll) at operators.jl:46
\end{minted}



\hypertarget{11661150833581032996}{}


\section{Custom pretty-printing}



Often, one wants to customize how instances of a type are displayed.  This is accomplished by overloading the \hyperlink{14071376285304310153}{\texttt{show()}} function.  For example, suppose we define a type to represent complex numbers in polar form:




\begin{lstlisting}
julia> struct Polar{T<:Real} <: Number
           r::T
           Θ::T
       end

julia> Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)
Polar
\end{lstlisting}



Here, we{\textquotesingle}ve added a custom constructor function so that it can take arguments of different \hyperlink{6175959395021454412}{\texttt{Real}} types and promote them to a common type (see \hyperlink{17317810227993044854}{Constructors} and \hyperlink{10686378388163930476}{Conversion and Promotion}). (Of course, we would have to define lots of other methods, too, to make it act like a \hyperlink{1990584313715697055}{\texttt{Number}}, e.g. \texttt{+}, \texttt{*}, \texttt{one}, \texttt{zero}, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. \texttt{Polar\{Float64\}(3.0,4.0)}.



If we want it to display instead as \texttt{3.0 * exp(4.0im)}, we would define the following method to print the object to a given output object \texttt{io} (representing a file, terminal, buffer, etcetera; see \hyperlink{12120385195625176605}{Networking and Streams}):




\begin{lstlisting}
julia> Base.show(io::IO, z::Polar) = print(io, z.r, " * exp(", z.Θ, "im)")
\end{lstlisting}



More fine-grained control over display of \texttt{Polar} objects is possible. In particular, sometimes one wants both a verbose multi-line printing format, used for displaying a single object in the REPL and other interactive environments, and also a more compact single-line format used for \hyperlink{8248717042415202230}{\texttt{print()}} or for displaying the object as part of another object (e.g. in an array). Although by default the \texttt{show(io, z)} function is called in both cases, you can define a \emph{different} multi-line format for displaying an object by overloading a three-argument form of \texttt{show} that takes the \texttt{text/plain} MIME type as its second argument (see \hyperlink{7442676307456961159}{Multimedia I/O}), for example:




\begin{lstlisting}
julia> Base.show{T}(io::IO, ::MIME"text/plain", z::Polar{T}) =
           print(io, "Polar{$T} complex number:\n   ", z)
\end{lstlisting}



(Note that \texttt{print(..., z)} here will call the 2-argument \texttt{show(io, z)} method.) This results in:




\begin{lstlisting}
julia> Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia> [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Array{Polar{Float64},1}:
 3.0 * exp(4.0im)
 4.0 * exp(5.3im)
\end{lstlisting}



where the single-line \texttt{show(io, z)} form is still used for an array of \texttt{Polar} values.   Technically, the REPL calls \texttt{display(z)} to display the result of executing a line, which defaults to \texttt{show(STDOUT, MIME({\textquotedbl}text/plain{\textquotedbl}), z)}, which in turn defaults to \texttt{show(STDOUT, z)}, but you should \emph{not} define new \hyperlink{12073120410747960438}{\texttt{display()}} methods unless you are defining a new multimedia display handler (see \hyperlink{7442676307456961159}{Multimedia I/O}).



Moreover, you can also define \texttt{show} methods for other MIME types in order to enable richer display (HTML, images, etcetera) of objects in environments that support this (e.g. IJulia).   For example, we can define formatted HTML display of \texttt{Polar} objects, with superscripts and italics, via:




\begin{lstlisting}
julia> Base.show{T}(io::IO, ::MIME"text/html", z::Polar{T}) =
           println(io, "<code>Polar{$T}</code> complex number: ",
                   z.r, " <i>e</i><sup>", z.Θ, " <i>i</i></sup>")
\end{lstlisting}



A \texttt{Polar} object will then display automatically using HTML in an environment that supports HTML display, but you can call \texttt{show} manually to get HTML output if you want:




\begin{lstlisting}
julia> show(STDOUT, "text/html", Polar(3.0,4.0))
<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup>
\end{lstlisting}





\hypertarget{7750565687602056032}{}


\section{{\textquotedbl}Value types{\textquotedbl}}



In Julia, you can{\textquotesingle}t dispatch on a \emph{value} such as \texttt{true} or \texttt{false}. However, you can dispatch on parametric types, and Julia allows you to include {\textquotedbl}plain bits{\textquotedbl} values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters.  A common example is the dimensionality parameter in \texttt{Array\{T,N\}}, where \texttt{T} is a type (e.g., \hyperlink{5027751419500983000}{\texttt{Float64}}) but \texttt{N} is just an \texttt{Int}.



You can create your own custom types that take values as parameters, and use them to control dispatch of custom types. By way of illustration of this idea, let{\textquotesingle}s introduce a parametric type, \texttt{Val\{T\}}, which serves as a customary way to exploit this technique for cases where you don{\textquotesingle}t need a more elaborate hierarchy.



\texttt{Val} is defined as:




\begin{lstlisting}
julia> struct Val{T}
       end
\end{lstlisting}



There is no more to the implementation of \texttt{Val} than this.  Some functions in Julia{\textquotesingle}s standard library accept \texttt{Val} types as arguments, and you can also use it to write your own functions.  For example:




\begin{lstlisting}
julia> firstlast(::Type{Val{true}}) = "First"
firstlast (generic function with 1 method)

julia> firstlast(::Type{Val{false}}) = "Last"
firstlast (generic function with 2 methods)

julia> firstlast(Val{true})
"First"

julia> firstlast(Val{false})
"Last"
\end{lstlisting}



For consistency across Julia, the call site should always pass a \texttt{Val}\emph{type} rather than creating an \emph{instance}, i.e., use \texttt{foo(Val\{:bar\})} rather than \texttt{foo(Val\{:bar\}())}.



It{\textquotesingle}s worth noting that it{\textquotesingle}s extremely easy to mis-use parametric {\textquotedbl}value{\textquotedbl} types, including \texttt{Val}; in unfavorable cases, you can easily end up making the performance of your code much \emph{worse}.  In particular, you would never want to write actual code as illustrated above.  For more information about the proper (and improper) uses of \texttt{Val}, please read the more extensive discussion in \hyperlink{3908315974291496321}{the performance tips}.



\hypertarget{6093361083853962389}{}


\section{Nullable Types: Representing Missing Values}



In many settings, you need to interact with a value of type \texttt{T} that may or may not exist. To handle these settings, Julia provides a parametric type called \hyperlink{2208920129454296646}{\texttt{Nullable\{T\}}}, which can be thought of as a specialized container type that can contain either zero or one values. \texttt{Nullable\{T\}} provides a minimal interface designed to ensure that interactions with missing values are safe. At present, the interface consists of several possible interactions:



\begin{itemize}
\item Construct a \texttt{Nullable} object.


\item Check if a \texttt{Nullable} object has a missing value.


\item Access the value of a \texttt{Nullable} object with a guarantee that a \hyperlink{3710635130313494548}{\texttt{NullException}} will be thrown if the object{\textquotesingle}s value is missing.


\item Access the value of a \texttt{Nullable} object with a guarantee that a default value of type \texttt{T} will be returned if the object{\textquotesingle}s value is missing.


\item Perform an operation on the value (if it exists) of a \texttt{Nullable} object, getting a \texttt{Nullable} result. The result will be missing if the original value was missing.


\item Performing a test on the value (if it exists) of a \texttt{Nullable} object, getting a result that is missing if either the \texttt{Nullable} itself was missing, or the test failed.


\item Perform general operations on single \texttt{Nullable} objects, propagating the missing data.

\end{itemize}


\hypertarget{15505089293773291192}{}


\subsection{Constructing \texttt{Nullable} objects}



To construct an object representing a missing value of type \texttt{T}, use the \texttt{Nullable\{T\}()} function:




\begin{minted}{jlcon}
julia> x1 = Nullable{Int64}()
Nullable{Int64}()

julia> x2 = Nullable{Float64}()
Nullable{Float64}()

julia> x3 = Nullable{Vector{Int64}}()
Nullable{Array{Int64,1}}()
\end{minted}



To construct an object representing a non-missing value of type \texttt{T}, use the \texttt{Nullable(x::T)} function:




\begin{minted}{jlcon}
julia> x1 = Nullable(1)
Nullable{Int64}(1)

julia> x2 = Nullable(1.0)
Nullable{Float64}(1.0)

julia> x3 = Nullable([1, 2, 3])
Nullable{Array{Int64,1}}([1, 2, 3])
\end{minted}



Note the core distinction between these two ways of constructing a \texttt{Nullable} object: in one style, you provide a type, \texttt{T}, as a function parameter; in the other style, you provide a single value of type \texttt{T} as an argument.



\hypertarget{6110127776457118939}{}


\subsection{Checking if a \texttt{Nullable} object has a value}



You can check if a \texttt{Nullable} object has any value using \hyperlink{16547052476421706505}{\texttt{isnull()}}:




\begin{minted}{jlcon}
julia> isnull(Nullable{Float64}())
true

julia> isnull(Nullable(0.0))
false
\end{minted}



\hypertarget{9083264855787688256}{}


\subsection{Safely accessing the value of a \texttt{Nullable} object}



You can safely access the value of a \texttt{Nullable} object using \hyperlink{1600067245044904172}{\texttt{get()}}:




\begin{minted}{jlcon}
julia> get(Nullable{Float64}())
ERROR: NullException()
Stacktrace:
 [1] get(::Nullable{Float64}) at ./nullable.jl:92

julia> get(Nullable(1.0))
1.0
\end{minted}



If the value is not present, as it would be for \texttt{Nullable\{Float64\}}, a \hyperlink{3710635130313494548}{\texttt{NullException}} error will be thrown. The error-throwing nature of the \texttt{get()} function ensures that any attempt to access a missing value immediately fails.



In cases for which a reasonable default value exists that could be used when a \texttt{Nullable} object{\textquotesingle}s value turns out to be missing, you can provide this default value as a second argument to \texttt{get()}:




\begin{minted}{jlcon}
julia> get(Nullable{Float64}(), 0.0)
0.0

julia> get(Nullable(1.0), 0.0)
1.0
\end{minted}



\begin{quote}
\textbf{Tip}

Make sure the type of the default value passed to \texttt{get()} and that of the \texttt{Nullable} object match to avoid type instability, which could hurt performance. Use \hyperlink{1846942650946171605}{\texttt{convert()}} manually if needed.

\end{quote}


\hypertarget{1310732098263179457}{}


\subsection{Performing operations on \texttt{Nullable} objects}



\texttt{Nullable} objects represent values that are possibly missing, and it is possible to write all code using these objects by first testing to see if the value is missing with \hyperlink{16547052476421706505}{\texttt{isnull()}}, and then doing an appropriate action. However, there are some common use cases where the code could be more concise or clear by using a higher-order function.



The \hyperlink{11483231213869150535}{\texttt{map}} function takes as arguments a function \texttt{f} and a \texttt{Nullable} value \texttt{x}. It produces a \texttt{Nullable}:



\begin{itemize}
\item If \texttt{x} is a missing value, then it produces a missing value;


\item If \texttt{x} has a value, then it produces a \texttt{Nullable} containing \texttt{f(get(x))} as value.

\end{itemize}


This is useful for performing simple operations on values that might be missing if the desired behaviour is to simply propagate the missing values forward.



The \hyperlink{11445961893478569145}{\texttt{filter}} function takes as arguments a predicate function \texttt{p} (that is, a function returning a boolean) and a \texttt{Nullable} value \texttt{x}. It produces a \texttt{Nullable} value:



\begin{itemize}
\item If \texttt{x} is a missing value, then it produces a missing value;


\item If \texttt{p(get(x))} is true, then it produces the original value \texttt{x};


\item If \texttt{p(get(x))} is false, then it produces a missing value.

\end{itemize}


In this way, \texttt{filter} can be thought of as selecting only allowable values, and converting non-allowable values to missing values.



While \texttt{map} and \texttt{filter} are useful in specific cases, by far the most useful higher-order function is \hyperlink{1261021074485016178}{\texttt{broadcast}}, which can handle a wide variety of cases, including making existing operations work and propagate \texttt{Nullable}s. An example will motivate the need for \texttt{broadcast}. Suppose we have a function that computes the greater of two real roots of a quadratic equation, using the quadratic formula:




\begin{lstlisting}
julia> root(a::Real, b::Real, c::Real) = (-b + √(b^2 - 4a*c)) / 2a
root (generic function with 1 method)
\end{lstlisting}



We may verify that the result of \texttt{root(1, -9, 20)} is \texttt{5.0}, as we expect, since \texttt{5.0} is the greater of two real roots of the quadratic equation.



Suppose now that we want to find the greatest real root of a quadratic equations where the coefficients might be missing values. Having missing values in datasets is a common occurrence in real-world data, and so it is important to be able to deal with them. But we cannot find the roots of an equation if we do not know all the coefficients. The best solution to this will depend on the particular use case; perhaps we should throw an error. However, for this example, we will assume that the best solution is to propagate the missing values forward; that is, if any input is missing, we simply produce a missing output.



The \texttt{broadcast()} function makes this task easy; we can simply pass the \texttt{root} function we wrote to \texttt{broadcast}:




\begin{lstlisting}
julia> broadcast(root, Nullable(1), Nullable(-9), Nullable(20))
Nullable{Float64}(5.0)

julia> broadcast(root, Nullable(1), Nullable{Int}(), Nullable{Int}())
Nullable{Float64}()

julia> broadcast(root, Nullable{Int}(), Nullable(-9), Nullable(20))
Nullable{Float64}()
\end{lstlisting}



If one or more of the inputs is missing, then the output of \texttt{broadcast()} will be missing.



There exists special syntactic sugar for the \texttt{broadcast()} function using a dot notation:




\begin{lstlisting}
julia> root.(Nullable(1), Nullable(-9), Nullable(20))
Nullable{Float64}(5.0)
\end{lstlisting}



In particular, the regular arithmetic operators can be \texttt{broadcast()} conveniently using \texttt{.}-prefixed operators:




\begin{minted}{jlcon}
julia> Nullable(2) ./ Nullable(3) .+ Nullable(1.0)
Nullable{Float64}(1.66667)
\end{minted}



\hypertarget{15216268953652766477}{}


\chapter{Methods}



Recall from \hyperlink{11836327794581856778}{Functions} that a function is an object that maps a tuple of arguments to a return value, or throws an exception if no appropriate value can be returned. It is common for the same conceptual function or operation to be implemented quite differently for different types of arguments: adding two integers is very different from adding two floating-point numbers, both of which are distinct from adding an integer to a floating-point number. Despite their implementation differences, these operations all fall under the general concept of {\textquotedbl}addition{\textquotedbl}. Accordingly, in Julia, these behaviors all belong to a single object: the \texttt{+} function.



To facilitate using many different implementations of the same concept smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of argument types and counts. A definition of one possible behavior for a function is called a \emph{method}. Thus far, we have presented only examples of functions defined with a single method, applicable to all types of arguments. However, the signatures of method definitions can be annotated to indicate the types of arguments in addition to their number, and more than a single method definition may be provided. When a function is applied to a particular tuple of arguments, the most specific method applicable to those arguments is applied. Thus, the overall behavior of a function is a patchwork of the behaviors of its various method definitions. If the patchwork is well designed, even though the implementations of the methods may be quite different, the outward behavior of the function will appear seamless and consistent.



The choice of which method to execute when a function is applied is called \emph{dispatch}. Julia allows the dispatch process to choose which of a function{\textquotesingle}s methods to call based on the number of arguments given, and on the types of all of the function{\textquotesingle}s arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. \footnotemark[1] Using all of a function{\textquotesingle}s arguments to choose which method should be invoked, rather than just the first, is known as \href{https://en.wikipedia.org/wiki/Multiple\_dispatch}{multiple dispatch}. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to {\textquotedbl}belong{\textquotedbl} to one argument more than any of the others: does the addition operation in \texttt{x + y} belong to \texttt{x} any more than it does to \texttt{y}? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.



\footnotetext[1]{In C++ or Java, for example, in a method call like \texttt{obj.meth(arg1,arg2)}, the object obj {\textquotedbl}receives{\textquotedbl} the method call and is implicitly passed to the method via the \texttt{this} keyword, rather than as an explicit method argument. When the current \texttt{this} object is the receiver of a method call, it can be omitted altogether, writing just \texttt{meth(arg1,arg2)}, with \texttt{this} implied as the receiving object.

}


\hypertarget{364308828739467596}{}


\section{Defining Methods}



Until now, we have, in our examples, defined only functions with a single method having unconstrained argument types. Such functions behave just like they would in traditional dynamically typed languages. Nevertheless, we have used multiple dispatch and methods almost continually without being aware of it: all of Julia{\textquotesingle}s standard functions and operators, like the aforementioned \texttt{+} function, have many methods defining their behavior over various possible combinations of argument type and count.



When defining a function, one can optionally constrain the types of parameters it is applicable to, using the \texttt{::} type-assertion operator, introduced in the section on \hyperlink{7447321282005802875}{Composite Types}:




\begin{lstlisting}
julia> f(x::Float64, y::Float64) = 2x + y
f (generic function with 1 method)
\end{lstlisting}



This function definition applies only to calls where \texttt{x} and \texttt{y} are both values of type \hyperlink{5027751419500983000}{\texttt{Float64}}:




\begin{lstlisting}
julia> f(2.0, 3.0)
7.0
\end{lstlisting}



Applying it to any other types of arguments will result in a \hyperlink{14644228586476494020}{\texttt{MethodError}}:




\begin{lstlisting}
julia> f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia> f(Float32(2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
Closest candidates are:
  f(!Matched::Float64, ::Float64) at none:1

julia> f(2.0, "3.0")
ERROR: MethodError: no method matching f(::Float64, ::String)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia> f("2.0", "3.0")
ERROR: MethodError: no method matching f(::String, ::String)
\end{lstlisting}



As you can see, the arguments must be precisely of type \hyperlink{5027751419500983000}{\texttt{Float64}}. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because \texttt{Float64} is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type \texttt{Float64}. It may often be useful, however, to write more general methods where the declared parameter types are abstract:




\begin{lstlisting}
julia> f(x::Number, y::Number) = 2x - y
f (generic function with 2 methods)

julia> f(2.0, 3)
1.0
\end{lstlisting}



This method definition applies to any pair of arguments that are instances of \hyperlink{1990584313715697055}{\texttt{Number}}. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression \texttt{2x - y}.



To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for \texttt{f} over all pairs of instances of the abstract type \texttt{Number} – but with a different behavior specific to pairs of \hyperlink{5027751419500983000}{\texttt{Float64}} values. If one of the arguments is a 64-bit float but the other one is not, then the \texttt{f(Float64,Float64)} method cannot be called and the more general \texttt{f(Number,Number)} method must be used:




\begin{lstlisting}
julia> f(2.0, 3.0)
7.0

julia> f(2, 3.0)
1.0

julia> f(2.0, 3)
1.0

julia> f(2, 3)
1
\end{lstlisting}



The \texttt{2x + y} definition is only used in the first case, while the \texttt{2x - y} definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. \hyperlink{10686378388163930476}{Conversion and Promotion}, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. \footnotemark[2]



For non-numeric values, and for fewer or more than two arguments, the function \texttt{f} remains undefined, and applying it will still result in a \hyperlink{14644228586476494020}{\texttt{MethodError}}:




\begin{lstlisting}
julia> f("foo", 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
Closest candidates are:
  f(!Matched::Number, ::Number) at none:1

julia> f()
ERROR: MethodError: no method matching f()
Closest candidates are:
  f(!Matched::Float64, !Matched::Float64) at none:1
  f(!Matched::Number, !Matched::Number) at none:1
\end{lstlisting}



You can easily see which methods exist for a function by entering the function object itself in an interactive session:




\begin{lstlisting}
julia> f
f (generic function with 2 methods)
\end{lstlisting}



This output tells us that \texttt{f} is a function object with two methods. To find out what the signatures of those methods are, use the \hyperlink{3025953302266245919}{\texttt{methods()}} function:




\begin{minted}{jlcon}
julia> methods(f)
# 2 methods for generic function "f":
f(x::Float64, y::Float64) in Main at none:1
f(x::Number, y::Number) in Main at none:1
\end{minted}



which shows that \texttt{f} has two methods, one taking two \texttt{Float64} arguments and one taking arguments of type \texttt{Number}. It also indicates the file and line number where the methods were defined: because these methods were defined at the REPL, we get the apparent line number \texttt{none:1}.



In the absence of a type declaration with \texttt{::}, the type of a method parameter is \texttt{Any} by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type \texttt{Any}. Thus, we can define a catch-all method for \texttt{f} like so:




\begin{lstlisting}
julia> f(x,y) = println("Whoa there, Nelly.")
f (generic function with 3 methods)

julia> f("foo", 1)
Whoa there, Nelly.
\end{lstlisting}



This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.



Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:




\begin{minted}{jlcon}
julia> methods(+)
# 180 methods for generic function "+":
+(x::Bool, z::Complex{Bool}) in Base at complex.jl:224
+(x::Bool, y::Bool) in Base at bool.jl:89
+(x::Bool) in Base at bool.jl:86
+(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96
+(x::Bool, z::Complex) in Base at complex.jl:231
+(a::Float16, b::Float16) in Base at float.jl:372
+(x::Float32, y::Float32) in Base at float.jl:374
+(x::Float64, y::Float64) in Base at float.jl:375
+(z::Complex{Bool}, x::Bool) in Base at complex.jl:225
+(z::Complex{Bool}, x::Real) in Base at complex.jl:239
+(x::Char, y::Integer) in Base at char.jl:40
+(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:303
+(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:303
+(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:296
+(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:290
+(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:258
+(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:315
...
+(a, b, c, xs...) at operators.jl:119
\end{minted}



Multiple dispatch together with the flexible parametric type system give Julia its ability to abstractly express high-level algorithms decoupled from implementation details, yet generate efficient, specialized code to handle each case at run time.



\hypertarget{8405464025999625028}{}


\section{Method Ambiguities}



It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:




\begin{lstlisting}
julia> g(x::Float64, y) = 2x + y
g (generic function with 1 method)

julia> g(x, y::Float64) = x + 2y
g (generic function with 2 methods)

julia> g(2.0, 3)
7.0

julia> g(2, 3.0)
8.0

julia> g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous.
[...]
\end{lstlisting}



Here the call \texttt{g(2.0, 3.0)} could be handled by either the \texttt{g(Float64, Any)} or the \texttt{g(Any, Float64)} method, and neither is more specific than the other. In such cases, Julia raises a \hyperlink{14644228586476494020}{\texttt{MethodError}} rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:




\begin{lstlisting}
julia> g(x::Float64, y::Float64) = 2x + 2y
g (generic function with 3 methods)

julia> g(2.0, 3)
7.0

julia> g(2, 3.0)
8.0

julia> g(2.0, 3.0)
10.0
\end{lstlisting}



It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.



In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further \hyperlink{11088607530909626670}{below}.



\hypertarget{14674719184591985798}{}


\section{Parametric Methods}



Method definitions can optionally have type parameters qualifying the signature:




\begin{lstlisting}
julia> same_type(x::T, y::T) where {T} = true
same_type (generic function with 1 method)

julia> same_type(x,y) = false
same_type (generic function with 2 methods)
\end{lstlisting}



The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:




\begin{lstlisting}
julia> same_type(1, 2)
true

julia> same_type(1, 2.0)
false

julia> same_type(1.0, 2.0)
true

julia> same_type("foo", 2.0)
false

julia> same_type("foo", "bar")
true

julia> same_type(Int32(1), Int64(2))
false
\end{lstlisting}



Such definitions correspond to methods whose type signatures are \texttt{UnionAll} types (see \hyperlink{16945289962829222266}{UnionAll Types}).



This kind of definition of function behavior by dispatch is quite common – idiomatic, even – in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function. Here{\textquotesingle}s an example where the method type parameter \texttt{T} is used as the type parameter to the parametric type \texttt{Vector\{T\}} in the method signature:




\begin{minted}{jlcon}
julia> myappend(v::Vector{T}, x::T) where {T} = [v..., x]
myappend (generic function with 1 method)

julia> myappend([1,2,3],4)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1

julia> myappend([1.0,2.0,3.0],4.0)
4-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0

julia> myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1
\end{minted}



As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a \hyperlink{14644228586476494020}{\texttt{MethodError}} is raised. In the following example, the method type parameter \texttt{T} is used as the return value:




\begin{minted}{jlcon}
julia> mytypeof(x::T) where {T} = T
mytypeof (generic function with 1 method)

julia> mytypeof(1)
Int64

julia> mytypeof(1.0)
Float64
\end{minted}



Just as you can put subtype constraints on type parameters in type declarations (see \hyperlink{15542027490314302254}{Parametric Types}), you can also constrain type parameters of methods:




\begin{minted}{jlcon}
julia> same_type_numeric(x::T, y::T) where {T<:Number} = true
same_type_numeric (generic function with 1 method)

julia> same_type_numeric(x::Number, y::Number) = false
same_type_numeric (generic function with 2 methods)

julia> same_type_numeric(1, 2)
true

julia> same_type_numeric(1, 2.0)
false

julia> same_type_numeric(1.0, 2.0)
true

julia> same_type_numeric("foo", 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
Closest candidates are:
  same_type_numeric(!Matched::T<:Number, ::T<:Number) where T<:Number at none:1
  same_type_numeric(!Matched::Number, ::Number) at none:1

julia> same_type_numeric("foo", "bar")
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)

julia> same_type_numeric(Int32(1), Int64(2))
false
\end{minted}



The \texttt{same\_type\_numeric} function behaves much like the \texttt{same\_type} function defined above, but is only defined for pairs of numbers.



Parametric methods allow the same syntax as \texttt{where} expressions used to write types (see \hyperlink{16945289962829222266}{UnionAll Types}). If there is only a single parameter, the enclosing curly braces (in \texttt{where \{T\}}) can be omitted, but are often preferred for clarity. Multiple parameters can be separated with commas, e.g. \texttt{where \{T, S<:Real\}}, or written using nested \texttt{where}, e.g. \texttt{where S<:Real where T}.



\hypertarget{6940442119591045288}{}


\section{Redefining Methods}



When redefining a method or adding new methods, it is important to realize that these changes don{\textquotesingle}t take effect immediately. This is key to Julia{\textquotesingle}s ability to statically infer and compile code to run fast, without the usual JIT tricks and overhead. Indeed, any new method definition won{\textquotesingle}t be visible to the current runtime environment, including Tasks and Threads (and any previously defined \texttt{@generated} functions). Let{\textquotesingle}s start with an example to see what this means:




\begin{minted}{jlcon}
julia> function tryeval()
           @eval newfun() = 1
           newfun()
       end
tryeval (generic function with 1 method)

julia> tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.
Closest candidates are:
  newfun() at none:1 (method too new to be called from this world context.)
 in tryeval() at none:1
 ...

julia> newfun()
1
\end{minted}



In this example, observe that the new definition for \texttt{newfun} has been created, but can{\textquotesingle}t be immediately called. The new global is immediately visible to the \texttt{tryeval} function, so you could write \texttt{return newfun} (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!



But there{\textquotesingle}s an exception: future calls to \texttt{newfun} \emph{from the REPL} work as expected, being able to both see and call the new definition of \texttt{newfun}.



However, future calls to \texttt{tryeval} will continue to see the definition of \texttt{newfun} as it was \emph{at the previous statement at the REPL}, and thus before that call to \texttt{tryeval}.



You may want to try this for yourself to see how it works.



The implementation of this behavior is a {\textquotedbl}world age counter{\textquotedbl}. This monotonically increasing value tracks each method definition operation. This allows describing {\textquotedbl}the set of method definitions visible to a given runtime environment{\textquotedbl} as a single number, or {\textquotedbl}world age{\textquotedbl}. It also allows comparing the methods available in two worlds just by comparing their ordinal value. In the example above, we see that the {\textquotedbl}current world{\textquotedbl} (in which the method \texttt{newfun()} exists), is one greater than the task-local {\textquotedbl}runtime world{\textquotedbl} that was fixed when the execution of \texttt{tryeval} started.



Sometimes it is necessary to get around this (for example, if you are implementing the above REPL). Fortunately, there is an easy solution: call the function using \hyperlink{15240876280767285272}{\texttt{Base.invokelatest}}:




\begin{minted}{jlcon}
julia> function tryeval2()
           @eval newfun2() = 2
           Base.invokelatest(newfun2)
       end
tryeval2 (generic function with 1 method)

julia> tryeval2()
2
\end{minted}



Finally, let{\textquotesingle}s take a look at some more complex examples where this rule comes into play. Define a function \texttt{f(x)}, which initially has one method:




\begin{lstlisting}
julia> f(x) = "original definition"
f (generic function with 1 method)
\end{lstlisting}



Start some other operations that use \texttt{f(x)}:




\begin{lstlisting}
julia> g(x) = f(x)
g (generic function with 1 method)

julia> t = @async f(wait()); yield();
\end{lstlisting}



Now we add some new methods to \texttt{f(x)}:




\begin{lstlisting}
julia> f(x::Int) = "definition for Int"
f (generic function with 2 methods)

julia> f(x::Type{Int}) = "definition for Type{Int}"
f (generic function with 3 methods)
\end{lstlisting}



Compare how these results differ:




\begin{lstlisting}
julia> f(1)
"definition for Int"

julia> g(1)
"definition for Int"

julia> wait(schedule(t, 1))
"original definition"

julia> t = @async f(wait()); yield();

julia> wait(schedule(t, 1))
"definition for Int"
\end{lstlisting}



\hypertarget{291060050167532995}{}


\section{Parametrically-constrained Varargs methods}



Function parameters can also be used to constrain the number of arguments that may be supplied to a {\textquotedbl}varargs{\textquotedbl} function (\hyperlink{17618471192037406942}{Varargs Functions}).  The notation \texttt{Vararg\{T,N\}} is used to indicate such a constraint.  For example:




\begin{minted}{jlcon}
julia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)
bar (generic function with 1 method)

julia> bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1

julia> bar(1,2,3,4)
(1, 2, (3, 4))

julia> bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, ::Any) at none:1
\end{minted}



More usefully, it is possible to constrain varargs methods by a parameter. For example:




\begin{minted}{julia}
function getindex(A::AbstractArray{T,N}, indexes::Vararg{Number,N}) where {T,N}
\end{minted}



would be called only when the number of \texttt{indexes} matches the dimensionality of the array.



\hypertarget{9349182470212981411}{}


\section{Note on Optional and keyword Arguments}



As mentioned briefly in \hyperlink{11836327794581856778}{Functions}, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:




\begin{minted}{julia}
f(a=1,b=2) = a+2b
\end{minted}



translates to the following three methods:




\begin{minted}{julia}
f(a,b) = a+2b
f(a) = f(a,2)
f() = f(1,2)
\end{minted}



This means that calling \texttt{f()} is equivalent to calling \texttt{f(1,2)}. In this case the result is \texttt{5}, because \texttt{f(1,2)} invokes the first method of \texttt{f} above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:




\begin{minted}{julia}
f(a::Int,b::Int) = a-2b
\end{minted}



then the result of both \texttt{f()} and \texttt{f(1,2)} is \texttt{-3}. In other words, optional arguments are tied to a function, not to any specific method of that function. It depends on the types of the optional arguments which method is invoked. When optional arguments are defined in terms of a global variable, the type of the optional argument may even change at run-time.



Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.



\hypertarget{8807737511981816375}{}


\section{Function-like objects}



Methods are associated with types, so it is possible to make any arbitrary Julia object {\textquotedbl}callable{\textquotedbl} by adding methods to its type. (Such {\textquotedbl}callable{\textquotedbl} objects are sometimes called {\textquotedbl}functors.{\textquotedbl})



For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:




\begin{lstlisting}
julia> struct Polynomial{R}
           coeffs::Vector{R}
       end

julia> function (p::Polynomial)(x)
           v = p.coeffs[end]
           for i = (length(p.coeffs)-1):-1:1
               v = v*x + p.coeffs[i]
           end
           return v
       end
\end{lstlisting}



Notice that the function is specified by type instead of by name. In the function body, \texttt{p} will refer to the object that was called. A \texttt{Polynomial} can be used as follows:




\begin{lstlisting}
julia> p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])

julia> p(3)
931
\end{lstlisting}



This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia, discussed \hyperlink{9881427980873554977}{later in the manual}.



\hypertarget{2737234790956119042}{}


\section{Empty generic functions}



Occasionally it is useful to introduce a generic function without yet adding methods. This can be used to separate interface definitions from implementations. It might also be done for the purpose of documentation or code readability. The syntax for this is an empty \texttt{function} block without a tuple of arguments:




\begin{minted}{julia}
function emptyfunc
end
\end{minted}



\hypertarget{11088607530909626670}{}


\section{Method design and the avoidance of ambiguities}



Julia{\textquotesingle}s method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges.  In particular, in more complex method hierarchies it is not uncommon for \hyperlink{8405464025999625028}{ambiguities} to arise.



Above, it was pointed out that one can resolve ambiguities like




\begin{minted}{julia}
f(x, y::Int) = 1
f(x::Int, y) = 2
\end{minted}



by defining a method




\begin{minted}{julia}
f(x::Int, y::Int) = 3
\end{minted}



This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.



Below we discuss particular challenges and some alternative ways to resolve such issues.



\hypertarget{12968608076555068412}{}


\subsection{Tuple and NTuple arguments}



\texttt{Tuple} (and \texttt{NTuple}) arguments present special challenges. For example,




\begin{minted}{julia}
f(x::NTuple{N,Int}) where {N} = 1
f(x::NTuple{N,Float64}) where {N} = 2
\end{minted}



are ambiguous because of the possibility that \texttt{N == 0}: there are no elements to determine whether the \texttt{Int} or \texttt{Float64} variant should be called. To resolve the ambiguity, one approach is define a method for the empty tuple:




\begin{minted}{julia}
f(x::Tuple{}) = 3
\end{minted}



Alternatively, for all methods but one you can insist that there is at least one element in the tuple:




\begin{minted}{julia}
f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback
f(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64
\end{minted}



\hypertarget{2934107525015609338}{}


\subsection{Orthogonalize your design}



When you might be tempted to dispatch on two or more arguments, consider whether a {\textquotedbl}wrapper{\textquotedbl} function might make for a simpler design. For example, instead of writing multiple variants:




\begin{minted}{julia}
f(x::A, y::A) = ...
f(x::A, y::B) = ...
f(x::B, y::A) = ...
f(x::B, y::B) = ...
\end{minted}



you might consider defining




\begin{minted}{julia}
f(x::A, y::A) = ...
f(x, y) = f(g(x), g(y))
\end{minted}



where \texttt{g} converts the argument to type \texttt{A}. This is a very specific example of the more general principle of \href{https://en.wikipedia.org/wiki/Orthogonality\_(programming)}{orthogonal design}, in which separate concepts are assigned to separate methods. Here, \texttt{g} will most likely need a fallback definition




\begin{minted}{julia}
g(x::A) = x
\end{minted}



A related strategy exploits \texttt{promote} to bring \texttt{x} and \texttt{y} to a common type:




\begin{minted}{julia}
f(x::T, y::T) where {T} = ...
f(x, y) = f(promote(x, y)...)
\end{minted}



One risk with this design is the possibility that if there is no suitable promotion method converting \texttt{x} and \texttt{y} to the same type, the second method will recurse on itself infinitely and trigger a stack overflow. The non-exported function \texttt{Base.promote\_noncircular} can be used as an alternative; when promotion fails it will still throw an error, but one that fails faster with a more specific error message.



\hypertarget{11304287325683172565}{}


\subsection{Dispatch on one argument at a time}



If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a {\textquotedbl}name cascade{\textquotedbl} where (for example) you dispatch on the first argument and then call an internal method:




\begin{minted}{julia}
f(x::A, y) = _fA(x, y)
f(x::B, y) = _fB(x, y)
\end{minted}



Then the internal methods \texttt{\_fA} and \texttt{\_fB} can dispatch on \texttt{y} without concern about ambiguities with each other with respect to \texttt{x}.



Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of \texttt{f} by defining further specializations of your exported function \texttt{f}. Instead, they have to define specializations for your internal methods \texttt{\_fA} and \texttt{\_fB}, and this blurs the lines between exported and internal methods.



\hypertarget{3205869102727626662}{}


\subsection{Abstract containers and element types}



Where possible, try to avoid defining methods that dispatch on specific element types of abstract containers. For example,




\begin{minted}{julia}
-(A::AbstractArray{T}, b::Date) where {T<:Date}
\end{minted}



generates ambiguities for anyone who defines a method




\begin{minted}{julia}
-(A::MyArrayType{T}, b::T) where {T}
\end{minted}



The best approach is to avoid defining \emph{either} of these methods: instead, rely on a generic method \texttt{-(A::AbstractArray, b)} and make sure this method is implemented with generic calls (like \texttt{similar} and \texttt{-}) that do the right thing for each container type and element type \emph{separately}. This is just a more complex variant of the advice to \hyperlink{2934107525015609338}{orthogonalize} your methods.



When this approach is not possible, it may be worth starting a discussion with other developers about resolving the ambiguity; just because one method was defined first does not necessarily mean that it can{\textquotesingle}t be modified or eliminated.  As a last resort, one developer can define the {\textquotedbl}band-aid{\textquotedbl} method




\begin{minted}{julia}
-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...
\end{minted}



that resolves the ambiguity by brute force.



\hypertarget{10734508014927682230}{}


\subsection{Complex method {\textquotedbl}cascades{\textquotedbl} with default arguments}



If you are defining a method {\textquotedbl}cascade{\textquotedbl} that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you{\textquotesingle}re writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:




\begin{minted}{julia}
function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel)  # now perform the "real" computation
end
\end{minted}



This will run afoul of a method that supplies default padding:




\begin{minted}{julia}
myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default
\end{minted}



Together, these two methods generate an infinite recursion with \texttt{A} constantly growing bigger.



The better design would be to define your call hierarchy like this:




\begin{minted}{julia}
struct NoPad end  # indicate that no padding is desired, or that it's already applied

myfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions

function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions
end

# other padding methods go here

function myfilter(A, kernel, ::NoPad)
    # Here's the "real" implementation of the core computation
end
\end{minted}



\texttt{NoPad} is supplied in the same argument position as any other kind of padding, so it keeps the dispatch hierarchy well organized and with reduced likelihood of ambiguities. Moreover, it extends the {\textquotedbl}public{\textquotedbl} \texttt{myfilter} interface: a user who wants to control the padding explicitly can call the \texttt{NoPad} variant directly.



\footnotetext[2]{Arthur C. Clarke, \emph{Profiles of the Future} (1961): Clarke{\textquotesingle}s Third Law.

}


\hypertarget{17317810227993044854}{}


\chapter{Constructors}



Constructors \footnotemark[1] are functions that create new objects – specifically, instances of \hyperlink{7447321282005802875}{Composite Types}. In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:




\begin{lstlisting}
julia> struct Foo
           bar
           baz
       end

julia> foo = Foo(1, 2)
Foo(1, 2)

julia> foo.bar
1

julia> foo.baz
2
\end{lstlisting}



For many types, forming new objects by binding their field values together is all that is ever needed to create instances. There are, however, cases where more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. \href{https://en.wikipedia.org/wiki/Recursion\_\%28computer\_science\%29\#Recursive\_data\_structures\_.28structural\_recursion.29}{Recursive data structures}, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it{\textquotesingle}s just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia{\textquotesingle}s system for object construction addresses all of these cases and more.



\footnotetext[1]{Nomenclature: while the term {\textquotedbl}constructor{\textquotedbl} generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as {\textquotedbl}constructors{\textquotedbl}. In such situations, it is generally clear from context that the term is used to mean {\textquotedbl}constructor method{\textquotedbl} rather than {\textquotedbl}constructor function{\textquotedbl}, especially as it is often used in the sense of singling out a particular method of the constructor from all of the others.

}


\hypertarget{14609452380769875478}{}


\section{Outer Constructor Methods}



A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let{\textquotesingle}s say you want to add a constructor method for \texttt{Foo} objects that takes only one argument and uses the given value for both the \texttt{bar} and \texttt{baz} fields. This is simple:




\begin{lstlisting}
julia> Foo(x) = Foo(x,x)
Foo

julia> Foo(1)
Foo(1, 1)
\end{lstlisting}



You could also add a zero-argument \texttt{Foo} constructor method that supplies default values for both of the \texttt{bar} and \texttt{baz} fields:




\begin{lstlisting}
julia> Foo() = Foo(0)
Foo

julia> Foo()
Foo(0, 0)
\end{lstlisting}



Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called \emph{outer} constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.



\hypertarget{14168932876595193626}{}


\section{Inner Constructor Methods}



While outer constructor methods succeed in addressing the problem of providing additional convenience methods for constructing objects, they fail to address the other two use cases mentioned in the introduction of this chapter: enforcing invariants, and allowing construction of self-referential objects. For these problems, one needs \emph{inner} constructor methods. An inner constructor method is much like an outer constructor method, with two differences:



\begin{itemize}
\item[1. ] It is declared inside the block of a type declaration, rather than outside of it like normal methods.


\item[2. ] It has access to a special locally existent function called \texttt{new} that creates objects of the block{\textquotesingle}s type.

\end{itemize}


For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:




\begin{lstlisting}
julia> struct OrderedPair
           x::Real
           y::Real
           OrderedPair(x,y) = x > y ? error("out of order") : new(x,y)
       end

\end{lstlisting}



Now \texttt{OrderedPair} objects can only be constructed such that \texttt{x <= y}:




\begin{lstlisting}
julia> OrderedPair(1, 2)
OrderedPair(1, 2)

julia> OrderedPair(2,1)
ERROR: out of order
Stacktrace:
 [1] OrderedPair(::Int64, ::Int64) at ./none:4
\end{lstlisting}



If the type were declared \texttt{mutable}, you could reach in and directly change the field values to violate this invariant, but messing around with an object{\textquotesingle}s internals uninvited is considered poor form. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type{\textquotesingle}s invariants.



If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object{\textquotesingle}s fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to \texttt{new}, returning the resulting object:




\begin{minted}{jlcon}
julia> struct Foo
           bar
           baz
           Foo(bar,baz) = new(bar,baz)
       end

\end{minted}



This declaration has the same effect as the earlier definition of the \texttt{Foo} type without an explicit inner constructor method. The following two types are equivalent – one with a default constructor, the other with an explicit constructor:




\begin{minted}{jlcon}
julia> struct T1
           x::Int64
       end

julia> struct T2
           x::Int64
           T2(x) = new(x)
       end

julia> T1(1)
T1(1)

julia> T2(1)
T2(1)

julia> T1(1.0)
T1(1)

julia> T2(1.0)
T2(1)
\end{minted}



It is considered good form to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.



\hypertarget{15450613029023620701}{}


\section{Incomplete Initialization}



The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:




\begin{lstlisting}
julia> mutable struct SelfReferential
           obj::SelfReferential
       end

\end{lstlisting}



This type may appear innocuous enough, until one considers how to construct an instance of it. If \texttt{a} is an instance of \texttt{SelfReferential}, then a second instance can be created by the call:




\begin{minted}{jlcon}
julia> b = SelfReferential(a)
\end{minted}



But how does one construct the first instance when no instance exists to provide as a valid value for its \texttt{obj} field? The only solution is to allow creating an incompletely initialized instance of \texttt{SelfReferential} with an unassigned \texttt{obj} field, and using that incomplete instance as a valid value for the \texttt{obj} field of another instance, such as, for example, itself.



To allow for the creation of incompletely initialized objects, Julia allows the \texttt{new} function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, we take another crack at defining the \texttt{SelfReferential} type, with a zero-argument inner constructor returning instances having \texttt{obj} fields pointing to themselves:




\begin{lstlisting}
julia> mutable struct SelfReferential
           obj::SelfReferential
           SelfReferential() = (x = new(); x.obj = x)
       end

\end{lstlisting}



We can verify that this constructor works and constructs objects that are, in fact, self-referential:




\begin{lstlisting}
julia> x = SelfReferential();

julia> x === x
true

julia> x === x.obj
true

julia> x === x.obj.obj
true
\end{lstlisting}



Although it is generally a good idea to return a fully initialized object from an inner constructor, incompletely initialized objects can be returned:




\begin{lstlisting}
julia> mutable struct Incomplete
           xx
           Incomplete() = new()
       end

julia> z = Incomplete();
\end{lstlisting}



While you are allowed to create objects with uninitialized fields, any access to an uninitialized reference is an immediate error:




\begin{lstlisting}
julia> z.xx
ERROR: UndefRefError: access to undefined reference
\end{lstlisting}



This avoids the need to continually check for \texttt{null} values. However, not all object fields are references. Julia considers some types to be {\textquotedbl}plain data{\textquotedbl}, meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. \texttt{Int}) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:




\begin{minted}{jlcon}
julia> struct HasPlain
           n::Int
           HasPlain() = new()
       end

julia> HasPlain()
HasPlain(438103441441)
\end{minted}



Arrays of plain data types exhibit the same behavior.



You can pass incomplete objects to other functions from inner constructors to delegate their completion:




\begin{minted}{jlcon}
julia> mutable struct Lazy
           xx
           Lazy(v) = complete_me(new(), v)
       end
\end{minted}



As with incomplete objects returned from constructors, if \texttt{complete\_me} or any of its callees try to access the \texttt{xx} field of the \texttt{Lazy} object before it has been initialized, an error will be thrown immediately.



\hypertarget{9197591618257318985}{}


\section{Parametric Constructors}



Parametric types add a few wrinkles to the constructor story. Recall from \hyperlink{15542027490314302254}{Parametric Types} that, by default, instances of parametric composite types can be constructed either with explicitly given type parameters or with type parameters implied by the types of the arguments given to the constructor. Here are some examples:




\begin{lstlisting}
julia> struct Point{T<:Real}
           x::T
           y::T
       end

julia> Point(1,2) ## implicit T ##
Point{Int64}(1, 2)

julia> Point(1.0,2.5) ## implicit T ##
Point{Float64}(1.0, 2.5)

julia> Point(1,2.5) ## implicit T ##
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T<:Real, !Matched::T<:Real) where T<:Real at none:2

julia> Point{Int64}(1, 2) ## explicit T ##
Point{Int64}(1, 2)

julia> Point{Int64}(1.0,2.5) ## explicit T ##
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int64}, ::Float64) at ./float.jl:679
 [2] Point{Int64}(::Float64, ::Float64) at ./none:2

julia> Point{Float64}(1.0, 2.5) ## explicit T ##
Point{Float64}(1.0, 2.5)

julia> Point{Float64}(1,2) ## explicit T ##
Point{Float64}(1.0, 2.0)
\end{lstlisting}



As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: \texttt{Point\{Int64\}(1,2)} works, but \texttt{Point\{Int64\}(1.0,2.5)} raises an \hyperlink{5399118524830636312}{\texttt{InexactError}} when converting \texttt{2.5} to \hyperlink{7720564657383125058}{\texttt{Int64}}. When the type is implied by the arguments to the constructor call, as in \texttt{Point(1,2)}, then the types of the arguments must agree – otherwise the \texttt{T} cannot be determined – but any pair of real arguments with matching type may be given to the generic \texttt{Point} constructor.



What{\textquotesingle}s really going on here is that \texttt{Point}, \texttt{Point\{Float64\}} and \texttt{Point\{Int64\}} are all different constructor functions. In fact, \texttt{Point\{T\}} is a distinct constructor function for each type \texttt{T}. Without any explicitly provided inner constructors, the declaration of the composite type \texttt{Point\{T<:Real\}} automatically provides an inner constructor, \texttt{Point\{T\}}, for each possible type \texttt{T<:Real}, that behaves just like non-parametric default inner constructors do. It also provides a single general outer \texttt{Point} constructor that takes pairs of real arguments, which must be of the same type. This automatic provision of constructors is equivalent to the following explicit declaration:




\begin{lstlisting}
julia> struct Point{T<:Real}
           x::T
           y::T
           Point{T}(x,y) where {T<:Real} = new(x,y)
       end

julia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);
\end{lstlisting}



Notice that each definition looks like the form of constructor call that it handles. The call \texttt{Point\{Int64\}(1,2)} will invoke the definition \texttt{Point\{T\}(x,y)} inside the \texttt{type} block. The outer constructor declaration, on the other hand, defines a method for the general \texttt{Point} constructor which only applies to pairs of values of the same real type. This declaration makes constructor calls without explicit type parameters, like \texttt{Point(1,2)} and \texttt{Point(1.0,2.5)}, work. Since the method declaration restricts the arguments to being of the same type, calls like \texttt{Point(1,2.5)}, with arguments of different types, result in {\textquotedbl}no method{\textquotedbl} errors.



Suppose we wanted to make the constructor call \texttt{Point(1,2.5)} work by {\textquotedbl}promoting{\textquotedbl} the integer value \texttt{1} to the floating-point value \texttt{1.0}. The simplest way to achieve this is to define the following additional outer constructor method:




\begin{lstlisting}
julia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);
\end{lstlisting}



This method uses the \hyperlink{1846942650946171605}{\texttt{convert()}} function to explicitly convert \texttt{x} to \hyperlink{5027751419500983000}{\texttt{Float64}} and then delegates construction to the general constructor for the case where both arguments are \hyperlink{5027751419500983000}{\texttt{Float64}}. With this method definition what was previously a \hyperlink{14644228586476494020}{\texttt{MethodError}} now successfully creates a point of type \texttt{Point\{Float64\}}:




\begin{lstlisting}
julia> Point(1,2.5)
Point{Float64}(1.0, 2.5)

julia> typeof(ans)
Point{Float64}
\end{lstlisting}



However, other similar calls still don{\textquotesingle}t work:




\begin{lstlisting}
julia> Point(1.5,2)
ERROR: MethodError: no method matching Point(::Float64, ::Int64)
Closest candidates are:
  Point(::T<:Real, !Matched::T<:Real) where T<:Real at none:1
\end{lstlisting}



For a more general way to make all such calls work sensibly, see \hyperlink{10686378388163930476}{Conversion and Promotion}. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general \texttt{Point} constructor work as one would expect:




\begin{lstlisting}
julia> Point(x::Real, y::Real) = Point(promote(x,y)...);
\end{lstlisting}



The \texttt{promote} function converts all its arguments to a common type – in this case \hyperlink{5027751419500983000}{\texttt{Float64}}. With this method definition, the \texttt{Point} constructor promotes its arguments the same way that numeric operators like \hyperlink{3677358729494553841}{\texttt{+}} do, and works for all kinds of real numbers:




\begin{lstlisting}
julia> Point(1.5,2)
Point{Float64}(1.5, 2.0)

julia> Point(1,1//2)
Point{Rational{Int64}}(1//1, 1//2)

julia> Point(1.0,1//2)
Point{Float64}(1.0, 0.5)
\end{lstlisting}



Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.



\hypertarget{13394318901311885654}{}


\section{Case Study: Rational}



Perhaps the best way to tie all these pieces together is to present a real world example of a parametric composite type and its constructor methods. To that end, here is the (slightly modified) beginning of \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}}, which implements Julia{\textquotesingle}s \hyperlink{12093481009248886258}{Rational Numbers}:




\begin{lstlisting}
julia> struct OurRational{T<:Integer} <: Real
           num::T
           den::T
           function OurRational{T}(num::T, den::T) where T<:Integer
               if num == 0 && den == 0
                    error("invalid rational: 0//0")
               end
               g = gcd(den, num)
               num = div(num, g)
               den = div(den, g)
               new(num, den)
           end
       end

julia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)
OurRational

julia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)
OurRational

julia> OurRational(n::Integer) = OurRational(n,one(n))
OurRational

julia> //(n::Integer, d::Integer) = OurRational(n,d)
// (generic function with 1 method)

julia> //(x::OurRational, y::Integer) = x.num // (x.den*y)
// (generic function with 2 methods)

julia> //(x::Integer, y::OurRational) = (x*y.den) // y.num
// (generic function with 3 methods)

julia> //(x::Complex, y::Real) = complex(real(x)//y, imag(x)//y)
// (generic function with 4 methods)

julia> //(x::Real, y::Complex) = x*y'//real(y*y')
// (generic function with 5 methods)

julia> function //(x::Complex, y::Complex)
           xy = x*y'
           yy = real(y*y')
           complex(real(xy)//yy, imag(xy)//yy)
       end
// (generic function with 6 methods)
\end{lstlisting}



The first line – \texttt{struct OurRational\{T<:Integer\} <: Real} – declares that \texttt{OurRational} takes one type parameter of an integer type, and is itself a real type. The field declarations \texttt{num::T} and \texttt{den::T} indicate that the data held in a \texttt{OurRational\{T\}} object are a pair of integers of type \texttt{T}, one representing the rational value{\textquotesingle}s numerator and the other representing its denominator.



Now things get interesting. \texttt{OurRational} has a single inner constructor method which checks that both of \texttt{num} and \texttt{den} aren{\textquotesingle}t zero and ensures that every rational is constructed in {\textquotedbl}lowest terms{\textquotedbl} with a non-negative denominator. This is accomplished by dividing the given numerator and denominator values by their greatest common divisor, computed using the \texttt{gcd} function. Since \texttt{gcd} returns the greatest common divisor of its arguments with sign matching the first argument (\texttt{den} here), after this division the new value of \texttt{den} is guaranteed to be non-negative. Because this is the only inner constructor for \texttt{OurRational}, we can be certain that \texttt{OurRational} objects are always constructed in this normalized form.



\texttt{OurRational} also provides several outer constructor methods for convenience. The first is the {\textquotedbl}standard{\textquotedbl} general constructor that infers the type parameter \texttt{T} from the type of the numerator and denominator when they have the same type. The second applies when the given numerator and denominator values have different types: it promotes them to a common type and then delegates construction to the outer constructor for arguments of matching type. The third outer constructor turns integer values into rationals by supplying a value of \texttt{1} as the denominator.



Following the outer constructor definitions, we have a number of methods for the \hyperlink{17539582191808611917}{\texttt{//}} operator, which provides a syntax for writing rationals. Before these definitions, \hyperlink{17539582191808611917}{\texttt{//}} is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in \hyperlink{12093481009248886258}{Rational Numbers} – its entire behavior is defined in these few lines. The first and most basic definition just makes \texttt{a//b} construct a \texttt{OurRational} by applying the \texttt{OurRational} constructor to \texttt{a} and \texttt{b} when they are integers. When one of the operands of \hyperlink{17539582191808611917}{\texttt{//}} is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying \hyperlink{17539582191808611917}{\texttt{//}} to complex integral values creates an instance of \texttt{Complex\{OurRational\}} – a complex number whose real and imaginary parts are rationals:




\begin{lstlisting}
julia> ans = (1 + 2im)//(1 - 2im);

julia> typeof(ans)
Complex{OurRational{Int64}}

julia> ans <: Complex{OurRational}
false
\end{lstlisting}



Thus, although the \hyperlink{17539582191808611917}{\texttt{//}} operator usually returns an instance of \texttt{OurRational}, if either of its arguments are complex integers, it will return an instance of \texttt{Complex\{OurRational\}} instead. The interested reader should consider perusing the rest of \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}}: it is short, self-contained, and implements an entire basic Julia type.



\hypertarget{9881427980873554977}{}


\section{Constructors and Conversion}



Constructors \texttt{T(args...)} in Julia are implemented like other callable objects: methods are added to their types. The type of a type is \texttt{Type}, so all constructor methods are stored in the method table for the \texttt{Type} type. This means that you can declare more flexible constructors, e.g. constructors for abstract types, by explicitly defining methods for the appropriate types.



However, in some cases you could consider adding methods to \texttt{Base.convert} \emph{instead} of defining a constructor, because Julia falls back to calling \hyperlink{1846942650946171605}{\texttt{convert()}} if no matching constructor is found. For example, if no constructor \texttt{T(args...) = ...} exists \texttt{Base.convert(::Type\{T\}, args...) = ...} is called.



\texttt{convert} is used extensively throughout Julia whenever one type needs to be converted to another (e.g. in assignment, \hyperlink{14245046751182637566}{\texttt{ccall}}, etcetera), and should generally only be defined (or successful) if the conversion is lossless.  For example, \texttt{convert(Int, 3.0)} produces \texttt{3}, but \texttt{convert(Int, 3.2)} throws an \texttt{InexactError}.  If you want to define a constructor for a lossless conversion from one type to another, you should probably define a \texttt{convert} method instead.



On the other hand, if your constructor does not represent a lossless conversion, or doesn{\textquotesingle}t represent {\textquotedbl}conversion{\textquotedbl} at all, it is better to leave it as a constructor rather than a \texttt{convert} method. For example, the \texttt{Array\{Int\}()} constructor creates a zero-dimensional \texttt{Array} of the type \texttt{Int}, but is not really a {\textquotedbl}conversion{\textquotedbl} from \texttt{Int} to an \texttt{Array}.



\hypertarget{11047482593881141721}{}


\section{Outer-only constructors}



As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to \texttt{Point\{Int\}} but not to \texttt{Point}. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a \texttt{Point\{Int\}} from the call \texttt{Point(1,2)}. Outer constructors call inner constructors to do the core work of making an instance. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.



For example, say we define a type that stores a vector along with an accurate representation of its sum:




\begin{minted}{jlcon}
julia> struct SummedArray{T<:Number,S<:Number}
           data::Vector{T}
           sum::S
       end

julia> SummedArray(Int32[1; 2; 3], Int32(6))
SummedArray{Int32,Int32}(Int32[1, 2, 3], 6)
\end{minted}



The problem is that we want \texttt{S} to be a larger type than \texttt{T}, so that we can sum many elements with less information loss. For example, when \texttt{T} is \hyperlink{10103694114785108551}{\texttt{Int32}}, we would like \texttt{S} to be \hyperlink{7720564657383125058}{\texttt{Int64}}. Therefore we want to avoid an interface that allows the user to construct instances of the type \texttt{SummedArray\{Int32,Int32\}}. One way to do this is to provide a constructor only for \texttt{SummedArray}, but inside the \texttt{type} definition block to suppress generation of default constructors:




\begin{minted}{jlcon}
julia> struct SummedArray{T<:Number,S<:Number}
           data::Vector{T}
           sum::S
           function SummedArray(a::Vector{T}) where T
               S = widen(T)
               new{T,S}(a, sum(S, a))
           end
       end

julia> SummedArray(Int32[1; 2; 3], Int32(6))
ERROR: MethodError: no method matching SummedArray(::Array{Int32,1}, ::Int32)
Closest candidates are:
  SummedArray(::Array{T,1}) where T at none:5
\end{minted}



This constructor will be invoked by the syntax \texttt{SummedArray(a)}. The syntax \texttt{new\{T,S\}} allows specifying parameters for the type to be constructed, i.e. this call will return a \texttt{SummedArray\{T,S\}}. \texttt{new\{T,S\}} can be used in any constructor definition, but for convenience the parameters to \texttt{new\{\}} are automatically derived from the type being constructed when possible.



\hypertarget{10686378388163930476}{}


\chapter{Conversion and Promotion}



Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including \hyperlink{17453309092420764607}{Integers and Floating-Point Numbers}, \hyperlink{16655087771805204817}{Mathematical Operations and Elementary Functions}, \hyperlink{2141690262982725665}{Types}, and \hyperlink{15216268953652766477}{Methods}. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:



\begin{itemize}
\item \textbf{Automatic promotion for built-in arithmetic types and operators.} In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as \texttt{+}, \texttt{-}, \texttt{*}, and \texttt{/}, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum \texttt{1 + 1.5} as the floating-point value \texttt{2.5}, even though one of the operands to \texttt{+} is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.


\item \textbf{No automatic promotion.} This camp includes Ada and ML – very {\textquotedbl}strict{\textquotedbl} statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression \texttt{1 + 1.5} would be a compilation error in both Ada and ML. Instead one must write \texttt{real(1) + 1.5}, explicitly converting the integer \texttt{1} to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.

\end{itemize}


In a sense, Julia falls into the {\textquotedbl}no automatic promotion{\textquotedbl} category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch – something which Julia{\textquotesingle}s dispatch and type systems are particularly well-suited to handle. {\textquotedbl}Automatic{\textquotedbl} promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.



\hypertarget{6267677177626975715}{}


\section{Conversion}



Conversion of values to various types is performed by the \texttt{convert} function. The \texttt{convert} function generally takes two arguments: the first is a type object while the second is a value to convert to that type; the returned value is the value converted to an instance of given type. The simplest way to understand this function is to see it in action:




\begin{minted}{jlcon}
julia> x = 12
12

julia> typeof(x)
Int64

julia> convert(UInt8, x)
0x0c

julia> typeof(ans)
UInt8

julia> convert(AbstractFloat, x)
12.0

julia> typeof(ans)
Float64

julia> a = Any[1 2 3; 4 5 6]
2×3 Array{Any,2}:
 1  2  3
 4  5  6

julia> convert(Array{Float64}, a)
2×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
\end{minted}



Conversion isn{\textquotesingle}t always possible, in which case a no method error is thrown indicating that \texttt{convert} doesn{\textquotesingle}t know how to perform the requested conversion:




\begin{minted}{jlcon}
julia> convert(AbstractFloat, "foo")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
This may have arisen from a call to the constructor AbstractFloat(...),
since type constructors fall back to convert methods.
\end{minted}



Some languages consider parsing strings as numbers or formatting numbers as strings to be conversions (many dynamic languages will even perform conversion for you automatically), however Julia does not: even though some strings can be parsed as numbers, most strings are not valid representations of numbers, and only a very limited subset of them are. Therefore in Julia the dedicated \texttt{parse()} function must be used to perform this operation, making it more explicit.



\hypertarget{16074497991385313458}{}


\subsection{Defining New Conversions}



To define a new conversion, simply provide a new method for \texttt{convert()}. That{\textquotesingle}s really all there is to it. For example, the method to convert a real number to a boolean is this:




\begin{minted}{julia}
convert(::Type{Bool}, x::Real) = x==0 ? false : x==1 ? true : throw(InexactError())
\end{minted}



The type of the first argument of this method is a \hyperlink{647919389478144252}{singleton type}, \texttt{Type\{Bool\}}, the only instance of which is \hyperlink{46725311238864537}{\texttt{Bool}}. Thus, this method is only invoked when the first argument is the type value \texttt{Bool}. Notice the syntax used for the first argument: the argument name is omitted prior to the \texttt{::} symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value is never used in the function body. In this example, since the type is a singleton, there would never be any reason to use its value within the body. When invoked, the method determines whether a numeric value is true or false as a boolean, by comparing it to one and zero:




\begin{minted}{jlcon}
julia> convert(Bool, 1)
true

julia> convert(Bool, 0)
false

julia> convert(Bool, 1im)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Bool}, ::Complex{Int64}) at ./complex.jl:31

julia> convert(Bool, 0im)
false
\end{minted}



The method signatures for conversion methods are often quite a bit more involved than this example, especially for parametric types. The example above is meant to be pedagogical, and is not the actual Julia behaviour. This is the actual implementation in Julia:




\begin{minted}{julia}
convert(::Type{T}, z::Complex) where {T<:Real} =
    (imag(z) == 0 ? convert(T, real(z)) : throw(InexactError()))
\end{minted}



\hypertarget{1257412251017943533}{}


\subsection{Case Study: Rational Conversions}



To continue our case study of Julia{\textquotesingle}s \hyperlink{8304566144531167610}{\texttt{Rational}} type, here are the conversions declared in \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}}, right after the declaration of the type and its constructors:




\begin{minted}{julia}
convert(::Type{Rational{T}}, x::Rational) where {T<:Integer} = Rational(convert(T,x.num),convert(T,x.den))
convert(::Type{Rational{T}}, x::Integer) where {T<:Integer} = Rational(convert(T,x), convert(T,1))

function convert(::Type{Rational{T}}, x::AbstractFloat, tol::Real) where T<:Integer
    if isnan(x); return zero(T)//zero(T); end
    if isinf(x); return sign(x)//zero(T); end
    y = x
    a = d = one(T)
    b = c = zero(T)
    while true
        f = convert(T,round(y)); y -= f
        a, b, c, d = f*a+c, f*b+d, a, b
        if y == 0 || abs(a/b-x) <= tol
            return a//b
        end
        y = 1/y
    end
end
convert(rt::Type{Rational{T}}, x::AbstractFloat) where {T<:Integer} = convert(rt,x,eps(x))

convert(::Type{T}, x::Rational) where {T<:AbstractFloat} = convert(T,x.num)/convert(T,x.den)
convert(::Type{T}, x::Rational) where {T<:Integer} = div(convert(T,x.num),convert(T,x.den))
\end{minted}



The initial four convert methods provide conversions to rational types. The first method converts one type of rational to another type of rational by converting the numerator and denominator to the appropriate integer type. The second method does the same conversion for integers by taking the denominator to be 1. The third method implements a standard algorithm for approximating a floating-point number by a ratio of integers to within a given tolerance, and the fourth method applies it, using machine epsilon at the given value as the threshold. In general, one should have \texttt{a//b == convert(Rational\{Int64\}, a/b)}.



The last two convert methods provide conversions from rational types to floating-point and integer types. To convert to floating point, one simply converts both numerator and denominator to that floating point type and then divides. To convert to integer, one can use the \texttt{div} operator for truncated integer division (rounded towards zero).



\hypertarget{10468267688867457385}{}


\section{Promotion}



Promotion refers to converting values of mixed types to a single common type. Although it is not strictly necessary, it is generally implied that the common type to which the values are converted can faithfully represent all of the original values. In this sense, the term {\textquotedbl}promotion{\textquotedbl} is appropriate since the values are converted to a {\textquotedbl}greater{\textquotedbl} type – i.e. one which can represent all of the input values in a single common type. It is important, however, not to confuse this with object-oriented (structural) super-typing, or Julia{\textquotesingle}s notion of abstract super-types: promotion has nothing to do with the type hierarchy, and everything to do with converting between alternate representations. For instance, although every \hyperlink{10103694114785108551}{\texttt{Int32}} value can also be represented as a \hyperlink{5027751419500983000}{\texttt{Float64}} value, \texttt{Int32} is not a subtype of \texttt{Float64}.



Promotion to a common {\textquotedbl}greater{\textquotedbl} type is performed in Julia by the \texttt{promote} function, which takes any number of arguments, and returns a tuple of the same number of values, converted to a common type, or throws an exception if promotion is not possible. The most common use case for promotion is to convert numeric arguments to a common type:




\begin{minted}{jlcon}
julia> promote(1, 2.5)
(1.0, 2.5)

julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)

julia> promote(2, 3//4)
(2//1, 3//4)

julia> promote(1, 2.5, 3, 3//4)
(1.0, 2.5, 3.0, 0.75)

julia> promote(1.5, im)
(1.5 + 0.0im, 0.0 + 1.0im)

julia> promote(1 + 2im, 3//4)
(1//1 + 2//1*im, 3//4 + 0//1*im)
\end{minted}



Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the larger of either the native machine word size or the largest integer argument type. Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals. Rationals mixed with floats are promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value.



That is really all there is to using promotions. The rest is just a matter of clever application, the most typical {\textquotedbl}clever{\textquotedbl} application being the definition of catch-all methods for numeric operations like the arithmetic operators \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/}. Here are some of the catch-all method definitions given in \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}}:




\begin{minted}{julia}
+(x::Number, y::Number) = +(promote(x,y)...)
-(x::Number, y::Number) = -(promote(x,y)...)
*(x::Number, y::Number) = *(promote(x,y)...)
/(x::Number, y::Number) = /(promote(x,y)...)
\end{minted}



These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That{\textquotesingle}s all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations – it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}}, but beyond that, there are hardly any calls to \texttt{promote} required in the Julia standard library. The most common usages of \texttt{promote} occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}} provides the following outer constructor method:




\begin{minted}{julia}
Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)
\end{minted}



This allows calls like the following to work:




\begin{minted}{jlcon}
julia> Rational(Int8(15),Int32(-5))
-3//1

julia> typeof(ans)
Rational{Int32}
\end{minted}



For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.



\hypertarget{9586216712544847095}{}


\subsection{Defining Promotion Rules}



Although one could, in principle, define methods for the \texttt{promote} function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of \texttt{promote} is defined in terms of an auxiliary function called \texttt{promote\_rule}, which one can provide methods for. The \texttt{promote\_rule} function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:




\begin{minted}{julia}
promote_rule(::Type{Float64}, ::Type{Float32}) = Float64
\end{minted}



one declares that when 64-bit and 32-bit floating-point values are promoted together, they should be promoted to 64-bit floating-point. The promotion type does not need to be one of the argument types, however; the following promotion rules both occur in Julia{\textquotesingle}s standard library:




\begin{minted}{julia}
promote_rule(::Type{UInt8}, ::Type{Int8}) = Int
promote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt
\end{minted}



In the latter case, the result type is \hyperlink{423405808990690832}{\texttt{BigInt}} since \texttt{BigInt} is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both \texttt{promote\_rule(::Type\{A\}, ::Type\{B\})} and \texttt{promote\_rule(::Type\{B\}, ::Type\{A\})} – the symmetry is implied by the way \texttt{promote\_rule} is used in the promotion process.



The \texttt{promote\_rule} function is used as a building block to define a second function called \texttt{promote\_type}, which, given any number of type objects, returns the common type to which those values, as arguments to \texttt{promote} should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use \texttt{promote\_type}:




\begin{minted}{jlcon}
julia> promote_type(Int8, UInt16)
Int64
\end{minted}



Internally, \texttt{promote\_type} is used inside of \texttt{promote} to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}}, which defines the complete promotion mechanism in about 35 lines.



\hypertarget{8539405338692781935}{}


\subsection{Case Study: Rational Promotions}



Finally, we finish off our ongoing case study of Julia{\textquotesingle}s rational number type, which makes relatively sophisticated use of the promotion mechanism with the following promotion rules:




\begin{minted}{julia}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)
\end{minted}



The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.



This small handful of promotion rules, together with the \hyperlink{1257412251017943533}{conversion methods discussed above}, are sufficient to make rational numbers interoperate completely naturally with all of Julia{\textquotesingle}s other numeric types – integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia{\textquotesingle}s predefined numerics.



\hypertarget{6589646210931807616}{}


\chapter{Interfaces}



A lot of the power and extensibility in Julia comes from a collection of informal interfaces.  By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.



\hypertarget{5510379658285713272}{}


\section{Iteration}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Required methods &   & Brief description \\
\hline
\texttt{start(iter)} &   & Returns the initial iteration state \\
\hline
\texttt{next(iter, state)} &   & Returns the current item and the next state \\
\hline
\texttt{done(iter, state)} &   & Tests if there are any items remaining \\
\hline
\textbf{Important optional methods} & \textbf{Default definition} & \textbf{Brief description} \\
\hline
\texttt{iteratorsize(IterType)} & \texttt{HasLength()} & One of \texttt{HasLength()}, \texttt{HasShape()}, \texttt{IsInfinite()}, or \texttt{SizeUnknown()} as appropriate \\
\hline
\texttt{iteratoreltype(IterType)} & \texttt{HasEltype()} & Either \texttt{EltypeUnknown()} or \texttt{HasEltype()} as appropriate \\
\hline
\texttt{eltype(IterType)} & \texttt{Any} & The type the items returned by \texttt{next()} \\
\hline
\texttt{length(iter)} & (\emph{undefined}) & The number of items, if known \\
\hline
\texttt{size(iter, [dim...])} & (\emph{undefined}) & The number of items in each dimension, if known \\
\hline
\end{tabulary}

\end{table}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Value returned by \texttt{iteratorsize(IterType)} & Required Methods \\
\hline
\texttt{HasLength()} & \texttt{length(iter)} \\
\hline
\texttt{HasShape()} & \texttt{length(iter)}  and \texttt{size(iter, [dim...])} \\
\hline
\texttt{IsInfinite()} & (\emph{none}) \\
\hline
\texttt{SizeUnknown()} & (\emph{none}) \\
\hline
\end{tabulary}

\end{table}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Value returned by \texttt{iteratoreltype(IterType)} & Required Methods \\
\hline
\texttt{HasEltype()} & \texttt{eltype(IterType)} \\
\hline
\texttt{EltypeUnknown()} & (\emph{none}) \\
\hline
\end{tabulary}

\end{table}



Sequential iteration is implemented by the methods \hyperlink{1075601569170970796}{\texttt{start()}}, \hyperlink{6277510345882109527}{\texttt{done()}}, and \hyperlink{11903630693622759236}{\texttt{next()}}. Instead of mutating objects as they are iterated over, Julia provides these three methods to keep track of the iteration state externally from the object. The \texttt{start(iter)} method returns the initial state for the iterable object \texttt{iter}. That state gets passed along to \texttt{done(iter, state)}, which tests if there are any elements remaining, and \texttt{next(iter, state)}, which returns a tuple containing the current element and an updated \texttt{state}. The \texttt{state} object can be anything, and is generally considered to be an implementation detail private to the iterable object.



Any object defines these three methods is iterable and can be used in the \hyperlink{405296213558195800}{many functions that rely upon iteration}. It can also be used directly in a \texttt{for} loop since the syntax:




\begin{minted}{julia}
for i in iter   # or  "for i = iter"
    # body
end
\end{minted}



is translated into:




\begin{minted}{julia}
state = start(iter)
while !done(iter, state)
    (i, state) = next(iter, state)
    # body
end
\end{minted}



A simple example is an iterable sequence of square numbers with a defined length:




\begin{lstlisting}
julia> struct Squares
           count::Int
       end

julia> Base.start(::Squares) = 1

julia> Base.next(S::Squares, state) = (state*state, state+1)

julia> Base.done(S::Squares, state) = state > S.count

julia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type

julia> Base.length(S::Squares) = S.count
\end{lstlisting}



With only \hyperlink{1075601569170970796}{\texttt{start}}, \hyperlink{11903630693622759236}{\texttt{next}}, and \hyperlink{6277510345882109527}{\texttt{done}} definitions, the \texttt{Squares} type is already pretty powerful. We can iterate over all the elements:




\begin{lstlisting}
julia> for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49
\end{lstlisting}



We can use many of the builtin methods that work with iterables, like \hyperlink{17277603976666670638}{\texttt{in()}}, \hyperlink{2002825322838319654}{\texttt{mean()}} and \hyperlink{8821409723106968118}{\texttt{std()}}:




\begin{lstlisting}
julia> 25 in Squares(10)
true

julia> mean(Squares(100))
3383.5

julia> std(Squares(100))
3024.355854282583
\end{lstlisting}



There are a few more methods we can extend to give Julia more information about this iterable collection.  We know that the elements in a \texttt{Squares} sequence will always be \texttt{Int}. By extending the \hyperlink{6396209842929672718}{\texttt{eltype()}} method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend \hyperlink{3699181304419743826}{\texttt{length()}}, too.



Now, when we ask Julia to \hyperlink{6278865767444641812}{\texttt{collect()}} all the elements into an array it can preallocate a \texttt{Vector\{Int\}} of the right size instead of blindly \hyperlink{18026893834387542681}{\texttt{push!}}ing each element into a \texttt{Vector\{Any\}}:




\begin{lstlisting}
julia> collect(Squares(10))' # transposed to save space
1×10 RowVector{Int64,Array{Int64,1}}:
 1  4  9  16  25  36  49  64  81  100
\end{lstlisting}



While we can rely upon generic implementations, we can also extend specific methods where we know there is a simpler algorithm. For example, there{\textquotesingle}s a formula to compute the sum of squares, so we can override the generic iterative version with a more performant solution:




\begin{lstlisting}
julia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia> sum(Squares(1803))
1955361914
\end{lstlisting}



This is a very common pattern throughout the Julia standard library: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.



\hypertarget{14566118977838625303}{}


\section{Indexing}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Methods to implement & Brief description \\
\hline
\texttt{getindex(X, i)} & \texttt{X[i]}, indexed element access \\
\hline
\texttt{setindex!(X, v, i)} & \texttt{X[i] = v}, indexed assignment \\
\hline
\texttt{endof(X)} & The last index, used in \texttt{X[end]} \\
\hline
\end{tabulary}

\end{table}



For the \texttt{Squares} iterable above, we can easily compute the \texttt{i}th element of the sequence by squaring it.  We can expose this as an indexing expression \texttt{S[i]}. To opt into this behavior, \texttt{Squares} simply needs to define \hyperlink{2839226020402435013}{\texttt{getindex()}}:




\begin{lstlisting}
julia> function Base.getindex(S::Squares, i::Int)
           1 <= i <= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia> Squares(100)[23]
529
\end{lstlisting}



Additionally, to support the syntax \texttt{S[end]}, we must define \hyperlink{7288835006555308491}{\texttt{endof()}} to specify the last valid index:




\begin{lstlisting}
julia> Base.endof(S::Squares) = length(S)

julia> Squares(23)[end]
529
\end{lstlisting}



Note, though, that the above \emph{only} defines \hyperlink{2839226020402435013}{\texttt{getindex()}} with one integer index. Indexing with anything other than an \texttt{Int} will throw a \hyperlink{14644228586476494020}{\texttt{MethodError}} saying that there was no matching method. In order to support indexing with ranges or vectors of \texttt{Int}s, separate methods must be written:




\begin{lstlisting}
julia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia> Base.getindex(S::Squares, I) = [S[i] for i in I]

julia> Squares(10)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25
\end{lstlisting}



While this is starting to support more of the \hyperlink{14469287548874312017}{indexing operations supported by some of the builtin types}, there{\textquotesingle}s still quite a number of behaviors missing. This \texttt{Squares} sequence is starting to look more and more like a vector as we{\textquotesingle}ve added behaviors to it. Instead of defining all these behaviors ourselves, we can officially define it as a subtype of an \hyperlink{6514416309183787338}{\texttt{AbstractArray}}.



\hypertarget{522338241536202486}{}


\section{Abstract Arrays}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Methods to implement &   & Brief description \\
\hline
\texttt{size(A)} &   & Returns a tuple containing the dimensions of \texttt{A} \\
\hline
\texttt{getindex(A, i::Int)} &   & (if \texttt{IndexLinear}) Linear scalar indexing \\
\hline
\texttt{getindex(A, I::Vararg\{Int, N\})} &   & (if \texttt{IndexCartesian}, where \texttt{N = ndims(A)}) N-dimensional scalar indexing \\
\hline
\texttt{setindex!(A, v, i::Int)} &   & (if \texttt{IndexLinear}) Scalar indexed assignment \\
\hline
\texttt{setindex!(A, v, I::Vararg\{Int, N\})} &   & (if \texttt{IndexCartesian}, where \texttt{N = ndims(A)}) N-dimensional scalar indexed assignment \\
\hline
\textbf{Optional methods} & \textbf{Default definition} & \textbf{Brief description} \\
\hline
\texttt{IndexStyle(::Type)} & \texttt{IndexCartesian()} & Returns either \texttt{IndexLinear()} or \texttt{IndexCartesian()}. See the description below. \\
\hline
\texttt{getindex(A, I...)} & defined in terms of scalar \texttt{getindex()} & \hyperlink{14469287548874312017}{Multidimensional and nonscalar indexing} \\
\hline
\texttt{setindex!(A, I...)} & defined in terms of scalar \texttt{setindex!()} & \hyperlink{14469287548874312017}{Multidimensional and nonscalar indexed assignment} \\
\hline
\texttt{start()}/\texttt{next()}/\texttt{done()} & defined in terms of scalar \texttt{getindex()} & Iteration \\
\hline
\texttt{length(A)} & \texttt{prod(size(A))} & Number of elements \\
\hline
\texttt{similar(A)} & \texttt{similar(A, eltype(A), size(A))} & Return a mutable array with the same shape and element type \\
\hline
\texttt{similar(A, ::Type\{S\})} & \texttt{similar(A, S, size(A))} & Return a mutable array with the same shape and the specified element type \\
\hline
\texttt{similar(A, dims::NTuple\{Int\})} & \texttt{similar(A, eltype(A), dims)} & Return a mutable array with the same element type and size \emph{dims} \\
\hline
\texttt{similar(A, ::Type\{S\}, dims::NTuple\{Int\})} & \texttt{Array\{S\}(dims)} & Return a mutable array with the specified element type and size \\
\hline
\textbf{Non-traditional indices} & \textbf{Default definition} & \textbf{Brief description} \\
\hline
\texttt{indices(A)} & \texttt{map(OneTo, size(A))} & Return the \texttt{AbstractUnitRange} of valid indices \\
\hline
\texttt{Base.similar(A, ::Type\{S\}, inds::NTuple\{Ind\})} & \texttt{similar(A, S, Base.to\_shape(inds))} & Return a mutable array with the specified indices \texttt{inds} (see below) \\
\hline
\texttt{Base.similar(T::Union\{Type,Function\}, inds)} & \texttt{T(Base.to\_shape(inds))} & Return an array similar to \texttt{T} with the specified indices \texttt{inds} (see below) \\
\hline
\end{tabulary}

\end{table}



If a type is defined as a subtype of \texttt{AbstractArray}, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access.  See the \hyperlink{12380164357355707963}{arrays manual page} and \hyperlink{14629781252390713372}{standard library section} for more supported methods.



A key part in defining an \texttt{AbstractArray} subtype is \hyperlink{7782790551324367092}{\texttt{IndexStyle}}. Since indexing is such an important part of an array and often occurs in hot loops, it{\textquotesingle}s important to make both indexing and indexed assignment as efficient as possible.  Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.  These two modalities are identified by Julia as \texttt{IndexLinear()} and \texttt{IndexCartesian()}.  Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.



This distinction determines which scalar indexing methods the type must define. \texttt{IndexLinear()} arrays are simple: just define \texttt{getindex(A::ArrayType, i::Int)}.  When the array is subsequently indexed with a multidimensional set of indices, the fallback \texttt{getindex(A::AbstractArray, I...)()} efficiently converts the indices into one linear index and then calls the above method. \texttt{IndexCartesian()} arrays, on the other hand, require methods to be defined for each supported dimensionality with \texttt{ndims(A)} \texttt{Int} indices. For example, the built-in \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} type only supports two dimensions, so it just defines \texttt{getindex(A::SparseMatrixCSC, i::Int, j::Int)}. The same holds for \texttt{setindex!()}.



Returning to the sequence of squares from above, we could instead define it as a subtype of an \texttt{AbstractArray\{Int, 1\}}:




\begin{lstlisting}
julia> struct SquaresVector <: AbstractArray{Int, 1}
           count::Int
       end

julia> Base.size(S::SquaresVector) = (S.count,)

julia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()

julia> Base.getindex(S::SquaresVector, i::Int) = i*i
\end{lstlisting}



Note that it{\textquotesingle}s very important to specify the two parameters of the \texttt{AbstractArray}; the first defines the \hyperlink{6396209842929672718}{\texttt{eltype()}}, and the second defines the \hyperlink{1688406579181746010}{\texttt{ndims()}}. That supertype and those three methods are all it takes for \texttt{SquaresVector} to be an iterable, indexable, and completely functional array:




\begin{lstlisting}
julia> s = SquaresVector(7)
7-element SquaresVector:
  1
  4
  9
 16
 25
 36
 49

julia> s[s .> 20]
3-element Array{Int64,1}:
 25
 36
 49

julia> s \ [1 2; 3 4; 5 6; 7 8; 9 10; 11 12; 13 14]
1×2 Array{Float64,2}:
 0.305389  0.335329

julia> s ⋅ s # dot(s, s)
4676
\end{lstlisting}



As a more complicated example, let{\textquotesingle}s define our own toy N-dimensional sparse-like array type built on top of \hyperlink{3089397136845322041}{\texttt{Dict}}:




\begin{lstlisting}
julia> struct SparseArray{T,N} <: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia> SparseArray{T}(::Type{T}, dims::Int...) = SparseArray(T, dims);

julia> SparseArray{T,N}(::Type{T}, dims::NTuple{N,Int}) = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia> Base.size(A::SparseArray) = A.dims

julia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)
\end{lstlisting}



Notice that this is an \texttt{IndexCartesian} array, so we must manually define \hyperlink{2839226020402435013}{\texttt{getindex()}} and \hyperlink{17903591429492118749}{\texttt{setindex!()}} at the dimensionality of the array. Unlike the \texttt{SquaresVector}, we are able to define \hyperlink{17903591429492118749}{\texttt{setindex!()}}, and so we can mutate the array:




\begin{lstlisting}
julia> A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> fill!(A, 2)
3×3 SparseArray{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia> A[:] = 1:length(A); A
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0
\end{lstlisting}



The result of indexing an \texttt{AbstractArray} can itself be an array (for instance when indexing by a \texttt{Range}). The \texttt{AbstractArray} fallback methods use \hyperlink{18368531196314541873}{\texttt{similar()}} to allocate an \texttt{Array} of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:




\begin{lstlisting}
julia> A[1:2,:]
2×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
\end{lstlisting}



In this example it is accomplished by defining \texttt{Base.similar\{T\}(A::SparseArray, ::Type\{T\}, dims::Dims)} to create the appropriate wrapped array. (Note that while \texttt{similar} supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it{\textquotesingle}s important that \texttt{SparseArray} is mutable (supports \texttt{setindex!}). Defining \texttt{similar()}, \texttt{getindex()} and \texttt{setindex!()} for \texttt{SparseArray} also makes it possible to \hyperlink{15665284441316555522}{\texttt{copy()}} the array:




\begin{lstlisting}
julia> copy(A)
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0
\end{lstlisting}



In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in the standard library for \texttt{AbstractArrays}:




\begin{lstlisting}
julia> A[SquaresVector(3)]
3-element SparseArray{Float64,1}:
 1.0
 4.0
 9.0

julia> dot(A[:,1],A[:,2])
32.0
\end{lstlisting}



If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize \texttt{indices}. You should also specialize \hyperlink{18368531196314541873}{\texttt{similar}} so that the \texttt{dims} argument (ordinarily a \texttt{Dims} size-tuple) can accept \texttt{AbstractUnitRange} objects, perhaps range-types \texttt{Ind} of your own design. For more information, see \hyperlink{12792533311031776054}{Arrays with custom indices}.



\hypertarget{10438697863683890874}{}


\chapter{Modules}



Modules in Julia are separate variable workspaces, i.e. they introduce a new global scope. They are delimited syntactically, inside \texttt{module Name ... end}. Modules allow you to create top-level definitions (aka global variables) without worrying about name conflicts when your code is used together with somebody else{\textquotesingle}s. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting).



The following example demonstrates the major features of modules. It is not meant to be run, but is shown for illustrative purposes:




\begin{minted}{julia}
module MyModule
using Lib

using BigLib: thing1, thing2

import Base.show

importall OtherLib

export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1

show(io::IO, a::MyType) = print(io, "MyType $(a.x)")
end
\end{minted}



Note that the style is not to indent the body of the module, since that would typically lead to whole files being indented.



This module defines a type \texttt{MyType}, and two functions. Function \texttt{foo} and type \texttt{MyType} are exported, and so will be available for importing into other modules.  Function \texttt{bar} is private to \texttt{MyModule}.



The statement \texttt{using Lib} means that a module called \texttt{Lib} will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by \texttt{Lib} and import it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in \texttt{Lib}.



The statement \texttt{using BigLib: thing1, thing2} is a syntactic shortcut for \texttt{using BigLib.thing1, BigLib.thing2}.



The \texttt{import} keyword supports all the same syntax as \texttt{using}, but only operates on a single name at a time. It does not add modules to be searched the way \texttt{using} does. \texttt{import} also differs from \texttt{using} in that functions must be imported using \texttt{import} to be extended with new methods.



In \texttt{MyModule} above we wanted to add a method to the standard \texttt{show} function, so we had to write \texttt{import Base.show}. Functions whose names are only visible via \texttt{using} cannot be extended.



The keyword \texttt{importall} explicitly imports all names exported by the specified module, as if \texttt{import} were individually used on all of them.



Once a variable is made visible via \texttt{using} or \texttt{import}, a module may not create its own variable with the same name. Imported variables are read-only; assigning to a global variable always affects a variable owned by the current module, or else raises an error.



\hypertarget{9459416503518337799}{}


\section{Summary of module usage}



To load a module, two main keywords can be used: \texttt{using} and \texttt{import}. To understand their differences, consider the following example:




\begin{minted}{julia}
module MyModule

export x, y

x() = "x"
y() = "y"
p() = "p"

end
\end{minted}



In this module we export the \texttt{x} and \texttt{y} functions (with the keyword \texttt{export}), and also have the non-exported function \texttt{p}. There are several different ways to load the Module and its inner functions into the current workspace:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Import Command & What is brought into scope & Available for method extension \\
\hline
\texttt{using MyModule} & All \texttt{export}ed names (\texttt{x} and \texttt{y}), \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} & \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} \\
\hline
\texttt{using MyModule.x, MyModule.p} & \texttt{x} and \texttt{p} &   \\
\hline
\texttt{using MyModule: x, p} & \texttt{x} and \texttt{p} &   \\
\hline
\texttt{import MyModule} & \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} & \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} \\
\hline
\texttt{import MyModule.x, MyModule.p} & \texttt{x} and \texttt{p} & \texttt{x} and \texttt{p} \\
\hline
\texttt{import MyModule: x, p} & \texttt{x} and \texttt{p} & \texttt{x} and \texttt{p} \\
\hline
\texttt{importall MyModule} & All \texttt{export}ed names (\texttt{x} and \texttt{y}) & \texttt{x} and \texttt{y} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{3166985494833258894}{}


\subsection{Modules and files}



Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file:




\begin{minted}{julia}
module Foo

include("file1.jl")
include("file2.jl")

end
\end{minted}



Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with {\textquotedbl}safe{\textquotedbl} versions of some operators:




\begin{minted}{julia}
module Normal
include("mycode.jl")
end

module Testing
include("safe_operators.jl")
include("mycode.jl")
end
\end{minted}



\hypertarget{4606629422334600397}{}


\subsection{Standard modules}



There are three important standard modules: Main, Core, and Base.



Main is the top-level module, and Julia starts with Main set as the current module.  Variables defined at the prompt go in Main, and \texttt{whos()} lists variables in Main.



Core contains all identifiers considered {\textquotedbl}built in{\textquotedbl} to the language, i.e. part of the core language and not libraries. Every module implicitly specifies \texttt{using Core}, since you can{\textquotesingle}t do anything without those definitions.



Base is the standard library (the contents of base/). All modules implicitly contain \texttt{using Base}, since this is needed in the vast majority of cases.



\hypertarget{14998237517455709420}{}


\subsection{Default top-level definitions and bare modules}



In addition to \texttt{using Base}, modules also automatically contain a definition of the \texttt{eval} function, which evaluates expressions within the context of that module.



If these default definitions are not wanted, modules can be defined using the keyword \texttt{baremodule} instead (note: \texttt{Core} is still imported, as per above). In terms of \texttt{baremodule}, a standard \texttt{module} looks like this:




\begin{lstlisting}
baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
eval(m,x) = Core.eval(m, x)

...

end
\end{lstlisting}



\hypertarget{17994468613015467697}{}


\subsection{Relative and absolute module paths}



Given the statement \texttt{using Foo}, the system looks for \texttt{Foo} within \texttt{Main}. If the module does not exist, the system attempts to \texttt{require({\textquotedbl}Foo{\textquotedbl})}, which typically results in loading code from an installed package.



However, some modules contain submodules, which means you sometimes need to access a module that is not directly available in \texttt{Main}. There are two ways to do this. The first is to use an absolute path, for example \texttt{using Base.Sort}. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:




\begin{lstlisting}
module Parent

module Utils
...
end

using .Utils

...
end
\end{lstlisting}



Here module \texttt{Parent} contains a submodule \texttt{Utils}, and code in \texttt{Parent} wants the contents of \texttt{Utils} to be visible. This is done by starting the \texttt{using} path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example \texttt{using ..Utils} would look for \texttt{Utils} in \texttt{Parent}{\textquotesingle}s enclosing module rather than in \texttt{Parent} itself.



Note that relative-import qualifiers are only valid in \texttt{using} and \texttt{import} statements.



\hypertarget{5280833280108912411}{}


\subsection{Module file paths}



The global variable \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}} contains the directories Julia searches for modules when calling \texttt{require}. It can be extended using \hyperlink{18026893834387542681}{\texttt{push!}}:




\begin{minted}{julia}
push!(LOAD_PATH, "/Path/To/My/Module/")
\end{minted}



Putting this statement in the file \texttt{{\textasciitilde}/.juliarc.jl} will extend \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}} on every Julia startup. Alternatively, the module load path can be extended by defining the environment variable \texttt{JULIA\_LOAD\_PATH}.



\hypertarget{5887420707815829350}{}


\subsection{Namespace miscellanea}



If a name is qualified (e.g. \texttt{Base.sin}), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, \texttt{Base.+} for example, you must use \texttt{Base.:+} to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: \texttt{Base.:(==)}.



Macro names are written with \texttt{@} in import and export statements, e.g. \texttt{import Mod.@mac}. Macros in other modules can be invoked as \texttt{Mod.@mac} or \texttt{@Mod.mac}.



The syntax \texttt{M.x = y} does not work to assign a global in another module; global assignment is always module-local.



A variable can be {\textquotedbl}reserved{\textquotedbl} for the current module without assigning to it by declaring it as \texttt{global x} at the top level. This can be used to prevent name conflicts for globals initialized after load time.



\hypertarget{16026249523986343319}{}


\subsection{Module initialization and precompilation}



Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia provides the ability to create precompiled versions of modules to reduce this time.



To create an incremental precompiled module file, add \texttt{\_\_precompile\_\_()} at the top of your module file (before the \texttt{module} starts). This will cause it to be automatically compiled the first time it is imported. Alternatively, you can manually call \texttt{Base.compilecache(modulename)}. The resulting cache files will be stored in \texttt{Base.LOAD\_CACHE\_PATH[1]}. Subsequently, the module is automatically recompiled upon \texttt{import} whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by \texttt{include\_dependency(path)} in the module file(s).



For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by \texttt{include} or added explicitly by \texttt{include\_dependency} is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can{\textquotesingle}t copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in \texttt{require} matches the path that had created the precompile file.



It also takes into account the set of dependencies already loaded into the current process and won{\textquotesingle}t recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache. If you want to have changes to the source reflected in the running system, you should call \texttt{reload({\textquotedbl}Module{\textquotedbl})} on the module you changed, and any module that depended on it in which you want to see the change reflected.



Precompiling a module also recursively precompiles any modules that are imported therein. If you know that it is \emph{not} safe to precompile your module (for the reasons described below), you should put \texttt{\_\_precompile\_\_(false)} in the module file to cause \texttt{Base.compilecache} to throw an error (and thereby prevent the module from being imported by any other precompiled module).



\texttt{\_\_precompile\_\_()} should \emph{not} be used in a module unless all of its dependencies are also using \texttt{\_\_precompile\_\_()}. Failure to do so can result in a runtime error when loading the module.



In order to make your module work with precompilation, however, you may need to change your module to explicitly separate any initialization steps that must occur at \emph{runtime} from steps that can occur at \emph{compile time}.  For this purpose, Julia allows you to define an \texttt{\_\_init\_\_()} function in your module that executes any initialization steps that must occur at runtime. This function will not be called during compilation (\texttt{--output-*} or \texttt{\_\_precompile\_\_()}). You may, of course, call it manually if necessary, but the default is to assume this function deals with computing state for the local machine, which does not need to be – or even should not be – captured in the compiled image. It will be called after the module is loaded into a process, including if it is being loaded into an incremental compile (\texttt{--output-incremental=yes}), but not if it is being loaded into a full-compilation process.



In particular, if you define a \texttt{function \_\_init\_\_()} in a module, then Julia will call \texttt{\_\_init\_\_()} immediately \emph{after} the module is loaded (e.g., by \texttt{import}, \texttt{using}, or \texttt{require}) at runtime for the \emph{first} time (i.e., \texttt{\_\_init\_\_} is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their \texttt{\_\_init\_\_} functions called \emph{before} the \texttt{\_\_init\_\_} of the enclosing module.



Two typical uses of \texttt{\_\_init\_\_} are calling runtime initialization functions of external C libraries and initializing global constants that involve pointers returned by external libraries.  For example, suppose that we are calling a C library \texttt{libfoo} that requires us to call a \texttt{foo\_init()} initialization function at runtime. Suppose that we also want to define a global constant \texttt{foo\_data\_ptr} that holds the return value of a \texttt{void *foo\_data()} function defined by \texttt{libfoo} – this constant must be initialized at runtime (not at compile time) because the pointer address will change from run to run.  You could accomplish this by defining the following \texttt{\_\_init\_\_} function in your module:




\begin{minted}{julia}
const foo_data_ptr = Ref{Ptr{Void}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Void, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Void}, ())
end
\end{minted}



Notice that it is perfectly possible to define a global inside a function like \texttt{\_\_init\_\_}; this is one of the advantages of using a dynamic language. But by making it a constant at global scope, we can ensure that the type is known to the compiler and allow it to generate better optimized code. Obviously, any other globals in your module that depends on \texttt{foo\_data\_ptr} would also have to be initialized in \texttt{\_\_init\_\_}.



Constants involving most Julia objects that are not produced by \texttt{ccall} do not need to be placed in \texttt{\_\_init\_\_}: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (Ptr objects will turn into null pointers unless they are hidden inside an isbits object). This includes the return values of the Julia functions \texttt{cfunction} and \texttt{pointer}.



Dictionary and set types, or in general anything that depends on the output of a \texttt{hash(key)} method, are a trickier case.  In the common case where the keys are numbers, strings, symbols, ranges, \texttt{Expr}, or compositions of these types (via arrays, tuples, sets, pairs, etc.) they are safe to precompile.  However, for a few other key types, such as \texttt{Function} or \texttt{DataType} and generic user-defined types where you haven{\textquotesingle}t defined a \texttt{hash} method, the fallback \texttt{hash} method depends on the memory address of the object (via its \texttt{object\_id}) and hence may change from run to run. If you have one of these key types, or if you aren{\textquotesingle}t sure, to be safe you can initialize this dictionary from within your \texttt{\_\_init\_\_} function. Alternatively, you can use the \texttt{ObjectIdDict} dictionary type, which is specially handled by precompilation so that it is safe to initialize at compile-time.



When using precompilation, it is important to keep a clear sense of the distinction between the compilation phase and the execution phase. In this mode, it will often be much more clearly apparent that Julia is a compiler which allows execution of arbitrary Julia code, not a standalone interpreter that also generates compiled code.



Other known potential failure scenarios include:



\begin{itemize}
\item[1. ] Global counters (for example, for attempting to uniquely identify objects) Consider the following code snippet:


\begin{minted}{julia}
mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end
\end{minted}

while the intent of this code was to give every instance a unique id, the counter value is recorded at the end of compilation. All subsequent usages of this incrementally compiled module will start from that same counter value.

Note that \texttt{object\_id} (which works by hashing the memory pointer) has similar issues (see notes on \texttt{Dict} usage below).

One alternative is to store both \hyperlink{14046118357995428445}{\texttt{current\_module()}} and the current \texttt{counter} value, however, it may be better to redesign the code to not depend on this global state.


\item[2. ] Associative collections (such as \texttt{Dict} and \texttt{Set}) need to be re-hashed in \texttt{\_\_init\_\_}. (In the future, a mechanism may be provided to register an initializer function.)


\item[3. ] Depending on compile-time side-effects persisting through load-time. Example include: modifying arrays or other variables in other Julia modules; maintaining handles to open files or devices; storing pointers to other system resources (including memory);


\item[4. ] Creating accidental {\textquotedbl}copies{\textquotedbl} of global state from another module, by referencing it directly instead of via its lookup path. For example, (in global scope):


\begin{minted}{julia}
#mystdout = Base.STDOUT #= will not work correctly, since this will copy Base.STDOUT into this module =#
# instead use accessor functions:
getstdout() = Base.STDOUT #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.STDOUT #= also works =#
\end{minted}

\end{itemize}


Several additional restrictions are placed on the operations that can be done while precompiling code to help the user avoid other wrong-behavior situations:



\begin{itemize}
\item[1. ] Calling \hyperlink{2345597220715550879}{\texttt{eval}} to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.


\item[2. ] \texttt{global const} statements from local scope after \texttt{\_\_init\_\_()} has been started (see issue \#12010 for plans to add an error for this)


\item[3. ] Replacing a module (or calling \hyperlink{7789928938295338947}{\texttt{workspace()}}) is a runtime error while doing an incremental precompile.

\end{itemize}


A few other points to be aware of:



\begin{itemize}
\item[1. ] No code reload / cache invalidation is performed after changes are made to the source files themselves, (including by \hyperlink{14197801802374863313}{\texttt{Pkg.update}}), and no cleanup is done after \hyperlink{13989694063022152176}{\texttt{Pkg.rm}}


\item[2. ] The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)


\item[3. ] Expecting the filesystem to be unchanged between compile-time and runtime e.g. \hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}}/\texttt{source\_path()} to find resources at runtime, or the BinDeps \texttt{@checked\_lib} macro. Sometimes this is unavoidable. However, when possible, it can be good practice to copy resources into the module at compile-time so they won{\textquotesingle}t need to be found at runtime.


\item[4. ] \texttt{WeakRef} objects and finalizers are not currently handled properly by the serializer (this will be fixed in an upcoming release).


\item[5. ] It is usually best to avoid capturing references to instances of internal metadata objects such as \texttt{Method}, \texttt{MethodInstance}, \texttt{MethodTable}, \texttt{TypeMapLevel}, \texttt{TypeMapEntry} and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.

\end{itemize}


It is sometimes helpful during module development to turn off incremental precompilation. The command line flag \texttt{--compilecache=\{yes|no\}} enables you to toggle module precompilation on and off. When Julia is started with \texttt{--compilecache=no} the serialized modules in the compile cache are ignored when loading modules and module dependencies. \texttt{Base.compilecache()} can still be called manually and it will respect \texttt{\_\_precompile\_\_()} directives for the module. The state of this command line flag is passed to \hyperlink{8295561239210722937}{\texttt{Pkg.build()}} to disable automatic precompilation triggering when installing, updating, and explicitly building packages.



\hypertarget{12287408952024800641}{}


\chapter{Documentation}



Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.



The basic syntax is very simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called \emph{docstrings}). Here is a very simple example:




\begin{minted}{julia}
"Tell whether there are too foo items in the array."
foo(xs::Array) = ...
\end{minted}



Documentation is interpreted as \href{https://en.wikipedia.org/wiki/Markdown}{Markdown}, so you can use indentation and code fences to delimit code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one can construct other string macros and pass them to the \texttt{@doc} macro just as well.



Here is a more complex example, still using Markdown:




\begin{minted}{julia}
"""
    bar(x[, y])

Compute the Bar index between `x` and `y`. If `y` is missing, compute
the Bar index between all pairs of columns of `x`.

# Examples
```julia-repl
julia> bar([1, 2], [1, 2])
1
```
"""
function bar(x, y) ...
\end{minted}



As in the example above, we recommend following some simple conventions when writing documentation:



\begin{itemize}
\item[1. ] Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.

This can be identical to the signature present in the Julia code (like \texttt{mean(x::AbstractArray)}), or a simplified form. Optional arguments should be represented with their default values (i.e. \texttt{f(x, y=1)}) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. \texttt{f(x[, y])} and \texttt{f(x[, y[, z]])}). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a \texttt{<keyword arguments>} placeholder in the signature (i.e. \texttt{f(x; <keyword arguments>)}), and give the complete list under an \texttt{\# Arguments} section (see point 4 below).


\item[2. ] Include a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.

The one-line sentence should use the imperative form ({\textquotedbl}Do this{\textquotedbl}, {\textquotedbl}Return that{\textquotedbl}) instead of the third person (do not write {\textquotedbl}Returns the length...{\textquotedbl}) when documenting functions. It should end with a period. If the meaning of a function cannot be summarized easily, splitting it into separate composable parts could be beneficial (this should not be taken as an absolute requirement for every single case though).


\item[3. ] Do not repeat yourself.

Since the function name is given by the signature, there is no need to start the documentation with {\textquotedbl}The function \texttt{bar}...{\textquotedbl}: go straight to the point. Similarly, if the signature specifies the types of the arguments, mentioning them in the description is redundant.


\item[4. ] Only provide an argument list when really necessary.

For simple functions, it is often clearer to mention the role of the arguments directly in the description of the function{\textquotesingle}s purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an \texttt{\# Arguments} header, with one \texttt{-} bullet for each argument. The list should mention the types and default values (if any) of the arguments:


\begin{minted}{julia}
"""
...
# Arguments
- `n::Integer`: the number of elements to compute.
- `dim::Integer=1`: the dimensions along which to perform the computation.
...
"""
\end{minted}


\item[5. ] Include any code examples in an \texttt{\# Examples} section.

Examples should, whenever possible, be written as \emph{doctests}. A \emph{doctest} is a fenced code block (see \hyperlink{9246544299434150790}{Code blocks}) starting with \texttt{```jldoctest} and contains any number of \texttt{julia>} prompts together with inputs and expected outputs that mimic the Julia REPL.

For example in the following docstring a variable \texttt{a} is defined and the expected result, as printed in a Julia REPL, appears afterwards:


\begin{minted}{julia}
"""
Some nice documentation here.

# Examples

```jldoctest
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4
```
"""
\end{minted}

\begin{quote}
\textbf{Warning}

Calling \texttt{rand} and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions.

Operating system word size (\hyperlink{10103694114785108551}{\texttt{Int32}} or \hyperlink{7720564657383125058}{\texttt{Int64}}) as well as path separator differences (\texttt{/} or \texttt{{\textbackslash}}) will also affect the reproducibility of some doctests.

Note that whitespace in your doctest is significant! The doctest will fail if you misalign the output of pretty-printing an array, for example.

\end{quote}
You can then run \texttt{make -C doc doctest} to run all the doctests in the Julia Manual, which will ensure that your example works.

Examples that are untestable should be written within fenced code blocks starting with \texttt{```julia} so that they are highlighted correctly in the generated documentation.

\begin{quote}
\textbf{Tip}

Wherever possible examples should be \textbf{self-contained} and \textbf{runnable} so that readers are able to try them out without having to include any dependencies.

\end{quote}

\item[6. ] Use backticks to identify code and equations.

Julia identifiers and code excerpts should always appear between backticks \texttt{`} to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks \texttt{``}. Use Unicode characters rather than their LaTeX escape sequence, i.e. \texttt{``α = 1``} rather than \texttt{``{\textbackslash}{\textbackslash}alpha = 1``}.


\item[7. ] Place the starting and ending \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} characters on lines by themselves.

That is, write:


\begin{minted}{julia}
"""
...

...
"""
f(x, y) = ...
\end{minted}

rather than:


\begin{minted}{julia}
"""...

..."""
f(x, y) = ...
\end{minted}

This makes it more clear where docstrings start and end.


\item[8. ] Respect the line length limit used in the surrounding code.

Docstrings are edited using the same tools as code. Therefore, the same conventions should apply. It it advised to add line breaks after 92 characters.

\end{itemize}


\hypertarget{13175452021130145252}{}


\section{Accessing Documentation}



Documentation can be accessed at the REPL or in \href{https://github.com/JuliaLang/IJulia.jl}{IJulia} by typing \texttt{?} followed by the name of a function or macro, and pressing \texttt{Enter}. For example,




\begin{minted}{julia}
?fft
?@time
?r""
\end{minted}



will bring up docs for the relevant function, macro or string macro respectively. In \href{http://junolab.org}{Juno} using \texttt{Ctrl-J, Ctrl-D} will bring up documentation for the object under the cursor.



\hypertarget{1610925430009782653}{}


\section{Functions \& Methods}



Functions in Julia may have multiple implementations, known as methods. While it{\textquotesingle}s good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by \texttt{function bar end}). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:




\begin{minted}{julia}
"""
    *(x, y, z...)

Multiplication operator. `x * y * z *...` calls this function with multiple
arguments, i.e. `*(x, y, z...)`.
"""
function *(x, y, z...)
    # ... [implementation sold separately] ...
end

"""
    *(x::AbstractString, y::AbstractString, z::AbstractString...)

When applied to strings, concatenates them.
"""
function *(x::AbstractString, y::AbstractString, z::AbstractString...)
    # ... [insert secret sauce here] ...
end

help?> *
search: * .*

  *(x, y, z...)

  Multiplication operator. x * y * z *... calls this function with multiple
  arguments, i.e. *(x,y,z...).

  *(x::AbstractString, y::AbstractString, z::AbstractString...)

  When applied to strings, concatenates them.
\end{minted}



When retrieving documentation for a generic function, the metadata for each method is concatenated with the \texttt{catdoc} function, which can of course be overridden for custom types.



\hypertarget{7493863945551919908}{}


\section{Advanced Usage}



The \texttt{@doc} macro associates its first argument with its second in a per-module dictionary called \texttt{META}. By default, documentation is expected to be written in Markdown, and the \texttt{doc{\textquotedbl}{\textquotedbl}} string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.



When used for retrieving documentation, the \texttt{@doc} macro (or equally, the \texttt{doc} function) will search all \texttt{META} dictionaries for metadata relevant to the given object and return it. The returned object (some Markdown content, for example) will by default display itself intelligently. This design also makes it easy to use the doc system in a programmatic way; for example, to re-use documentation between different versions of a function:




\begin{minted}{julia}
@doc "..." foo!
@doc (@doc foo!) foo
\end{minted}



Or for use with Julia{\textquotesingle}s metaprogramming functionality:




\begin{minted}{julia}
for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))
    @eval begin
        $f(a,b) = $op(a,b)
    end
end
@doc "`add(a,b)` adds `a` and `b` together" add
@doc "`subtract(a,b)` subtracts `b` from `a`" subtract
\end{minted}



Documentation written in non-toplevel blocks, such as \texttt{begin}, \texttt{if}, \texttt{for}, and \texttt{let}, is added to the documentation system as blocks are evaluated. For example:




\begin{minted}{julia}
if VERSION > v"0.5"
    "..."
    f(x) = x
end
\end{minted}



will add documentation to \texttt{f(x)} when the condition is \texttt{true}. Note that even if \texttt{f(x)} goes out of scope at the end of the block, its documentation will remain.



\hypertarget{1853789607931388452}{}


\subsection{Dynamic documentation}



Sometimes the appropriate documentation for an instance of a type depends on the field values of that instance, rather than just on the type itself. In these cases, you can add a method to \texttt{Docs.getdoc} for your custom type that returns the documentation on a per-instance basis. For instance,




\begin{minted}{julia}
struct MyType
    value::String
end

Docs.getdoc(t::MyType) = "Documentation for MyType with value $(t.value)"

x = MyType("x")
y = MyType("y")
\end{minted}



\texttt{?x} will display {\textquotedbl}Documentation for MyType with value x{\textquotedbl} while \texttt{?y} will display {\textquotedbl}Documentation for MyType with value y{\textquotedbl}.



\hypertarget{16279340761375223329}{}


\section{Syntax Guide}



A comprehensive overview of all documentable Julia syntax.



In the following examples \texttt{{\textquotedbl}...{\textquotedbl}} is used to illustrate an arbitrary docstring which may be one of the follow four variants and contain arbitrary text:




\begin{minted}{julia}
"..."

doc"..."

"""
...
"""

doc"""
...
"""
\end{minted}



\texttt{@doc\_str} should only be used when the docstring contains \texttt{\$} or \texttt{{\textbackslash}} characters that should not be parsed by Julia such as LaTeX syntax or Julia source code examples containing interpolation.



\hypertarget{8714381096633713163}{}


\subsection{Functions and Methods}




\begin{minted}{julia}
"..."
function f end

"..."
f
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to \texttt{Function}\texttt{f}. The first version is the preferred syntax, however both are equivalent.




\begin{minted}{julia}
"..."
f(x) = x

"..."
function f(x)
    x
end

"..."
f(x)
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to \texttt{Method}\texttt{f(::Any)}.




\begin{minted}{julia}
"..."
f(x, y = 1) = x + y
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to two \texttt{Method}s, namely \texttt{f(::Any)} and \texttt{f(::Any, ::Any)}.



\hypertarget{7735912728489467540}{}


\subsection{Macros}




\begin{minted}{julia}
"..."
macro m(x) end
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the \texttt{@m(::Any)} macro definition.




\begin{minted}{julia}
"..."
:(@m)
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the macro named \texttt{@m}.



\hypertarget{388524109337598454}{}


\subsection{Types}




\begin{lstlisting}
"..."
abstract type T1 end

"..."
mutable struct T2
    ...
end

"..."
struct T3
    ...
end
\end{lstlisting}



Adds the docstring \texttt{{\textquotedbl}...{\textquotedbl}} to types \texttt{T1}, \texttt{T2}, and \texttt{T3}.




\begin{minted}{julia}
"..."
struct T
    "x"
    x
    "y"
    y
end
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to type \texttt{T}, \texttt{{\textquotedbl}x{\textquotedbl}} to field \texttt{T.x} and \texttt{{\textquotedbl}y{\textquotedbl}} to field \texttt{T.y}. Also applicable to \texttt{mutable struct} types.



\hypertarget{11199822992728837276}{}


\subsection{Modules}




\begin{minted}{julia}
"..."
module M end

module M

"..."
M

end
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the \texttt{Module}\texttt{M}. Adding the docstring above the \texttt{Module} is the preferred syntax, however both are equivalent.




\begin{minted}{julia}
"..."
baremodule M
# ...
end

baremodule M

import Base: @doc

"..."
f(x) = x

end
\end{minted}



Documenting a \texttt{baremodule} by placing a docstring above the expression automatically imports \texttt{@doc} into the module. These imports must be done manually when the module expression is not documented. Empty \texttt{baremodule}s cannot be documented.



\hypertarget{1246107342185770044}{}


\subsection{Global Variables}




\begin{minted}{julia}
"..."
const a = 1

"..."
b = 2

"..."
global c = 3
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the \texttt{Binding}s \texttt{a}, \texttt{b}, and \texttt{c}.



\texttt{Binding}s are used to store a reference to a particular \texttt{Symbol} in a \texttt{Module} without storing the referenced value itself.



\begin{quote}
\textbf{Note}

When a \texttt{const} definition is only used to define an alias of another definition, such as is the case with the function \texttt{div} and its alias \texttt{÷} in \texttt{Base}, do not document the alias and instead document the actual function.

If the alias is documented and not the real definition then the docsystem (\texttt{?} mode) will not return the docstring attached to the alias when the real definition is searched for.

For example you should write


\begin{minted}{julia}
"..."
f(x) = x + 1
const alias = f
\end{minted}

rather than


\begin{minted}{julia}
f(x) = x + 1
"..."
const alias = f
\end{minted}

\end{quote}



\begin{minted}{julia}
"..."
sym
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the value associated with \texttt{sym}. Users should prefer documenting \texttt{sym} at it{\textquotesingle}s definition.



\hypertarget{16007303151473682937}{}


\subsection{Multiple Objects}




\begin{minted}{julia}
"..."
a, b
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to \texttt{a} and \texttt{b} each of which should be a documentable expression. This syntax is equivalent to




\begin{minted}{julia}
"..."
a

"..."
b
\end{minted}



Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions \texttt{f} and \texttt{f!}.



\hypertarget{10676417314609910318}{}


\subsection{Macro-generated code}




\begin{minted}{julia}
"..."
@m expression
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to expression generated by expanding \texttt{@m expression}. This allows for expressions decorated with \texttt{@inline}, \texttt{@noinline}, \texttt{@generated}, or any other macro to be documented in the same way as undecorated expressions.



Macro authors should take note that only macros that generate a single expression will automatically support docstrings. If a macro returns a block containing multiple subexpressions then the subexpression that should be documented must be marked using the \hyperlink{8194145670752069829}{\texttt{@\_\_doc\_\_}} macro.



The \texttt{@enum} macro makes use of \texttt{@\_\_doc\_\_} to allow for documenting \texttt{Enum}s. Examining it{\textquotesingle}s definition should serve as an example of how to use \texttt{@\_\_doc\_\_} correctly.


\hypertarget{8194145670752069829}{} 
\hyperlink{8194145670752069829}{\texttt{Core.@\_\_doc\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@__doc__(ex)
\end{lstlisting}

Low-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.


\begin{lstlisting}
macro example(f)
    quote
        $(f)() = 0
        @__doc__ $(f)(x) = 1
        $(f)(x, y) = 2
    end |> esc
end
\end{lstlisting}

\texttt{@\_\_doc\_\_} has no effect when a macro that uses it is not documented.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/Docs.jl#L570-L585}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9616939662988024327}{}


\section{Markdown syntax}



The following markdown syntax is supported in Julia.



\hypertarget{8063626144587397226}{}


\subsection{Inline elements}



Here {\textquotedbl}inline{\textquotedbl} refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.



\hypertarget{10166533682417016306}{}


\subsubsection{Bold}



Surround words with two asterisks, \texttt{**}, to display the enclosed text in boldface.




\begin{lstlisting}
A paragraph containing a **bold** word.
\end{lstlisting}



\hypertarget{4277603997710742460}{}


\subsubsection{Italics}



Surround words with one asterisk, \texttt{*}, to display the enclosed text in italics.




\begin{lstlisting}
A paragraph containing an *emphasised* word.
\end{lstlisting}



\hypertarget{6850088772867679045}{}


\subsubsection{Literals}



Surround text that should be displayed exactly as written with single backticks, \texttt{`} .




\begin{lstlisting}
A paragraph containing a `literal` word.
\end{lstlisting}



Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.



\begin{quote}
\textbf{Tip}

To include a backtick character within literal text use three backticks rather than one to enclose the text.


\begin{lstlisting}
A paragraph containing a ``` `backtick` character ```.
\end{lstlisting}

By extension any odd number of backticks may be used to enclose a lesser number of backticks.

\end{quote}


\hypertarget{6917271240677862304}{}


\subsubsection{\LaTeX}



Surround text that should be displayed as mathematics using \LaTeX syntax with double backticks, \texttt{``} .




\begin{lstlisting}
A paragraph containing some ``\LaTeX`` markup.
\end{lstlisting}



\begin{quote}
\textbf{Tip}

As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within \LaTeX markup then two enclosing backticks is sufficient.

\end{quote}


\hypertarget{10395937766942848638}{}


\subsubsection{Links}



Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, \texttt{[ ]}, is the name of the link and the text enclosed in parentheses, \texttt{( )}, is the URL.




\begin{lstlisting}
A paragraph containing a link to [Julia](http://www.julialang.org).
\end{lstlisting}



It{\textquotesingle}s also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:




\begin{minted}{julia}
"""
    eigvals!(A,[irange,][vl,][vu]) -> values

Same as [`eigvals`](@ref), but saves space by overwriting the input `A`, instead of creating a copy.
"""
\end{minted}



This will create a link in the generated docs to the \texttt{eigvals} documentation (which has more information about what this function actually does). It{\textquotesingle}s good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.



\begin{quote}
\textbf{Note}

The above cross referencing is \emph{not} a Markdown feature, and relies on \href{https://github.com/JuliaDocs/Documenter.jl}{Documenter.jl}, which is used to build base Julia{\textquotesingle}s documentation.

\end{quote}


\hypertarget{1886176754537713588}{}


\subsubsection{Footnote references}



Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word containing no punctuation.




\begin{lstlisting}
A paragraph containing a numbered footnote [^1] and a named one [^named].
\end{lstlisting}



\begin{quote}
\textbf{Note}

The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the \hyperlink{1021238270223877775}{Footnotes} section below.

\end{quote}


\hypertarget{1299449328577314863}{}


\subsection{Toplevel elements}



The following elements can be written either at the {\textquotedbl}toplevel{\textquotedbl} of a document or within another {\textquotedbl}toplevel{\textquotedbl} element.



\hypertarget{7653906193491884111}{}


\subsubsection{Paragraphs}



A paragraph is a block of plain text, possibly containing any number of inline elements defined in the \hyperlink{8063626144587397226}{Inline elements} section above, with one or more blank lines above and below it.




\begin{lstlisting}
This is a paragraph.

And this is *another* one containing some emphasised text.
A new line, but still part of the same paragraph.
\end{lstlisting}



\hypertarget{14939650886219602329}{}


\subsubsection{Headers}



A document can be split up into different sections using headers. Headers use the following syntax:




\begin{minted}{julia}
# Level One
## Level Two
### Level Three
#### Level Four
##### Level Five
###### Level Six
\end{minted}



A header line can contain any inline syntax in the same way as a paragraph can.



\begin{quote}
\textbf{Tip}

Try to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics.

\end{quote}


\hypertarget{9246544299434150790}{}


\subsubsection{Code blocks}



Source code can be displayed as a literal block using an indent of four spaces as shown in the following example.




\begin{lstlisting}
This is a paragraph.

    function func(x)
        # ...
    end

Another paragraph.
\end{lstlisting}



Additionally, code blocks can be enclosed using triple backticks with an optional {\textquotedbl}language{\textquotedbl} to specify how a block of code should be highlighted.




\begin{lstlisting}
A code block without a "language":

```
function func(x)
    # ...
end
```

and another one with the "language" specified as `julia`:

```julia
function func(x)
    # ...
end
```
\end{lstlisting}



\begin{quote}
\textbf{Note}

{\textquotedbl}Fenced{\textquotedbl} code blocks, as shown in the last example, should be prefered over indented code blocks since there is no way to specify what language an indented code block is written in.

\end{quote}


\hypertarget{12305052721486916392}{}


\subsubsection{Block quotes}



Text from external sources, such as quotations from books or websites, can be quoted using \texttt{>} characters prepended to each line of the quote as follows.




\begin{lstlisting}
Here's a quote:

> Julia is a high-level, high-performance dynamic programming language for
> technical computing, with syntax that is familiar to users of other
> technical computing environments.
\end{lstlisting}



Note that a single space must appear after the \texttt{>} character on each line. Quoted blocks may themselves contain other toplevel or inline elements.



\hypertarget{9122787766607047979}{}


\subsubsection{Images}



The syntax for images is similar to the link syntax mentioned above. Prepending a \texttt{!} character to a link will display an image from the specified URL rather than a link to it.




\begin{minted}{julia}
![alternative text](link/to/image.png)
\end{minted}



\hypertarget{5671077042730580546}{}


\subsubsection{Lists}



Unordered lists can be written by prepending each item in a list with either \texttt{*}, \texttt{+}, or \texttt{-}.




\begin{lstlisting}
A list of items:

  * item one
  * item two
  * item three
\end{lstlisting}



Note the two spaces before each \texttt{*} and the single space after each one.



Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.




\begin{lstlisting}
Another list:

  * item one

  * item two

    ```
    f(x) = x
    ```

  * And a sublist:

      + sub-item one
      + sub-item two
\end{lstlisting}



\begin{quote}
\textbf{Note}

The contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the \texttt{i} in \texttt{item two}.

\end{quote}


Ordered lists are written by replacing the {\textquotedbl}bullet{\textquotedbl} character, either \texttt{*}, \texttt{+}, or \texttt{-}, with a positive integer followed by either \texttt{.} or \texttt{)}.




\begin{lstlisting}
Two ordered lists:

 1. item one
 2. item two
 3. item three

 5) item five
 6) item six
 7) item seven
\end{lstlisting}



An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.



\hypertarget{8249559303631128892}{}


\subsubsection{Display equations}



Large \LaTeX equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the {\textquotedbl}language{\textquotedbl} \texttt{math} as in the example below.




\begin{minted}{julia}
```math
f(a) = \frac{1}{2\pi}\int_{0}^{2\pi} (\alpha+R\cos(\theta))d\theta
```
\end{minted}



\hypertarget{1021238270223877775}{}


\subsubsection{Footnotes}



This syntax is paired with the inline syntax for \hyperlink{1886176754537713588}{Footnote references}. Make sure to read that section as well.



Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the \texttt{:} character that is appended to the footnote label.




\begin{lstlisting}
[^1]: Numbered footnote text.

[^note]:

    Named footnote text containing several toplevel elements.

      * item one
      * item two
      * item three

    ```julia
    function func(x)
        # ...
    end
    ```
\end{lstlisting}



\begin{quote}
\textbf{Note}

No checks are done during parsing to make sure that all footnote references have matching footnotes.

\end{quote}


\hypertarget{5663489325501471007}{}


\subsubsection{Horizontal rules}



The equivalent of an \texttt{<hr>} HTML tag can be written using the following syntax:




\begin{lstlisting}
Text above the line.

---

And text below the line.
\end{lstlisting}



\hypertarget{13092196581825070152}{}


\subsubsection{Tables}



Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above – only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.




\begin{lstlisting}
| Column One | Column Two | Column Three |
|:---------- | ---------- |:------------:|
| Row `1`    | Column `2` |              |
| *Row* 2    | **Row** 2  | Column ``3`` |
\end{lstlisting}



\begin{quote}
\textbf{Note}

As illustrated in the above example each column of \texttt{|} characters must be aligned vertically.

A \texttt{:} character on either end of a column{\textquotesingle}s header separator (the row containing \texttt{-} characters) specifies whether the row is left-aligned, right-aligned, or (when \texttt{:} appears on both ends) center-aligned. Providing no \texttt{:} characters will default to right-aligning the column.

\end{quote}


\hypertarget{7215905182614360565}{}


\subsubsection{Admonitions}



Specially formatted blocks with titles such as {\textquotedbl}Notes{\textquotedbl}, {\textquotedbl}Warning{\textquotedbl}, or {\textquotedbl}Tips{\textquotedbl} are known as admonitions and are used when some part of a document needs special attention. They can be defined using the following \texttt{!!!} syntax:




\begin{lstlisting}
!!! note

    This is the content of the note.

!!! warning "Beware!"

    And this is another one.

    This warning admonition has a custom title: `"Beware!"`.
\end{lstlisting}



Admonitions, like most other toplevel elements, can contain other toplevel elements. When no title text, specified after the admonition type in double quotes, is included then the title used will be the type of the block, i.e. \texttt{{\textquotedbl}Note{\textquotedbl}} in the case of the \texttt{note} admonition.



\hypertarget{10627994621615977524}{}


\section{Markdown Syntax Extensions}



Julia{\textquotesingle}s markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual \texttt{show} methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.



In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.



\hypertarget{15444528597476882531}{}


\chapter{Metaprogramming}



The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of \href{https://en.wikipedia.org/wiki/Abstract\_syntax\_tree}{abstract syntax trees}. In contrast, preprocessor {\textquotedbl}macro{\textquotedbl} systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful \href{https://en.wikipedia.org/wiki/Reflection\_\%28computer\_programming\%29}{reflection} capabilities are available to explore the internals of a program and its types just like any other data.



\hypertarget{12892852681895845682}{}


\section{Program representation}



Every Julia program starts life as a string:




\begin{lstlisting}
julia> prog = "1 + 1"
"1 + 1"
\end{lstlisting}



\textbf{What happens next?}



The next step is to \href{https://en.wikipedia.org/wiki/Parsing\#Computer\_languages}{parse} each string into an object called an expression, represented by the Julia type \texttt{Expr}:




\begin{lstlisting}
julia> ex1 = parse(prog)
:(1 + 1)

julia> typeof(ex1)
Expr
\end{lstlisting}



\texttt{Expr} objects contain two parts:



\begin{itemize}
\item a \texttt{Symbol} identifying the kind of expression. A symbol is an \href{https://en.wikipedia.org/wiki/String\_interning}{interned string} identifier (more discussion below).

\end{itemize}



\begin{lstlisting}
julia> ex1.head
:call
\end{lstlisting}



\begin{itemize}
\item the expression arguments, which may be symbols, other expressions, or literal values:

\end{itemize}



\begin{lstlisting}
julia> ex1.args
3-element Array{Any,1}:
  :+
 1
 1
\end{lstlisting}



Expressions may also be constructed directly in \href{https://en.wikipedia.org/wiki/Polish\_notation}{prefix notation}:




\begin{lstlisting}
julia> ex2 = Expr(:call, :+, 1, 1)
:(1 + 1)
\end{lstlisting}



The two expressions constructed above – by parsing and by direct construction – are equivalent:




\begin{lstlisting}
julia> ex1 == ex2
true
\end{lstlisting}



\textbf{The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.}



The \hyperlink{15981569052160951906}{\texttt{dump()}} function provides indented and annotated display of \texttt{Expr} objects:




\begin{lstlisting}
julia> dump(ex2)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1
  typ: Any
\end{lstlisting}



\texttt{Expr} objects may also be nested:




\begin{lstlisting}
julia> ex3 = parse("(4 + 4) / 2")
:((4 + 4) / 2)
\end{lstlisting}



Another way to view expressions is with Meta.show\_sexpr, which displays the \href{https://en.wikipedia.org/wiki/S-expression}{S-expression} form of a given \texttt{Expr}, which may look very familiar to users of Lisp. Here{\textquotesingle}s an example illustrating the display on a nested \texttt{Expr}:




\begin{lstlisting}
julia> Meta.show_sexpr(ex3)
(:call, :/, (:call, :+, 4, 4), 2)
\end{lstlisting}



\hypertarget{6563994256673110563}{}


\subsection{Symbols}



The \texttt{:} character has two syntactic purposes in Julia. The first form creates a \hyperlink{18332791376992528422}{\texttt{Symbol}}, an \href{https://en.wikipedia.org/wiki/String\_interning}{interned string} used as one building-block of expressions:




\begin{minted}{jlcon}
julia> :foo
:foo

julia> typeof(ans)
Symbol
\end{minted}



The \hyperlink{18332791376992528422}{\texttt{Symbol}} constructor takes any number of arguments and creates a new symbol by concatenating their string representations together:




\begin{minted}{jlcon}
julia> :foo == Symbol("foo")
true

julia> Symbol("func",10)
:func10

julia> Symbol(:var,'_',"sym")
:var_sym
\end{minted}



In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate \hyperlink{14993622729045334657}{scope}.



Sometimes extra parentheses around the argument to \texttt{:} are needed to avoid ambiguity in parsing.:




\begin{minted}{jlcon}
julia> :(:)
:(:)

julia> :(::)
:(::)
\end{minted}



\hypertarget{12215734802536944772}{}


\section{Expressions and evaluation}



\hypertarget{11332877811842244390}{}


\subsection{Quoting}



The second syntactic purpose of the \texttt{:} character is to create expression objects without using the explicit \texttt{Expr} constructor. This is referred to as \emph{quoting}. The \texttt{:} character, followed by paired parentheses around a single statement of Julia code, produces an \texttt{Expr} object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:




\begin{minted}{jlcon}
julia> ex = :(a+b*c+1)
:(a + b * c + 1)

julia> typeof(ex)
Expr
\end{minted}



(to view the structure of this expression, try \texttt{ex.head} and \texttt{ex.args}, or use \hyperlink{15981569052160951906}{\texttt{dump()}} as above)



Note that equivalent expressions may be constructed using \hyperlink{13108503824143481717}{\texttt{parse()}} or the direct \texttt{Expr} form:




\begin{minted}{jlcon}
julia>      :(a + b*c + 1)  ==
       parse("a + b*c + 1") ==
       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)
true
\end{minted}



Expressions provided by the parser generally only have symbols, other expressions, and literal values as their args, whereas expressions constructed by Julia code can have arbitrary run-time values without literal forms as args. In this specific example, \texttt{+} and \texttt{a} are symbols, \texttt{*(b,c)} is a subexpression, and \texttt{1} is a literal 64-bit signed integer.



There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in \texttt{quote ... end}. Note that this form introduces \texttt{QuoteNode} elements to the expression tree, which must be considered when directly manipulating an expression tree generated from \texttt{quote} blocks. For other purposes, \texttt{:( ... )} and \texttt{quote .. end} blocks are treated identically.




\begin{minted}{jlcon}
julia> ex = quote
           x = 1
           y = 2
           x + y
       end
quote  # none, line 2:
    x = 1 # none, line 3:
    y = 2 # none, line 4:
    x + y
end

julia> typeof(ex)
Expr
\end{minted}



\hypertarget{8465054249083249204}{}


\subsection{Interpolation}



Direct construction of \texttt{Expr} objects with value arguments is powerful, but \texttt{Expr} constructors can be tedious compared to {\textquotedbl}normal{\textquotedbl} Julia syntax. As an alternative, Julia allows {\textquotedbl}splicing{\textquotedbl} or interpolation of literals or expressions into quoted expressions. Interpolation is indicated by the \texttt{\$} prefix.



In this example, the literal value of \texttt{a} is interpolated:




\begin{lstlisting}
julia> a = 1;

julia> ex = :($a + b)
:(1 + b)
\end{lstlisting}



Interpolating into an unquoted expression is not supported and will cause a compile-time error:




\begin{lstlisting}
julia> $a + b
ERROR: unsupported or misplaced expression $
 ...
\end{lstlisting}



In this example, the tuple \texttt{(1,2,3)} is interpolated as an expression into a conditional test:




\begin{lstlisting}
julia> ex = :(a in $:((1,2,3)) )
:(a in (1, 2, 3))
\end{lstlisting}



Interpolating symbols into a nested expression requires enclosing each symbol in an enclosing quote block:




\begin{minted}{jlcon}
julia> :( :a in $( :(:a + :b) ) )
                   ^^^^^^^^^^
                   quoted inner expression
\end{minted}



The use of \texttt{\$} for expression interpolation is intentionally reminiscent of \hyperlink{12583298261221600612}{string interpolation} and \hyperlink{6373319844820183024}{command interpolation}. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.



\hypertarget{14639104447431020358}{}


\subsection{\texttt{eval()} and effects}



Given an expression object, one can cause Julia to evaluate (execute) it at global scope using \hyperlink{2345597220715550879}{\texttt{eval()}}:




\begin{lstlisting}
julia> :(1 + 2)
:(1 + 2)

julia> eval(ans)
3

julia> ex = :(a + b)
:(a + b)

julia> eval(ex)
ERROR: UndefVarError: b not defined
[...]

julia> a = 1; b = 2;

julia> eval(ex)
3
\end{lstlisting}



Every \hyperlink{10438697863683890874}{module} has its own \hyperlink{2345597220715550879}{\texttt{eval()}} function that evaluates expressions in its global scope. Expressions passed to \hyperlink{2345597220715550879}{\texttt{eval()}} are not limited to returning values – they can also have side-effects that alter the state of the enclosing module{\textquotesingle}s environment:




\begin{minted}{jlcon}
julia> ex = :(x = 1)
:(x = 1)

julia> x
ERROR: UndefVarError: x not defined

julia> eval(ex)
1

julia> x
1
\end{minted}



Here, the evaluation of an expression object causes a value to be assigned to the global variable \texttt{x}.



Since expressions are just \texttt{Expr} objects which can be constructed programmatically and then evaluated, it is possible to dynamically generate arbitrary code which can then be run using \hyperlink{2345597220715550879}{\texttt{eval()}}. Here is a simple example:




\begin{minted}{jlcon}
julia> a = 1;

julia> ex = Expr(:call, :+, a, :b)
:(1 + b)

julia> a = 0; b = 2;

julia> eval(ex)
3
\end{minted}



The value of \texttt{a} is used to construct the expression \texttt{ex} which applies the \texttt{+} function to the value 1 and the variable \texttt{b}. Note the important distinction between the way \texttt{a} and \texttt{b} are used:



\begin{itemize}
\item The value of the \emph{variable}\texttt{a} at expression construction time is used as an immediate value in the expression. Thus, the value of \texttt{a} when the expression is evaluated no longer matters: the value in the expression is already \texttt{1}, independent of whatever the value of \texttt{a} might be.


\item On the other hand, the \emph{symbol}\texttt{:b} is used in the expression construction, so the value of the variable \texttt{b} at that time is irrelevant – \texttt{:b} is just a symbol and the variable \texttt{b} need not even be defined. At expression evaluation time, however, the value of the symbol \texttt{:b} is resolved by looking up the value of the variable \texttt{b}.

\end{itemize}


\hypertarget{17158151525488525846}{}


\subsection{Functions on \texttt{Expr}essions}



As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning \texttt{Expr} objects: the \hyperlink{13108503824143481717}{\texttt{parse()}} function, which takes a string of Julia code and returns the corresponding \texttt{Expr}. A function can also take one or more \texttt{Expr} objects as arguments, and return another \texttt{Expr}. Here is a simple, motivating example:




\begin{minted}{jlcon}
julia> function math_expr(op, op1, op2)
           expr = Expr(:call, op, op1, op2)
           return expr
       end
math_expr (generic function with 1 method)

julia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))
:(1 + 4 * 5)

julia> eval(ex)
21
\end{minted}



As another example, here is a function that doubles any numeric argument, but leaves expressions alone:




\begin{minted}{jlcon}
julia> function make_expr2(op, opr1, opr2)
           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))
           retexpr = Expr(:call, op, opr1f, opr2f)
           return retexpr
       end
make_expr2 (generic function with 1 method)

julia> make_expr2(:+, 1, 2)
:(2 + 4)

julia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))
:(2 + 5 * 8)

julia> eval(ex)
42
\end{minted}



\hypertarget{11146454106624591870}{}


\section{Macros}



Macros provide a method to include generated code in the final body of a program. A macro maps a tuple of arguments to a returned \emph{expression}, and the resulting expression is compiled directly rather than requiring a runtime \hyperlink{2345597220715550879}{\texttt{eval()}} call. Macro arguments may include expressions, literal values, and symbols.



\hypertarget{6520588903420337396}{}


\subsection{Basics}



Here is an extraordinarily simple macro:




\begin{lstlisting}
julia> macro sayhello()
           return :( println("Hello, world!") )
       end
@sayhello (macro with 1 method)
\end{lstlisting}



Macros have a dedicated character in Julia{\textquotesingle}s syntax: the \texttt{@} (at-sign), followed by the unique name declared in a \texttt{macro NAME ... end} block. In this example, the compiler will replace all instances of \texttt{@sayhello} with:




\begin{minted}{julia}
:( println("Hello, world!") )
\end{minted}



When \texttt{@sayhello} is entered in the REPL, the expression executes immediately, thus we only see the evaluation result:




\begin{lstlisting}
julia> @sayhello()
Hello, world!
\end{lstlisting}



Now, consider a slightly more complex macro:




\begin{lstlisting}
julia> macro sayhello(name)
           return :( println("Hello, ", $name) )
       end
@sayhello (macro with 1 method)
\end{lstlisting}



This macro takes one argument: \texttt{name}. When \texttt{@sayhello} is encountered, the quoted expression is \emph{expanded} to interpolate the value of the argument into the final expression:




\begin{lstlisting}
julia> @sayhello("human")
Hello, human
\end{lstlisting}



We can view the quoted return expression using the function \hyperlink{8018172489611994488}{\texttt{macroexpand()}} (\textbf{important note:} this is an extremely useful tool for debugging macros):




\begin{lstlisting}
julia> ex = macroexpand( :(@sayhello("human")) )
:((println)("Hello, ", "human"))

julia> typeof(ex)
Expr
\end{lstlisting}



We can see that the \texttt{{\textquotedbl}human{\textquotedbl}} literal has been interpolated into the expression.



There also exists a macro \hyperlink{14913190777653949565}{\texttt{@macroexpand}} that is perhaps a bit more convenient than the \texttt{macroexpand} function:




\begin{lstlisting}
julia> @macroexpand @sayhello "human"
:((println)("Hello, ", "human"))
\end{lstlisting}



\hypertarget{12261577225730588688}{}


\subsection{Hold up: why macros?}



We have already seen a function \texttt{f(::Expr...) -> Expr} in a previous section. In fact, \hyperlink{8018172489611994488}{\texttt{macroexpand()}} is also such a function. So, why do macros exist?



Macros are necessary because they execute when code is parsed, therefore, macros allow the programmer to generate and include fragments of customized code \emph{before} the full program is run. To illustrate the difference, consider the following example:




\begin{lstlisting}
julia> macro twostep(arg)
           println("I execute at parse time. The argument is: ", arg)
           return :(println("I execute at runtime. The argument is: ", $arg))
       end
@twostep (macro with 1 method)

julia> ex = macroexpand( :(@twostep :(1, 2, 3)) );
I execute at parse time. The argument is: $(Expr(:quote, :((1, 2, 3))))
\end{lstlisting}



The first call to \hyperlink{783803254548423222}{\texttt{println()}} is executed when \hyperlink{8018172489611994488}{\texttt{macroexpand()}} is called. The resulting expression contains \emph{only} the second \texttt{println}:




\begin{lstlisting}
julia> typeof(ex)
Expr

julia> ex
:((println)("I execute at runtime. The argument is: ", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))

julia> eval(ex)
I execute at runtime. The argument is: (1, 2, 3)
\end{lstlisting}



\hypertarget{2473581068379690741}{}


\subsection{Macro invocation}



Macros are invoked with the following general syntax:




\begin{minted}{julia}
@name expr1 expr2 ...
@name(expr1, expr2, ...)
\end{minted}



Note the distinguishing \texttt{@} before the macro name and the lack of commas between the argument expressions in the first form, and the lack of whitespace after \texttt{@name} in the second form. The two styles should not be mixed. For example, the following syntax is different from the examples above; it passes the tuple \texttt{(expr1, expr2, ...)} as one argument to the macro:




\begin{minted}{julia}
@name (expr1, expr2, ...)
\end{minted}



It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the \hyperlink{14071376285304310153}{\texttt{show()}} function within the macro body:




\begin{minted}{jlcon}
julia> macro showarg(x)
           show(x)
           # ... remainder of macro, returning an expression
       end
@showarg (macro with 1 method)

julia> @showarg(a)
:a

julia> @showarg(1+1)
:(1 + 1)

julia> @showarg(println("Yo!"))
:(println("Yo!"))
\end{minted}



\hypertarget{14391724801032783576}{}


\subsection{Building an advanced macro}



Here is a simplified definition of Julia{\textquotesingle}s \texttt{@assert} macro:




\begin{lstlisting}
julia> macro assert(ex)
           return :( $ex ? nothing : throw(AssertionError($(string(ex)))) )
       end
@assert (macro with 1 method)
\end{lstlisting}



This macro can be used like this:




\begin{lstlisting}
julia> @assert 1 == 1.0

julia> @assert 1 == 0
ERROR: AssertionError: 1 == 0
\end{lstlisting}



In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:




\begin{minted}{julia}
1 == 1.0 ? nothing : throw(AssertionError("1 == 1.0"))
1 == 0 ? nothing : throw(AssertionError("1 == 0"))
\end{minted}



That is, in the first call, the expression \texttt{:(1 == 1.0)} is spliced into the test condition slot, while the value of \texttt{string(:(1 == 1.0))} is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the \texttt{@assert} macro call occurs. Then at execution time, if the test expression evaluates to true, then \texttt{nothing} is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false. Notice that it would not be possible to write this as a function, since only the \emph{value} of the condition is available and it would be impossible to display the expression that computed it in the error message.



The actual definition of \texttt{@assert} in the standard library is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments, this is specified with an ellipses following the last argument:




\begin{lstlisting}
julia> macro assert(ex, msgs...)
           msg_body = isempty(msgs) ? ex : msgs[1]
           msg = string(msg_body)
           return :($ex ? nothing : throw(AssertionError($msg)))
       end
@assert (macro with 1 method)
\end{lstlisting}



Now \texttt{@assert} has two modes of operation, depending upon the number of arguments it receives! If there{\textquotesingle}s only one argument, the tuple of expressions captured by \texttt{msgs} will be empty and it will behave the same as the simpler definition above. But now if the user specifies a second argument, it is printed in the message body instead of the failing expression. You can inspect the result of a macro expansion with the aptly named \hyperlink{8018172489611994488}{\texttt{macroexpand()}} function:




\begin{lstlisting}
julia> macroexpand(:(@assert a == b))
:(if a == b
        nothing
    else
        (throw)((AssertionError)("a == b"))
    end)

julia> macroexpand(:(@assert a==b "a should equal b!"))
:(if a == b
        nothing
    else
        (throw)((AssertionError)("a should equal b!"))
    end)
\end{lstlisting}



There is yet another case that the actual \texttt{@assert} macro handles: what if, in addition to printing {\textquotedbl}a should equal b,{\textquotedbl} we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., \texttt{@assert a==b {\textquotedbl}a (\$a) should equal b (\$b)!{\textquotedbl}}, but this won{\textquotesingle}t work as expected with the above macro. Can you see why? Recall from \hyperlink{12583298261221600612}{string interpolation} that an interpolated string is rewritten to a call to \hyperlink{7919678712989769360}{\texttt{string()}}. Compare:




\begin{minted}{jlcon}
julia> typeof(:("a should equal b"))
String

julia> typeof(:("a ($a) should equal b ($b)!"))
Expr

julia> dump(:("a ($a) should equal b ($b)!"))
Expr
  head: Symbol string
  args: Array{Any}((5,))
    1: String "a ("
    2: Symbol a
    3: String ") should equal b ("
    4: Symbol b
    5: String ")!"
  typ: Any
\end{minted}



So now instead of getting a plain string in \texttt{msg\_body}, the macro is receiving a full expression that will need to be evaluated in order to display as expected. This can be spliced directly into the returned expression as an argument to the \hyperlink{7919678712989769360}{\texttt{string()}} call; see \href{https://github.com/JuliaLang/julia/blob/master/base/error.jl}{\texttt{error.jl}} for the complete implementation.



The \texttt{@assert} macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body.



\hypertarget{9112380944649753006}{}


\subsection{Hygiene}



An issue that arises in more complex macros is that of \href{https://en.wikipedia.org/wiki/Hygienic\_macro}{hygiene}. In short, macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into. Conversely, the expressions that are passed into a macro as arguments are often \emph{expected} to evaluate in the context of the surrounding code, interacting with and modifying the existing variables. Another concern arises from the fact that a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia already has a major advantage over languages with textual macro expansion (like C) in that it only needs to consider the returned expression. All the other variables (such as \texttt{msg} in \texttt{@assert} above) follow the \hyperlink{14993622729045334657}{normal scoping block behavior}.



To demonstrate these issues, let us consider writing a \texttt{@time} macro that takes an expression as its argument, records the time, evaluates the expression, records the time again, prints the difference between the before and after times, and then has the value of the expression as its final value. The macro might look like this:




\begin{minted}{julia}
macro time(ex)
    return quote
        local t0 = time()
        local val = $ex
        local t1 = time()
        println("elapsed time: ", t1-t0, " seconds")
        val
    end
end
\end{minted}



Here, we want \texttt{t0}, \texttt{t1}, and \texttt{val} to be private temporary variables, and we want \texttt{time} to refer to the \hyperlink{2441622941271736623}{\texttt{time()}} function in the standard library, not to any \texttt{time} variable the user might have (the same applies to \texttt{println}). Imagine the problems that could occur if the user expression \texttt{ex} also contained assignments to a variable called \texttt{t0}, or defined its own \texttt{time} variable. We might get errors, or mysteriously incorrect behavior.



Julia{\textquotesingle}s macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the \hyperlink{3515345868651201289}{\texttt{gensym()}} function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro{\textquotesingle}s locals will not conflict with any user variables, and \texttt{time} and \texttt{println} will refer to the standard library definitions.



One problem remains however. Consider the following use of this macro:




\begin{minted}{julia}
module MyModule
import Base.@time

time() = ... # compute something

@time time()
end
\end{minted}



Here the user expression \texttt{ex} is a call to \texttt{time}, but not the same \texttt{time} function that the macro uses. It clearly refers to \texttt{MyModule.time}. Therefore we must arrange for the code in \texttt{ex} to be resolved in the macro call environment. This is done by {\textquotedbl}escaping{\textquotedbl} the expression with \hyperlink{17861659594346526773}{\texttt{esc()}}:




\begin{minted}{julia}
macro time(ex)
    ...
    local val = $(esc(ex))
    ...
end
\end{minted}



An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.



This escaping mechanism can be used to {\textquotedbl}violate{\textquotedbl} hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets \texttt{x} to zero in the call environment:




\begin{minted}{jlcon}
julia> macro zerox()
           return esc(:(x = 0))
       end
@zerox (macro with 1 method)

julia> function foo()
           x = 1
           @zerox
           return x # is zero
       end
foo (generic function with 1 method)

julia> foo()
0
\end{minted}



This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.



\hypertarget{9929589604023551324}{}


\section{Code Generation}



When a significant amount of repetitive boilerplate code is required, it is common to generate it programmatically to avoid redundancy. In most languages, this requires an extra build step, and a separate program to generate the repetitive code. In Julia, expression interpolation and \hyperlink{2345597220715550879}{\texttt{eval()}} allow such code generation to take place in the normal course of program execution. For example, the following code defines a series of operators on three arguments in terms of their 2-argument forms:




\begin{minted}{julia}
for op = (:+, :*, :&, :|, :$)
    eval(quote
        ($op)(a,b,c) = ($op)(($op)(a,b),c)
    end)
end
\end{minted}



In this manner, Julia acts as its own \href{https://en.wikipedia.org/wiki/Preprocessor}{preprocessor}, and allows code generation from inside the language. The above code could be written slightly more tersely using the \texttt{:} prefix quoting form:




\begin{minted}{julia}
for op = (:+, :*, :&, :|, :$)
    eval(:(($op)(a,b,c) = ($op)(($op)(a,b),c)))
end
\end{minted}



This sort of in-language code generation, however, using the \texttt{eval(quote(...))} pattern, is common enough that Julia comes with a macro to abbreviate this pattern:




\begin{minted}{julia}
for op = (:+, :*, :&, :|, :$)
    @eval ($op)(a,b,c) = ($op)(($op)(a,b),c)
end
\end{minted}



The \hyperlink{12895501458291832858}{\texttt{@eval}} macro rewrites this call to be precisely equivalent to the above longer versions. For longer blocks of generated code, the expression argument given to \hyperlink{12895501458291832858}{\texttt{@eval}} can be a block:




\begin{minted}{julia}
@eval begin
    # multiple lines
end
\end{minted}



\hypertarget{15927263197819636529}{}


\section{Non-Standard String Literals}



Recall from \hyperlink{16709477590855265963}{Strings} that string literals prefixed by an identifier are called non-standard string literals, and can have different semantics than un-prefixed string literals. For example:



\begin{itemize}
\item \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} produces a regular expression object rather than a string


\item \texttt{b{\textquotedbl}DATA{\textbackslash}xff{\textbackslash}u2200{\textquotedbl}} is a byte array literal for \texttt{[68,65,84,65,255,226,136,128]}.

\end{itemize}


Perhaps surprisingly, these behaviors are not hard-coded into the Julia parser or compiler. Instead, they are custom behaviors provided by a general mechanism that anyone can use: prefixed string literals are parsed as calls to specially-named macros. For example, the regular expression macro is just the following:




\begin{minted}{julia}
macro r_str(p)
    Regex(p)
end
\end{minted}



That{\textquotesingle}s all. This macro says that the literal contents of the string literal \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} should be passed to the \texttt{@r\_str} macro and the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} is equivalent to placing the following object directly into the syntax tree:




\begin{minted}{julia}
Regex("^\\s*(?:#|\$)")
\end{minted}



Not only is the string literal form shorter and far more convenient, but it is also more efficient: since the regular expression is compiled and the \texttt{Regex} object is actually created \emph{when the code is compiled}, the compilation occurs only once, rather than every time the code is executed. Consider if the regular expression occurs in a loop:




\begin{minted}{julia}
for line = lines
    m = match(r"^\s*(?:#|$)", line)
    if m === nothing
        # non-comment
    else
        # comment
    end
end
\end{minted}



Since the regular expression \texttt{r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}} is compiled and inserted into the syntax tree when this code is parsed, the expression is only compiled once instead of each time the loop is executed. In order to accomplish this without macros, one would have to write this loop like this:




\begin{minted}{julia}
re = Regex("^\\s*(?:#|\$)")
for line = lines
    m = match(re, line)
    if m === nothing
        # non-comment
    else
        # comment
    end
end
\end{minted}



Moreover, if the compiler could not determine that the regex object was constant over all loops, certain optimizations might not be possible, making this version still less efficient than the more convenient literal form above. Of course, there are still situations where the non-literal form is more convenient: if one needs to interpolate a variable into the regular expression, one must take this more verbose approach; in cases where the regular expression pattern itself is dynamic, potentially changing upon each loop iteration, a new regular expression object must be constructed on each iteration. In the vast majority of use cases, however, regular expressions are not constructed based on run-time data. In this majority of cases, the ability to write regular expressions as compile-time values is invaluable.



Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command literal \texttt{custom`literal`} is parsed as \texttt{@custom\_cmd {\textquotedbl}literal{\textquotedbl}}. Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the \texttt{\_cmd} suffix instead of the \texttt{\_str} suffix, non-standard command literals behave exactly like non-standard string literals.



In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both \texttt{Foo} and \texttt{Bar} provide non-standard string literal \texttt{@x\_str}, then one can write \texttt{Foo.x{\textquotedbl}literal{\textquotedbl}} or \texttt{Bar.x{\textquotedbl}literal{\textquotedbl}} to disambiguate between the two.



The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia{\textquotesingle}s non-standard literals implemented using it, but also the command literal syntax (\texttt{`echo {\textquotedbl}Hello, \$person{\textquotedbl}`}) is implemented with the following innocuous-looking macro:




\begin{minted}{julia}
macro cmd(str)
    :(cmd_gen($(shell_parse(str)[1])))
end
\end{minted}



Of course, a large amount of complexity is hidden in the functions used in this macro definition, but they are just functions, written entirely in Julia. You can read their source and see precisely what they do – and all they do is construct expression objects to be inserted into your program{\textquotesingle}s syntax tree.



\hypertarget{5974918746922359559}{}


\section{Generated functions}



A very special macro is \texttt{@generated}, which allows you to define so-called \emph{generated functions}. These have the capability to generate specialized code depending on the types of their arguments with more flexibility and/or less code than what can be achieved with multiple dispatch. While macros work with expressions at parsing-time and cannot access the types of their inputs, a generated function gets expanded at a time when the types of the arguments are known, but the function is not yet compiled.



Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When called, the body expression is first evaluated and compiled, then the returned expression is compiled and run. To make this efficient, the result is often cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible framework to move work from run-time to compile-time, at the expense of greater restrictions on the allowable constructs.



When defining generated functions, there are four main differences to ordinary functions:



\begin{itemize}
\item[1. ] You annotate the function declaration with the \texttt{@generated} macro. This adds some information to the AST that lets the compiler know that this is a generated function.


\item[2. ] In the body of the generated function you only have access to the \emph{types} of the arguments – not their values – and any function that was defined \emph{before} the definition of the generated function.


\item[3. ] Instead of calculating something or performing some action, you return a \emph{quoted expression} which, when evaluated, does what you want.


\item[4. ] Generated functions must not \emph{mutate} or \emph{observe} any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using \texttt{method\_exists}). This means they can only read global constants, and cannot have any side effects. In other words, they must be completely pure. Due to an implementation limitation, this also means that they currently cannot define a closure or untyped generator.

\end{itemize}


It{\textquotesingle}s easiest to illustrate this with an example. We can declare a generated function \texttt{foo} as




\begin{lstlisting}
julia> @generated function foo(x)
           Core.println(x)
           return :(x * x)
       end
foo (generic function with 1 method)
\end{lstlisting}



Note that the body returns a quoted expression, namely \texttt{:(x * x)}, rather than just the value of \texttt{x * x}.



From the caller{\textquotesingle}s perspective, they are very similar to regular functions; in fact, you don{\textquotesingle}t have to know if you{\textquotesingle}re calling a regular or generated function - the syntax and result of the call is just the same. Let{\textquotesingle}s see how \texttt{foo} behaves:




\begin{lstlisting}
julia> x = foo(2); # note: output is from println() statement in the body
Int64

julia> x           # now we print x
4

julia> y = foo("bar");
String

julia> y
"barbar"
\end{lstlisting}



So, we see that in the body of the generated function, \texttt{x} is the \emph{type} of the passed argument, and the value returned by the generated function, is the result of evaluating the quoted expression we returned from the definition, now with the \emph{value} of \texttt{x}.



What happens if we evaluate \texttt{foo} again with a type that we have already used?




\begin{lstlisting}
julia> foo(4)
16
\end{lstlisting}



Note that there is no printout of \hyperlink{7720564657383125058}{\texttt{Int64}}. We can see that the body of the generated function was only executed once here, for the specific set of argument types, and the result was cached. After that, for this example, the expression returned from the generated function on the first invocation was re-used as the method body. However, the actual caching behavior is an implementation-defined performance optimization, so it is invalid to depend too closely on this behavior.



The number of times a generated function is generated \emph{might} be only once, but it \emph{might} also be more often, or appear to not happen at all. As a consequence, you should \emph{never} write a generated function with side effects - when, and how often, the side effects occur is undefined. (This is true for macros too - and just like for macros, the use of \hyperlink{2345597220715550879}{\texttt{eval()}} in a generated function is a sign that you{\textquotesingle}re doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to \hyperlink{2345597220715550879}{\texttt{eval()}}, so it is disallowed.



It is also important to see how \texttt{@generated} functions interact with method redefinition. Following the principle that a correct \texttt{@generated} function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function \emph{cannot} call any method that was not defined prior to the \emph{definition} of the generated function itself.



Initially \texttt{f(x)} has one definition




\begin{lstlisting}
julia> f(x) = "original definition";
\end{lstlisting}



Define other operations that use \texttt{f(x)}:




\begin{lstlisting}
julia> g(x) = f(x);

julia> @generated gen1(x) = f(x);

julia> @generated gen2(x) = :(f(x));
\end{lstlisting}



We now add some new definitions for \texttt{f(x)}:




\begin{lstlisting}
julia> f(x::Int) = "definition for Int";

julia> f(x::Type{Int}) = "definition for Type{Int}";
\end{lstlisting}



and compare how these results differ:




\begin{lstlisting}
julia> f(1)
"definition for Int"

julia> g(1)
"definition for Int"

julia> gen1(1)
"original definition"

julia> gen2(1)
"definition for Int"
\end{lstlisting}



Each method of a generated function has its own view of defined functions:




\begin{lstlisting}
julia> @generated gen1(x::Real) = f(x);

julia> gen1(1)
"definition for Type{Int}"
\end{lstlisting}



The example generated function \texttt{foo} above did not do anything a normal function \texttt{foo(x) = x * x} could not do (except printing the type on the first invocation, and incurring higher overhead). However, the power of a generated function lies in its ability to compute different quoted expressions depending on the types passed to it:




\begin{minted}{jlcon}
julia> @generated function bar(x)
           if x <: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia> bar(4)
16

julia> bar("baz")
"baz"
\end{minted}



(although of course this contrived example would be more easily implemented using multiple dispatch...)



Abusing this will corrupt the runtime system and cause undefined behavior:




\begin{minted}{jlcon}
julia> @generated function baz(x)
           if rand() < .9
               return :(x^2)
           else
               return :("boo!")
           end
       end
baz (generic function with 1 method)
\end{minted}



Since the body of the generated function is non-deterministic, its behavior, \emph{and the behavior of all subsequent code} is undefined.



\emph{Don{\textquotesingle}t copy these examples!}



These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, \emph{don{\textquotesingle}t copy them}, for the following reasons:



\begin{itemize}
\item the \texttt{foo} function has side-effects (the call to \texttt{Core.println}), and it is undefined exactly when, how often or how many times these side-effects will occur


\item the \texttt{bar} function solves a problem that is better solved with multiple dispatch - defining \texttt{bar(x) = x} and \texttt{bar(x::Integer) = x {\textasciicircum} 2} will do the same thing, but it is both simpler and faster.


\item the \texttt{baz} function is pathologically insane

\end{itemize}


Note that the set of operations that should not be attempted in a generated function is unbounded, and the runtime system can currently only detect a subset of the invalid operations. There are many other operations that will simply corrupt the runtime system without notification, usually in subtle ways not obviously connected to the bad definition. Because the function generator is run during inference, it must respect all of the limitations of that code.



Some operations that should not be attempted include:



\begin{itemize}
\item[1. ] Caching of native pointers.


\item[2. ] Interacting with the contents or methods of Core.Inference in any way.


\item[3. ] Observing any mutable state.

\begin{itemize}
\item Inference on the generated function may be run at \emph{any} time, including while your code is attempting to observe or mutate this state.

\end{itemize}

\item[4. ] Taking any locks: C code you call out to may use locks internally, (for example, it is not problematic to call \texttt{malloc}, even though most implementations require locks internally) but don{\textquotesingle}t attempt to hold or acquire any while executing Julia code.


\item[5. ] Calling any function that is defined after the body of the generated function. This condition is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.

\end{itemize}


Alright, now that we have a better understanding of how generated functions work, let{\textquotesingle}s use them to build some more advanced (and valid) functionality...



\hypertarget{6756262828640546675}{}


\subsection{An advanced example}



Julia{\textquotesingle}s base library has a \hyperlink{3802607582438455846}{\texttt{sub2ind()}} function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index \texttt{i} that can be used to index into an array \texttt{A} using \texttt{A[i]}, instead of \texttt{A[x,y,z,...]}. One possible implementation is the following:




\begin{lstlisting}
julia> function sub2ind_loop(dims::NTuple{N}, I::Integer...) where N
           ind = I[N] - 1
           for i = N-1:-1:1
               ind = I[i]-1 + dims[i]*ind
           end
           return ind + 1
       end
sub2ind_loop (generic function with 1 method)

julia> sub2ind_loop((3, 5), 1, 2)
4
\end{lstlisting}



The same thing can be done using recursion:




\begin{minted}{jlcon}
julia> sub2ind_rec(dims::Tuple{}) = 1;

julia> sub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =
           i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());

julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;

julia> sub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =
           i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);

julia> sub2ind_rec((3, 5), 1, 2)
4
\end{minted}



Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting the offset in each dimension into the final index.



However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an \emph{expression} that calculates the index:




\begin{lstlisting}
julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen (generic function with 1 method)

julia> sub2ind_gen((3, 5), 1, 2)
4
\end{lstlisting}



\textbf{What code will this generate?}



An easy way to find out is to extract the body into another (regular) function:




\begin{lstlisting}
julia> @generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N
           return sub2ind_gen_impl(dims, I...)
       end
sub2ind_gen (generic function with 1 method)

julia> function sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N
           length(I) == N || return :(error("partial indexing is unsupported"))
           ex = :(I[$N] - 1)
           for i = (N - 1):-1:1
               ex = :(I[$i] - 1 + dims[$i] * $ex)
           end
           return :($ex + 1)
       end
sub2ind_gen_impl (generic function with 1 method)
\end{lstlisting}



We can now execute \texttt{sub2ind\_gen\_impl} and examine the expression it returns:




\begin{lstlisting}
julia> sub2ind_gen_impl(Tuple{Int,Int}, Int, Int)
:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)
\end{lstlisting}



So, the method body that will be used here doesn{\textquotesingle}t include a loop at all - just indexing into the two tuples, multiplication and addition/subtraction. All the looping is performed compile-time, and we avoid looping during execution entirely. Thus, we only loop \emph{once per type}, in this case once per \texttt{N} (except in edge cases where the function is generated more than once - see disclaimer above).



\hypertarget{12380164357355707963}{}


\chapter{Arrays Multi-dimensionales}



Julia, como la mayoría de los lenguajes informáticos técnicos, proporciona una implementación de los arrays de primera clase. La mayoría de los lenguajes informáticos técnicos prestan mucha atención a su implementación de arrays a expensas de otros contenedores. Julia no trata los arrays de manera especial. La biblioteca de arrays se ha implementado casi completamente en el propio lenguaje Julia, y deriva su rendimiento del compilador, al igual que cualquier otro código escrito en Julia. Como tal, es también posible definir tipos de arrays personalizados heredando de AbstractArray. Consulte la \hyperlink{522338241536202486}{sección de manual en la interfaz AbstractArray} para ms detalles sobre implementar un tipo array personalizado.



Un array es una colección de objetos almacenados en una cuadrícula multidimensional. En el caso más general, un array puede contener objetos de tipo \texttt{Any}. Para la mayoría de los propósitos computacionales, los arrays deben contener objetos de un tipo más específico, como  \hyperlink{5027751419500983000}{\texttt{Float64}} o \hyperlink{10103694114785108551}{\texttt{Int32}}.



En general, a diferencia de muchos otros lenguajes informáticos técnicos, Julia no espera que los programas se escriban en un estilo vectorizado para el rendimiento. El compilador de Julia utiliza la inferencia de tipos y genera código optimizado para la indexación escalar de arrays, permitiendo que los programas se escriban en un estilo que sea conveniente y legible, sin sacrificar el rendimiento y utilizando menos memoria a veces.



En Julia, todos los argumentos a las funciones se pasan por referencia. Algunos lenguajes informáticos técnicos pasan los arrays por valor, y esto es conveniente en muchos casos. En Julia, las modificaciones hechas a los arrays de entrada dentro de una función serán visibles en la función principal. Toda la biblioteca de arrays de Julia garantiza que las entradas no sean modificadas por las funciones de biblioteca. El código de usuario, si necesita mostrar un comportamiento similar, debe tener cuidado de crear una copia de las entradas que puede modificar.



\hypertarget{15299817005323384893}{}


\section{Arrays}



\hypertarget{3742150230926700713}{}


\subsection{Funciones Básicas}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\hyperlink{6396209842929672718}{\texttt{eltype(A)}} & Tipo de los elementos contenidos en \texttt{A} \\
\hline
\hyperlink{4781133548011803693}{\texttt{length(A)}} & Número de elementos en \texttt{A} \\
\hline
\hyperlink{1688406579181746010}{\texttt{ndims(A)}} & Número de dimensiones de \texttt{A} \\
\hline
\hyperlink{17888996102305087038}{\texttt{size(A)}} & Una tupla que contien las dimensiones de \texttt{A} \\
\hline
\hyperlink{17888996102305087038}{\texttt{size(A,n)}} & El tamaño de \texttt{A} a lo largo de una dimensión particular \texttt{n} \\
\hline
\hyperlink{16112307926804387301}{\texttt{indices(A)}} & Una tupla que contiene los índices válidos de \texttt{A} \\
\hline
\hyperlink{16112307926804387301}{\texttt{indices(A,n)}} & Un rango expresando los úndices válidos a lo largo de la dimensión \texttt{n}           \\
\hline
\hyperlink{4701773772897287974}{\texttt{eachindex(A)}} & Un iterador eficiente para visitar cada posición en \texttt{A} \\
\hline
\hyperlink{97811245619734938}{\texttt{stride(A,k)}} & La zancada (\emph{stride}, distancia de índice lineal entre elementos adyacentes) a lo largo de la dimensión \texttt{k}. \\
\hline
\hyperlink{13576557637670855932}{\texttt{strides(A)}} & Una tupla de las zancadas en cada dimensión \\
\hline
\end{tabulary}

\end{table}



\hypertarget{2718974068386098500}{}


\subsection{Construcción e Inicialización}



Existen muchas funciones para construir e inicializar matrices. En la siguiente lista de tales funciones, las llamadas con un argumento \texttt{dims...} pueden tomar una sola tupla de tamaños de dimensión o una serie de tamaños de dimensión pasados como un número variable de argumentos. Muchas de estas funciones también aceptan un primea entrada \texttt{T}, que es el tipo de los elementos del array. Si este tipo es omitido se asumirá como tipo por defecto por defecto \hyperlink{5027751419500983000}{\texttt{Float64}}.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\hyperlink{15492651498431872487}{\texttt{Array\{T\}(dims...)}} & an uninitialized dense \hyperlink{15492651498431872487}{\texttt{Array}} \\
\hline
\hyperlink{13837674686090348619}{\texttt{zeros(T, dims...)}} & an \texttt{Array} of all zeros \\
\hline
\hyperlink{13837674686090348619}{\texttt{zeros(A)}} & an array of all zeros with the same type, element type and shape as \texttt{A} \\
\hline
\hyperlink{5858390260510292771}{\texttt{ones(T, dims...)}} & an \texttt{Array} of all ones \\
\hline
\hyperlink{5858390260510292771}{\texttt{ones(A)}} & an array of all ones with the same type, element type and shape as \texttt{A} \\
\hline
\hyperlink{12844393578243965152}{\texttt{trues(dims...)}} & a \hyperlink{18015155802543401629}{\texttt{BitArray}} with all values \texttt{true} \\
\hline
\hyperlink{12844393578243965152}{\texttt{trues(A)}} & a \texttt{BitArray} with all values \texttt{true} and the same shape as \texttt{A} \\
\hline
\hyperlink{12518029339635756199}{\texttt{falses(dims...)}} & a \texttt{BitArray} with all values \texttt{false} \\
\hline
\hyperlink{12518029339635756199}{\texttt{falses(A)}} & a \texttt{BitArray} with all values \texttt{false} and the same shape as \texttt{A} \\
\hline
\hyperlink{3388738163419525310}{\texttt{reshape(A, dims...)}} & an array containing the same data as \texttt{A}, but with different dimensions \\
\hline
\hyperlink{15665284441316555522}{\texttt{copy(A)}} & copy \texttt{A} \\
\hline
\hyperlink{3259459540194502889}{\texttt{deepcopy(A)}} & copy \texttt{A}, recursively copying its elements \\
\hline
\hyperlink{18368531196314541873}{\texttt{similar(A, T, dims...)}} & an uninitialized array of the same type as \texttt{A} (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of \texttt{A} if omitted. \\
\hline
\hyperlink{293815781001952115}{\texttt{reinterpret(T, A)}} & an array with the same binary data as \texttt{A}, but with element type \texttt{T} \\
\hline
\hyperlink{791894090820620170}{\texttt{rand(T, dims...)}} & an \texttt{Array} with random, iid \footnotemark[1] and uniformly distributed values in the half-open interval \([0, 1)\) \\
\hline
\hyperlink{8153706463199753760}{\texttt{randn(T, dims...)}} & an \texttt{Array} with random, iid and standard normally distributed values \\
\hline
\hyperlink{245874853049830800}{\texttt{eye(T, n)}} & \texttt{n}-by-\texttt{n} identity matrix \\
\hline
\hyperlink{245874853049830800}{\texttt{eye(T, m, n)}} & \texttt{m}-by-\texttt{n} identity matrix \\
\hline
\hyperlink{11519832570242386196}{\texttt{linspace(start, stop, n)}} & range of \texttt{n} linearly spaced elements from \texttt{start} to \texttt{stop} \\
\hline
\hyperlink{5162290739791026948}{\texttt{fill!(A, x)}} & fill the array \texttt{A} with the value \texttt{x} \\
\hline
\hyperlink{2836152204730819918}{\texttt{fill(x, dims...)}} & an \texttt{Array} filled with the value \texttt{x} \\
\hline
\end{tabulary}

\end{table}



\footnotetext[1]{\emph{iid}, independently and identically distributed.

}


La sintaxis \texttt{[A, B, C, ...]} construye un array 1-dimensional (vector) a partir de sus argumentos. Si todos los argumentos tienen un \hyperlink{10686378388163930476}{tipo de promocion} comun entonces ellos son convertidos a este tipo usando \texttt{convert()}.



\hypertarget{10393014471752931909}{}


\subsection{Concatenación}



Los arrays pueden ser construídos y también concatenados usando las siguientes funciones:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\hyperlink{9868138443525443234}{\texttt{cat(k, A...)}} & concatena n-d arrays a lo largo de la dimensión \texttt{k} \\
\hline
\hyperlink{14691815416955507876}{\texttt{vcat(A...)}} & abreviatura para \texttt{cat(1, A...)} \\
\hline
\hyperlink{8862791894748483563}{\texttt{hcat(A...)}} & abreviatura para \texttt{cat(2, A...)} \\
\hline
\end{tabulary}

\end{table}



Los valores escalares pasados a estas funciones son tratados como arrays de 1 elemento.



Las funciones de concatenación se usan tan frecuentemente que tiene una sintaxis especial:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Expression & Calls \\
\hline
\texttt{[A; B; C; ...]} & \hyperlink{14691815416955507876}{\texttt{vcat()}} \\
\hline
\texttt{[A B C ...]} & \hyperlink{8862791894748483563}{\texttt{hcat()}} \\
\hline
\texttt{[A B; C D; ...]} & \hyperlink{16279083053557795116}{\texttt{hvcat()}} \\
\hline
\end{tabulary}

\end{table}



\hyperlink{16279083053557795116}{\texttt{hvcat()}} concatena tanto en la dimensión 1 (con puntos y coma) como en la dos (con espacios).



\hypertarget{40378116110818994}{}


\subsection{Inicializadores de Array Tipados}



Se puede construir una matriz con un tipo de elemento específico utilizando la sintaxis \texttt{T[A, B, C, ...]}. Esto construirá un array 1-d con el tipo de elemento \texttt{T}, inicializado para contener los elementos \texttt{A}, \texttt{B}, \texttt{C}, etc. Por ejemplo, \texttt{Any [x, y, z]} construye un array heterogéneo que puede contener cualquier valor.



La sintaxis de concatenación puede ser prefijada de forma similar con un tipo para especificar el tipo de elemento del resultado.




\begin{minted}{jlcon}
julia> [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia> Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4
\end{minted}



\hypertarget{10712284114727773149}{}


\subsection{Comprensiones}



Las comprensiones proporcionan una forma general y potente de construir arrays. Su sintaxis es similar a la notación de construcción de conjuntos en matemáticas:




\begin{lstlisting}
A = [ F(x,y,...) for x=rx, y=ry, ... ]
\end{lstlisting}



El significado de esta forma es que \texttt{F(x, y, ...)} es evaluado para las variables x, y, etc. tomando cada valor de la lista de valores proporcionada. Los valores se pueden especificar mediante cualquier objeto iterable, pero comúnmente serán rangos como \texttt{1:n} o \texttt{2:(n-1)}, o arrays de valores explícitos como \texttt{[1.2, 3.4, 5.7]}. El resultado es una matriz N-d densa con dimensiones que son la concatenación de las dimensiones de los rangos de las variables \texttt{rx}, \texttt{ry}, etc. y donde cada evaluación \texttt{F(x, y, ...)} devuelve un escalar.



El siguiente ejemplo calcula la media ponderada del elemento actual y su vecino izquierdo y derecho a lo largo de una rejilla unidimensional:




\begin{minted}{jlcon}
julia> x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511
\end{minted}



El tipo del array resultante depende de los tipos de los elementos calculados. Para controlar el tipo explícitamente, un tipo puede ser precedido a la comprensión. Por ejemplo, podríamos haber solicitado el resultado en precisión simple escribiendo:




\begin{minted}{julia}
Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
\end{minted}



\hypertarget{5932317856076876818}{}


\subsection{Expresiones Generador}



Las comprensiones también se pueden escribir sin los corchetes que las encierran, produciendo un objeto conocido como \textbf{generador}. Este objeto puede ser iterado para producir valores bajo demanda, en lugar de reservar espacio para un array y almacenarlos en él de antemano (véase \hyperlink{5510379658285713272}{Iteración}). Por ejemplo, la siguiente expresión suma una serie sin asignar memoria:




\begin{minted}{jlcon}
julia> sum(1/n^2 for n=1:1000)
1.6439345666815615
\end{minted}



Cuando se escribe una expresión generador con múltiples dimensiones dentro de una lista de argumentos, se necesitan paréntesis para separar el generador de argumentos posteriores:




\begin{minted}{jlcon}
julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification
\end{minted}



Todas las expresiones separadas por comas después del \texttt{for} se interpretan como rangos. Añadir paréntesis permite añadir un tercer argumento a \texttt{map}:




\begin{minted}{jlcon}
julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)
\end{minted}



Los rangos en generadores y comprensiones pueden depender de rangos anteriores escribiendo varias palabras clave \texttt{for}:




\begin{minted}{jlcon}
julia> [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)
\end{minted}



En tales casos, el resultado es siempre unidimensional.



Los valores generados se pueden filtrar usando la palabra clave \texttt{if}:




\begin{minted}{jlcon}
julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)
\end{minted}



\hypertarget{14469287548874312017}{}


\subsection{Indexación}



La sintaxis general para indexar en un array n-dimensional \texttt{A} es:




\begin{lstlisting}
X = A[I_1, I_2, ..., I_n]
\end{lstlisting}



donde cada \texttt{I\_k} puede ser un entero escalar, un array de enteros o cualquier otro \hyperlink{982887983034702059}{índice soportado}. Esto incluye \hyperlink{13649361117037263099}{\texttt{Colon}} (\texttt{:}) para seleccionar todos los índices dentro de la dimensión completa, rangos de la forma \texttt{a:c} o \texttt{a:b:c} para seleccionar subsecciones contiguas o con salto, y arrays de booleans para seleccionar elementos en sus índices \texttt{true}.



Si todos los índices son escalares, entonces el resultado \texttt{X} es un solo elemento del array \texttt{A}. De lo contrario, \texttt{X} es un array con el mismo número de dimensiones que la suma de las dimensionalidades de todos los índices.



Si todos los índices son vectores, por ejemplo, entonces la forma de \texttt{X} sería \texttt{(length(I\_1), length(I\_2), ..., length(I\_n))}, donde las ubicaciones \texttt{(i\_1, i\_2, ..., i\_n)} de \texttt{X} contienen el valor \texttt{A[I\_1[i\_1], I\_2[i\_2], ..., I\_n[i\_n]]}. Si \texttt{I\_1} se cambia por un array bidimensional, entonces \texttt{X} se vuelve un \texttt{n+1}-dimensional array de forma \texttt{(size(I\_1, 1), size(I\_1, 2), length(I\_2), ..., length(I\_n))}. La matriz añade una dimensión. La ubicación \texttt{(i\_1, i\_2, i\_3, ..., i\_\{n+1\})} contiene el valor en \texttt{A[I\_1[i\_1, i\_2], I\_2[i\_3], ..., I\_n[i\_\{n+1\}]]}. Todas las dimensiones indexadas con escalares se eliminan. Por ejemplo, el resultado de \texttt{A[2, I, 3]} es un array de tamaño \texttt{size(I)}. Su i-ésimo elemento es poblado por \texttt{A[2, I[i], 3]}.



Como parte especial de esta sintaxis, se puede usar la palabra clave \texttt{end} para representar el último índice de cada dimensión dentro de los corchetes de indexación, según lo determinado por el tamaño del array más interno indexado. La sintaxis de indexación sin la palabra \texttt{end} es equivalente a una llamada a \texttt{getindex}:




\begin{lstlisting}
X = getindex(A, I_1, I_2, ..., I_n)
\end{lstlisting}



Example:




\begin{minted}{jlcon}
julia> x = reshape(1:16, 4, 4)
4×4 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia> x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1
\end{minted}



Los rangos vacío de la forma \texttt{n:n-1} se suelen usar para indicar la localización inter-index entre \texttt{n-1} y \texttt{n}. Por ejemplo, la función \hyperlink{17287969759719368562}{\texttt{searchsorted()}} usa esta convención para indicar el punto de inserción de un valor no encontrados en un array ordenado:




\begin{minted}{jlcon}
julia> a = [1,2,5,6,7];

julia> searchsorted(a, 3)
3:2
\end{minted}



\hypertarget{5433025065156514046}{}


\subsection{Asignación}



La sintaxis general para asignar valores en un array n-dimensional \texttt{A} es:




\begin{lstlisting}
A[I_1, I_2, ..., I_n] = X
\end{lstlisting}



donde cada \texttt{I\_k} puede ser un índice escalar, un array de enteros o cualquier otro \hyperlink{982887983034702059}{índice soportado}. Esto incluye \hyperlink{13649361117037263099}{\texttt{Colon}} (\texttt{:}) para seleccionar todos los índices dentro de la dimensión completa, rangos de la forma \texttt{a:c} o \texttt{a:b:c} para seleccionar subsecciones contiguas o con salto, y arrays de booleans para seleccionar elementos en sus índices \texttt{true}.



Si \texttt{X} es un array, debe tener el mismo número de elementos que el producto de las longitudes de los índices \texttt{prod(length(I\_1), length(I\_2), ..., length(I\_n))}. El valor en la localización \texttt{I\_1[i\_1], I\_2[i\_2], ..., I\_n[i\_n]}de \texttt{A} es sobreescrito con el valor \texttt{X[i\_1, i\_2, ..., i\_n]}. Si \texttt{X} no es un array, su valor es escrito a todas las localizaciones referenciadas de \texttt{A}.



Justo como en \hyperlink{14469287548874312017}{Indexación}, la palabra clave \texttt{end} puede utilizarse para representar el último índice de cada dimensión dentro de los corchetes de los índices, como queda determinado por el tamaño del array en el que se está siendo asignado. La sintaxis de la asignación indexada sin la palabra clave \texttt{end} es equivalente a llamar a la función \hyperlink{17903591429492118749}{\texttt{setindex!()}}:




\begin{lstlisting}
setindex!(A, X, I_1, I_2, ..., I_n)
\end{lstlisting}



Ejemplo:




\begin{minted}{jlcon}
julia> x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia> x[1:2, 2:3] = -1
-1

julia> x
3×3 Array{Int64,2}:
 1  -1  -1
 2  -1  -1
 3   6   9
\end{minted}



\hypertarget{982887983034702059}{}


\subsection{Tipos de Índices Soportados}



En la expresión \texttt{A[I\_1, I\_2, ..., I\_n]}, cada \texttt{I\_k} puede ser un índice escalar, un array de índices escalares o un objeto que repreenta un array de índices escalares y puede ser convertido a tal mediante \hyperlink{10027537986402266830}{\texttt{to\_indices}}:



\begin{itemize}
\item[1. ] Un índice escalar. Por defecto esto incluye:

\begin{itemize}
\item Enteros no booleanos

\end{itemize}
\end{itemize}


   * \texttt{CartesianIndex\{N\}}s, que se comportan como una \texttt{N}-tupla de enteros abarcando múltiples dimensiones (ver abajo para ms detalles)



\begin{itemize}
\item[2. ] Un array de índices escalares. Esto incluye:

\begin{itemize}
\item Vectores y arrays multidimensionales de enteros

\end{itemize}
\end{itemize}


   * Arrays vacíos como \texttt{[]}, que no selecciona elementos     * \texttt{Range}s de la forma \texttt{a:c} o \texttt{a:b:c}, que seleccionan subsecciones contiguas o con salto desde \texttt{a} hasta \texttt{c} (inclusive)     * Cualquier array de índices escalares que sea un subtipo de \texttt{AbstractArray}     * Arrays de \texttt{CartesianIndex\{N\}} (ver abajo para ms detalles)



\begin{itemize}
\item[3. ] Un objeto que representa un array de índice escalares y puede ser convertido a tal mediante \hyperlink{10027537986402266830}{\texttt{to\_indices}}. Por defecto esto incluye:

\end{itemize}


   * \hyperlink{13649361117037263099}{\texttt{Colon()}} (\texttt{:}), que representa todos los índices dentro de una dimensión entera o a través del array completo     * Arrays de booleans, que seleccionan los elementos en los que sus índices son \texttt{true} indices (ver abajo para más detalles)



\hypertarget{4655120660876939995}{}


\subsubsection{Índices Cartesianos}



El objeto especial \texttt{CartesianIndex\{N\}} representa un índice escalar que se comporta como una \texttt{N}-tupla de enteros que abarcan multiples dimensioneas. Por ejemplo:




\begin{lstlisting}
julia> A = reshape(1:32, 4, 4, 2);

julia> A[3, 2, 1]
7

julia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true
\end{lstlisting}



Considerado solo, esto puede parecer relativamente trivial; \texttt{CartesianIndex} simplemente reúne múltiples enteros juntos en un objeto que representa un único índice multidimensional. Sin embargo, cuando se combina con otras formas de indexación e iteradores que producen \texttt{CartesianIndex}es, esto puede conducir directamente a un código muy elegante y eficiente. Ver \hyperlink{5510379658285713272}{Iteración} a continuación, y para algunos ejemplos más avanzados, ver \href{https://julialang.org/blog/2016/02/iteration}{esta publicación en el blog sobre algoritmos multidimensionales e iteración}.



Los \emph{arrays} de \texttt{CartesianIndex\{N\}} también sestán soportados. Representan una colección de índices escalares que abarcan   \texttt{N} dimensiones cada uno, lo que permite una forma de indexación que a veces se denomina \emph{indexación puntual}. Por ejemplo, permite acceder a los elementos diagonales desde la primera {\textquotedbl}página{\textquotedbl} de {\textquotesingle}A{\textquotesingle} desde arriba:




\begin{lstlisting}
julia> page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16
\end{lstlisting}



Esto se puede expresar mucho más simplemente con \hyperlink{13590013989415065742}{\emph{dot broadcasting}} y combinándolo con un índice entero normal (en lugar de extraer la primera página de\texttt{A} como un paso separado). Incluso se puede combinar con \texttt{:} para extraer ambas diagonales de las dos páginas al mismo tiempo:




\begin{lstlisting}
julia> A[CartesianIndex.(indices(A, 1), indices(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia> A[CartesianIndex.(indices(A, 1), indices(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32
\end{lstlisting}



\begin{quote}
\textbf{Warning}

\texttt{CartesianIndex} y los arrays de \texttt{CartesianIndex} no son compatibles con la palabra

\end{quote}


   clave \texttt{end} que representa el último índice de una dimensión. No usaremos \texttt{end}     cuando se indexen expresiones que puedan contener \texttt{CartesianIndex} or arrays de ellos.



\hypertarget{15088539231972097937}{}


\subsubsection{Indexación Lógica}



A menudo denominada indexación lógica o indexación con una máscara lógica, la indexación mediante  una matriz booleana selecciona elementos en los índices cuyos valores son \texttt{verdaderos}. La indexación por un vector booleano \texttt{B} es efectivamente igual a la indexación por el vector de enteros que es devuelto por \texttt{find (B)}. De forma similar, la indexación por una matriz booleana \texttt{N}-dimensional es efectivamente igual a la indexación por el vector de \texttt{CartesianIndex\{N\}}s donde sus valores son \texttt{true}. Un índice lógico debe ser un vector de la misma longitud que la dimensión en la que indexa, o debe ser el único índice proporcionado y debe coincidir con el tamaño y la dimensionalidad de la matriz en la que se indexa. En general, es más eficiente usar matrices booleanas como índices directamente en lugar de llamar primero a \hyperlink{13973031941728195278}{\texttt{find()}}.




\begin{minted}{jlcon}
julia> x = reshape(1:16, 4, 4)
4×4 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia> mask = map(ispow2, x)
4×4 Array{Bool,2}:
  true  false  false  false
  true  false  false  false
 false  false  false  false
  true   true  false   true

julia> x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16
\end{minted}



\hypertarget{14266659218850988151}{}


\subsection{Iteración}



Las formas recomendadas de iterar sobre un array completo son:




\begin{minted}{julia}
for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end
\end{minted}



La primera construcción se usa cuando necesitamos el valor, pero no los índices, de cada elemento. En la segunda construcción, \texttt{i} será un \texttt{Int} si \texttt{A} es un tipo array con indexación lineal rápida; en caso contrario será un \texttt{CartesianIndex}:




\begin{minted}{jlcon}
julia> A = rand(4,3);

julia> B = view(A, 1:3, 2:3);

julia> for i in eachindex(B)
           @show i
       end
i = CartesianIndex{2}((1, 1))
i = CartesianIndex{2}((2, 1))
i = CartesianIndex{2}((3, 1))
i = CartesianIndex{2}((1, 2))
i = CartesianIndex{2}((2, 2))
i = CartesianIndex{2}((3, 2))
\end{minted}



En contraste con \texttt{for i = 1:length(A)}, iterar con \texttt{eachindex} proporciona una forma eficiente de iterar sobre cualquier tipo de array.



\hypertarget{2985383153793243157}{}


\subsection{Rasgos de  Array}



Si uno escribe un tipo \hyperlink{6514416309183787338}{\texttt{AbstractArray}} personalizado, uno puede especificar que el tipo tiene indexación lineal rápida usando:




\begin{minted}{julia}
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()
\end{minted}



Esta configuración hará que la iteración \texttt{eachindex} sobre un objeto \texttt{MyArray} use enteros. Si no especifica este rasgo, se usa el valor predeterminado \texttt{IndexCartesian()}.



\hypertarget{3377433517916213965}{}


\subsection{Arrays, Funciones y Operadores Vectorizados}



Los siguientes operadores están soportados para arrays:



\begin{itemize}
\item[1. ] Aritmética unaria – \texttt{-}, \texttt{+}


\item[2. ] Aritmética binaria – \texttt{-}, \texttt{+}, \texttt{*}, \texttt{/}, \texttt{{\textbackslash}}, \texttt{{\textasciicircum}}


\item[3. ] Comparación – \texttt{==}, \texttt{!=}, \texttt{≈} (\hyperlink{12499503887608197213}{\texttt{isapprox}}), \texttt{≉}

\end{itemize}


La mayoría de los operadores aritméticos binarios enumerados anteriormente también funcionan elemento a elemento cuando un argumento es escalar: \texttt{-}, \texttt{+}, y \texttt{*}cuando cualquiera de los argumentos es escalar, y \texttt{/} y \texttt{{\textbackslash}} cuando el denominador es escalar. Por ejemplo, \texttt{[1, 2] + 3 == [4, 5]} y \texttt{[6, 4] / 2 == [3, 2]}.



Además, para permitir una conveniente vectorización de operaciones matemáticas y de otro tipo, Julia \hyperlink{13590013989415065742}{proporciona la sintaxis punto} \texttt{f.(args ...)}, por ejemplo, \texttt{sin.(x)} o \texttt{min.(x, y)}, para operaciones con elementos sobre arrays o mezclas de matrices y escalares (una \hyperlink{6411237952146762090}{Retransmisión (\emph{broadcasting})}); estos tienen la ventaja adicional de {\textquotedbl}fusión{\textquotedbl} en un solo bucle cuando se combina con otras llamadas de puntos, por ejemplo, \texttt{sin.(cos.(x))}



También, \emph{cada} operador binario admite una \hyperlink{6173297391052343261}{versión de punto} que se puede aplicar a matrices (y combinaciones de matrices y escalares) en tales \hyperlink{13590013989415065742}{operaciones de retransmisión fusionadas}, por ejemplo, \texttt{z .== sin.(x. * y)}.



Tenga en cuenta que las comparaciones como \texttt{==} operan en arrays completos, dando un solo booleano como respuesta. Use operadores de punto como \texttt{.==} para comparaciones elemento a elemento. (Para operaciones de comparación como \texttt{<}, \emph{solo} la versión de elementos \texttt{.<} es aplicable a las matrices).



También note la diferencia entre \texttt{max.(a, b)}, que retransmitir \hyperlink{7839419811914289844}{\texttt{max()}} elemento a elemento sobre \texttt{a} y\texttt{b}, y \texttt{maximum(a)}, que encuentra el mayor valor dentro de \texttt{a}. La misma relación se cumple para \texttt{min.(A, b)} y \texttt{minimum(a)}.



\hypertarget{6411237952146762090}{}


\subsection{Retransmisión}



A veces es útil realizar operaciones binarias elemento por elemento en matrices de diferentes tamaños, como agregar un vector a cada columna de una matriz. Una forma ineficiente de hacer esto sería replicar el vector al tamaño de la matriz:




\begin{minted}{jlcon}
julia> a = rand(2,1); A = rand(2,3);

julia> repmat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846
\end{minted}



Esto es un desperdicio cuando las dimensiones son grandes, por lo que Julia ofrece \texttt{broadcast()}, que expande las dimensiones \emph{singleton} en los argumentos array para hacer coincidir la dimensión correspondiente en el otro array sin usar memoria extra, y aplicar la función dada elemento a elemento:




\begin{minted}{jlcon}
julia> broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia> b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia> broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631
\end{minted}



\hyperlink{6173297391052343261}{Los operadores con punto} tales como \texttt{.+} y \texttt{.*} son equivalentes a llamadas a \texttt{broadcast} (excepto que se funden, como se describe a continuación). También hay una función \texttt{broadcast!()} para especificar un destino explícito (al que también se puede acceder por fusión mediante asignación \texttt{.=}), y funciones \hyperlink{5896180186078332739}{\texttt{broadcast\_getindex()}} y \texttt{broadcast\_setindex! ()} que retransmiten los índices antes de indexar. Además, \texttt{f. (Args ...)} es equivalente a \texttt{broadcast(f, args ...)}, proporcionando una sintaxis conveniente para retransmitir cualquier función (\hyperlink{13590013989415065742}{sintaxis punto}). {\textquotedbl}Llamadas punto{\textquotedbl} anidadas \texttt{f.(...)} (incluidas las llamadas a \texttt{.+} Etcétera) \hyperlink{6173297391052343261}{fusibles automáticamente} en una sola llamada \texttt{broadcast}.



Además, \texttt{broadcast ()} no está limitado a los array (ver la documentación de la función), también maneja tuplas y trata cualquier argumento que no sea un array, tupla o \texttt{Ref} (excepto para\texttt{Ptr} ) como un {\textquotedbl}escalar{\textquotedbl}.




\begin{minted}{jlcon}
julia> convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia> ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia> string.(1:3, ". ", ["First", "Second", "Third"])
3-element Array{String,1}:
 "1. First"
 "2. Second"
 "3. Third"
\end{minted}



\hypertarget{612241206445696325}{}


\subsection{Implementation}



El tipo de matriz base en Julia es el tipo abstracto \texttt{AbstractArray \{T, N\}}. Este tipo está parametrizado por el número de dimensiones \texttt{N} y el tipo de elementos \texttt{T}. \texttt{AbstractVector} y \texttt{AbstractMatrix} son aliases para los casos 1-d y 2-d. Las operaciones en los objetos \texttt{AbstractArray} se definen usando operadores y funciones de alto nivel, de  manera que es independiente del almacenamiento subyacente. Estas operaciones generalmente funcionan correctamente como una alternativa para cualquier implementación de matriz específica.



El tipo \texttt{AbstractArray} incluye algo vagamente parecido a un array, y las implementaciones de este podrían ser bastante diferentes de los arrays convencionales. Por ejemplo, los elementos se pueden calcular a petición en lugar de ser almacenados. Sin embargo, cualquier tipo concreto de \texttt{AbstractArray\{T, N\}} debería implementar al menos \hyperlink{17888996102305087038}{\texttt{size(A)}} (que devolvería una tupla \texttt{Int}), \hyperlink{2839226020402435013}{\texttt{getindex(A,i)}} y \hyperlink{2839226020402435013}{\texttt{getindex(A, i1, ..., iN)}}; Los arrays mutables también deberían implementar \hyperlink{17903591429492118749}{\texttt{setindex!()}}. Se recomienda que estas operaciones tengan complejidad temporal casi constante, o técnicamente complejidad de orden 1 (Õ(1)), ya que de lo contrario algunas funciones podrían ser inesperadamente lentas. Los tipos concretos también deberían proporcionar un método \hyperlink{18368531196314541873}{\texttt{similar(A,T=eltype(A),dims=size(A))}}, que se utiliza para asignar un conjunto similar para \hyperlink{15665284441316555522}{\texttt{copy()}} y otras operaciones de actualización. No importa cómo se represente internamente un \texttt{AbstractArray \{T, N\}}, \texttt{T} es el tipo de objeto devuelto por la indización entera (\texttt{A [1, ..., 1]}, cuando \texttt{A} no está vacío) y\texttt{N} debe ser la longitud de la tupla devuelta por \hyperlink{17888996102305087038}{\texttt{size()}}.



\texttt{DenseArray} es un subtipo abstracto de\texttt{AbstractArray} que pretende incluir todos los arrays que están establecidos en bloques regulares de memoria y que, por tanto, se puede pasar a funciones externas C y Fortran que esperan este diseño de memoria. Los subtipos deberían proporcionar un método \hyperlink{97811245619734938}{\texttt{stride(A,k)}} que devuelve el {\textquotedbl}paso{\textquotedbl} de la dimensión \texttt{k}; incrementar el índice de dimensión \texttt{k} en \texttt{1} debería incremental el índice \texttt{i} de \hyperlink{2839226020402435013}{\texttt{getindex(A,i)}} en \hyperlink{97811245619734938}{\texttt{stride(A,k)}}. Si se proporciona un método de conversión de puntero \hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert(Ptr\{T\}, A)}}, el diseño de la memoria debe corresponder de la misma manera a estos pasos.



El tipo \hyperlink{15492651498431872487}{\texttt{Array}} es una instancia específica de \texttt{DenseArray} donde los elementos se almacenan en orden de columnas principales (consulte notas adicionales en \hyperlink{3908315974291496321}{Sugerencias de rendimiento}). \texttt{Vector} y \texttt{Matrix} son alias para los casos 1-d y 2-d. Las operaciones específicas como la indexación escalar, la asignación y algunas otras operaciones básicas específicas del almacenamiento son todas las que tienen que estar implementadas en  \hyperlink{15492651498431872487}{\texttt{Array}}, de modo que el resto de la biblioteca de arrays puede implementarse de forma genérica.



\texttt{SubArray} es una especialización de \texttt{AbstractArray} que realiza indexación por referencia en lugar de por copia. Un \texttt{SubArray} se crea con la función \hyperlink{4861450464669906845}{\texttt{view()}}, que es llamada de la misma manera que \hyperlink{2839226020402435013}{\texttt{getindex()}} (con una matriz y una serie de argumentos de índice) . El resultado de \hyperlink{4861450464669906845}{\texttt{view()}} se ve igual que el resultado de \hyperlink{2839226020402435013}{\texttt{getindex()}}, excepto que los datos se dejan en su lugar. \hyperlink{4861450464669906845}{\texttt{view()}} almacena los vectores de índice de entrada en un objeto \texttt{SubArray}, que luego puede usarse para indexar la matriz original de forma indirecta. Al colocar la macro \hyperlink{4544474300423667148}{\texttt{@views}} delante de una expresión o bloque de código, cualquier segmento \texttt{array[...]} en esa expresión se convertirá para crear una vista \texttt{SubArray} en su lugar.



\texttt{StridedVector} y\texttt{StridedMatrix} son alias convenientes definidos para que Julia pueda llamar a un rango más amplio de funciones BLAS y LAPACK pasándoles objetos \hyperlink{15492651498431872487}{\texttt{Array}} o \texttt{SubArray}, y ahorrando así ineficiencias de asignación de memoria y copia.



El siguiente ejemplo calcula la descomposición QR de una pequeña sección de una matriz más grande, sin crear ningún array temporal, y llamando a la función LAPACK apropiada con los parámetros de tamaño de dimensión y salto correctos.




\begin{minted}{jlcon}
julia> a = rand(10,10)
10×10 Array{Float64,2}:
 0.561255   0.226678   0.203391  0.308912   …  0.750307  0.235023   0.217964
 0.718915   0.537192   0.556946  0.996234      0.666232  0.509423   0.660788
 0.493501   0.0565622  0.118392  0.493498      0.262048  0.940693   0.252965
 0.0470779  0.736979   0.264822  0.228787      0.161441  0.897023   0.567641
 0.343935   0.32327    0.795673  0.452242      0.468819  0.628507   0.511528
 0.935597   0.991511   0.571297  0.74485    …  0.84589   0.178834   0.284413
 0.160706   0.672252   0.133158  0.65554       0.371826  0.770628   0.0531208
 0.306617   0.836126   0.301198  0.0224702     0.39344   0.0370205  0.536062
 0.890947   0.168877   0.32002   0.486136      0.096078  0.172048   0.77672
 0.507762   0.573567   0.220124  0.165816      0.211049  0.433277   0.539476

julia> b = view(a, 2:2:8,2:2:4)
4×2 SubArray{Float64,2,Array{Float64,2},Tuple{StepRange{Int64,Int64},StepRange{Int64,Int64}},false}:
 0.537192  0.996234
 0.736979  0.228787
 0.991511  0.74485
 0.836126  0.0224702

julia> (q,r) = qr(b);

julia> q
4×2 Array{Float64,2}:
 -0.338809   0.78934
 -0.464815  -0.230274
 -0.625349   0.194538
 -0.527347  -0.534856

julia> r
2×2 Array{Float64,2}:
 -1.58553  -0.921517
  0.0       0.866567
\end{minted}



\hypertarget{15616629732727427304}{}


\section{Vectores y Matrices \emph{Sparse}}



Julia tiene soporte integrado para vectores y \href{https://en.wikipedia.org/wiki/Sparse\_matrix}{matrices dispersas (\emph{sparse})}. Las matrices \emph{sparse} son matrices que contienen suficientes ceros para almacenarlos en una estructura de datos especial que ahorra espacio y tiempo de ejecución, en comparación con las matrices densas.



\hypertarget{4438718230137239554}{}


\subsection{Columna Comprimida \emph{Sparse} (CSC) Para Almacenamiento de Matrices \emph{Sparse}}



En Julia, las matrices dispersas se almacenan en el formato \href{https://en.wikipedia.org/wiki/Sparse\_matrix\#Compressed\_sparse\_column\_.28CSC\_or\_CCS.29}{Compressed Sparse Column (CSC)}. Las matrices \emph{sparse} de Julia tienen el tipo \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC\{Tv,Ti\}}}, donde \texttt{Tv} es el tipo de los valores almacenados, y\texttt{Ti} es el tipo entero para almacenar punteros de columnas e índices de filas. La representación interna de \texttt{SparseMatrixCSC} es la siguiente:




\begin{minted}{julia}
struct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}
    m::Int                  # Number of rows
    n::Int                  # Number of columns
    colptr::Vector{Ti}      # Column i is in colptr[i]:(colptr[i+1]-1)
    rowval::Vector{Ti}      # Row indices of stored values
    nzval::Vector{Tv}       # Stored values, typically nonzeros
end
\end{minted}



El almacenamiento de columnas dispersas y comprimidas (CSC) facilita y agiliza el acceso a los elementos en la columna de una matriz \emph{sparse}, mientras que el acceso a la matriz \emph{sparse} por filas es considerablemente más lento. Las operaciones como la inserción de entradas previamente no almacenadas de una en una en la estructura de CSC tienden a ser lentas. Esto se debe a que todos los elementos de la matriz \emph{sparse} que están más allá del punto de inserción deben moverse un lugar más.



Todas las operaciones en matrices \emph{sparse} se implementan cuidadosamente para aprovechar la estructura de datos CSC para el rendimiento y para evitar operaciones costosas.



Si tiene datos en formato CSC desde una aplicación o biblioteca diferente, y desea importarlos a Julia, asegúrese de utilizar la indexación basada en 1. Los índices de fila en cada columna deben estar ordenados. Si su objeto \texttt{SparseMatrixCSC} contiene índices de filas sin ordenar, una forma rápida de ordenarlos es hacer una doble transposición.



En algunas aplicaciones, es conveniente almacenar valores cero explícitos en una \texttt{SparseMatrixCSC}. Estas \emph{son} aceptadas por funciones en \texttt{Base} (pero no hay garantía de que se conservarán en las operaciones de mutación). Tales ceros explícitamente almacenados son tratados como no estructurales por muchas rutinas. La función \hyperlink{6318543341724753931}{\texttt{nnz()}} devuelve la cantidad de elementos almacenados explícitamente en la estructura de datos dispersos, incluidos los no-ceros estructurales. Para contar el número exacto de nozeros numéricos, use \hyperlink{14756260737478660234}{\texttt{countnz()}}, que inspecciona todos los elementos almacenados en un a matriz \emph{sparse}. \hyperlink{16980472205632865276}{\texttt{dropzeros()}}, y \hyperlink{4343590179532251994}{\texttt{dropzeros!()}}, se puede usar para eliminar ceros almacenados de la matriz dispersa.




\begin{minted}{jlcon}
julia> A = sparse([1, 2, 3], [1, 2, 3], [0, 2, 0])
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  0
  [2, 2]  =  2
  [3, 3]  =  0

julia> dropzeros(A)
3×3 SparseMatrixCSC{Int64,Int64} with 1 stored entry:
  [2, 2]  =  2
\end{minted}



\hypertarget{11978256442297483077}{}


\subsection{Almacenamiento de Vectores \emph{Sparse}}



Los vectores \emph{sparse} se almacenan en un formato de columna análogo al que se usa en las matrices \emph{sparse}. En Julia, los vectores \emph{sparse} tienen el tipo \hyperlink{17278185509996384677}{\texttt{SparseVector\{Tv,Ti\}}} donde \texttt{Tv} es el tipo de los valores almacenados y\texttt{Ti} el tipo entero para los índices. La representación interna es la siguiente:




\begin{minted}{julia}
struct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}
    n::Int              # Length of the sparse vector
    nzind::Vector{Ti}   # Indices of stored values
    nzval::Vector{Tv}   # Stored values, typically nonzeros
end
\end{minted}



En cuanto a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}}, el tipo \texttt{SparseVector} también puede contener ceros almacenados explícitamente. (Consulte \hyperlink{4438718230137239554}{Almacenamiento de matriz \emph{sparse}}.).



\hypertarget{14573726910211075461}{}


\subsection{Constructores de Vectores y Matrices \emph{Sparse}}



La forma más sencilla de crear matrices \emph{sparse} es usar funciones equivalentes a las funciones \hyperlink{13837674686090348619}{\texttt{zeros()}} y \hyperlink{245874853049830800}{\texttt{eye()}} que proporciona Julia para trabajar con matrices densas. Para producir matrices \emph{sparse} en su lugar, puede usar los mismos nombres con el prefijo \texttt{sp}:




\begin{minted}{jlcon}
julia> spzeros(3)
3-element SparseVector{Float64,Int64} with 0 stored entries

julia> speye(3,5)
3×5 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
\end{minted}



La función \hyperlink{6442735913986985800}{\texttt{sparse()}} suele ser una forma útil de construir arrays \emph{sparse}. Por ejemplo, para construir una matriz \emph{sparse}, podemos ingresar un vector \texttt{I} de índices de fila, un vector\texttt{J} de índices de columna, y un vector \texttt{V} de valores almacenados (esto también se conoce como \href{https://en.wikipedia.org/wiki/Sparse\_matrix\#Coordinate\_list\_.28COO.29}{formato COO (coordenada)}). \texttt{sparse (I,J,V)} construye una matriz \emph{sparse} tal que \texttt{S[I[k], J[k]] = V[k]}. El constructor de vector \emph{sparse} equivalente es \hyperlink{18161940743946340171}{\texttt{sparsevec}}, que toma el vector de índices (fila) \texttt{I} y el vector \texttt{V} con los valores almacenados y construye un vector \emph{sparse} \texttt{R} tal que \texttt{R[I[k]] = V[k]}.




\begin{lstlisting}
julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia> S = sparse(I,J,V)
5×18 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1 ,  4]  =  1
  [4 ,  7]  =  2
  [5 ,  9]  =  3
  [3 , 18]  =  -5

julia> R = sparsevec(I,V)
5-element SparseVector{Int64,Int64} with 4 stored entries:
  [1]  =  1
  [3]  =  -5
  [4]  =  2
  [5]  =  3
\end{lstlisting}



La inversa de las funciones \hyperlink{6442735913986985800}{\texttt{sparse()}} y \hyperlink{18161940743946340171}{\texttt{sparsevec}} es \hyperlink{10811968090686169507}{\texttt{findnz()}}, que recupera las entradas utilizadas para crear el array \emph{sparse}. También hay una función \hyperlink{7762671957301951450}{\texttt{findn}} que solo devuelve los vectores índice.




\begin{lstlisting}
julia> findnz(S)
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia> findn(S)
([1, 4, 5, 3], [4, 7, 9, 18])

julia> findnz(R)
([1, 3, 4, 5], [1, -5, 2, 3])

julia> findn(R)
4-element Array{Int64,1}:
 1
 3
 4
 5
\end{lstlisting}



Otra forma de crear un array \emph{sparse} es convertir un array denso en un array \emph{sparse} usando la función \hyperlink{6442735913986985800}{\texttt{sparse()}}:




\begin{minted}{jlcon}
julia> sparse(eye(5))
5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  1.0
  [5, 5]  =  1.0

julia> sparse([1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0
\end{minted}



Puede ir en la otra dirección usando el constructor \hyperlink{15492651498431872487}{\texttt{Array}}. La función \hyperlink{4718940244439103334}{\texttt{issparse()}} se puede usar para consultar si una matriz es o no \emph{sparse}.




\begin{minted}{jlcon}
julia> issparse(speye(5))
true
\end{minted}



\hypertarget{17281408938920196874}{}


\subsection{Operaciones con matrices \emph{sparse}}



Las operaciones aritméticas en matrices \emph{sparse} también funcionan como lo hacen en matrices densas. La indexación de, la asignación en y la concatenación de matrices \emph{sparse} funcionan de la misma manera que las matrices densas. Las operaciones de indexación, especialmente la asignación, son costosas, cuando se llevan a cabo un elemento cada vez. En muchos casos, puede ser mejor convertir la matriz dispersa en formato \texttt{(I,J,V)} usando \hyperlink{10811968090686169507}{\texttt{findnz()}}, manipular los valores o la estructura en los vectores densos \texttt{(I,J,V)}, y luego reconstruir la matriz \emph{sparse}.



\hypertarget{3328350436064607795}{}


\subsection{Correspondence of dense and sparse methods}



La siguiente tabla proporciona una correspondencia entre los métodos incorporados en matrices \emph{sparse} y sus métodos correspondientes en tipos de matrices densas. En general, los métodos que generan matrices \emph{sparse} difieren de sus contrapartes densas en que la matriz resultante sigue el mismo patrón de dispersión que una matriz \emph{sparse} dada \texttt{S}, o que la matriz \emph{sparse} resultante tiene densidad \texttt{d}, es decir, cada elemento de matriz tiene una probabilidad \texttt{d} de ser diferente de cero.



Los detalles se pueden encontrar en la sección \hyperlink{2402954669804328212}{Vectores y Matrices \emph{Sparse}} de la referencia de biblioteca estándar.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Sparse & Dense & Description \\
\hline
\hyperlink{7195216781795987163}{\texttt{spzeros(m,n)}} & \hyperlink{13837674686090348619}{\texttt{zeros(m,n)}} & Creates a \emph{m}-by-\emph{n} matrix of zeros. (\hyperlink{7195216781795987163}{\texttt{spzeros(m,n)}} is empty.) \\
\hline
\hyperlink{8792030753977135320}{\texttt{spones(S)}} & \hyperlink{5858390260510292771}{\texttt{ones(m,n)}} & Creates a matrix filled with ones. Unlike the dense version, \hyperlink{8792030753977135320}{\texttt{spones()}} has the same sparsity pattern as \emph{S}. \\
\hline
\hyperlink{15336931858862742282}{\texttt{speye(n)}} & \hyperlink{245874853049830800}{\texttt{eye(n)}} & Creates a \emph{n}-by-\emph{n} identity matrix. \\
\hline
\hyperlink{6442668105237896007}{\texttt{full(S)}} & \hyperlink{6442735913986985800}{\texttt{sparse(A)}} & Interconverts between dense and sparse formats. \\
\hline
\hyperlink{7938626005548874744}{\texttt{sprand(m,n,d)}} & \hyperlink{791894090820620170}{\texttt{rand(m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed uniformly on the half-open interval \([0, 1)\). \\
\hline
\hyperlink{641245889672681934}{\texttt{sprandn(m,n,d)}} & \hyperlink{8153706463199753760}{\texttt{randn(m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution. \\
\hline
\hyperlink{641245889672681934}{\texttt{sprandn(m,n,d,X)}} & \hyperlink{8153706463199753760}{\texttt{randn(m,n,X)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed according to the \emph{X} distribution. (Requires the \texttt{Distributions} package.) \\
\hline
\end{tabulary}

\end{table}



\hypertarget{11547352483373884762}{}


\chapter{Linear algebra}



In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations. Basic operations, such as \hyperlink{4723994450949629907}{\texttt{trace}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{9013378623280719296}{\texttt{inv}} are all supported:




\begin{minted}{jlcon}
julia> A = [1 2 3; 4 1 6; 7 8 1]
3×3 Array{Int64,2}:
 1  2  3
 4  1  6
 7  8  1

julia> trace(A)
3

julia> det(A)
104.0

julia> inv(A)
3×3 Array{Float64,2}:
 -0.451923   0.211538    0.0865385
  0.365385  -0.192308    0.0576923
  0.240385   0.0576923  -0.0673077
\end{minted}



As well as other useful operations, such as finding eigenvalues or eigenvectors:




\begin{minted}{jlcon}
julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia> eigvals(A)
3-element Array{Complex{Float64},1}:
  9.31908+0.0im
 -2.40954+2.72095im
 -2.40954-2.72095im

julia> eigvecs(A)
3×3 Array{Complex{Float64},2}:
 -0.488645+0.0im  0.182546-0.39813im   0.182546+0.39813im
 -0.540358+0.0im  0.692926+0.0im       0.692926-0.0im
   0.68501+0.0im  0.254058-0.513301im  0.254058+0.513301im
\end{minted}



In addition, Julia provides many \hyperlink{12615392115882150758}{factorizations} which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on \hyperlink{10363263068585650380}{\texttt{factorize}} for more information. As an example:




\begin{minted}{jlcon}
julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia> factorize(A)
Base.LinAlg.LU{Float64,Array{Float64,2}} with factors L and U:
[1.0 0.0 0.0; -0.15 1.0 0.0; -0.3 -0.132196 1.0]
[-10.0 2.3 4.0; 0.0 2.345 -3.4; 0.0 0.0 -5.24947]
\end{minted}



Since \texttt{A} is not Hermitian, symmetric, triangular, tridiagonal, or bidiagonal, an LU factorization may be the best we can do. Compare with:




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> factorize(B)
Base.LinAlg.BunchKaufman{Float64,Array{Float64,2}}([-1.64286 0.142857 -0.8; 2.0 -2.8 -0.6; -4.0 -3.0 5.0], [1, 2, 3], 'U', true, false, 0)
\end{minted}



Here, Julia was able to detect that \texttt{B} is in fact symmetric, and used a more appropriate factorization. Often it{\textquotesingle}s possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can {\textquotedbl}tag{\textquotedbl} matrices as having these properties. For instance:




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0
\end{minted}



\texttt{sB} has been tagged as a matrix that{\textquotesingle}s (real) symmetric, so for later operations we might perform on it, such as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half of it. For example:




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> x = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> sB\x
3-element Array{Float64,1}:
 -1.73913
 -1.1087
 -1.45652
\end{minted}



The \texttt{{\textbackslash}} operation here performs the linear solution. Julia{\textquotesingle}s parser provides convenient dispatch to specialized methods for the \emph{transpose} of a matrix left-divided by a vector, or for the various combinations of transpose operations in matrix-matrix solutions. Many of these are further specialized for certain special matrix types. For example, \texttt{A{\textbackslash}B} will end up calling \hyperlink{16784809286794154433}{\texttt{Base.LinAlg.A\_ldiv\_B!}} while \texttt{A{\textquotesingle}{\textbackslash}B} will end up calling \hyperlink{9966202373988898888}{\texttt{Base.LinAlg.Ac\_ldiv\_B}}, even though we used the same left-division operator. This works for matrices too: \texttt{A.{\textquotesingle}{\textbackslash}B.{\textquotesingle}} would call \hyperlink{13563153742436501281}{\texttt{Base.LinAlg.At\_ldiv\_Bt}}. The left-division operator is pretty powerful and it{\textquotesingle}s easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.



\hypertarget{17886925214388874704}{}


\section{Special matrices}



\href{http://www2.imm.dtu.dk/pubdb/views/publication\_details.php?id=3274}{Matrices with special symmetries and structures} arise often in linear algebra and are frequently associated with various matrix factorizations. Julia features a rich collection of special matrix types, which allow for fast computation with specialized routines that are specially developed for particular matrix types.



The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Type & Description \\
\hline
\hyperlink{11943711269274284831}{\texttt{Hermitian}} & \href{https://en.wikipedia.org/wiki/Hermitian\_matrix}{Hermitian matrix} \\
\hline
\hyperlink{1757421215459158076}{\texttt{UpperTriangular}} & Upper \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{triangular matrix} \\
\hline
\hyperlink{17017578003271911360}{\texttt{LowerTriangular}} & Lower \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{triangular matrix} \\
\hline
\hyperlink{10627817666628508033}{\texttt{Tridiagonal}} & \href{https://en.wikipedia.org/wiki/Tridiagonal\_matrix}{Tridiagonal matrix} \\
\hline
\hyperlink{14121197223449931750}{\texttt{SymTridiagonal}} & Symmetric tridiagonal matrix \\
\hline
\hyperlink{3712437588055447942}{\texttt{Bidiagonal}} & Upper/lower \href{https://en.wikipedia.org/wiki/Bidiagonal\_matrix}{bidiagonal matrix} \\
\hline
\hyperlink{14932727513503167130}{\texttt{Diagonal}} & \href{https://en.wikipedia.org/wiki/Diagonal\_matrix}{Diagonal matrix} \\
\hline
\texttt{UniformScaling} & \href{https://en.wikipedia.org/wiki/Uniform\_scaling}{Uniform scaling operator} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{17944625623829928397}{}


\subsection{Elementary operations}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
Matrix type & \texttt{+} & \texttt{-} & \texttt{*} & \texttt{{\textbackslash}} & Other functions with optimized methods \\
\hline
\hyperlink{11943711269274284831}{\texttt{Hermitian}} &   &   &   & MV & \hyperlink{9013378623280719296}{\texttt{inv()}}, \hyperlink{16982789562347489346}{\texttt{sqrtm()}}, \hyperlink{13066189226307440587}{\texttt{expm()}} \\
\hline
\hyperlink{1757421215459158076}{\texttt{UpperTriangular}} &   &   & MV & MV & \hyperlink{9013378623280719296}{\texttt{inv()}}, \hyperlink{1300265042345987014}{\texttt{det()}} \\
\hline
\hyperlink{17017578003271911360}{\texttt{LowerTriangular}} &   &   & MV & MV & \hyperlink{9013378623280719296}{\texttt{inv()}}, \hyperlink{1300265042345987014}{\texttt{det()}} \\
\hline
\hyperlink{14121197223449931750}{\texttt{SymTridiagonal}} & M & M & MS & MV & \hyperlink{2002481541828933425}{\texttt{eigmax()}}, \hyperlink{3000514364430926525}{\texttt{eigmin()}} \\
\hline
\hyperlink{10627817666628508033}{\texttt{Tridiagonal}} & M & M & MS & MV &   \\
\hline
\hyperlink{3712437588055447942}{\texttt{Bidiagonal}} & M & M & MS & MV &   \\
\hline
\hyperlink{14932727513503167130}{\texttt{Diagonal}} & M & M & MV & MV & \hyperlink{9013378623280719296}{\texttt{inv()}}, \hyperlink{1300265042345987014}{\texttt{det()}}, \hyperlink{6649271058375699908}{\texttt{logdet()}}, \hyperlink{4103478871488785445}{\texttt{/()}} \\
\hline
\texttt{UniformScaling} & M & M & MVS & MVS & \hyperlink{4103478871488785445}{\texttt{/()}} \\
\hline
\end{tabulary}

\end{table}



Legend:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Key & Description \\
\hline
M (matrix) & An optimized method for matrix-matrix operations is available \\
\hline
V (vector) & An optimized method for matrix-vector operations is available \\
\hline
S (scalar) & An optimized method for matrix-scalar operations is available \\
\hline
\end{tabulary}

\end{table}



\hypertarget{9743537278285582026}{}


\subsection{Matrix factorizations}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|}
\hline
Matrix type & LAPACK & \hyperlink{14864609220164435086}{\texttt{eig()}} & \hyperlink{3176364577236723896}{\texttt{eigvals()}} & \hyperlink{13341009863130381110}{\texttt{eigvecs()}} & \hyperlink{14775973623414930183}{\texttt{svd()}} & \hyperlink{15097149969632009300}{\texttt{svdvals()}} \\
\hline
\hyperlink{11943711269274284831}{\texttt{Hermitian}} & HE &   & ARI &   &   &   \\
\hline
\hyperlink{1757421215459158076}{\texttt{UpperTriangular}} & TR & A & A & A &   &   \\
\hline
\hyperlink{17017578003271911360}{\texttt{LowerTriangular}} & TR & A & A & A &   &   \\
\hline
\hyperlink{14121197223449931750}{\texttt{SymTridiagonal}} & ST & A & ARI & AV &   &   \\
\hline
\hyperlink{10627817666628508033}{\texttt{Tridiagonal}} & GT &   &   &   &   &   \\
\hline
\hyperlink{3712437588055447942}{\texttt{Bidiagonal}} & BD &   &   &   & A & A \\
\hline
\hyperlink{14932727513503167130}{\texttt{Diagonal}} & DI &   & A &   &   &   \\
\hline
\end{tabulary}

\end{table}



Legend:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Key & Description & Example \\
\hline
A (all) & An optimized method to find all the characteristic values and/or vectors is available & e.g. \texttt{eigvals(M)} \\
\hline
R (range) & An optimized method to find the \texttt{il}th through the \texttt{ih}th characteristic values are available & \texttt{eigvals(M, il, ih)} \\
\hline
I (interval) & An optimized method to find the characteristic values in the interval [\texttt{vl}, \texttt{vh}] is available & \texttt{eigvals(M, vl, vh)} \\
\hline
V (vectors) & An optimized method to find the characteristic vectors corresponding to the characteristic values \texttt{x=[x1, x2,...]} is available & \texttt{eigvecs(M, x)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{8735142158345502219}{}


\subsection{The uniform scaling operator}



A \texttt{UniformScaling} operator represents a scalar times the identity operator, \texttt{λ*I}. The identity operator  \texttt{I} is defined as a constant and is an instance of \texttt{UniformScaling}. The size of these operators are generic and match the other matrix in the binary operations \hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{8486205126068439173}{\texttt{*}} and \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}. For \texttt{A+I} and \texttt{A-I} this means that \texttt{A} must be square. Multiplication with the identity operator \texttt{I} is a noop (except for checking that the scaling factor is one) and therefore almost without overhead.



\hypertarget{12615392115882150758}{}


\section{Matrix factorizations}



\href{https://en.wikipedia.org/wiki/Matrix\_decomposition}{Matrix factorizations (a.k.a. matrix decompositions)} compute the factorization of a matrix into a product of matrices, and are one of the central concepts in linear algebra.



The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the \hyperlink{2892037563719910727}{Linear Algebra} section of the standard library documentation.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Type & Description \\
\hline
\texttt{Cholesky} & \href{https://en.wikipedia.org/wiki/Cholesky\_decomposition}{Cholesky factorization} \\
\hline
\texttt{CholeskyPivoted} & \href{https://en.wikipedia.org/wiki/Pivot\_element}{Pivoted} Cholesky factorization \\
\hline
\texttt{LU} & \href{https://en.wikipedia.org/wiki/LU\_decomposition}{LU factorization} \\
\hline
\texttt{LUTridiagonal} & LU factorization for \hyperlink{10627817666628508033}{\texttt{Tridiagonal}} matrices \\
\hline
\texttt{UmfpackLU} & LU factorization for sparse matrices (computed by UMFPack) \\
\hline
\texttt{QR} & \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} \\
\hline
\texttt{QRCompactWY} & Compact WY form of the QR factorization \\
\hline
\texttt{QRPivoted} & Pivoted \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} \\
\hline
\texttt{Hessenberg} & \href{http://mathworld.wolfram.com/HessenbergDecomposition.html}{Hessenberg decomposition} \\
\hline
\texttt{Eigen} & \href{https://en.wikipedia.org/wiki/Eigendecomposition\_(matrix)}{Spectral decomposition} \\
\hline
\texttt{SVD} & \href{https://en.wikipedia.org/wiki/Singular\_value\_decomposition}{Singular value decomposition} \\
\hline
\texttt{GeneralizedSVD} & \href{https://en.wikipedia.org/wiki/Generalized\_singular\_value\_decomposition\#Higher\_order\_version}{Generalized SVD} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12120385195625176605}{}


\chapter{Networking and Streams}



Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (\hyperlink{15038256797533490288}{coroutine}) functionality.



\hypertarget{3895262063332236083}{}


\section{Basic Stream I/O}



All Julia streams expose at least a \hyperlink{8104134490906192097}{\texttt{read()}} and a \hyperlink{16947913578760238729}{\texttt{write()}} method, taking the stream as their first argument, e.g.:




\begin{minted}{jlcon}
julia> write(STDOUT,"Hello World");  # suppress return value 11 with ;
Hello World
julia> read(STDIN,Char)

'\n': ASCII/Unicode U+000a (category Cc: Other, control)
\end{minted}



Note that \hyperlink{16947913578760238729}{\texttt{write()}} returns 11, the number of bytes (in \texttt{{\textquotedbl}Hello World{\textquotedbl}}) written to \hyperlink{2784333101804678420}{\texttt{STDOUT}}, but this return value is suppressed with the \texttt{;}.



Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, \hyperlink{16947913578760238729}{\texttt{write()}} takes the data to write as its second argument, while \hyperlink{8104134490906192097}{\texttt{read()}} takes the type of the data to be read as the second argument.



For example, to read a simple byte array, we could do:




\begin{minted}{jlcon}
julia> x = zeros(UInt8, 4)
4-element Array{UInt8,1}:
 0x00
 0x00
 0x00
 0x00

julia> read!(STDIN, x)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64
\end{minted}



However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:




\begin{minted}{jlcon}
julia> read(STDIN,4)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64
\end{minted}



or if we had wanted to read the entire line instead:




\begin{minted}{jlcon}
julia> readline(STDIN)
abcd
"abcd"
\end{minted}



Note that depending on your terminal settings, your TTY may be line buffered and might thus require an additional enter before the data is sent to Julia.



To read every line from \hyperlink{13806523663202420575}{\texttt{STDIN}} you can use \hyperlink{3474649815265066504}{\texttt{eachline()}}:




\begin{minted}{julia}
for line in eachline(STDIN)
    print("Found $line")
end
\end{minted}



or \hyperlink{8104134490906192097}{\texttt{read()}} if you wanted to read by character instead:




\begin{minted}{julia}
while !eof(STDIN)
    x = read(STDIN, Char)
    println("Found: $x")
end
\end{minted}



\hypertarget{14698673630421811997}{}


\section{Text I/O}



Note that the \hyperlink{16947913578760238729}{\texttt{write()}} method mentioned above operates on binary streams. In particular, values do not get converted to any canonical text representation but are written out as is:




\begin{minted}{jlcon}
julia> write(STDOUT,0x61);  # suppress return value 1 with ;
a
\end{minted}



Note that \texttt{a} is written to \hyperlink{2784333101804678420}{\texttt{STDOUT}} by the \hyperlink{16947913578760238729}{\texttt{write()}} function and that the returned value is \texttt{1} (since \texttt{0x61} is one byte).



For text I/O, use the \hyperlink{8248717042415202230}{\texttt{print()}} or \hyperlink{14071376285304310153}{\texttt{show()}} methods, depending on your needs (see the standard library reference for a detailed discussion of the difference between the two):




\begin{minted}{jlcon}
julia> print(STDOUT, 0x61)
97
\end{minted}



\hypertarget{17657270292090685253}{}


\section{IO Output Contextual Properties}



Sometimes IO output can benefit from the ability to pass contextual information into show methods. The \hyperlink{13454403377667762339}{\texttt{IOContext}} object provides this framework for associating arbitrary metadata with an IO object. For example, \hyperlink{5384438952883464143}{\texttt{showcompact}} adds a hinting parameter to the IO object that the invoked show method should print a shorter output (if applicable).



\hypertarget{15055859070673990183}{}


\section{Working with Files}



Like many other environments, Julia has an \hyperlink{300818094931158296}{\texttt{open()}} function, which takes a filename and returns an \texttt{IOStream} object that you can use to read and write things from the file. For example if we have a file, \texttt{hello.txt}, whose contents are \texttt{Hello, World!}:




\begin{minted}{jlcon}
julia> f = open("hello.txt")
IOStream(<file hello.txt>)

julia> readlines(f)
1-element Array{String,1}:
 "Hello, World!"
\end{minted}



If you want to write to a file, you can open it with the write (\texttt{{\textquotedbl}w{\textquotedbl}}) flag:




\begin{minted}{jlcon}
julia> f = open("hello.txt","w")
IOStream(<file hello.txt>)

julia> write(f,"Hello again.")
12
\end{minted}



If you examine the contents of \texttt{hello.txt} at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the \texttt{IOStream} must be closed before the write is actually flushed to disk:




\begin{minted}{jlcon}
julia> close(f)
\end{minted}



Examining \texttt{hello.txt} again will show its contents have been changed.



Opening a file, doing something to its contents, and closing it again is a very common pattern. To make this easier, there exists another invocation of \hyperlink{300818094931158296}{\texttt{open()}} which takes a function as its first argument and filename as its second, opens the file, calls the function with the file as an argument, and then closes it again. For example, given a function:




\begin{minted}{julia}
function read_and_capitalize(f::IOStream)
    return uppercase(readstring(f))
end
\end{minted}



You can call:




\begin{minted}{jlcon}
julia> open(read_and_capitalize, "hello.txt")
"HELLO AGAIN."
\end{minted}



to open \texttt{hello.txt}, call \texttt{read\_and\_capitalize on it}, close \texttt{hello.txt} and return the capitalized contents.



To avoid even having to define a named function, you can use the \texttt{do} syntax, which creates an anonymous function on the fly:




\begin{minted}{jlcon}
julia> open("hello.txt") do f
           uppercase(readstring(f))
       end
"HELLO AGAIN."
\end{minted}



\hypertarget{16212538065755518733}{}


\section{A simple TCP example}



Let{\textquotesingle}s jump right in with a simple example involving TCP sockets. Let{\textquotesingle}s first create a simple server:




\begin{minted}{jlcon}
julia> @async begin
           server = listen(2000)
           while true
               sock = accept(server)
               println("Hello World\n")
           end
       end
Task (runnable) @0x00007fd31dc11ae0
\end{minted}



To those familiar with the Unix socket API, the method names will feel familiar, though their usage is somewhat simpler than the raw Unix socket API. The first call to \hyperlink{10380677384505520251}{\texttt{listen()}} will create a server waiting for incoming connections on the specified port (2000) in this case. The same function may also be used to create various other kinds of servers:




\begin{minted}{jlcon}
julia> listen(2000) # Listens on localhost:2000 (IPv4)
TCPServer(active)

julia> listen(ip"127.0.0.1",2000) # Equivalent to the first
TCPServer(active)

julia> listen(ip"::1",2000) # Listens on localhost:2000 (IPv6)
TCPServer(active)

julia> listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces
TCPServer(active)

julia> listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces
TCPServer(active)

julia> listen("testsocket") # Listens on a UNIX domain socket/named pipe
PipeServer(active)
\end{minted}



Note that the return type of the last invocation is different. This is because this server does not listen on TCP, but rather on a named pipe (Windows) or UNIX domain socket. The difference is subtle and has to do with the \hyperlink{7162820662735004343}{\texttt{accept()}} and \hyperlink{9152037818560122293}{\texttt{connect()}} methods. The \hyperlink{7162820662735004343}{\texttt{accept()}} method retrieves a connection to the client that is connecting on the server we just created, while the \hyperlink{9152037818560122293}{\texttt{connect()}} function connects to a server using the specified method. The \hyperlink{9152037818560122293}{\texttt{connect()}} function takes the same arguments as \hyperlink{10380677384505520251}{\texttt{listen()}}, so, assuming the environment (i.e. host, cwd, etc.) is the same you should be able to pass the same arguments to \hyperlink{9152037818560122293}{\texttt{connect()}} as you did to listen to establish the connection. So let{\textquotesingle}s try that out (after having created the server above):




\begin{minted}{jlcon}
julia> connect(2000)
TCPSocket(open, 0 bytes waiting)

julia> Hello World
\end{minted}



As expected we saw {\textquotedbl}Hello World{\textquotedbl} printed. So, let{\textquotesingle}s actually analyze what happened behind the scenes. When we called \hyperlink{9152037818560122293}{\texttt{connect()}}, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints {\textquotedbl}Hello World{\textquotedbl} to indicate that the connection was successful.



A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn{\textquotesingle}t have to worry callbacks or even making sure that the server gets to run. When we called \hyperlink{9152037818560122293}{\texttt{connect()}} the current task waited for the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing works in the same way. To see this, consider the following simple echo server:




\begin{minted}{jlcon}
julia> @async begin
           server = listen(2001)
           while true
               sock = accept(server)
               @async while isopen(sock)
                   write(sock,readline(sock))
               end
           end
       end
Task (runnable) @0x00007fd31dc12e60

julia> clientside = connect(2001)
TCPSocket(RawFD(28) open, 0 bytes waiting)

julia> @async while true
           write(STDOUT,readline(clientside))
       end
Task (runnable) @0x00007fd31dc11870

julia> println(clientside,"Hello World from the Echo Server")
Hello World from the Echo Server
\end{minted}



As with other streams, use \hyperlink{5331333469799487255}{\texttt{close()}} to disconnect the socket:




\begin{minted}{jlcon}
julia> close(clientside)
\end{minted}



\hypertarget{17493699701665466884}{}


\section{Resolving IP Addresses}



One of the \hyperlink{9152037818560122293}{\texttt{connect()}} methods that does not follow the \hyperlink{10380677384505520251}{\texttt{listen()}} methods is \texttt{connect(host::String,port)}, which will attempt to connect to the host given by the \texttt{host} parameter on the port given by the port parameter. It allows you to do things like:




\begin{minted}{jlcon}
julia> connect("google.com",80)
TCPSocket(RawFD(30) open, 0 bytes waiting)
\end{minted}



At the base of this functionality is \hyperlink{8137893525760517927}{\texttt{getaddrinfo()}}, which will do the appropriate address resolution:




\begin{minted}{jlcon}
julia> getaddrinfo("google.com")
ip"74.125.226.225"
\end{minted}



\hypertarget{3649475918943763834}{}


\chapter{Parallel Computing}



Most modern computers possess more than one CPU, and several computers can be combined together in a cluster. Harnessing the power of these multiple CPUs allows many computations to be completed more quickly. There are two major factors that influence performance: the speed of the CPUs themselves, and the speed of their access to memory. In a cluster, it{\textquotesingle}s fairly obvious that a given CPU will have fastest access to the RAM within the same computer (node). Perhaps more surprisingly, similar issues are relevant on a typical multicore laptop, due to differences in the speed of main memory and the \href{https://www.akkadia.org/drepper/cpumemory.pdf}{cache}. Consequently, a good multiprocessing environment should allow control over the {\textquotedbl}ownership{\textquotedbl} of a chunk of memory by a particular CPU. Julia provides a multiprocessing environment based on message passing to allow programs to run on multiple processes in separate memory domains at once.



Julia{\textquotesingle}s implementation of message passing is different from other environments such as MPI \footnotemark[1]. Communication in Julia is generally {\textquotedbl}one-sided{\textquotedbl}, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like {\textquotedbl}message send{\textquotedbl} and {\textquotedbl}message receive{\textquotedbl} but rather resemble higher-level operations like calls to user functions.



Parallel programming in Julia is built on two primitives: \emph{remote references} and \emph{remote calls}. A remote reference is an object that can be used from any process to refer to an object stored on a particular process. A remote call is a request by one process to call a certain function on certain arguments on another (possibly the same) process.



Remote references come in two flavors: \hyperlink{11214097672600393233}{\texttt{Future}} and \hyperlink{18168838922212360925}{\texttt{RemoteChannel}}.



A remote call returns a \hyperlink{11214097672600393233}{\texttt{Future}} to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling \hyperlink{13761789780433862250}{\texttt{wait()}} on the returned \hyperlink{11214097672600393233}{\texttt{Future}}, and you can obtain the full value of the result using \hyperlink{7098010828229464277}{\texttt{fetch()}}.



On the other hand, \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} s are rewritable. For example, multiple processes can co-ordinate their processing by referencing the same remote \texttt{Channel}.



Each process has an associated identifier. The process providing the interactive Julia prompt always has an \texttt{id} equal to 1. The processes used by default for parallel operations are referred to as {\textquotedbl}workers{\textquotedbl}. When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1.



Let{\textquotesingle}s try this out. Starting with \texttt{julia -p n} provides \texttt{n} worker processes on the local machine. Generally it makes sense for \texttt{n} to equal the number of CPU cores on the machine.




\begin{minted}{julia}
$ ./julia -p 2

julia> r = remotecall(rand, 2, 2, 2)
Future(2, 1, 4, Nullable{Any}())

julia> s = @spawnat 2 1 .+ fetch(r)
Future(2, 1, 5, Nullable{Any}())

julia> fetch(s)
2×2 Array{Float64,2}:
 1.18526  1.50912
 1.16296  1.60607
\end{minted}



The first argument to \hyperlink{1245601033905961947}{\texttt{remotecall()}} is the function to call. Most parallel programming in Julia does not reference specific processes or the number of processes available, but \hyperlink{1245601033905961947}{\texttt{remotecall()}} is considered a low-level interface providing finer control. The second argument to \hyperlink{1245601033905961947}{\texttt{remotecall()}} is the \texttt{id} of the process that will do the work, and the remaining arguments will be passed to the function being called.



As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, \texttt{r} and \texttt{s}. The \hyperlink{13196020699522784599}{\texttt{@spawnat}} macro evaluates the expression in the second argument on the process specified by the first argument.



Occasionally you might want a remotely-computed value immediately. This typically happens when you read from a remote object to obtain data needed by the next local operation. The function \hyperlink{16429337757386989414}{\texttt{remotecall\_fetch()}} exists for this purpose. It is equivalent to \texttt{fetch(remotecall(...))} but is more efficient.




\begin{minted}{jlcon}
julia> remotecall_fetch(getindex, 2, r, 1, 1)
0.18526337335308085
\end{minted}



Remember that \hyperlink{2839226020402435013}{\texttt{getindex(r,1,1)}} is \hyperlink{14469287548874312017}{equivalent} to \texttt{r[1,1]}, so this call fetches the first element of the future \texttt{r}.



The syntax of \hyperlink{1245601033905961947}{\texttt{remotecall()}} is not especially convenient. The macro \hyperlink{2703776722227867458}{\texttt{@spawn}} makes things easier. It operates on an expression rather than a function, and picks where to do the operation for you:




\begin{minted}{jlcon}
julia> r = @spawn rand(2,2)
Future(2, 1, 4, Nullable{Any}())

julia> s = @spawn 1 .+ fetch(r)
Future(3, 1, 5, Nullable{Any}())

julia> fetch(s)
2×2 Array{Float64,2}:
 1.38854  1.9098
 1.20939  1.57158
\end{minted}



Note that we used \texttt{1 .+ fetch(r)} instead of \texttt{1 .+ r}. This is because we do not know where the code will run, so in general a \hyperlink{7098010828229464277}{\texttt{fetch()}} might be required to move \texttt{r} to the process doing the addition. In this case, \hyperlink{2703776722227867458}{\texttt{@spawn}} is smart enough to perform the computation on the process that owns \texttt{r}, so the \hyperlink{7098010828229464277}{\texttt{fetch()}} will be a no-op (no work is done).



(It is worth noting that \hyperlink{2703776722227867458}{\texttt{@spawn}} is not built-in but defined in Julia as a \hyperlink{11146454106624591870}{macro}. It is possible to define your own such constructs.)



An important thing to remember is that, once fetched, a \hyperlink{11214097672600393233}{\texttt{Future}} will cache its value locally. Further \hyperlink{7098010828229464277}{\texttt{fetch()}} calls do not entail a network hop. Once all referencing \hyperlink{11214097672600393233}{\texttt{Future}}s have fetched, the remote stored value is deleted.



\hypertarget{893674864058732798}{}


\section{Code Availability and Loading Packages}



Your code must be available on any process that runs it. For example, type the following into the Julia prompt:




\begin{minted}{jlcon}
julia> function rand2(dims...)
           return 2*rand(dims...)
       end

julia> rand2(2,2)
2×2 Array{Float64,2}:
 0.153756  0.368514
 1.15119   0.918912

julia> fetch(@spawn rand2(2,2))
ERROR: RemoteException(2, CapturedException(UndefVarError(Symbol("#rand2"))
[...]
\end{minted}



Process 1 knew about the function \texttt{rand2}, but process 2 did not.



Most commonly you{\textquotesingle}ll be loading code from files or packages, and you have a considerable amount of flexibility in controlling which processes load code. Consider a file, \texttt{DummyModule.jl}, containing the following code:




\begin{minted}{julia}
module DummyModule

export MyType, f

mutable struct MyType
    a::Int
end

f(x) = x^2+1

println("loaded")

end
\end{minted}



Starting Julia with \texttt{julia -p 2}, you can use this to verify the following:



\begin{itemize}
\item \hyperlink{438355891087818425}{\texttt{include({\textquotedbl}DummyModule.jl{\textquotedbl})}} loads the file on just a single process (whichever one executes the statement).


\item \texttt{using DummyModule} causes the module to be loaded on all processes; however, the module is brought into scope only on the one executing the statement.


\item As long as \texttt{DummyModule} is loaded on process 2, commands like


\begin{minted}{julia}
rr = RemoteChannel(2)
put!(rr, MyType(7))
\end{minted}

allow you to store an object of type \texttt{MyType} on process 2 even if \texttt{DummyModule} is not in scope on process 2.

\end{itemize}


You can force a command to run on all processes using the \hyperlink{12473779098025967223}{\texttt{@everywhere}} macro. For example, \texttt{@everywhere} can also be used to directly define a function on all processes:




\begin{minted}{jlcon}
julia> @everywhere id = myid()

julia> remotecall_fetch(()->id, 2)
2
\end{minted}



A file can also be preloaded on multiple processes at startup, and a driver script can be used to drive the computation:




\begin{lstlisting}
julia -p <n> -L file1.jl -L file2.jl driver.jl
\end{lstlisting}



The Julia process running the driver script in the example above has an \texttt{id} equal to 1, just like a process providing an interactive prompt.



The base Julia installation has in-built support for two types of clusters:



\begin{itemize}
\item A local cluster specified with the \texttt{-p} option as shown above.


\item A cluster spanning machines using the \texttt{--machinefile} option. This uses a passwordless \texttt{ssh} login to start Julia worker processes (from the same path as the current host) on the specified machines.

\end{itemize}


Functions \hyperlink{1448678099847390}{\texttt{addprocs()}}, \hyperlink{10441166839192005456}{\texttt{rmprocs()}}, \hyperlink{13629390137500792933}{\texttt{workers()}}, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.



Note that workers do not run a \texttt{.juliarc.jl} startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.



Other types of clusters can be supported by writing your own custom \texttt{ClusterManager}, as described below in the \hyperlink{6714934932026232883}{ClusterManagers} section.



\hypertarget{2346546032059567717}{}


\section{Data Movement}



Sending messages and moving data constitute most of the overhead in a parallel program. Reducing the number of messages and the amount of data sent is critical to achieving performance and scalability. To this end, it is important to understand the data movement performed by Julia{\textquotesingle}s various parallel programming constructs.



\hyperlink{7098010828229464277}{\texttt{fetch()}} can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. \hyperlink{2703776722227867458}{\texttt{@spawn}} (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:



Method 1:




\begin{minted}{jlcon}
julia> A = rand(1000,1000);

julia> Bref = @spawn A^2;

[...]

julia> fetch(Bref);
\end{minted}



Method 2:




\begin{minted}{jlcon}
julia> Bref = @spawn rand(1000,1000)^2;

[...]

julia> fetch(Bref);
\end{minted}



The difference seems trivial, but in fact is quite significant due to the behavior of \hyperlink{2703776722227867458}{\texttt{@spawn}}. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.



In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix \texttt{A} then the first method might be better. Or, if computing \texttt{A} is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the \hyperlink{2703776722227867458}{\texttt{@spawn}} and \texttt{fetch(Bref)}, it might be better to eliminate the parallelism altogether. Or imagine \texttt{rand(1000,1000)} is replaced with a more expensive operation. Then it might make sense to add another \hyperlink{2703776722227867458}{\texttt{@spawn}} statement just for this step.



\hypertarget{3799157488399393885}{}


\chapter{Global variables}



Expressions executed remotely via \texttt{@spawn}, or closures specified for remote execution using \texttt{remotecall} may refer to global variables. Global bindings under module \texttt{Main} are treated a little differently compared to global bindings in other modules. Consider the following code snippet:




\begin{minted}{jlcon}
A = rand(10,10)
remotecall_fetch(()->foo(A), 2)
\end{minted}



Note that \texttt{A} is a global variable defined in the local workspace. Worker 2 does not have a variable called \texttt{A} under \texttt{Main}. The act of shipping the closure \texttt{()->foo(A)} to worker 2 results in \texttt{Main.A} being defined on 2. \texttt{Main.A} continues to exist on worker 2 even after the call \texttt{remotecall\_fetch} returns. Remote calls with embedded global references (under \texttt{Main} module only) manage globals as follows:



\begin{itemize}
\item New global bindings are created on destination workers if they are referenced as part of a remote call.


\item Global constants are declared as constants on remote nodes too.


\item Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster does not synchronize global bindings across nodes. For example:


\begin{minted}{julia}
A = rand(10,10)
remotecall_fetch(()->foo(A), 2) # worker 2
A = rand(10,10)
remotecall_fetch(()->foo(A), 3) # worker 3
A = nothing
\end{minted}

Executing the above snippet results in \texttt{Main.A} on worker 2 having a different value from \texttt{Main.A} on worker 3, while the value of \texttt{Main.A} on node 1 is set to \texttt{nothing}.

\end{itemize}


As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. \hyperlink{16259780224935483802}{\texttt{clear!}} can be used to manually reassign specific globals on remote nodes to \texttt{nothing} once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.



Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you must reference globals, consider using \texttt{let} blocks to localize global variables.



For example:




\begin{minted}{jlcon}
julia> A = rand(10,10);

julia> remotecall_fetch(()->A, 2);

julia> B = rand(10,10);

julia> let B = B
           remotecall_fetch(()->B, 2)
       end;

julia> @spawnat 2 whos();

julia>  From worker 2:                               A    800 bytes  10×10 Array{Float64,2}
        From worker 2:                            Base               Module
        From worker 2:                            Core               Module
        From worker 2:                            Main               Module
\end{minted}



As can be seen, global variable \texttt{A} is defined on worker 2, but \texttt{B} is captured as a local variable and hence a binding for \texttt{B} does not exist on worker 2.



\hypertarget{14061631345729052518}{}


\section{Parallel Map and Loops}



Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use \hyperlink{2703776722227867458}{\texttt{@spawn}} to flip coins on two processes. First, write the following function in \texttt{count\_heads.jl}:




\begin{minted}{julia}
function count_heads(n)
    c::Int = 0
    for i = 1:n
        c += rand(Bool)
    end
    c
end
\end{minted}



The function \texttt{count\_heads} simply adds together \texttt{n} random bits. Here is how we can perform some trials on two machines, and add together the results:




\begin{minted}{jlcon}
julia> @everywhere include("count_heads.jl")

julia> a = @spawn count_heads(100000000)
Future(2, 1, 6, Nullable{Any}())

julia> b = @spawn count_heads(100000000)
Future(3, 1, 7, Nullable{Any}())

julia> fetch(a)+fetch(b)
100001564
\end{minted}



This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a \emph{reduction}, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern \texttt{x = f(x,v[i])}, where \texttt{x} is the accumulator, \texttt{f} is the reduction function, and the \texttt{v[i]} are the elements being reduced. It is desirable for \texttt{f} to be associative, so that it does not matter what order the operations are performed in.



Notice that our use of this pattern with \texttt{count\_heads} can be generalized. We used two explicit \hyperlink{2703776722227867458}{\texttt{@spawn}} statements, which limits the parallelism to two processes. To run on any number of processes, we can use a \emph{parallel for loop}, which can be written in Julia using \hyperlink{11870389661093259741}{\texttt{@parallel}} like this:




\begin{minted}{julia}
nheads = @parallel (+) for i = 1:200000000
    Int(rand(Bool))
end
\end{minted}



This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case \texttt{(+)}). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.



Note that although parallel for loops look like serial for loops, their behavior is dramatically different. In particular, the iterations do not happen in a specified order, and writes to variables or arrays will not be globally visible since iterations run on different processes. Any variables used inside the parallel loop will be copied and broadcast to each process.



For example, the following code will not work as intended:




\begin{minted}{julia}
a = zeros(100000)
@parallel for i = 1:100000
    a[i] = i
end
\end{minted}



This code will not initialize all of \texttt{a}, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, \hyperlink{16489506716059563786}{Shared Arrays} can be used to get around this limitation:




\begin{minted}{julia}
a = SharedArray{Float64}(10)
@parallel for i = 1:10
    a[i] = i
end
\end{minted}



Using {\textquotedbl}outside{\textquotedbl} variables in parallel loops is perfectly reasonable if the variables are read-only:




\begin{minted}{julia}
a = randn(1000)
@parallel (+) for i = 1:100000
    f(a[rand(1:end)])
end
\end{minted}



Here each iteration applies \texttt{f} to a randomly-chosen sample from a vector \texttt{a} shared by all processes.



As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of \hyperlink{11214097672600393233}{\texttt{Future}} immediately without waiting for completion. The caller can wait for the \hyperlink{11214097672600393233}{\texttt{Future}} completions at a later point by calling \hyperlink{7098010828229464277}{\texttt{fetch()}} on them, or wait for completion at the end of the loop by prefixing it with \hyperlink{7188613740509403855}{\texttt{@sync}}, like \texttt{@sync @parallel for}.



In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called \emph{parallel map}, implemented in Julia as the \hyperlink{3190941263759446411}{\texttt{pmap()}} function. For example, we could compute the singular values of several large random matrices in parallel as follows:




\begin{minted}{jlcon}
julia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];

julia> pmap(svd, M);
\end{minted}



Julia{\textquotesingle}s \hyperlink{3190941263759446411}{\texttt{pmap()}} is designed for the case where each function call does a large amount of work. In contrast, \texttt{@parallel for} can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both \hyperlink{3190941263759446411}{\texttt{pmap()}} and \texttt{@parallel for} for the parallel computation. In case of \texttt{@parallel for}, the final reduction is done on the calling process.



\hypertarget{11080581090081739822}{}


\section{Synchronization With Remote References}



\hypertarget{3706829557192562237}{}


\section{Scheduling}



Julia{\textquotesingle}s parallel programming platform uses \hyperlink{15038256797533490288}{Tasks (aka Coroutines)} to switch among multiple computations. Whenever code performs a communication operation like \hyperlink{7098010828229464277}{\texttt{fetch()}} or \hyperlink{13761789780433862250}{\texttt{wait()}}, the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.



For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same time, which provides for \emph{dynamic scheduling}. In dynamic scheduling, a program decides what to compute or where to compute it based on when other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish their current tasks.



As an example, consider computing the singular values of matrices of different sizes:




\begin{minted}{jlcon}
julia> M = Matrix{Float64}[rand(800,800), rand(600,600), rand(800,800), rand(600,600)];

julia> pmap(svd, M);
\end{minted}



If one process handles both 800×800 matrices and another handles both 600×600 matrices, we will not get as much scalability as we could. The solution is to make a local task to {\textquotedbl}feed{\textquotedbl} work to each process when it completes its current task. For example, consider a simple \hyperlink{3190941263759446411}{\texttt{pmap()}} implementation:




\begin{minted}{julia}
function pmap(f, lst)
    np = nprocs()  # determine the number of processes available
    n = length(lst)
    results = Vector{Any}(n)
    i = 1
    # function to produce the next work item from the queue.
    # in this case it's just an index.
    nextidx() = (idx=i; i+=1; idx)
    @sync begin
        for p=1:np
            if p != myid() || np == 1
                @async begin
                    while true
                        idx = nextidx()
                        if idx > n
                            break
                        end
                        results[idx] = remotecall_fetch(f, p, lst[idx])
                    end
                end
            end
        end
    end
    results
end
\end{minted}



\hyperlink{10770947021537241619}{\texttt{@async}} is similar to \hyperlink{2703776722227867458}{\texttt{@spawn}}, but only runs tasks on the local process. We use it to create a {\textquotedbl}feeder{\textquotedbl} task for each process. Each task picks the next index that needs to be computed, then waits for its process to finish, then repeats until we run out of indexes. Note that the feeder tasks do not begin to execute until the main task reaches the end of the \hyperlink{7188613740509403855}{\texttt{@sync}} block, at which point it surrenders control and waits for all the local tasks to complete before returning from the function. The feeder tasks are able to share state via \texttt{nextidx()} because they all run on the same process. No locking is required, since the threads are scheduled cooperatively and not preemptively. This means context switches only occur at well-defined points: in this case, when \hyperlink{16429337757386989414}{\texttt{remotecall\_fetch()}} is called.



\hypertarget{5026428100850833092}{}


\section{Channels}



The section on \hyperlink{7131243650304654155}{\texttt{Task}}s in \hyperlink{8710711813610225279}{Control Flow} discussed the execution of multiple functions in a co-operative manner. \hyperlink{12548845729684045604}{\texttt{Channel}}s can be quite useful to pass data between running tasks, particularly those involving I/O operations.



Examples of operations involving I/O include reading/writing to files, accessing web services, executing external programs, etc. In all these cases, overall execution time can be improved if other tasks can be run while a file is being read, or while waiting for an external service/program to complete.



A channel can be visualized as a pipe, i.e., it has a write end and read end.



\begin{itemize}
\item Multiple writers in different tasks can write to the same channel concurrently via \hyperlink{12719543094136814100}{\texttt{put!()}} calls.


\item Multiple readers in different tasks can read data concurrently via \hyperlink{4360129174058888556}{\texttt{take!()}} calls.


\item As an example:


\begin{minted}{julia}
# Given Channels c1 and c2,
c1 = Channel(32)
c2 = Channel(32)

# and a function `foo()` which reads items from from c1, processes the item read
# and writes a result to c2,
function foo()
    while true
        data = take!(c1)
        [...]               # process data
        put!(c2, result)    # write out result
    end
end

# we can schedule `n` instances of `foo()` to be active concurrently.
for _ in 1:n
    @schedule foo()
end
\end{minted}


\item Channels are created via the \texttt{Channel\{T\}(sz)} constructor. The channel will only hold objects of type \texttt{T}. If the type is not specified, the channel can hold objects of any type. \texttt{sz} refers to the maximum number of elements that can be held in the channel at any time. For example, \texttt{Channel(32)} creates a channel that can hold a maximum of 32 objects of any type. A \texttt{Channel\{MyType\}(64)} can hold up to 64 objects of \texttt{MyType} at any time.


\item If a \hyperlink{12548845729684045604}{\texttt{Channel}} is empty, readers (on a \hyperlink{4360129174058888556}{\texttt{take!()}} call) will block until data is available.


\item If a \hyperlink{12548845729684045604}{\texttt{Channel}} is full, writers (on a \hyperlink{12719543094136814100}{\texttt{put!()}} call) will block until space becomes available.


\item \hyperlink{15888554370655089980}{\texttt{isready()}} tests for the presence of any object in the channel, while \hyperlink{13761789780433862250}{\texttt{wait()}} waits for an object to become available.


\item A \hyperlink{12548845729684045604}{\texttt{Channel}} is in an open state initially. This means that it can be read from and written to freely via \hyperlink{4360129174058888556}{\texttt{take!()}} and \hyperlink{12719543094136814100}{\texttt{put!()}} calls. \hyperlink{5331333469799487255}{\texttt{close()}} closes a \hyperlink{12548845729684045604}{\texttt{Channel}}. On a closed \hyperlink{12548845729684045604}{\texttt{Channel}}, \hyperlink{12719543094136814100}{\texttt{put!()}} will fail. For example:

\end{itemize}



\begin{minted}{jlcon}
julia> c = Channel(2);

julia> put!(c, 1) # `put!` on an open channel succeeds
1

julia> close(c);

julia> put!(c, 2) # `put!` on a closed channel throws an exception.
ERROR: InvalidStateException("Channel is closed.",:closed)
[...]
\end{minted}



\begin{itemize}
\item \hyperlink{4360129174058888556}{\texttt{take!()}} and \hyperlink{7098010828229464277}{\texttt{fetch()}} (which retrieves but does not remove the value) on a closed channel successfully return any existing values until it is emptied. Continuing the above example:

\end{itemize}



\begin{minted}{jlcon}
julia> fetch(c) # Any number of `fetch` calls succeed.
1

julia> fetch(c)
1

julia> take!(c) # The first `take!` removes the value.
1

julia> take!(c) # No more data available on a closed channel.
ERROR: InvalidStateException("Channel is closed.",:closed)
[...]
\end{minted}



A \texttt{Channel} can be used as an iterable object in a \texttt{for} loop, in which case the loop runs as long as the \texttt{Channel} has data or is open. The loop variable takes on all values added to the \texttt{Channel}. The \texttt{for} loop is terminated once the \texttt{Channel} is closed and emptied.



For example, the following would cause the \texttt{for} loop to wait for more data:




\begin{minted}{jlcon}
julia> c = Channel{Int}(10);

julia> foreach(i->put!(c, i), 1:3) # add a few entries

julia> data = [i for i in c]
\end{minted}



while this will return after reading all data:




\begin{minted}{jlcon}
julia> c = Channel{Int}(10);

julia> foreach(i->put!(c, i), 1:3); # add a few entries

julia> close(c);                    # `for` loops can exit

julia> data = [i for i in c]
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



Consider a simple example using channels for inter-task communication. We start 4 tasks to process data from a single \texttt{jobs} channel. Jobs, identified by an id (\texttt{job\_id}), are written to the channel. Each task in this simulation reads a \texttt{job\_id}, waits for a random amout of time and writes back a tuple of \texttt{job\_id} and the simulated time to the results channel. Finally all the \texttt{results} are printed out.




\begin{minted}{jlcon}
julia> const jobs = Channel{Int}(32);

julia> const results = Channel{Tuple}(32);

julia> function do_work()
           for job_id in jobs
               exec_time = rand()
               sleep(exec_time)                # simulates elapsed time doing actual work
                                               # typically performed externally.
               put!(results, (job_id, exec_time))
           end
       end;

julia> function make_jobs(n)
           for i in 1:n
               put!(jobs, i)
           end
       end;

julia> n = 12;

julia> @schedule make_jobs(n); # feed the jobs channel with "n" jobs

julia> for i in 1:4 # start 4 tasks to process requests in parallel
           @schedule do_work()
       end

julia> @elapsed while n > 0 # print out results
           job_id, exec_time = take!(results)
           println("$job_id finished in $(round(exec_time,2)) seconds")
           n = n - 1
       end
4 finished in 0.22 seconds
3 finished in 0.45 seconds
1 finished in 0.5 seconds
7 finished in 0.14 seconds
2 finished in 0.78 seconds
5 finished in 0.9 seconds
9 finished in 0.36 seconds
6 finished in 0.87 seconds
8 finished in 0.79 seconds
10 finished in 0.64 seconds
12 finished in 0.5 seconds
11 finished in 0.97 seconds
0.029772311
\end{minted}



The current version of Julia multiplexes all tasks onto a single OS thread. Thus, while tasks involving I/O operations benefit from parallel execution, compute bound tasks are effectively executed sequentially on a single OS thread. Future versions of Julia may support scheduling of tasks on multiple threads, in which case compute bound tasks will see benefits of parallel execution too.



\hypertarget{13095556636924919294}{}


\section{Remote References and AbstractChannels}



Remote references always refer to an implementation of an \texttt{AbstractChannel}.



A concrete implementation of an \texttt{AbstractChannel} (like \texttt{Channel}), is required to implement \hyperlink{12719543094136814100}{\texttt{put!()}}, \hyperlink{4360129174058888556}{\texttt{take!()}}, \hyperlink{7098010828229464277}{\texttt{fetch()}}, \hyperlink{15888554370655089980}{\texttt{isready()}} and \hyperlink{13761789780433862250}{\texttt{wait()}}. The remote object referred to by a \hyperlink{11214097672600393233}{\texttt{Future}} is stored in a \texttt{Channel\{Any\}(1)}, i.e., a \texttt{Channel} of size 1 capable of holding objects of \texttt{Any} type.



\hyperlink{18168838922212360925}{\texttt{RemoteChannel}}, which is rewritable, can point to any type and size of channels, or any other implementation of an \texttt{AbstractChannel}.



The constructor \texttt{RemoteChannel(f::Function, pid)()} allows us to construct references to channels holding more than one value of a specific type. \texttt{f()} is a function executed on \texttt{pid} and it must return an \texttt{AbstractChannel}.



For example, \texttt{RemoteChannel(()->Channel\{Int\}(10), pid)}, will return a reference to a channel of type \texttt{Int} and size 10. The channel exists on worker \texttt{pid}.



Methods \hyperlink{12719543094136814100}{\texttt{put!()}}, \hyperlink{4360129174058888556}{\texttt{take!()}}, \hyperlink{7098010828229464277}{\texttt{fetch()}}, \hyperlink{15888554370655089980}{\texttt{isready()}} and \hyperlink{13761789780433862250}{\texttt{wait()}} on a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} are proxied onto the backing store on the remote process.



\hyperlink{18168838922212360925}{\texttt{RemoteChannel}} can thus be used to refer to user implemented \texttt{AbstractChannel} objects. A simple example of this is provided in \texttt{examples/dictchannel.jl} which uses a dictionary as its remote store.



\hypertarget{1440088565186592100}{}


\section{Channels and RemoteChannels}



\begin{itemize}
\item A \hyperlink{12548845729684045604}{\texttt{Channel}} is local to a process. Worker 2 cannot directly refer to a \texttt{Channel} on worker 3 and vice-versa. A \hyperlink{18168838922212360925}{\texttt{RemoteChannel}}, however, can put and take values across workers.


\item A \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} can be thought of as a \emph{handle} to a \texttt{Channel}.


\item The process id, \texttt{pid}, associated with a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} identifies the process where the backing store, i.e., the backing \texttt{Channel} exists.


\item Any process with a reference to a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} is associated with.


\item Serializing  a \texttt{Channel} also serializes any data present in the channel. Deserializing it therefore effectively makes a copy of the original object.


\item On the other hand, serializing a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} only involves the serialization of an identifier that identifies the location and instance of \texttt{Channel} referred to by the handle. A deserialized \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} object (on any worker), therefore also points to the same backing store as the original.

\end{itemize}


The channels example from above can be modified for interprocess communication, as shown below.



We start 4 workers to process a single \texttt{jobs} remote channel. Jobs, identified by an id (\texttt{job\_id}), are written to the channel. Each remotely executing task in this simulation reads a \texttt{job\_id}, waits for a random amount of time and writes back a tuple of \texttt{job\_id}, time taken and its own \texttt{pid} to the results channel. Finally all the \texttt{results} are printed out on the master process.




\begin{minted}{jlcon}
julia> addprocs(4); # add worker processes

julia> const jobs = RemoteChannel(()->Channel{Int}(32));

julia> const results = RemoteChannel(()->Channel{Tuple}(32));

julia> @everywhere function do_work(jobs, results) # define work function everywhere
           while true
               job_id = take!(jobs)
               exec_time = rand()
               sleep(exec_time) # simulates elapsed time doing actual work
               put!(results, (job_id, exec_time, myid()))
           end
       end

julia> function make_jobs(n)
           for i in 1:n
               put!(jobs, i)
           end
       end;

julia> n = 12;

julia> @schedule make_jobs(n); # feed the jobs channel with "n" jobs

julia> for p in workers() # start tasks on the workers to process requests in parallel
           @async remote_do(do_work, p, jobs, results)
       end

julia> @elapsed while n > 0 # print out results
           job_id, exec_time, where = take!(results)
           println("$job_id finished in $(round(exec_time,2)) seconds on worker $where")
           n = n - 1
       end
1 finished in 0.18 seconds on worker 4
2 finished in 0.26 seconds on worker 5
6 finished in 0.12 seconds on worker 4
7 finished in 0.18 seconds on worker 4
5 finished in 0.35 seconds on worker 5
4 finished in 0.68 seconds on worker 2
3 finished in 0.73 seconds on worker 3
11 finished in 0.01 seconds on worker 3
12 finished in 0.02 seconds on worker 3
9 finished in 0.26 seconds on worker 5
8 finished in 0.57 seconds on worker 4
10 finished in 0.58 seconds on worker 2
0.055971741
\end{minted}



\hypertarget{1222102857865795644}{}


\section{Remote References and Distributed Garbage Collection}



Objects referred to by remote references can be freed only when \emph{all} held references in the cluster are deleted.



The node where the value is stored keeps track of which of the workers have a reference to it. Every time a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} or a (unfetched) \hyperlink{11214097672600393233}{\texttt{Future}} is serialized to a worker, the node pointed to by the reference is notified. And every time a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} or a (unfetched) \hyperlink{11214097672600393233}{\texttt{Future}} is garbage collected locally, the node owning the value is again notified.



The notifications are done via sending of {\textquotedbl}tracking{\textquotedbl} messages–an {\textquotedbl}add reference{\textquotedbl} message when a reference is serialized to a different process and a {\textquotedbl}delete reference{\textquotedbl} message when a reference is locally garbage collected.



Since \hyperlink{11214097672600393233}{\texttt{Future}}s are write-once and cached locally, the act of \hyperlink{7098010828229464277}{\texttt{fetch()}}ing a \hyperlink{11214097672600393233}{\texttt{Future}} also updates reference tracking information on the node owning the value.



The node which owns the value frees it once all references to it are cleared.



With \hyperlink{11214097672600393233}{\texttt{Future}}s, serializing an already fetched \hyperlink{11214097672600393233}{\texttt{Future}} to a different node also sends the value since the original remote store may have collected the value by this time.



It is important to note that \emph{when} an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.



In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call \hyperlink{6584919147438336166}{\texttt{finalize()}} on local instances of a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}}, or on unfetched \hyperlink{11214097672600393233}{\texttt{Future}}s. Since calling \hyperlink{7098010828229464277}{\texttt{fetch()}} on a \hyperlink{11214097672600393233}{\texttt{Future}} also removes its reference from the remote store, this is not required on fetched \hyperlink{11214097672600393233}{\texttt{Future}}s. Explicitly calling \hyperlink{6584919147438336166}{\texttt{finalize()}} results in an immediate message sent to the remote node to go ahead and remove its reference to the value.



Once finalized, a reference becomes invalid and cannot be used in any further calls.



\hypertarget{16489506716059563786}{}


\section{Shared Arrays}



Shared Arrays use system shared memory to map the same array across many processes. While there are some similarities to a \href{https://github.com/JuliaParallel/DistributedArrays.jl}{\texttt{DArray}}, the behavior of a \hyperlink{7878126212965430667}{\texttt{SharedArray}} is quite different. In a \href{https://github.com/JuliaParallel/DistributedArrays.jl}{\texttt{DArray}}, each process has local access to just a chunk of the data, and no two processes share the same chunk; in contrast, in a \hyperlink{7878126212965430667}{\texttt{SharedArray}} each {\textquotedbl}participating{\textquotedbl} process has access to the entire array.  A \hyperlink{7878126212965430667}{\texttt{SharedArray}} is a good choice when you want to have a large amount of data jointly accessible to two or more processes on the same machine.



\hyperlink{7878126212965430667}{\texttt{SharedArray}} indexing (assignment and accessing values) works just as with regular arrays, and is efficient because the underlying memory is available to the local process. Therefore, most algorithms work naturally on \hyperlink{7878126212965430667}{\texttt{SharedArray}}s, albeit in single-process mode. In cases where an algorithm insists on an \hyperlink{15492651498431872487}{\texttt{Array}} input, the underlying array can be retrieved from a \hyperlink{7878126212965430667}{\texttt{SharedArray}} by calling \hyperlink{12236070431744516222}{\texttt{sdata()}}. For other \texttt{AbstractArray} types, \hyperlink{12236070431744516222}{\texttt{sdata()}} just returns the object itself, so it{\textquotesingle}s safe to use \hyperlink{12236070431744516222}{\texttt{sdata()}} on any \texttt{Array}-type object.



The constructor for a shared array is of the form:




\begin{minted}{julia}
SharedArray{T,N}(dims::NTuple; init=false, pids=Int[])
\end{minted}



which creates an \texttt{N}-dimensional shared array of a bits type \texttt{T} and size \texttt{dims} across the processes specified by \texttt{pids}. Unlike distributed arrays, a shared array is accessible only from those participating workers specified by the \texttt{pids} named argument (and the creating process too, if it is on the same host).



If an \texttt{init} function, of signature \texttt{initfn(S::SharedArray)}, is specified, it is called on all the participating workers. You can specify that each worker runs the \texttt{init} function on a distinct portion of the array, thereby parallelizing initialization.



Here{\textquotesingle}s a brief example:




\begin{minted}{jlcon}
julia> addprocs(3)
3-element Array{Int64,1}:
 2
 3
 4

julia> S = SharedArray{Int,2}((3,4), init = S -> S[Base.localindexes(S)] = myid())
3×4 SharedArray{Int64,2}:
 2  2  3  4
 2  3  3  4
 2  3  4  4

julia> S[3,2] = 7
7

julia> S
3×4 SharedArray{Int64,2}:
 2  2  3  4
 2  3  3  4
 2  7  4  4
\end{minted}



\hyperlink{6459655385118725622}{\texttt{Base.localindexes()}} provides disjoint one-dimensional ranges of indexes, and is sometimes convenient for splitting up tasks among processes. You can, of course, divide the work any way you wish:




\begin{minted}{jlcon}
julia> S = SharedArray{Int,2}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = myid())
3×4 SharedArray{Int64,2}:
 2  2  2  2
 3  3  3  3
 4  4  4  4
\end{minted}



Since all processes have access to the underlying data, you do have to be careful not to set up conflicts. For example:




\begin{minted}{julia}
@sync begin
    for p in procs(S)
        @async begin
            remotecall_wait(fill!, p, S, p)
        end
    end
end
\end{minted}



would result in undefined behavior. Because each process fills the \emph{entire} array with its own \texttt{pid}, whichever process is the last to execute (for any particular element of \texttt{S}) will have its \texttt{pid} retained.



As a more extended and complex example, consider running the following {\textquotedbl}kernel{\textquotedbl} in parallel:




\begin{minted}{julia}
q[i,j,t+1] = q[i,j,t] + u[i,j,t]
\end{minted}



In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if \texttt{q[i,j,t]} is near the end of the block assigned to one worker and \texttt{q[i,j,t+1]} is near the beginning of the block assigned to another, it{\textquotesingle}s very likely that \texttt{q[i,j,t]} will not be ready at the time it{\textquotesingle}s needed for computing \texttt{q[i,j,t+1]}. In such cases, one is better off chunking the array manually. Let{\textquotesingle}s split along the second dimension. Define a function that returns the \texttt{(irange, jrange)} indexes assigned to this worker:




\begin{minted}{jlcon}
julia> @everywhere function myrange(q::SharedArray)
           idx = indexpids(q)
           if idx == 0 # This worker is not assigned a piece
               return 1:0, 1:0
           end
           nchunks = length(procs(q))
           splits = [round(Int, s) for s in linspace(0,size(q,2),nchunks+1)]
           1:size(q,1), splits[idx]+1:splits[idx+1]
       end
\end{minted}



Next, define the kernel:




\begin{minted}{jlcon}
julia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)
           @show (irange, jrange, trange)  # display so we can see what's happening
           for t in trange, j in jrange, i in irange
               q[i,j,t+1] = q[i,j,t] + u[i,j,t]
           end
           q
       end
\end{minted}



We also define a convenience wrapper for a \texttt{SharedArray} implementation




\begin{minted}{jlcon}
julia> @everywhere advection_shared_chunk!(q, u) =
           advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)
\end{minted}



Now let{\textquotesingle}s compare three different versions, one that runs in a single process:




\begin{minted}{jlcon}
julia> advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);
\end{minted}



one that uses \hyperlink{11870389661093259741}{\texttt{@parallel}}:




\begin{minted}{jlcon}
julia> function advection_parallel!(q, u)
           for t = 1:size(q,3)-1
               @sync @parallel for j = 1:size(q,2)
                   for i = 1:size(q,1)
                       q[i,j,t+1]= q[i,j,t] + u[i,j,t]
                   end
               end
           end
           q
       end;
\end{minted}



and one that delegates in chunks:




\begin{minted}{jlcon}
julia> function advection_shared!(q, u)
           @sync begin
               for p in procs(q)
                   @async remotecall_wait(advection_shared_chunk!, p, q, u)
               end
           end
           q
       end;
\end{minted}



If we create \texttt{SharedArray}s and time these functions, we get the following results (with \texttt{julia -p 4}):




\begin{minted}{jlcon}
julia> q = SharedArray{Float64,3}((500,500,500));

julia> u = SharedArray{Float64,3}((500,500,500));
\end{minted}



Run the functions once to JIT-compile and \hyperlink{8029752041511656628}{\texttt{@time}} them on the second run:




\begin{minted}{jlcon}
julia> @time advection_serial!(q, u);
(irange,jrange,trange) = (1:500,1:500,1:499)
 830.220 milliseconds (216 allocations: 13820 bytes)

julia> @time advection_parallel!(q, u);
   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)

julia> @time advection_shared!(q,u);
        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)
        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)
        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)
        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)
 238.119 milliseconds (2264 allocations: 169 KB)
\end{minted}



The biggest advantage of \texttt{advection\_shared!} is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.



\hypertarget{16687107137086926880}{}


\section{Shared Arrays and Distributed Garbage Collection}



Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.



\hypertarget{6714934932026232883}{}


\section{ClusterManagers}



The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A \texttt{ClusterManager} is responsible for



\begin{itemize}
\item launching worker processes in a cluster environment


\item managing events during the lifetime of each worker


\item optionally, providing data transport

\end{itemize}


A Julia cluster has the following characteristics:



\begin{itemize}
\item The initial Julia process, also called the \texttt{master}, is special and has an \texttt{id} of 1.


\item Only the \texttt{master} process can add or remove worker processes.


\item All processes can directly communicate with each other.

\end{itemize}


Connections between workers (using the in-built TCP/IP transport) is established in the following manner:



\begin{itemize}
\item \hyperlink{1448678099847390}{\texttt{addprocs()}} is called on the master process with a \texttt{ClusterManager} object.


\item \hyperlink{1448678099847390}{\texttt{addprocs()}} calls the appropriate \hyperlink{6239708201491318480}{\texttt{launch()}} method which spawns required number of worker processes on appropriate machines.


\item Each worker starts listening on a free port and writes out its host and port information to \hyperlink{2784333101804678420}{\texttt{STDOUT}}.


\item The cluster manager captures the \hyperlink{2784333101804678420}{\texttt{STDOUT}} of each worker and makes it available to the master process.


\item The master process parses this information and sets up TCP/IP connections to each worker.


\item Every worker is also notified of other workers in the cluster.


\item Each worker connects to all workers whose \texttt{id} is less than the worker{\textquotesingle}s own \texttt{id}.


\item In this way a mesh network is established, wherein every worker is directly connected with every other worker.

\end{itemize}


While the default transport layer uses plain \texttt{TCPSocket}, it is possible for a Julia cluster to provide its own transport.



Julia provides two in-built cluster managers:



\begin{itemize}
\item \texttt{LocalManager}, used when \hyperlink{1448678099847390}{\texttt{addprocs()}} or \hyperlink{1448678099847390}{\texttt{addprocs(np::Integer)}} are called


\item \texttt{SSHManager}, used when \hyperlink{1448678099847390}{\texttt{addprocs(hostnames::Array)}} is called with a list of hostnames

\end{itemize}


\texttt{LocalManager} is used to launch additional workers on the same host, thereby leveraging multi-core and multi-processor hardware.



Thus, a minimal cluster manager would need to:



\begin{itemize}
\item be a subtype of the abstract \texttt{ClusterManager}


\item implement \hyperlink{6239708201491318480}{\texttt{launch()}}, a method responsible for launching new workers


\item implement \hyperlink{7891835938868853982}{\texttt{manage()}}, which is called at various events during a worker{\textquotesingle}s lifetime (for example, sending an interrupt signal)

\end{itemize}


\hyperlink{1448678099847390}{\texttt{addprocs(manager::FooManager)}} requires \texttt{FooManager} to implement:




\begin{minted}{julia}
function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)
    [...]
end

function manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)
    [...]
end
\end{minted}



As an example let us see how the \texttt{LocalManager}, the manager responsible for starting workers on the same host, is implemented:




\begin{minted}{julia}
struct LocalManager <: ClusterManager
    np::Integer
end

function launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)
    [...]
end

function manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)
    [...]
end
\end{minted}



The \hyperlink{6239708201491318480}{\texttt{launch()}} method takes the following arguments:



\begin{itemize}
\item \texttt{manager::ClusterManager}: the cluster manager that \hyperlink{1448678099847390}{\texttt{addprocs()}} is called with


\item \texttt{params::Dict}: all the keyword arguments passed to \hyperlink{1448678099847390}{\texttt{addprocs()}}


\item \texttt{launched::Array}: the array to append one or more \texttt{WorkerConfig} objects to


\item \texttt{c::Condition}: the condition variable to be notified as and when workers are launched

\end{itemize}


The \hyperlink{6239708201491318480}{\texttt{launch()}} method is called asynchronously in a separate task. The termination of this task signals that all requested workers have been launched. Hence the \hyperlink{6239708201491318480}{\texttt{launch()}} function MUST exit as soon as all the requested workers have been launched.



Newly launched workers are connected to each other, and the master process, in an all-to-all manner. Specifying the command argument \texttt{--worker <cookie>} results in the launched processes initializing themselves as workers and connections being set up via TCP/IP sockets. Optionally, \texttt{--bind-to bind\_addr[:port]} may also be specified to enable other workers to connect to it at the specified \texttt{bind\_addr} and \texttt{port}. This is useful for multi-homed hosts.



As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case \texttt{--worker} must NOT be specified. Instead, newly launched workers should call \texttt{init\_worker(cookie)} before using any of the parallel constructs.



For every worker launched, the \hyperlink{6239708201491318480}{\texttt{launch()}} method must add a \texttt{WorkerConfig} object (with appropriate fields initialized) to \texttt{launched}




\begin{minted}{julia}
mutable struct WorkerConfig
    # Common fields relevant to all cluster managers
    io::Nullable{IO}
    host::Nullable{AbstractString}
    port::Nullable{Integer}

    # Used when launching additional workers at a host
    count::Nullable{Union{Int, Symbol}}
    exename::Nullable{AbstractString}
    exeflags::Nullable{Cmd}

    # External cluster managers can use this to store information at a per-worker level
    # Can be a dict if multiple fields need to be stored.
    userdata::Nullable{Any}

    # SSHManager / SSH tunnel connections to workers
    tunnel::Nullable{Bool}
    bind_addr::Nullable{AbstractString}
    sshflags::Nullable{Cmd}
    max_parallel::Nullable{Integer}

    connect_at::Nullable{Any}

    [...]
end
\end{minted}



Most of the fields in \texttt{WorkerConfig} are used by the inbuilt managers. Custom cluster managers would typically specify only \texttt{io} or \texttt{host} / \texttt{port}:



\begin{itemize}
\item If \texttt{io} is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.


\item If \texttt{io} is not specified, \texttt{host} and \texttt{port} are used to connect.


\item \texttt{count}, \texttt{exename} and \texttt{exeflags} are relevant for launching additional workers from a worker. For example, a cluster manager may launch a single worker per node, and use that to launch additional workers.

\begin{itemize}
\item \texttt{count} with an integer value \texttt{n} will launch a total of \texttt{n} workers.


\item \texttt{count} with a value of \texttt{:auto} will launch as many workers as the number of cores on that machine.


\item \texttt{exename} is the name of the \texttt{julia} executable including the full path.


\item \texttt{exeflags} should be set to the required command line arguments for new workers.

\end{itemize}

\item \texttt{tunnel}, \texttt{bind\_addr}, \texttt{sshflags} and \texttt{max\_parallel} are used when a ssh tunnel is required to connect to the workers from the master process.


\item \texttt{userdata} is provided for custom cluster managers to store their own worker-specific information.

\end{itemize}


\texttt{manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)} is called at different times during the worker{\textquotesingle}s lifetime with appropriate \texttt{op} values:



\begin{itemize}
\item with \texttt{:register}/\texttt{:deregister} when a worker is added / removed from the Julia worker pool.


\item with \texttt{:interrupt} when \texttt{interrupt(workers)} is called. The \texttt{ClusterManager} should signal the appropriate worker with an interrupt signal.


\item with \texttt{:finalize} for cleanup purposes.

\end{itemize}


\hypertarget{4372656851195769827}{}


\section{Cluster Managers with Custom Transports}



Replacing the default TCP/IP all-to-all socket connections with a custom transport layer is a little more involved. Each Julia process has as many communication tasks as the workers it is connected to. For example, consider a Julia cluster of 32 processes in an all-to-all mesh network:



\begin{itemize}
\item Each Julia process thus has 31 communication tasks.


\item Each task handles all incoming messages from a single remote worker in a message-processing loop.


\item The message-processing loop waits on an \texttt{IO} object (for example, a \texttt{TCPSocket} in the default implementation), reads an entire message, processes it and waits for the next one.


\item Sending messages to a process is done directly from any Julia task–not just communication tasks–again, via the appropriate \texttt{IO} object.

\end{itemize}


Replacing the default transport requires the new implementation to set up connections to remote workers and to provide appropriate \texttt{IO} objects that the message-processing loops can wait on. The manager-specific callbacks to be implemented are:




\begin{minted}{julia}
connect(manager::FooManager, pid::Integer, config::WorkerConfig)
kill(manager::FooManager, pid::Int, config::WorkerConfig)
\end{minted}



The default implementation (which uses TCP/IP sockets) is implemented as \texttt{connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)}.



\texttt{connect} should return a pair of \texttt{IO} objects, one for reading data sent from worker \texttt{pid}, and the other to write data that needs to be sent to worker \texttt{pid}. Custom cluster managers can use an in-memory \texttt{BufferStream} as the plumbing to proxy data between the custom, possibly non-\texttt{IO} transport and Julia{\textquotesingle}s in-built parallel infrastructure.



A \texttt{BufferStream} is an in-memory \texttt{IOBuffer} which behaves like an \texttt{IO}–it is a stream which can be handled asynchronously.



Folder \texttt{examples/clustermanager/0mq} contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all \emph{logically} connected to each other–any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.



When using custom transports:



\begin{itemize}
\item Julia workers must NOT be started with \texttt{--worker}. Starting with \texttt{--worker} will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.


\item For every incoming logical connection with a worker, \texttt{Base.process\_messages(rd::IO, wr::IO)()} must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the \texttt{IO} objects.


\item \texttt{init\_worker(cookie, manager::FooManager)} MUST be called as part of worker process initialization.


\item Field \texttt{connect\_at::Any} in \texttt{WorkerConfig} can be set by the cluster manager when \hyperlink{6239708201491318480}{\texttt{launch()}} is called. The value of this field is passed in in all \hyperlink{9152037818560122293}{\texttt{connect()}} callbacks. Typically, it carries information on \emph{how to connect} to a worker. For example, the TCP/IP socket transport uses this field to specify the \texttt{(host, port)} tuple at which to connect to a worker.

\end{itemize}


\texttt{kill(manager, pid, config)} is called to remove a worker from the cluster. On the master process, the corresponding \texttt{IO} objects must be closed by the implementation to ensure proper cleanup. The default implementation simply executes an \texttt{exit()} call on the specified remote worker.



\texttt{examples/clustermanager/simple} is an example that shows a simple implementation using UNIX domain sockets for cluster setup.



\hypertarget{2286461170104731740}{}


\section{Network Requirements for LocalManager and SSHManager}



Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, or even the cloud. This section covers network security requirements for the inbuilt \texttt{LocalManager} and \texttt{SSHManager}:



\begin{itemize}
\item The master process does not listen on any port. It only connects out to the workers.


\item Each worker binds to only one of the local interfaces and listens on the first free port starting from \texttt{9009}.


\item \texttt{LocalManager}, used by \texttt{addprocs(N)}, by default binds only to the loopback interface. This means that workers started later on remote hosts (or by anyone with malicious intentions) are unable to connect to the cluster. An \texttt{addprocs(4)} followed by an \texttt{addprocs([{\textquotedbl}remote\_host{\textquotedbl}])} will fail. Some users may need to create a cluster comprising their local system and a few remote systems. This can be done by explicitly requesting \texttt{LocalManager} to bind to an external network interface via the \texttt{restrict} keyword argument: \texttt{addprocs(4; restrict=false)}.


\item \texttt{SSHManager}, used by \texttt{addprocs(list\_of\_remote\_hosts)}, launches workers on remote hosts via SSH. By default SSH is only used to launch Julia workers. Subsequent master-worker and worker-worker connections use plain, unencrypted TCP/IP sockets. The remote hosts must have passwordless login enabled. Additional SSH flags or credentials may be specified via keyword argument \texttt{sshflags}.


\item \texttt{addprocs(list\_of\_remote\_hosts; tunnel=true, sshflags=<ssh keys and other flags>)} is useful when we wish to use SSH connections for master-worker too. A typical scenario for this is a local laptop running the Julia REPL (i.e., the master) with the rest of the cluster on the cloud, say on Amazon EC2. In this case only port 22 needs to be opened at the remote cluster coupled with SSH client authenticated via public key infrastructure (PKI). Authentication credentials can be supplied via \texttt{sshflags}, for example \texttt{sshflags=`-e <keyfile>`}.

Note that worker-worker connections are still plain TCP and the local security policy on the remote cluster must allow for free connections between worker nodes, at least for ports 9009 and above.

Securing and encrypting all worker-worker traffic (via SSH) or encrypting individual messages can be done via a custom ClusterManager.

\end{itemize}


\hypertarget{11096683472832940667}{}


\section{Cluster Cookie}



All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:



\begin{itemize}
\item \hyperlink{12027223643055649570}{\texttt{Base.cluster\_cookie()}} returns the cookie, while \texttt{Base.cluster\_cookie(cookie)()} sets it and returns the new cookie.


\item All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.


\item The cookie must be passed to the workers at startup via argument \texttt{--worker <cookie>}. Custom ClusterManagers can retrieve the cookie on the master by calling \hyperlink{12027223643055649570}{\texttt{Base.cluster\_cookie()}}. Cluster managers not using the default TCP/IP transport (and hence not specifying \texttt{--worker}) must call \texttt{init\_worker(cookie, manager)} with the same cookie as on the master.

\end{itemize}


Note that environments requiring higher levels of security can implement this via a custom \texttt{ClusterManager}. For example, cookies can be pre-shared and hence not specified as a startup argument.



\hypertarget{8702505877927784954}{}


\section{Specifying Network Topology (Experimental)}



The keyword argument \texttt{topology} passed to \texttt{addprocs} is used to specify how the workers must be connected to each other:



\begin{itemize}
\item \texttt{:all\_to\_all}, the default: all workers are connected to each other.


\item \texttt{:master\_slave}: only the driver process, i.e. \texttt{pid} 1, has connections to the workers.


\item \texttt{:custom}: the \texttt{launch} method of the cluster manager specifies the connection topology via the fields \texttt{ident} and \texttt{connect\_idents} in \texttt{WorkerConfig}. A worker with a cluster-manager-provided identity \texttt{ident} will connect to all workers specified in \texttt{connect\_idents}.

\end{itemize}


Currently, sending a message between unconnected workers results in an error. This behaviour, as with the functionality and interface, should be considered experimental in nature and may change in future releases.



\hypertarget{13672791666476110942}{}


\section{Multi-Threading (Experimental)}



In addition to tasks, remote calls, and remote references, Julia from \texttt{v0.5} forwards will natively support multi-threading. Note that this section is experimental and the interfaces may change in the future.



\hypertarget{13317778601345852941}{}


\subsection{Setup}



By default, Julia starts up with a single thread of execution. This can be verified by using the command \hyperlink{11061583461116144745}{\texttt{Threads.nthreads()}}:




\begin{minted}{jlcon}
julia> Threads.nthreads()
1
\end{minted}



The number of threads Julia starts up with is controlled by an environment variable called \texttt{JULIA\_NUM\_THREADS}. Now, let{\textquotesingle}s start up Julia with 4 threads:




\begin{lstlisting}
export JULIA_NUM_THREADS=4
\end{lstlisting}



(The above command works on bourne shells on Linux and OSX. Note that if you{\textquotesingle}re using a C shell on these platforms, you should use the keyword \texttt{set} instead of \texttt{export}. If you{\textquotesingle}re on Windows, start up the command line in the location of \texttt{julia.exe} and use \texttt{set} instead of \texttt{export}.)



Let{\textquotesingle}s verify there are 4 threads at our disposal.




\begin{minted}{jlcon}
julia> Threads.nthreads()
4
\end{minted}



But we are currently on the master thread. To check, we use the command \hyperlink{12668125807854133993}{\texttt{Threads.threadid()}}




\begin{minted}{jlcon}
julia> Threads.threadid()
1
\end{minted}



\hypertarget{7114907478769739437}{}


\subsection{The \texttt{@threads} Macro}



Let{\textquotesingle}s work a simple example using our native threads. Let us create an array of zeros:




\begin{minted}{jlcon}
julia> a = zeros(10)
10-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
\end{minted}



Let us operate on this array simultaneously using 4 threads. We{\textquotesingle}ll have each thread write its thread ID into each location.



Julia supports parallel loops using the \hyperlink{15582842999596899869}{\texttt{Threads.@threads}} macro. This macro is affixed in front of a \texttt{for} loop to indicate to Julia that the loop is a multi-threaded region:




\begin{minted}{jlcon}
julia> Threads.@threads for i = 1:10
           a[i] = Threads.threadid()
       end
\end{minted}



The iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations:




\begin{minted}{jlcon}
julia> a
10-element Array{Float64,1}:
 1.0
 1.0
 1.0
 2.0
 2.0
 2.0
 3.0
 3.0
 4.0
 4.0
\end{minted}



Note that \hyperlink{15582842999596899869}{\texttt{Threads.@threads}} does not have an optional reduction parameter like \hyperlink{11870389661093259741}{\texttt{@parallel}}.



\hypertarget{4888104675376389648}{}


\section{@threadcall (Experimental)}



All I/O tasks, timers, REPL commands, etc are multiplexed onto a single OS thread via an event loop. A patched version of libuv (\href{http://docs.libuv.org/en/v1.x/}{http://docs.libuv.org/en/v1.x/}) provides this functionality. Yield points provide for co-operatively scheduling multiple tasks onto the same OS thread. I/O tasks and timers yield implicitly while waiting for the event to occur. Calling \hyperlink{13455314829114364187}{\texttt{yield()}} explicitly allows for other tasks to be scheduled.



Thus, a task executing a \hyperlink{14245046751182637566}{\texttt{ccall}} effectively prevents the Julia scheduler from executing any other tasks till the call returns. This is true for all calls into external libraries. Exceptions are calls into custom C code that call back into Julia (which may then yield) or C code that calls \texttt{jl\_yield()} (C equivalent of \hyperlink{13455314829114364187}{\texttt{yield()}}).



Note that while Julia code runs on a single thread (by default), libraries used by Julia may launch their own internal threads. For example, the BLAS library may start as many threads as there are cores on a machine.



The \texttt{@threadcall} macro addresses scenarios where we do not want a \texttt{ccall} to block the main Julia event loop. It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is controlled via environment variable \texttt{UV\_THREADPOOL\_SIZE}. While waiting for a free thread, and during function execution once a thread is available, the requesting task (on the main Julia event loop) yields to other tasks. Note that \texttt{@threadcall} does not return till the execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs.



It is very important that the called function does not call back into Julia.



\texttt{@threadcall} may be removed/changed in future versions of Julia.



\footnotetext[1]{In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding RMA to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see \href{http://mpi-forum.org/docs/}{http://mpi-forum.org/docs}.

}


\hypertarget{14708268282391318496}{}


\chapter{Date and DateTime}





The \texttt{Dates} module provides two types for working with dates: \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}}, representing day and millisecond precision, respectively; both are subtypes of the abstract \hyperlink{10402032810188745271}{\texttt{TimeType}}. The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don{\textquotesingle}t have to be dealt with. For example, since the \hyperlink{5911165232663997394}{\texttt{Date}} type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.



Both \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} are basically immutable \hyperlink{7720564657383125058}{\texttt{Int64}} wrappers. The single \texttt{instant} field of either type is actually a \texttt{UTInstant\{P\}} type, which represents a continuously increasing machine timeline based on the UT second \footnotemark[1]. The \hyperlink{8865912400344885633}{\texttt{DateTime}} type is not aware of time zones (\emph{naive}, in Python parlance), analogous to a \emph{LocalDateTime} in Java 8. Additional time zone functionality can be added through the \href{https://github.com/JuliaTime/TimeZones.jl/}{TimeZones.jl package}, which compiles the \href{http://www.iana.org/time-zones}{IANA time zone database}. Both \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} are based on the \href{https://en.wikipedia.org/wiki/ISO\_8601}{ISO 8601} standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so \texttt{0000-12-31} is the day before \texttt{0001-01-01}, and year \texttt{-0001} (yes, negative one for the year) is 2 BC/BCE, year \texttt{-0002} is 3 BC/BCE, etc.



\footnotetext[1]{The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a {\textquotedbl}UT second{\textquotedbl}, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called \href{https://en.wikipedia.org/wiki/Universal\_Time}{UT} or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.

}


\hypertarget{3597362352537600414}{}


\section{Constructors}



\hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} types can be constructed by integer or \hyperlink{14377501606406826094}{\texttt{Period}} types, by parsing, or through adjusters (more on those later):




\begin{minted}{jlcon}
julia> DateTime(2013)
2013-01-01T00:00:00

julia> DateTime(2013,7)
2013-07-01T00:00:00

julia> DateTime(2013,7,1)
2013-07-01T00:00:00

julia> DateTime(2013,7,1,12)
2013-07-01T12:00:00

julia> DateTime(2013,7,1,12,30)
2013-07-01T12:30:00

julia> DateTime(2013,7,1,12,30,59)
2013-07-01T12:30:59

julia> DateTime(2013,7,1,12,30,59,1)
2013-07-01T12:30:59.001

julia> Date(2013)
2013-01-01

julia> Date(2013,7)
2013-07-01

julia> Date(2013,7,1)
2013-07-01

julia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))
2013-07-01

julia> Date(Dates.Month(7),Dates.Year(2013))
2013-07-01
\end{minted}



\hyperlink{5911165232663997394}{\texttt{Date}} or \hyperlink{8865912400344885633}{\texttt{DateTime}} parsing is accomplished by the use of format strings. Format strings work by the notion of defining \emph{delimited} or \emph{fixed-width} {\textquotedbl}slots{\textquotedbl} that contain a period to parse and passing the text to parse and format string to a \hyperlink{5911165232663997394}{\texttt{Date}} or \hyperlink{8865912400344885633}{\texttt{DateTime}} constructor, of the form \texttt{Date({\textquotedbl}2015-01-01{\textquotedbl},{\textquotedbl}y-m-d{\textquotedbl})} or \texttt{DateTime({\textquotedbl}20150101{\textquotedbl},{\textquotedbl}yyyymmdd{\textquotedbl})}.



Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so \texttt{{\textquotedbl}y-m-d{\textquotedbl}} lets the parser know that between the first and second slots in a date string like \texttt{{\textquotedbl}2014-07-16{\textquotedbl}}, it should find the \texttt{-} character. The \texttt{y}, \texttt{m}, and \texttt{d} characters let the parser know which periods to parse in each slot.



Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So \texttt{{\textquotedbl}yyyymmdd{\textquotedbl}} would correspond to a date string like \texttt{{\textquotedbl}20140716{\textquotedbl}}. The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition \texttt{{\textquotedbl}yyyymm{\textquotedbl}} from one period character to the next.



Support for text-form month parsing is also supported through the \texttt{u} and \texttt{U} characters, for abbreviated and full-length month names, respectively. By default, only English month names are supported, so \texttt{u} corresponds to {\textquotedbl}Jan{\textquotedbl}, {\textquotedbl}Feb{\textquotedbl}, {\textquotedbl}Mar{\textquotedbl}, etc. And \texttt{U} corresponds to {\textquotedbl}January{\textquotedbl}, {\textquotedbl}February{\textquotedbl}, {\textquotedbl}March{\textquotedbl}, etc. Similar to other name=>value mapping functions \hyperlink{3340143850480916413}{\texttt{dayname()}} and \hyperlink{12803026364514696452}{\texttt{monthname()}}, custom locales can be loaded by passing in the \texttt{locale=>Dict\{String,Int\}} mapping to the \texttt{MONTHTOVALUEABBR} and \texttt{MONTHTOVALUE} dicts for abbreviated and full-name month names, respectively.



One note on parsing performance: using the \texttt{Date(date\_string,format\_string)} function is fine if only called a few times. If there are many similarly formatted date strings to parse however, it is much more efficient to first create a \hyperlink{18366440545577280750}{\texttt{Dates.DateFormat}}, and pass it instead of a raw format string.




\begin{minted}{jlcon}
julia> df = DateFormat("y-m-d");

julia> dt = Date("2015-01-01",df)
2015-01-01

julia> dt2 = Date("2015-01-02",df)
2015-01-02
\end{minted}



You can also use the \texttt{dateformat{\textquotedbl}{\textquotedbl}} string macro. This macro creates the \texttt{DateFormat} object once when the macro is expanded and uses the same \texttt{DateFormat} object even if a code snippet is run multiple times.




\begin{minted}{jlcon}
julia> for i = 1:10^5
           Date("2015-01-01", dateformat"y-m-d")
       end
\end{minted}



A full suite of parsing and formatting tests and examples is available in \href{https://github.com/JuliaLang/julia/blob/release-0.6/test/dates/io.jl}{\texttt{tests/dates/io.jl}}.



\hypertarget{9675062304126123157}{}


\section{Durations/Comparisons}



Finding the length of time between two \hyperlink{5911165232663997394}{\texttt{Date}} or \hyperlink{8865912400344885633}{\texttt{DateTime}} is straightforward given their underlying representation as \texttt{UTInstant\{Day\}} and \texttt{UTInstant\{Millisecond\}}, respectively. The difference between \hyperlink{5911165232663997394}{\texttt{Date}} is returned in the number of \hyperlink{5199769942291019025}{\texttt{Day}}, and \hyperlink{8865912400344885633}{\texttt{DateTime}} in the number of \hyperlink{2512115765177421351}{\texttt{Millisecond}}. Similarly, comparing \hyperlink{10402032810188745271}{\texttt{TimeType}} is a simple matter of comparing the underlying machine instants (which in turn compares the internal \hyperlink{7720564657383125058}{\texttt{Int64}} values).




\begin{minted}{jlcon}
julia> dt = Date(2012,2,29)
2012-02-29

julia> dt2 = Date(2000,2,1)
2000-02-01

julia> dump(dt)
Date
  instant: Base.Dates.UTInstant{Base.Dates.Day}
    periods: Base.Dates.Day
      value: Int64 734562

julia> dump(dt2)
Date
  instant: Base.Dates.UTInstant{Base.Dates.Day}
    periods: Base.Dates.Day
      value: Int64 730151

julia> dt > dt2
true

julia> dt != dt2
true

julia> dt + dt2
ERROR: MethodError: no method matching +(::Date, ::Date)
[...]

julia> dt * dt2
ERROR: MethodError: no method matching *(::Date, ::Date)
[...]

julia> dt / dt2
ERROR: MethodError: no method matching /(::Date, ::Date)
[...]

julia> dt - dt2
4411 days

julia> dt2 - dt
-4411 days

julia> dt = DateTime(2012,2,29)
2012-02-29T00:00:00

julia> dt2 = DateTime(2000,2,1)
2000-02-01T00:00:00

julia> dt - dt2
381110400000 milliseconds
\end{minted}



\hypertarget{15274886386548419130}{}


\section{Accessor Functions}



Because the \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} types are stored as single \hyperlink{7720564657383125058}{\texttt{Int64}} values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:




\begin{lstlisting}
julia> t = Date(2014, 1, 31)
2014-01-31

julia> Dates.year(t)
2014

julia> Dates.month(t)
1

julia> Dates.week(t)
5

julia> Dates.day(t)
31
\end{lstlisting}



While propercase return the same value in the corresponding \hyperlink{14377501606406826094}{\texttt{Period}} type:




\begin{lstlisting}
julia> Dates.Year(t)
2014 years

julia> Dates.Day(t)
31 days
\end{lstlisting}



Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:




\begin{lstlisting}
julia> Dates.yearmonth(t)
(2014, 1)

julia> Dates.monthday(t)
(1, 31)

julia> Dates.yearmonthday(t)
(2014, 1, 31)
\end{lstlisting}



One may also access the underlying \texttt{UTInstant} or integer value:




\begin{lstlisting}
julia> dump(t)
Date
  instant: Base.Dates.UTInstant{Base.Dates.Day}
    periods: Base.Dates.Day
      value: Int64 735264

julia> t.instant
Base.Dates.UTInstant{Base.Dates.Day}(735264 days)

julia> Dates.value(t)
735264
\end{lstlisting}



\hypertarget{16158364891045757229}{}


\section{Query Functions}



Query functions provide calendrical information about a \hyperlink{10402032810188745271}{\texttt{TimeType}}. They include information about the day of the week:




\begin{lstlisting}
julia> t = Date(2014, 1, 31)
2014-01-31

julia> Dates.dayofweek(t)
5

julia> Dates.dayname(t)
"Friday"

julia> Dates.dayofweekofmonth(t) # 5th Friday of January
5
\end{lstlisting}



Month of the year:




\begin{lstlisting}
julia> Dates.monthname(t)
"January"

julia> Dates.daysinmonth(t)
31
\end{lstlisting}



As well as information about the \hyperlink{10402032810188745271}{\texttt{TimeType}}{\textquotesingle}s year and quarter:




\begin{lstlisting}
julia> Dates.isleapyear(t)
false

julia> Dates.dayofyear(t)
31

julia> Dates.quarterofyear(t)
1

julia> Dates.dayofquarter(t)
31
\end{lstlisting}



The \hyperlink{3340143850480916413}{\texttt{dayname()}} and \hyperlink{12803026364514696452}{\texttt{monthname()}} methods can also take an optional \texttt{locale} keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely \hyperlink{2563884892429498349}{\texttt{dayabbr()}} and \hyperlink{1979988737860589713}{\texttt{monthabbr()}}. First the mapping is loaded into the \texttt{LOCALES} variable:




\begin{lstlisting}
julia> french_months = ["janvier", "février", "mars", "avril", "mai", "juin",
                        "juillet", "août", "septembre", "octobre", "novembre", "décembre"];

julia> french_monts_abbrev = ["janv","févr","mars","avril","mai","juin",
                              "juil","août","sept","oct","nov","déc"];

julia> french_days = ["lundi","mardi","mercredi","jeudi","vendredi","samedi","dimanche"];

julia> Dates.LOCALES["french"] = Dates.DateLocale(french_months, french_monts_abbrev, french_days, [""]);
\end{lstlisting}



The above mentioned functions can then be used to perform the queries:




\begin{lstlisting}
julia> Dates.dayname(t;locale="french")
"vendredi"

julia> Dates.monthname(t;locale="french")
"janvier"

julia> Dates.monthabbr(t;locale="french")
"janv"
\end{lstlisting}



Since the abbreviated versions of the days are not loaded, trying to use the function \texttt{dayabbr()} will error.




\begin{lstlisting}
julia> Dates.dayabbr(t;locale="french")
ERROR: BoundsError: attempt to access 1-element Array{String,1} at index [5]
Stacktrace:
 [1] #dayabbr#6(::String, ::Function, ::Int64) at ./dates/query.jl:114
 [2] (::Base.Dates.#kw##dayabbr)(::Array{Any,1}, ::Base.Dates.#dayabbr, ::Int64) at ./<missing>:0 (repeats 2 times)
\end{lstlisting}



\hypertarget{10010400361329749456}{}


\section{TimeType-Period Arithmetic}



It{\textquotesingle}s good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some \href{https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/}{tricky issues} to deal with (though much less so for day-precision types).



The \texttt{Dates} module approach tries to follow the simple principle of trying to change as little as possible when doing \hyperlink{14377501606406826094}{\texttt{Period}} arithmetic. This approach is also often known as \emph{calendrical} arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let{\textquotesingle}s take a classic example: add 1 month to January 31st, 2014. What{\textquotesingle}s the answer? Javascript will say \href{http://www.markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/}{March 3} (assumes 31 days). PHP says \href{http://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month}{March 2} (assumes 30 days). The fact is, there is no right answer. In the \texttt{Dates} module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.



Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, \texttt{2014-02-28 + Month(1) == 2014-03-28}. What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we{\textquotesingle}re done because that{\textquotesingle}s a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:




\begin{minted}{jlcon}
julia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)
2014-02-28

julia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)
2014-03-01
\end{minted}



What{\textquotesingle}s going on there? In the first line, we{\textquotesingle}re adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28. In the second example, we add 1 month \emph{first}, where we get 2014-02-29, which adjusts down to 2014-02-28, and \emph{then} add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods, the operations will be ordered by the Periods{\textquotesingle} \emph{types}, not their value or positional order; this means \texttt{Year} will always be added first, then \texttt{Month}, then \texttt{Week}, etc. Hence the following \emph{does} result in associativity and Just Works:




\begin{minted}{jlcon}
julia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)
2014-03-01

julia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)
2014-03-01
\end{minted}



Tricky? Perhaps. What is an innocent \texttt{Dates} user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that{\textquotesingle}s pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the {\textquotedbl}joys{\textquotedbl} of dealing with daylight savings, leap seconds, etc.).



As a bonus, all period arithmetic objects work directly with ranges:




\begin{minted}{jlcon}
julia> dr = Date(2014,1,29):Date(2014,2,3)
2014-01-29:1 day:2014-02-03

julia> collect(dr)
6-element Array{Date,1}:
 2014-01-29
 2014-01-30
 2014-01-31
 2014-02-01
 2014-02-02
 2014-02-03

julia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)
2014-01-29:1 month:2014-07-29

julia> collect(dr)
7-element Array{Date,1}:
 2014-01-29
 2014-02-28
 2014-03-29
 2014-04-29
 2014-05-29
 2014-06-29
 2014-07-29
\end{minted}



\hypertarget{13551592780469201884}{}


\section{Adjuster Functions}



As convenient as date-period arithmetics are, often the kinds of calculations needed on dates take on a \emph{calendrical} or \emph{temporal} nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as {\textquotedbl}Memorial Day = Last Monday of May{\textquotedbl}, or {\textquotedbl}Thanksgiving = 4th Thursday of November{\textquotedbl}. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.



The \texttt{Dates} module provides the \emph{adjuster} API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single \hyperlink{10402032810188745271}{\texttt{TimeType}} as input and return or \emph{adjust to} the first or last of the desired period relative to the input.




\begin{minted}{jlcon}
julia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input's week
2014-07-14

julia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input's month
2014-07-31

julia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input's quarter
2014-09-30
\end{minted}



The next two higher-order methods, \hyperlink{17409471999654347609}{\texttt{tonext()}}, and \hyperlink{7599972091906648015}{\texttt{toprev()}}, generalize working with temporal expressions by taking a \texttt{DateFunction} as first argument, along with a starting \hyperlink{10402032810188745271}{\texttt{TimeType}}. A \texttt{DateFunction} is just a function, usually anonymous, that takes a single \hyperlink{10402032810188745271}{\texttt{TimeType}} as input and returns a \hyperlink{46725311238864537}{\texttt{Bool}}, \texttt{true} indicating a satisfied adjustment criterion. For example:




\begin{minted}{jlcon}
julia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday # Returns true if the day of the week of x is Tuesday
(::#1) (generic function with 1 method)

julia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 is a Sunday
2014-07-15

julia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # Convenience method provided for day of the week adjustments
2014-07-15
\end{minted}



This is useful with the do-block syntax for more complex temporal expressions:




\begin{minted}{jlcon}
julia> Dates.tonext(Date(2014,7,13)) do x
           # Return true on the 4th Thursday of November (Thanksgiving)
           Dates.dayofweek(x) == Dates.Thursday &&
           Dates.dayofweekofmonth(x) == 4 &&
           Dates.month(x) == Dates.November
       end
2014-11-27
\end{minted}



The \hyperlink{11445961893478569145}{\texttt{Base.filter()}} method can be used to obtain all valid dates/moments in a specified range:




\begin{minted}{jlcon}
# Pittsburgh street cleaning; Every 2nd Tuesday from April to November
# Date range from January 1st, 2014 to January 1st, 2015
julia> dr = Dates.Date(2014):Dates.Date(2015);

julia> filter(dr) do x
           Dates.dayofweek(x) == Dates.Tue &&
           Dates.April <= Dates.month(x) <= Dates.Nov &&
           Dates.dayofweekofmonth(x) == 2
       end
8-element Array{Date,1}:
 2014-04-08
 2014-05-13
 2014-06-10
 2014-07-08
 2014-08-12
 2014-09-09
 2014-10-14
 2014-11-11
\end{minted}



Additional examples and tests are available in \href{https://github.com/JuliaLang/julia/blob/release-0.6/test/dates/adjusters.jl}{\texttt{test/dates/adjusters.jl}}.



\hypertarget{6665623146623573170}{}


\section{Period Types}



Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context. Or a year could represent 365 or 366 days in the case of a leap year. \hyperlink{14377501606406826094}{\texttt{Period}} types are simple \hyperlink{7720564657383125058}{\texttt{Int64}} wrappers and are constructed by wrapping any \texttt{Int64} convertible type, i.e. \texttt{Year(1)} or \texttt{Month(3.0)}. Arithmetic between \hyperlink{14377501606406826094}{\texttt{Period}} of the same type behave like integers, and limited \texttt{Period-Real} arithmetic is available.




\begin{minted}{jlcon}
julia> y1 = Dates.Year(1)
1 year

julia> y2 = Dates.Year(2)
2 years

julia> y3 = Dates.Year(10)
10 years

julia> y1 + y2
3 years

julia> div(y3,y2)
5

julia> y3 - y2
8 years

julia> y3 % y2
0 years

julia> div(y3,3) # mirrors integer division
3 years
\end{minted}



\hypertarget{12464510960418657842}{}


\section{Rounding}



\hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with \hyperlink{13948277906659863497}{\texttt{floor()}}, \hyperlink{11509984064218511874}{\texttt{ceil()}}, or \hyperlink{7894166454005036294}{\texttt{round()}}:




\begin{minted}{jlcon}
julia> floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia> round(DateTime(2016, 8, 6, 20, 15), Dates.Day)
2016-08-07T00:00:00
\end{minted}



Unlike the numeric \hyperlink{7894166454005036294}{\texttt{round()}} method, which breaks ties toward the even number by default, the \hyperlink{10402032810188745271}{\texttt{TimeType}}\hyperlink{7894166454005036294}{\texttt{round()}} method uses the \texttt{RoundNearestTiesUp} rounding mode. (It{\textquotesingle}s difficult to guess what breaking ties to nearest {\textquotedbl}even{\textquotedbl} \hyperlink{10402032810188745271}{\texttt{TimeType}} would entail.) Further details on the available \texttt{RoundingMode} s can be found in the \hyperlink{11995623453970199783}{API reference}.



Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is not obvious.



\hypertarget{18235125897086797691}{}


\subsection{Rounding Epoch}



In many cases, the resolution specified for rounding (e.g., \texttt{Dates.Second(30)}) divides evenly into the next largest period (in this case, \texttt{Dates.Minute(1)}). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a \hyperlink{8865912400344885633}{\texttt{DateTime}} to the nearest 10 hours?




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))
2016-07-17T12:00:00
\end{minted}



That may seem confusing, given that the hour (12) is not divisible by 10. The reason that \texttt{2016-07-17T12:00:00} was chosen is that it is 17,676,660 hours after \texttt{0000-01-01T00:00:00}, and 17,676,660 is divisible by 10.



As Julia \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} values are represented according to the ISO 8601 standard, \texttt{0000-01-01T00:00:00} was chosen as base (or {\textquotedbl}rounding epoch{\textquotedbl}) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia{\textquotesingle}s internal representation of \hyperlink{5911165232663997394}{\texttt{Date}} s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, \texttt{0000-01-01T00:00:00} was chosen as the rounding epoch instead of the \texttt{0000-12-31T00:00:00} used internally to minimize confusion.)



The only exception to the use of \texttt{0000-01-01T00:00:00} as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use \texttt{0000-01-03T00:00:00} (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.



Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest \texttt{P(2)}, where \texttt{P} is a \hyperlink{14377501606406826094}{\texttt{Period}} type? In some cases (specifically, when \texttt{P <: Dates.TimePeriod}) the answer is clear:




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))
2016-07-17T08:00:00

julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))
2016-07-17T08:56:00
\end{minted}



This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))
2016-07-01T00:00:00
\end{minted}



Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0).



This means that rounding a \hyperlink{8865912400344885633}{\texttt{DateTime}} to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a \hyperlink{8865912400344885633}{\texttt{DateTime}} with an even value in that field, while rounding a \hyperlink{8865912400344885633}{\texttt{DateTime}} to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.



See the \hyperlink{11995623453970199783}{API reference} for additional information on methods exported from the \texttt{Dates} module.



\hypertarget{9220662049678686366}{}


\chapter{Interacting With Julia}



Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the \texttt{julia} executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling \texttt{julia} with no arguments or double-clicking on the executable:




\begin{lstlisting}
$ julia
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org
   _ _   _| |_  __ _   |  Type "?help" for help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 0.6.0-dev.2493 (2017-01-31 18:53 UTC)
 _/ |\__'_|_|_|\__'_|  |  Commit c99e12c* (0 days old master)
|__/                   |  x86_64-linux-gnu

julia>
\end{lstlisting}



To exit the interactive session, type \texttt{{\textasciicircum}D} – the control key together with the \texttt{d} key on a blank line – or type \texttt{quit()} followed by the return or enter key. The REPL greets you with a banner and a \texttt{julia>} prompt.



\hypertarget{3373315244675036651}{}


\section{The different prompt modes}



\hypertarget{3833232147615596628}{}


\subsection{The Julian mode}



The REPL has four main modes of operation. The first and most common is the Julian prompt. It is the default mode of operation; each new line initially starts with \texttt{julia>}. It is here that you can enter Julia expressions. Hitting return or enter after a complete expression has been entered will evaluate the entry and show the result of the last expression.




\begin{minted}{jlcon}
julia> string(1 + 2)
"3"
\end{minted}



There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the variable \texttt{ans}. A trailing semicolon on the line can be used as a flag to suppress showing the result.




\begin{minted}{jlcon}
julia> string(3 * 4);

julia> ans
"12"
\end{minted}



In Julia mode, the REPL supports something called \emph{prompt pasting}. This activates when pasting text that starts with \texttt{julia> } into the REPL. In that case, only expressions starting with \texttt{julia> } are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with \texttt{Base.REPL.enable\_promptpaste(::Bool)}. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.



\hypertarget{8090123169740528583}{}


\subsection{Help mode}



When the cursor is at the beginning of the line, the prompt can be changed to a help mode by typing \texttt{?}. Julia will attempt to print help or documentation for anything entered in help mode:




\begin{minted}{jlcon}
julia> ? # upon typing ?, the prompt changes (in place) to: help?>

help?> string
search: string String stringmime Cstring Cwstring RevString readstring randstring bytestring SubString

  string(xs...)

  Create a string from any values using the print function.
\end{minted}



Macros, types and variables can also be queried:




\begin{lstlisting}
help?> @time
  @time

  A macro to execute an expression, printing the time it took to execute, the number of allocations,
  and the total number of bytes its execution caused to be allocated, before returning the value of the
  expression.

  See also @timev, @timed, @elapsed, and @allocated.

help?> AbstractString
search: AbstractString AbstractSparseMatrix AbstractSparseVector AbstractSet

  No documentation found.

  Summary:

  abstract AbstractString <: Any

  Subtypes:

  Base.Test.GenericString
  DirectIndexString
  String
\end{lstlisting}



Help mode can be exited by pressing backspace at the beginning of the line.



\hypertarget{17654100848947676892}{}


\subsection{Shell mode}



Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as \texttt{?} entered help mode when at the beginning of the line, a semicolon (\texttt{;}) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.




\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> echo hello
hello
\end{minted}



\hypertarget{13961930499248375782}{}


\subsection{Search modes}



In all of the above modes, the executed lines get saved to a history file, which can be searched.  To initiate an incremental search through the previous history, type \texttt{{\textasciicircum}R} – the control key together with the \texttt{r} key. The prompt will change to \texttt{(reverse-i-search)`{\textquotesingle}:}, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type \texttt{{\textasciicircum}R} again.



Just as \texttt{{\textasciicircum}R} is a reverse search, \texttt{{\textasciicircum}S} is a forward search, with the prompt \texttt{(i-search)`{\textquotesingle}:}.  The two may be used in conjunction with each other to move through the previous or next matching results, respectively.



\hypertarget{11229238099061625177}{}


\section{Key bindings}



The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (\texttt{{\textasciicircum}D} to exit, \texttt{{\textasciicircum}R} and \texttt{{\textasciicircum}S} for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so).




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Keybinding & Description \\
\hline
\textbf{Program control} &   \\
\hline
\texttt{{\textasciicircum}D} & Exit (when buffer is empty) \\
\hline
\texttt{{\textasciicircum}C} & Interrupt or cancel \\
\hline
\texttt{{\textasciicircum}L} & Clear console screen \\
\hline
Return/Enter, \texttt{{\textasciicircum}J} & New line, executing if it is complete \\
\hline
meta-Return/Enter & Insert new line without executing it \\
\hline
\texttt{?} or \texttt{;} & Enter help or shell mode (when at start of a line) \\
\hline
\texttt{{\textasciicircum}R}, \texttt{{\textasciicircum}S} & Incremental history search, described above \\
\hline
\textbf{Cursor movement} &   \\
\hline
Right arrow, \texttt{{\textasciicircum}F} & Move right one character \\
\hline
Left arrow, \texttt{{\textasciicircum}B} & Move left one character \\
\hline
Home, \texttt{{\textasciicircum}A} & Move to beginning of line \\
\hline
End, \texttt{{\textasciicircum}E} & Move to end of line \\
\hline
\texttt{{\textasciicircum}P} & Change to the previous or next history entry \\
\hline
\texttt{{\textasciicircum}N} & Change to the next history entry \\
\hline
Up arrow & Move up one line (or to the previous history entry) \\
\hline
Down arrow & Move down one line (or to the next history entry) \\
\hline
Page-up & Change to the previous history entry that matches the text before the cursor \\
\hline
Page-down & Change to the next history entry that matches the text before the cursor \\
\hline
\texttt{meta-F} & Move right one word \\
\hline
\texttt{meta-B} & Move left one word \\
\hline
\textbf{Editing} &   \\
\hline
Backspace, \texttt{{\textasciicircum}H} & Delete the previous character \\
\hline
Delete, \texttt{{\textasciicircum}D} & Forward delete one character (when buffer has text) \\
\hline
meta-Backspace & Delete the previous word \\
\hline
\texttt{meta-D} & Forward delete the next word \\
\hline
\texttt{{\textasciicircum}W} & Delete previous text up to the nearest whitespace \\
\hline
\texttt{{\textasciicircum}K} & {\textquotedbl}Kill{\textquotedbl} to end of line, placing the text in a buffer \\
\hline
\texttt{{\textasciicircum}Y} & {\textquotedbl}Yank{\textquotedbl} insert the text from the kill buffer \\
\hline
\texttt{{\textasciicircum}T} & Transpose the characters about the cursor \\
\hline
\texttt{{\textasciicircum}Q} & Write a number in REPL and press \texttt{{\textasciicircum}Q} to open editor at corresponding stackframe \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12600332236460824227}{}


\subsection{Customizing keybindings}



Julia{\textquotesingle}s REPL keybindings may be fully customized to a user{\textquotesingle}s preferences by passing a dictionary to \texttt{REPL.setup\_interface()}. The keys of this dictionary may be characters or strings. The key \texttt{{\textquotesingle}*{\textquotesingle}} refers to the default action. Control plus character \texttt{x} bindings are indicated with \texttt{{\textquotedbl}{\textasciicircum}x{\textquotedbl}}. Meta plus \texttt{x} can be written \texttt{{\textquotedbl}{\textbackslash}{\textbackslash}Mx{\textquotedbl}}. The values of the custom keymap must be \texttt{nothing} (indicating that the input should be ignored) or functions that accept the signature \texttt{(PromptState, AbstractREPL, Char)}. The \texttt{REPL.setup\_interface()} function must be called before the REPL is initialized, by registering the operation with \texttt{atreplinit()}. For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in \texttt{.juliarc.jl}:




\begin{minted}{julia}
import Base: LineEdit, REPL

const mykeys = Dict{Any,Any}(
    # Up Arrow
    "\e[A" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),
    # Down Arrow
    "\e[B" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))
)

function customize_keys(repl)
    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)
end

atreplinit(customize_keys)
\end{minted}



Users should refer to \texttt{base/LineEdit.jl} to discover the available actions on key input.



\hypertarget{9567689438493430677}{}


\section{Tab completion}



In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:




\begin{minted}{jlcon}
julia> stri[TAB]
stride     strides     string      stringmime  strip

julia> Stri[TAB]
StridedArray    StridedMatrix    StridedVecOrMat  StridedVector    String
\end{minted}



The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:




\begin{minted}{jlcon}
julia> \pi[TAB]
julia> π
π = 3.1415926535897...

julia> e\_1[TAB] = [1,0]
julia> e₁ = [1,0]
2-element Array{Int64,1}:
 1
 0

julia> e\^1[TAB] = [1 0]
julia> e¹ = [1 0]
1×2 Array{Int64,2}:
 1  0

julia> \sqrt[TAB]2     # √ is equivalent to the sqrt() function
julia> √2
1.4142135623730951

julia> \hbar[TAB](h) = h / 2\pi[TAB]
julia> ħ(h) = h / 2π
ħ (generic function with 1 method)

julia> \h[TAB]
\hat              \hermitconjmatrix  \hkswarow          \hrectangle
\hatapprox        \hexagon           \hookleftarrow     \hrectangleblack
\hbar             \hexagonblack      \hookrightarrow    \hslash
\heartsuit        \hksearow          \house             \hspace

julia> α="\alpha[TAB]"   # LaTeX completion also works in strings
julia> α="α"
\end{minted}



A full list of tab-completions can be found in the \hyperlink{7696893994298815226}{Unicode Input} section of the manual.



Completion of paths works for strings and julia{\textquotesingle}s shell mode:




\begin{minted}{jlcon}
julia> path="/[TAB]"
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
shell> /[TAB]
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
\end{minted}



Tab completion can help with investigation of the available methods matching the input arguments:




\begin{minted}{jlcon}
julia> max([TAB] # All methods are displayed, not shown here due to size of the list

julia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument
max(x, y) in Base at operators.jl:215
max(a, b, c, xs...) in Base at operators.jl:281

julia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.
max(x, y) in Base at operators.jl:215
max(a, b, c, xs...) in Base at operators.jl:281
\end{minted}



Keywords are also displayed in the suggested methods, see second line after \texttt{;} where \texttt{limit} and \texttt{keep} are keyword arguments:




\begin{minted}{jlcon}
julia> split("1 1 1", [TAB]
split(str::AbstractString) in Base at strings/util.jl:278
split{T<:AbstractString}(str::T, splitter; limit, keep) in Base at strings/util.jl:254
\end{minted}



The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.



Tab completion can also help completing fields:




\begin{minted}{jlcon}
julia> Pkg.a[TAB]
add       available
\end{minted}



Fields for output from functions can also be completed:




\begin{minted}{jlcon}
julia> split("","")[1].[TAB]
endof  offset  string
\end{minted}



The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.



\hypertarget{17268458035861597176}{}


\section{Customizing Colors}



The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your \texttt{.juliarc.jl} file, which is to be placed inside your home directory:




\begin{minted}{julia}
function customize_colors(repl)
    repl.prompt_color = Base.text_colors[:cyan]
end

atreplinit(customize_colors)
\end{minted}



The available color keys can be seen by typing \texttt{Base.text\_colors} in the help mode of the REPL. In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.



You can also change the colors for the help and shell prompts and input and answer text by setting the appropriate field of \texttt{repl} in the \texttt{customize\_colors} function above (respectively, \texttt{help\_color}, \texttt{shell\_color}, \texttt{input\_color}, and \texttt{answer\_color}). For the latter two, be sure that the \texttt{envcolors} field is also set to false.



It is also possible to apply boldface formatting by using \texttt{Base.text\_colors[:bold]} as a color. For instance, to print answers in boldface font, one can use the following as a \texttt{.juliarc.jl}:




\begin{minted}{julia}
function customize_colors(repl)
    repl.envcolors = false
    repl.answer_color = Base.text_colors[:bold]
end

atreplinit(customize_colors)
\end{minted}



You can also customize the color used to render warning and informational messages by setting the appropriate environment variables. For instance, to render error, warning, and informational messages respectively in magenta, yellow, and cyan you can add the following to your \texttt{.juliarc.jl} file:




\begin{minted}{julia}
ENV["JULIA_ERROR_COLOR"] = :magenta
ENV["JULIA_WARN_COLOR"] = :yellow
ENV["JULIA_INFO_COLOR"] = :cyan
\end{minted}



\hypertarget{11862922961978750349}{}


\chapter{Running External Programs}



Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing




\begin{minted}{jlcon}
julia> `echo hello`
`echo hello`
\end{minted}



differs in several aspects from the behavior in various shells, Perl, or Ruby:



\begin{itemize}
\item Instead of immediately running the command, backticks create a \texttt{Cmd} object to represent the command. You can use this object to connect the command to others via pipes, run it, and read or write to it.


\item When the command is run, Julia does not capture its output unless you specifically arrange for it to. Instead, the output of the command by default goes to \hyperlink{2784333101804678420}{\texttt{STDOUT}} as it would using \texttt{libc}{\textquotesingle}s \texttt{system} call.


\item The command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax. The command is run as \texttt{julia}{\textquotesingle}s immediate child process, using \texttt{fork} and \texttt{exec} calls.

\end{itemize}


Here{\textquotesingle}s a simple example of running an external program:




\begin{minted}{jlcon}
julia> mycommand = `echo hello`
`echo hello`

julia> typeof(mycommand)
Cmd

julia> run(mycommand)
hello
\end{minted}



The \texttt{hello} is the output of the \texttt{echo} command, sent to \hyperlink{2784333101804678420}{\texttt{STDOUT}}. The run method itself returns \texttt{nothing}, and throws an \hyperlink{12102596058483452470}{\texttt{ErrorException}} if the external command fails to run successfully.



If you want to read the output of the external command, \hyperlink{6219586633767848672}{\texttt{readstring()}} can be used instead:




\begin{minted}{jlcon}
julia> a = readstring(`echo hello`)
"hello\n"

julia> chomp(a) == "hello"
true
\end{minted}



More generally, you can use \hyperlink{300818094931158296}{\texttt{open()}} to read from or write to an external command.




\begin{minted}{jlcon}
julia> open(`less`, "w", STDOUT) do io
           for i = 1:3
               println(io, i)
           end
       end
1
2
3
\end{minted}



\hypertarget{6373319844820183024}{}


\section{Interpolation}



Suppose you want to do something a bit more complicated and use the name of a file in the variable \texttt{file} as an argument to a command. You can use \texttt{\$} for interpolation much as you would in a string literal (see \hyperlink{5278796056388981234}{Strings}):




\begin{minted}{jlcon}
julia> file = "/etc/passwd"
"/etc/passwd"

julia> `sort $file`
`sort /etc/passwd`
\end{minted}



A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior. Suppose, for example, rather than \texttt{/etc/passwd}, we wanted to sort the contents of the file \texttt{/Volumes/External HD/data.csv}. Let{\textquotesingle}s try it:




\begin{minted}{jlcon}
julia> file = "/Volumes/External HD/data.csv"
"/Volumes/External HD/data.csv"

julia> `sort $file`
`sort '/Volumes/External HD/data.csv'`
\end{minted}



How did the file name get quoted? Julia knows that \texttt{file} is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of \texttt{file} is never interpreted by a shell, so there{\textquotesingle}s no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:




\begin{minted}{jlcon}
julia> path = "/Volumes/External HD"
"/Volumes/External HD"

julia> name = "data"
"data"

julia> ext = "csv"
"csv"

julia> `sort $path/$name.$ext`
`sort '/Volumes/External HD/data.csv'`
\end{minted}



As you can see, the space in the \texttt{path} variable is appropriately escaped. But what if you \emph{want} to interpolate multiple words? In that case, just use an array (or any other iterable container):




\begin{minted}{jlcon}
julia> files = ["/etc/passwd","/Volumes/External HD/data.csv"]
2-element Array{String,1}:
 "/etc/passwd"
 "/Volumes/External HD/data.csv"

julia> `grep foo $files`
`grep foo /etc/passwd '/Volumes/External HD/data.csv'`
\end{minted}



If you interpolate an array as part of a shell word, Julia emulates the shell{\textquotesingle}s \texttt{\{a,b,c\}} argument generation:




\begin{minted}{jlcon}
julia> names = ["foo","bar","baz"]
3-element Array{String,1}:
 "foo"
 "bar"
 "baz"

julia> `grep xylophone $names.txt`
`grep xylophone foo.txt bar.txt baz.txt`
\end{minted}



Moreover, if you interpolate multiple arrays into the same word, the shell{\textquotesingle}s Cartesian product generation behavior is emulated:




\begin{minted}{jlcon}
julia> names = ["foo","bar","baz"]
3-element Array{String,1}:
 "foo"
 "bar"
 "baz"

julia> exts = ["aux","log"]
2-element Array{String,1}:
 "aux"
 "log"

julia> `rm -f $names.$exts`
`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`
\end{minted}



Since you can interpolate literal arrays, you can use this generative functionality without needing to create temporary array objects first:




\begin{minted}{jlcon}
julia> `rm -rf $["foo","bar","baz","qux"].$["aux","log","pdf"]`
`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`
\end{minted}



\hypertarget{11332877811842244390}{}


\section{Quoting}



Inevitably, one wants to write commands that aren{\textquotesingle}t quite so simple, and it becomes necessary to use quotes. Here{\textquotesingle}s a simple example of a Perl one-liner at a shell prompt:




\begin{lstlisting}
sh$ perl -le '$|=1; for (0..3) { print }'
0
1
2
3
\end{lstlisting}



The Perl expression needs to be in single quotes for two reasons: so that spaces don{\textquotesingle}t break the expression into multiple shell words, and so that uses of Perl variables like \texttt{\$|} (yes, that{\textquotesingle}s the name of a variable in Perl), don{\textquotesingle}t cause interpolation. In other instances, you may want to use double quotes so that interpolation \emph{does} occur:




\begin{lstlisting}
sh$ first="A"
sh$ second="B"
sh$ perl -le '$|=1; print for @ARGV' "1: $first" "2: $second"
1: A
2: B
\end{lstlisting}



In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell{\textquotesingle}s. The only difference is that the interpolation is integrated and aware of Julia{\textquotesingle}s notion of what is a single string value, and what is a container for multiple values. Let{\textquotesingle}s try the above two examples in Julia:




\begin{minted}{jlcon}
julia> A = `perl -le '$|=1; for (0..3) { print }'`
`perl -le '$|=1; for (0..3) { print }'`

julia> run(A)
0
1
2
3

julia> first = "A"; second = "B";

julia> B = `perl -le 'print for @ARGV' "1: $first" "2: $second"`
`perl -le 'print for @ARGV' '1: A' '2: B'`

julia> run(B)
1: A
2: B
\end{minted}



The results are identical, and Julia{\textquotesingle}s interpolation behavior mimics the shell{\textquotesingle}s with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.



\hypertarget{13844592500116120236}{}


\section{Pipelines}



Shell metacharacters, such as \texttt{|}, \texttt{\&}, and \texttt{>}, need to be quoted (or escaped) inside of Julia{\textquotesingle}s backticks:




\begin{minted}{jlcon}
julia> run(`echo hello '|' sort`)
hello | sort

julia> run(`echo hello \| sort`)
hello | sort
\end{minted}



This expression invokes the \texttt{echo} command with three words as arguments: \texttt{hello}, \texttt{|}, and \texttt{sort}. The result is that a single line is printed: \texttt{hello | sort}. How, then, does one construct a pipeline? Instead of using \texttt{{\textquotesingle}|{\textquotesingle}} inside of backticks, one uses \hyperlink{17710887576380723118}{\texttt{pipeline()}}:




\begin{minted}{jlcon}
julia> run(pipeline(`echo hello`, `sort`))
hello
\end{minted}



This pipes the output of the \texttt{echo} command to the \texttt{sort} command. Of course, this isn{\textquotesingle}t terribly interesting since there{\textquotesingle}s only one line to sort, but we can certainly do much more interesting things:




\begin{minted}{jlcon}
julia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))
210
211
212
213
214
\end{minted}



This prints the highest five user IDs on a UNIX system. The \texttt{cut}, \texttt{sort} and \texttt{tail} commands are all spawned as immediate children of the current \texttt{julia} process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.



Julia can run multiple commands in parallel:




\begin{minted}{jlcon}
julia> run(`echo hello` & `echo world`)
world
hello
\end{minted}



The order of the output here is non-deterministic because the two \texttt{echo} processes are started nearly simultaneously, and race to make the first write to the \hyperlink{2784333101804678420}{\texttt{STDOUT}} descriptor they share with each other and the \texttt{julia} parent process. Julia lets you pipe the output from both of these processes to another program:




\begin{minted}{jlcon}
julia> run(pipeline(`echo world` & `echo hello`, `sort`))
hello
world
\end{minted}



In terms of UNIX plumbing, what{\textquotesingle}s happening here is that a single UNIX pipe object is created and written to by both \texttt{echo} processes, and the other end of the pipe is read from by the \texttt{sort} command.



IO redirection can be accomplished by passing keyword arguments stdin, stdout, and stderr to the \texttt{pipeline} function:




\begin{minted}{julia}
pipeline(`do_work`, stdout=pipeline(`sort`, "out.txt"), stderr="errs.txt")
\end{minted}



\hypertarget{10079881271299950533}{}


\subsection{Avoiding Deadlock in Pipelines}



When reading and writing to both ends of a pipeline from a single process, it is important to avoid forcing the kernel to buffer all of the data.



For example, when reading all of the output from a command, call \texttt{readstring(out)}, not \texttt{wait(process)}, since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel{\textquotesingle}s buffers while waiting for a reader to be connected.



Another common solution is to separate the reader and writer of the pipeline into separate Tasks:




\begin{minted}{julia}
writer = @async writeall(process, "data")
reader = @async do_compute(readstring(process))
wait(process)
fetch(reader)
\end{minted}



\hypertarget{3209356706755394100}{}


\subsection{Complex Example}



The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl one-liners:




\begin{minted}{jlcon}
julia> prefixer(prefix, sleep) = `perl -nle '$|=1; print "'$prefix' ", $_; sleep '$sleep';'`;

julia> run(pipeline(`perl -le '$|=1; for(0..9){ print; sleep 1 }'`, prefixer("A",2) & prefixer("B",2)))
A 0
B 1
A 2
B 3
A 4
B 5
A 6
B 7
A 8
B 9
\end{minted}



This is a classic example of a single producer feeding two concurrent consumers: one \texttt{perl} process generates lines with the numbers 0 through 9 on them, while two parallel processes consume that output, one prefixing lines with the letter {\textquotedbl}A{\textquotedbl}, the other with the letter {\textquotedbl}B{\textquotedbl}. Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting \texttt{\$|=1} in Perl causes each print statement to flush the \hyperlink{2784333101804678420}{\texttt{STDOUT}} handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)



Here is an even more complex multi-stage producer-consumer example:




\begin{minted}{jlcon}
julia> run(pipeline(`perl -le '$|=1; for(0..9){ print; sleep 1 }'`,
           prefixer("X",3) & prefixer("Y",3) & prefixer("Z",3),
           prefixer("A",2) & prefixer("B",2)))
A X 0
B Y 1
A Z 2
B X 3
A Y 4
B Z 5
A X 6
B Y 7
A Z 8
B X 9
\end{minted}



This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.



We strongly encourage you to try all these examples to see how they work.



\hypertarget{17572913146419880234}{}


\chapter{Llamando a código C y Fortran}



Aunque la mayoría del código se puede escribir en Julia, hay muchas bibliotecas maduras de alta calidad para computación numérica ya escritas en C y Fortran. Para permitir el uso fácil de este código existente, Julia hace que sea sencillo y eficiente llamar a las funciones C y Fortran. Julia tiene una filosofía de {\textquotedbl}no repetitivo{\textquotedbl}: las funciones se pueden llamar directamente desde Julia sin ningún código de {\textquotedbl}pegamento{\textquotedbl}, generación de código o compilación, incluso desde el aviso interactivo. Esto se logra haciendo una llamada apropiada con la sintaxis \hyperlink{14245046751182637566}{\texttt{ccall}}, que se parece a una llamada de función ordinaria.



El código que se debe llamar debe estar disponible como una biblioteca compartida. La mayoría de las bibliotecas C y Fortran ya se han compilado como bibliotecas compartidas, pero si está compilando el código usted mismo usando GCC (o Clang), necesitará usar las opciones \texttt{-shared} y\texttt{-fPIC}. Las instrucciones de la máquina generadas por el JIT de Julia son las mismas que una llamada C nativa, por lo que la sobrecarga resultante es lo mismo que llamar a una función de biblioteca desde el código C. (Las llamadas a funciones que no son de la biblioteca en C y Julia pueden estar incluidas y, por lo tanto, pueden tener incluso menos gastos generales que las llamadas a funciones de biblioteca compartidas. Cuando LLVM genera bibliotecas y ejecutables, es posible realizar optimizaciones de todo el programa que incluso optimizar a través de este límite, pero Julia aún no lo admite. Sin embargo, en el futuro, puede hacerlo, produciendo ganancias de rendimiento incluso mayores).



Las bibliotecas y funciones compartidas están referenciadas por una tupla de la forma \texttt{(:función,{\textquotedbl}biblioteca{\textquotedbl})} o \texttt{({\textquotedbl}función{\textquotedbl}, {\textquotedbl}biblioteca{\textquotedbl})} donde \texttt{función} es el nombre de función exportado por C. \texttt{library} se refiere al nombre de la biblioteca compartida: las bibliotecas compartidas disponibles en la ruta de carga (específica de la plataforma) se resolverán por nombre y, si es necesario, se puede especificar una ruta directa.



El nombre de una función se puede usar solo en lugar de la tupla (solo \texttt{:función} o\texttt{{\textquotedbl}función{\textquotedbl}}). En este caso, el nombre se resuelve dentro del proceso actual. Este formulario se puede usar para llamar funciones de biblioteca C, funciones en el tiempo de ejecución de Julia o funciones en una aplicación vinculada a Julia.



Por defecto, los compiladores Fortran \href{https://en.wikipedia.org/wiki/Name\_mangling\#Fortran}{generan nombres destrozados} (por ejemplo, convirtiendo nombres de funciones a minúsculas o mayúsculas, a menudo añadiendo un guión bajo), y para llamar a una función Fortran a través de \hyperlink{14245046751182637566}{\texttt{ccall}} debe pasar el identificador mutilado correspondiente a la regla seguida por su compilador Fortran . Además, cuando se llama a una función Fortran, todas las entradas se deben pasar por referencia.



Por último, se puede usar \hyperlink{14245046751182637566}{\texttt{ccall}} para generar de hecho una llamada a la función de librería. Los argumentos a  \hyperlink{14245046751182637566}{\texttt{ccall}} son los siguientes:



\begin{itemize}
\item[1. ] Una pareja \texttt{(:función, {\textquotedbl}librería{\textquotedbl})}, que debe ser escrita como una constante literal,

O

\end{itemize}


  un puntero a función (por ejemplo, de \texttt{dlsym}).



\begin{itemize}
\item[2. ] Tipo de retorno (ver abajo para la correspondencia entre el tipo declarado en C y Julia)

\end{itemize}


    * Este argumento será evaluado en tiempo de compilación, cuando se defina el método que lo contiene.



\begin{itemize}
\item[3. ] Una tupla de tipos de entrada. Los tipos de entrada deben ser escritos como un literal tupla, no como una variable o expresión de valor tupla.

\begin{itemize}
\item Este argumento será evaluado en tiempo de compilación, cuando se defina el método que lo contiene.

\end{itemize}

\item[4. ] Los siguientes argumentos, si los hay, son los valores de los argumentos actuales pasados a la función.

\end{itemize}


Como un ejemplo completo pero simple, el siguiente código llama a la función \texttt{clock} de la librería estándar C:




\begin{minted}{jlcon}
julia> t = ccall((:clock, "libc"), Int32, ())
2292761

julia> t
2292761

julia> typeof(ans)
Int32
\end{minted}



\texttt{clock} no toma argumentos y devuelve un \hyperlink{10103694114785108551}{\texttt{Int32}}. Un problema común es que una 1-tupla debe escribirse con una coma al final. Por ejemplo, para llamar a la función \texttt{getenv} para obtener un puntero al valor de una variable de entorno, se realiza una llamada como esta:




\begin{minted}{jlcon}
julia> path = ccall((:getenv, "libc"), Cstring, (Cstring,), "SHELL")
Cstring(@0x00007fff5fbffc45)

julia> unsafe_string(path)
"/bin/bash"
\end{minted}



Note que la tupla del tipo de argumento debe ser escrita como \texttt{(Cstring,)}, en lugar de como \texttt{(Cstring)}. Esto es debido a que \texttt{(Cstring)} es justo la expresión \texttt{Cstring} rodeada entre paréntesis, en lugar de una tupla que contiene a \texttt{Cstring}:




\begin{minted}{jlcon}
julia> (Cstring)
Cstring

julia> (Cstring,)
(Cstring,)
\end{minted}



En la práctica, especialmente cuando se proporciona funcionalidad reutilizable, generalmente se envuelve el usp de  \hyperlink{14245046751182637566}{\texttt{ccall}} en funciones de Julia que configuran argumentos y luego se comprueban los errores de cualquier forma que la función C o Fortran los indique, propagándose al código que llama desde Julia como excepciones. Esto es especialmente importante ya que las API de C y Fortran son notoriamente inconsistentes sobre cómo indican las condiciones de error. Por ejemplo, la función de biblioteca C \texttt{getenv} está envuelta en la siguiente función Julia, que es una versión simplificada de la definición real de \href{https://github.com/JuliaLang/julia/blob/master/base/env.jl}{\texttt{env.jl}}:




\begin{minted}{julia}
function getenv(var::AbstractString)
    val = ccall((:getenv, "libc"),
                Cstring, (Cstring,), var)
    if val == C_NULL
        error("getenv: undefined variable: ", var)
    end
    unsafe_string(val)
end
\end{minted}



La función C \texttt{getenv} indica un error al devolver\texttt{NULL}, pero otras funciones C estándar indican errores de varias maneras diferentes, incluyendo al devolver -1, 0, 1 y otros valores especiales. Este contenedor arroja una excepción que indica claramente el problema si la persona que llama intenta obtener una variable de entorno inexistente:




\begin{minted}{jlcon}
julia> getenv("SHELL")
"/bin/bash"

julia> getenv("FOOBAR")
getenv: undefined variable: FOOBAR
\end{minted}



Aquí hay un ejemplo ligeramente ms complejo que descubre el nombre de host de la máquina local:




\begin{minted}{julia}
function gethostname()
    hostname = Vector{UInt8}(128)
    ccall((:gethostname, "libc"), Int32,
          (Ptr{UInt8}, Csize_t),
          hostname, sizeof(hostname))
    hostname[end] = 0; # ensure null-termination
    return unsafe_string(pointer(hostname))
end
\end{minted}



Este ejemplo primero asigna un array de bytes, luego llama a la función de biblioteca C \texttt{gethostname} para llenar el array con el nombre de host, toma un puntero al buffer de nombre de host, y convierte el puntero a una cadena Julia, asumiendo que es una cadena C terminada en NUL. Es común que las bibliotecas C usen este patrón de requerir al llamador que asigne memoria para que la pase al llamado y la complete. La asignación de la memoria de Julia se logra generalmente creando un array no inicializada y pasando un puntero a sus datos a la función C. Es por eso que no usamos el tipo \texttt{Cstring} aquí: como la matriz no está inicializada, podría contener bytes NUL. Convertir a \texttt{Cstring} como parte de \hyperlink{14245046751182637566}{\texttt{ccall}} comprueba si hay bytes NUL contenidos y, por lo tanto, puede arrojar un error de conversión.



\hypertarget{8124607308067696037}{}


\section{Creating C-Compatible Julia Function Pointers}



It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:




\begin{lstlisting}
typedef returntype (*functiontype)(argumenttype,...)
\end{lstlisting}



The function \hyperlink{13392697678913949769}{\texttt{cfunction()}} generates the C-compatible function pointer for a call to a Julia library function. Arguments to \hyperlink{13392697678913949769}{\texttt{cfunction()}} are as follows:



\begin{itemize}
\item[1. ] A Julia Function


\item[2. ] Return type


\item[3. ] A tuple of input types

\end{itemize}


A classic example is the standard C library \texttt{qsort} function, declared as:




\begin{lstlisting}
void qsort(void *base, size_t nmemb, size_t size,
           int(*compare)(const void *a, const void *b));
\end{lstlisting}



The \texttt{base} argument is a pointer to an array of length \texttt{nmemb}, with elements of \texttt{size} bytes each. \texttt{compare} is a callback function which takes pointers to two elements \texttt{a} and \texttt{b} and returns an integer less/greater than zero if \texttt{a} should appear before/after \texttt{b} (or zero if any order is permitted). Now, suppose that we have a 1d array \texttt{A} of values in Julia that we want to sort using the \texttt{qsort} function (rather than Julia{\textquotesingle}s built-in \texttt{sort} function). Before we worry about calling \texttt{qsort} and passing arguments, we need to write a comparison function that works for some arbitrary type T:




\begin{lstlisting}
julia> function mycompare(a::T, b::T) where T
           return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint
       end
mycompare (generic function with 1 method)
\end{lstlisting}



Notice that we have to be careful about the return type: \texttt{qsort} expects a function returning a C \texttt{int}, so we must be sure to return \texttt{Cint} via a call to \texttt{convert} and a \texttt{typeassert}.



In order to pass this function to C, we obtain its address using the function \texttt{cfunction}:




\begin{lstlisting}
julia> const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));
\end{lstlisting}



\hyperlink{13392697678913949769}{\texttt{cfunction()}} accepts three arguments: the Julia function (\texttt{mycompare}), the return type (\texttt{Cint}), and a tuple of the argument types, in this case to sort an array of \texttt{Cdouble} (\hyperlink{5027751419500983000}{\texttt{Float64}}) elements.



The final call to \texttt{qsort} looks like this:




\begin{lstlisting}
julia> A = [1.3, -2.7, 4.4, 3.1]
4-element Array{Float64,1}:
  1.3
 -2.7
  4.4
  3.1

julia> ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),
             A, length(A), sizeof(eltype(A)), mycompare_c)

julia> A
4-element Array{Float64,1}:
 -2.7
  1.3
  3.1
  4.4
\end{lstlisting}



As can be seen, \texttt{A} is changed to the sorted array \texttt{[-2.7, 1.3, 3.1, 4.4]}. Note that Julia knows how to convert an array into a \texttt{Ptr\{Cdouble\}}, how to compute the size of a type in bytes (identical to C{\textquotesingle}s \texttt{sizeof} operator), and so on. For fun, try inserting a \texttt{println({\textquotedbl}mycompare(\$a,\$b){\textquotedbl})} line into \texttt{mycompare}, which will allow you to see the comparisons that \texttt{qsort} is performing (and to verify that it is really calling the Julia function that you passed to it).



\hypertarget{7299460396633422544}{}


\section{Mapping C Types to Julia}



It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.



Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The \href{https://github.com/ihnorton/Clang.jl}{Clang package} can be used to auto-generate Julia code from a C header file.)



\hypertarget{12226435363744783027}{}


\subsection{Auto-conversion:}



Julia automatically inserts calls to the \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} function to convert each argument to the specified type. For example, the following call:




\begin{minted}{julia}
ccall((:foo, "libfoo"), Void, (Int32, Float64), x, y)
\end{minted}



will behave as if the following were written:




\begin{minted}{julia}
ccall((:foo, "libfoo"), Void, (Int32, Float64),
      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),
      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))
\end{minted}



\hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} normally just calls \hyperlink{1846942650946171605}{\texttt{convert()}}, but can be defined to return an arbitrary new object more appropriate for passing to C. For example, this is used to convert an \texttt{Array} of objects (e.g. strings) to an array of pointers.



\hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert()}} handles conversion to \texttt{Ptr} types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.



\hypertarget{8963563453975340082}{}


\subsection{Type Correspondences:}



First, a review of some relevant Julia type terminology:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Syntax / Keyword & Example & Description \\
\hline
\texttt{mutable struct} & \texttt{String} & {\textquotedbl}Leaf Type{\textquotedbl} :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no \texttt{TypeVars} are allowed) in order for the instance to be constructed. \\
\hline
\texttt{abstract type} & \texttt{Any}, \texttt{AbstractArray\{T, N\}}, \texttt{Complex\{T\}} & {\textquotedbl}Super Type{\textquotedbl} :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types. \\
\hline
\texttt{T\{A\}} & \texttt{Vector\{Int\}} & {\textquotedbl}Type Parameter{\textquotedbl} :: A specialization of a type (typically used for dispatch or storage optimization). \\
\hline
 &  & {\textquotedbl}TypeVar{\textquotedbl} :: The \texttt{T} in the type parameter declaration is referred to as a TypeVar (short for type variable). \\
\hline
\texttt{primitive type} & \texttt{Int}, \texttt{Float64} & {\textquotedbl}Primitive Type{\textquotedbl} :: A type with no fields, but a size. It is stored and defined by-value. \\
\hline
\texttt{struct} & \texttt{Pair\{Int, Int\}} & {\textquotedbl}Struct{\textquotedbl} :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag. \\
\hline
 & \texttt{Complex128} (\texttt{isbits}) & {\textquotedbl}Is-Bits{\textquotedbl}   :: A \texttt{primitive type}, or a \texttt{struct} type where all fields are other \texttt{isbits} types. It is defined by-value, and is stored without a type-tag. \\
\hline
\texttt{struct ...; end} & \texttt{nothing} & {\textquotedbl}Singleton{\textquotedbl} :: a Leaf Type or Struct with no fields. \\
\hline
\texttt{(...)} or \texttt{tuple(...)} & \texttt{(1, 2, 3)} & {\textquotedbl}Tuple{\textquotedbl} :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{15482144590484122804}{}


\subsection{Bits Types:}



There are several special types to be aware of, as no other type can be defined to behave the same:



\begin{itemize}
\item \texttt{Float32}

Exactly corresponds to the \texttt{float} type in C (or \texttt{REAL*4} in Fortran).


\item \texttt{Float64}

Exactly corresponds to the \texttt{double} type in C (or \texttt{REAL*8} in Fortran).


\item \texttt{Complex64}

Exactly corresponds to the \texttt{complex float} type in C (or \texttt{COMPLEX*8} in Fortran).


\item \texttt{Complex128}

Exactly corresponds to the \texttt{complex double} type in C (or \texttt{COMPLEX*16} in Fortran).


\item \texttt{Signed}

Exactly corresponds to the \texttt{signed} type annotation in C (or any \texttt{INTEGER} type in Fortran). Any Julia type that is not a subtype of \hyperlink{14154866400772377486}{\texttt{Signed}} is assumed to be unsigned.

\end{itemize}


\begin{itemize}
\item \texttt{Ref\{T\}}

Behaves like a \texttt{Ptr\{T\}} that can manage its memory via the Julia GC.

\end{itemize}


\begin{itemize}
\item \texttt{Array\{T,N\}}

When an array is passed to C as a \texttt{Ptr\{T\}} argument, it is not reinterpret-cast: Julia requires that the element type of the array matches \texttt{T}, and the address of the first element is passed.

Therefore, if an \texttt{Array} contains data in the wrong format, it will have to be explicitly converted using a call such as \texttt{trunc(Int32, a)}.

To pass an array \texttt{A} as a pointer of a different type \emph{without} converting the data beforehand (for example, to pass a \texttt{Float64} array to a function that operates on uninterpreted bytes), you can declare the argument as \texttt{Ptr\{Void\}}.

If an array of eltype \texttt{Ptr\{T\}} is passed as a \texttt{Ptr\{Ptr\{T\}\}} argument, \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} will attempt to first make a null-terminated copy of the array with each element replaced by its \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} version. This allows, for example, passing an \texttt{argv} pointer array of type \texttt{Vector\{String\}} to an argument of type \texttt{Ptr\{Ptr\{Cchar\}\}}.

\end{itemize}


On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an \texttt{int} in C is not the same as an \texttt{Int} in Julia).



\textbf{System Independent:}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
C name & Fortran name & Standard Julia Alias & Julia Base Type \\
\hline
\texttt{unsigned char} & \texttt{CHARACTER} & \texttt{Cuchar} & \texttt{UInt8} \\
\hline
\texttt{bool} (only in C++) &  & \texttt{Cuchar} & \texttt{UInt8} \\
\hline
\texttt{short} & \texttt{INTEGER*2}, \texttt{LOGICAL*2} & \texttt{Cshort} & \texttt{Int16} \\
\hline
\texttt{unsigned short} &   & \texttt{Cushort} & \texttt{UInt16} \\
\hline
\texttt{int}, \texttt{BOOL} (C, typical) & \texttt{INTEGER*4}, \texttt{LOGICAL*4} & \texttt{Cint} & \texttt{Int32} \\
\hline
\texttt{unsigned int} &   & \texttt{Cuint} & \texttt{UInt32} \\
\hline
\texttt{long long} & \texttt{INTEGER*8}, \texttt{LOGICAL*8} & \texttt{Clonglong} & \texttt{Int64} \\
\hline
\texttt{unsigned long long} &   & \texttt{Culonglong} & \texttt{UInt64} \\
\hline
\texttt{intmax\_t} &   & \texttt{Cintmax\_t} & \texttt{Int64} \\
\hline
\texttt{uintmax\_t} &   & \texttt{Cuintmax\_t} & \texttt{UInt64} \\
\hline
\texttt{float} & \texttt{REAL*4i} & \texttt{Cfloat} & \texttt{Float32} \\
\hline
\texttt{double} & \texttt{REAL*8} & \texttt{Cdouble} & \texttt{Float64} \\
\hline
\texttt{complex float} & \texttt{COMPLEX*8} & \texttt{Complex64} & \texttt{Complex\{Float32\}} \\
\hline
\texttt{complex double} & \texttt{COMPLEX*16} & \texttt{Complex128} & \texttt{Complex\{Float64\}} \\
\hline
\texttt{ptrdiff\_t} &   & \texttt{Cptrdiff\_t} & \texttt{Int} \\
\hline
\texttt{ssize\_t} &   & \texttt{Cssize\_t} & \texttt{Int} \\
\hline
\texttt{size\_t} &   & \texttt{Csize\_t} & \texttt{UInt} \\
\hline
\texttt{void} &   &   & \texttt{Void} \\
\hline
\texttt{void} and \texttt{[[noreturn]]} or \texttt{\_Noreturn} &   &   & \texttt{Union\{\}} \\
\hline
\texttt{void*} &   &   & \texttt{Ptr\{Void\}} \\
\hline
\texttt{T*} (where T represents an appropriately defined type) &   &   & \texttt{Ref\{T\}} \\
\hline
\texttt{char*} (or \texttt{char[]}, e.g. a string) & \texttt{CHARACTER*N} &   & \texttt{Cstring} if NUL-terminated, or \texttt{Ptr\{UInt8\}} if not \\
\hline
\texttt{char**} (or \texttt{*char[]}) &   &   & \texttt{Ptr\{Ptr\{UInt8\}\}} \\
\hline
\texttt{jl\_value\_t*} (any Julia Type) &   &   & \texttt{Any} \\
\hline
\texttt{jl\_value\_t**} (a reference to a Julia Type) &   &   & \texttt{Ref\{Any\}} \\
\hline
\texttt{va\_arg} &   &   & Not supported \\
\hline
\texttt{...} (variadic function specification) &   &   & \texttt{T...} (where \texttt{T} is one of the above types, variadic functions of different argument types are not supported) \\
\hline
\end{tabulary}

\end{table}



The \texttt{Cstring} type is essentially a synonym for \texttt{Ptr\{UInt8\}}, except the conversion to \texttt{Cstring} throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a \texttt{char*} to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use \texttt{Ptr\{UInt8\}} as the argument type. \texttt{Cstring} can also be used as the \hyperlink{14245046751182637566}{\texttt{ccall}} return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.



\textbf{System-dependent:}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
C name & Standard Julia Alias & Julia Base Type \\
\hline
\texttt{char} & \texttt{Cchar} & \texttt{Int8} (x86, x86\_64), \texttt{UInt8} (powerpc, arm) \\
\hline
\texttt{long} & \texttt{Clong} & \texttt{Int} (UNIX), \texttt{Int32} (Windows) \\
\hline
\texttt{unsigned long} & \texttt{Culong} & \texttt{UInt} (UNIX), \texttt{UInt32} (Windows) \\
\hline
\texttt{wchar\_t} & \texttt{Cwchar\_t} & \texttt{Int32} (UNIX), \texttt{UInt16} (Windows) \\
\hline
\end{tabulary}

\end{table}



\begin{quote}
\textbf{Note}

When calling a Fortran function, all inputs must be passed by reference, so all type correspondences above should contain an additional \texttt{Ptr\{..\}} or \texttt{Ref\{..\}} wrapper around their type specification.

\end{quote}


\begin{quote}
\textbf{Warning}

For string arguments (\texttt{char*}) the Julia type should be \texttt{Cstring} (if NUL- terminated data is expected) or either \texttt{Ptr\{Cchar\}} or \texttt{Ptr\{UInt8\}} otherwise (these two pointer types have the same effect), as described above, not \texttt{String}. Similarly, for array arguments (\texttt{T[]} or \texttt{T*}), the Julia type should again be \texttt{Ptr\{T\}}, not \texttt{Vector\{T\}}.

\end{quote}


\begin{quote}
\textbf{Warning}

Julia{\textquotesingle}s \texttt{Char} type is 32 bits, which is not the same as the wide character type (\texttt{wchar\_t} or \texttt{wint\_t}) on all platforms.

\end{quote}


\begin{quote}
\textbf{Warning}

A return type of \texttt{Union\{\}} means the function will not return i.e. C++11 \texttt{[[noreturn]]} or C11 \texttt{\_Noreturn} (e.g. \texttt{jl\_throw} or \texttt{longjmp}). Do not use this for functions that return no value (\texttt{void}) but do return, use \texttt{Void} instead.

\end{quote}


\begin{quote}
\textbf{Note}

For \texttt{wchar\_t*} arguments, the Julia type should be \texttt{Cwstring} (if the C routine expects a NUL-terminated string) or \texttt{Ptr\{Cwchar\_t\}} otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the \texttt{Cwstring} type will cause an error to be thrown if the string itself contains NUL characters).

\end{quote}


\begin{quote}
\textbf{Note}

C functions that take an argument of the type \texttt{char**} can be called by using a \texttt{Ptr\{Ptr\{UInt8\}\}} type within Julia. For example, C functions of the form:


\begin{lstlisting}
int main(int argc, char **argv);
\end{lstlisting}

can be called via the following Julia code:


\begin{minted}{julia}
argv = [ "a.out", "arg1", "arg2" ]
ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)
\end{minted}

\end{quote}


\begin{quote}
\textbf{Note}

A C function declared to return \texttt{Void} will return the value \texttt{nothing} in Julia.

\end{quote}


\hypertarget{13731679927184956787}{}


\subsection{Struct Type correspondences}



Composite types, aka \texttt{struct} in C or \texttt{TYPE} in Fortran90 (or \texttt{STRUCTURE} / \texttt{RECORD} in some variants of F77), can be mirrored in Julia by creating a \texttt{struct} definition with the same field layout.



When used recursively, \texttt{isbits} types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an \texttt{isbits} struct type and use that instead. Unnamed structs are not possible in the translation to Julia.



Packed structs and union declarations are not supported by Julia.



You can get a near approximation of a \texttt{union} if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.



Arrays of parameters can be expressed with \texttt{NTuple}:




\begin{lstlisting}
in C:
struct B {
    int A[3];
};
b_a_2 = B.A[2];

in Julia:
struct B
    A::NTuple{3, CInt}
end
b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)
\end{lstlisting}



Arrays of unknown size (C99-compliant variable length structs specified by \texttt{[]} or \texttt{[0]}) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:




\begin{lstlisting}
struct String {
    int strlen;
    char data[];
};
\end{lstlisting}



In Julia, we can access the parts independently to make a copy of that string:




\begin{minted}{julia}
str = from_c::Ptr{Void}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)
\end{minted}



\hypertarget{7624173302473303801}{}


\subsection{Type Parameters}



The type arguments to \texttt{ccall} are evaluated statically, when the method containing the ccall is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.



This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.



However, while the type layout must be known statically to compute the \texttt{ccall} ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the \texttt{ccall} signature, as long as they don{\textquotesingle}t affect the layout of the type. For example, \texttt{f(x::T) where \{T\} = ccall(:valid, Ptr\{T\}, (Ptr\{T\},), x)} is valid, since \texttt{Ptr} is always a word-size primitive type. But, \texttt{g(x::T) where \{T\} = ccall(:notvalid, T, (T,), x)} is not valid, since the type layout of \texttt{T} is not known statically.



\hypertarget{17832703301283919502}{}


\subsection{SIMD Values}



Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.



If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of \texttt{VecElement} that naturally maps to the SIMD type.  Specifically:



\begin{quote}
\begin{itemize}
\item The tuple must be the same size as the SIMD type. For example, a tuple representing an \texttt{\_\_m128} on x86 must have a size of 16 bytes.


\item The element type of the tuple must be an instance of \texttt{VecElement\{T\}} where \texttt{T} is a primitive type that is 1, 2, 4 or 8 bytes.

\end{itemize}
\end{quote}


For instance, consider this C routine that uses AVX intrinsics:




\begin{lstlisting}
#include <immintrin.h>

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}
\end{lstlisting}



The following Julia code calls \texttt{dist} using \texttt{ccall}:




\begin{minted}{julia}
const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    ccall((:dist, "libdist"), m256, (m256, m256), a, b)
end

println(call_dist(a,b))
\end{minted}



The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support.



\hypertarget{6052846273119995959}{}


\subsection{Memory Ownership}



\textbf{malloc/free}



Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with \texttt{Libc.free} in Julia, as this may result in the \texttt{free} function being called via the wrong \texttt{libc} library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.



\hypertarget{15982365234273661730}{}


\subsection{When to use T, Ptr\{T\} and Ref\{T\}}



In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type \texttt{T} inside the \hyperlink{14245046751182637566}{\texttt{ccall}}, as they are passed by value.  For C code accepting pointers, \texttt{Ref\{T\}} should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}}.  In contrast, pointers returned by the C function called should be declared to be of output type \texttt{Ptr\{T\}}, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type \texttt{Ptr\{T\}} within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.



In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type \texttt{Ref\{T\}}, as Fortran passes all variables by reference. The return type should either be \texttt{Void} for Fortran subroutines, or a \texttt{T} for Fortran functions returning the type \texttt{T}.



\hypertarget{6114319820079574946}{}


\section{Mapping C Functions to Julia}



\hypertarget{9085571853862897545}{}


\subsection{\texttt{ccall}/\texttt{cfunction} argument translation guide}



For translating a C argument list to Julia:



\begin{itemize}
\item \texttt{T}, where \texttt{T} is one of the primitive types: \texttt{char}, \texttt{int}, \texttt{long}, \texttt{short}, \texttt{float}, \texttt{double}, \texttt{complex}, \texttt{enum} or any of their \texttt{typedef} equivalents

\begin{itemize}
\item \texttt{T}, where \texttt{T} is an equivalent Julia Bits Type (per the table above)


\item if \texttt{T} is an \texttt{enum}, the argument type should be equivalent to \texttt{Cint} or \texttt{Cuint}


\item argument value will be copied (passed by value)

\end{itemize}

\item \texttt{struct T} (including typedef to a struct)

\begin{itemize}
\item \texttt{T}, where \texttt{T} is a Julia leaf type


\item argument value will be copied (passed by value)

\end{itemize}

\item \texttt{void*}

\begin{itemize}
\item depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list


\item this argument may be declared as \texttt{Ptr\{Void\}}, if it really is just an unknown pointer

\end{itemize}

\item \texttt{jl\_value\_t*}

\begin{itemize}
\item \texttt{Any}


\item argument value must be a valid Julia object


\item currently unsupported by \hyperlink{13392697678913949769}{\texttt{cfunction()}}

\end{itemize}

\item \texttt{jl\_value\_t**}

\begin{itemize}
\item \texttt{Ref\{Any\}}


\item argument value must be a valid Julia object (or \texttt{C\_NULL})


\item currently unsupported by \hyperlink{13392697678913949769}{\texttt{cfunction()}}

\end{itemize}

\item \texttt{T*}

\begin{itemize}
\item \texttt{Ref\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}


\item argument value will be copied if it is an \texttt{isbits} type otherwise, the value must be a valid Julia object

\end{itemize}

\item \texttt{(T*)(...)} (e.g. a pointer to a function)

\begin{itemize}
\item \texttt{Ptr\{Void\}} (you may need to use \hyperlink{13392697678913949769}{\texttt{cfunction()}} explicitly to create this pointer)

\end{itemize}

\item \texttt{...} (e.g. a vararg)

\begin{itemize}
\item \texttt{T...}, where \texttt{T} is the Julia type

\end{itemize}

\item \texttt{va\_arg}

\begin{itemize}
\item not supported

\end{itemize}
\end{itemize}


\hypertarget{4058583142675680098}{}


\subsection{\texttt{ccall}/\texttt{cfunction} return type translation guide}



For translating a C return type to Julia:



\begin{itemize}
\item \texttt{void}

\begin{itemize}
\item \texttt{Void} (this will return the singleton instance \texttt{nothing::Void})

\end{itemize}

\item \texttt{T}, where \texttt{T} is one of the primitive types: \texttt{char}, \texttt{int}, \texttt{long}, \texttt{short}, \texttt{float}, \texttt{double}, \texttt{complex}, \texttt{enum} or any of their \texttt{typedef} equivalents

\begin{itemize}
\item \texttt{T}, where \texttt{T} is an equivalent Julia Bits Type (per the table above)


\item if \texttt{T} is an \texttt{enum}, the argument type should be equivalent to \texttt{Cint} or \texttt{Cuint}


\item argument value will be copied (returned by-value)

\end{itemize}

\item \texttt{struct T} (including typedef to a struct)

\begin{itemize}
\item \texttt{T}, where \texttt{T} is a Julia Leaf Type


\item argument value will be copied (returned by-value)

\end{itemize}

\item \texttt{void*}

\begin{itemize}
\item depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list


\item this argument may be declared as \texttt{Ptr\{Void\}}, if it really is just an unknown pointer

\end{itemize}

\item \texttt{jl\_value\_t*}

\begin{itemize}
\item \texttt{Any}


\item argument value must be a valid Julia object

\end{itemize}

\item \texttt{jl\_value\_t**}

\begin{itemize}
\item \texttt{Ref\{Any\}}


\item argument value must be a valid Julia object (or \texttt{C\_NULL})

\end{itemize}

\item \texttt{T*}

\begin{itemize}
\item If the memory is already owned by Julia, or is an \texttt{isbits} type, and is known to be non-null:

\begin{itemize}
\item \texttt{Ref\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}


\item a return type of \texttt{Ref\{Any\}} is invalid, it should either be \texttt{Any} (corresponding to \texttt{jl\_value\_t*}) or \texttt{Ptr\{Any\}} (corresponding to \texttt{Ptr\{Any\}})


\item C \textbf{MUST NOT} modify the memory returned via \texttt{Ref\{T\}} if \texttt{T} is an \texttt{isbits} type

\end{itemize}

\item If the memory is owned by C:

\begin{itemize}
\item \texttt{Ptr\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}

\end{itemize}
\end{itemize}

\item \texttt{(T*)(...)} (e.g. a pointer to a function)

\begin{itemize}
\item \texttt{Ptr\{Void\}} (you may need to use \hyperlink{13392697678913949769}{\texttt{cfunction()}} explicitly to create this pointer)

\end{itemize}
\end{itemize}


\hypertarget{12317000517353378133}{}


\subsection{Passing Pointers for Modifying Inputs}



Because C doesn{\textquotesingle}t support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a \hyperlink{14245046751182637566}{\texttt{ccall}}, you need to first encapsulate the value inside an \texttt{Ref\{T\}} of the appropriate type. When you pass this \texttt{Ref} object as an argument, Julia will automatically pass a C pointer to the encapsulated data:




\begin{minted}{julia}
width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
ccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)
\end{minted}



Upon return, the contents of \texttt{width} and \texttt{range} can be retrieved (if they were changed by \texttt{foo}) by \texttt{width[]} and \texttt{range[]}; that is, they act like zero-dimensional arrays.



\hypertarget{13468242842430921722}{}


\subsection{Special Reference Syntax for ccall (deprecated):}



The \texttt{\&} syntax is deprecated, use the \texttt{Ref\{T\}} argument type instead.



A prefix \texttt{\&} is used on an argument to \hyperlink{14245046751182637566}{\texttt{ccall}} to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.




\begin{minted}{julia}
function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = ccall((:ddot_, "libLAPACK"),
                    Float64,
                    (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),
                    &n, DX, &incx, DY, &incy)
    return product
end
\end{minted}



The meaning of prefix \texttt{\&} is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via \texttt{type}). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, \texttt{\&} may be used with any expression, such as \texttt{\&0} or \texttt{\&f(x)}.



When a scalar value is passed with \texttt{\&} as an argument of type \texttt{Ptr\{T\}}, the value will first be converted to type \texttt{T}.



\hypertarget{3327404933822645337}{}


\section{Some Examples of C Wrappers}



Here is a simple example of a C wrapper that returns a \texttt{Ptr} type:




\begin{minted}{julia}
mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = ccall(
        (:gsl_permutation_alloc, :libgsl), # name of C function and library
        Ptr{gsl_permutation},              # output type
        (Csize_t,),                        # tuple of input types
        n                                  # name of Julia variable to pass in
    )
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end
\end{minted}



The \href{https://www.gnu.org/software/gsl/}{GNU Scientific Library} (here assumed to be accessible through \texttt{:libgsl}) defines an opaque pointer, \texttt{gsl\_permutation *}, as the return type of the C function \texttt{gsl\_permutation\_alloc()}. As user code never has to look inside the \texttt{gsl\_permutation} struct, the corresponding Julia wrapper simply needs a new type declaration, \texttt{gsl\_permutation}, that has no internal fields and whose sole purpose is to be placed in the type parameter of a \texttt{Ptr} type.  The return type of the \hyperlink{14245046751182637566}{\texttt{ccall}} is declared as \texttt{Ptr\{gsl\_permutation\}}, since the memory allocated and pointed to by \texttt{output\_ptr} is controlled by C (and not Julia).



The input \texttt{n} is passed by value, and so the function{\textquotesingle}s input signature is simply declared as \texttt{(Csize\_t,)} without any \texttt{Ref} or \texttt{Ptr} necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be \texttt{(Ref\{Csize\_t\},)}, since Fortran variables are passed by reference.) Furthermore, \texttt{n} can be any type that is convertable to a \texttt{Csize\_t} integer; the \hyperlink{14245046751182637566}{\texttt{ccall}} implicitly calls \hyperlink{16487788729383051927}{\texttt{Base.cconvert(Csize\_t, n)}}.



Here is a second example wrapping the corresponding destructor:




\begin{minted}{julia}
# The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ref{gsl_permutation})
    ccall(
        (:gsl_permutation_free, :libgsl), # name of C function and library
        Void,                             # output type
        (Ref{gsl_permutation},),          # tuple of input types
        p                                 # name of Julia variable to pass in
    )
end
\end{minted}



Here, the input \texttt{p} is declared to be of type \texttt{Ref\{gsl\_permutation\}}, meaning that the memory that \texttt{p} points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type \texttt{Ptr\{gsl\_permutation\}}, but it is convertable using \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} and therefore can be used in the same (covariant) context of the input argument to a \hyperlink{14245046751182637566}{\texttt{ccall}}. A pointer to memory allocated by Julia must be of type \texttt{Ref\{gsl\_permutation\}}, to ensure that the memory address pointed to is valid and that Julia{\textquotesingle}s garbage collector manages the chunk of memory pointed to correctly. Therefore, the \texttt{Ref\{gsl\_permutation\}} declaration allows pointers managed by C or Julia to be used.



If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using \texttt{p::Ptr\{gsl\_permutation\}} for the method signature of the wrapper and similarly in the \hyperlink{14245046751182637566}{\texttt{ccall}} is also acceptable.



Here is a third example passing Julia arrays:




\begin{minted}{julia}
# The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax < nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(nmax - nmin + 1)
    errorcode = ccall(
        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library
        Cint,                               # output type
        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types
        nmin, nmax, x, result_array         # names of Julia variables to pass in
    )
    if errorcode != 0
        error("GSL error code $errorcode")
    end
    return result_array
end
\end{minted}



The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array \texttt{result\_array}. This variable can only be used with corresponding input type declaration \texttt{Ref\{Cdouble\}}, since its memory is allocated and managed by Julia, not C. The implicit call to \hyperlink{16487788729383051927}{\texttt{Base.cconvert(Ref\{Cdouble\}, result\_array)}} unpacks the Julia pointer to a Julia array data structure into a form understandable by C.



Note that for this code to work correctly, \texttt{result\_array} must be declared to be of type \texttt{Ref\{Cdouble\}} and not \texttt{Ptr\{Cdouble\}}. The memory is managed by Julia and the \texttt{Ref} signature alerts Julia{\textquotesingle}s garbage collector to keep managing the memory for \texttt{result\_array} while the \hyperlink{14245046751182637566}{\texttt{ccall}} executes. If \texttt{Ptr\{Cdouble\}} were used instead, the \hyperlink{14245046751182637566}{\texttt{ccall}} may still work, but Julia{\textquotesingle}s garbage collector would not be aware that the memory declared for \texttt{result\_array} is being used by the external C function. As a result, the code may produce a memory leak if \texttt{result\_array} never gets freed by the garbage collector, or if the garbage collector prematurely frees \texttt{result\_array}, the C function may end up throwing an invalid memory access exception.



\hypertarget{6663973011603779975}{}


\section{Garbage Collection Safety}



When passing data to a \hyperlink{14245046751182637566}{\texttt{ccall}}, it is best to avoid using the \hyperlink{8901246211940014300}{\texttt{pointer()}} function. Instead define a convert method and pass the variables directly to the \hyperlink{14245046751182637566}{\texttt{ccall}}. \hyperlink{14245046751182637566}{\texttt{ccall}} automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the \hyperlink{14245046751182637566}{\texttt{ccall}} returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global variable of type \texttt{Array\{Ref,1\}} to hold these values, until the C library notifies you that it is finished with them.



Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many methods in Julia such as \hyperlink{13744149973765810952}{\texttt{unsafe\_load()}} and \hyperlink{2825695355940841177}{\texttt{String()}} make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is \hyperlink{14566494858943689253}{\texttt{unsafe\_wrap()}} which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.



The garbage collector does not guarantee any order of finalization. That is, if \texttt{a} contained a reference to \texttt{b} and both \texttt{a} and \texttt{b} are due for garbage collection, there is no guarantee that \texttt{b} would be finalized after \texttt{a}. If proper finalization of \texttt{a} depends on \texttt{b} being valid, it must be handled in other ways.



\hypertarget{14397309909238125480}{}


\section{Non-constant Function Specifications}



A \texttt{(name, library)} function specification must be a constant expression. However, it is possible to use computed values as function names by staging through \texttt{eval} as follows:




\begin{lstlisting}
@eval ccall(($(string("a", "b")), "lib"), ...
\end{lstlisting}



This expression constructs a name using \texttt{string}, then substitutes this name into a new \hyperlink{14245046751182637566}{\texttt{ccall}} expression, which is then evaluated. Keep in mind that \texttt{eval} only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with \texttt{\$}). For this reason, \texttt{eval} is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions.



If your usage is more dynamic, use indirect calls as described in the next section.



\hypertarget{14195829583958657383}{}


\section{Indirect Calls}



The first argument to \hyperlink{14245046751182637566}{\texttt{ccall}} can also be an expression evaluated at run time. In this case, the expression must evaluate to a \texttt{Ptr}, which will be used as the address of the native function to call. This behavior occurs when the first \hyperlink{14245046751182637566}{\texttt{ccall}} argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.



For example, you might look up the function via \texttt{dlsym}, then cache it in a global variable for that session. For example:




\begin{minted}{julia}
macro dlsym(func, lib)
    z, zlocal = gensym(string(func)), gensym()
    eval(current_module(), :(global $z = C_NULL))
    z = esc(z)
    quote
        let $zlocal::Ptr{Void} = $z::Ptr{Void}
            if $zlocal == C_NULL
                $zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))
                global $z = $zlocal
            end
            $zlocal
        end
    end
end

mylibvar = Libdl.dlopen("mylib")
ccall(@dlsym("myfunc", mylibvar), Void, ())
\end{minted}



\hypertarget{8984473107328045984}{}


\section{Calling Convention}



The second argument to \hyperlink{14245046751182637566}{\texttt{ccall}} can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: \texttt{stdcall}, \texttt{cdecl}, \texttt{fastcall}, and \texttt{thiscall}. For example (from \texttt{base/libc.jl}) we see the same \texttt{gethostname}\hyperlink{14245046751182637566}{\texttt{ccall}} as above, but with the correct signature for Windows:




\begin{minted}{julia}
hn = Vector{UInt8}(256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))
\end{minted}



For more information, please see the \href{http://llvm.org/docs/LangRef.html\#calling-conventions}{LLVM Language Reference}.



There is one additional special calling convention \texttt{llvmcall}, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for \href{http://llvm.org/docs/NVPTXUsage.html}{CUDA}, we need to be able to read the thread index:




\begin{minted}{julia}
ccall("llvm.nvvm.read.ptx.sreg.tid.x", llvmcall, Int32, ())
\end{minted}



As with any \texttt{ccall}, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by \texttt{Core.Intrinsics}.



\hypertarget{2707067892080774554}{}


\section{Accessing Global Variables}



Global variables exported by native libraries can be accessed by name using the \hyperlink{2746947069730856184}{\texttt{cglobal()}} function. The arguments to \hyperlink{2746947069730856184}{\texttt{cglobal()}} are a symbol specification identical to that used by \hyperlink{14245046751182637566}{\texttt{ccall}}, and a type describing the value stored in the variable:




\begin{minted}{jlcon}
julia> cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8
\end{minted}



The result is a pointer giving the address of the value. The value can be manipulated through this pointer using \hyperlink{13744149973765810952}{\texttt{unsafe\_load()}} and \hyperlink{4579672834750013041}{\texttt{unsafe\_store!()}}.



\hypertarget{14428977823562595292}{}


\section{Accessing Data through a Pointer}



The following methods are described as {\textquotedbl}unsafe{\textquotedbl} because a bad pointer or type declaration can cause Julia to terminate abruptly.



Given a \texttt{Ptr\{T\}}, the contents of type \texttt{T} can generally be copied from the referenced memory into a Julia object using \texttt{unsafe\_load(ptr, [index])}. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of \hyperlink{2839226020402435013}{\texttt{getindex()}} and \hyperlink{17903591429492118749}{\texttt{setindex!()}} (e.g. \texttt{[]} access syntax).



The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.



If \texttt{T} is \texttt{Any}, then the memory is assumed to contain a reference to a Julia object (a \texttt{jl\_value\_t*}), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia{\textquotesingle}s garbage collector.  If the \texttt{Ptr} itself is actually a \texttt{jl\_value\_t*}, it can be converted back to a Julia object reference by \hyperlink{10812596548944930674}{\texttt{unsafe\_pointer\_to\_objref(ptr)}}. (Julia values \texttt{v} can be converted to \texttt{jl\_value\_t*} pointers, as \texttt{Ptr\{Void\}}, by calling \hyperlink{9366554937543398846}{\texttt{pointer\_from\_objref(v)}}.)



The reverse operation (writing data to a \texttt{Ptr\{T\}}), can be performed using \hyperlink{4579672834750013041}{\texttt{unsafe\_store!(ptr, value, [index])}}. Currently, this is only supported for primitive types or other pointer-free (\texttt{isbits}) immutable struct types.



Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.



If the pointer of interest is a plain-data array (primitive type or immutable struct), the function \hyperlink{14566494858943689253}{\texttt{unsafe\_wrap(Array, ptr,dims,[own])}} may be more useful. The final parameter should be true if Julia should {\textquotedbl}take ownership{\textquotedbl} of the underlying buffer and call \texttt{free(ptr)} when the returned \texttt{Array} object is finalized.  If the \texttt{own} parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.



Arithmetic on the \texttt{Ptr} type in Julia (e.g. using \texttt{+}) does not behave the same as C{\textquotesingle}s pointer arithmetic. Adding an integer to a \texttt{Ptr} in Julia always moves the pointer by some number of \emph{bytes}, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.



\hypertarget{13563408698628305845}{}


\section{Thread-safety}



Some C libraries execute their callbacks from a different thread, and since Julia isn{\textquotesingle}t thread-safe you{\textquotesingle}ll need to take some extra precautions. In particular, you{\textquotesingle}ll need to set up a two-layered system: the C callback should only \emph{schedule} (via Julia{\textquotesingle}s event loop) the execution of your {\textquotedbl}real{\textquotedbl} callback. To do this, create a \texttt{AsyncCondition} object and wait on it:




\begin{minted}{julia}
cond = Base.AsyncCondition()
wait(cond)
\end{minted}



The callback you pass to C should only execute a \hyperlink{14245046751182637566}{\texttt{ccall}} to \texttt{:uv\_async\_send}, passing \texttt{cond.handle} as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.



Note that events may be coalesced, so multiple calls to \texttt{uv\_async\_send} may result in a single wakeup notification to the condition.



\hypertarget{144011036836523845}{}


\section{More About Callbacks}



For more details on how to pass callbacks to C libraries, see this \href{https://julialang.org/blog/2013/05/callback}{blog post}.



\hypertarget{4039606750368114245}{}


\section{C++}



For direct C++ interfacing, see the \href{https://github.com/Keno/Cxx.jl}{Cxx} package. For tools to create C++ bindings, see the \href{https://github.com/JuliaInterop/CxxWrap.jl}{CxxWrap} package.



\hypertarget{4478407192401635368}{}


\chapter{Handling Operating System Variation}



When dealing with platform libraries, it is often necessary to provide special cases for various platforms. The variable \texttt{Sys.KERNEL} can be used to write these special cases. There are several functions intended to make this easier: \texttt{is\_unix}, \texttt{is\_linux}, \texttt{is\_apple}, \texttt{is\_bsd}, and \texttt{is\_windows}. These may be used as follows:




\begin{minted}{julia}
if is_windows()
    some_complicated_thing(a)
end
\end{minted}



Note that \texttt{is\_linux} and \texttt{is\_apple} are mutually exclusive subsets of \texttt{is\_unix}. Additionally, there is a macro \texttt{@static} which makes it possible to use these functions to conditionally hide invalid code, as demonstrated in the following examples.



Simple blocks:




\begin{lstlisting}
ccall( (@static is_windows() ? :_fopen : :fopen), ...)
\end{lstlisting}



Complex blocks:




\begin{minted}{julia}
@static if is_linux()
    some_complicated_thing(a)
else
    some_different_thing(a)
end
\end{minted}



When chaining conditionals (including if/elseif/end), the \texttt{@static} must be repeated for each level (parentheses optional, but recommended for readability):




\begin{minted}{julia}
@static is_windows() ? :a : (@static is_apple() ? :b : :c)
\end{minted}



\hypertarget{1581416507643810205}{}


\chapter{Environment Variables}



Julia may be configured with a number of environment variables, either in the usual way of the operating system, or in a portable way from within Julia. Suppose you want to set the environment variable \texttt{JULIA\_EDITOR} to \texttt{vim}, then either type \texttt{ENV[{\textquotedbl}JULIA\_EDITOR{\textquotedbl}] = {\textquotedbl}vim{\textquotedbl}} for instance in the REPL to make this change on a case by case basis, or add the same to the user configuration file \texttt{.juliarc.jl} in the user{\textquotesingle}s home directory to have a permanent effect. The current value of the same environment variable is determined by evaluating \texttt{ENV[{\textquotedbl}JULIA\_EDITOR{\textquotedbl}]}.



The environment variables that Julia uses generally start with \texttt{JULIA}. If \hyperlink{4959604240462971450}{\texttt{Base.versioninfo}} is called with \texttt{verbose} equal to \texttt{true}, then the output will list defined environment variables relevant for Julia, including those for which \texttt{JULIA} appears in the name.



\hypertarget{10898854776400220815}{}


\section{File locations}



\hypertarget{16977344973946922110}{}


\subsection{\texttt{JULIA\_HOME}}



The absolute path of the directory containing the Julia executable, which sets the global variable \hyperlink{15863123579738922895}{\texttt{Base.JULIA\_HOME}}. If \texttt{\$JULIA\_HOME} is not set, then Julia determines the value \texttt{Base.JULIA\_HOME} at run-time.



The executable itself is one of




\begin{lstlisting}
$JULIA_HOME/julia
$JULIA_HOME/julia-debug
\end{lstlisting}



by default.



The global variable \texttt{Base.DATAROOTDIR} determines a relative path from \texttt{Base.JULIA\_HOME} to the data directory associated with Julia. Then the path




\begin{lstlisting}
$JULIA_HOME/$DATAROOTDIR/julia/base
\end{lstlisting}



determines the directory in which Julia initially searches for source files (via \texttt{Base.find\_source\_file()}).



Likewise, the global variable \texttt{Base.SYSCONFDIR} determines a relative path to the configuration file directory. Then Julia searches for a \texttt{juliarc.jl} file at




\begin{lstlisting}
$JULIA_HOME/$SYSCONFDIR/julia/juliarc.jl
$JULIA_HOME/../etc/julia/juliarc.jl
\end{lstlisting}



by default (via \texttt{Base.load\_juliarc()}).



For example, a Linux installation with a Julia executable located at \texttt{/bin/julia}, a \texttt{DATAROOTDIR} of \texttt{../share}, and a \texttt{SYSCONFDIR} of \texttt{../etc} will have \texttt{JULIA\_HOME} set to \texttt{/bin}, a source-file search path of




\begin{lstlisting}
/share/julia/base
\end{lstlisting}



and a global configuration search path of




\begin{lstlisting}
/etc/julia/juliarc.jl
\end{lstlisting}



\hypertarget{1363234541366705734}{}


\subsection{\texttt{JULIA\_LOAD\_PATH}}



A separated list of absolute paths that are to be appended to the variable \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}}. (In Unix-like systems, the path separator is \texttt{:}; in Windows systems, the path separator is \texttt{;}.) The \texttt{LOAD\_PATH} variable is where \hyperlink{16690217505788642360}{\texttt{Base.require}} and \texttt{Base.load\_in\_path()} look for code; it defaults to the absolute paths




\begin{lstlisting}
$JULIA_HOME/../local/share/julia/site/v$(VERSION.major).$(VERSION.minor)
$JULIA_HOME/../share/julia/site/v$(VERSION.major).$(VERSION.minor)
\end{lstlisting}



so that, e.g., version 0.6 of Julia on a Linux system with a Julia executable at \texttt{/bin/julia} will have a default \texttt{LOAD\_PATH} of




\begin{lstlisting}
/local/share/julia/site/v0.6
/share/julia/site/v0.6
\end{lstlisting}



\hypertarget{10906004900633915980}{}


\subsection{\texttt{JULIA\_PKGDIR}}



The path of the parent directory \texttt{Pkg.Dir.\_pkgroot()} for the version-specific Julia package repositories. If the path is relative, then it is taken with respect to the working directory. If \texttt{\$JULIA\_PKGDIR} is not set, then \texttt{Pkg.Dir.\_pkgroot()} defaults to




\begin{lstlisting}
$HOME/.julia
\end{lstlisting}



Then the repository location \hyperlink{4800223299836980046}{\texttt{Pkg.dir}} for a given Julia version is




\begin{lstlisting}
$JULIA_PKGDIR/v$(VERSION.major).$(VERSION.minor)
\end{lstlisting}



For example, for a Linux user whose home directory is \texttt{/home/alice}, the directory containing the package repositories would by default be




\begin{lstlisting}
/home/alice/.julia
\end{lstlisting}



and the package repository for version 0.6 of Julia would be




\begin{lstlisting}
/home/alice/.julia/v0.6
\end{lstlisting}



\hypertarget{7464422147684280847}{}


\subsection{\texttt{JULIA\_HISTORY}}



The absolute path \texttt{Base.REPL.find\_hist\_file()} of the REPL{\textquotesingle}s history file. If \texttt{\$JULIA\_HISTORY} is not set, then \texttt{Base.REPL.find\_hist\_file()} defaults to




\begin{lstlisting}
$HOME/.julia_history
\end{lstlisting}



\hypertarget{12321769564794734949}{}


\subsection{\texttt{JULIA\_PKGRESOLVE\_ACCURACY}}



A positive \texttt{Int} that determines how much time the max-sum subroutine \texttt{MaxSum.maxsum()} of the package dependency resolver \hyperlink{246440786291582695}{\texttt{Base.Pkg.resolve}} will devote to attempting satisfying constraints before giving up: this value is by default \texttt{1}, and larger values correspond to larger amounts of time.



Suppose the value of \texttt{\$JULIA\_PKGRESOLVE\_ACCURACY} is \texttt{n}. Then



\begin{itemize}
\item the number of pre-decimation iterations is \texttt{20*n},


\item the number of iterations between decimation steps is \texttt{10*n}, and


\item at decimation steps, at most one in every \texttt{20*n} packages is decimated.

\end{itemize}


\hypertarget{10361309947213171508}{}


\section{External applications}



\hypertarget{12177211249965413749}{}


\subsection{\texttt{JULIA\_SHELL}}



The absolute path of the shell with which Julia should execute external commands (via \texttt{Base.repl\_cmd()}). Defaults to the environment variable \texttt{\$SHELL}, and falls back to \texttt{/bin/sh} if \texttt{\$SHELL} is unset.



\begin{quote}
\textbf{Note}

On Windows, this environment variable is ignored, and external commands are executed directly.

\end{quote}


\hypertarget{327473439132778011}{}


\subsection{\texttt{JULIA\_EDITOR}}



The editor returned by \texttt{Base.editor()} and used in, e.g., \hyperlink{7044880690333675643}{\texttt{Base.edit}}, referring to the command of the preferred editor, for instance \texttt{vim}.



\texttt{\$JULIA\_EDITOR} takes precedence over \texttt{\$VISUAL}, which in turn takes precedence over \texttt{\$EDITOR}. If none of these environment variables is set, then the editor is taken to be \texttt{open} on Windows and OS X, or \texttt{/etc/alternatives/editor} if it exists, or \texttt{emacs} otherwise.



\begin{quote}
\textbf{Note}

\texttt{\$JULIA\_EDITOR} is \emph{not} used in the determination of the editor for \hyperlink{3124493295760422384}{\texttt{Base.Pkg.edit}}: this function checks \texttt{\$VISUAL} and \texttt{\$EDITOR} alone.

\end{quote}


\hypertarget{413071238949720018}{}


\section{Parallelization}



\hypertarget{12080077898249568422}{}


\subsection{\texttt{JULIA\_CPU\_CORES}}



Overrides the global variable \hyperlink{8935415573697237606}{\texttt{Base.Sys.CPU\_CORES}}, the number of logical CPU cores available.



\hypertarget{17625390316676574932}{}


\subsection{\texttt{JULIA\_WORKER\_TIMEOUT}}



A \hyperlink{5027751419500983000}{\texttt{Float64}} that sets the value of \texttt{Base.worker\_timeout()} (default: \texttt{60.0}). This function gives the number of seconds a worker process will wait for a master process to establish a connection before dying.



\hypertarget{7328254851646027731}{}


\subsection{\texttt{JULIA\_NUM\_THREADS}}



An unsigned 64-bit integer (\texttt{uint64\_t}) that sets the maximum number of threads available to Julia. If \texttt{\$JULIA\_NUM\_THREADS} exceeds the number of available physical CPU cores, then the number of threads is set to the number of cores. If \texttt{\$JULIA\_NUM\_THREADS} is not positive or is not set, or if the number of CPU cores cannot be determined through system calls, then the number of threads is set to \texttt{1}.



\hypertarget{10532418503410947704}{}


\subsection{\texttt{JULIA\_THREAD\_SLEEP\_THRESHOLD}}



If set to a string that starts with the case-insensitive substring \texttt{{\textquotedbl}infinite{\textquotedbl}}, then spinning threads never sleep. Otherwise, \texttt{\$JULIA\_THREAD\_SLEEP\_THRESHOLD} is interpreted as an unsigned 64-bit integer (\texttt{uint64\_t}) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.



\hypertarget{12794875033848178110}{}


\subsection{\texttt{JULIA\_EXCLUSIVE}}



If set to anything besides \texttt{0}, then Julia{\textquotesingle}s thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.



\hypertarget{15272312977385719181}{}


\section{REPL formatting}



Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to \href{http://ascii-table.com/ansi-escape-sequences.php}{ANSI terminal escape sequences}. Julia provides a high-level interface with much of the same functionality: see the section on \hyperlink{9220662049678686366}{Interacting With Julia}.



\hypertarget{13891100922495428417}{}


\subsection{\texttt{JULIA\_ERROR\_COLOR}}



The formatting \texttt{Base.error\_color()} (default: light red, \texttt{{\textquotedbl}{\textbackslash}033[91m{\textquotedbl}}) that errors should have at the terminal.



\hypertarget{17711733982596187514}{}


\subsection{\texttt{JULIA\_WARN\_COLOR}}



The formatting \texttt{Base.warn\_color()} (default: yellow, \texttt{{\textquotedbl}{\textbackslash}033[93m{\textquotedbl}}) that warnings should have at the terminal.



\hypertarget{10994657891761481518}{}


\subsection{\texttt{JULIA\_INFO\_COLOR}}



The formatting \texttt{Base.info\_color()} (default: cyan, \texttt{{\textquotedbl}{\textbackslash}033[36m{\textquotedbl}}) that info should have at the terminal.



\hypertarget{7277467062996316804}{}


\subsection{\texttt{JULIA\_INPUT\_COLOR}}



The formatting \texttt{Base.input\_color()} (default: normal, \texttt{{\textquotedbl}{\textbackslash}033[0m{\textquotedbl}}) that input should have at the terminal.



\hypertarget{11974933399373427924}{}


\subsection{\texttt{JULIA\_ANSWER\_COLOR}}



The formatting \texttt{Base.answer\_color()} (default: normal, \texttt{{\textquotedbl}{\textbackslash}033[0m{\textquotedbl}}) that output should have at the terminal.



\hypertarget{1071250415559095053}{}


\subsection{\texttt{JULIA\_STACKFRAME\_LINEINFO\_COLOR}}



The formatting \texttt{Base.stackframe\_lineinfo\_color()} (default: bold, \texttt{{\textquotedbl}{\textbackslash}033[1m{\textquotedbl}}) that line info should have during a stack trace at the terminal.



\hypertarget{15357004504591912181}{}


\subsection{\texttt{JULIA\_STACKFRAME\_FUNCTION\_COLOR}}



The formatting \texttt{Base.stackframe\_function\_color()} (default: bold, \texttt{{\textquotedbl}{\textbackslash}033[1m{\textquotedbl}}) that function calls should have during a stack trace at the terminal.



\hypertarget{17883302099195179636}{}


\section{Debugging and profiling}



\hypertarget{17935900017233878037}{}


\subsection{\texttt{JULIA\_GC\_ALLOC\_POOL}, \texttt{JULIA\_GC\_ALLOC\_OTHER}, \texttt{JULIA\_GC\_ALLOC\_PRINT}}



If set, these environment variables take strings that optionally start with the character \texttt{{\textquotesingle}r{\textquotesingle}}, followed by a string interpolation of a colon-separated list of three signed 64-bit integers (\texttt{int64\_t}). This triple of integers \texttt{a:b:c} represents the arithmetic sequence \texttt{a}, \texttt{a + b}, \texttt{a + 2*b}, ... \texttt{c}.



\begin{itemize}
\item If it{\textquotesingle}s the \texttt{n}th time that \texttt{jl\_gc\_pool\_alloc()} has been called, and \texttt{n}   belongs to the arithmetic sequence represented by \texttt{\$JULIA\_GC\_ALLOC\_POOL},   then garbage collection is forced.


\item If it{\textquotesingle}s the \texttt{n}th time that \texttt{maybe\_collect()} has been called, and \texttt{n} belongs   to the arithmetic sequence represented by \texttt{\$JULIA\_GC\_ALLOC\_OTHER}, then garbage   collection is forced.


\item If it{\textquotesingle}s the \texttt{n}th time that \texttt{jl\_gc\_collect()} has been called, and \texttt{n} belongs   to the arithmetic sequence represented by \texttt{\$JULIA\_GC\_ALLOC\_PRINT}, then counts   for the number of calls to \texttt{jl\_gc\_pool\_alloc()} and \texttt{maybe\_collect()} are   printed.

\end{itemize}


If the value of the environment variable begins with the character \texttt{{\textquotesingle}r{\textquotesingle}}, then the interval between garbage collection events is randomized.



\begin{quote}
\textbf{Note}

These environment variables only have an effect if Julia was compiled with garbage-collection debugging (that is, if \texttt{WITH\_GC\_DEBUG\_ENV} is set to \texttt{1} in the build configuration).

\end{quote}


\hypertarget{15291982466110123243}{}


\subsection{\texttt{JULIA\_GC\_NO\_GENERATIONAL}}



If set to anything besides \texttt{0}, then the Julia garbage collector never performs {\textquotedbl}quick sweeps{\textquotedbl} of memory.



\begin{quote}
\textbf{Note}

This environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if \texttt{WITH\_GC\_DEBUG\_ENV} is set to \texttt{1} in the build configuration).

\end{quote}


\hypertarget{4439082668862420182}{}


\subsection{\texttt{JULIA\_GC\_WAIT\_FOR\_DEBUGGER}}



If set to anything besides \texttt{0}, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there{\textquotesingle}s a critical error.



\begin{quote}
\textbf{Note}

This environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if \texttt{WITH\_GC\_DEBUG\_ENV} is set to \texttt{1} in the build configuration).

\end{quote}


\hypertarget{1100661411174026998}{}


\subsection{\texttt{ENABLE\_JITPROFILING}}



If set to anything besides \texttt{0}, then the compiler will create and register an event listener for just-in-time (JIT) profiling.



\begin{quote}
\textbf{Note}

This environment variable only has an effect if Julia was compiled with JIT profiling support, using either

\end{quote}


\begin{itemize}
\item Intel{\textquotesingle}s \href{https://software.intel.com/en-us/intel-vtune-amplifier-xe}{VTune™ Amplifier}   (\texttt{USE\_INTEL\_JITEVENTS} set to \texttt{1} in the build configuration), or


\item \href{http://oprofile.sourceforge.net/news/}{OProfile} (\texttt{USE\_OPROFILE\_JITEVENTS} set to \texttt{1}   in the build configuration).

\end{itemize}


\hypertarget{12744946110825549407}{}


\subsection{\texttt{JULIA\_LLVM\_ARGS}}



Arguments to be passed to the LLVM backend.



\begin{quote}
\textbf{Note}

This environment variable has an effect only if Julia was compiled with \texttt{JL\_DEBUG\_BUILD} set — in particular, the \texttt{julia-debug} executable is always compiled with this build variable.

\end{quote}


\hypertarget{2233455458339293271}{}


\subsection{\texttt{JULIA\_DEBUG\_LOADING}}



If set, then Julia prints detailed information about the cache in the loading process of \hyperlink{16690217505788642360}{\texttt{Base.require}}.



\hypertarget{7688715278401899796}{}


\chapter{Embedding Julia}



As we have seen in \hyperlink{17572913146419880234}{Calling C and Fortran Code}, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C\#).



\hypertarget{2692186280181047639}{}


\section{High-Level Embedding}



We start with a simple C program that initializes Julia and calls some Julia code:




\begin{lstlisting}
#include <julia.h>

int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string("print(sqrt(2.0))");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



In order to build this program you have to put the path to the Julia header into the include path and link against \texttt{libjulia}. For instance, when Julia is installed to \texttt{\$JULIA\_DIR}, one can compile the above test program \texttt{test.c} with \texttt{gcc} using:




\begin{lstlisting}
gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib test.c -ljulia $JULIA_DIR/lib/julia/libstdc++.so.6
\end{lstlisting}



Then if the environment variable \texttt{JULIA\_HOME} is set to \texttt{\$JULIA\_DIR/bin}, the output \texttt{test} program can be executed.



Alternatively, look at the \texttt{embedding.c} program in the Julia source tree in the \texttt{examples/} folder. The file \texttt{ui/repl.c} program is another simple example of how to set \texttt{jl\_options} options while linking against \texttt{libjulia}.



The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling \texttt{jl\_init}, which tries to automatically determine Julia{\textquotesingle}s install location. If you need to specify a custom location, or specify which system image to load, use \texttt{jl\_init\_with\_image} instead.



The second statement in the test program evaluates a Julia statement using a call to \texttt{jl\_eval\_string}.



Before the program terminates, it is strongly recommended to call \texttt{jl\_atexit\_hook}.  The above example program calls this before returning from \texttt{main}.



\begin{quote}
\textbf{Note}

Currently, dynamically linking with the \texttt{libjulia} shared library requires passing the \texttt{RTLD\_GLOBAL} option. In Python, this looks like:


\begin{lstlisting}
>>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)
>>> julia.jl_init.argtypes = []
>>> julia.jl_init()
250593296
\end{lstlisting}

\end{quote}


\begin{quote}
\textbf{Note}

If the julia program needs to access symbols from the main executable, it may be necessary to add \texttt{-Wl,--export-dynamic} linker flag at compile time on Linux in addition to the ones generated by \texttt{julia-config.jl} described below. This is not necessary when compiling a shared library.

\end{quote}


\hypertarget{7452394744805348324}{}


\subsection{Using julia-config to automatically determine build parameters}



The script \texttt{julia-config.jl} was created to aid in determining what build parameters are required by a program that uses embedded Julia.  This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution.  This script is located in the Julia shared data directory.



\hypertarget{3004524604150878810}{}


\subsubsection{Example}




\begin{lstlisting}
#include <julia.h>

int main(int argc, char *argv[])
{
    jl_init();
    (void)jl_eval_string("println(sqrt(2.0))");
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



\hypertarget{3428797394902131495}{}


\subsubsection{On the command line}



A simple use of this script is from the command line.  Assuming that \texttt{julia-config.jl} is located in \texttt{/usr/local/julia/share/julia}, it can be invoked on the command line directly and takes any combination of 3 flags:




\begin{lstlisting}
/usr/local/julia/share/julia/julia-config.jl
Usage: julia-config [--cflags|--ldflags|--ldlibs]
\end{lstlisting}



If the above example source is saved in the file \texttt{embed\_example.c}, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute \texttt{clang} for \texttt{gcc}.:




\begin{lstlisting}
/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c
\end{lstlisting}



\hypertarget{4427716365208739491}{}


\subsubsection{Use in Makefiles}



But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well – assuming GNU make because of the use of the \textbf{shell} macro expansions.  Additionally, though many times \texttt{julia-config.jl} may be found in the directory \texttt{/usr/local}, this is not necessarily the case, but Julia can be used to locate \texttt{julia-config.jl} too, and the makefile can be used to take advantage of that.  The above example is extended to use a Makefile:




\begin{lstlisting}
JL_SHARE = $(shell julia -e 'print(joinpath(JULIA_HOME,Base.DATAROOTDIR,"julia"))')
CFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
LDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example
\end{lstlisting}



Now the build command is simply \texttt{make}.



\hypertarget{15196043106042315499}{}


\section{Converting Types}



Real applications will not just need to execute expressions, but also return their values to the host program. \texttt{jl\_eval\_string} returns a \texttt{jl\_value\_t*}, which is a pointer to a heap-allocated Julia object. Storing simple data types like \hyperlink{5027751419500983000}{\texttt{Float64}} in this way is called \texttt{boxing}, and extracting the stored primitive data is called \texttt{unboxing}. Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C looks as follows:




\begin{lstlisting}
jl_value_t *ret = jl_eval_string("sqrt(2.0)");

if (jl_typeis(ret, jl_float64_type)) {
    double ret_unboxed = jl_unbox_float64(ret);
    printf("sqrt(2.0) in C: %e \n", ret_unboxed);
}
else {
    printf("ERROR: unexpected return type from sqrt(::Float64)\n");
}
\end{lstlisting}



In order to check whether \texttt{ret} is of a specific Julia type, we can use the \texttt{jl\_isa}, \texttt{jl\_typeis}, or \texttt{jl\_is\_...} functions. By typing \texttt{typeof(sqrt(2.0))} into the Julia shell we can see that the return type is \hyperlink{5027751419500983000}{\texttt{Float64}} (\texttt{double} in C). To convert the boxed Julia value into a C double the \texttt{jl\_unbox\_float64} function is used in the above code snippet.



Corresponding \texttt{jl\_box\_...} functions are used to convert the other way:




\begin{lstlisting}
jl_value_t *a = jl_box_float64(3.0);
jl_value_t *b = jl_box_float32(3.0f);
jl_value_t *c = jl_box_int32(3);
\end{lstlisting}



As we will see next, boxing is required to call Julia functions with specific arguments.



\hypertarget{12323658234921669115}{}


\section{Calling Julia Functions}



While \texttt{jl\_eval\_string} allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using \texttt{jl\_call}:




\begin{lstlisting}
jl_function_t *func = jl_get_function(jl_base_module, "sqrt");
jl_value_t *argument = jl_box_float64(2.0);
jl_value_t *ret = jl_call1(func, argument);
\end{lstlisting}



In the first step, a handle to the Julia function \texttt{sqrt} is retrieved by calling \texttt{jl\_get\_function}. The first argument passed to \texttt{jl\_get\_function} is a pointer to the \texttt{Base} module in which \texttt{sqrt} is defined. Then, the double value is boxed using \texttt{jl\_box\_float64}. Finally, in the last step, the function is called using \texttt{jl\_call1}. \texttt{jl\_call0}, \texttt{jl\_call2}, and \texttt{jl\_call3} functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use \texttt{jl\_call}:




\begin{lstlisting}
jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)
\end{lstlisting}



Its second argument \texttt{args} is an array of \texttt{jl\_value\_t*} arguments and \texttt{nargs} is the number of arguments.



\hypertarget{8210663840912105043}{}


\section{Memory Management}



As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.



Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.



The GC can only run when Julia objects are allocated. Calls like \texttt{jl\_box\_float64} perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between \texttt{jl\_...} calls. But in order to make sure that values can survive \texttt{jl\_...} calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the \texttt{JL\_GC\_PUSH} macros:




\begin{lstlisting}
jl_value_t *ret = jl_eval_string("sqrt(2.0)");
JL_GC_PUSH1(&ret);
// Do something with ret
JL_GC_POP();
\end{lstlisting}



The \texttt{JL\_GC\_POP} call releases the references established by the previous \texttt{JL\_GC\_PUSH}. Note that \texttt{JL\_GC\_PUSH}  is working on the stack, so it must be exactly paired with a \texttt{JL\_GC\_POP} before the stack frame is destroyed.



Several Julia values can be pushed at once using the \texttt{JL\_GC\_PUSH2} , \texttt{JL\_GC\_PUSH3} , and \texttt{JL\_GC\_PUSH4} macros. To push an array of Julia values one can use the  \texttt{JL\_GC\_PUSHARGS} macro, which can be used as follows:




\begin{lstlisting}
jl_value_t **args;
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects
args[0] = some_value;
args[1] = some_other_value;
// Do something with args (e.g. call jl_... functions)
JL_GC_POP();
\end{lstlisting}



The garbage collector also operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the \texttt{jl\_gc\_wb} (write barrier) function like so:




\begin{lstlisting}
jl_value_t *parent = some_old_value, *child = some_young_value;
((some_specific_type*)parent)->field = child;
jl_gc_wb(parent, child);
\end{lstlisting}



It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the \texttt{parent} object was just allocated and garbage collection was not run since then. Remember that most \texttt{jl\_...} functions can sometimes invoke garbage collection.



The write barrier is also necessary for arrays of pointers when updating their data directly. For example:




\begin{lstlisting}
jl_array_t *some_array = ...; // e.g. a Vector{Any}
void **data = (void**)jl_array_data(some_array);
jl_value_t *some_value = ...;
data[0] = some_value;
jl_gc_wb(some_array, some_value);
\end{lstlisting}



\hypertarget{10013959686315797399}{}


\subsection{Manipulating the Garbage Collector}



There are some functions to control the GC. In normal use cases, these should not be necessary.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\texttt{jl\_gc\_collect()} & Force a GC run \\
\hline
\texttt{jl\_gc\_enable(0)} & Disable the GC, return previous state as int \\
\hline
\texttt{jl\_gc\_enable(1)} & Enable the GC,  return previous state as int \\
\hline
\texttt{jl\_gc\_is\_enabled()} & Return current state as int \\
\hline
\end{tabulary}

\end{table}



\hypertarget{11331212931537392185}{}


\section{Working with Arrays}



Julia and C can share array data without copying. The next example will show how this works.



Julia arrays are represented in C by the datatype \texttt{jl\_array\_t*}. Basically, \texttt{jl\_array\_t} is a struct that contains:



\begin{itemize}
\item Information about the datatype


\item A pointer to the data block


\item Information about the sizes of the array

\end{itemize}


To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:




\begin{lstlisting}
jl_value_t* array_type = jl_apply_array_type(jl_float64_type, 1);
jl_array_t* x          = jl_alloc_array_1d(array_type, 10);
\end{lstlisting}



Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:




\begin{lstlisting}
double *existingArray = (double*)malloc(sizeof(double)*10);
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);
\end{lstlisting}



The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call \texttt{free} on the data pointer when the array is no longer referenced.



In order to access the data of x, we can use \texttt{jl\_array\_data}:




\begin{lstlisting}
double *xData = (double*)jl_array_data(x);
\end{lstlisting}



Now we can fill the array:




\begin{lstlisting}
for(size_t i=0; i<jl_array_len(x); i++)
    xData[i] = i;
\end{lstlisting}



Now let us call a Julia function that performs an in-place operation on \texttt{x}:




\begin{lstlisting}
jl_function_t *func = jl_get_function(jl_base_module, "reverse!");
jl_call1(func, (jl_value_t*)x);
\end{lstlisting}



By printing the array, one can verify that the elements of \texttt{x} are now reversed.



\hypertarget{7420178557371558504}{}


\subsection{Accessing Returned Arrays}



If a Julia function returns an array, the return value of \texttt{jl\_eval\_string} and \texttt{jl\_call} can be cast to a \texttt{jl\_array\_t*}:




\begin{lstlisting}
jl_function_t *func  = jl_get_function(jl_base_module, "reverse");
jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);
\end{lstlisting}



Now the content of \texttt{y} can be accessed as before using \texttt{jl\_array\_data}. As always, be sure to keep a reference to the array while it is in use.



\hypertarget{14696119346407960155}{}


\subsection{Multidimensional Arrays}



Julia{\textquotesingle}s multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:




\begin{lstlisting}
// Create 2D array of float64 type
jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);
jl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);

// Get array pointer
double *p = (double*)jl_array_data(x);
// Get number of dimensions
int ndims = jl_array_ndims(x);
// Get the size of the i-th dim
size_t size0 = jl_array_dim(x,0);
size_t size1 = jl_array_dim(x,1);

// Fill array with data
for(size_t i=0; i<size1; i++)
    for(size_t j=0; j<size0; j++)
        p[j + size0*i] = i + j;
\end{lstlisting}



Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling \texttt{jl\_array\_dim}) in order to read as idiomatic C code.



\hypertarget{15281182540313819412}{}


\section{Exceptions}



Julia code can throw exceptions. For example, consider:




\begin{lstlisting}
jl_eval_string("this_function_does_not_exist()");
\end{lstlisting}



This call will appear to do nothing. However, it is possible to check whether an exception was thrown:




\begin{lstlisting}
if (jl_exception_occurred())
    printf("%s \n", jl_typeof_str(jl_exception_occurred()));
\end{lstlisting}



If you are using the Julia C API from a language that supports exceptions (e.g. Python, C\#, C++), it makes sense to wrap each call into \texttt{libjulia} with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.



\hypertarget{6187003825237320013}{}


\subsection{Throwing Julia Exceptions}



When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:




\begin{lstlisting}
if (!jl_typeis(val, jl_float64_type)) {
    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);
}
\end{lstlisting}



General exceptions can be raised using the functions:




\begin{lstlisting}
void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);
\end{lstlisting}



\texttt{jl\_error} takes a C string, and \texttt{jl\_errorf} is called like \texttt{printf}:




\begin{lstlisting}
jl_errorf("argument x = %d is too large", x);
\end{lstlisting}



where in this example \texttt{x} is assumed to be an integer.



\hypertarget{9952244917530713055}{}


\chapter{Packages}



Julia has a built-in package manager for installing add-on functionality written in Julia. It can also install external libraries using your operating system{\textquotesingle}s standard system for doing so, or by compiling from source. The list of registered Julia packages can be found at \href{http://pkg.julialang.org}{http://pkg.julialang.org}. All package manager commands are found in the \texttt{Pkg} module, included in Julia{\textquotesingle}s \texttt{Base} install.



First we{\textquotesingle}ll go over the mechanics of the \texttt{Pkg} family of commands and then we{\textquotesingle}ll provide some guidance on how to get your package registered. Be sure to read the section below on package naming conventions, tagging versions and the importance of a \texttt{REQUIRE} file for when you{\textquotesingle}re ready to add your code to the curated METADATA repository.



\hypertarget{4569897111701597415}{}


\section{Package Status}



The \hyperlink{7389584356782450249}{\texttt{Pkg.status()}} function prints out a summary of the state of packages you have installed. Initially, you{\textquotesingle}ll have no packages installed:




\begin{minted}{jlcon}
julia> Pkg.status()
INFO: Initializing package repository /Users/stefan/.julia/v0.6
INFO: Cloning METADATA from git://github.com/JuliaLang/METADATA.jl
No packages installed.
\end{minted}



Your package directory is automatically initialized the first time you run a \texttt{Pkg} command that expects it to exist – which includes \hyperlink{7389584356782450249}{\texttt{Pkg.status()}}. Here{\textquotesingle}s an example non-trivial set of required and additional packages:




\begin{minted}{jlcon}
julia> Pkg.status()
Required packages:
 - Distributions                 0.2.8
 - SHA                           0.3.2
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.6
\end{minted}



These packages are all on registered versions, managed by \texttt{Pkg}. Packages can be in more complicated states, indicated by annotations to the right of the installed package version; we will explain these states and annotations as we encounter them. For programmatic usage, \hyperlink{10971725533820181631}{\texttt{Pkg.installed()}} returns a dictionary, mapping installed package names to the version of that package which is installed:




\begin{minted}{jlcon}
julia> Pkg.installed()
Dict{String,VersionNumber} with 4 entries:
"Distributions"     => v"0.2.8"
"Stats"             => v"0.2.6"
"SHA"               => v"0.3.2"
"NumericExtensions" => v"0.2.17"
\end{minted}



\hypertarget{4708678209928683701}{}


\section{Adding and Removing Packages}



Julia{\textquotesingle}s package manager is a little unusual in that it is declarative rather than imperative. This means that you tell it what you want and it figures out what versions to install (or remove) to satisfy those requirements optimally – and minimally. So rather than installing a package, you just add it to the list of requirements and then {\textquotedbl}resolve{\textquotedbl} what needs to be installed. In particular, this means that if some package had been installed because it was needed by a previous version of something you wanted, and a newer version doesn{\textquotesingle}t have that requirement anymore, updating will actually remove that package.



Your package requirements are in the file \texttt{{\textasciitilde}/.julia/v0.6/REQUIRE}. You can edit this file by hand and then call \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} to install, upgrade or remove packages to optimally satisfy the requirements, or you can do \hyperlink{3124493295760422384}{\texttt{Pkg.edit()}}, which will open \texttt{REQUIRE} in your editor (configured via the \texttt{EDITOR} or \texttt{VISUAL} environment variables), and then automatically call \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} afterwards if necessary. If you only want to add or remove the requirement for a single package, you can also use the non-interactive \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} and \hyperlink{13989694063022152176}{\texttt{Pkg.rm()}} commands, which add or remove a single requirement to \texttt{REQUIRE} and then call \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}}.



You can add a package to the list of requirements with the \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} function, and the package and all the packages that it depends on will be installed:




\begin{minted}{jlcon}
julia> Pkg.status()
No packages installed.

julia> Pkg.add("Distributions")
INFO: Cloning cache of Distributions from git://github.com/JuliaStats/Distributions.jl.git
INFO: Cloning cache of NumericExtensions from git://github.com/lindahua/NumericExtensions.jl.git
INFO: Cloning cache of Stats from git://github.com/JuliaStats/Stats.jl.git
INFO: Installing Distributions v0.2.7
INFO: Installing NumericExtensions v0.2.17
INFO: Installing Stats v0.2.6
INFO: REQUIRE updated.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.7
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.6
\end{minted}



What this is doing is first adding \texttt{Distributions} to your \texttt{{\textasciitilde}/.julia/v0.6/REQUIRE} file:




\begin{lstlisting}
$ cat ~/.julia/v0.6/REQUIRE
Distributions
\end{lstlisting}



It then runs \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} using these new requirements, which leads to the conclusion that the \texttt{Distributions} package should be installed since it is required but not installed. As stated before, you can accomplish the same thing by editing your \texttt{{\textasciitilde}/.julia/v0.6/REQUIRE} file by hand and then running \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} yourself:




\begin{minted}{jlcon}
$ echo SHA >> ~/.julia/v0.6/REQUIRE

julia> Pkg.resolve()
INFO: Cloning cache of SHA from git://github.com/staticfloat/SHA.jl.git
INFO: Installing SHA v0.3.2

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.7
 - SHA                           0.3.2
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.6
\end{minted}



This is functionally equivalent to calling \hyperlink{10284711283997279340}{\texttt{Pkg.add({\textquotedbl}SHA{\textquotedbl})}}, except that \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} doesn{\textquotesingle}t change \texttt{REQUIRE} until \emph{after} installation has completed, so if there are problems, \texttt{REQUIRE} will be left as it was before calling \hyperlink{10284711283997279340}{\texttt{Pkg.add()}}. The format of the \texttt{REQUIRE} file is described in \hyperlink{16110950416626149644}{Requirements Specification}; it allows, among other things, requiring specific ranges of versions of packages.



When you decide that you don{\textquotesingle}t want to have a package around any more, you can use \hyperlink{13989694063022152176}{\texttt{Pkg.rm()}} to remove the requirement for it from the \texttt{REQUIRE} file:




\begin{minted}{jlcon}
julia> Pkg.rm("Distributions")
INFO: Removing Distributions v0.2.7
INFO: Removing Stats v0.2.6
INFO: Removing NumericExtensions v0.2.17
INFO: REQUIRE updated.

julia> Pkg.status()
Required packages:
 - SHA                           0.3.2

julia> Pkg.rm("SHA")
INFO: Removing SHA v0.3.2
INFO: REQUIRE updated.

julia> Pkg.status()
No packages installed.
\end{minted}



Once again, this is equivalent to editing the \texttt{REQUIRE} file to remove the line with each package name on it then running \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} to update the set of installed packages to match. While \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} and \hyperlink{13989694063022152176}{\texttt{Pkg.rm()}} are convenient for adding and removing requirements for a single package, when you want to add or remove multiple packages, you can call \hyperlink{3124493295760422384}{\texttt{Pkg.edit()}} to manually change the contents of \texttt{REQUIRE} and then update your packages accordingly. \hyperlink{3124493295760422384}{\texttt{Pkg.edit()}} does not roll back the contents of \texttt{REQUIRE} if \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} fails – rather, you have to run \hyperlink{3124493295760422384}{\texttt{Pkg.edit()}} again to fix the files contents yourself.



Because the package manager uses libgit2 internally to manage the package git repositories, users may run into protocol issues (if behind a firewall, for example), when running \hyperlink{10284711283997279340}{\texttt{Pkg.add()}}. By default, all GitHub-hosted packages wil be accessed via {\textquotesingle}https{\textquotesingle}; this default can be modified by calling \hyperlink{16637824229915276013}{\texttt{Pkg.setprotocol!()}}. The following command can be run from the command line in order to tell git to use {\textquotesingle}https{\textquotesingle} instead of the {\textquotesingle}git{\textquotesingle} protocol when cloning all repositories, wherever they are hosted:




\begin{lstlisting}
git config --global url."https://".insteadOf git://
\end{lstlisting}



However, this change will be system-wide and thus the use of \hyperlink{16637824229915276013}{\texttt{Pkg.setprotocol!()}} is preferable.



\begin{quote}
\textbf{Note}

The package manager functions also accept the \texttt{.jl} suffix on package names, though the suffix is stripped internally. For example:


\begin{minted}{julia}
Pkg.add("Distributions.jl")
Pkg.rm("Distributions.jl")
\end{minted}

\end{quote}


\hypertarget{3678752773734988809}{}


\section{Offline Installation of Packages}



For machines with no Internet connection, packages may be installed by copying the package root directory (given by \hyperlink{4800223299836980046}{\texttt{Pkg.dir()}}) from a machine with the same operating system and environment.



\hyperlink{10284711283997279340}{\texttt{Pkg.add()}} does the following within the package root directory:



\begin{itemize}
\item[1. ] Adds the name of the package to \texttt{REQUIRE}.


\item[2. ] Downloads the package to \texttt{.cache}, then copies the package to the package root directory.


\item[3. ] Recursively performs step 2 against all the packages listed in the package{\textquotesingle}s \texttt{REQUIRE} file.


\item[4. ] Runs \hyperlink{8295561239210722937}{\texttt{Pkg.build()}}

\end{itemize}


\begin{quote}
\textbf{Warning}

Copying installed packages from a different machine is brittle for packages requiring binary external dependencies. Such packages may break due to differences in operating system versions, build environments, and/or absolute path dependencies.

\end{quote}


\hypertarget{16787287787268232709}{}


\section{Installing Unregistered Packages}



Julia packages are simply git repositories, clonable via any of the \href{https://www.kernel.org/pub/software/scm/git/docs/git-clone.html\#URLS}{protocols} that git supports, and containing Julia code that follows certain layout conventions. Official Julia packages are registered in the \href{https://github.com/JuliaLang/METADATA.jl}{METADATA.jl} repository, available at a well-known location \footnotemark[1]. The \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} and \hyperlink{13989694063022152176}{\texttt{Pkg.rm()}} commands in the previous section interact with registered packages, but the package manager can install and work with unregistered packages too. To install an unregistered package, use \hyperlink{12404258328199389568}{\texttt{Pkg.clone(url)}}, where \texttt{url} is a git URL from which the package can be cloned:




\begin{minted}{jlcon}
julia> Pkg.clone("git://example.com/path/to/Package.jl.git")
INFO: Cloning Package from git://example.com/path/to/Package.jl.git
Cloning into 'Package'...
remote: Counting objects: 22, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 22 (delta 8), reused 22 (delta 8)
Receiving objects: 100% (22/22), 2.64 KiB, done.
Resolving deltas: 100% (8/8), done.
\end{minted}



By convention, Julia repository names end with \texttt{.jl} (the additional \texttt{.git} indicates a {\textquotedbl}bare{\textquotedbl} git repository), which keeps them from colliding with repositories for other languages, and also makes Julia packages easy to find in search engines. When packages are installed in your \texttt{.julia/v0.6} directory, however, the extension is redundant so we leave it off.



If unregistered packages contain a \texttt{REQUIRE} file at the top of their source tree, that file will be used to determine which registered packages the unregistered package depends on, and they will automatically be installed. Unregistered packages participate in the same version resolution logic as registered packages, so installed package versions will be adjusted as necessary to satisfy the requirements of both registered and unregistered packages.



\footnotetext[1]{The official set of packages is at \href{https://github.com/JuliaLang/METADATA.jl}{https://github.com/JuliaLang/METADATA.jl}, but individuals and organizations can easily use a different metadata repository. This allows control which packages are available for automatic installation. One can allow only audited and approved package versions, and make private packages or forks available. See \hyperlink{17535558414921821394}{Custom METADATA Repository} for details.

}


\hypertarget{16740892132305394109}{}


\section{Updating Packages}



When package developers publish new registered versions of packages that you{\textquotesingle}re using, you will, of course, want the new shiny versions. To get the latest and greatest versions of all your packages, just do \hyperlink{14197801802374863313}{\texttt{Pkg.update()}}:




\begin{minted}{jlcon}
julia> Pkg.update()
INFO: Updating METADATA...
INFO: Computing changes...
INFO: Upgrading Distributions: v0.2.8 => v0.2.10
INFO: Upgrading Stats: v0.2.7 => v0.2.8
\end{minted}



The first step of updating packages is to pull new changes to \texttt{{\textasciitilde}/.julia/v0.6/METADATA} and see if any new registered package versions have been published. After this, \hyperlink{14197801802374863313}{\texttt{Pkg.update()}} attempts to update packages that are checked out on a branch and not dirty (i.e. no changes have been made to files tracked by git) by pulling changes from the package{\textquotesingle}s upstream repository. Upstream changes will only be applied if no merging or rebasing is necessary – i.e. if the branch can be \href{https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging}{{\textquotedbl}fast-forwarded{\textquotedbl}}. If the branch cannot be fast-forwarded, it is assumed that you{\textquotesingle}re working on it and will update the repository yourself.



Finally, the update process recomputes an optimal set of package versions to have installed to satisfy your top-level requirements and the requirements of {\textquotedbl}fixed{\textquotedbl} packages. A package is considered fixed if it is one of the following:



\begin{itemize}
\item[1. ] \textbf{Unregistered:} the package is not in \texttt{METADATA} – you installed it with \hyperlink{12404258328199389568}{\texttt{Pkg.clone()}}.


\item[2. ] \textbf{Checked out:} the package repo is on a development branch.


\item[3. ] \textbf{Dirty:} changes have been made to files in the repo.

\end{itemize}


If any of these are the case, the package manager cannot freely change the installed version of the package, so its requirements must be satisfied by whatever other package versions it picks. The combination of top-level requirements in \texttt{{\textasciitilde}/.julia/v0.6/REQUIRE} and the requirement of fixed packages are used to determine what should be installed.



You can also update only a subset of the installed packages, by providing arguments to the \hyperlink{14197801802374863313}{\texttt{Pkg.update}} function. In that case, only the packages provided as arguments and their dependencies will be updated:




\begin{minted}{jlcon}
julia> Pkg.update("Example")
INFO: Updating METADATA...
INFO: Computing changes...
INFO: Upgrading Example: v0.4.0 => 0.4.1
\end{minted}



This partial update process still computes the new set of package versions according to top-level requirements and {\textquotedbl}fixed{\textquotedbl} packages, but it additionally considers all other packages except those explicitly provided, and their dependencies, as fixed.



\hypertarget{17682929269364598503}{}


\section{Checkout, Pin and Free}



You may want to use the \texttt{master} version of a package rather than one of its registered versions. There might be fixes or functionality on master that you need that aren{\textquotesingle}t yet published in any registered versions, or you may be a developer of the package and need to make changes on \texttt{master} or some other development branch. In such cases, you can do \hyperlink{13289698592044275412}{\texttt{Pkg.checkout(pkg)}} to checkout the \texttt{master} branch of \texttt{pkg} or \hyperlink{13289698592044275412}{\texttt{Pkg.checkout(pkg,branch)}} to checkout some other branch:




\begin{minted}{jlcon}
julia> Pkg.add("Distributions")
INFO: Installing Distributions v0.2.9
INFO: Installing NumericExtensions v0.2.17
INFO: Installing Stats v0.2.7
INFO: REQUIRE updated.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7

julia> Pkg.checkout("Distributions")
INFO: Checking out Distributions master...
INFO: No packages to install, update or remove.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9+             master
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7
\end{minted}



Immediately after installing \texttt{Distributions} with \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} it is on the current most recent registered version – \texttt{0.2.9} at the time of writing this. Then after running \hyperlink{13289698592044275412}{\texttt{Pkg.checkout({\textquotedbl}Distributions{\textquotedbl})}}, you can see from the output of \hyperlink{7389584356782450249}{\texttt{Pkg.status()}} that \texttt{Distributions} is on an unregistered version greater than \texttt{0.2.9}, indicated by the {\textquotedbl}pseudo-version{\textquotedbl} number \texttt{0.2.9+}.



When you checkout an unregistered version of a package, the copy of the \texttt{REQUIRE} file in the package repo takes precedence over any requirements registered in \texttt{METADATA}, so it is important that developers keep this file accurate and up-to-date, reflecting the actual requirements of the current version of the package. If the \texttt{REQUIRE} file in the package repo is incorrect or missing, dependencies may be removed when the package is checked out. This file is also used to populate newly published versions of the package if you use the API that \texttt{Pkg} provides for this (described below).



When you decide that you no longer want to have a package checked out on a branch, you can {\textquotedbl}free{\textquotedbl} it back to the control of the package manager with \hyperlink{17638373134027476185}{\texttt{Pkg.free(pkg)}}:




\begin{minted}{jlcon}
julia> Pkg.free("Distributions")
INFO: Freeing Distributions...
INFO: No packages to install, update or remove.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7
\end{minted}



After this, since the package is on a registered version and not on a branch, its version will be updated as new registered versions of the package are published.



If you want to pin a package at a specific version so that calling \hyperlink{14197801802374863313}{\texttt{Pkg.update()}} won{\textquotesingle}t change the version the package is on, you can use the \hyperlink{5411776221154476292}{\texttt{Pkg.pin()}} function:




\begin{minted}{jlcon}
julia> Pkg.pin("Stats")
INFO: Creating Stats branch pinned.47c198b1.tmp

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7              pinned.47c198b1.tmp
\end{minted}



After this, the \texttt{Stats} package will remain pinned at version \texttt{0.2.7} – or more specifically, at commit \texttt{47c198b1}, but since versions are permanently associated a given git hash, this is the same thing. \hyperlink{5411776221154476292}{\texttt{Pkg.pin()}} works by creating a throw-away branch for the commit you want to pin the package at and then checking that branch out. By default, it pins a package at the current commit, but you can choose a different version by passing a second argument:




\begin{minted}{jlcon}
julia> Pkg.pin("Stats",v"0.2.5")
INFO: Creating Stats branch pinned.1fd0983b.tmp
INFO: No packages to install, update or remove.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.5              pinned.1fd0983b.tmp
\end{minted}



Now the \texttt{Stats} package is pinned at commit \texttt{1fd0983b}, which corresponds to version \texttt{0.2.5}. When you decide to {\textquotedbl}unpin{\textquotedbl} a package and let the package manager update it again, you can use \hyperlink{17638373134027476185}{\texttt{Pkg.free()}} like you would to move off of any branch:




\begin{minted}{jlcon}
julia> Pkg.free("Stats")
INFO: Freeing Stats...
INFO: No packages to install, update or remove.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7
\end{minted}



After this, the \texttt{Stats} package is managed by the package manager again, and future calls to \hyperlink{14197801802374863313}{\texttt{Pkg.update()}} will upgrade it to newer versions when they are published. The throw-away \texttt{pinned.1fd0983b.tmp} branch remains in your local \texttt{Stats} repo, but since git branches are extremely lightweight, this doesn{\textquotesingle}t really matter; if you feel like cleaning them up, you can go into the repo and delete those branches \footnotemark[2].



\footnotetext[2]{Packages that aren{\textquotesingle}t on branches will also be marked as dirty if you make changes in the repo, but that{\textquotesingle}s a less common thing to do.

}


\hypertarget{17535558414921821394}{}


\section{Custom METADATA Repository}



By default, Julia assumes you will be using the \href{https://github.com/JuliaLang/METADATA.jl}{official METADATA.jl} repository for downloading and installing packages. You can also provide a different metadata repository location. A common approach is to keep your \texttt{metadata-v2} branch up to date with the Julia official branch and add another branch with your custom packages. You can initialize your local metadata repository using that custom location and branch and then periodically rebase your custom branch with the official \texttt{metadata-v2} branch. In order to use a custom repository and branch, issue the following command:




\begin{minted}{jlcon}
julia> Pkg.init("https://me.example.com/METADATA.jl.git", "branch")
\end{minted}



The branch argument is optional and defaults to \texttt{metadata-v2}. Once initialized, a file named \texttt{META\_BRANCH} in your \texttt{{\textasciitilde}/.julia/vX.Y/} path will track the branch that your METADATA repository was initialized with. If you want to change branches, you will need to either modify the \texttt{META\_BRANCH} file directly (be careful!) or remove the \texttt{vX.Y} directory and re-initialize your METADATA repository using the \texttt{Pkg.init} command.



\hypertarget{1291144519806895574}{}


\chapter{Package Development}



Julia{\textquotesingle}s package manager is designed so that when you have a package installed, you are already in a position to look at its source code and full development history. You are also able to make changes to packages, commit them using git, and easily contribute fixes and enhancements upstream. Similarly, the system is designed so that if you want to create a new package, the simplest way to do so is within the infrastructure provided by the package manager.



\hypertarget{10119090900086482810}{}


\section{Initial Setup}



Since packages are git repositories, before doing any package development you should setup the following standard global git configuration settings:




\begin{lstlisting}
$ git config --global user.name "FULL NAME"
$ git config --global user.email "EMAIL"
\end{lstlisting}



where \texttt{FULL NAME} is your actual full name (spaces are allowed between the double quotes) and \texttt{EMAIL} is your actual email address. Although it isn{\textquotesingle}t necessary to use \href{https://github.com/}{GitHub} to create or publish Julia packages, most Julia packages as of writing this are hosted on GitHub and the package manager knows how to format origin URLs correctly and otherwise work with the service smoothly. We recommend that you create a \href{https://github.com/join}{free account} on GitHub and then do:




\begin{lstlisting}
$ git config --global github.user "USERNAME"
\end{lstlisting}



where \texttt{USERNAME} is your actual GitHub user name. Once you do this, the package manager knows your GitHub user name and can configure things accordingly. You should also \href{https://github.com/login?return\_to=https\%3A\%2F\%2Fgithub.com\%2Fsettings\%2Fssh}{upload} your public SSH key to GitHub and set up an \href{https://linux.die.net/man/1/ssh-agent}{SSH agent} on your development machine so that you can push changes with minimal hassle. In the future, we will make this system extensible and support other common git hosting options like \href{https://bitbucket.org}{BitBucket} and allow developers to choose their favorite. Since the package development functions has been moved to the \href{https://github.com/JuliaLang/PkgDev.jl}{PkgDev} package, you need to run \texttt{Pkg.add({\textquotedbl}PkgDev{\textquotedbl}); import PkgDev} to access the functions starting with \texttt{PkgDev.} in the document below.



\hypertarget{14180710500180460981}{}


\section{Making changes to an existing package}



\hypertarget{9756593469566562585}{}


\subsection{Documentation changes}



If you want to improve the online documentation of a package, the easiest approach (at least for small changes) is to use GitHub{\textquotesingle}s online editing functionality. First, navigate to the repository{\textquotesingle}s GitHub {\textquotedbl}home page,{\textquotedbl} find the file (e.g., \texttt{README.md}) within the repository{\textquotesingle}s folder structure, and click on it. You{\textquotesingle}ll see the contents displayed, along with a small {\textquotedbl}pencil{\textquotedbl} icon in the upper right hand corner. Clicking that icon opens the file in edit mode. Make your changes, write a brief summary describing the changes you want to make (this is your \emph{commit message}), and then hit {\textquotedbl}Propose file change.{\textquotedbl} Your changes will be submitted for consideration by the package owner(s) and collaborators.



For larger documentation changes–and especially ones that you expect to have to update in response to feedback–you might find it easier to use the procedure for code changes described below.



\hypertarget{14808272641467070302}{}


\subsection{Code changes}



\hypertarget{1356157252895634215}{}


\subsubsection{Executive summary}



Here we assume you{\textquotesingle}ve already set up git on your local machine and have a GitHub account (see above). Let{\textquotesingle}s imagine you{\textquotesingle}re fixing a bug in the Images package:




\begin{lstlisting}
Pkg.checkout("Images")           # check out the master branch
<here, make sure your bug is still a bug and hasn't been fixed already>
cd(Pkg.dir("Images"))
;git checkout -b myfixes         # create a branch for your changes
<edit code>                      # be sure to add a test for your bug
Pkg.test("Images")               # make sure everything works now
;git commit -a -m "Fix foo by calling bar"   # write a descriptive message
using PkgDev
PkgDev.submit("Images")
\end{lstlisting}



The last line will present you with a link to submit a pull request to incorporate your changes.



\hypertarget{7527313422218872005}{}


\subsubsection{Detailed description}



If you want to fix a bug or add new functionality, you want to be able to test your changes before you submit them for consideration. You also need to have an easy way to update your proposal in response to the package owner{\textquotesingle}s feedback. Consequently, in this case the strategy is to work locally on your own machine; once you are satisfied with your changes, you submit them for consideration.  This process is called a \emph{pull request} because you are asking to {\textquotedbl}pull{\textquotedbl} your changes into the project{\textquotesingle}s main repository. Because the online repository can{\textquotesingle}t see the code on your private machine, you first \emph{push} your changes to a publicly-visible location, your own online \emph{fork} of the package (hosted on your own personal GitHub account).



Let{\textquotesingle}s assume you already have the \texttt{Foo} package installed. In the description below, anything starting with \texttt{Pkg.} or \texttt{PkgDev.} is meant to be typed at the Julia prompt; anything starting with \texttt{git} is meant to be typed in \hyperlink{17654100848947676892}{julia{\textquotesingle}s shell mode} (or using the shell that comes with your operating system). Within Julia, you can combine these two modes:




\begin{minted}{jlcon}
julia> cd(Pkg.dir("Foo"))          # go to Foo's folder

shell> git command arguments...    # command will apply to Foo
\end{minted}



Now suppose you{\textquotesingle}re ready to make some changes to \texttt{Foo}. While there are several possible approaches, here is one that is widely used:



\begin{itemize}
\item From the Julia prompt, type \hyperlink{13289698592044275412}{\texttt{Pkg.checkout({\textquotedbl}Foo{\textquotedbl})}}. This ensures you{\textquotesingle}re running the latest code (the \texttt{master} branch), rather than just whatever {\textquotedbl}official release{\textquotedbl} version you have installed. (If you{\textquotesingle}re planning to fix a bug, at this point it{\textquotesingle}s a good idea to check again whether the bug has already been fixed by someone else. If it has, you can request that a new official release be tagged so that the fix gets distributed to the rest of the community.) If you receive an error \texttt{Foo is dirty, bailing}, see \hyperlink{11667096676202946902}{Dirty packages} below.


\item Create a branch for your changes: navigate to the package folder (the one that Julia reports from \hyperlink{4800223299836980046}{\texttt{Pkg.dir({\textquotedbl}Foo{\textquotedbl})}}) and (in shell mode) create a new branch using \texttt{git checkout -b <newbranch>}, where \texttt{<newbranch>} might be some descriptive name (e.g., \texttt{fixbar}). By creating a branch, you ensure that you can easily go back and forth between your new work and the current \texttt{master} branch (see \href{https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell}{https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell}).

If you forget to do this step until after you{\textquotesingle}ve already made some changes, don{\textquotesingle}t worry: see \hyperlink{1840922819273614147}{more detail about branching} below.


\item Make your changes. Whether it{\textquotesingle}s fixing a bug or adding new functionality, in most cases your change should include updates to both the \texttt{src/} and \texttt{test/} folders. If you{\textquotesingle}re fixing a bug, add your minimal example demonstrating the bug (on the current code) to the test suite; by contributing a test for the bug, you ensure that the bug won{\textquotesingle}t accidentally reappear at some later time due to other changes. If you{\textquotesingle}re adding new functionality, creating tests demonstrates to the package owner that you{\textquotesingle}ve made sure your code works as intended.


\item Run the package{\textquotesingle}s tests and make sure they pass. There are several ways to run the tests:

\begin{itemize}
\item From Julia, run \hyperlink{9222688485458908711}{\texttt{Pkg.test({\textquotedbl}Foo{\textquotedbl})}}: this will run your tests in a separate (new) \texttt{julia} process.


\item From Julia, \texttt{include({\textquotedbl}runtests.jl{\textquotedbl})} from the package{\textquotesingle}s \texttt{test/} folder (it{\textquotesingle}s possible the file has a different name, look for one that runs all the tests): this allows you to run the tests repeatedly in the same session without reloading all the package code; for packages that take a while to load, this can be much faster. With this approach, you do have to do some extra work to make \hyperlink{14117620934191882930}{changes in the package code}.


\item From the shell, run \texttt{julia ../test/runtests.jl} from within the package{\textquotesingle}s \texttt{src/} folder.

\end{itemize}

\item Commit your changes: see \href{https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository}{https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository}.


\item Submit your changes: From the Julia prompt, type \texttt{PkgDev.submit({\textquotedbl}Foo{\textquotedbl})}. This will push your changes to your GitHub fork, creating it if it doesn{\textquotesingle}t already exist. (If you encounter an error, \hyperlink{10119090900086482810}{make sure you{\textquotesingle}ve set up your SSH keys}.) Julia will then give you a hyperlink; open that link, edit the message, and then click {\textquotedbl}submit.{\textquotedbl} At that point, the package owner will be notified of your changes and may initiate discussion. (If you are comfortable with git, you can also do these steps manually from the shell.)


\item The package owner may suggest additional improvements. To respond to those suggestions, you can easily update the pull request (this only works for changes that have not already been merged; for merged pull requests, make new changes by starting a new branch):

\begin{itemize}
\item If you{\textquotesingle}ve changed branches in the meantime, make sure you go back to the same branch with \texttt{git checkout fixbar} (from shell mode) or \hyperlink{13289698592044275412}{\texttt{Pkg.checkout({\textquotedbl}Foo{\textquotedbl}, {\textquotedbl}fixbar{\textquotedbl})}} (from the Julia prompt).


\item As above, make your changes, run the tests, and commit your changes.


\item From the shell, type \texttt{git push}.  This will add your new commit(s) to the same pull request; you should see them appear automatically on the page holding the discussion of your pull request.

\end{itemize}
One potential type of change the owner may request is that you squash your commits. See \hyperlink{7222706544523187857}{Squashing} below.

\end{itemize}


\hypertarget{11667096676202946902}{}


\subsection{Dirty packages}



If you can{\textquotesingle}t change branches because the package manager complains that your package is dirty, it means you have some changes that have not been committed. From the shell, use \texttt{git diff} to see what these changes are; you can either discard them (\texttt{git checkout changedfile.jl}) or commit them before switching branches.  If you can{\textquotesingle}t easily resolve the problems manually, as a last resort you can delete the entire \texttt{{\textquotedbl}Foo{\textquotedbl}} folder and reinstall a fresh copy with \hyperlink{10284711283997279340}{\texttt{Pkg.add({\textquotedbl}Foo{\textquotedbl})}}. Naturally, this deletes any changes you{\textquotesingle}ve made.



\hypertarget{1840922819273614147}{}


\subsection{Making a branch \emph{post hoc}}



Especially for newcomers to git, one often forgets to create a new branch until after some changes have already been made. If you haven{\textquotesingle}t yet staged or committed your changes, you can create a new branch with \texttt{git checkout -b <newbranch>} just as usual–git will kindly show you that some files have been modified and create the new branch for you. \emph{Your changes have not yet been committed to this new branch}, so the normal work rules still apply.



However, if you{\textquotesingle}ve already made a commit to \texttt{master} but wish to go back to the official \texttt{master} (called \texttt{origin/master}), use the following procedure:



\begin{itemize}
\item Create a new branch. This branch will hold your changes.


\item Make sure everything is committed to this branch.


\item \texttt{git checkout master}. If this fails, \emph{do not} proceed further until you have resolved the problems, or you may lose your changes.


\item \emph{Reset}\texttt{master} (your current branch) back to an earlier state with \texttt{git reset --hard origin/master} (see \href{https://git-scm.com/blog/2011/07/11/reset.html}{https://git-scm.com/blog/2011/07/11/reset.html}).

\end{itemize}


This requires a bit more familiarity with git, so it{\textquotesingle}s much better to get in the habit of creating a branch at the outset.



\hypertarget{7222706544523187857}{}


\subsection{Squashing and rebasing}



Depending on the tastes of the package owner (s)he may ask you to {\textquotedbl}squash{\textquotedbl} your commits. This is especially likely if your change is quite simple but your commit history looks like this:




\begin{lstlisting}
WIP: add new 1-line whizbang function (currently breaks package)
Finish whizbang function
Fix typo in variable name
Oops, don't forget to supply default argument
Split into two 1-line functions
Rats, forgot to export the second function
...
\end{lstlisting}



This gets into the territory of more advanced git usage, and you{\textquotesingle}re encouraged to do some reading (\href{https://git-scm.com/book/en/v2/Git-Branching-Rebasing}{https://git-scm.com/book/en/v2/Git-Branching-Rebasing}).  However, a brief summary of the procedure is as follows:



\begin{itemize}
\item To protect yourself from error, start from your \texttt{fixbar} branch and create a new branch with \texttt{git checkout -b fixbar\_backup}.  Since you started from \texttt{fixbar}, this will be a copy. Now go back to the one you intend to modify with \texttt{git checkout fixbar}.


\item From the shell, type \texttt{git rebase -i origin/master}.


\item To combine commits, change \texttt{pick} to \texttt{squash} (for additional options, consult other sources). Save the file and close the editor window.


\item Edit the combined commit message.

\end{itemize}


If the rebase goes badly, you can go back to the beginning to try again like this:




\begin{lstlisting}
git checkout fixbar
git reset --hard fixbar_backup
\end{lstlisting}



Now let{\textquotesingle}s assume you{\textquotesingle}ve rebased successfully. Since your \texttt{fixbar} repository has now diverged from the one in your GitHub fork, you{\textquotesingle}re going to have to do a \emph{force push}:



\begin{itemize}
\item To make it easy to refer to your GitHub fork, create a {\textquotedbl}handle{\textquotedbl} for it with \texttt{git remote add myfork https://github.com/myaccount/Foo.jl.git}, where the URL comes from the {\textquotedbl}clone URL{\textquotedbl} on your GitHub fork{\textquotesingle}s page.


\item Force-push to your fork with \texttt{git push myfork +fixbar}. The \texttt{+} indicates that this should replace the \texttt{fixbar} branch found at \texttt{myfork}.

\end{itemize}


\hypertarget{11861177827206025597}{}


\section{Creating a new Package}



\hypertarget{17718546136122660012}{}


\subsection{REQUIRE speaks for itself}



You should have a \texttt{REQUIRE} file in your package repository, with a bare minimum directive of what Julia version you expect your users to be running for the package to work. Putting a floor on what Julia version your package supports is done by simply adding \texttt{julia 0.x} in this file. While this line is partly informational, it also has the consequence of whether \texttt{Pkg.update()} will update code found in \texttt{.julia} version directories. It will not update code found in version directories beneath the floor of what{\textquotesingle}s specified in your \texttt{REQUIRE}.



As the development version \texttt{0.y} matures, you may find yourself using it more frequently, and wanting your package to support it. Be warned, the development branch of Julia is the land of breakage, and you can expect things to break. When you go about fixing whatever broke your package in the development \texttt{0.y} branch, you will likely find that you just broke your package on the stable version.



There is a mechanism found in the \href{https://github.com/JuliaLang/Compat.jl}{Compat} package that will enable you to support both the stable version and breaking changes found in the development version. Should you decide to use this solution, you will need to add \texttt{Compat} to your \texttt{REQUIRE} file. In this case, you will still have \texttt{julia 0.x} in your \texttt{REQUIRE}. The \texttt{x} is the floor version of what your package supports.



You might also have no interest in supporting the development version of Julia. Just as you can add a floor to the version you expect your users to be on, you can set an upper bound. In this case, you would put \texttt{julia 0.x 0.y-} in your \texttt{REQUIRE} file. The \texttt{-} at the end of the version number means pre-release versions of that specific version from the very first commit. By setting it as the ceiling, you mean the code supports everything up to but not including the ceiling version.



Another scenario is that you are writing the bulk of the code for your package with Julia \texttt{0.y} and do not want to support the current stable version of Julia. If you choose to do this, simply add \texttt{julia 0.y-} to your \texttt{REQUIRE}. Just remember to change the \texttt{julia 0.y-} to \texttt{julia 0.y} in your \texttt{REQUIRE} file once \texttt{0.y} is officially released. If you don{\textquotesingle}t edit the dash cruft you are suggesting that you support both the development and stable versions of the same version number! That would be madness. See the \hyperlink{16110950416626149644}{Requirements Specification} for the full format of \texttt{REQUIRE}.



Lastly, in many cases you may need extra packages for testing. Additional packages which are only required for tests should be specified in the \texttt{test/REQUIRE} file. This \texttt{REQUIRE} file has the same specification as the standard \texttt{REQUIRE} file.



\hypertarget{1968323327731198101}{}


\subsection{Guidelines for naming a package}



Package names should be sensible to most Julia users, \emph{even to those who are not domain experts}. When you submit your package to METADATA, you can expect a little back and forth about the package name with collaborators, especially if it{\textquotesingle}s ambiguous or can be confused with something other than what it is. During this bike-shedding, it{\textquotesingle}s not uncommon to get a range of \emph{different} name suggestions. These are only suggestions though, with the intent being to keep a tidy namespace in the curated METADATA repository. Since this repository belongs to the entire community, there will likely be a few collaborators who care about your package name. Here are some guidelines to follow in naming your package:



\begin{itemize}
\item[1. ] Avoid jargon. In particular, avoid acronyms unless there is minimal possibility of confusion.

\begin{itemize}
\item It{\textquotesingle}s ok to say \texttt{USA} if you{\textquotesingle}re talking about the USA.


\item It{\textquotesingle}s not ok to say \texttt{PMA}, even if you{\textquotesingle}re talking about positive mental attitude.

\end{itemize}

\item[2. ] Avoid using \texttt{Julia} in your package name.

\begin{itemize}
\item It is usually clear from context and to your users that the package is a Julia package.


\item Having Julia in the name can imply that the package is connected to, or endorsed by, contributors to the Julia language itself.

\end{itemize}

\item[3. ] Packages that provide most of their functionality in association with a new type should have pluralized names.

\begin{itemize}
\item \texttt{DataFrames} provides the \texttt{DataFrame} type.


\item \texttt{BloomFilters} provides the \texttt{BloomFilter} type.


\item In contrast, \texttt{JuliaParser} provides no new type, but instead new functionality in the \texttt{JuliaParser.parse()} function.

\end{itemize}

\item[4. ] Err on the side of clarity, even if clarity seems long-winded to you.

\begin{itemize}
\item \texttt{RandomMatrices} is a less ambiguous name than \texttt{RndMat} or \texttt{RMT}, even though the latter are shorter.

\end{itemize}

\item[5. ] A less systematic name may suit a package that implements one of several possible approaches to its domain.

\begin{itemize}
\item Julia does not have a single comprehensive plotting package. Instead, \texttt{Gadfly}, \texttt{PyPlot}, \texttt{Winston} and other packages each implement a unique approach based on a particular design philosophy.


\item In contrast, \texttt{SortingAlgorithms} provides a consistent interface to use many well-established sorting algorithms.

\end{itemize}

\item[6. ] Packages that wrap external libraries or programs should be named after those libraries or programs.

\begin{itemize}
\item \texttt{CPLEX.jl} wraps the \texttt{CPLEX} library, which can be identified easily in a web search.


\item \texttt{MATLAB.jl} provides an interface to call the MATLAB engine from within Julia.

\end{itemize}
\end{itemize}


\hypertarget{11697380935174527303}{}


\subsection{Generating the package}



Suppose you want to create a new Julia package called \texttt{FooBar}. To get started, do \texttt{PkgDev.generate(pkg,license)} where \texttt{pkg} is the new package name and \texttt{license} is the name of a license that the package generator knows about:




\begin{minted}{jlcon}
julia> PkgDev.generate("FooBar","MIT")
INFO: Initializing FooBar repo: /Users/stefan/.julia/v0.6/FooBar
INFO: Origin: git://github.com/StefanKarpinski/FooBar.jl.git
INFO: Generating LICENSE.md
INFO: Generating README.md
INFO: Generating src/FooBar.jl
INFO: Generating test/runtests.jl
INFO: Generating REQUIRE
INFO: Generating .travis.yml
INFO: Generating appveyor.yml
INFO: Generating .gitignore
INFO: Committing FooBar generated files
\end{minted}



This creates the directory \texttt{{\textasciitilde}/.julia/v0.6/FooBar}, initializes it as a git repository, generates a bunch of files that all packages should have, and commits them to the repository:




\begin{lstlisting}
$ cd ~/.julia/v0.6/FooBar && git show --stat

commit 84b8e266dae6de30ab9703150b3bf771ec7b6285
Author: Stefan Karpinski <stefan@karpinski.org>
Date:   Wed Oct 16 17:57:58 2013 -0400

    FooBar.jl generated files.

        license: MIT
        authors: Stefan Karpinski
        years:   2013
        user:    StefanKarpinski

    Julia Version 0.3.0-prerelease+3217 [5fcfb13*]

 .gitignore       |  2 ++
 .travis.yml      | 13 +++++++++++++
 LICENSE.md       | 22 +++++++++++++++++++++++
 README.md        |  3 +++
 REQUIRE          |  1 +
 appveyor.yml     | 34 ++++++++++++++++++++++++++++++++++
 src/FooBar.jl    |  5 +++++
 test/runtests.jl |  5 +++++
 8 files changed, 85 insertions(+)
\end{lstlisting}



At the moment, the package manager knows about the MIT {\textquotedbl}Expat{\textquotedbl} License, indicated by \texttt{{\textquotedbl}MIT{\textquotedbl}}, the Simplified BSD License, indicated by \texttt{{\textquotedbl}BSD{\textquotedbl}}, and version 2.0 of the Apache Software License, indicated by \texttt{{\textquotedbl}ASL{\textquotedbl}}. If you want to use a different license, you can ask us to add it to the package generator, or just pick one of these three and then modify the \texttt{{\textasciitilde}/.julia/v0.6/PACKAGE/LICENSE.md} file after it has been generated.



If you created a GitHub account and configured git to know about it, \texttt{PkgDev.generate()} will set an appropriate origin URL for you. It will also automatically generate a \texttt{.travis.yml} file for using the \href{https://travis-ci.org}{Travis} automated testing service, and an \texttt{appveyor.yml} file for using \href{https://www.appveyor.com}{AppVeyor}. You will have to enable testing on the Travis and AppVeyor websites for your package repository, but once you{\textquotesingle}ve done that, it will already have working tests. Of course, all the default testing does is verify that \texttt{using FooBar} in Julia works.



\hypertarget{15423080927588707748}{}


\subsection{Loading Static Non-Julia Files}



If your package code needs to load static files which are not Julia code, e.g. an external library or data files, and are located within the package directory, use the \texttt{@\_\_DIR\_\_} macro to determine the directory of the current source file. For example if \texttt{FooBar/src/FooBar.jl} needs to load \texttt{FooBar/data/foo.csv}, use the following code:




\begin{minted}{julia}
datapath = joinpath(@__DIR__, "..", "data")
foo = readcsv(joinpath(datapath, "foo.csv"))
\end{minted}



\hypertarget{4036070632145674227}{}


\subsection{Making Your Package Available}



Once you{\textquotesingle}ve made some commits and you{\textquotesingle}re happy with how \texttt{FooBar} is working, you may want to get some other people to try it out. First you{\textquotesingle}ll need to create the remote repository and push your code to it; we don{\textquotesingle}t yet automatically do this for you, but we will in the future and it{\textquotesingle}s not too hard to figure out \footnotemark[3]. Once you{\textquotesingle}ve done this, letting people try out your code is as simple as sending them the URL of the published repo – in this case:




\begin{lstlisting}
git://github.com/StefanKarpinski/FooBar.jl.git
\end{lstlisting}



For your package, it will be your GitHub user name and the name of your package, but you get the idea. People you send this URL to can use \hyperlink{12404258328199389568}{\texttt{Pkg.clone()}} to install the package and try it out:




\begin{minted}{jlcon}
julia> Pkg.clone("git://github.com/StefanKarpinski/FooBar.jl.git")
INFO: Cloning FooBar from git@github.com:StefanKarpinski/FooBar.jl.git
\end{minted}



\footnotetext[3]{Installing and using GitHub{\textquotesingle}s \href{https://github.com/github/hub}{{\textquotedbl}hub{\textquotedbl} tool} is highly recommended. It allows you to do things like run \texttt{hub create} in the package repo and have it automatically created via GitHub{\textquotesingle}s API.

}


\hypertarget{15434198254171333487}{}


\subsection{Tagging and Publishing Your Package}



\begin{quote}
\textbf{Tip}

If you are hosting your package on GitHub, you can use the \href{https://github.com/attobot/attobot}{attobot integration} to handle package registration, tagging and publishing.

\end{quote}


Once you{\textquotesingle}ve decided that \texttt{FooBar} is ready to be registered as an official package, you can add it to your local copy of \texttt{METADATA} using \texttt{PkgDev.register()}:




\begin{minted}{jlcon}
julia> PkgDev.register("FooBar")
INFO: Registering FooBar at git://github.com/StefanKarpinski/FooBar.jl.git
INFO: Committing METADATA for FooBar
\end{minted}



This creates a commit in the \texttt{{\textasciitilde}/.julia/v0.6/METADATA} repo:




\begin{lstlisting}
$ cd ~/.julia/v0.6/METADATA && git show

commit 9f71f4becb05cadacb983c54a72eed744e5c019d
Author: Stefan Karpinski <stefan@karpinski.org>
Date:   Wed Oct 16 18:46:02 2013 -0400

    Register FooBar

diff --git a/FooBar/url b/FooBar/url
new file mode 100644
index 0000000..30e525e
--- /dev/null
+++ b/FooBar/url
@@ -0,0 +1 @@
+git://github.com/StefanKarpinski/FooBar.jl.git
\end{lstlisting}



This commit is only locally visible, however. To make it visible to the Julia community, you need to merge your local \texttt{METADATA} upstream into the official repo. The \texttt{PkgDev.publish()} command will fork the \texttt{METADATA} repository on GitHub, push your changes to your fork, and open a pull request:




\begin{minted}{jlcon}
julia> PkgDev.publish()
INFO: Validating METADATA
INFO: No new package versions to publish
INFO: Submitting METADATA changes
INFO: Forking JuliaLang/METADATA.jl to StefanKarpinski
INFO: Pushing changes as branch pull-request/ef45f54b
INFO: To create a pull-request open:

  https://github.com/StefanKarpinski/METADATA.jl/compare/pull-request/ef45f54b
\end{minted}



\begin{quote}
\textbf{Tip}

If \texttt{PkgDev.publish()} fails with error:


\begin{lstlisting}
ERROR: key not found: "token"
\end{lstlisting}

then you may have encountered an issue from using the GitHub API on multiple systems. The solution is to delete the {\textquotedbl}Julia Package Manager{\textquotedbl} personal access token \href{https://github.com/login?return\_to=https\%3A\%2F\%2Fgithub.com\%2Fsettings\%2Ftokens}{from your Github account} and try again.

Other failures may require you to circumvent \texttt{PkgDev.publish()} by \href{https://help.github.com/articles/creating-a-pull-request/}{creating a pull request on GitHub}. See: \hyperlink{11207769664532169625}{Publishing METADATA manually} below.

\end{quote}


Once the package URL for \texttt{FooBar} is registered in the official \texttt{METADATA} repo, people know where to clone the package from, but there still aren{\textquotesingle}t any registered versions available. You can tag and register it with the \texttt{PkgDev.tag()} command:




\begin{minted}{jlcon}
julia> PkgDev.tag("FooBar")
INFO: Tagging FooBar v0.0.1
INFO: Committing METADATA for FooBar
\end{minted}



This tags \texttt{v0.0.1} in the \texttt{FooBar} repo:




\begin{lstlisting}
$ cd ~/.julia/v0.6/FooBar && git tag
v0.0.1
\end{lstlisting}



It also creates a new version entry in your local \texttt{METADATA} repo for \texttt{FooBar}:




\begin{lstlisting}
$ cd ~/.julia/v0.6/FooBar && git show
commit de77ee4dc0689b12c5e8b574aef7f70e8b311b0e
Author: Stefan Karpinski <stefan@karpinski.org>
Date:   Wed Oct 16 23:06:18 2013 -0400

    Tag FooBar v0.0.1

diff --git a/FooBar/versions/0.0.1/sha1 b/FooBar/versions/0.0.1/sha1
new file mode 100644
index 0000000..c1cb1c1
--- /dev/null
+++ b/FooBar/versions/0.0.1/sha1
@@ -0,0 +1 @@
+84b8e266dae6de30ab9703150b3bf771ec7b6285
\end{lstlisting}



The \texttt{PkgDev.tag()} command takes an optional second argument that is either an explicit version number object like \texttt{v{\textquotedbl}0.0.1{\textquotedbl}} or one of the symbols \texttt{:patch}, \texttt{:minor} or \texttt{:major}. These increment the patch, minor or major version number of your package intelligently.



Adding a tagged version of your package will expedite the official registration into METADATA.jl by collaborators. It is strongly recommended that you complete this process, regardless if your package is completely ready for an official release.



As a general rule, packages should be tagged \texttt{0.0.1} first. Since Julia itself hasn{\textquotesingle}t achieved \texttt{1.0} status, it{\textquotesingle}s best to be conservative in your package{\textquotesingle}s tagged versions.



As with \texttt{PkgDev.register()}, these changes to \texttt{METADATA} aren{\textquotesingle}t available to anyone else until they{\textquotesingle}ve been included upstream. Again, use the \texttt{PkgDev.publish()} command, which first makes sure that individual package repos have been tagged, pushes them if they haven{\textquotesingle}t already been, and then opens a pull request to \texttt{METADATA}:




\begin{minted}{jlcon}
julia> PkgDev.publish()
INFO: Validating METADATA
INFO: Pushing FooBar permanent tags: v0.0.1
INFO: Submitting METADATA changes
INFO: Forking JuliaLang/METADATA.jl to StefanKarpinski
INFO: Pushing changes as branch pull-request/3ef4f5c4
INFO: To create a pull-request open:

  https://github.com/StefanKarpinski/METADATA.jl/compare/pull-request/3ef4f5c4
\end{minted}



\hypertarget{11207769664532169625}{}


\subsubsection{Publishing METADATA manually}



If \texttt{PkgDev.publish()} fails you can follow these instructions to manually publish your package.



By {\textquotedbl}forking{\textquotedbl} the main METADATA repository, you can create a personal copy (of METADATA.jl) under your GitHub account. Once that copy exists, you can push your local changes to your copy (just like any other GitHub project).



\begin{itemize}
\item[1. ] Create a \href{https://github.com/login?return\_to=https\%3A\%2F\%2Fgithub.com\%2FJuliaLang\%2FMETADATA.jl\%2Ffork}{fork of METADATA.jl}.


\item[2. ] Add your fork as a remote repository for the METADATA repository on your local computer (in the terminal where USERNAME is your github username):


\begin{lstlisting}
cd ~/.julia/v0.6/METADATA
git remote add USERNAME https://github.com/USERNAME/METADATA.jl.git
\end{lstlisting}


\item[3. ] Push your changes to your fork:


\begin{lstlisting}
git push USERNAME metadata-v2
\end{lstlisting}


\item[4. ] If all of that works, then go back to the GitHub page for your fork, and click the {\textquotedbl}pull request{\textquotedbl} link.

\end{itemize}


\hypertarget{4361188995750101402}{}


\section{Fixing Package Requirements}



If you need to fix the registered requirements of an already-published package version, you can do so just by editing the metadata for that version, which will still have the same commit hash – the hash associated with a version is permanent:




\begin{lstlisting}
$ cd ~/.julia/v0.6/METADATA/FooBar/versions/0.0.1 && cat requires
julia 0.3-
$ vi requires
\end{lstlisting}



Since the commit hash stays the same, the contents of the \texttt{REQUIRE} file that will be checked out in the repo will \textbf{not} match the requirements in \texttt{METADATA} after such a change; this is unavoidable. When you fix the requirements in \texttt{METADATA} for a previous version of a package, however, you should also fix the \texttt{REQUIRE} file in the current version of the package.



\hypertarget{16110950416626149644}{}


\section{Requirements Specification}



The \texttt{{\textasciitilde}/.julia/v0.6/REQUIRE} file, the \texttt{REQUIRE} file inside packages, and the \texttt{METADATA} package \texttt{requires} files use a simple line-based format to express the ranges of package versions which need to be installed. Package \texttt{REQUIRE} and \texttt{METADATA requires} files should also include the range of versions of \texttt{julia} the package is expected to work with. Additionally, packages can include a \texttt{test/REQUIRE} file to specify additional packages which are only required for testing.



Here{\textquotesingle}s how these files are parsed and interpreted.



\begin{itemize}
\item Everything after a \texttt{\#} mark is stripped from each line as a comment.


\item If nothing but whitespace is left, the line is ignored.


\item If there are non-whitespace characters remaining, the line is a requirement and the is split on whitespace into words.

\end{itemize}


The simplest possible requirement is just the name of a package name on a line by itself:




\begin{minted}{julia}
Distributions
\end{minted}



This requirement is satisfied by any version of the \texttt{Distributions} package. The package name can be followed by zero or more version numbers in ascending order, indicating acceptable intervals of versions of that package. One version opens an interval, while the next closes it, and the next opens a new interval, and so on; if an odd number of version numbers are given, then arbitrarily large versions will satisfy; if an even number of version numbers are given, the last one is an upper limit on acceptable version numbers. For example, the line:




\begin{lstlisting}
Distributions 0.1
\end{lstlisting}



is satisfied by any version of \texttt{Distributions} greater than or equal to \texttt{0.1.0}. Suffixing a version with \texttt{-} allows any pre-release versions as well. For example:




\begin{lstlisting}
Distributions 0.1-
\end{lstlisting}



is satisfied by pre-release versions such as \texttt{0.1-dev} or \texttt{0.1-rc1}, or by any version greater than or equal to \texttt{0.1.0}.



This requirement entry:




\begin{lstlisting}
Distributions 0.1 0.2.5
\end{lstlisting}



is satisfied by versions from \texttt{0.1.0} up to, but not including \texttt{0.2.5}. If you want to indicate that any \texttt{0.1.x} version will do, you will want to write:




\begin{lstlisting}
Distributions 0.1 0.2-
\end{lstlisting}



If you want to start accepting versions after \texttt{0.2.7}, you can write:




\begin{lstlisting}
Distributions 0.1 0.2- 0.2.7
\end{lstlisting}



If a requirement line has leading words that begin with \texttt{@}, it is a system-dependent requirement. If your system matches these system conditionals, the requirement is included, if not, the requirement is ignored. For example:




\begin{lstlisting}
@osx Homebrew
\end{lstlisting}



will require the \texttt{Homebrew} package only on systems where the operating system is OS X. The system conditions that are currently supported are (hierarchically):



\begin{itemize}
\item \texttt{@unix}

\begin{itemize}
\item \texttt{@linux}


\item \texttt{@bsd}

\begin{itemize}
\item \texttt{@osx}

\end{itemize}
\end{itemize}

\item \texttt{@windows}

\end{itemize}


The \texttt{@unix} condition is satisfied on all UNIX systems, including Linux and BSD. Negated system conditionals are also supported by adding a \texttt{!} after the leading \texttt{@}. Examples:




\begin{lstlisting}
@!windows
@unix @!osx
\end{lstlisting}



The first condition applies to any system but Windows and the second condition applies to any UNIX system besides OS X.



Runtime checks for the current version of Julia can be made using the built-in \texttt{VERSION} variable, which is of type \texttt{VersionNumber}. Such code is occasionally necessary to keep track of new or deprecated functionality between various releases of Julia. Examples of runtime checks:




\begin{minted}{julia}
VERSION < v"0.3-" #exclude all pre-release versions of 0.3

v"0.2-" <= VERSION < v"0.3-" #get all 0.2 versions, including pre-releases, up to the above

v"0.2" <= VERSION < v"0.3-" #To get only stable 0.2 versions (Note v"0.2" == v"0.2.0")

VERSION >= v"0.2.1" #get at least version 0.2.1
\end{minted}



See the section on \hyperlink{10038787961375920908}{version number literals} for a more complete description.



\hypertarget{13874102823603666739}{}


\chapter{Profiling}



The \texttt{Profile} module provides tools to help developers improve the performance of their code. When used, it takes measurements on running code, and produces output that helps you understand how much time is spent on individual line(s). The most common usage is to identify {\textquotedbl}bottlenecks{\textquotedbl} as targets for optimization.



\texttt{Profile} implements what is known as a {\textquotedbl}sampling{\textquotedbl} or \href{https://en.wikipedia.org/wiki/Profiling\_(computer\_programming)}{statistical profiler}.  It works by periodically taking a backtrace during the execution of any task. Each backtrace captures the currently-running function and line number, plus the complete chain of function calls that led to this line, and hence is a {\textquotedbl}snapshot{\textquotedbl} of the current state of execution.



If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the {\textquotedbl}cost{\textquotedbl} of a given line–or really, the cost of the sequence of function calls up to and including this line–is proportional to how often it appears in the set of all backtraces.



A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals (by default, 1 ms on Unix systems and 10 ms on Windows, although the actual scheduling is subject to operating system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all execution points, the data collected by a sampling profiler is subject to statistical noise.



Despite these limitations, sampling profilers have substantial strengths:



\begin{itemize}
\item You do not have to make any modifications to your code to take timing measurements (in contrast to the alternative \href{https://github.com/timholy/IProfile.jl}{instrumenting profiler}).


\item It can profile into Julia{\textquotesingle}s core code and even (optionally) into C and Fortran libraries.


\item By running {\textquotedbl}infrequently{\textquotedbl} there is very little performance overhead; while profiling, your code can run at nearly native speed.

\end{itemize}


For these reasons, it{\textquotesingle}s recommended that you try using the built-in sampling profiler before considering any alternatives.



\hypertarget{7677569888163576190}{}


\section{Basic usage}



Let{\textquotesingle}s work with a simple test case:




\begin{minted}{jlcon}
julia> function myfunc()
           A = rand(200, 200, 400)
           maximum(A)
       end
\end{minted}



It{\textquotesingle}s a good idea to first run the code you intend to profile at least once (unless you want to profile Julia{\textquotesingle}s JIT-compiler):




\begin{minted}{jlcon}
julia> myfunc() # run once to force compilation
\end{minted}



Now we{\textquotesingle}re ready to profile this function:




\begin{minted}{jlcon}
julia> @profile myfunc()
\end{minted}



To see the profiling results, there is a \href{https://github.com/timholy/ProfileView.jl}{graphical browser} available, but here we{\textquotesingle}ll use the text-based display that comes with the standard library:




\begin{minted}{jlcon}
julia> Profile.print()
80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
 80 ./REPL.jl:97; macro expansion
  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)
   80 ./boot.jl:235; eval(::Module, ::Any)
    80 ./<missing>:?; anonymous
     80 ./profile.jl:23; macro expansion
      52 ./REPL[1]:2; myfunc()
       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...
        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...
       14 ./random.jl:278; rand
        14 ./random.jl:277; rand
         14 ./random.jl:366; rand
          14 ./random.jl:369; rand
      28 ./REPL[1]:3; myfunc()
       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...
        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
\end{minted}



Each line of this display represents a particular spot (line number) in the code. Indentation is used to indicate the nested sequence of function calls, with more-indented lines being deeper in the sequence of calls. In each line, the first {\textquotedbl}field{\textquotedbl} is the number of backtraces (samples) taken \emph{at this line or in any functions executed by this line}. The second field is the file name and line number and the third field is the function name. Note that the specific line numbers may change as Julia{\textquotesingle}s code changes; if you want to follow along, it{\textquotesingle}s best to run this example yourself.



In this example, we can see that the top level function called is in the file \texttt{event.jl}. This is the function that runs the REPL when you launch Julia. If you examine line 97 of \texttt{REPL.jl}, you{\textquotesingle}ll see this is where the function \texttt{eval\_user\_input()} is called. This is the function that evaluates what you type at the REPL, and since we{\textquotesingle}re working interactively these functions were invoked when we entered \texttt{@profile myfunc()}. The next line reflects actions taken in the \hyperlink{2219312293287618200}{\texttt{@profile}} macro.



The first line shows that 80 backtraces were taken at line 73 of \texttt{event.jl}, but it{\textquotesingle}s not that this line was {\textquotedbl}expensive{\textquotedbl} on its own: the third line reveals that all 80 of these backtraces were actually triggered inside its call to \texttt{eval\_user\_input}, and so on. To find out which operations are actually taking the time, we need to look deeper in the call chain.



The first {\textquotedbl}important{\textquotedbl} line in this output is this one:




\begin{lstlisting}
52 ./REPL[1]:2; myfunc()
\end{lstlisting}



\texttt{REPL} refers to the fact that we defined \texttt{myfunc} in the REPL, rather than putting it in a file; if we had used a file, this would show the file name. The \texttt{[1]} shows that the function \texttt{myfunc} was the first expression evaluated in this REPL session. Line 2 of \texttt{myfunc()} contains the call to \texttt{rand}, and there were 52 (out of 80) backtraces that occurred at this line. Below that, you can see a call to \texttt{dsfmt\_fill\_array\_close\_open!} inside \texttt{dSFMT.jl}.



A little further down, you see:




\begin{lstlisting}
28 ./REPL[1]:3; myfunc()
\end{lstlisting}



Line 3 of \texttt{myfunc} contains the call to \texttt{maximum}, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific places in \texttt{base/reduce.jl} that carry out the time-consuming operations in the \texttt{maximum} function for this type of input data.



Overall, we can tentatively conclude that generating the random numbers is approximately twice as expensive as finding the maximum element. We could increase our confidence in this result by collecting more samples:




\begin{minted}{jlcon}
julia> @profile (for i = 1:100; myfunc(); end)

julia> Profile.print()
[....]
 3821 ./REPL[1]:2; myfunc()
  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...
   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...
  310  ./random.jl:278; rand
   [....]
 2893 ./REPL[1]:3; myfunc()
  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...
   [....]
\end{minted}



In general, if you have \texttt{N} samples collected at a line, you can expect an uncertainty on the order of \texttt{sqrt(N)} (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia{\textquotesingle}s garbage collector is written in C, such events can be detected using the \texttt{C=true} output mode described below, or by using \href{https://github.com/timholy/ProfileView.jl}{ProfileView.jl}.)



This illustrates the default {\textquotedbl}tree{\textquotedbl} dump; an alternative is the {\textquotedbl}flat{\textquotedbl} dump, which accumulates counts independent of their nesting:




\begin{minted}{jlcon}
julia> Profile.print(format=:flat)
 Count File          Line Function
  6714 ./<missing>     -1 anonymous
  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)
  6714 ./REPL.jl       97 macro expansion
  3821 ./REPL[1]        2 myfunc()
  2893 ./REPL[1]        3 myfunc()
  6714 ./REPL[7]        1 macro expansion
  6714 ./boot.jl      235 eval(::Module, ::Any)
  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...
  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
  6714 ./profile.jl    23 macro expansion
  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...
   310 ./random.jl    277 rand
   310 ./random.jl    278 rand
   310 ./random.jl    366 rand
   310 ./random.jl    369 rand
  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...
     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
\end{minted}



If your code has recursion, one potentially-confusing point is that a line in a {\textquotedbl}child{\textquotedbl} function can accumulate more counts than there are total backtraces. Consider the following function definitions:




\begin{minted}{julia}
dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)
dumbsum3() = dumbsum(3)
\end{minted}



If you were to profile \texttt{dumbsum3}, and a backtrace was taken while it was executing \texttt{dumbsum(1)}, the backtrace would look like this:




\begin{minted}{julia}
dumbsum3
    dumbsum(3)
        dumbsum(2)
            dumbsum(1)
\end{minted}



Consequently, this child function gets 3 counts, even though the parent only gets one. The {\textquotedbl}tree{\textquotedbl} representation makes this much clearer, and for this reason (among others) is probably the most useful way to view the results.



\hypertarget{7329730080567638181}{}


\section{Accumulation and clearing}



Results from \hyperlink{2219312293287618200}{\texttt{@profile}} accumulate in a buffer; if you run multiple pieces of code under \hyperlink{2219312293287618200}{\texttt{@profile}}, then \hyperlink{15011226253236705098}{\texttt{Profile.print()}} will show you the combined results. This can be very useful, but sometimes you want to start fresh; you can do so with \hyperlink{11632425935156818951}{\texttt{Profile.clear()}}.



\hypertarget{3969903285145334188}{}


\section{Options for controlling the display of profile results}



\hyperlink{15011226253236705098}{\texttt{Profile.print()}} has more options than we{\textquotesingle}ve described so far. Let{\textquotesingle}s see the full declaration:




\begin{minted}{julia}
function print(io::IO = STDOUT, data = fetch(); kwargs...)
\end{minted}



Let{\textquotesingle}s first discuss the two positional arguments, and later the keyword arguments:



\begin{itemize}
\item \texttt{io} – Allows you to save the results to a buffer, e.g. a file, but the default is to print to \texttt{STDOUT} (the console).


\item \texttt{data} – Contains the data you want to analyze; by default that is obtained from \hyperlink{9770463724510220682}{\texttt{Profile.fetch()}}, which pulls out the backtraces from a pre-allocated buffer. For example, if you want to profile the profiler, you could say:


\begin{minted}{julia}
data = copy(Profile.fetch())
Profile.clear()
@profile Profile.print(STDOUT, data) # Prints the previous results
Profile.print()                      # Prints results from Profile.print()
\end{minted}

\end{itemize}


The keyword arguments can be any combination of:



\begin{itemize}
\item \texttt{format} – Introduced above, determines whether backtraces are printed  with (default, \texttt{:tree}) or without (\texttt{:flat}) indentation indicating tree  structure.


\item \texttt{C} – If \texttt{true}, backtraces from C and Fortran code are shown (normally they are excluded). Try running the introductory example with \texttt{Profile.print(C = true)}. This can be extremely helpful in deciding whether it{\textquotesingle}s Julia code or C code that is causing a bottleneck; setting \texttt{C = true} also improves the interpretability of the nesting, at the cost of longer profile dumps.


\item \texttt{combine} – Some lines of code contain multiple operations; for example, \texttt{s += A[i]} contains both an array reference (\texttt{A[i]}) and a sum operation. These correspond to different lines in the generated machine code, and hence there may be two or more different addresses captured during backtraces on this line. \texttt{combine = true} lumps them together, and is probably what you typically want, but you can generate an output separately for each unique instruction pointer with \texttt{combine = false}.


\item \texttt{maxdepth} – Limits frames at a depth higher than \texttt{maxdepth} in the \texttt{:tree} format.


\item \texttt{sortedby} – Controls the order in \texttt{:flat} format. \texttt{:filefuncline} (default) sorts by the source line, whereas \texttt{:count} sorts in order of number of collected samples.


\item \texttt{noisefloor} – Limits frames that are below the heuristic noise floor of the sample (only applies to format \texttt{:tree}). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which \texttt{n <= noisefloor * √N}, where \texttt{n} is the number of samples on this line, and \texttt{N} is the number of samples for the callee.


\item \texttt{mincount} – Limits frames with less than \texttt{mincount} occurrences.

\end{itemize}


File/function names are sometimes truncated (with \texttt{...}), and indentation is truncated with a \texttt{+n} at the beginning, where \texttt{n} is the number of extra spaces that would have been inserted, had there been room. If you want a complete profile of deeply-nested code, often a good idea is to save to a file using a wide \texttt{displaysize} in an \hyperlink{13454403377667762339}{\texttt{IOContext}}:




\begin{minted}{julia}
open("/tmp/prof.txt", "w") do s
    Profile.print(IOContext(s, :displaysize => (24, 500)))
end
\end{minted}



\hypertarget{11369986377061669582}{}


\section{Configuration}



\hyperlink{2219312293287618200}{\texttt{@profile}} just accumulates backtraces, and the analysis happens when you call \hyperlink{15011226253236705098}{\texttt{Profile.print()}}. For a long-running computation, it{\textquotesingle}s entirely possible that the pre-allocated buffer for storing backtraces will be filled. If that happens, the backtraces stop but your computation continues. As a consequence, you may miss some important profiling data (you will get a warning when that happens).



You can obtain and configure the relevant parameters this way:




\begin{minted}{julia}
Profile.init() # returns the current settings
Profile.init(n = 10^7, delay = 0.01)
\end{minted}



\texttt{n} is the total number of instruction pointers you can store, with a default value of \texttt{10{\textasciicircum}6}. If your typical backtrace is 20 instruction pointers, then you can collect 50000 backtraces, which suggests a statistical uncertainty of less than 1\%. This may be good enough for most applications.



Consequently, you are more likely to need to modify \texttt{delay}, expressed in seconds, which sets the amount of time that Julia gets between snapshots to perform the requested computations. A very long-running job might not need frequent backtraces. The default setting is \texttt{delay = 0.001}. Of course, you can decrease the delay as well as increase it; however, the overhead of profiling grows once the delay becomes similar to the amount of time needed to take a backtrace ({\textasciitilde}30 microseconds on the author{\textquotesingle}s laptop).



\hypertarget{10992983602239333354}{}


\chapter{Memory allocation analysis}



One of the most common techniques to improve performance is to reduce memory allocation. The total amount of allocation can be measured with \hyperlink{8029752041511656628}{\texttt{@time}} and \hyperlink{5377755456008435782}{\texttt{@allocated}}, and specific lines triggering allocation can often be inferred from profiling via the cost of garbage collection that these lines incur. However, sometimes it is more efficient to directly measure the amount of memory allocated by each line of code.



To measure allocation line-by-line, start Julia with the \texttt{--track-allocation=<setting>} command-line option, for which you can choose \texttt{none} (the default, do not measure allocation), \texttt{user} (measure memory allocation everywhere except Julia{\textquotesingle}s core code), or \texttt{all} (measure memory allocation at each line of Julia code). Allocation gets measured for each line of compiled code. When you quit Julia, the cumulative results are written to text files with \texttt{.mem} appended after the file name, residing in the same directory as the source file. Each line lists the total number of bytes allocated. The \href{https://github.com/JuliaCI/Coverage.jl}{\texttt{Coverage} package} contains some elementary analysis tools, for example to sort the lines in order of number of bytes allocated.



In interpreting the results, there are a few important details. Under the \texttt{user} setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia{\textquotesingle}s compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call \hyperlink{12267785385121896224}{\texttt{Profile.clear\_malloc\_data()}} to reset all allocation counters.  Finally, execute the desired commands and quit Julia to trigger the generation of the \texttt{.mem} files.



\hypertarget{12400320882474083416}{}


\chapter{Stack Traces}



The \texttt{StackTraces} module provides simple stack traces that are both human readable and easy to use programmatically.



\hypertarget{13246952085615559057}{}


\section{Viewing a stack trace}



The primary function used to obtain a stack trace is \hyperlink{11964270650763140298}{\texttt{stacktrace()}}:




\begin{minted}{jlcon}
julia> stacktrace()
4-element Array{StackFrame,1}:
 eval(::Module, ::Any) at boot.jl:236
 eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66
 macro expansion at REPL.jl:97 [inlined]
 (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73
\end{minted}



Calling \hyperlink{11964270650763140298}{\texttt{stacktrace()}} returns a vector of \hyperlink{16824886840215699957}{\texttt{StackFrame}} s. For ease of use, the alias \hyperlink{12289172590874430030}{\texttt{StackTrace}} can be used in place of \texttt{Vector\{StackFrame\}}. (Examples with \texttt{[...]} indicate that output may vary depending on how the code is run.)




\begin{minted}{jlcon}
julia> example() = stacktrace()
example (generic function with 1 method)

julia> example()
5-element Array{StackFrame,1}:
 example() at REPL[1]:1
 eval(::Module, ::Any) at boot.jl:236
[...]

julia> @noinline child() = stacktrace()
child (generic function with 1 method)

julia> @noinline parent() = child()
parent (generic function with 1 method)

julia> grandparent() = parent()
grandparent (generic function with 1 method)

julia> grandparent()
7-element Array{StackFrame,1}:
 child() at REPL[3]:1
 parent() at REPL[4]:1
 grandparent() at REPL[5]:1
[...]
\end{minted}



Note that when calling \hyperlink{11964270650763140298}{\texttt{stacktrace()}} you{\textquotesingle}ll typically see a frame with \texttt{eval(...) at boot.jl}. When calling \hyperlink{11964270650763140298}{\texttt{stacktrace()}} from the REPL you{\textquotesingle}ll also have a few extra frames in the stack from \texttt{REPL.jl}, usually looking something like this:




\begin{minted}{jlcon}
julia> example() = stacktrace()
example (generic function with 1 method)

julia> example()
5-element Array{StackFrame,1}:
 example() at REPL[1]:1
 eval(::Module, ::Any) at boot.jl:236
 eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66
 macro expansion at REPL.jl:97 [inlined]
 (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73
\end{minted}



\hypertarget{18214495163799289313}{}


\section{Extracting useful information}



Each \hyperlink{16824886840215699957}{\texttt{StackFrame}} contains the function name, file name, line number, lambda info, a flag indicating whether the frame has been inlined, a flag indicating whether it is a C function (by default C functions do not appear in the stack trace), and an integer representation of the pointer returned by \hyperlink{6187626674327343338}{\texttt{backtrace()}}:




\begin{minted}{jlcon}
julia> top_frame = stacktrace()[1]
eval(::Module, ::Any) at boot.jl:236

julia> top_frame.func
:eval

julia> top_frame.file
Symbol("./boot.jl")

julia> top_frame.line
236

julia> top_frame.linfo
Nullable{Core.MethodInstance}(MethodInstance for eval(::Module, ::Any))

julia> top_frame.inlined
false

julia> top_frame.from_c
false
\end{minted}




\begin{minted}{jlcon}
julia> top_frame.pointer
0x00007f390d152a59
\end{minted}



This makes stack trace information available programmatically for logging, error handling, and more.



\hypertarget{9156917265404076381}{}


\section{Error handling}



While having easy access to information about the current state of the callstack can be helpful in many places, the most obvious application is in error handling and debugging.




\begin{minted}{jlcon}
julia> @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia> @noinline example() = try
           bad_function()
       catch
           stacktrace()
       end
example (generic function with 1 method)

julia> example()
5-element Array{StackFrame,1}:
 example() at REPL[2]:4
 eval(::Module, ::Any) at boot.jl:236
[...]
\end{minted}



You may notice that in the example above the first stack frame points points at line 4, where \hyperlink{11964270650763140298}{\texttt{stacktrace()}} is called, rather than line 2, where \emph{bad\_function} is called, and \texttt{bad\_function}{\textquotesingle}s frame is missing entirely. This is understandable, given that \hyperlink{11964270650763140298}{\texttt{stacktrace()}} is called from the context of the \emph{catch}. While in this example it{\textquotesingle}s fairly easy to find the actual source of the error, in complex cases tracking down the source of the error becomes nontrivial.



This can be remedied by calling \hyperlink{16506728660892665673}{\texttt{catch\_stacktrace()}} instead of \hyperlink{11964270650763140298}{\texttt{stacktrace()}}. Instead of returning callstack information for the current context, \hyperlink{16506728660892665673}{\texttt{catch\_stacktrace()}} returns stack information for the context of the most recent exception:




\begin{minted}{jlcon}
julia> @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia> @noinline example() = try
           bad_function()
       catch
           catch_stacktrace()
       end
example (generic function with 1 method)

julia> example()
6-element Array{StackFrame,1}:
 bad_function() at REPL[1]:1
 example() at REPL[2]:2
[...]
\end{minted}



Notice that the stack trace now indicates the appropriate line number and the missing frame.




\begin{minted}{jlcon}
julia> @noinline child() = error("Whoops!")
child (generic function with 1 method)

julia> @noinline parent() = child()
parent (generic function with 1 method)

julia> @noinline function grandparent()
           try
               parent()
           catch err
               println("ERROR: ", err.msg)
               catch_stacktrace()
           end
       end
grandparent (generic function with 1 method)

julia> grandparent()
ERROR: Whoops!
7-element Array{StackFrame,1}:
 child() at REPL[1]:1
 parent() at REPL[2]:1
 grandparent() at REPL[3]:3
[...]
\end{minted}



\hypertarget{10112412018921465525}{}


\section{Comparison with \texttt{backtrace()}}



A call to \hyperlink{6187626674327343338}{\texttt{backtrace()}} returns a vector of \texttt{Ptr\{Void\}}, which may then be passed into \hyperlink{11964270650763140298}{\texttt{stacktrace()}} for translation:




\begin{minted}{jlcon}
julia> trace = backtrace()
21-element Array{Ptr{Void},1}:
 Ptr{Void} @0x00007f10049d5b2f
 Ptr{Void} @0x00007f0ffeb4d29c
 Ptr{Void} @0x00007f0ffeb4d2a9
 Ptr{Void} @0x00007f1004993fe7
 Ptr{Void} @0x00007f10049a92be
 Ptr{Void} @0x00007f10049a823a
 Ptr{Void} @0x00007f10049a9fb0
 Ptr{Void} @0x00007f10049aa718
 Ptr{Void} @0x00007f10049c0d5e
 Ptr{Void} @0x00007f10049a3286
 Ptr{Void} @0x00007f0ffe9ba3ba
 Ptr{Void} @0x00007f0ffe9ba3d0
 Ptr{Void} @0x00007f1004993fe7
 Ptr{Void} @0x00007f0ded34583d
 Ptr{Void} @0x00007f0ded345a87
 Ptr{Void} @0x00007f1004993fe7
 Ptr{Void} @0x00007f0ded34308f
 Ptr{Void} @0x00007f0ded343320
 Ptr{Void} @0x00007f1004993fe7
 Ptr{Void} @0x00007f10049aeb67
 Ptr{Void} @0x0000000000000000

julia> stacktrace(trace)
5-element Array{StackFrame,1}:
 backtrace() at error.jl:46
 eval(::Module, ::Any) at boot.jl:236
 eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66
 macro expansion at REPL.jl:97 [inlined]
 (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73
\end{minted}



Notice that the vector returned by \hyperlink{6187626674327343338}{\texttt{backtrace()}} had 21 pointers, while the vector returned by \hyperlink{11964270650763140298}{\texttt{stacktrace()}} only has 5. This is because, by default, \hyperlink{11964270650763140298}{\texttt{stacktrace()}} removes any lower-level C functions from the stack. If you want to include stack frames from C calls, you can do it like this:




\begin{minted}{jlcon}
julia> stacktrace(trace, true)
27-element Array{StackFrame,1}:
 jl_backtrace_from_here at stackwalk.c:103
 backtrace() at error.jl:46
 backtrace() at sys.so:?
 jl_call_method_internal at julia_internal.h:248 [inlined]
 jl_apply_generic at gf.c:2215
 do_call at interpreter.c:75
 eval at interpreter.c:215
 eval_body at interpreter.c:519
 jl_interpret_toplevel_thunk at interpreter.c:664
 jl_toplevel_eval_flex at toplevel.c:592
 jl_toplevel_eval_in at builtins.c:614
 eval(::Module, ::Any) at boot.jl:236
 eval(::Module, ::Any) at sys.so:?
 jl_call_method_internal at julia_internal.h:248 [inlined]
 jl_apply_generic at gf.c:2215
 eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66
 ip:0x7f1c707f1846
 jl_call_method_internal at julia_internal.h:248 [inlined]
 jl_apply_generic at gf.c:2215
 macro expansion at REPL.jl:97 [inlined]
 (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73
 ip:0x7f1c707ea1ef
 jl_call_method_internal at julia_internal.h:248 [inlined]
 jl_apply_generic at gf.c:2215
 jl_apply at julia.h:1411 [inlined]
 start_task at task.c:261
 ip:0xffffffffffffffff
\end{minted}



Individual pointers returned by \hyperlink{6187626674327343338}{\texttt{backtrace()}} can be translated into \hyperlink{16824886840215699957}{\texttt{StackFrame}} s by passing them into \hyperlink{1451426077045795515}{\texttt{StackTraces.lookup()}}:




\begin{minted}{jlcon}
julia> pointer = backtrace()[1];

julia> frame = StackTraces.lookup(pointer)
1-element Array{StackFrame,1}:
 jl_backtrace_from_here at stackwalk.c:103

julia> println("The top frame is from $(frame[1].func)!")
The top frame is from jl_backtrace_from_here!
\end{minted}



\hypertarget{3908315974291496321}{}


\chapter{Performance Tips}



In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.



\hypertarget{8908549671364476026}{}


\section{Avoid global variables}



A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.



Any code that is performance critical or being benchmarked should be inside a function.



We find that global names are frequently constants, and declaring them as such greatly improves performance:




\begin{minted}{julia}
const DEFAULT_VAL = 0
\end{minted}



Uses of non-constant globals can be optimized by annotating their types at the point of use:




\begin{minted}{julia}
global x
y = f(x::Int + 1)
\end{minted}



Writing functions is better style. It leads to more reusable code and clarifies what steps are being done, and what their inputs and outputs are.



\begin{quote}
\textbf{Note}

All code in the REPL is evaluated in global scope, so a variable defined and assigned at toplevel will be a \textbf{global} variable.

\end{quote}


In the following REPL session:




\begin{minted}{jlcon}
julia> x = 1.0
\end{minted}



is equivalent to:




\begin{minted}{jlcon}
julia> global x = 1.0
\end{minted}



so all the performance issues discussed previously apply.



\hypertarget{1385939278590919882}{}


\section{Measure performance with \texttt{@time} and pay attention to memory allocation}



A useful tool for measuring performance is the \hyperlink{8029752041511656628}{\texttt{@time}} macro. The following example illustrates good working style:




\begin{minted}{jlcon}
julia> function f(n)
           s = 0
           for i = 1:n
               s += i/2
           end
           s
       end
f (generic function with 1 method)

julia> @time f(1)
  0.012686 seconds (2.09 k allocations: 103.421 KiB)
0.5

julia> @time f(10^6)
  0.021061 seconds (3.00 M allocations: 45.777 MiB, 11.69% gc time)
2.5000025e11
\end{minted}



On the first call (\texttt{@time f(1)}), \texttt{f} gets compiled.  (If you{\textquotesingle}ve not yet used \hyperlink{8029752041511656628}{\texttt{@time}} in this session, it will also compile functions needed for timing.)  You should not take the results of this run seriously. For the second run, note that in addition to reporting the time, it also indicated that a large amount of memory was allocated. This is the single biggest advantage of \hyperlink{8029752041511656628}{\texttt{@time}} vs. functions like \hyperlink{15143202356224875278}{\texttt{tic()}} and \hyperlink{16488371574475401451}{\texttt{toc()}}, which only report time.



Unexpected memory allocation is almost always a sign of some problem with your code, usually a problem with type-stability. Consequently, in addition to the allocation itself, it{\textquotesingle}s very likely that the code generated for your function is far from optimal. Take such indications seriously and follow the advice below.



For more serious benchmarking, consider the \href{https://github.com/JuliaCI/BenchmarkTools.jl}{BenchmarkTools.jl} package which evaluates the function multiple times in order to reduce noise.



As a teaser, an improved version of this function allocates no memory (the allocation reported below is due to running the \texttt{@time} macro in global scope) and has an order of magnitude faster execution after the first call:




\begin{minted}{jlcon}
julia> @time f_improved(1)
  0.007008 seconds (1.32 k allocations: 63.640 KiB)
0.5

julia> @time f_improved(10^6)
  0.002997 seconds (6 allocations: 192 bytes)
2.5000025e11
\end{minted}



Below you{\textquotesingle}ll learn how to spot the problem with \texttt{f} and how to fix it.



In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the \hyperlink{14350444000650775715}{tools} below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see \hyperlink{9465526813695170184}{Pre-allocating outputs}).



\hypertarget{14350444000650775715}{}


\section{Tools}



Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:



\begin{itemize}
\item \hyperlink{13874102823603666739}{Profiling} allows you to measure the performance of your running code and identify lines that serve as bottlenecks.  For complex projects, the \href{https://github.com/timholy/ProfileView.jl}{ProfileView} package can help you visualize your profiling results.


\item Unexpectedly-large memory allocations–as reported by \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{5377755456008435782}{\texttt{@allocated}}, or the profiler (through calls to the garbage-collection routines)–hint that there might be issues with your code.  If you don{\textquotesingle}t see another reason for the allocations, suspect a type problem.  You can also start Julia with the \texttt{--track-allocation=user} option and examine the resulting \texttt{*.mem} files to see information about where those allocations occur.  See \hyperlink{10992983602239333354}{Memory allocation analysis}.


\item \texttt{@code\_warntype} generates a representation of your code that can be helpful in finding expressions that result in type uncertainty. See \hyperlink{7509450972834198661}{\texttt{@code\_warntype}} below.


\item The \href{https://github.com/tonyhffong/Lint.jl}{Lint} package can also warn you of certain types of programming errors.

\end{itemize}


\hypertarget{10897967302437980226}{}


\section{Avoid containers with abstract type parameters}



When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible.



Consider the following:




\begin{minted}{julia}
a = Real[]    # typeof(a) = Array{Real,1}
if (f = rand()) < .8
    push!(a, f)
end
\end{minted}



Because \texttt{a} is a an array of abstract type \hyperlink{6175959395021454412}{\texttt{Real}}, it must be able to hold any \texttt{Real} value.  Since \texttt{Real} objects can be of arbitrary size and structure, \texttt{a} must be represented as an array of pointers to individually allocated \texttt{Real} objects. Because \texttt{f} will always be a \hyperlink{5027751419500983000}{\texttt{Float64}}, we should instead, use:




\begin{minted}{julia}
a = Float64[] # typeof(a) = Array{Float64,1}
\end{minted}



which will create a contiguous block of 64-bit floating-point values that can be manipulated efficiently.



See also the discussion under \hyperlink{15542027490314302254}{Parametric Types}.



\hypertarget{14626636305597624304}{}


\section{Type declarations}



In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is \emph{not} the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.



\hypertarget{1456452126529302259}{}


\subsection{Avoid fields with abstract type}



Types can be declared without specifying the types of their fields:




\begin{lstlisting}
julia> struct MyAmbiguousType
           a
       end
\end{lstlisting}



This allows \texttt{a} to be of any type. This can often be useful, but it does have a downside: for objects of type \texttt{MyAmbiguousType}, the compiler will not be able to generate high-performance code.  The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type \texttt{MyAmbiguousType}:




\begin{lstlisting}
julia> b = MyAmbiguousType("Hello")
MyAmbiguousType("Hello")

julia> c = MyAmbiguousType(17)
MyAmbiguousType(17)

julia> typeof(b)
MyAmbiguousType

julia> typeof(c)
MyAmbiguousType
\end{lstlisting}



\texttt{b} and \texttt{c} have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field \texttt{a}, the fact that the memory representation of a \hyperlink{6609065134969660118}{\texttt{UInt8}} differs from a \hyperlink{5027751419500983000}{\texttt{Float64}} also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.



You can do better by declaring the type of \texttt{a}. Here, we are focused on the case where \texttt{a} might be any one of several types, in which case the natural solution is to use parameters. For example:




\begin{lstlisting}
julia> mutable struct MyType{T<:AbstractFloat}
           a::T
       end
\end{lstlisting}



This is a better choice than




\begin{lstlisting}
julia> mutable struct MyStillAmbiguousType
           a::AbstractFloat
       end
\end{lstlisting}



because the first version specifies the type of \texttt{a} from the type of the wrapper object.  For example:




\begin{lstlisting}
julia> m = MyType(3.2)
MyType{Float64}(3.2)

julia> t = MyStillAmbiguousType(3.2)
MyStillAmbiguousType(3.2)

julia> typeof(m)
MyType{Float64}

julia> typeof(t)
MyStillAmbiguousType
\end{lstlisting}



The type of field \texttt{a} can be readily determined from the type of \texttt{m}, but not from the type of \texttt{t}.  Indeed, in \texttt{t} it{\textquotesingle}s possible to change the type of field \texttt{a}:




\begin{lstlisting}
julia> typeof(t.a)
Float64

julia> t.a = 4.5f0
4.5f0

julia> typeof(t.a)
Float32
\end{lstlisting}



In contrast, once \texttt{m} is constructed, the type of \texttt{m.a} cannot change:




\begin{lstlisting}
julia> m.a = 4.5f0
4.5f0

julia> typeof(m.a)
Float64
\end{lstlisting}



The fact that the type of \texttt{m.a} is known from \texttt{m}{\textquotesingle}s type–coupled with the fact that its type cannot change mid-function–allows the compiler to generate highly-optimized code for objects like \texttt{m} but not for objects like \texttt{t}.



Of course, all of this is true only if we construct \texttt{m} with a concrete type.  We can break this by explicitly constructing it with an abstract type:




\begin{lstlisting}
julia> m = MyType{AbstractFloat}(3.2)
MyType{AbstractFloat}(3.2)

julia> typeof(m.a)
Float64

julia> m.a = 4.5f0
4.5f0

julia> typeof(m.a)
Float32
\end{lstlisting}



For all practical purposes, such objects behave identically to those of \texttt{MyStillAmbiguousType}.



It{\textquotesingle}s quite instructive to compare the sheer amount code generated for a simple function




\begin{minted}{julia}
func(m::MyType) = m.a+1
\end{minted}



using




\begin{minted}{julia}
code_llvm(func,Tuple{MyType{Float64}})
code_llvm(func,Tuple{MyType{AbstractFloat}})
code_llvm(func,Tuple{MyType})
\end{minted}



For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn{\textquotesingle}t need to generate any code to resolve the type at run-time. This results in shorter and faster code.



\hypertarget{595407961498030927}{}


\subsection{Avoid fields with abstract containers}



The same best practices also work for container types:




\begin{lstlisting}
julia> mutable struct MySimpleContainer{A<:AbstractVector}
           a::A
       end

julia> mutable struct MyAmbiguousContainer{T}
           a::AbstractVector{T}
       end
\end{lstlisting}



For example:




\begin{lstlisting}
julia> c = MySimpleContainer(1:3);

julia> typeof(c)
MySimpleContainer{UnitRange{Int64}}

julia> c = MySimpleContainer([1:3;]);

julia> typeof(c)
MySimpleContainer{Array{Int64,1}}

julia> b = MyAmbiguousContainer(1:3);

julia> typeof(b)
MyAmbiguousContainer{Int64}

julia> b = MyAmbiguousContainer([1:3;]);

julia> typeof(b)
MyAmbiguousContainer{Int64}
\end{lstlisting}



For \texttt{MySimpleContainer}, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.



While the compiler can now do its job perfectly well, there are cases where \emph{you} might wish that your code could do different things depending on the \emph{element type} of \texttt{a}.  Usually the best way to achieve this is to wrap your specific operation (here, \texttt{foo}) in a separate function:




\begin{lstlisting}
julia> function sumfoo(c::MySimpleContainer)
           s = 0
           for x in c.a
               s += foo(x)
           end
           s
       end
sumfoo (generic function with 1 method)

julia> foo(x::Integer) = x
foo (generic function with 1 method)

julia> foo(x::AbstractFloat) = round(x)
foo (generic function with 2 methods)
\end{lstlisting}



This keeps things simple, while allowing the compiler to generate optimized code in all cases.



However, there are cases where you may need to declare different versions of the outer function for different element types of \texttt{a}. You could do it like this:




\begin{lstlisting}
function myfun(c::MySimpleContainer{Vector{T}}) where T<:AbstractFloat
    ...
end
function myfun(c::MySimpleContainer{Vector{T}}) where T<:Integer
    ...
end
\end{lstlisting}



This works fine for \texttt{Vector\{T\}}, but we{\textquotesingle}d also have to write explicit versions for \texttt{UnitRange\{T\}} or other abstract types. To prevent such tedium, you can use two parameters in the declaration of \texttt{MyContainer}:




\begin{lstlisting}
julia> mutable struct MyContainer{T, A<:AbstractVector}
           a::A
       end

julia> MyContainer(v::AbstractVector) = MyContainer{eltype(v), typeof(v)}(v)
MyContainer

julia> b = MyContainer(1:5);

julia> typeof(b)
MyContainer{Int64,UnitRange{Int64}}
\end{lstlisting}



Note the somewhat surprising fact that \texttt{T} doesn{\textquotesingle}t appear in the declaration of field \texttt{a}, a point that we{\textquotesingle}ll return to in a moment. With this approach, one can write functions such as:




\begin{lstlisting}
julia> function myfunc(c::MyContainer{<:Integer, <:AbstractArray})
           return c.a[1]+1
       end
myfunc (generic function with 1 method)

julia> function myfunc(c::MyContainer{<:AbstractFloat})
           return c.a[1]+2
       end
myfunc (generic function with 2 methods)

julia> function myfunc(c::MyContainer{T,Vector{T}}) where T<:Integer
           return c.a[1]+3
       end
myfunc (generic function with 3 methods)
\end{lstlisting}



\begin{quote}
\textbf{Note}

Because we can only define \texttt{MyContainer} for \texttt{A<:AbstractArray}, and any unspecified parameters are arbitrary, the first function above could have been written more succinctly as \texttt{function myfunc\{T<:Integer\}(c::MyContainer\{T\})}

\end{quote}



\begin{lstlisting}
julia> myfunc(MyContainer(1:3))
2

julia> myfunc(MyContainer(1.0:3))
3.0

julia> myfunc(MyContainer([1:3;]))
4
\end{lstlisting}



As you can see, with this approach it{\textquotesingle}s possible to specialize on both the element type \texttt{T} and the array type \texttt{A}.



However, there{\textquotesingle}s one remaining hole: we haven{\textquotesingle}t enforced that \texttt{A} has element type \texttt{T}, so it{\textquotesingle}s perfectly possible to construct an object like this:




\begin{lstlisting}
julia> b = MyContainer{Int64, UnitRange{Float64}}(UnitRange(1.3, 5.0));

julia> typeof(b)
MyContainer{Int64,UnitRange{Float64}}
\end{lstlisting}



To prevent this, we can add an inner constructor:




\begin{lstlisting}
julia> mutable struct MyBetterContainer{T<:Real, A<:AbstractVector}
           a::A
           MyBetterContainer{T,A}(v::AbstractVector{T}) where {T,A} = new(v)
       end

julia> MyBetterContainer(v::AbstractVector) = MyBetterContainer{eltype(v),typeof(v)}(v)
MyBetterContainer

julia> b = MyBetterContainer(UnitRange(1.3, 5.0));

julia> typeof(b)
MyBetterContainer{Float64,UnitRange{Float64}}

julia> b = MyBetterContainer{Int64, UnitRange{Float64}}(UnitRange(1.3, 5.0));
ERROR: MethodError: Cannot `convert` an object of type UnitRange{Float64} to an object of type MyBetterContainer{Int64,UnitRange{Float64}}
[...]
\end{lstlisting}



The inner constructor requires that the element type of \texttt{A} be \texttt{T}.



\hypertarget{8349945497889639186}{}


\subsection{Annotate values taken from untyped locations}



It is often convenient to work with data structures that may contain values of any type (arrays of type \texttt{Array\{Any\}}). But, if you{\textquotesingle}re using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:




\begin{minted}{julia}
function foo(a::Array{Any,1})
    x = a[1]::Int32
    b = x+1
    ...
end
\end{minted}



Here, we happened to know that the first element of \texttt{a} would be an \hyperlink{10103694114785108551}{\texttt{Int32}}. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.



\hypertarget{3940644267230903518}{}


\subsection{Declare types of keyword arguments}



Keyword arguments can have declared types:




\begin{minted}{julia}
function with_keyword(x; name::Int = 1)
    ...
end
\end{minted}



Functions are specialized on the types of keyword arguments, so these declarations will not affect performance of code inside the function. However, they will reduce the overhead of calls to the function that include keyword arguments.



Functions with keyword arguments have near-zero overhead for call sites that pass only positional arguments.



Passing dynamic lists of keyword arguments, as in \texttt{f(x; keywords...)}, can be slow and should be avoided in performance-sensitive code.



\hypertarget{46524760051978294}{}


\section{Break functions into multiple definitions}



Writing a function as many small definitions allows the compiler to directly call the most applicable code, or even inline it.



Here is an example of a {\textquotedbl}compound function{\textquotedbl} that should really be written as multiple definitions:




\begin{minted}{julia}
function norm(A)
    if isa(A, Vector)
        return sqrt(real(dot(A,A)))
    elseif isa(A, Matrix)
        return maximum(svd(A)[2])
    else
        error("norm: invalid argument")
    end
end
\end{minted}



This can be written more concisely and efficiently as:




\begin{minted}{julia}
norm(x::Vector) = sqrt(real(dot(x,x)))
norm(A::Matrix) = maximum(svd(A)[2])
\end{minted}



\hypertarget{11858157923263469229}{}


\section{Write {\textquotedbl}type-stable{\textquotedbl} functions}



When possible, it helps to ensure that a function always returns a value of the same type. Consider the following definition:




\begin{minted}{julia}
pos(x) = x < 0 ? 0 : x
\end{minted}



Although this seems innocent enough, the problem is that \texttt{0} is an integer (of type \texttt{Int}) and \texttt{x} might be of any type. Thus, depending on the value of \texttt{x}, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:




\begin{minted}{julia}
pos(x) = x < 0 ? zero(x) : x
\end{minted}



There is also a \hyperlink{11395333326208453101}{\texttt{one()}} function, and a more general \hyperlink{374166931194490566}{\texttt{oftype(x, y)}} function, which returns \texttt{y} converted to the type of \texttt{x}.



\hypertarget{8500497942804690009}{}


\section{Avoid changing the type of a variable}



An analogous {\textquotedbl}type-stability{\textquotedbl} problem exists for variables used repeatedly within a function:




\begin{minted}{julia}
function foo()
    x = 1
    for i = 1:10
        x = x/bar()
    end
    return x
end
\end{minted}



Local variable \texttt{x} starts as an integer, and after one loop iteration becomes a floating-point number (the result of \hyperlink{4103478871488785445}{\texttt{/}} operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:



\begin{itemize}
\item Initialize \texttt{x} with \texttt{x = 1.0}


\item Declare the type of \texttt{x}: \texttt{x::Float64 = 1}


\item Use an explicit conversion: \texttt{x = oneunit(T)}


\item Initialize with the first loop iteration, to \texttt{x = 1/bar()}, then loop \texttt{for i = 2:10}

\end{itemize}


\hypertarget{13103982983044032238}{}


\section{Separate kernel functions (aka, function barriers)}



Many functions follow a pattern of performing some set-up work, and then running many iterations to perform a core computation. Where possible, it is a good idea to put these core computations in separate functions. For example, the following contrived function returns an array of a randomly-chosen type:






\begin{minted}{jlcon}
julia> function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(n)
           for i = 1:n
               a[i] = 2
           end
           return a
       end
strange_twos (generic function with 1 method)

julia> strange_twos(3)
3-element Array{Float64,1}:
 2.0
 2.0
 2.0
\end{minted}



This should be written as:




\begin{minted}{jlcon}
julia> function fill_twos!(a)
           for i=1:length(a)
               a[i] = 2
           end
       end
fill_twos! (generic function with 1 method)

julia> function strange_twos(n)
           a = Array{rand(Bool) ? Int64 : Float64}(n)
           fill_twos!(a)
           return a
       end
strange_twos (generic function with 1 method)

julia> strange_twos(3)
3-element Array{Float64,1}:
 2.0
 2.0
 2.0
\end{minted}



Julia{\textquotesingle}s compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of \texttt{a} during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of \texttt{fill\_twos!} for different types of \texttt{a}.



The second form is also often better style and can lead to more code reuse.



This pattern is used in several places in the standard library. For example, see \texttt{hvcat\_fill} in \href{https://github.com/JuliaLang/julia/blob/master/base/abstractarray.jl}{\texttt{abstractarray.jl}}, or the \hyperlink{5162290739791026948}{\texttt{fill!}} function, which we could have used instead of writing our own \texttt{fill\_twos!}.



Functions like \texttt{strange\_twos} occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.



\hypertarget{14283833063419818391}{}


\section{Types with values-as-parameters}



Let{\textquotesingle}s say you want to create an \texttt{N}-dimensional array that has size 3 along each axis.  Such arrays can be created like this:




\begin{minted}{jlcon}
julia> A = fill(5.0, (3, 3))
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



This approach works very well: the compiler can figure out that \texttt{A} is an \texttt{Array\{Float64,2\}} because it knows the type of the fill value (\texttt{5.0::Float64}) and the dimensionality (\texttt{(3, 3)::NTuple\{2,Int\}}). This implies that the compiler can generate very efficient code for any future usage of \texttt{A} in the same function.



But now let{\textquotesingle}s say you want to write a function that creates a 3×3×... array in arbitrary dimensions; you might be tempted to write a function




\begin{minted}{jlcon}
julia> function array3(fillval, N)
           fill(fillval, ntuple(d->3, N))
       end
array3 (generic function with 1 method)

julia> array3(5.0, 2)
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



This works, but (as you can verify for yourself using \texttt{@code\_warntype array3(5.0, 2)}) the problem is that the output type cannot be inferred: the argument \texttt{N} is a \emph{value} of type \texttt{Int}, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of \texttt{A}; such code will be very slow.



Now, one very good way to solve such problems is by using the \hyperlink{13103982983044032238}{function-barrier technique}. However, in some cases you might want to eliminate the type-instability altogether.  In such cases, one approach is to pass the dimensionality as a parameter, for example through \texttt{Val\{T\}} (see \hyperlink{7750565687602056032}{{\textquotedbl}Value types{\textquotedbl}}):




\begin{minted}{jlcon}
julia> function array3(fillval, ::Type{Val{N}}) where N
           fill(fillval, ntuple(d->3, Val{N}))
       end
array3 (generic function with 1 method)

julia> array3(5.0, Val{2})
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



Julia has a specialized version of \texttt{ntuple} that accepts a \texttt{Val\{::Int\}} as the second parameter; by passing \texttt{N} as a type-parameter, you make its {\textquotedbl}value{\textquotedbl} known to the compiler. Consequently, this version of \texttt{array3} allows the compiler to predict the return type.



However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called \texttt{array3} from a function like this:




\begin{minted}{julia}
function call_array3(fillval, n)
    A = array3(fillval, Val{n})
end
\end{minted}



Here, you{\textquotesingle}ve created the same problem all over again: the compiler can{\textquotesingle}t guess the type of \texttt{n}, so it doesn{\textquotesingle}t know the type of \texttt{Val\{n\}}.  Attempting to use \texttt{Val}, but doing so incorrectly, can easily make performance \emph{worse} in many situations.  (Only in situations where you{\textquotesingle}re effectively combining \texttt{Val} with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)



An example of correct usage of \texttt{Val} would be:




\begin{minted}{julia}
function filter3(A::AbstractArray{T,N}) where {T,N}
    kernel = array3(1, Val{N})
    filter(A, kernel)
end
\end{minted}



In this example, \texttt{N} is passed as a parameter, so its {\textquotedbl}value{\textquotedbl} is known to the compiler.  Essentially, \texttt{Val\{T\}} works only when \texttt{T} is either hard-coded (\texttt{Val\{3\}}) or already specified in the type-domain.



\hypertarget{5410118045861360063}{}


\section{The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)}



Once one learns to appreciate multiple dispatch, there{\textquotesingle}s an understandable tendency to go crazy and try to use it for everything. For example, you might imagine using it to store information, e.g.




\begin{lstlisting}
struct Car{Make,Model}
    year::Int
    ...more fields...
end
\end{lstlisting}



and then dispatch on objects like \texttt{Car\{:Honda,:Accord\}(year, args...)}.



This might be worthwhile when the following are true:



\begin{itemize}
\item You require CPU-intensive processing on each \texttt{Car}, and it becomes vastly more efficient if you know the \texttt{Make} and \texttt{Model} at compile time.


\item You have homogenous lists of the same type of \texttt{Car} to process, so that you can store them all in an \texttt{Array\{Car\{:Honda,:Accord\},N\}}.

\end{itemize}


When the latter holds, a function processing such a homogenous array can be productively specialized: Julia knows the type of each element in advance (all objects in the container have the same concrete type), so Julia can {\textquotedbl}look up{\textquotedbl} the correct method calls when the function is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list.



When these do not hold, then it{\textquotesingle}s likely that you{\textquotesingle}ll get no benefit; worse, the resulting {\textquotedbl}combinatorial explosion of types{\textquotedbl} will be counterproductive.  If \texttt{items[i+1]} has a different type than \texttt{item[i]}, Julia has to look up the type at run-time, search for the appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In essence, you{\textquotesingle}re asking the full type- system and JIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary lookup in your own code.



Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a {\textquotedbl}switch{\textquotedbl} statement can be found \href{https://groups.google.com/forum/\#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ}{on the mailing list}.



Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized functions for each different \texttt{Car\{Make, Model\}}; if you have hundreds or thousands of such types, then every function that accepts such an object as a parameter (from a custom \texttt{get\_year} function you might write yourself, to the generic \texttt{push!} function in the standard library) will have hundreds or thousands of variants compiled for it.  Each of these increases the size of the cache of compiled code, the length of internal lists of methods, etc.  Excess enthusiasm for values-as-parameters can easily waste enormous resources.



\hypertarget{18377588874636550850}{}


\section{Access arrays in memory order, along columns}



Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be verified using the \texttt{vec} function or the syntax \texttt{[:]} as shown below (notice that the array is ordered \texttt{[1 3 2 4]}, not \texttt{[1 2 3 4]}):




\begin{minted}{jlcon}
julia> x = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> x[:]
4-element Array{Int64,1}:
 1
 3
 2
 4
\end{minted}



This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (\texttt{numpy}) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.



Consider the following contrived example. Imagine we wanted to write a function that accepts a \texttt{Vector} and returns a square \texttt{Matrix} with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in \hyperlink{7643954538117657889}{\texttt{repmat()}}):




\begin{minted}{julia}
function copy_cols(x::Vector{T}) where T
    n = size(x, 1)
    out = Array{T}(n, n)
    for i = 1:n
        out[:, i] = x
    end
    out
end

function copy_rows(x::Vector{T}) where T
    n = size(x, 1)
    out = Array{T}(n, n)
    for i = 1:n
        out[i, :] = x
    end
    out
end

function copy_col_row(x::Vector{T}) where T
    n = size(x, 1)
    out = Array{T}(n, n)
    for col = 1:n, row = 1:n
        out[row, col] = x[row]
    end
    out
end

function copy_row_col(x::Vector{T}) where T
    n = size(x, 1)
    out = Array{T}(n, n)
    for row = 1:n, col = 1:n
        out[row, col] = x[col]
    end
    out
end
\end{minted}



Now we will time each of these functions using the same random \texttt{10000} by \texttt{1} input vector:




\begin{minted}{jlcon}
julia> x = randn(10000);

julia> fmt(f) = println(rpad(string(f)*": ", 14, ' '), @elapsed f(x))

julia> map(fmt, Any[copy_cols, copy_rows, copy_col_row, copy_row_col]);
copy_cols:    0.331706323
copy_rows:    1.799009911
copy_col_row: 0.415630047
copy_row_col: 1.721531501
\end{minted}



Notice that \texttt{copy\_cols} is much faster than \texttt{copy\_rows}. This is expected because \texttt{copy\_cols} respects the column-based memory layout of the \texttt{Matrix} and fills it one column at a time. Additionally, \texttt{copy\_col\_row} is much faster than \texttt{copy\_row\_col} because it follows our rule of thumb that the first element to appear in a slice expression should be coupled with the inner-most loop.



\hypertarget{9465526813695170184}{}


\section{Pre-allocating outputs}



If your function returns an \texttt{Array} or some other complex type, it may have to allocate memory.  Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.



Sometimes you can circumvent the need to allocate memory on each function call by preallocating the output.  As a trivial example, compare




\begin{minted}{julia}
function xinc(x)
    return [x, x+1, x+2]
end

function loopinc()
    y = 0
    for i = 1:10^7
        ret = xinc(i)
        y += ret[2]
    end
    y
end
\end{minted}



with




\begin{minted}{julia}
function xinc!(ret::AbstractVector{T}, x::T) where T
    ret[1] = x
    ret[2] = x+1
    ret[3] = x+2
    nothing
end

function loopinc_prealloc()
    ret = Array{Int}(3)
    y = 0
    for i = 1:10^7
        xinc!(ret, i)
        y += ret[2]
    end
    y
end
\end{minted}



Timing results:




\begin{minted}{jlcon}
julia> @time loopinc()
  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)
50000015000000

julia> @time loopinc_prealloc()
  0.030850 seconds (6 allocations: 288 bytes)
50000015000000
\end{minted}



Preallocation has other advantages, for example by allowing the caller to control the {\textquotedbl}output{\textquotedbl} type from an algorithm.  In the example above, we could have passed a \texttt{SubArray} rather than an \hyperlink{15492651498431872487}{\texttt{Array}}, had we so desired.



Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for {\textquotedbl}vectorized{\textquotedbl} (element-wise) functions, the convenient syntax \texttt{x .= f.(y)} can be used for in-place operations with fused loops and no temporary arrays (see the \hyperlink{13590013989415065742}{dot syntax for vectorizing functions}).



\hypertarget{17646926318481901948}{}


\section{More dots: Fuse vectorized operations}



Julia has a special \hyperlink{13590013989415065742}{dot syntax} that converts any scalar function into a {\textquotedbl}vectorized{\textquotedbl} function call, and any operator into a {\textquotedbl}vectorized{\textquotedbl} operator, with the special property that nested {\textquotedbl}dot calls{\textquotedbl} are \emph{fusing}: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use \texttt{.=} and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).



In a linear-algebra context, this means that even though operations like \texttt{vector + vector} and \texttt{vector * scalar} are defined, it can be advantageous to instead use \texttt{vector .+ vector} and \texttt{vector .* scalar} because the resulting loops can be fused with surrounding computations. For example, consider the two functions:




\begin{minted}{julia}
f(x) = 3x.^2 + 4x + 7x.^3

fdot(x) = @. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3
\end{minted}



Both \texttt{f} and \texttt{fdot} compute the same thing.  However, \texttt{fdot} (defined with the help of the \hyperlink{16688502228717894452}{\texttt{@.}} macro) is significantly faster when applied to an array:




\begin{minted}{jlcon}
julia> x = rand(10^6);

julia> @time f(x);
  0.010986 seconds (18 allocations: 53.406 MiB, 11.45% gc time)

julia> @time fdot(x);
  0.003470 seconds (6 allocations: 7.630 MiB)

julia> @time f.(x);
  0.003297 seconds (30 allocations: 7.631 MiB)
\end{minted}



That is, \texttt{fdot(x)} is three times faster and allocates 1/7 the memory of \texttt{f(x)}, because each \texttt{*} and \texttt{+} operation in \texttt{f(x)} allocates a new temporary array and executes in a separate loop. (Of course, if you just do \texttt{f.(x)} then it is as fast as \texttt{fdot(x)} in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)



\hypertarget{10279107342440166344}{}


\section{Consider using views for slices}



In Julia, an array {\textquotedbl}slice{\textquotedbl} expression like \texttt{array[1:5, :]} creates a copy of that data (except on the left-hand side of an assignment, where \texttt{array[1:5, :] = ...} assigns in-place to that portion of \texttt{array}). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.



An alternative is to create a {\textquotedbl}view{\textquotedbl} of the array, which is an array object (a \texttt{SubArray}) that actually references the data of the original array in-place, without making a copy.  (If you write to a view, it modifies the original array{\textquotesingle}s data as well.) This can be done for individual slices by calling \hyperlink{4861450464669906845}{\texttt{view()}}, or more simply for a whole expression or block of code by putting \hyperlink{4544474300423667148}{\texttt{@views}} in front of that expression.  For example:




\begin{minted}{jlcon}
julia> fcopy(x) = sum(x[2:end-1])

julia> @views fview(x) = sum(x[2:end-1])

julia> x = rand(10^6);

julia> @time fcopy(x);
  0.003051 seconds (7 allocations: 7.630 MB)

julia> @time fview(x);
  0.001020 seconds (6 allocations: 224 bytes)
\end{minted}



Notice both the 3× speedup and the decreased memory allocation of the \texttt{fview} version of the function.



\hypertarget{17505542591786045379}{}


\section{Avoid string interpolation for I/O}



When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of:




\begin{minted}{julia}
println(file, "$a $b")
\end{minted}



use:




\begin{minted}{julia}
println(file, a, " ", b)
\end{minted}



The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:




\begin{minted}{julia}
println(file, "$(f(a))$(f(b))")
\end{minted}



versus:




\begin{minted}{julia}
println(file, f(a), f(b))
\end{minted}



\hypertarget{4757281004083031972}{}


\section{Optimize network I/O during parallel execution}



When executing a remote function in parallel:




\begin{minted}{julia}
responses = Vector{Any}(nworkers())
@sync begin
    for (idx, pid) in enumerate(workers())
        @async responses[idx] = remotecall_fetch(pid, foo, args...)
    end
end
\end{minted}



is faster than:




\begin{minted}{julia}
refs = Vector{Any}(nworkers())
for (idx, pid) in enumerate(workers())
    refs[idx] = @spawnat pid foo(args...)
end
responses = [fetch(r) for r in refs]
\end{minted}



The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the \hyperlink{13196020699522784599}{\texttt{@spawnat}} and the second due to the \hyperlink{7098010828229464277}{\texttt{fetch}} (or even a \hyperlink{13761789780433862250}{\texttt{wait}}). The \hyperlink{7098010828229464277}{\texttt{fetch}}/\hyperlink{13761789780433862250}{\texttt{wait}} is also being executed serially resulting in an overall poorer performance.



\hypertarget{15573873242571976679}{}


\section{Fix deprecation warnings}



A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.



\hypertarget{12747370404536591663}{}


\section{Tweaks}



These are some minor points that might help in tight inner loops.



\begin{itemize}
\item Avoid unnecessary arrays. For example, instead of \hyperlink{8666686648688281595}{\texttt{sum([x,y,z])}} use \texttt{x+y+z}.


\item Use \hyperlink{15686257922156163743}{\texttt{abs2(z)}} instead of \hyperlink{5729367935110528960}{\texttt{abs(z){\textasciicircum}2}} for complex \texttt{z}. In general, try to rewrite code to use \hyperlink{15686257922156163743}{\texttt{abs2()}} instead of \hyperlink{9614495866226399167}{\texttt{abs()}} for complex arguments.


\item Use \hyperlink{8020976424566491334}{\texttt{div(x,y)}} for truncating division of integers instead of \hyperlink{7412479111462927551}{\texttt{trunc(x/y)}}, \hyperlink{15067916827074788527}{\texttt{fld(x,y)}} instead of \hyperlink{13948277906659863497}{\texttt{floor(x/y)}}, and \hyperlink{7922388465305816555}{\texttt{cld(x,y)}} instead of \hyperlink{11509984064218511874}{\texttt{ceil(x/y)}}.

\end{itemize}


\hypertarget{10607053427200951903}{}


\section{Performance Annotations}



Sometimes you can enable better optimization by promising certain program properties.



\begin{itemize}
\item Use \texttt{@inbounds} to eliminate array bounds checking within expressions. Be certain before doing this. If the subscripts are ever out of bounds, you may suffer crashes or silent corruption.


\item Use \texttt{@fastmath} to allow floating point optimizations that are correct for real numbers, but lead to differences for IEEE numbers. Be careful when doing this, as this may change numerical results. This corresponds to the \texttt{-ffast-math} option of clang.


\item Write \texttt{@simd} in front of \texttt{for} loops that are amenable to vectorization. \textbf{This feature is experimental} and could change or disappear in future versions of Julia.

\end{itemize}


Note: While \texttt{@simd} needs to be placed directly in front of a loop, both \texttt{@inbounds} and \texttt{@fastmath} can be applied to several statements at once, e.g. using \texttt{begin} ... \texttt{end}, or even to a whole function.



Here is an example with both \texttt{@inbounds} and \texttt{@simd} markup:




\begin{minted}{julia}
function inner(x, y)
    s = zero(eltype(x))
    for i=1:length(x)
        @inbounds s += x[i]*y[i]
    end
    s
end

function innersimd(x, y)
    s = zero(eltype(x))
    @simd for i=1:length(x)
        @inbounds s += x[i]*y[i]
    end
    s
end

function timeit(n, reps)
    x = rand(Float32,n)
    y = rand(Float32,n)
    s = zero(Float64)
    time = @elapsed for j in 1:reps
        s+=inner(x,y)
    end
    println("GFlop/sec        = ",2.0*n*reps/time*1E-9)
    time = @elapsed for j in 1:reps
        s+=innersimd(x,y)
    end
    println("GFlop/sec (SIMD) = ",2.0*n*reps/time*1E-9)
end

timeit(1000,1000)
\end{minted}



On a computer with a 2.4GHz Intel Core i5 processor, this produces:




\begin{lstlisting}
GFlop/sec        = 1.9467069505224963
GFlop/sec (SIMD) = 17.578554163920018
\end{lstlisting}



(\texttt{GFlop/sec} measures the performance, and larger numbers are better.) The range for a \texttt{@simd for} loop should be a one-dimensional range. A variable used for accumulating, such as \texttt{s} in the example, is called a \emph{reduction variable}. By using \texttt{@simd}, you are asserting several properties of the loop:



\begin{itemize}
\item It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.


\item Floating-point operations on reduction variables can be reordered, possibly causing different results than without \texttt{@simd}.


\item No iteration ever waits on another iteration to make forward progress.

\end{itemize}


A loop containing \texttt{break}, \texttt{continue}, or \texttt{@goto} will cause a compile-time error.



Using \texttt{@simd} merely gives the compiler license to vectorize. Whether it actually does so depends on the compiler. To actually benefit from the current implementation, your loop should have the following additional properties:



\begin{itemize}
\item The loop must be an innermost loop.


\item The loop body must be straight-line code. This is why \texttt{@inbounds} is currently needed for all array accesses. The compiler can sometimes turn short \texttt{\&\&}, \texttt{||}, and \texttt{?:} expressions into straight-line code, if it is safe to evaluate all operands unconditionally. Consider using \hyperlink{9861487635347877687}{\texttt{ifelse()}} instead of \texttt{?:} in the loop if it is safe to do so.


\item Accesses must have a stride pattern and cannot be {\textquotedbl}gathers{\textquotedbl} (random-index reads) or {\textquotedbl}scatters{\textquotedbl} (random-index writes).


\item The stride should be unit stride.


\item In some simple cases, for example with 2-3 arrays accessed in a loop, the LLVM auto-vectorization may kick in automatically, leading to no further speedup with \texttt{@simd}.

\end{itemize}


Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:




\begin{minted}{julia}
function init!(u)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds @simd for i in 1:n
        u[i] = sin(2pi*dx*i)
    end
end

function deriv!(u, du)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx
    @fastmath @inbounds @simd for i in 2:n-1
        du[i] = (u[i+1] - u[i-1]) / (2*dx)
    end
    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx
end

function norm(u)
    n = length(u)
    T = eltype(u)
    s = zero(T)
    @fastmath @inbounds @simd for i in 1:n
        s += u[i]^2
    end
    @fastmath @inbounds return sqrt(s/n)
end

function main()
    n = 2000
    u = Array{Float64}(n)
    init!(u)
    du = similar(u)

    deriv!(u, du)
    nu = norm(du)

    @time for i in 1:10^6
        deriv!(u, du)
        nu = norm(du)
    end

    println(nu)
end

main()
\end{minted}



On a computer with a 2.7 GHz Intel Core i7 processor, this produces:




\begin{lstlisting}
$ julia wave.jl;
elapsed time: 1.207814709 seconds (0 bytes allocated)

$ julia --math-mode=ieee wave.jl;
elapsed time: 4.487083643 seconds (0 bytes allocated)
\end{lstlisting}



Here, the option \texttt{--math-mode=ieee} disables the \texttt{@fastmath} macro, so that we can compare results.



In this case, the speedup due to \texttt{@fastmath} is a factor of about 3.7. This is unusually large – in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result – in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.



The annotation \texttt{@fastmath} re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression \texttt{1 / (2*dx)} in the function \texttt{deriv} is hoisted out of the loop (i.e. calculated outside the loop), as if one had written \texttt{idx = 1 / (2*dx)}. In the loop, the expression \texttt{... / (2*dx)} then becomes \texttt{... * idx}, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia{\textquotesingle}s \hyperlink{1731537926898979255}{\texttt{code\_native()}} function.



\hypertarget{12370344689233780157}{}


\section{Treat Subnormal Numbers as Zeros}



Subnormal numbers, formerly called \href{https://en.wikipedia.org/wiki/Denormal\_number}{denormal numbers}, are useful in many contexts, but incur a performance penalty on some hardware. A call \hyperlink{2845950135157372113}{\texttt{set\_zero\_subnormals(true)}} grants permission for floating-point operations to treat subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call \hyperlink{2845950135157372113}{\texttt{set\_zero\_subnormals(false)}} enforces strict IEEE behavior for subnormal numbers.



Below is an example where subnormals noticeably impact performance on some hardware:




\begin{minted}{julia}
function timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T
    @assert length(a)==length(b)
    n = length(b)
    b[1] = 1                            # Boundary condition
    for i=2:n-1
        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt
    end
    b[n] = 0                            # Boundary condition
end

function heatflow(a::Vector{T}, nstep::Integer) where T
    b = similar(a)
    for t=1:div(nstep,2)                # Assume nstep is even
        timestep(b,a,T(0.1))
        timestep(a,b,T(0.1))
    end
end

heatflow(zeros(Float32,10),2)           # Force compilation
for trial=1:6
    a = zeros(Float32,1000)
    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic
    @time heatflow(a,1000)
end
\end{minted}



This example generates many subnormal numbers because the values in \texttt{a} become an exponentially decreasing curve, which slowly flattens out over time.



Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as \texttt{x-y == 0} implies \texttt{x == y}:




\begin{minted}{jlcon}
julia> x = 3f-38; y = 2f-38;

julia> set_zero_subnormals(true); (x - y, x == y)
(0.0f0, false)

julia> set_zero_subnormals(false); (x - y, x == y)
(1.0000001f-38, false)
\end{minted}



In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.  For example, instead of initializing \texttt{a} with zeros, initialize it with:




\begin{minted}{julia}
a = rand(Float32,1000) * 1.f-9
\end{minted}



\hypertarget{7082991166860772411}{}


\section{\texttt{@code\_warntype}}



The macro \hyperlink{7509450972834198661}{\texttt{@code\_warntype}} (or its function variant \hyperlink{16883039507765569860}{\texttt{code\_warntype()}}) can sometimes be helpful in diagnosing type-related problems. Here{\textquotesingle}s an example:




\begin{minted}{julia}
pos(x) = x < 0 ? 0 : x

function f(x)
    y = pos(x)
    sin(y*x+1)
end

julia> @code_warntype f(3.2)
Variables:
  #self#::#f
  x::Float64
  y::UNION{FLOAT64,INT64}
  fy::Float64
  #temp#@_5::UNION{FLOAT64,INT64}
  #temp#@_6::Core.MethodInstance
  #temp#@_7::Float64

Body:
  begin
      $(Expr(:inbounds, false))
      # meta: location REPL[1] pos 1
      # meta: location float.jl < 487
      fy::Float64 = (Core.typeassert)((Base.sitofp)(Float64,0)::Float64,Float64)::Float64
      # meta: pop location
      unless (Base.or_int)((Base.lt_float)(x::Float64,fy::Float64)::Bool,(Base.and_int)((Base.and_int)((Base.eq_float)(x::Float64,fy::Float64)::Bool,(Base.lt_float)(fy::Float64,9.223372036854776e18)::Bool)::Bool,(Base.slt_int)((Base.fptosi)(Int64,fy::Float64)::Int64,0)::Bool)::Bool)::Bool goto 9
      #temp#@_5::UNION{FLOAT64,INT64} = 0
      goto 11
      9:
      #temp#@_5::UNION{FLOAT64,INT64} = x::Float64
      11:
      # meta: pop location
      $(Expr(:inbounds, :pop))
      y::UNION{FLOAT64,INT64} = #temp#@_5::UNION{FLOAT64,INT64} # line 3:
      unless (y::UNION{FLOAT64,INT64} isa Int64)::ANY goto 19
      #temp#@_6::Core.MethodInstance = MethodInstance for *(::Int64, ::Float64)
      goto 28
      19:
      unless (y::UNION{FLOAT64,INT64} isa Float64)::ANY goto 23
      #temp#@_6::Core.MethodInstance = MethodInstance for *(::Float64, ::Float64)
      goto 28
      23:
      goto 25
      25:
      #temp#@_7::Float64 = (y::UNION{FLOAT64,INT64} * x::Float64)::Float64
      goto 30
      28:
      #temp#@_7::Float64 = $(Expr(:invoke, :(#temp#@_6), :(Main.*), :(y), :(x)))
      30:
      return $(Expr(:invoke, MethodInstance for sin(::Float64), :(Main.sin), :((Base.add_float)(#temp#@_7,(Base.sitofp)(Float64,1)::Float64)::Float64)))
  end::Float64
\end{minted}



Interpreting the output of \hyperlink{7509450972834198661}{\texttt{@code\_warntype}}, like that of its cousins \hyperlink{10170271820987078660}{\texttt{@code\_lowered}}, \hyperlink{12279119633919839581}{\texttt{@code\_typed}}, \hyperlink{4715999780877895760}{\texttt{@code\_llvm}}, and \hyperlink{2366615256687729425}{\texttt{@code\_native}}, takes a little practice. Your code is being presented in form that has been partially digested on its way to generating compiled machine code.  Most of the expressions are annotated by a type, indicated by the \texttt{::T} (where \texttt{T} might be \hyperlink{5027751419500983000}{\texttt{Float64}}, for example). The most important characteristic of \hyperlink{7509450972834198661}{\texttt{@code\_warntype}} is that non-concrete types are displayed in red; in the above example, such output is shown in all-caps.



The top part of the output summarizes the type information for the different variables internal to the function. You can see that \texttt{y}, one of the variables you created, is a \texttt{Union\{Int64,Float64\}}, due to the type-instability of \texttt{pos}.  There is another variable, \texttt{\_var4}, which you can see also has the same type.



The next lines represent the body of \texttt{f}. The lines starting with a number followed by a colon (\texttt{1:}, \texttt{2:}) are labels, and represent targets for jumps (via \texttt{goto}) in your code.  Looking at the body, you can see that \texttt{pos} has been \emph{inlined} into \texttt{f}–everything before \texttt{2:} comes from code defined in \texttt{pos}.



Starting at \texttt{2:}, the variable \texttt{y} is defined, and again annotated as a \texttt{Union} type.  Next, we see that the compiler created the temporary variable \texttt{\_var1} to hold the result of \texttt{y*x}. Because a \hyperlink{5027751419500983000}{\texttt{Float64}} times \emph{either} an \hyperlink{7720564657383125058}{\texttt{Int64}} or \texttt{Float64} yields a \texttt{Float64}, all type-instability ends here. The net result is that \texttt{f(x::Float64)} will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.



How you use this information is up to you. Obviously, it would be far and away best to fix \texttt{pos} to be type-stable: if you did so, all of the variables in \texttt{f} would be concrete, and its performance would be optimal.  However, there are circumstances where this kind of \emph{ephemeral} type instability might not matter too much: for example, if \texttt{pos} is never used in isolation, the fact that \texttt{f}{\textquotesingle}s output is type-stable (for \hyperlink{5027751419500983000}{\texttt{Float64}} inputs) will shield later code from the propagating effects of type instability.  This is particularly relevant in cases where fixing the type instability is difficult or impossible: for example, currently it{\textquotesingle}s not possible to infer the return type of an anonymous function.  In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the {\textquotedbl}damage{\textquotedbl} from type instability.



The following examples may help you interpret expressions marked as containing non-leaf types:



\begin{itemize}
\item Function body ending in \texttt{end::Union\{T1,T2\})}

\begin{itemize}
\item Interpretation: function with unstable return type


\item Suggestion: make the return value type-stable, even if you have to annotate it

\end{itemize}

\item \texttt{f(x::T)::Union\{T1,T2\}}

\begin{itemize}
\item Interpretation: call to a type-unstable function


\item Suggestion: fix the function, or if necessary annotate the return value

\end{itemize}

\item \texttt{(top(arrayref))(A::Array\{Any,1\},1)::Any}

\begin{itemize}
\item Interpretation: accessing elements of poorly-typed arrays


\item Suggestion: use arrays with better-defined types, or if necessary annotate the type of individual element accesses

\end{itemize}

\item \texttt{(top(getfield))(A::ArrayContainer\{Float64\},:data)::Array\{Float64,N\}}

\begin{itemize}
\item Interpretation: getting a field that is of non-leaf type. In this case, \texttt{ArrayContainer} had a field \texttt{data::Array\{T\}}. But \texttt{Array} needs the dimension \texttt{N}, too, to be a concrete type.


\item Suggestion: use concrete types like \texttt{Array\{T,3\}} or \texttt{Array\{T,N\}}, where \texttt{N} is now a parameter of \texttt{ArrayContainer}

\end{itemize}
\end{itemize}


\hypertarget{14117620934191882930}{}


\chapter{Workflow Tips}



Here are some tips for working with Julia efficiently.



\hypertarget{9117157922141826251}{}


\section{REPL-based workflow}



As already elaborated in \hyperlink{9220662049678686366}{Interacting With Julia}, Julia{\textquotesingle}s REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.



\hypertarget{126896972279328152}{}


\subsection{A basic editor/REPL workflow}



The most basic Julia workflows involve using a text editor in conjunction with the \texttt{julia} command line. A common pattern includes the following elements:



\begin{itemize}
\item \textbf{Put code under development in a temporary module.} Create a file, say \texttt{Tmp.jl}, and include within it


\begin{lstlisting}
module Tmp

<your definitions here>

end
\end{lstlisting}


\item \textbf{Put your test code in another file.} Create another file, say \texttt{tst.jl}, which begins with


\begin{minted}{julia}
import Tmp
\end{minted}

and includes tests for the contents of \texttt{Tmp}. The value of using \texttt{import} versus \texttt{using} is that you can call \texttt{reload({\textquotedbl}Tmp{\textquotedbl})} instead of having to restart the REPL when your definitions change. Of course, the cost is the need to prepend \texttt{Tmp.} to uses of names defined in your module. (You can lower that cost by keeping your module name short.)

Alternatively, you can wrap the contents of your test file in a module, as


\begin{lstlisting}
module Tst
    using Tmp

    <scratch work>

end
\end{lstlisting}

The advantage is that you can now do \texttt{using Tmp} in your test code and can therefore avoid prepending \texttt{Tmp.} everywhere. The disadvantage is that code can no longer be selectively copied to the REPL without some tweaking.


\item \textbf{Lather. Rinse. Repeat.} Explore ideas at the \texttt{julia} command prompt. Save good ideas in \texttt{tst.jl}. Occasionally restart the REPL, issuing


\begin{minted}{julia}
reload("Tmp")
include("tst.jl")
\end{minted}

\end{itemize}


\hypertarget{16277073820866957327}{}


\subsection{Simplify initialization}



To simplify restarting the REPL, put project-specific initialization code in a file, say \texttt{\_init.jl}, which you can run on startup by issuing the command:




\begin{lstlisting}
julia -L _init.jl
\end{lstlisting}



If you further add the following to your \texttt{.juliarc.jl} file




\begin{minted}{julia}
isfile("_init.jl") && include(joinpath(pwd(), "_init.jl"))
\end{minted}



then calling \texttt{julia} from that directory will run the initialization code without the additional command line argument.



\hypertarget{3725235168071892595}{}


\section{Browser-based workflow}



It is also possible to interact with a Julia REPL in the browser via \href{https://github.com/JuliaLang/IJulia.jl}{IJulia}. See the package home for details.



\hypertarget{17403906501138262503}{}


\chapter{Style Guide}



The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs.



\hypertarget{2948313739076508076}{}


\section{Write functions, not just scripts}



Writing code as a series of steps at the top level is a quick way to get started solving a problem, but you should try to divide a program into functions as soon as possible. Functions are more reusable and testable, and clarify what steps are being done and what their inputs and outputs are. Furthermore, code inside functions tends to run much faster than top level code, due to how Julia{\textquotesingle}s compiler works.



It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like \hyperlink{13833999108924821801}{\texttt{pi}}).



\hypertarget{8633000073735097014}{}


\section{Avoid writing overly-specific types}



Code should be as generic as possible. Instead of writing:




\begin{minted}{julia}
convert(Complex{Float64}, x)
\end{minted}



it{\textquotesingle}s better to use available generic functions:




\begin{minted}{julia}
complex(float(x))
\end{minted}



The second version will convert \texttt{x} to an appropriate type, instead of always the same type.



This style point is especially relevant to function arguments. For example, don{\textquotesingle}t declare an argument to be of type \texttt{Int} or \hyperlink{10103694114785108551}{\texttt{Int32}} if it really could be any integer, expressed with the abstract type \hyperlink{8469131683393450448}{\texttt{Integer}}. In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a \hyperlink{14644228586476494020}{\texttt{MethodError}} will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as \href{https://en.wikipedia.org/wiki/Duck\_typing}{duck typing}.)



For example, consider the following definitions of a function \texttt{addone} that returns one plus its argument:




\begin{minted}{julia}
addone(x::Int) = x + 1                 # works only for Int
addone(x::Integer) = x + oneunit(x)    # any integer type
addone(x::Number) = x + oneunit(x)     # any numeric type
addone(x) = x + oneunit(x)             # any type supporting + and oneunit
\end{minted}



The last definition of \texttt{addone} handles any type supporting \hyperlink{2310843180104103470}{\texttt{oneunit}} (which returns 1 in the same type as \texttt{x}, which avoids unwanted type promotion) and the \hyperlink{3677358729494553841}{\texttt{+}} function with those arguments. The key thing to realize is that there is \emph{no performance penalty} to defining \emph{only} the general \texttt{addone(x) = x + oneunit(x)}, because Julia will automatically compile specialized versions as needed. For example, the first time you call \texttt{addone(12)}, Julia will automatically compile a specialized \texttt{addone} function for \texttt{x::Int} arguments, with the call to \texttt{oneunit} replaced by its inlined value \texttt{1}. Therefore, the first three definitions of \texttt{addone} above are completely redundant with the fourth definition.



\hypertarget{7939603283413938233}{}


\section{Handle excess argument diversity in the caller}



Instead of:




\begin{minted}{julia}
function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)
\end{minted}



use:




\begin{minted}{julia}
function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))
\end{minted}



This is better style because \texttt{foo} does not really accept numbers of all types; it really needs \texttt{Int} s.



One issue here is that if a function inherently requires integers, it might be better to force the caller to decide how non-integers should be converted (e.g. floor or ceiling). Another issue is that declaring more specific types leaves more {\textquotedbl}space{\textquotedbl} for future method definitions.



\hypertarget{5069960220419336034}{}


\section{Append \texttt{!} to names of functions that modify their arguments}



Instead of:




\begin{minted}{julia}
function double(a::AbstractArray{<:Number})
    for i = 1:endof(a)
        a[i] *= 2
    end
    return a
end
\end{minted}



use:




\begin{minted}{julia}
function double!(a::AbstractArray{<:Number})
    for i = 1:endof(a)
        a[i] *= 2
    end
    return a
end
\end{minted}



The Julia standard library uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., \hyperlink{8473525809131227606}{\texttt{sort()}} and \hyperlink{12296873681374954808}{\texttt{sort!()}}), and others which are just modifying (e.g., \hyperlink{18026893834387542681}{\texttt{push!()}}, \hyperlink{8214834680518266248}{\texttt{pop!()}}, \hyperlink{13785507599688955371}{\texttt{splice!()}}).  It is typical for such functions to also return the modified array for convenience.



\hypertarget{10428813764890088659}{}


\section{Avoid strange type \texttt{Union}s}



Types such as \texttt{Union\{Function,AbstractString\}} are often a sign that some design could be cleaner.



\hypertarget{11801656383675029142}{}


\section{Avoid type Unions in fields}



When creating a type such as:




\begin{minted}{julia}
mutable struct MyType
    ...
    x::Union{Void,T}
end
\end{minted}



ask whether the option for \texttt{x} to be \texttt{nothing} (of type \texttt{Void}) is really necessary. Here are some alternatives to consider:



\begin{itemize}
\item Find a safe default value to initialize \texttt{x} with


\item Introduce another type that lacks \texttt{x}


\item If there are many fields like \texttt{x}, store them in a dictionary


\item Determine whether there is a simple rule for when \texttt{x} is \texttt{nothing}. For example, often the field will start as \texttt{nothing} but get initialized at some well-defined point. In that case, consider leaving it undefined at first.


\item If \texttt{x} really needs to hold no value at some times, define it as \texttt{::Nullable\{T\}} instead, as this guarantees type-stability in the code accessing this field (see \hyperlink{6093361083853962389}{Nullable types}).

\end{itemize}


\hypertarget{14603252271391913020}{}


\section{Avoid elaborate container types}



It is usually not much help to construct arrays like the following:




\begin{minted}{julia}
a = Array{Union{Int,AbstractString,Tuple,Array}}(n)
\end{minted}



In this case \texttt{Array\{Any\}(n)} is better. It is also more helpful to the compiler to annotate specific uses (e.g. \texttt{a[i]::Int}) than to try to pack many alternatives into one type.



\hypertarget{5379518548148345587}{}


\section{Use naming conventions consistent with Julia{\textquotesingle}s \texttt{base/}}



\begin{itemize}
\item modules and type names use capitalization and camel case: \texttt{module SparseArrays}, \texttt{struct UnitRange}.


\item functions are lowercase (\hyperlink{10566500735406837086}{\texttt{maximum()}}, \hyperlink{1846942650946171605}{\texttt{convert()}}) and, when readable, with multiple words squashed together (\hyperlink{12829995639916057841}{\texttt{isequal()}}, \hyperlink{16178429961779994033}{\texttt{haskey()}}). When necessary, use underscores as word separators. Underscores are also used to indicate a combination of concepts (\hyperlink{16429337757386989414}{\texttt{remotecall\_fetch()}} as a more efficient implementation of \texttt{fetch(remotecall(...))}) or as modifiers (\hyperlink{16119876305082002277}{\texttt{sum\_kbn()}}).


\item conciseness is valued, but avoid abbreviation (\hyperlink{16333903346703258373}{\texttt{indexin()}} rather than \texttt{indxin()}) as it becomes difficult to remember whether and how particular words are abbreviated.

\end{itemize}


If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.



\hypertarget{1647718431228063309}{}


\section{Don{\textquotesingle}t overuse try-catch}



It is better to avoid errors than to rely on catching them.



\hypertarget{17798039231548285745}{}


\section{Don{\textquotesingle}t parenthesize conditions}



Julia doesn{\textquotesingle}t require parens around conditions in \texttt{if} and \texttt{while}. Write:




\begin{minted}{julia}
if a == b
\end{minted}



instead of:




\begin{minted}{julia}
if (a == b)
\end{minted}



\hypertarget{14974037283324979251}{}


\section{Don{\textquotesingle}t overuse \texttt{...}}



Splicing function arguments can be addictive. Instead of \texttt{[a..., b...]}, use simply \texttt{[a; b]}, which already concatenates arrays. \hyperlink{6278865767444641812}{\texttt{collect(a)}} is better than \texttt{[a...]}, but since \texttt{a} is already iterable it is often even better to leave it alone, and not convert it to an array.



\hypertarget{10051740899027010685}{}


\section{Don{\textquotesingle}t use unnecessary static parameters}



A function signature:




\begin{minted}{julia}
foo(x::T) where {T<:Real} = ...
\end{minted}



should be written as:




\begin{minted}{julia}
foo(x::Real) = ...
\end{minted}



instead, especially if \texttt{T} is not used in the function body. Even if \texttt{T} is used, it can be replaced with \hyperlink{13440452181855594120}{\texttt{typeof(x)}} if convenient. There is no performance difference. Note that this is not a general caution against static parameters, just against uses where they are not needed.



Note also that container types, specifically may need type parameters in function calls. See the FAQ \hyperlink{595407961498030927}{Avoid fields with abstract containers} for more information.



\hypertarget{15290964794103571171}{}


\section{Avoid confusion about whether something is an instance or a type}



Sets of definitions like the following are confusing:




\begin{minted}{julia}
foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)
\end{minted}



Decide whether the concept in question will be written as \texttt{MyType} or \texttt{MyType()}, and stick to it.



The preferred style is to use instances by default, and only add methods involving \texttt{Type\{MyType\}} later if they become necessary to solve some problem.



If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the {\textquotedbl}values{\textquotedbl} as subtypes.



\hypertarget{12428976482555043721}{}


\section{Don{\textquotesingle}t overuse macros}



Be aware of when a macro could really be a function instead.



Calling \hyperlink{2345597220715550879}{\texttt{eval()}} inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs.



\hypertarget{636981573846719295}{}


\section{Don{\textquotesingle}t expose unsafe operations at the interface level}



If you have a type that uses a native pointer:




\begin{minted}{julia}
mutable struct NativeType
    p::Ptr{UInt8}
    ...
end
\end{minted}



don{\textquotesingle}t write definitions like the following:




\begin{minted}{julia}
getindex(x::NativeType, i) = unsafe_load(x.p, i)
\end{minted}



The problem is that users of this type can write \texttt{x[i]} without realizing that the operation is unsafe, and then be susceptible to memory bugs.



Such a function should either check the operation to ensure it is safe, or have \texttt{unsafe} somewhere in its name to alert callers.



\hypertarget{7776747104938186409}{}


\section{Don{\textquotesingle}t overload methods of base container types}



It is possible to write definitions like the following:




\begin{minted}{julia}
show(io::IO, v::Vector{MyType}) = ...
\end{minted}



This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like \texttt{Vector()} to behave in a certain way, and overly customizing its behavior can make it harder to work with.



\hypertarget{1175802074481431045}{}


\section{Avoid type piracy}



{\textquotedbl}Type piracy{\textquotedbl} refers to the practice of extending or redefining methods in Base or other packages on types that you have not defined. In some cases, you can get away with type piracy with little ill effect. In extreme cases, however, you can even crash Julia (e.g. if your method extension or redefinition causes invalid input to be passed to a \texttt{ccall}). Type piracy can complicate reasoning about code, and may introduce incompatibilities that are hard to predict and diagnose.



As an example, suppose you wanted to define multiplication on symbols in a module:




\begin{minted}{julia}
module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end
\end{minted}



The problem is that now any other module that uses \texttt{Base.*} will also see this definition. Since \texttt{Symbol} is defined in Base and is used by other modules, this can change the behavior of unrelated code unexpectedly. There are several alternatives here, including using a different function name, or wrapping the \texttt{Symbol}s in another type that you define.



Sometimes, coupled packages may engage in type piracy to separate features from definitions, especially when the packages were designed by collaborating authors, and when the definitions are reusable. For example, one package might provide some types useful for working with colors; another package could define methods for those types that enable conversions between color spaces. Another example might be a package that acts as a thin wrapper for some C code, which another package might then pirate to implement a higher-level, Julia-friendly API.



\hypertarget{4240422973127998789}{}


\section{Be careful with type equality}



You generally want to use \hyperlink{7066325108767373297}{\texttt{isa()}} and \texttt{<:} (\hyperlink{5954612615304731643}{\texttt{issubtype()}}) for testing types, not \texttt{==}. Checking types for exact equality typically only makes sense when comparing to a known concrete type (e.g. \texttt{T == Float64}), or if you \emph{really, really} know what you{\textquotesingle}re doing.



\hypertarget{13513867638142428691}{}


\section{Do not write \texttt{x->f(x)}}



Since higher-order functions are often called with anonymous functions, it is easy to conclude that this is desirable or even necessary. But any function can be passed directly, without being {\textquotedbl}wrapped{\textquotedbl} in an anonymous function. Instead of writing \texttt{map(x->f(x), a)}, write \hyperlink{11483231213869150535}{\texttt{map(f, a)}}.



\hypertarget{1845203369165848080}{}


\section{Avoid using floats for numeric literals in generic code when possible}



If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.



For example,




\begin{minted}{jlcon}
julia> f(x) = 2.0 * x
f (generic function with 1 method)

julia> f(1//2)
1.0

julia> f(1/2)
1.0

julia> f(1)
2.0
\end{minted}



while




\begin{minted}{jlcon}
julia> g(x) = 2 * x
g (generic function with 1 method)

julia> g(1//2)
1//1

julia> g(1/2)
1.0

julia> g(1)
2
\end{minted}



As you can see, the second version, where we used an \texttt{Int} literal, preserved the type of the input argument, while the first didn{\textquotesingle}t. This is because e.g. \texttt{promote\_type(Int, Float64) == Float64}, and promotion happens with the multiplication. Similarly, \hyperlink{8304566144531167610}{\texttt{Rational}} literals are less type disruptive than \hyperlink{5027751419500983000}{\texttt{Float64}} literals, but more disruptive than \texttt{Int}s:




\begin{minted}{jlcon}
julia> h(x) = 2//1 * x
h (generic function with 1 method)

julia> h(1//2)
1//1

julia> h(1/2)
1.0

julia> h(1)
2//1
\end{minted}



Thus, use \texttt{Int} literals when possible, with \texttt{Rational\{Int\}} for literal non-integer numbers, in order to make it easier to use your code.



\hypertarget{2735091372912754285}{}


\chapter{Frequently Asked Questions}



\hypertarget{6346532337786246456}{}


\section{Sessions and the REPL}



\hypertarget{10305692387204937900}{}


\subsection{How do I delete an object in memory?}



Julia does not have an analog of MATLAB{\textquotesingle}s \texttt{clear} function; once a name is defined in a Julia session (technically, in module \texttt{Main}), it is always present.



If memory usage is your concern, you can always replace objects with ones that consume less memory.  For example, if \texttt{A} is a gigabyte-sized array that you no longer need, you can free the memory with \texttt{A = 0}.  The memory will be released the next time the garbage collector runs; you can force this to happen with \hyperlink{13037394137368605126}{\texttt{gc()}}.



\hypertarget{2409321909107091733}{}


\subsection{How can I modify the declaration of a type in my session?}



Perhaps you{\textquotesingle}ve defined a type and then realize you need to add a new field.  If you try this at the REPL, you get the error:




\begin{lstlisting}
ERROR: invalid redefinition of constant MyType
\end{lstlisting}



Types in module \texttt{Main} cannot be redefined.



While this can be inconvenient when you are developing new code, there{\textquotesingle}s an excellent workaround.  Modules can be replaced by redefining them, and so if you wrap all your new code inside a module you can redefine types and constants.  You can{\textquotesingle}t import the type names into \texttt{Main} and then expect to be able to redefine them there, but you can use the module name to resolve the scope.  In other words, while developing you might use a workflow something like this:




\begin{minted}{julia}
include("mynewcode.jl")              # this defines a module MyModule
obj1 = MyModule.ObjConstructor(a, b)
obj2 = MyModule.somefunction(obj1)
# Got an error. Change something in "mynewcode.jl"
include("mynewcode.jl")              # reload the module
obj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct
obj2 = MyModule.somefunction(obj1)   # this time it worked!
obj3 = MyModule.someotherfunction(obj2, c)
...
\end{minted}



\hypertarget{1675991399371562561}{}


\section{Functions}



\hypertarget{12855086270323701749}{}


\subsection{I passed an argument \texttt{x} to a function, modified it inside that function, but on the outside,}



the variable \texttt{x} is still unchanged. Why?



Suppose you call a function like this:




\begin{minted}{jlcon}
julia> x = 10
10

julia> function change_value!(y)
           y = 17
       end
change_value! (generic function with 1 method)

julia> change_value!(x)
17

julia> x # x is unchanged!
10
\end{minted}



In Julia, the binding of a variable \texttt{x} cannot be changed by passing \texttt{x} as an argument to a function. When calling \texttt{change\_value!(x)} in the above example, \texttt{y} is a newly created variable, bound initially to the value of \texttt{x}, i.e. \texttt{10}; then \texttt{y} is rebound to the constant \texttt{17}, while the variable \texttt{x} of the outer scope is left untouched.



But here is a thing you should pay attention to: suppose \texttt{x} is bound to an object of type \texttt{Array} (or any other \emph{mutable} type). From within the function, you cannot {\textquotedbl}unbind{\textquotedbl} \texttt{x} from this Array, but you can change its content. For example:




\begin{minted}{jlcon}
julia> x = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> function change_array!(A)
           A[1] = 5
       end
change_array! (generic function with 1 method)

julia> change_array!(x)
5

julia> x
3-element Array{Int64,1}:
 5
 2
 3
\end{minted}



Here we created a function \texttt{change\_array!()}, that assigns \texttt{5} to the first element of the passed array (bound to \texttt{x} at the call site, and bound to \texttt{A} within the function). Notice that, after the function call, \texttt{x} is still bound to the same array, but the content of that array changed: the variables \texttt{A} and \texttt{x} were distinct bindings refering to the same mutable \texttt{Array} object.



\hypertarget{1083374634946363107}{}


\subsection{Can I use \texttt{using} or \texttt{import} inside a function?}



No, you are not allowed to have a \texttt{using} or \texttt{import} statement inside a function.  If you want to import a module but only use its symbols inside a specific function or set of functions, you have two options:



\begin{itemize}
\item[1. ] Use \texttt{import}:


\begin{minted}{julia}
import Foo
function bar(...)
    # ... refer to Foo symbols via Foo.baz ...
end
\end{minted}

This loads the module \texttt{Foo} and defines a variable \texttt{Foo} that refers to the module, but does not import any of the other symbols from the module into the current namespace.  You refer to the \texttt{Foo} symbols by their qualified names \texttt{Foo.bar} etc.


\item[2. ] Wrap your function in a module:


\begin{minted}{julia}
module Bar
export bar
using Foo
function bar(...)
    # ... refer to Foo.baz as simply baz ....
end
end
using Bar
\end{minted}

This imports all the symbols from \texttt{Foo}, but only inside the module \texttt{Bar}.

\end{itemize}


\hypertarget{12294034902075429755}{}


\subsection{What does the \texttt{...} operator do?}



\hypertarget{13127773043618399697}{}


\subsection{The two uses of the \texttt{...} operator: slurping and splatting}



Many newcomers to Julia find the use of \texttt{...} operator confusing. Part of what makes the \texttt{...} operator confusing is that it means two different things depending on context.



\hypertarget{6000213923717698457}{}


\subsection{\texttt{...} combines many arguments into one argument in function definitions}



In the context of function definitions, the \texttt{...} operator is used to combine many different arguments into a single argument. This use of \texttt{...} for combining many different arguments into a single argument is called slurping:




\begin{minted}{jlcon}
julia> function printargs(args...)
           @printf("%s\n", typeof(args))
           for (i, arg) in enumerate(args)
               @printf("Arg %d = %s\n", i, arg)
           end
       end
printargs (generic function with 1 method)

julia> printargs(1, 2, 3)
Tuple{Int64,Int64,Int64}
Arg 1 = 1
Arg 2 = 2
Arg 3 = 3
\end{minted}



If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as \texttt{<-...} instead of \texttt{...}.



\hypertarget{18215777153354710149}{}


\subsection{\texttt{...} splits one argument into many different arguments in function calls}



In contrast to the use of the \texttt{...} operator to denote slurping many different arguments into one argument when defining a function, the \texttt{...} operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of \texttt{...} is called splatting:




\begin{minted}{jlcon}
julia> function threeargs(a, b, c)
           @printf("a = %s::%s\n", a, typeof(a))
           @printf("b = %s::%s\n", b, typeof(b))
           @printf("c = %s::%s\n", c, typeof(c))
       end
threeargs (generic function with 1 method)

julia> vec = [1, 2, 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> threeargs(vec...)
a = 1::Int64
b = 2::Int64
c = 3::Int64
\end{minted}



If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as \texttt{...->} instead of \texttt{...}.



\hypertarget{13169720538693416930}{}


\section{Types, type declarations, and constructors}



\hypertarget{11170875837665758023}{}


\subsection{What does {\textquotedbl}type-stable{\textquotedbl} mean?}



It means that the type of the output is predictable from the types of the inputs.  In particular, it means that the type of the output cannot vary depending on the \emph{values} of the inputs. The following code is \emph{not} type-stable:




\begin{minted}{jlcon}
julia> function unstable(flag::Bool)
           if flag
               return 1
           else
               return 1.0
           end
       end
unstable (generic function with 1 method)
\end{minted}



It returns either an \texttt{Int} or a \hyperlink{5027751419500983000}{\texttt{Float64}} depending on the value of its argument. Since Julia can{\textquotesingle}t predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.



\hypertarget{6904365807459053438}{}


\subsection{Why does Julia give a \texttt{DomainError} for certain seemingly-sensible operations?}



Certain operations make mathematical sense but result in errors:




\begin{minted}{jlcon}
julia> sqrt(-2.0)
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Float64) at ./math.jl:425

julia> 2^-5
ERROR: DomainError:
Cannot raise an integer x to a negative power -n.
Make x a float by adding a zero decimal (e.g. 2.0^-n instead of 2^-n), or write 1/x^n, float(x)^-n, or (x//1)^-n.
Stacktrace:
 [1] power_by_squaring(::Int64, ::Int64) at ./intfuncs.jl:173
 [2] literal_pow(::Base.#^, ::Int64, ::Type{Val{-5}}) at ./intfuncs.jl:208
\end{minted}



This behavior is an inconvenient consequence of the requirement for type-stability.  In the case of \hyperlink{4178506499510800909}{\texttt{sqrt()}}, most users want \texttt{sqrt(2.0)} to give a real number, and would be unhappy if it produced the complex number \texttt{1.4142135623730951 + 0.0im}.  One could write the \hyperlink{4178506499510800909}{\texttt{sqrt()}} function to switch to a complex-valued output only when passed a negative number (which is what \hyperlink{4178506499510800909}{\texttt{sqrt()}} does in some other languages), but then the result would not be \hyperlink{11170875837665758023}{type-stable} and the \hyperlink{4178506499510800909}{\texttt{sqrt()}} function would have poor performance.



In these and other cases, you can get the result you want by choosing an \emph{input type} that conveys your willingness to accept an \emph{output type} in which the result can be represented:




\begin{minted}{jlcon}
julia> sqrt(-2.0+0im)
0.0 + 1.4142135623730951im

julia> 2.0^-5
0.03125
\end{minted}



\hypertarget{15697426267824518488}{}


\subsection{Why does Julia use native machine integer arithmetic?}



Julia uses machine arithmetic for integer computations. This means that the range of \texttt{Int} values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:




\begin{minted}{jlcon}
julia> typemax(Int)
9223372036854775807

julia> ans+1
-9223372036854775808

julia> -ans
-9223372036854775808

julia> 2*ans
0
\end{minted}



Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.



One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as \hyperlink{8012327724714767060}{\texttt{Int128}} or \hyperlink{423405808990690832}{\texttt{BigInt}} in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) – it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, \hyperlink{11170875837665758023}{type-stability is crucial} for effective generation of efficient code. If you can{\textquotesingle}t count on the results of integer operations being integers, it{\textquotesingle}s impossible to generate fast, simple code the way C and Fortran compilers do.



A variation on this approach, which avoids the appearance of type instability is to merge the \texttt{Int} and \hyperlink{423405808990690832}{\texttt{BigInt}} types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach \emph{can} be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots – large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps – situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.



An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab™ does:




\begin{lstlisting}
>> int64(9223372036854775807)

ans =

  9223372036854775807

>> int64(9223372036854775807) + 1

ans =

  9223372036854775807

>> int64(-9223372036854775808)

ans =

 -9223372036854775808

>> int64(-9223372036854775808) - 1

ans =

 -9223372036854775808
\end{lstlisting}



At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with \hyperlink{3613894539247233488}{\texttt{typemin(Int)}} or \hyperlink{17760305803764597758}{\texttt{typemax(Int)}} as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse – saturating integer arithmetic isn{\textquotesingle}t associative. Consider this Matlab computation:




\begin{lstlisting}
>> n = int64(2)^62
4611686018427387904

>> n + (n - 1)
9223372036854775807

>> (n + n) - 1
9223372036854775806
\end{lstlisting}



This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow \emph{is} associative. Consider finding the midpoint between integer values \texttt{lo} and \texttt{hi} in Julia using the expression \texttt{(lo + hi) >>> 1}:




\begin{minted}{jlcon}
julia> n = 2^62
4611686018427387904

julia> (n + 2n) >>> 1
6917529027641081856
\end{minted}



See? No problem. That{\textquotesingle}s the correct midpoint between 2{\textasciicircum}62 and 2{\textasciicircum}63, despite the fact that \texttt{n + 2n} is -4611686018427387904. Now try it in Matlab:




\begin{lstlisting}
>> (n + 2*n)/2

ans =

  4611686018427387904
\end{lstlisting}



Oops. Adding a \texttt{>>>} operator to Matlab wouldn{\textquotesingle}t help, because saturation that occurs when adding \texttt{n} and \texttt{2n} has already destroyed the information necessary to compute the correct midpoint.



Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions like \texttt{f(k) = 5k-1}. The machine code for this function is just this:




\begin{minted}{jlcon}
julia> code_native(f, Tuple{Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 1
  leaq  -1(%rdi,%rdi,4), %rax
  popq  %rbp
  retq
  nopl  (%rax,%rax)
\end{minted}



The actual body of the function is a single \texttt{leaq} instruction, which computes the integer multiply and add at once. This is even more beneficial when \texttt{f} gets inlined into another function:




\begin{minted}{jlcon}
julia> function g(k, n)
           for i = 1:n
               k = f(k)
           end
           return k
       end
g (generic function with 1 methods)

julia> code_native(g, Tuple{Int,Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 2
  testq %rsi, %rsi
  jle L26
  nopl  (%rax)
Source line: 3
L16:
  leaq  -1(%rdi,%rdi,4), %rdi
Source line: 2
  decq  %rsi
  jne L16
Source line: 5
L26:
  movq  %rdi, %rax
  popq  %rbp
  retq
  nop
\end{minted}



Since the call to \texttt{f} gets inlined, the loop body ends up being just a single \texttt{leaq} instruction. Next, consider what happens if we make the number of loop iterations fixed:




\begin{minted}{jlcon}
julia> function g(k)
           for i = 1:10
               k = f(k)
           end
           return k
       end
g (generic function with 2 methods)

julia> code_native(g,(Int,))
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 3
  imulq $9765625, %rdi, %rax    # imm = 0x9502F9
  addq  $-2441406, %rax         # imm = 0xFFDABF42
Source line: 5
  popq  %rbp
  retq
  nopw  %cs:(%rax,%rax)
\end{minted}



Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition – neither of which is true of saturating arithmetic – it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.



The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this \href{http://danluu.com/integer-overflow/}{blog post}, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.



\hypertarget{12379471796822806857}{}


\subsection{What are the possible causes of an \texttt{UndefVarError} during remote execution?}



As the error states, an immediate cause of an \texttt{UndefVarError} on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.




\begin{minted}{jlcon}
julia> module Foo
           foo() = remotecall_fetch(x->x, 2, "Hello")
       end

julia> Foo.foo()
ERROR: On worker 2:
UndefVarError: Foo not defined
[...]
\end{minted}



The closure \texttt{x->x} carries a reference to \texttt{Foo}, and since \texttt{Foo} is unavailable on node 2, an \texttt{UndefVarError} is thrown.



Globals under modules other than \texttt{Main} are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under \texttt{Main}) may cause an \texttt{UndefVarError} to be thrown later.




\begin{minted}{jlcon}
julia> @everywhere module Foo
           function foo()
               global gvar = "Hello"
               remotecall_fetch(()->gvar, 2)
           end
       end

julia> Foo.foo()
ERROR: On worker 2:
UndefVarError: gvar not defined
[...]
\end{minted}



In the above example, \texttt{@everywhere module Foo} defined \texttt{Foo} on all nodes. However the call to \texttt{Foo.foo()} created a new global binding \texttt{gvar} on the local node, but this was not found on node 2 resulting in an \texttt{UndefVarError} error.



Note that this does not apply to globals created under module \texttt{Main}. Globals under module \texttt{Main} are serialized and new bindings created under \texttt{Main} on the remote node.




\begin{minted}{jlcon}
julia> gvar_self = "Node1"
"Node1"

julia> remotecall_fetch(()->gvar_self, 2)
"Node1"

julia> remotecall_fetch(whos, 2)
	From worker 2:	                          Base  41762 KB     Module
	From worker 2:	                          Core  27337 KB     Module
	From worker 2:	                           Foo   2477 bytes  Module
	From worker 2:	                          Main  46191 KB     Module
	From worker 2:	                     gvar_self     13 bytes  String
\end{minted}



This does not apply to \texttt{function} or \texttt{type} declarations. However, anonymous functions bound to global variables are serialized as can be seen below.




\begin{minted}{jlcon}
julia> bar() = 1
bar (generic function with 1 method)

julia> remotecall_fetch(bar, 2)
ERROR: On worker 2:
UndefVarError: #bar not defined
[...]

julia> anon_bar  = ()->1
(::#21) (generic function with 1 method)

julia> remotecall_fetch(anon_bar, 2)
1
\end{minted}



\hypertarget{9055376787547294791}{}


\section{Packages and Modules}



\hypertarget{2987319322833292835}{}


\subsection{What is the difference between {\textquotedbl}using{\textquotedbl} and {\textquotedbl}importall{\textquotedbl}?}



There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between \texttt{using} and \texttt{importall} is that with \texttt{using} you need to say \texttt{function Foo.bar(..} to extend module Foo{\textquotesingle}s function bar with a new method, but with \texttt{importall} or \texttt{import Foo.bar}, you only need to say \texttt{function bar(...} and it automatically extends module Foo{\textquotesingle}s function bar.



If you use \texttt{importall}, then \texttt{function Foo.bar(...} and \texttt{function bar(...} become equivalent. If you use \texttt{using}, then they are different.



The reason this is important enough to have been given separate syntax is that you don{\textquotesingle}t want to accidentally extend a function that you didn{\textquotesingle}t know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use \texttt{importall}, then you{\textquotesingle}ll replace the other module{\textquotesingle}s implementation of \texttt{bar(s::AbstractString)} with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).



\hypertarget{259296306383383012}{}


\section{Nothingness and missing values}



\hypertarget{12770241465913898525}{}


\subsection{How does {\textquotedbl}null{\textquotedbl} or {\textquotedbl}nothingness{\textquotedbl} work in Julia?}



Unlike many languages (for example, C and Java), Julia does not have a {\textquotedbl}null{\textquotedbl} value. When a reference (variable, object field, or array element) is uninitialized, accessing it will immediately throw an error. This situation can be detected using the \texttt{isdefined} function.



Some functions are used only for their side effects, and do not need to return a value. In these cases, the convention is to return the value \texttt{nothing}, which is just a singleton object of type \texttt{Void}. This is an ordinary type with no fields; there is nothing special about it except for this convention, and that the REPL does not print anything for it. Some language constructs that would not otherwise have a value also yield \texttt{nothing}, for example \texttt{if false; end}.



For situations where a value exists only sometimes (for example, missing statistical data), it is best to use the \texttt{Nullable\{T\}} type, which allows specifying the type of a missing value.



The empty tuple (\texttt{()}) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.



In code written for Julia prior to version 0.4 you may occasionally see \texttt{None}, which is quite different. It is the empty (or {\textquotedbl}bottom{\textquotedbl}) type, a type with no values and no subtypes (except itself). This is now written as \texttt{Union\{\}} (an empty union type). You will generally not need to use this type.



\hypertarget{3259018490286985422}{}


\section{Memory}



\hypertarget{11679692065584506902}{}


\subsection{Why does \texttt{x += y} allocate memory when \texttt{x} and \texttt{y} are arrays?}



In Julia, \texttt{x += y} gets replaced during parsing by \texttt{x = x + y}. For arrays, this has the consequence that, rather than storing the result in the same location in memory as \texttt{x}, it allocates a new array to store the result.



While this behavior might surprise some, the choice is deliberate. The main reason is the presence of immutable objects within Julia, which cannot change their value once created.  Indeed, a number is an immutable object; the statements \texttt{x = 5; x += 1} do not modify the meaning of \texttt{5}, they modify the value bound to \texttt{x}. For an immutable, the only way to change the value is to reassign it.



To amplify a bit further, consider the following function:




\begin{minted}{julia}
function power_by_squaring(x, n::Int)
    ispow2(n) || error("This implementation only works for powers of 2")
    while n >= 2
        x *= x
        n >>= 1
    end
    x
end
\end{minted}



After a call like \texttt{x = 5; y = power\_by\_squaring(x, 4)}, you would get the expected result: \texttt{x == 5 \&\& y == 625}.  However, now suppose that \texttt{*=}, when used with matrices, instead mutated the left hand side.  There would be two problems:



\begin{itemize}
\item For general square matrices, \texttt{A = A*B} cannot be implemented without temporary storage: \texttt{A[1,1]} gets computed and stored on the left hand side before you{\textquotesingle}re done using it on the right hand side.


\item Suppose you were willing to allocate a temporary for the computation (which would eliminate most of the point of making \texttt{*=} work in-place); if you took advantage of the mutability of \texttt{x}, then this function would behave differently for mutable vs. immutable inputs. In particular, for immutable \texttt{x}, after the call you{\textquotesingle}d have (in general) \texttt{y != x}, but for mutable \texttt{x} you{\textquotesingle}d have \texttt{y == x}.

\end{itemize}


Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like \texttt{+=} and \texttt{*=} work by rebinding new values.



\hypertarget{2869294219122234478}{}


\section{Asynchronous IO and concurrent synchronous writes}



\hypertarget{8021601646076660276}{}


\subsection{Why do concurrent writes to the same stream result in inter-mixed output?}



While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.



Consider the printed output from the following:




\begin{minted}{jlcon}
julia> @sync for i in 1:3
           @async write(STDOUT, string(i), " Foo ", " Bar ")
       end
123 Foo  Foo  Foo  Bar  Bar  Bar
\end{minted}



This is happening because, while the \texttt{write} call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.



\texttt{print} and \texttt{println} {\textquotedbl}lock{\textquotedbl} the stream during a call. Consequently changing \texttt{write} to \texttt{println} in the above example results in:




\begin{minted}{jlcon}
julia> @sync for i in 1:3
           @async println(STDOUT, string(i), " Foo ", " Bar ")
       end
1 Foo  Bar
2 Foo  Bar
3 Foo  Bar
\end{minted}



You can lock your writes with a \texttt{ReentrantLock} like this:




\begin{minted}{jlcon}
julia> l = ReentrantLock()
ReentrantLock(Nullable{Task}(), Condition(Any[]), 0)

julia> @sync for i in 1:3
           @async begin
               lock(l)
               try
                   write(STDOUT, string(i), " Foo ", " Bar ")
               finally
                   unlock(l)
               end
           end
       end
1 Foo  Bar 2 Foo  Bar 3 Foo  Bar
\end{minted}



\hypertarget{11890167907781042305}{}


\section{Julia Releases}



\hypertarget{5265282656824289674}{}


\subsection{Do I want to use a release, beta, or nightly version of Julia?}



You may prefer the release version of Julia if you are looking for a stable code base. Releases generally occur every 6 months, giving you a stable platform for writing code.



You may prefer the beta version of Julia if you don{\textquotesingle}t mind being slightly behind the latest bugfixes and changes, but find the slightly faster rate of changes more appealing. Additionally, these binaries are tested before they are published to ensure they are fully functional.



You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don{\textquotesingle}t mind if the version available today occasionally doesn{\textquotesingle}t actually work.



Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our \href{https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md}{guidelines for contributing}.



Links to each of these download types can be found on the download page at \href{https://julialang.org/downloads/}{https://julialang.org/downloads/}. Note that not all versions of Julia are available for all platforms.



\hypertarget{14356999914957430359}{}


\subsection{When are deprecated functions removed?}



Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release.



\hypertarget{16083606765476288441}{}


\chapter{Noteworthy Differences from other Languages}



\hypertarget{12239763473214700690}{}


\section{Noteworthy differences from MATLAB}



Although MATLAB users may find Julia{\textquotesingle}s syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:



\begin{itemize}
\item Julia arrays are indexed with square brackets, \texttt{A[i,j]}.


\item Julia arrays are assigned by reference. After \texttt{A=B}, changing elements of \texttt{B} will modify \texttt{A} as well.


\item Julia values are passed and assigned by reference. If a function modifies an array, the changes will be visible in the caller.


\item Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB \texttt{a(4) = 3.2} can create the array \texttt{a = [0 0 0 3.2]} and \texttt{a(5) = 7} can grow it into \texttt{a = [0 0 0 3.2 7]}, the corresponding Julia statement \texttt{a[5] = 7} throws an error if the length of \texttt{a} is less than 5 or if this statement is the first use of the identifier \texttt{a}. Julia has \hyperlink{18026893834387542681}{\texttt{push!()}} and \hyperlink{2587432243763606566}{\texttt{append!()}}, which grow \texttt{Vector}s much more efficiently than MATLAB{\textquotesingle}s \texttt{a(end+1) = val}.


\item The imaginary unit \texttt{sqrt(-1)} is represented in Julia as \hyperlink{15097910740298861288}{\texttt{im}}, not \texttt{i} or \texttt{j} as in MATLAB.


\item In Julia, literal numbers without a decimal point (such as \texttt{42}) create integers instead of floating point numbers. Arbitrarily large integer literals are supported. As a result, some operations such as \texttt{2{\textasciicircum}-1} will throw a domain error as the result is not an integer (see \hyperlink{6904365807459053438}{the FAQ entry on domain errors} for details).


\item In Julia, multiple values are returned and assigned as tuples, e.g. \texttt{(a, b) = (1, 2)} or \texttt{a, b = 1, 2}. MATLAB{\textquotesingle}s \texttt{nargout}, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.


\item Julia has true one-dimensional arrays. Column vectors are of size \texttt{N}, not \texttt{Nx1}. For example, \hyperlink{791894090820620170}{\texttt{rand(N)}} makes a 1-dimensional array.


\item In Julia, \texttt{[x,y,z]} will always construct a 3-element array containing \texttt{x}, \texttt{y} and \texttt{z}.

\begin{itemize}
\item To concatenate in the first ({\textquotedbl}vertical{\textquotedbl}) dimension use either \hyperlink{14691815416955507876}{\texttt{vcat(x,y,z)}} or separate with semicolons (\texttt{[x; y; z]}).


\item To concatenate in the second ({\textquotedbl}horizontal{\textquotedbl}) dimension use either \hyperlink{8862791894748483563}{\texttt{hcat(x,y,z)}} or separate with spaces (\texttt{[x y z]}).


\item To construct block matrices (concatenating in the first two dimensions), use either \hyperlink{16279083053557795116}{\texttt{hvcat()}} or combine spaces and semicolons (\texttt{[a b; c d]}).

\end{itemize}

\item In Julia, \texttt{a:b} and \texttt{a:b:c} construct \texttt{Range} objects. To construct a full vector like in MATLAB, use \hyperlink{6278865767444641812}{\texttt{collect(a:b)}}. Generally, there is no need to call \texttt{collect} though. \texttt{Range} will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as \hyperlink{11519832570242386196}{\texttt{linspace}}, or with iterators such as \texttt{enumerate}, and \texttt{zip}. The special objects can mostly be used as if they were normal arrays.


\item Functions in Julia return values from their last expression or the \texttt{return} keyword instead of listing the names of variables to return in the function definition (see \hyperlink{1093175794875601028}{The return Keyword} for details).


\item A Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.


\item In Julia, reductions such as \hyperlink{8666686648688281595}{\texttt{sum()}}, \hyperlink{13484084847910116333}{\texttt{prod()}}, and \hyperlink{7839419811914289844}{\texttt{max()}} are performed over every element of an array when called with a single argument, as in \texttt{sum(A)}, even if \texttt{A} has more than one dimension.


\item In Julia, functions such as \hyperlink{8473525809131227606}{\texttt{sort()}} that operate column-wise by default (\texttt{sort(A)} is equivalent to \texttt{sort(A,1)}) do not have special behavior for \texttt{1xN} arrays; the argument is returned unmodified since it still performs \texttt{sort(A,1)}. To sort a \texttt{1xN} matrix like a vector, use \texttt{sort(A,2)}.


\item In Julia, if \texttt{A} is a 2-dimensional array, \texttt{fft(A)} computes a 2D FFT. In particular, it is not equivalent to \texttt{fft(A,1)}, which computes a 1D FFT acting column-wise.


\item In Julia, parentheses must be used to call a function with zero arguments, like in \hyperlink{15143202356224875278}{\texttt{tic()}} and \hyperlink{16488371574475401451}{\texttt{toc()}}.


\item Julia discourages the used of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. \hyperlink{783803254548423222}{\texttt{println()}} or \hyperlink{4087473154660177488}{\texttt{@printf()}} can be used to print specific output.


\item In Julia, if \texttt{A} and \texttt{B} are arrays, logical comparison operations like \texttt{A == B} do not return an array of booleans. Instead, use \texttt{A .== B}, and similarly for the other boolean operators like \hyperlink{702782232449268329}{\texttt{<}}, \hyperlink{8677991761303191103}{\texttt{>}} and \texttt{=}.


\item In Julia, the operators \hyperlink{1494761116451616317}{\texttt{\&}}, \hyperlink{9633687763646488853}{\texttt{|}}, and \hyperlink{7071880015536674935}{\texttt{⊻}} (\hyperlink{7071880015536674935}{\texttt{xor}}) perform the bitwise operations equivalent to \texttt{and}, \texttt{or}, and \texttt{xor} respectively in MATLAB, and have precedence similar to Python{\textquotesingle}s bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of \texttt{A} equal to 1 or 2 use \texttt{(A .== 1) | (A .== 2)}).


\item In Julia, the elements of a collection can be passed as arguments to a function using the splat operator \texttt{...}, as in \texttt{xs=[1,2]; f(xs...)}.


\item Julia{\textquotesingle}s \hyperlink{14775973623414930183}{\texttt{svd()}} returns singular values as a vector instead of as a dense diagonal matrix.


\item In Julia, \texttt{...} is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.


\item In both Julia and MATLAB, the variable \texttt{ans} is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, \texttt{ans} is not set when Julia code is run in non-interactive mode.


\item Julia{\textquotesingle}s \texttt{type}s do not support dynamically adding fields at runtime, unlike MATLAB{\textquotesingle}s \texttt{class}es. Instead, use a \hyperlink{3089397136845322041}{\texttt{Dict}}.


\item In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.


\item In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression \texttt{x(x>3)} or in the statement \texttt{x(x>3) = []} to modify \texttt{x} in-place. In contrast, Julia provides the higher order functions \hyperlink{11445961893478569145}{\texttt{filter()}} and \hyperlink{3384092630307389071}{\texttt{filter!()}}, allowing users to write \texttt{filter(z->z>3, x)} and \texttt{filter!(z->z>3, x)} as alternatives to the corresponding transliterations \texttt{x[x.>3]} and \texttt{x = x[x.>3]}. Using \hyperlink{3384092630307389071}{\texttt{filter!()}} reduces the use of temporary arrays.


\item The analogue of extracting (or {\textquotedbl}dereferencing{\textquotedbl}) all elements of a cell array, e.g. in \texttt{vertcat(A\{:\})} in MATLAB, is written using the splat operator in Julia, e.g. as \texttt{vcat(A...)}.

\end{itemize}


\hypertarget{2824295160422151139}{}


\section{Noteworthy differences from R}



One of Julia{\textquotesingle}s goals is to provide an effective language for data analysis and statistical programming. For users coming to Julia from R, these are some noteworthy differences:



\begin{itemize}
\item Julia{\textquotesingle}s single quotes enclose characters, not strings.


\item Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.


\item In Julia, like Python but unlike R, strings can be created with triple quotes \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl} ... {\textquotedbl}{\textquotedbl}{\textquotedbl}}. This syntax is convenient for constructing strings that contain line breaks.


\item In Julia, varargs are specified using the splat operator \texttt{...}, which always follows the name of a specific variable, unlike R, for which \texttt{...} can occur in isolation.


\item In Julia, modulus is \texttt{mod(a, b)}, not \texttt{a \%\% b}. \texttt{\%} in Julia is the remainder operator.


\item In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:

\begin{itemize}
\item In R, \texttt{c(1, 2, 3, 4)[c(TRUE, FALSE)]} is equivalent to \texttt{c(1, 3)}.


\item In R, \texttt{c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]} is equivalent to \texttt{c(1, 3)}.


\item In Julia, \texttt{[1, 2, 3, 4][[true, false]]} throws a \hyperlink{9731558909100893938}{\texttt{BoundsError}}.


\item In Julia, \texttt{[1, 2, 3, 4][[true, false, true, false]]} produces \texttt{[1, 3]}.

\end{itemize}

\item Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range.  For example, \texttt{c(1, 2, 3, 4) + c(1, 2)} is valid R but the equivalent \texttt{[1, 2, 3, 4] + [1, 2]} will throw an error in Julia.


\item Julia{\textquotesingle}s \hyperlink{11483231213869150535}{\texttt{map()}} takes the function first, then its arguments, unlike \texttt{lapply(<structure>, function, ...)} in R. Similarly Julia{\textquotesingle}s equivalent of \texttt{apply(X, MARGIN, FUN, ...)} in R is \hyperlink{8678396932318499078}{\texttt{mapslices()}} where the function is the first argument.


\item Multivariate apply in R, e.g. \texttt{mapply(choose, 11:13, 1:3)}, can be written as \texttt{broadcast(binomial, 11:13, 1:3)} in Julia. Equivalently Julia offers a shorter dot syntax for vectorizing functions \texttt{binomial.(11:13, 1:3)}.


\item Julia uses \texttt{end} to denote the end of conditional blocks, like \texttt{if}, loop blocks, like \texttt{while}/ \texttt{for}, and functions. In lieu of the one-line \texttt{if ( cond ) statement}, Julia allows statements of the form \texttt{if cond; statement; end}, \texttt{cond \&\& statement} and \texttt{!cond || statement}. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. \texttt{cond \&\& (x = value)}.


\item In Julia, \texttt{<-}, \texttt{<<-} and \texttt{->} are not assignment operators.


\item Julia{\textquotesingle}s \texttt{->} creates an anonymous function, like Python.


\item Julia constructs vectors using brackets. Julia{\textquotesingle}s \texttt{[1, 2, 3]} is the equivalent of R{\textquotesingle}s \texttt{c(1, 2, 3)}.


\item Julia{\textquotesingle}s \hyperlink{8486205126068439173}{\texttt{*}} operator can perform matrix multiplication, unlike in R. If \texttt{A} and \texttt{B} are matrices, then \texttt{A * B} denotes a matrix multiplication in Julia, equivalent to R{\textquotesingle}s \texttt{A \%*\% B}. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write \texttt{A .* B} in Julia.


\item Julia performs matrix transposition using the \texttt{.{\textquotesingle}} operator and conjugated transposition using the \texttt{{\textquotesingle}} operator. Julia{\textquotesingle}s \texttt{A.{\textquotesingle}} is therefore equivalent to R{\textquotesingle}s \texttt{t(A)}.


\item Julia does not require parentheses when writing \texttt{if} statements or \texttt{for}/\texttt{while} loops: use \texttt{for i in [1, 2, 3]} instead of \texttt{for (i in c(1, 2, 3))} and \texttt{if i == 1} instead of \texttt{if (i == 1)}.


\item Julia does not treat the numbers \texttt{0} and \texttt{1} as Booleans. You cannot write \texttt{if (1)} in Julia, because \texttt{if} statements accept only booleans. Instead, you can write \texttt{if true}, \texttt{if Bool(1)}, or \texttt{if 1==1}.


\item Julia does not provide \texttt{nrow} and \texttt{ncol}. Instead, use \texttt{size(M, 1)} for \texttt{nrow(M)} and \texttt{size(M, 2)} for \texttt{ncol(M)}.


\item Julia is careful to distinguish scalars, vectors and matrices.  In R, \texttt{1} and \texttt{c(1)} are the same. In Julia, they cannot be used interchangeably.


\item Julia{\textquotesingle}s \hyperlink{6899395651203530298}{\texttt{diag}} and \hyperlink{8563936900334873682}{\texttt{diagm}} are not like R{\textquotesingle}s.


\item Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write \texttt{diag(M) = ones(n)}.


\item Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in \href{http://pkg.julialang.org/}{packages} under the \href{https://github.com/JuliaStats}{JuliaStats organization}. For example:

\begin{itemize}
\item Functions pertaining to probability distributions are provided by the \href{https://github.com/JuliaStats/Distributions.jl}{Distributions package}.


\item The \href{https://github.com/JuliaData/DataFrames.jl}{DataFrames package} provides data frames.


\item Generalized linear models are provided by the \href{https://github.com/JuliaStats/GLM.jl}{GLM package}.

\end{itemize}

\item Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple: instead of \texttt{list(a = 1, b = 2)}, use \texttt{(1, 2)}.


\item Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia{\textquotesingle}s multiple dispatch system means that \texttt{table(x::TypeA)} and \texttt{table(x::TypeB)} act like R{\textquotesingle}s \texttt{table.TypeA(x)} and \texttt{table.TypeB(x)}.


\item In Julia, values are passed and assigned by reference. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.


\item In Julia, vectors and matrices are concatenated using \hyperlink{8862791894748483563}{\texttt{hcat()}}, \hyperlink{14691815416955507876}{\texttt{vcat()}} and \hyperlink{16279083053557795116}{\texttt{hvcat()}}, not \texttt{c}, \texttt{rbind} and \texttt{cbind} like in R.


\item In Julia, a range like \texttt{a:b} is not shorthand for a vector like in R, but is a specialized \texttt{Range} that is used for iteration without high memory overhead. To convert a range into a vector, use \hyperlink{6278865767444641812}{\texttt{collect(a:b)}}.


\item Julia{\textquotesingle}s \hyperlink{7839419811914289844}{\texttt{max()}} and \hyperlink{7458766354532817148}{\texttt{min()}} are the equivalent of \texttt{pmax} and \texttt{pmin} respectively in R, but both arguments need to have the same dimensions.  While \hyperlink{10566500735406837086}{\texttt{maximum()}} and \hyperlink{5463833925251886106}{\texttt{minimum()}} replace \texttt{max} and \texttt{min} in R, there are important differences.


\item Julia{\textquotesingle}s \hyperlink{8666686648688281595}{\texttt{sum()}}, \hyperlink{13484084847910116333}{\texttt{prod()}}, \hyperlink{10566500735406837086}{\texttt{maximum()}}, and \hyperlink{5463833925251886106}{\texttt{minimum()}} are different from their counterparts in R. They all accept one or two arguments. The first argument is an iterable collection such as an array.  If there is a second argument, then this argument indicates the dimensions, over which the operation is carried out.  For instance, let \texttt{A=[[1 2],[3 4]]} in Julia and \texttt{B=rbind(c(1,2),c(3,4))} be the same matrix in R.  Then \texttt{sum(A)} gives the same result as \texttt{sum(B)}, but \texttt{sum(A, 1)} is a row vector containing the sum over each column and \texttt{sum(A, 2)} is a column vector containing the sum over each row.  This contrasts to the behavior of R, where \texttt{sum(B,1)=11} and \texttt{sum(B,2)=12}.  If the second argument is a vector, then it specifies all the dimensions over which the sum is performed, e.g., \texttt{sum(A,[1,2])=10}.  It should be noted that there is no error checking regarding the second argument.


\item Julia has several functions that can mutate their arguments. For example, it has both \hyperlink{8473525809131227606}{\texttt{sort()}} and \hyperlink{12296873681374954808}{\texttt{sort!()}}.


\item In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.


\item Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.


\item Julia does not support the \texttt{NULL} type.


\item Julia lacks the equivalent of R{\textquotesingle}s \texttt{assign} or \texttt{get}.


\item In Julia, \texttt{return} does not require parentheses.


\item In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression \texttt{x[x>3]} or in the statement \texttt{x = x[x>3]} to modify \texttt{x} in-place. In contrast, Julia provides the higher order functions \hyperlink{11445961893478569145}{\texttt{filter()}} and \hyperlink{3384092630307389071}{\texttt{filter!()}}, allowing users to write \texttt{filter(z->z>3, x)} and \texttt{filter!(z->z>3, x)} as alternatives to the corresponding transliterations \texttt{x[x.>3]} and \texttt{x = x[x.>3]}. Using \hyperlink{3384092630307389071}{\texttt{filter!()}} reduces the use of temporary arrays.

\end{itemize}


\hypertarget{17575785050737161441}{}


\section{Noteworthy differences from Python}



\begin{itemize}
\item Julia requires \texttt{end} to end a block. Unlike Python, Julia has no \texttt{pass} keyword.


\item In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.


\item Julia{\textquotesingle}s slice indexing includes the last element, unlike in Python. \texttt{a[2:3]} in Julia is \texttt{a[1:3]} in Python.


\item Julia does not support negative indexes. In particular, the last element of a list or array is indexed with \texttt{end} in Julia, not \texttt{-1} as in Python.


\item Julia{\textquotesingle}s \texttt{for}, \texttt{if}, \texttt{while}, etc. blocks are terminated by the \texttt{end} keyword. Indentation level is not significant as it is in Python.


\item Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.


\item Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of \hyperlink{3908315974291496321}{Performance Tips}).


\item Julia{\textquotesingle}s updating operators (e.g. \texttt{+=}, \texttt{-=}, ...) are \emph{not in-place} whereas NumPy{\textquotesingle}s are. This means \texttt{A = ones(4); B = A; B += 3} doesn{\textquotesingle}t change values in \texttt{A}, it rather rebinds the name \texttt{B} to the result of the right- hand side \texttt{B = B + 3}, which is a new array. Use \texttt{B[:] += 3}, explicit loops, or \texttt{InplaceOps.jl}.


\item Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function \texttt{f(x=rand()) = x} returns a new random number every time it is invoked without argument. On the other hand, the function \texttt{g(x=[1,2]) = push!(x,3)} returns \texttt{[1,2,3]} every time it is called as \texttt{g()}.


\item In Julia \texttt{\%} is the remainder operator, whereas in Python it is the modulus.

\end{itemize}


\hypertarget{30781051824837113}{}


\section{Noteworthy differences from C/C++}



\begin{itemize}
\item Julia arrays are indexed with square brackets, and can have more than one dimension \texttt{A[i,j]}. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).


\item In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.


\item Julia arrays are assigned by reference. After \texttt{A=B}, changing elements of \texttt{B} will modify \texttt{A} as well. Updating operators like \texttt{+=} do not operate in-place, they are equivalent to \texttt{A = A + B} which rebinds the left-hand side to the result of the right-hand side expression.


\item Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of \hyperlink{3908315974291496321}{Performance Tips}).


\item Julia values are passed and assigned by reference. If a function modifies an array, the changes will be visible in the caller.


\item In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.


\item In Julia, literal numbers without a decimal point (such as \texttt{42}) create signed integers, of type \texttt{Int}, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as \texttt{Int64} (if \texttt{Int} is \texttt{Int32}), \texttt{Int128}, or the arbitrarily large \texttt{BigInt} type. There are no numeric literal suffixes, such as \texttt{L}, \texttt{LL}, \texttt{U}, \texttt{UL}, \texttt{ULL} to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with \texttt{0x} like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the \emph{length} of the literal, including leading 0s. For example, \texttt{0x0} and \texttt{0x00} have type \hyperlink{6609065134969660118}{\texttt{UInt8}}, \texttt{0x000} and \texttt{0x0000} have type \hyperlink{7018610346698168012}{\texttt{UInt16}}, then literals with 5 to 8 hex digits have type \texttt{UInt32}, 9 to 16 hex digits type \texttt{UInt64} and 17 to 32 hex digits type \texttt{UInt128}. This needs to be taken into account when defining hexadecimal masks, for example \texttt{{\textasciitilde}0xf == 0xf0} is very different from \texttt{{\textasciitilde}0x000f == 0xfff0}. 64 bit \texttt{Float64} and 32 bit \hyperlink{8101639384272933082}{\texttt{Float32}} bit literals are expressed as \texttt{1.0} and \texttt{1.0f0} respectively. Floating point literals are rounded (and not promoted to the \texttt{BigFloat} type) if they can not be exactly represented.  Floating point literals are closer in behavior to C/C++. Octal (prefixed with \texttt{0o}) and binary (prefixed with \texttt{0b}) literals are also treated as unsigned.


\item String literals can be delimited with either \texttt{{\textquotedbl}}  or \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}}, \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} delimited literals can contain \texttt{{\textquotedbl}} characters without quoting it like \texttt{{\textquotedbl}{\textbackslash}{\textquotedbl}{\textquotedbl}} String literals can have values of other variables or expressions interpolated into them, indicated by \texttt{\$variablename} or \texttt{\$(expression)}, which evaluates the variable name or the expression in the context of the function.


\item \texttt{//} indicates a \hyperlink{8304566144531167610}{\texttt{Rational}} number, and not a single-line comment (which is \texttt{\#} in Julia)


\item \texttt{\#=} indicates the start of a multiline comment, and \texttt{=\#} ends it.


\item Functions in Julia return values from their last expression(s) or the \texttt{return} keyword.  Multiple values can be returned from functions and assigned as tuples, e.g. \texttt{(a, b) = myfunction()} or \texttt{a, b = myfunction()}, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. \texttt{a = myfunction(\&b)}.


\item Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. \hyperlink{783803254548423222}{\texttt{println()}} or \hyperlink{4087473154660177488}{\texttt{@printf()}} can be used to print specific output. In the REPL, \texttt{;} can be used to suppress output. \texttt{;} also has a different meaning within \texttt{[ ]}, something to watch out for. \texttt{;} can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.


\item In Julia, the operator \hyperlink{7071880015536674935}{\texttt{⊻}} (\hyperlink{7071880015536674935}{\texttt{xor}}) performs the bitwise XOR operation, i.e. \hyperlink{5729367935110528960}{\texttt{{\textasciicircum}}} in C/C++.  Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.


\item Julia{\textquotesingle}s \hyperlink{5729367935110528960}{\texttt{{\textasciicircum}}} is exponentiation (pow), not bitwise XOR as in C/C++ (use \hyperlink{7071880015536674935}{\texttt{⊻}}, or \hyperlink{7071880015536674935}{\texttt{xor}}, in Julia)


\item Julia has two right-shift operators, \texttt{>>} and \texttt{>>>}.  \texttt{>>>} performs an arithmetic shift, \texttt{>>} always performs a logical shift, unlike C/C++, where the meaning of \texttt{>>} depends on the type of the value being shifted.


\item Julia{\textquotesingle}s \texttt{->} creates an anonymous function, it does not access a member via a pointer.


\item Julia does not require parentheses when writing \texttt{if} statements or \texttt{for}/\texttt{while} loops: use \texttt{for i in [1, 2, 3]} instead of \texttt{for (int i=1; i <= 3; i++)} and \texttt{if i == 1} instead of \texttt{if (i == 1)}.


\item Julia does not treat the numbers \texttt{0} and \texttt{1} as Booleans. You cannot write \texttt{if (1)} in Julia, because \texttt{if} statements accept only booleans. Instead, you can write \texttt{if true}, \texttt{if Bool(1)}, or \texttt{if 1==1}.


\item Julia uses \texttt{end} to denote the end of conditional blocks, like \texttt{if}, loop blocks, like \texttt{while}/ \texttt{for}, and functions. In lieu of the one-line \texttt{if ( cond ) statement}, Julia allows statements of the form \texttt{if cond; statement; end}, \texttt{cond \&\& statement} and \texttt{!cond || statement}. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. \texttt{cond \&\& (x = value)}, because of the operator precedence.


\item Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.


\item Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the \texttt{@} character, and have both a function-like syntax, \texttt{@mymacro(arg1, arg2, arg3)}, and a statement-like syntax, \texttt{@mymacro arg1 arg2 arg3}. The forms are interchangable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the parallel \texttt{for} construct: \texttt{@parallel for i in 1:n; \#= body =\#; end}. Where the end of the macro construct may be unclear, use the function-like form.


\item Julia now has an enumeration type, expressed using the macro \texttt{@enum(name, value1, value2, ...)} For example: \texttt{@enum(Fruit, banana=1, apple, pear)}


\item By convention, functions that modify their arguments have a \texttt{!} at the end of the name, for example \texttt{push!}.


\item In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is {\textquotedbl}virtual{\textquotedbl} (although it{\textquotesingle}s more general than that since methods are dispatched on every argument type, not only \texttt{this}, using the most-specific-declaration rule).

\end{itemize}


\hypertarget{7696893994298815226}{}


\chapter{Unicode Input}



The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in various other editing environments).  You can also get information on how to type a symbol by entering it in the REPL help, i.e. by typing \texttt{?} and then entering the symbol in the REPL (e.g., by copy-paste from somewhere you saw the symbol).



\begin{quote}
\textbf{Warning}

This table may appear to contain missing characters in the second column, or even show characters that are inconsistent with the characters as they are rendered in the Julia REPL. In these cases, users are strongly advised to check their choice of fonts in their browser and REPL environment, as there are known issues with glyphs in many fonts.

\end{quote}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
Code point(s) & Character(s) & Tab completion sequence(s) & Unicode name(s) \\
\hline
U+000A1 & ¡ & {\textbackslash}textexclamdown & Inverted Exclamation Mark \\
\hline
U+000A3 & £ & {\textbackslash}sterling & Pound Sign \\
\hline
U+000A5 & ¥ & {\textbackslash}yen & Yen Sign \\
\hline
U+000A6 & ¦ & {\textbackslash}textbrokenbar & Broken Bar / Broken Vertical Bar \\
\hline
U+000A7 & § & {\textbackslash}S & Section Sign \\
\hline
U+000A8 & ¨ & {\textbackslash}textasciidieresis & Diaeresis / Spacing Diaeresis \\
\hline
U+000A9 & © & {\textbackslash}copyright, {\textbackslash}:copyright: & Copyright Sign \\
\hline
U+000AA & ª & {\textbackslash}textordfeminine & Feminine Ordinal Indicator \\
\hline
U+000AC & ¬ & {\textbackslash}neg & Not Sign \\
\hline
U+000AE & ® & {\textbackslash}circledR, {\textbackslash}:registered: & Registered Sign / Registered Trade Mark Sign \\
\hline
U+000AF & ¯ & {\textbackslash}textasciimacron & Macron / Spacing Macron \\
\hline
U+000B0 & ° & {\textbackslash}degree & Degree Sign \\
\hline
U+000B1 & ± & {\textbackslash}pm & Plus-minus Sign / Plus-or-minus Sign \\
\hline
U+000B2 & ² & {\textbackslash}{\textasciicircum}2 & Superscript Two / Superscript Digit Two \\
\hline
U+000B3 & ³ & {\textbackslash}{\textasciicircum}3 & Superscript Three / Superscript Digit Three \\
\hline
U+000B4 & ´ & {\textbackslash}textasciiacute & Acute Accent / Spacing Acute \\
\hline
U+000B6 & ¶ & {\textbackslash}P & Pilcrow Sign / Paragraph Sign \\
\hline
U+000B7 & · & {\textbackslash}cdotp & Middle Dot \\
\hline
U+000B9 & ¹ & {\textbackslash}{\textasciicircum}1 & Superscript One / Superscript Digit One \\
\hline
U+000BA & º & {\textbackslash}textordmasculine & Masculine Ordinal Indicator \\
\hline
U+000BC & ¼ & {\textbackslash}textonequarter & Vulgar Fraction One Quarter / Fraction One Quarter \\
\hline
U+000BD & ½ & {\textbackslash}textonehalf & Vulgar Fraction One Half / Fraction One Half \\
\hline
U+000BE & ¾ & {\textbackslash}textthreequarters & Vulgar Fraction Three Quarters / Fraction Three Quarters \\
\hline
U+000BF & ¿ & {\textbackslash}textquestiondown & Inverted Question Mark \\
\hline
U+000C5 & Å & {\textbackslash}AA & Latin Capital Letter A With Ring Above / Latin Capital Letter A Ring \\
\hline
U+000C6 & Æ & {\textbackslash}AE & Latin Capital Letter Ae / Latin Capital Letter A E \\
\hline
U+000D0 & Ð & {\textbackslash}DH & Latin Capital Letter Eth \\
\hline
U+000D7 & × & {\textbackslash}times & Multiplication Sign \\
\hline
U+000D8 & Ø & {\textbackslash}O & Latin Capital Letter O With Stroke / Latin Capital Letter O Slash \\
\hline
U+000DE & Þ & {\textbackslash}TH & Latin Capital Letter Thorn \\
\hline
U+000DF & ß & {\textbackslash}ss & Latin Small Letter Sharp S \\
\hline
U+000E5 & å & {\textbackslash}aa & Latin Small Letter A With Ring Above / Latin Small Letter A Ring \\
\hline
U+000E6 & æ & {\textbackslash}ae & Latin Small Letter Ae / Latin Small Letter A E \\
\hline
U+000F0 & ð & {\textbackslash}eth & Latin Small Letter Eth \\
\hline
U+000F7 & ÷ & {\textbackslash}div & Division Sign \\
\hline
U+000F8 & ø & {\textbackslash}o & Latin Small Letter O With Stroke / Latin Small Letter O Slash \\
\hline
U+000FE & þ & {\textbackslash}th & Latin Small Letter Thorn \\
\hline
U+00110 & Đ & {\textbackslash}DJ & Latin Capital Letter D With Stroke / Latin Capital Letter D Bar \\
\hline
U+00111 & đ & {\textbackslash}dj & Latin Small Letter D With Stroke / Latin Small Letter D Bar \\
\hline
U+00127 & ħ & {\textbackslash}Elzxh, {\textbackslash}hbar & Latin Small Letter H With Stroke / Latin Small Letter H Bar \\
\hline
U+00141 & Ł & {\textbackslash}L & Latin Capital Letter L With Stroke / Latin Capital Letter L Slash \\
\hline
U+00142 & ł & {\textbackslash}l & Latin Small Letter L With Stroke / Latin Small Letter L Slash \\
\hline
U+0014A & Ŋ & {\textbackslash}NG & Latin Capital Letter Eng \\
\hline
U+0014B & ŋ & {\textbackslash}ng & Latin Small Letter Eng \\
\hline
U+00152 & Œ & {\textbackslash}OE & Latin Capital Ligature Oe / Latin Capital Letter O E \\
\hline
U+00153 & œ & {\textbackslash}oe & Latin Small Ligature Oe / Latin Small Letter O E \\
\hline
U+00195 & ƕ & {\textbackslash}texthvlig & Latin Small Letter Hv / Latin Small Letter H V \\
\hline
U+0019E & ƞ & {\textbackslash}textnrleg & Latin Small Letter N With Long Right Leg \\
\hline
U+001B5 & Ƶ & {\textbackslash}Zbar & Latin Capital Letter Z With Stroke / Latin Capital Letter Z Bar \\
\hline
U+001C2 & ǂ & {\textbackslash}textdoublepipe & Latin Letter Alveolar Click / Latin Letter Pipe Double Bar \\
\hline
U+00250 & ɐ & {\textbackslash}Elztrna & Latin Small Letter Turned A \\
\hline
U+00252 & ɒ & {\textbackslash}Elztrnsa & Latin Small Letter Turned Alpha / Latin Small Letter Turned Script A \\
\hline
U+00254 & ɔ & {\textbackslash}Elzopeno & Latin Small Letter Open O \\
\hline
U+00256 & ɖ & {\textbackslash}Elzrtld & Latin Small Letter D With Tail / Latin Small Letter D Retroflex Hook \\
\hline
U+00259 & ə & {\textbackslash}Elzschwa & Latin Small Letter Schwa \\
\hline
U+00263 & ɣ & {\textbackslash}Elzpgamma & Latin Small Letter Gamma \\
\hline
U+00264 & ɤ & {\textbackslash}Elzpbgam & Latin Small Letter Rams Horn / Latin Small Letter Baby Gamma \\
\hline
U+00265 & ɥ & {\textbackslash}Elztrnh & Latin Small Letter Turned H \\
\hline
U+0026C & ɬ & {\textbackslash}Elzbtdl & Latin Small Letter L With Belt / Latin Small Letter L Belt \\
\hline
U+0026D & ɭ & {\textbackslash}Elzrtll & Latin Small Letter L With Retroflex Hook / Latin Small Letter L Retroflex Hook \\
\hline
U+0026F & ɯ & {\textbackslash}Elztrnm & Latin Small Letter Turned M \\
\hline
U+00270 & ɰ & {\textbackslash}Elztrnmlr & Latin Small Letter Turned M With Long Leg \\
\hline
U+00271 & ɱ & {\textbackslash}Elzltlmr & Latin Small Letter M With Hook / Latin Small Letter M Hook \\
\hline
U+00272 & ɲ & {\textbackslash}Elzltln & Latin Small Letter N With Left Hook / Latin Small Letter N Hook \\
\hline
U+00273 & ɳ & {\textbackslash}Elzrtln & Latin Small Letter N With Retroflex Hook / Latin Small Letter N Retroflex Hook \\
\hline
U+00277 & ɷ & {\textbackslash}Elzclomeg & Latin Small Letter Closed Omega \\
\hline
U+00278 & ɸ & {\textbackslash}textphi & Latin Small Letter Phi \\
\hline
U+00279 & ɹ & {\textbackslash}Elztrnr & Latin Small Letter Turned R \\
\hline
U+0027A & ɺ & {\textbackslash}Elztrnrl & Latin Small Letter Turned R With Long Leg \\
\hline
U+0027B & ɻ & {\textbackslash}Elzrttrnr & Latin Small Letter Turned R With Hook / Latin Small Letter Turned R Hook \\
\hline
U+0027C & ɼ & {\textbackslash}Elzrl & Latin Small Letter R With Long Leg \\
\hline
U+0027D & ɽ & {\textbackslash}Elzrtlr & Latin Small Letter R With Tail / Latin Small Letter R Hook \\
\hline
U+0027E & ɾ & {\textbackslash}Elzfhr & Latin Small Letter R With Fishhook / Latin Small Letter Fishhook R \\
\hline
U+00282 & ʂ & {\textbackslash}Elzrtls & Latin Small Letter S With Hook / Latin Small Letter S Hook \\
\hline
U+00283 & ʃ & {\textbackslash}Elzesh & Latin Small Letter Esh \\
\hline
U+00287 & ʇ & {\textbackslash}Elztrnt & Latin Small Letter Turned T \\
\hline
U+00288 & ʈ & {\textbackslash}Elzrtlt & Latin Small Letter T With Retroflex Hook / Latin Small Letter T Retroflex Hook \\
\hline
U+0028A & ʊ & {\textbackslash}Elzpupsil & Latin Small Letter Upsilon \\
\hline
U+0028B & ʋ & {\textbackslash}Elzpscrv & Latin Small Letter V With Hook / Latin Small Letter Script V \\
\hline
U+0028C & ʌ & {\textbackslash}Elzinvv & Latin Small Letter Turned V \\
\hline
U+0028D & ʍ & {\textbackslash}Elzinvw & Latin Small Letter Turned W \\
\hline
U+0028E & ʎ & {\textbackslash}Elztrny & Latin Small Letter Turned Y \\
\hline
U+00290 & ʐ & {\textbackslash}Elzrtlz & Latin Small Letter Z With Retroflex Hook / Latin Small Letter Z Retroflex Hook \\
\hline
U+00292 & ʒ & {\textbackslash}Elzyogh & Latin Small Letter Ezh / Latin Small Letter Yogh \\
\hline
U+00294 & ʔ & {\textbackslash}Elzglst & Latin Letter Glottal Stop \\
\hline
U+00295 & ʕ & {\textbackslash}Elzreglst & Latin Letter Pharyngeal Voiced Fricative / Latin Letter Reversed Glottal Stop \\
\hline
U+00296 & ʖ & {\textbackslash}Elzinglst & Latin Letter Inverted Glottal Stop \\
\hline
U+0029E & ʞ & {\textbackslash}textturnk & Latin Small Letter Turned K \\
\hline
U+002A4 & ʤ & {\textbackslash}Elzdyogh & Latin Small Letter Dezh Digraph / Latin Small Letter D Yogh \\
\hline
U+002A7 & ʧ & {\textbackslash}Elztesh & Latin Small Letter Tesh Digraph / Latin Small Letter T Esh \\
\hline
U+002B0 & ʰ & {\textbackslash}{\textasciicircum}h & Modifier Letter Small H \\
\hline
U+002B2 & ʲ & {\textbackslash}{\textasciicircum}j & Modifier Letter Small J \\
\hline
U+002B3 & ʳ & {\textbackslash}{\textasciicircum}r & Modifier Letter Small R \\
\hline
U+002B7 & ʷ & {\textbackslash}{\textasciicircum}w & Modifier Letter Small W \\
\hline
U+002B8 & ʸ & {\textbackslash}{\textasciicircum}y & Modifier Letter Small Y \\
\hline
U+002BC & ʼ & {\textbackslash}rasp & Modifier Letter Apostrophe \\
\hline
U+002C7 & ˇ & {\textbackslash}textasciicaron & Caron / Modifier Letter Hacek \\
\hline
U+002C8 & ˈ & {\textbackslash}Elzverts & Modifier Letter Vertical Line \\
\hline
U+002CC & ˌ & {\textbackslash}Elzverti & Modifier Letter Low Vertical Line \\
\hline
U+002D0 & ː & {\textbackslash}Elzlmrk & Modifier Letter Triangular Colon \\
\hline
U+002D1 & ˑ & {\textbackslash}Elzhlmrk & Modifier Letter Half Triangular Colon \\
\hline
U+002D2 & ˒ & {\textbackslash}Elzsbrhr & Modifier Letter Centred Right Half Ring / Modifier Letter Centered Right Half Ring \\
\hline
U+002D3 & ˓ & {\textbackslash}Elzsblhr & Modifier Letter Centred Left Half Ring / Modifier Letter Centered Left Half Ring \\
\hline
U+002D4 & ˔ & {\textbackslash}Elzrais & Modifier Letter Up Tack \\
\hline
U+002D5 & ˕ & {\textbackslash}Elzlow & Modifier Letter Down Tack \\
\hline
U+002D8 & ˘ & {\textbackslash}u & Breve / Spacing Breve \\
\hline
U+002DC & ˜ & {\textbackslash}texttildelow & Small Tilde / Spacing Tilde \\
\hline
U+002E1 & ˡ & {\textbackslash}{\textasciicircum}l & Modifier Letter Small L \\
\hline
U+002E2 & ˢ & {\textbackslash}{\textasciicircum}s & Modifier Letter Small S \\
\hline
U+002E3 & ˣ & {\textbackslash}{\textasciicircum}x & Modifier Letter Small X \\
\hline
U+00300 & ◌̀ & {\textbackslash}grave & Combining Grave Accent / Non-spacing Grave \\
\hline
U+00301 & ◌́ & {\textbackslash}acute & Combining Acute Accent / Non-spacing Acute \\
\hline
U+00302 & ◌̂ & {\textbackslash}hat & Combining Circumflex Accent / Non-spacing Circumflex \\
\hline
U+00303 & ◌̃ & {\textbackslash}tilde & Combining Tilde / Non-spacing Tilde \\
\hline
U+00304 & ◌̄ & {\textbackslash}bar & Combining Macron / Non-spacing Macron \\
\hline
U+00305 & ◌̅ & {\textbackslash}overbar & Combining Overline / Non-spacing Overscore \\
\hline
U+00306 & ◌̆ & {\textbackslash}breve & Combining Breve / Non-spacing Breve \\
\hline
U+00307 & ◌̇ & {\textbackslash}dot & Combining Dot Above / Non-spacing Dot Above \\
\hline
U+00308 & ◌̈ & {\textbackslash}ddot & Combining Diaeresis / Non-spacing Diaeresis \\
\hline
U+00309 & ◌̉ & {\textbackslash}ovhook & Combining Hook Above / Non-spacing Hook Above \\
\hline
U+0030A & ◌̊ & {\textbackslash}ocirc & Combining Ring Above / Non-spacing Ring Above \\
\hline
U+0030B & ◌̋ & {\textbackslash}H & Combining Double Acute Accent / Non-spacing Double Acute \\
\hline
U+0030C & ◌̌ & {\textbackslash}check & Combining Caron / Non-spacing Hacek \\
\hline
U+00310 & ◌̐ & {\textbackslash}candra & Combining Candrabindu / Non-spacing Candrabindu \\
\hline
U+00312 & ◌̒ & {\textbackslash}oturnedcomma & Combining Turned Comma Above / Non-spacing Turned Comma Above \\
\hline
U+00315 & ◌̕ & {\textbackslash}ocommatopright & Combining Comma Above Right / Non-spacing Comma Above Right \\
\hline
U+0031A & ◌̚ & {\textbackslash}droang & Combining Left Angle Above / Non-spacing Left Angle Above \\
\hline
U+00321 & ◌̡ & {\textbackslash}Elzpalh & Combining Palatalized Hook Below / Non-spacing Palatalized Hook Below \\
\hline
U+00322 & ◌̢ & {\textbackslash}Elzrh & Combining Retroflex Hook Below / Non-spacing Retroflex Hook Below \\
\hline
U+00327 & ◌̧ & {\textbackslash}c & Combining Cedilla / Non-spacing Cedilla \\
\hline
U+00328 & ◌̨ & {\textbackslash}k & Combining Ogonek / Non-spacing Ogonek \\
\hline
U+0032A & ◌̪ & {\textbackslash}Elzsbbrg & Combining Bridge Below / Non-spacing Bridge Below \\
\hline
U+00330 & ◌̰ & {\textbackslash}wideutilde & Combining Tilde Below / Non-spacing Tilde Below \\
\hline
U+00332 & ◌̲ & {\textbackslash}underbar & Combining Low Line / Non-spacing Underscore \\
\hline
U+00335 & ◌̵ & {\textbackslash}Elzxl & Combining Short Stroke Overlay / Non-spacing Short Bar Overlay \\
\hline
U+00336 & ◌̶ & {\textbackslash}Elzbar, {\textbackslash}sout & Combining Long Stroke Overlay / Non-spacing Long Bar Overlay \\
\hline
U+00338 & ◌̸ & {\textbackslash}not & Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0034D & ◌͍ & {\textbackslash}underleftrightarrow & Combining Left Right Arrow Below \\
\hline
U+00391 & Α & {\textbackslash}Alpha & Greek Capital Letter Alpha \\
\hline
U+00392 & Β & {\textbackslash}Beta & Greek Capital Letter Beta \\
\hline
U+00393 & Γ & {\textbackslash}Gamma & Greek Capital Letter Gamma \\
\hline
U+00394 & Δ & {\textbackslash}Delta & Greek Capital Letter Delta \\
\hline
U+00395 & Ε & {\textbackslash}Epsilon & Greek Capital Letter Epsilon \\
\hline
U+00396 & Ζ & {\textbackslash}Zeta & Greek Capital Letter Zeta \\
\hline
U+00397 & Η & {\textbackslash}Eta & Greek Capital Letter Eta \\
\hline
U+00398 & Θ & {\textbackslash}Theta & Greek Capital Letter Theta \\
\hline
U+00399 & Ι & {\textbackslash}Iota & Greek Capital Letter Iota \\
\hline
U+0039A & Κ & {\textbackslash}Kappa & Greek Capital Letter Kappa \\
\hline
U+0039B & Λ & {\textbackslash}Lambda & Greek Capital Letter Lamda / Greek Capital Letter Lambda \\
\hline
U+0039C & Μ & {\textbackslash}upMu & Greek Capital Letter Mu \\
\hline
U+0039D & Ν & {\textbackslash}upNu & Greek Capital Letter Nu \\
\hline
U+0039E & Ξ & {\textbackslash}Xi & Greek Capital Letter Xi \\
\hline
U+0039F & Ο & {\textbackslash}upOmicron & Greek Capital Letter Omicron \\
\hline
U+003A0 & Π & {\textbackslash}Pi & Greek Capital Letter Pi \\
\hline
U+003A1 & Ρ & {\textbackslash}Rho & Greek Capital Letter Rho \\
\hline
U+003A3 & Σ & {\textbackslash}Sigma & Greek Capital Letter Sigma \\
\hline
U+003A4 & Τ & {\textbackslash}Tau & Greek Capital Letter Tau \\
\hline
U+003A5 & Υ & {\textbackslash}Upsilon & Greek Capital Letter Upsilon \\
\hline
U+003A6 & Φ & {\textbackslash}Phi & Greek Capital Letter Phi \\
\hline
U+003A7 & Χ & {\textbackslash}Chi & Greek Capital Letter Chi \\
\hline
U+003A8 & Ψ & {\textbackslash}Psi & Greek Capital Letter Psi \\
\hline
U+003A9 & Ω & {\textbackslash}Omega & Greek Capital Letter Omega \\
\hline
U+003B1 & α & {\textbackslash}alpha & Greek Small Letter Alpha \\
\hline
U+003B2 & β & {\textbackslash}beta & Greek Small Letter Beta \\
\hline
U+003B3 & γ & {\textbackslash}gamma & Greek Small Letter Gamma \\
\hline
U+003B4 & δ & {\textbackslash}delta & Greek Small Letter Delta \\
\hline
U+003B5 & ε & {\textbackslash}upepsilon, {\textbackslash}varepsilon & Greek Small Letter Epsilon \\
\hline
U+003B6 & ζ & {\textbackslash}zeta & Greek Small Letter Zeta \\
\hline
U+003B7 & η & {\textbackslash}eta & Greek Small Letter Eta \\
\hline
U+003B8 & θ & {\textbackslash}theta & Greek Small Letter Theta \\
\hline
U+003B9 & ι & {\textbackslash}iota & Greek Small Letter Iota \\
\hline
U+003BA & κ & {\textbackslash}kappa & Greek Small Letter Kappa \\
\hline
U+003BB & λ & {\textbackslash}lambda & Greek Small Letter Lamda / Greek Small Letter Lambda \\
\hline
U+003BC & μ & {\textbackslash}mu & Greek Small Letter Mu \\
\hline
U+003BD & ν & {\textbackslash}nu & Greek Small Letter Nu \\
\hline
U+003BE & ξ & {\textbackslash}xi & Greek Small Letter Xi \\
\hline
U+003BF & ο & {\textbackslash}upomicron & Greek Small Letter Omicron \\
\hline
U+003C0 & π & {\textbackslash}pi & Greek Small Letter Pi \\
\hline
U+003C1 & ρ & {\textbackslash}rho & Greek Small Letter Rho \\
\hline
U+003C2 & ς & {\textbackslash}varsigma & Greek Small Letter Final Sigma \\
\hline
U+003C3 & σ & {\textbackslash}sigma & Greek Small Letter Sigma \\
\hline
U+003C4 & τ & {\textbackslash}tau & Greek Small Letter Tau \\
\hline
U+003C5 & υ & {\textbackslash}upsilon & Greek Small Letter Upsilon \\
\hline
U+003C6 & φ & {\textbackslash}varphi & Greek Small Letter Phi \\
\hline
U+003C7 & χ & {\textbackslash}chi & Greek Small Letter Chi \\
\hline
U+003C8 & ψ & {\textbackslash}psi & Greek Small Letter Psi \\
\hline
U+003C9 & ω & {\textbackslash}omega & Greek Small Letter Omega \\
\hline
U+003D0 & ϐ & {\textbackslash}upvarbeta & Greek Beta Symbol / Greek Small Letter Curled Beta \\
\hline
U+003D1 & ϑ & {\textbackslash}vartheta & Greek Theta Symbol / Greek Small Letter Script Theta \\
\hline
U+003D5 & ϕ & {\textbackslash}phi & Greek Phi Symbol / Greek Small Letter Script Phi \\
\hline
U+003D6 & ϖ & {\textbackslash}varpi & Greek Pi Symbol / Greek Small Letter Omega Pi \\
\hline
U+003D8 & Ϙ & {\textbackslash}upoldKoppa & Greek Letter Archaic Koppa \\
\hline
U+003D9 & ϙ & {\textbackslash}upoldkoppa & Greek Small Letter Archaic Koppa \\
\hline
U+003DA & Ϛ & {\textbackslash}Stigma & Greek Letter Stigma / Greek Capital Letter Stigma \\
\hline
U+003DB & ϛ & {\textbackslash}upstigma & Greek Small Letter Stigma \\
\hline
U+003DC & Ϝ & {\textbackslash}Digamma & Greek Letter Digamma / Greek Capital Letter Digamma \\
\hline
U+003DD & ϝ & {\textbackslash}digamma & Greek Small Letter Digamma \\
\hline
U+003DE & Ϟ & {\textbackslash}Koppa & Greek Letter Koppa / Greek Capital Letter Koppa \\
\hline
U+003DF & ϟ & {\textbackslash}upkoppa & Greek Small Letter Koppa \\
\hline
U+003E0 & Ϡ & {\textbackslash}Sampi & Greek Letter Sampi / Greek Capital Letter Sampi \\
\hline
U+003E1 & ϡ & {\textbackslash}upsampi & Greek Small Letter Sampi \\
\hline
U+003F0 & ϰ & {\textbackslash}varkappa & Greek Kappa Symbol / Greek Small Letter Script Kappa \\
\hline
U+003F1 & ϱ & {\textbackslash}varrho & Greek Rho Symbol / Greek Small Letter Tailed Rho \\
\hline
U+003F4 & ϴ & {\textbackslash}textTheta & Greek Capital Theta Symbol \\
\hline
U+003F5 & ϵ & {\textbackslash}epsilon & Greek Lunate Epsilon Symbol \\
\hline
U+003F6 & ϶ & {\textbackslash}backepsilon & Greek Reversed Lunate Epsilon Symbol \\
\hline
U+01D2C & ᴬ & {\textbackslash}{\textasciicircum}A & Modifier Letter Capital A \\
\hline
U+01D2E & ᴮ & {\textbackslash}{\textasciicircum}B & Modifier Letter Capital B \\
\hline
U+01D30 & ᴰ & {\textbackslash}{\textasciicircum}D & Modifier Letter Capital D \\
\hline
U+01D31 & ᴱ & {\textbackslash}{\textasciicircum}E & Modifier Letter Capital E \\
\hline
U+01D33 & ᴳ & {\textbackslash}{\textasciicircum}G & Modifier Letter Capital G \\
\hline
U+01D34 & ᴴ & {\textbackslash}{\textasciicircum}H & Modifier Letter Capital H \\
\hline
U+01D35 & ᴵ & {\textbackslash}{\textasciicircum}I & Modifier Letter Capital I \\
\hline
U+01D36 & ᴶ & {\textbackslash}{\textasciicircum}J & Modifier Letter Capital J \\
\hline
U+01D37 & ᴷ & {\textbackslash}{\textasciicircum}K & Modifier Letter Capital K \\
\hline
U+01D38 & ᴸ & {\textbackslash}{\textasciicircum}L & Modifier Letter Capital L \\
\hline
U+01D39 & ᴹ & {\textbackslash}{\textasciicircum}M & Modifier Letter Capital M \\
\hline
U+01D3A & ᴺ & {\textbackslash}{\textasciicircum}N & Modifier Letter Capital N \\
\hline
U+01D3C & ᴼ & {\textbackslash}{\textasciicircum}O & Modifier Letter Capital O \\
\hline
U+01D3E & ᴾ & {\textbackslash}{\textasciicircum}P & Modifier Letter Capital P \\
\hline
U+01D3F & ᴿ & {\textbackslash}{\textasciicircum}R & Modifier Letter Capital R \\
\hline
U+01D40 & ᵀ & {\textbackslash}{\textasciicircum}T & Modifier Letter Capital T \\
\hline
U+01D41 & ᵁ & {\textbackslash}{\textasciicircum}U & Modifier Letter Capital U \\
\hline
U+01D42 & ᵂ & {\textbackslash}{\textasciicircum}W & Modifier Letter Capital W \\
\hline
U+01D43 & ᵃ & {\textbackslash}{\textasciicircum}a & Modifier Letter Small A \\
\hline
U+01D45 & ᵅ & {\textbackslash}{\textasciicircum}alpha & Modifier Letter Small Alpha \\
\hline
U+01D47 & ᵇ & {\textbackslash}{\textasciicircum}b & Modifier Letter Small B \\
\hline
U+01D48 & ᵈ & {\textbackslash}{\textasciicircum}d & Modifier Letter Small D \\
\hline
U+01D49 & ᵉ & {\textbackslash}{\textasciicircum}e & Modifier Letter Small E \\
\hline
U+01D4B & ᵋ & {\textbackslash}{\textasciicircum}epsilon & Modifier Letter Small Open E \\
\hline
U+01D4D & ᵍ & {\textbackslash}{\textasciicircum}g & Modifier Letter Small G \\
\hline
U+01D4F & ᵏ & {\textbackslash}{\textasciicircum}k & Modifier Letter Small K \\
\hline
U+01D50 & ᵐ & {\textbackslash}{\textasciicircum}m & Modifier Letter Small M \\
\hline
U+01D52 & ᵒ & {\textbackslash}{\textasciicircum}o & Modifier Letter Small O \\
\hline
U+01D56 & ᵖ & {\textbackslash}{\textasciicircum}p & Modifier Letter Small P \\
\hline
U+01D57 & ᵗ & {\textbackslash}{\textasciicircum}t & Modifier Letter Small T \\
\hline
U+01D58 & ᵘ & {\textbackslash}{\textasciicircum}u & Modifier Letter Small U \\
\hline
U+01D5B & ᵛ & {\textbackslash}{\textasciicircum}v & Modifier Letter Small V \\
\hline
U+01D5D & ᵝ & {\textbackslash}{\textasciicircum}beta & Modifier Letter Small Beta \\
\hline
U+01D5E & ᵞ & {\textbackslash}{\textasciicircum}gamma & Modifier Letter Small Greek Gamma \\
\hline
U+01D5F & ᵟ & {\textbackslash}{\textasciicircum}delta & Modifier Letter Small Delta \\
\hline
U+01D60 & ᵠ & {\textbackslash}{\textasciicircum}phi & Modifier Letter Small Greek Phi \\
\hline
U+01D61 & ᵡ & {\textbackslash}{\textasciicircum}chi & Modifier Letter Small Chi \\
\hline
U+01D62 & ᵢ & {\textbackslash}\_i & Latin Subscript Small Letter I \\
\hline
U+01D63 & ᵣ & {\textbackslash}\_r & Latin Subscript Small Letter R \\
\hline
U+01D64 & ᵤ & {\textbackslash}\_u & Latin Subscript Small Letter U \\
\hline
U+01D65 & ᵥ & {\textbackslash}\_v & Latin Subscript Small Letter V \\
\hline
U+01D66 & ᵦ & {\textbackslash}\_beta & Greek Subscript Small Letter Beta \\
\hline
U+01D67 & ᵧ & {\textbackslash}\_gamma & Greek Subscript Small Letter Gamma \\
\hline
U+01D68 & ᵨ & {\textbackslash}\_rho & Greek Subscript Small Letter Rho \\
\hline
U+01D69 & ᵩ & {\textbackslash}\_phi & Greek Subscript Small Letter Phi \\
\hline
U+01D6A & ᵪ & {\textbackslash}\_chi & Greek Subscript Small Letter Chi \\
\hline
U+01D9C & ᶜ & {\textbackslash}{\textasciicircum}c & Modifier Letter Small C \\
\hline
U+01DA0 & ᶠ & {\textbackslash}{\textasciicircum}f & Modifier Letter Small F \\
\hline
U+01DA5 & ᶥ & {\textbackslash}{\textasciicircum}iota & Modifier Letter Small Iota \\
\hline
U+01DB2 & ᶲ & {\textbackslash}{\textasciicircum}Phi & Modifier Letter Small Phi \\
\hline
U+01DBB & ᶻ & {\textbackslash}{\textasciicircum}z & Modifier Letter Small Z \\
\hline
U+01DBF & ᶿ & {\textbackslash}{\textasciicircum}theta & Modifier Letter Small Theta \\
\hline
U+02002 &   & {\textbackslash}enspace & En Space \\
\hline
U+02003 &   & {\textbackslash}quad & Em Space \\
\hline
U+02005 &   & {\textbackslash}thickspace & Four-per-em Space \\
\hline
U+02009 &   & {\textbackslash}thinspace & Thin Space \\
\hline
U+0200A &   & {\textbackslash}hspace & Hair Space \\
\hline
U+02013 & – & {\textbackslash}endash & En Dash \\
\hline
U+02014 & — & {\textbackslash}emdash & Em Dash \\
\hline
U+02016 & ‖ & {\textbackslash}Vert & Double Vertical Line / Double Vertical Bar \\
\hline
U+02018 & ‘ & {\textbackslash}lq & Left Single Quotation Mark / Single Turned Comma Quotation Mark \\
\hline
U+02019 & ’ & {\textbackslash}rq & Right Single Quotation Mark / Single Comma Quotation Mark \\
\hline
U+0201B & ‛ & {\textbackslash}Elzreapos & Single High-reversed-9 Quotation Mark / Single Reversed Comma Quotation Mark \\
\hline
U+0201C & “ & {\textbackslash}textquotedblleft & Left Double Quotation Mark / Double Turned Comma Quotation Mark \\
\hline
U+0201D & ” & {\textbackslash}textquotedblright & Right Double Quotation Mark / Double Comma Quotation Mark \\
\hline
U+02020 & † & {\textbackslash}dagger & Dagger \\
\hline
U+02021 & ‡ & {\textbackslash}ddagger & Double Dagger \\
\hline
U+02022 & • & {\textbackslash}bullet & Bullet \\
\hline
U+02026 & … & {\textbackslash}dots, {\textbackslash}ldots & Horizontal Ellipsis \\
\hline
U+02030 & ‰ & {\textbackslash}textperthousand & Per Mille Sign \\
\hline
U+02031 & ‱ & {\textbackslash}textpertenthousand & Per Ten Thousand Sign \\
\hline
U+02032 & ′ & {\textbackslash}prime & Prime \\
\hline
U+02033 & ″ & {\textbackslash}pprime & Double Prime \\
\hline
U+02034 & ‴ & {\textbackslash}ppprime & Triple Prime \\
\hline
U+02035 & ‵ & {\textbackslash}backprime & Reversed Prime \\
\hline
U+02036 & ‶ & {\textbackslash}backpprime & Reversed Double Prime \\
\hline
U+02037 & ‷ & {\textbackslash}backppprime & Reversed Triple Prime \\
\hline
U+02039 & ‹ & {\textbackslash}guilsinglleft & Single Left-pointing Angle Quotation Mark / Left Pointing Single Guillemet \\
\hline
U+0203A & › & {\textbackslash}guilsinglright & Single Right-pointing Angle Quotation Mark / Right Pointing Single Guillemet \\
\hline
U+0203C & ‼ & {\textbackslash}:bangbang: & Double Exclamation Mark \\
\hline
U+02040 & ⁀ & {\textbackslash}tieconcat & Character Tie \\
\hline
U+02049 & ⁉ & {\textbackslash}:interrobang: & Exclamation Question Mark \\
\hline
U+02057 & ⁗ & {\textbackslash}pppprime & Quadruple Prime \\
\hline
U+02060 & ⁠ & {\textbackslash}nolinebreak & Word Joiner \\
\hline
U+02070 & ⁰ & {\textbackslash}{\textasciicircum}0 & Superscript Zero / Superscript Digit Zero \\
\hline
U+02071 & ⁱ & {\textbackslash}{\textasciicircum}i & Superscript Latin Small Letter I \\
\hline
U+02074 & ⁴ & {\textbackslash}{\textasciicircum}4 & Superscript Four / Superscript Digit Four \\
\hline
U+02075 & ⁵ & {\textbackslash}{\textasciicircum}5 & Superscript Five / Superscript Digit Five \\
\hline
U+02076 & ⁶ & {\textbackslash}{\textasciicircum}6 & Superscript Six / Superscript Digit Six \\
\hline
U+02077 & ⁷ & {\textbackslash}{\textasciicircum}7 & Superscript Seven / Superscript Digit Seven \\
\hline
U+02078 & ⁸ & {\textbackslash}{\textasciicircum}8 & Superscript Eight / Superscript Digit Eight \\
\hline
U+02079 & ⁹ & {\textbackslash}{\textasciicircum}9 & Superscript Nine / Superscript Digit Nine \\
\hline
U+0207A & ⁺ & {\textbackslash}{\textasciicircum}+ & Superscript Plus Sign \\
\hline
U+0207B & ⁻ & {\textbackslash}{\textasciicircum}- & Superscript Minus / Superscript Hyphen-minus \\
\hline
U+0207C & ⁼ & {\textbackslash}{\textasciicircum}= & Superscript Equals Sign \\
\hline
U+0207D & ⁽ & {\textbackslash}{\textasciicircum}( & Superscript Left Parenthesis / Superscript Opening Parenthesis \\
\hline
U+0207E & ⁾ & {\textbackslash}{\textasciicircum}) & Superscript Right Parenthesis / Superscript Closing Parenthesis \\
\hline
U+0207F & ⁿ & {\textbackslash}{\textasciicircum}n & Superscript Latin Small Letter N \\
\hline
U+02080 & ₀ & {\textbackslash}\_0 & Subscript Zero / Subscript Digit Zero \\
\hline
U+02081 & ₁ & {\textbackslash}\_1 & Subscript One / Subscript Digit One \\
\hline
U+02082 & ₂ & {\textbackslash}\_2 & Subscript Two / Subscript Digit Two \\
\hline
U+02083 & ₃ & {\textbackslash}\_3 & Subscript Three / Subscript Digit Three \\
\hline
U+02084 & ₄ & {\textbackslash}\_4 & Subscript Four / Subscript Digit Four \\
\hline
U+02085 & ₅ & {\textbackslash}\_5 & Subscript Five / Subscript Digit Five \\
\hline
U+02086 & ₆ & {\textbackslash}\_6 & Subscript Six / Subscript Digit Six \\
\hline
U+02087 & ₇ & {\textbackslash}\_7 & Subscript Seven / Subscript Digit Seven \\
\hline
U+02088 & ₈ & {\textbackslash}\_8 & Subscript Eight / Subscript Digit Eight \\
\hline
U+02089 & ₉ & {\textbackslash}\_9 & Subscript Nine / Subscript Digit Nine \\
\hline
U+0208A & ₊ & {\textbackslash}\_+ & Subscript Plus Sign \\
\hline
U+0208B & ₋ & {\textbackslash}\_- & Subscript Minus / Subscript Hyphen-minus \\
\hline
U+0208C & ₌ & {\textbackslash}\_= & Subscript Equals Sign \\
\hline
U+0208D & ₍ & {\textbackslash}\_( & Subscript Left Parenthesis / Subscript Opening Parenthesis \\
\hline
U+0208E & ₎ & {\textbackslash}\_) & Subscript Right Parenthesis / Subscript Closing Parenthesis \\
\hline
U+02090 & ₐ & {\textbackslash}\_a & Latin Subscript Small Letter A \\
\hline
U+02091 & ₑ & {\textbackslash}\_e & Latin Subscript Small Letter E \\
\hline
U+02092 & ₒ & {\textbackslash}\_o & Latin Subscript Small Letter O \\
\hline
U+02093 & ₓ & {\textbackslash}\_x & Latin Subscript Small Letter X \\
\hline
U+02094 & ₔ & {\textbackslash}\_schwa & Latin Subscript Small Letter Schwa \\
\hline
U+02095 & ₕ & {\textbackslash}\_h & Latin Subscript Small Letter H \\
\hline
U+02096 & ₖ & {\textbackslash}\_k & Latin Subscript Small Letter K \\
\hline
U+02097 & ₗ & {\textbackslash}\_l & Latin Subscript Small Letter L \\
\hline
U+02098 & ₘ & {\textbackslash}\_m & Latin Subscript Small Letter M \\
\hline
U+02099 & ₙ & {\textbackslash}\_n & Latin Subscript Small Letter N \\
\hline
U+0209A & ₚ & {\textbackslash}\_p & Latin Subscript Small Letter P \\
\hline
U+0209B & ₛ & {\textbackslash}\_s & Latin Subscript Small Letter S \\
\hline
U+0209C & ₜ & {\textbackslash}\_t & Latin Subscript Small Letter T \\
\hline
U+020A7 & ₧ & {\textbackslash}Elzpes & Peseta Sign \\
\hline
U+020AC & € & {\textbackslash}euro & Euro Sign \\
\hline
U+020D0 & ◌⃐ & {\textbackslash}leftharpoonaccent & Combining Left Harpoon Above / Non-spacing Left Harpoon Above \\
\hline
U+020D1 & ◌⃑ & {\textbackslash}rightharpoonaccent & Combining Right Harpoon Above / Non-spacing Right Harpoon Above \\
\hline
U+020D2 & ◌⃒ & {\textbackslash}vertoverlay & Combining Long Vertical Line Overlay / Non-spacing Long Vertical Bar Overlay \\
\hline
U+020D6 & ◌⃖ & {\textbackslash}overleftarrow & Combining Left Arrow Above / Non-spacing Left Arrow Above \\
\hline
U+020D7 & ◌⃗ & {\textbackslash}vec & Combining Right Arrow Above / Non-spacing Right Arrow Above \\
\hline
U+020DB & ◌⃛ & {\textbackslash}dddot & Combining Three Dots Above / Non-spacing Three Dots Above \\
\hline
U+020DC & ◌⃜ & {\textbackslash}ddddot & Combining Four Dots Above / Non-spacing Four Dots Above \\
\hline
U+020DD & ◌⃝ & {\textbackslash}enclosecircle & Combining Enclosing Circle / Enclosing Circle \\
\hline
U+020DE & ◌⃞ & {\textbackslash}enclosesquare & Combining Enclosing Square / Enclosing Square \\
\hline
U+020DF & ◌⃟ & {\textbackslash}enclosediamond & Combining Enclosing Diamond / Enclosing Diamond \\
\hline
U+020E1 & ◌⃡ & {\textbackslash}overleftrightarrow & Combining Left Right Arrow Above / Non-spacing Left Right Arrow Above \\
\hline
U+020E4 & ◌⃤ & {\textbackslash}enclosetriangle & Combining Enclosing Upward Pointing Triangle \\
\hline
U+020E7 & ◌⃧ & {\textbackslash}annuity & Combining Annuity Symbol \\
\hline
U+020E8 & ◌⃨ & {\textbackslash}threeunderdot & Combining Triple Underdot \\
\hline
U+020E9 & ◌⃩ & {\textbackslash}widebridgeabove & Combining Wide Bridge Above \\
\hline
U+020EC & ◌⃬ & {\textbackslash}underrightharpoondown & Combining Rightwards Harpoon With Barb Downwards \\
\hline
U+020ED & ◌⃭ & {\textbackslash}underleftharpoondown & Combining Leftwards Harpoon With Barb Downwards \\
\hline
U+020EE & ◌⃮ & {\textbackslash}underleftarrow & Combining Left Arrow Below \\
\hline
U+020EF & ◌⃯ & {\textbackslash}underrightarrow & Combining Right Arrow Below \\
\hline
U+020F0 & ◌⃰ & {\textbackslash}asteraccent & Combining Asterisk Above \\
\hline
U+02102 & ℂ & {\textbackslash}BbbC & Double-struck Capital C / Double-struck C \\
\hline
U+02107 & ℇ & {\textbackslash}Eulerconst & Euler Constant / Eulers \\
\hline
U+0210A & ℊ & {\textbackslash}mscrg & Script Small G \\
\hline
U+0210B & ℋ & {\textbackslash}mscrH & Script Capital H / Script H \\
\hline
U+0210C & ℌ & {\textbackslash}mfrakH & Black-letter Capital H / Black-letter H \\
\hline
U+0210D & ℍ & {\textbackslash}BbbH & Double-struck Capital H / Double-struck H \\
\hline
U+0210E & ℎ & {\textbackslash}Planckconst & Planck Constant \\
\hline
U+0210F & ℏ & {\textbackslash}hslash & Planck Constant Over Two Pi / Planck Constant Over 2 Pi \\
\hline
U+02110 & ℐ & {\textbackslash}mscrI & Script Capital I / Script I \\
\hline
U+02111 & ℑ & {\textbackslash}Im & Black-letter Capital I / Black-letter I \\
\hline
U+02112 & ℒ & {\textbackslash}mscrL & Script Capital L / Script L \\
\hline
U+02113 & ℓ & {\textbackslash}ell & Script Small L \\
\hline
U+02115 & ℕ & {\textbackslash}BbbN & Double-struck Capital N / Double-struck N \\
\hline
U+02116 & № & {\textbackslash}textnumero & Numero Sign / Numero \\
\hline
U+02118 & ℘ & {\textbackslash}wp & Script Capital P / Script P \\
\hline
U+02119 & ℙ & {\textbackslash}BbbP & Double-struck Capital P / Double-struck P \\
\hline
U+0211A & ℚ & {\textbackslash}BbbQ & Double-struck Capital Q / Double-struck Q \\
\hline
U+0211B & ℛ & {\textbackslash}mscrR & Script Capital R / Script R \\
\hline
U+0211C & ℜ & {\textbackslash}Re & Black-letter Capital R / Black-letter R \\
\hline
U+0211D & ℝ & {\textbackslash}BbbR & Double-struck Capital R / Double-struck R \\
\hline
U+0211E & ℞ & {\textbackslash}Elzxrat & Prescription Take \\
\hline
U+02122 & ™ & {\textbackslash}texttrademark, {\textbackslash}:tm: & Trade Mark Sign / Trademark \\
\hline
U+02124 & ℤ & {\textbackslash}BbbZ & Double-struck Capital Z / Double-struck Z \\
\hline
U+02127 & ℧ & {\textbackslash}mho & Inverted Ohm Sign / Mho \\
\hline
U+02128 & ℨ & {\textbackslash}mfrakZ & Black-letter Capital Z / Black-letter Z \\
\hline
U+02129 & ℩ & {\textbackslash}turnediota & Turned Greek Small Letter Iota \\
\hline
U+0212B & Å & {\textbackslash}Angstrom & Angstrom Sign / Angstrom Unit \\
\hline
U+0212C & ℬ & {\textbackslash}mscrB & Script Capital B / Script B \\
\hline
U+0212D & ℭ & {\textbackslash}mfrakC & Black-letter Capital C / Black-letter C \\
\hline
U+0212F & ℯ & {\textbackslash}mscre & Script Small E \\
\hline
U+02130 & ℰ & {\textbackslash}mscrE & Script Capital E / Script E \\
\hline
U+02131 & ℱ & {\textbackslash}mscrF & Script Capital F / Script F \\
\hline
U+02132 & Ⅎ & {\textbackslash}Finv & Turned Capital F / Turned F \\
\hline
U+02133 & ℳ & {\textbackslash}mscrM & Script Capital M / Script M \\
\hline
U+02134 & ℴ & {\textbackslash}mscro & Script Small O \\
\hline
U+02135 & ℵ & {\textbackslash}aleph & Alef Symbol / First Transfinite Cardinal \\
\hline
U+02136 & ℶ & {\textbackslash}beth & Bet Symbol / Second Transfinite Cardinal \\
\hline
U+02137 & ℷ & {\textbackslash}gimel & Gimel Symbol / Third Transfinite Cardinal \\
\hline
U+02138 & ℸ & {\textbackslash}daleth & Dalet Symbol / Fourth Transfinite Cardinal \\
\hline
U+02139 & ℹ & {\textbackslash}:information\_source: & Information Source \\
\hline
U+0213C & ℼ & {\textbackslash}Bbbpi & Double-struck Small Pi \\
\hline
U+0213D & ℽ & {\textbackslash}Bbbgamma & Double-struck Small Gamma \\
\hline
U+0213E & ℾ & {\textbackslash}BbbGamma & Double-struck Capital Gamma \\
\hline
U+0213F & ℿ & {\textbackslash}BbbPi & Double-struck Capital Pi \\
\hline
U+02140 & ⅀ & {\textbackslash}bbsum & Double-struck N-ary Summation \\
\hline
U+02141 & ⅁ & {\textbackslash}Game & Turned Sans-serif Capital G \\
\hline
U+02142 & ⅂ & {\textbackslash}sansLturned & Turned Sans-serif Capital L \\
\hline
U+02143 & ⅃ & {\textbackslash}sansLmirrored & Reversed Sans-serif Capital L \\
\hline
U+02144 & ⅄ & {\textbackslash}Yup & Turned Sans-serif Capital Y \\
\hline
U+02145 & ⅅ & {\textbackslash}mitBbbD & Double-struck Italic Capital D \\
\hline
U+02146 & ⅆ & {\textbackslash}mitBbbd & Double-struck Italic Small D \\
\hline
U+02147 & ⅇ & {\textbackslash}mitBbbe & Double-struck Italic Small E \\
\hline
U+02148 & ⅈ & {\textbackslash}mitBbbi & Double-struck Italic Small I \\
\hline
U+02149 & ⅉ & {\textbackslash}mitBbbj & Double-struck Italic Small J \\
\hline
U+0214A & ⅊ & {\textbackslash}PropertyLine & Property Line \\
\hline
U+0214B & ⅋ & {\textbackslash}upand & Turned Ampersand \\
\hline
U+02190 & ← & {\textbackslash}leftarrow & Leftwards Arrow / Left Arrow \\
\hline
U+02191 & ↑ & {\textbackslash}uparrow & Upwards Arrow / Up Arrow \\
\hline
U+02192 & → & {\textbackslash}to, {\textbackslash}rightarrow & Rightwards Arrow / Right Arrow \\
\hline
U+02193 & ↓ & {\textbackslash}downarrow & Downwards Arrow / Down Arrow \\
\hline
U+02194 & ↔ & {\textbackslash}leftrightarrow, {\textbackslash}:left\_right\_arrow: & Left Right Arrow \\
\hline
U+02195 & ↕ & {\textbackslash}updownarrow, {\textbackslash}:arrow\_up\_down: & Up Down Arrow \\
\hline
U+02196 & ↖ & {\textbackslash}nwarrow, {\textbackslash}:arrow\_upper\_left: & North West Arrow / Upper Left Arrow \\
\hline
U+02197 & ↗ & {\textbackslash}nearrow, {\textbackslash}:arrow\_upper\_right: & North East Arrow / Upper Right Arrow \\
\hline
U+02198 & ↘ & {\textbackslash}searrow, {\textbackslash}:arrow\_lower\_right: & South East Arrow / Lower Right Arrow \\
\hline
U+02199 & ↙ & {\textbackslash}swarrow, {\textbackslash}:arrow\_lower\_left: & South West Arrow / Lower Left Arrow \\
\hline
U+0219A & ↚ & {\textbackslash}nleftarrow & Leftwards Arrow With Stroke / Left Arrow With Stroke \\
\hline
U+0219B & ↛ & {\textbackslash}nrightarrow & Rightwards Arrow With Stroke / Right Arrow With Stroke \\
\hline
U+0219C & ↜ & {\textbackslash}leftwavearrow & Leftwards Wave Arrow / Left Wave Arrow \\
\hline
U+0219D & ↝ & {\textbackslash}rightwavearrow & Rightwards Wave Arrow / Right Wave Arrow \\
\hline
U+0219E & ↞ & {\textbackslash}twoheadleftarrow & Leftwards Two Headed Arrow / Left Two Headed Arrow \\
\hline
U+0219F & ↟ & {\textbackslash}twoheaduparrow & Upwards Two Headed Arrow / Up Two Headed Arrow \\
\hline
U+021A0 & ↠ & {\textbackslash}twoheadrightarrow & Rightwards Two Headed Arrow / Right Two Headed Arrow \\
\hline
U+021A1 & ↡ & {\textbackslash}twoheaddownarrow & Downwards Two Headed Arrow / Down Two Headed Arrow \\
\hline
U+021A2 & ↢ & {\textbackslash}leftarrowtail & Leftwards Arrow With Tail / Left Arrow With Tail \\
\hline
U+021A3 & ↣ & {\textbackslash}rightarrowtail & Rightwards Arrow With Tail / Right Arrow With Tail \\
\hline
U+021A4 & ↤ & {\textbackslash}mapsfrom & Leftwards Arrow From Bar / Left Arrow From Bar \\
\hline
U+021A5 & ↥ & {\textbackslash}mapsup & Upwards Arrow From Bar / Up Arrow From Bar \\
\hline
U+021A6 & ↦ & {\textbackslash}mapsto & Rightwards Arrow From Bar / Right Arrow From Bar \\
\hline
U+021A7 & ↧ & {\textbackslash}mapsdown & Downwards Arrow From Bar / Down Arrow From Bar \\
\hline
U+021A8 & ↨ & {\textbackslash}updownarrowbar & Up Down Arrow With Base \\
\hline
U+021A9 & ↩ & {\textbackslash}hookleftarrow, {\textbackslash}:leftwards\_arrow\_with\_hook: & Leftwards Arrow With Hook / Left Arrow With Hook \\
\hline
U+021AA & ↪ & {\textbackslash}hookrightarrow, {\textbackslash}:arrow\_right\_hook: & Rightwards Arrow With Hook / Right Arrow With Hook \\
\hline
U+021AB & ↫ & {\textbackslash}looparrowleft & Leftwards Arrow With Loop / Left Arrow With Loop \\
\hline
U+021AC & ↬ & {\textbackslash}looparrowright & Rightwards Arrow With Loop / Right Arrow With Loop \\
\hline
U+021AD & ↭ & {\textbackslash}leftrightsquigarrow & Left Right Wave Arrow \\
\hline
U+021AE & ↮ & {\textbackslash}nleftrightarrow & Left Right Arrow With Stroke \\
\hline
U+021AF & ↯ & {\textbackslash}downzigzagarrow & Downwards Zigzag Arrow / Down Zigzag Arrow \\
\hline
U+021B0 & ↰ & {\textbackslash}Lsh & Upwards Arrow With Tip Leftwards / Up Arrow With Tip Left \\
\hline
U+021B1 & ↱ & {\textbackslash}Rsh & Upwards Arrow With Tip Rightwards / Up Arrow With Tip Right \\
\hline
U+021B2 & ↲ & {\textbackslash}Ldsh & Downwards Arrow With Tip Leftwards / Down Arrow With Tip Left \\
\hline
U+021B3 & ↳ & {\textbackslash}Rdsh & Downwards Arrow With Tip Rightwards / Down Arrow With Tip Right \\
\hline
U+021B4 & ↴ & {\textbackslash}linefeed & Rightwards Arrow With Corner Downwards / Right Arrow With Corner Down \\
\hline
U+021B5 & ↵ & {\textbackslash}carriagereturn & Downwards Arrow With Corner Leftwards / Down Arrow With Corner Left \\
\hline
U+021B6 & ↶ & {\textbackslash}curvearrowleft & Anticlockwise Top Semicircle Arrow \\
\hline
U+021B7 & ↷ & {\textbackslash}curvearrowright & Clockwise Top Semicircle Arrow \\
\hline
U+021B8 & ↸ & {\textbackslash}barovernorthwestarrow & North West Arrow To Long Bar / Upper Left Arrow To Long Bar \\
\hline
U+021B9 & ↹ & {\textbackslash}barleftarrowrightarrowbar & Leftwards Arrow To Bar Over Rightwards Arrow To Bar / Left Arrow To Bar Over Right Arrow To Bar \\
\hline
U+021BA & ↺ & {\textbackslash}circlearrowleft & Anticlockwise Open Circle Arrow \\
\hline
U+021BB & ↻ & {\textbackslash}circlearrowright & Clockwise Open Circle Arrow \\
\hline
U+021BC & ↼ & {\textbackslash}leftharpoonup & Leftwards Harpoon With Barb Upwards / Left Harpoon With Barb Up \\
\hline
U+021BD & ↽ & {\textbackslash}leftharpoondown & Leftwards Harpoon With Barb Downwards / Left Harpoon With Barb Down \\
\hline
U+021BE & ↾ & {\textbackslash}upharpoonleft & Upwards Harpoon With Barb Rightwards / Up Harpoon With Barb Right \\
\hline
U+021BF & ↿ & {\textbackslash}upharpoonright & Upwards Harpoon With Barb Leftwards / Up Harpoon With Barb Left \\
\hline
U+021C0 & ⇀ & {\textbackslash}rightharpoonup & Rightwards Harpoon With Barb Upwards / Right Harpoon With Barb Up \\
\hline
U+021C1 & ⇁ & {\textbackslash}rightharpoondown & Rightwards Harpoon With Barb Downwards / Right Harpoon With Barb Down \\
\hline
U+021C2 & ⇂ & {\textbackslash}downharpoonright & Downwards Harpoon With Barb Rightwards / Down Harpoon With Barb Right \\
\hline
U+021C3 & ⇃ & {\textbackslash}downharpoonleft & Downwards Harpoon With Barb Leftwards / Down Harpoon With Barb Left \\
\hline
U+021C4 & ⇄ & {\textbackslash}rightleftarrows & Rightwards Arrow Over Leftwards Arrow / Right Arrow Over Left Arrow \\
\hline
U+021C5 & ⇅ & {\textbackslash}dblarrowupdown & Upwards Arrow Leftwards Of Downwards Arrow / Up Arrow Left Of Down Arrow \\
\hline
U+021C6 & ⇆ & {\textbackslash}leftrightarrows & Leftwards Arrow Over Rightwards Arrow / Left Arrow Over Right Arrow \\
\hline
U+021C7 & ⇇ & {\textbackslash}leftleftarrows & Leftwards Paired Arrows / Left Paired Arrows \\
\hline
U+021C8 & ⇈ & {\textbackslash}upuparrows & Upwards Paired Arrows / Up Paired Arrows \\
\hline
U+021C9 & ⇉ & {\textbackslash}rightrightarrows & Rightwards Paired Arrows / Right Paired Arrows \\
\hline
U+021CA & ⇊ & {\textbackslash}downdownarrows & Downwards Paired Arrows / Down Paired Arrows \\
\hline
U+021CB & ⇋ & {\textbackslash}leftrightharpoons & Leftwards Harpoon Over Rightwards Harpoon / Left Harpoon Over Right Harpoon \\
\hline
U+021CC & ⇌ & {\textbackslash}rightleftharpoons & Rightwards Harpoon Over Leftwards Harpoon / Right Harpoon Over Left Harpoon \\
\hline
U+021CD & ⇍ & {\textbackslash}nLeftarrow & Leftwards Double Arrow With Stroke / Left Double Arrow With Stroke \\
\hline
U+021CE & ⇎ & {\textbackslash}nLeftrightarrow & Left Right Double Arrow With Stroke \\
\hline
U+021CF & ⇏ & {\textbackslash}nRightarrow & Rightwards Double Arrow With Stroke / Right Double Arrow With Stroke \\
\hline
U+021D0 & ⇐ & {\textbackslash}Leftarrow & Leftwards Double Arrow / Left Double Arrow \\
\hline
U+021D1 & ⇑ & {\textbackslash}Uparrow & Upwards Double Arrow / Up Double Arrow \\
\hline
U+021D2 & ⇒ & {\textbackslash}Rightarrow & Rightwards Double Arrow / Right Double Arrow \\
\hline
U+021D3 & ⇓ & {\textbackslash}Downarrow & Downwards Double Arrow / Down Double Arrow \\
\hline
U+021D4 & ⇔ & {\textbackslash}Leftrightarrow & Left Right Double Arrow \\
\hline
U+021D5 & ⇕ & {\textbackslash}Updownarrow & Up Down Double Arrow \\
\hline
U+021D6 & ⇖ & {\textbackslash}Nwarrow & North West Double Arrow / Upper Left Double Arrow \\
\hline
U+021D7 & ⇗ & {\textbackslash}Nearrow & North East Double Arrow / Upper Right Double Arrow \\
\hline
U+021D8 & ⇘ & {\textbackslash}Searrow & South East Double Arrow / Lower Right Double Arrow \\
\hline
U+021D9 & ⇙ & {\textbackslash}Swarrow & South West Double Arrow / Lower Left Double Arrow \\
\hline
U+021DA & ⇚ & {\textbackslash}Lleftarrow & Leftwards Triple Arrow / Left Triple Arrow \\
\hline
U+021DB & ⇛ & {\textbackslash}Rrightarrow & Rightwards Triple Arrow / Right Triple Arrow \\
\hline
U+021DC & ⇜ & {\textbackslash}leftsquigarrow & Leftwards Squiggle Arrow / Left Squiggle Arrow \\
\hline
U+021DD & ⇝ & {\textbackslash}rightsquigarrow & Rightwards Squiggle Arrow / Right Squiggle Arrow \\
\hline
U+021DE & ⇞ & {\textbackslash}nHuparrow & Upwards Arrow With Double Stroke / Up Arrow With Double Stroke \\
\hline
U+021DF & ⇟ & {\textbackslash}nHdownarrow & Downwards Arrow With Double Stroke / Down Arrow With Double Stroke \\
\hline
U+021E0 & ⇠ & {\textbackslash}leftdasharrow & Leftwards Dashed Arrow / Left Dashed Arrow \\
\hline
U+021E1 & ⇡ & {\textbackslash}updasharrow & Upwards Dashed Arrow / Up Dashed Arrow \\
\hline
U+021E2 & ⇢ & {\textbackslash}rightdasharrow & Rightwards Dashed Arrow / Right Dashed Arrow \\
\hline
U+021E3 & ⇣ & {\textbackslash}downdasharrow & Downwards Dashed Arrow / Down Dashed Arrow \\
\hline
U+021E4 & ⇤ & {\textbackslash}barleftarrow & Leftwards Arrow To Bar / Left Arrow To Bar \\
\hline
U+021E5 & ⇥ & {\textbackslash}rightarrowbar & Rightwards Arrow To Bar / Right Arrow To Bar \\
\hline
U+021E6 & ⇦ & {\textbackslash}leftwhitearrow & Leftwards White Arrow / White Left Arrow \\
\hline
U+021E7 & ⇧ & {\textbackslash}upwhitearrow & Upwards White Arrow / White Up Arrow \\
\hline
U+021E8 & ⇨ & {\textbackslash}rightwhitearrow & Rightwards White Arrow / White Right Arrow \\
\hline
U+021E9 & ⇩ & {\textbackslash}downwhitearrow & Downwards White Arrow / White Down Arrow \\
\hline
U+021EA & ⇪ & {\textbackslash}whitearrowupfrombar & Upwards White Arrow From Bar / White Up Arrow From Bar \\
\hline
U+021F4 & ⇴ & {\textbackslash}circleonrightarrow & Right Arrow With Small Circle \\
\hline
U+021F5 & ⇵ & {\textbackslash}DownArrowUpArrow & Downwards Arrow Leftwards Of Upwards Arrow \\
\hline
U+021F6 & ⇶ & {\textbackslash}rightthreearrows & Three Rightwards Arrows \\
\hline
U+021F7 & ⇷ & {\textbackslash}nvleftarrow & Leftwards Arrow With Vertical Stroke \\
\hline
U+021F8 & ⇸ & {\textbackslash}nvrightarrow & Rightwards Arrow With Vertical Stroke \\
\hline
U+021F9 & ⇹ & {\textbackslash}nvleftrightarrow & Left Right Arrow With Vertical Stroke \\
\hline
U+021FA & ⇺ & {\textbackslash}nVleftarrow & Leftwards Arrow With Double Vertical Stroke \\
\hline
U+021FB & ⇻ & {\textbackslash}nVrightarrow & Rightwards Arrow With Double Vertical Stroke \\
\hline
U+021FC & ⇼ & {\textbackslash}nVleftrightarrow & Left Right Arrow With Double Vertical Stroke \\
\hline
U+021FD & ⇽ & {\textbackslash}leftarrowtriangle & Leftwards Open-headed Arrow \\
\hline
U+021FE & ⇾ & {\textbackslash}rightarrowtriangle & Rightwards Open-headed Arrow \\
\hline
U+021FF & ⇿ & {\textbackslash}leftrightarrowtriangle & Left Right Open-headed Arrow \\
\hline
U+02200 & ∀ & {\textbackslash}forall & For All \\
\hline
U+02201 & ∁ & {\textbackslash}complement & Complement \\
\hline
U+02202 & ∂ & {\textbackslash}partial & Partial Differential \\
\hline
U+02203 & ∃ & {\textbackslash}exists & There Exists \\
\hline
U+02204 & ∄ & {\textbackslash}nexists & There Does Not Exist \\
\hline
U+02205 & ∅ & {\textbackslash}varnothing, {\textbackslash}emptyset & Empty Set \\
\hline
U+02206 & ∆ & {\textbackslash}increment & Increment \\
\hline
U+02207 & ∇ & {\textbackslash}del, {\textbackslash}nabla & Nabla \\
\hline
U+02208 & ∈ & {\textbackslash}in & Element Of \\
\hline
U+02209 & ∉ & {\textbackslash}notin & Not An Element Of \\
\hline
U+0220A & ∊ & {\textbackslash}smallin & Small Element Of \\
\hline
U+0220B & ∋ & {\textbackslash}ni & Contains As Member \\
\hline
U+0220C & ∌ & {\textbackslash}nni & Does Not Contain As Member \\
\hline
U+0220D & ∍ & {\textbackslash}smallni & Small Contains As Member \\
\hline
U+0220E & ∎ & {\textbackslash}QED & End Of Proof \\
\hline
U+0220F & ∏ & {\textbackslash}prod & N-ary Product \\
\hline
U+02210 & ∐ & {\textbackslash}coprod & N-ary Coproduct \\
\hline
U+02211 & ∑ & {\textbackslash}sum & N-ary Summation \\
\hline
U+02212 & − & {\textbackslash}minus & Minus Sign \\
\hline
U+02213 & ∓ & {\textbackslash}mp & Minus-or-plus Sign \\
\hline
U+02214 & ∔ & {\textbackslash}dotplus & Dot Plus \\
\hline
U+02216 & ∖ & {\textbackslash}setminus & Set Minus \\
\hline
U+02217 & ∗ & {\textbackslash}ast & Asterisk Operator \\
\hline
U+02218 & ∘ & {\textbackslash}circ & Ring Operator \\
\hline
U+02219 & ∙ & {\textbackslash}vysmblkcircle & Bullet Operator \\
\hline
U+0221A & √ & {\textbackslash}surd, {\textbackslash}sqrt & Square Root \\
\hline
U+0221B & ∛ & {\textbackslash}cbrt & Cube Root \\
\hline
U+0221C & ∜ & {\textbackslash}fourthroot & Fourth Root \\
\hline
U+0221D & ∝ & {\textbackslash}propto & Proportional To \\
\hline
U+0221E & ∞ & {\textbackslash}infty & Infinity \\
\hline
U+0221F & ∟ & {\textbackslash}rightangle & Right Angle \\
\hline
U+02220 & ∠ & {\textbackslash}angle & Angle \\
\hline
U+02221 & ∡ & {\textbackslash}measuredangle & Measured Angle \\
\hline
U+02222 & ∢ & {\textbackslash}sphericalangle & Spherical Angle \\
\hline
U+02223 & ∣ & {\textbackslash}mid & Divides \\
\hline
U+02224 & ∤ & {\textbackslash}nmid & Does Not Divide \\
\hline
U+02225 & ∥ & {\textbackslash}parallel & Parallel To \\
\hline
U+02226 & ∦ & {\textbackslash}nparallel & Not Parallel To \\
\hline
U+02227 & ∧ & {\textbackslash}wedge & Logical And \\
\hline
U+02228 & ∨ & {\textbackslash}vee & Logical Or \\
\hline
U+02229 & ∩ & {\textbackslash}cap & Intersection \\
\hline
U+0222A & ∪ & {\textbackslash}cup & Union \\
\hline
U+0222B & ∫ & {\textbackslash}int & Integral \\
\hline
U+0222C & ∬ & {\textbackslash}iint & Double Integral \\
\hline
U+0222D & ∭ & {\textbackslash}iiint & Triple Integral \\
\hline
U+0222E & ∮ & {\textbackslash}oint & Contour Integral \\
\hline
U+0222F & ∯ & {\textbackslash}oiint & Surface Integral \\
\hline
U+02230 & ∰ & {\textbackslash}oiiint & Volume Integral \\
\hline
U+02231 & ∱ & {\textbackslash}clwintegral & Clockwise Integral \\
\hline
U+02232 & ∲ & {\textbackslash}varointclockwise & Clockwise Contour Integral \\
\hline
U+02233 & ∳ & {\textbackslash}ointctrclockwise & Anticlockwise Contour Integral \\
\hline
U+02234 & ∴ & {\textbackslash}therefore & Therefore \\
\hline
U+02235 & ∵ & {\textbackslash}because & Because \\
\hline
U+02237 & ∷ & {\textbackslash}Colon & Proportion \\
\hline
U+02238 & ∸ & {\textbackslash}dotminus & Dot Minus \\
\hline
U+0223A & ∺ & {\textbackslash}dotsminusdots & Geometric Proportion \\
\hline
U+0223B & ∻ & {\textbackslash}kernelcontraction & Homothetic \\
\hline
U+0223C & ∼ & {\textbackslash}sim & Tilde Operator \\
\hline
U+0223D & ∽ & {\textbackslash}backsim & Reversed Tilde \\
\hline
U+0223E & ∾ & {\textbackslash}lazysinv & Inverted Lazy S \\
\hline
U+0223F & ∿ & {\textbackslash}sinewave & Sine Wave \\
\hline
U+02240 & ≀ & {\textbackslash}wr & Wreath Product \\
\hline
U+02241 & ≁ & {\textbackslash}nsim & Not Tilde \\
\hline
U+02242 & ≂ & {\textbackslash}eqsim & Minus Tilde \\
\hline
U+02242 + U+00338 & ≂̸ & {\textbackslash}neqsim & Minus Tilde + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02243 & ≃ & {\textbackslash}simeq & Asymptotically Equal To \\
\hline
U+02244 & ≄ & {\textbackslash}nsime & Not Asymptotically Equal To \\
\hline
U+02245 & ≅ & {\textbackslash}cong & Approximately Equal To \\
\hline
U+02246 & ≆ & {\textbackslash}approxnotequal & Approximately But Not Actually Equal To \\
\hline
U+02247 & ≇ & {\textbackslash}ncong & Neither Approximately Nor Actually Equal To \\
\hline
U+02248 & ≈ & {\textbackslash}approx & Almost Equal To \\
\hline
U+02249 & ≉ & {\textbackslash}napprox & Not Almost Equal To \\
\hline
U+0224A & ≊ & {\textbackslash}approxeq & Almost Equal Or Equal To \\
\hline
U+0224B & ≋ & {\textbackslash}tildetrpl & Triple Tilde \\
\hline
U+0224C & ≌ & {\textbackslash}allequal & All Equal To \\
\hline
U+0224D & ≍ & {\textbackslash}asymp & Equivalent To \\
\hline
U+0224E & ≎ & {\textbackslash}Bumpeq & Geometrically Equivalent To \\
\hline
U+0224E + U+00338 & ≎̸ & {\textbackslash}nBumpeq & Geometrically Equivalent To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0224F & ≏ & {\textbackslash}bumpeq & Difference Between \\
\hline
U+0224F + U+00338 & ≏̸ & {\textbackslash}nbumpeq & Difference Between + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02250 & ≐ & {\textbackslash}doteq & Approaches The Limit \\
\hline
U+02251 & ≑ & {\textbackslash}Doteq & Geometrically Equal To \\
\hline
U+02252 & ≒ & {\textbackslash}fallingdotseq & Approximately Equal To Or The Image Of \\
\hline
U+02253 & ≓ & {\textbackslash}risingdotseq & Image Of Or Approximately Equal To \\
\hline
U+02254 & ≔ & {\textbackslash}coloneq & Colon Equals / Colon Equal \\
\hline
U+02255 & ≕ & {\textbackslash}eqcolon & Equals Colon / Equal Colon \\
\hline
U+02256 & ≖ & {\textbackslash}eqcirc & Ring In Equal To \\
\hline
U+02257 & ≗ & {\textbackslash}circeq & Ring Equal To \\
\hline
U+02258 & ≘ & {\textbackslash}arceq & Corresponds To \\
\hline
U+02259 & ≙ & {\textbackslash}wedgeq & Estimates \\
\hline
U+0225A & ≚ & {\textbackslash}veeeq & Equiangular To \\
\hline
U+0225B & ≛ & {\textbackslash}starequal & Star Equals \\
\hline
U+0225C & ≜ & {\textbackslash}triangleq & Delta Equal To \\
\hline
U+0225D & ≝ & {\textbackslash}eqdef & Equal To By Definition \\
\hline
U+0225E & ≞ & {\textbackslash}measeq & Measured By \\
\hline
U+0225F & ≟ & {\textbackslash}questeq & Questioned Equal To \\
\hline
U+02260 & ≠ & {\textbackslash}ne & Not Equal To \\
\hline
U+02261 & ≡ & {\textbackslash}equiv & Identical To \\
\hline
U+02262 & ≢ & {\textbackslash}nequiv & Not Identical To \\
\hline
U+02263 & ≣ & {\textbackslash}Equiv & Strictly Equivalent To \\
\hline
U+02264 & ≤ & {\textbackslash}le & Less-than Or Equal To / Less Than Or Equal To \\
\hline
U+02265 & ≥ & {\textbackslash}ge & Greater-than Or Equal To / Greater Than Or Equal To \\
\hline
U+02266 & ≦ & {\textbackslash}leqq & Less-than Over Equal To / Less Than Over Equal To \\
\hline
U+02267 & ≧ & {\textbackslash}geqq & Greater-than Over Equal To / Greater Than Over Equal To \\
\hline
U+02268 & ≨ & {\textbackslash}lneqq & Less-than But Not Equal To / Less Than But Not Equal To \\
\hline
U+02268 + U+0FE00 & ≨︀ & {\textbackslash}lvertneqq & Less-than But Not Equal To / Less Than But Not Equal To + Variation Selector-1 \\
\hline
U+02269 & ≩ & {\textbackslash}gneqq & Greater-than But Not Equal To / Greater Than But Not Equal To \\
\hline
U+02269 + U+0FE00 & ≩︀ & {\textbackslash}gvertneqq & Greater-than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1 \\
\hline
U+0226A & ≪ & {\textbackslash}ll & Much Less-than / Much Less Than \\
\hline
U+0226A + U+00338 & ≪̸ & {\textbackslash}NotLessLess & Much Less-than / Much Less Than + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0226B & ≫ & {\textbackslash}gg & Much Greater-than / Much Greater Than \\
\hline
U+0226B + U+00338 & ≫̸ & {\textbackslash}NotGreaterGreater & Much Greater-than / Much Greater Than + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0226C & ≬ & {\textbackslash}between & Between \\
\hline
U+0226D & ≭ & {\textbackslash}nasymp & Not Equivalent To \\
\hline
U+0226E & ≮ & {\textbackslash}nless & Not Less-than / Not Less Than \\
\hline
U+0226F & ≯ & {\textbackslash}ngtr & Not Greater-than / Not Greater Than \\
\hline
U+02270 & ≰ & {\textbackslash}nleq & Neither Less-than Nor Equal To / Neither Less Than Nor Equal To \\
\hline
U+02271 & ≱ & {\textbackslash}ngeq & Neither Greater-than Nor Equal To / Neither Greater Than Nor Equal To \\
\hline
U+02272 & ≲ & {\textbackslash}lesssim & Less-than Or Equivalent To / Less Than Or Equivalent To \\
\hline
U+02273 & ≳ & {\textbackslash}gtrsim & Greater-than Or Equivalent To / Greater Than Or Equivalent To \\
\hline
U+02274 & ≴ & {\textbackslash}nlesssim & Neither Less-than Nor Equivalent To / Neither Less Than Nor Equivalent To \\
\hline
U+02275 & ≵ & {\textbackslash}ngtrsim & Neither Greater-than Nor Equivalent To / Neither Greater Than Nor Equivalent To \\
\hline
U+02276 & ≶ & {\textbackslash}lessgtr & Less-than Or Greater-than / Less Than Or Greater Than \\
\hline
U+02277 & ≷ & {\textbackslash}gtrless & Greater-than Or Less-than / Greater Than Or Less Than \\
\hline
U+02278 & ≸ & {\textbackslash}notlessgreater & Neither Less-than Nor Greater-than / Neither Less Than Nor Greater Than \\
\hline
U+02279 & ≹ & {\textbackslash}notgreaterless & Neither Greater-than Nor Less-than / Neither Greater Than Nor Less Than \\
\hline
U+0227A & ≺ & {\textbackslash}prec & Precedes \\
\hline
U+0227B & ≻ & {\textbackslash}succ & Succeeds \\
\hline
U+0227C & ≼ & {\textbackslash}preccurlyeq & Precedes Or Equal To \\
\hline
U+0227D & ≽ & {\textbackslash}succcurlyeq & Succeeds Or Equal To \\
\hline
U+0227E & ≾ & {\textbackslash}precsim & Precedes Or Equivalent To \\
\hline
U+0227E + U+00338 & ≾̸ & {\textbackslash}nprecsim & Precedes Or Equivalent To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0227F & ≿ & {\textbackslash}succsim & Succeeds Or Equivalent To \\
\hline
U+0227F + U+00338 & ≿̸ & {\textbackslash}nsuccsim & Succeeds Or Equivalent To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02280 & ⊀ & {\textbackslash}nprec & Does Not Precede \\
\hline
U+02281 & ⊁ & {\textbackslash}nsucc & Does Not Succeed \\
\hline
U+02282 & ⊂ & {\textbackslash}subset & Subset Of \\
\hline
U+02283 & ⊃ & {\textbackslash}supset & Superset Of \\
\hline
U+02284 & ⊄ & {\textbackslash}nsubset & Not A Subset Of \\
\hline
U+02285 & ⊅ & {\textbackslash}nsupset & Not A Superset Of \\
\hline
U+02286 & ⊆ & {\textbackslash}subseteq & Subset Of Or Equal To \\
\hline
U+02287 & ⊇ & {\textbackslash}supseteq & Superset Of Or Equal To \\
\hline
U+02288 & ⊈ & {\textbackslash}nsubseteq & Neither A Subset Of Nor Equal To \\
\hline
U+02289 & ⊉ & {\textbackslash}nsupseteq & Neither A Superset Of Nor Equal To \\
\hline
U+0228A & ⊊ & {\textbackslash}subsetneq & Subset Of With Not Equal To / Subset Of Or Not Equal To \\
\hline
U+0228A + U+0FE00 & ⊊︀ & {\textbackslash}varsubsetneqq & Subset Of With Not Equal To / Subset Of Or Not Equal To + Variation Selector-1 \\
\hline
U+0228B & ⊋ & {\textbackslash}supsetneq & Superset Of With Not Equal To / Superset Of Or Not Equal To \\
\hline
U+0228B + U+0FE00 & ⊋︀ & {\textbackslash}varsupsetneq & Superset Of With Not Equal To / Superset Of Or Not Equal To + Variation Selector-1 \\
\hline
U+0228D & ⊍ & {\textbackslash}cupdot & Multiset Multiplication \\
\hline
U+0228E & ⊎ & {\textbackslash}uplus & Multiset Union \\
\hline
U+0228F & ⊏ & {\textbackslash}sqsubset & Square Image Of \\
\hline
U+0228F + U+00338 & ⊏̸ & {\textbackslash}NotSquareSubset & Square Image Of + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02290 & ⊐ & {\textbackslash}sqsupset & Square Original Of \\
\hline
U+02290 + U+00338 & ⊐̸ & {\textbackslash}NotSquareSuperset & Square Original Of + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02291 & ⊑ & {\textbackslash}sqsubseteq & Square Image Of Or Equal To \\
\hline
U+02292 & ⊒ & {\textbackslash}sqsupseteq & Square Original Of Or Equal To \\
\hline
U+02293 & ⊓ & {\textbackslash}sqcap & Square Cap \\
\hline
U+02294 & ⊔ & {\textbackslash}sqcup & Square Cup \\
\hline
U+02295 & ⊕ & {\textbackslash}oplus & Circled Plus \\
\hline
U+02296 & ⊖ & {\textbackslash}ominus & Circled Minus \\
\hline
U+02297 & ⊗ & {\textbackslash}otimes & Circled Times \\
\hline
U+02298 & ⊘ & {\textbackslash}oslash & Circled Division Slash \\
\hline
U+02299 & ⊙ & {\textbackslash}odot & Circled Dot Operator \\
\hline
U+0229A & ⊚ & {\textbackslash}circledcirc & Circled Ring Operator \\
\hline
U+0229B & ⊛ & {\textbackslash}circledast & Circled Asterisk Operator \\
\hline
U+0229C & ⊜ & {\textbackslash}circledequal & Circled Equals \\
\hline
U+0229D & ⊝ & {\textbackslash}circleddash & Circled Dash \\
\hline
U+0229E & ⊞ & {\textbackslash}boxplus & Squared Plus \\
\hline
U+0229F & ⊟ & {\textbackslash}boxminus & Squared Minus \\
\hline
U+022A0 & ⊠ & {\textbackslash}boxtimes & Squared Times \\
\hline
U+022A1 & ⊡ & {\textbackslash}boxdot & Squared Dot Operator \\
\hline
U+022A2 & ⊢ & {\textbackslash}vdash & Right Tack \\
\hline
U+022A3 & ⊣ & {\textbackslash}dashv & Left Tack \\
\hline
U+022A4 & ⊤ & {\textbackslash}top & Down Tack \\
\hline
U+022A5 & ⊥ & {\textbackslash}bot & Up Tack \\
\hline
U+022A7 & ⊧ & {\textbackslash}models & Models \\
\hline
U+022A8 & ⊨ & {\textbackslash}vDash & True \\
\hline
U+022A9 & ⊩ & {\textbackslash}Vdash & Forces \\
\hline
U+022AA & ⊪ & {\textbackslash}Vvdash & Triple Vertical Bar Right Turnstile \\
\hline
U+022AB & ⊫ & {\textbackslash}VDash & Double Vertical Bar Double Right Turnstile \\
\hline
U+022AC & ⊬ & {\textbackslash}nvdash & Does Not Prove \\
\hline
U+022AD & ⊭ & {\textbackslash}nvDash & Not True \\
\hline
U+022AE & ⊮ & {\textbackslash}nVdash & Does Not Force \\
\hline
U+022AF & ⊯ & {\textbackslash}nVDash & Negated Double Vertical Bar Double Right Turnstile \\
\hline
U+022B0 & ⊰ & {\textbackslash}prurel & Precedes Under Relation \\
\hline
U+022B1 & ⊱ & {\textbackslash}scurel & Succeeds Under Relation \\
\hline
U+022B2 & ⊲ & {\textbackslash}vartriangleleft & Normal Subgroup Of \\
\hline
U+022B3 & ⊳ & {\textbackslash}vartriangleright & Contains As Normal Subgroup \\
\hline
U+022B4 & ⊴ & {\textbackslash}trianglelefteq & Normal Subgroup Of Or Equal To \\
\hline
U+022B5 & ⊵ & {\textbackslash}trianglerighteq & Contains As Normal Subgroup Or Equal To \\
\hline
U+022B6 & ⊶ & {\textbackslash}original & Original Of \\
\hline
U+022B7 & ⊷ & {\textbackslash}image & Image Of \\
\hline
U+022B8 & ⊸ & {\textbackslash}multimap & Multimap \\
\hline
U+022B9 & ⊹ & {\textbackslash}hermitconjmatrix & Hermitian Conjugate Matrix \\
\hline
U+022BA & ⊺ & {\textbackslash}intercal & Intercalate \\
\hline
U+022BB & ⊻ & {\textbackslash}veebar, {\textbackslash}xor & Xor \\
\hline
U+022BC & ⊼ & {\textbackslash}barwedge & Nand \\
\hline
U+022BD & ⊽ & {\textbackslash}barvee & Nor \\
\hline
U+022BE & ⊾ & {\textbackslash}rightanglearc & Right Angle With Arc \\
\hline
U+022BF & ⊿ & {\textbackslash}varlrtriangle & Right Triangle \\
\hline
U+022C0 & ⋀ & {\textbackslash}bigwedge & N-ary Logical And \\
\hline
U+022C1 & ⋁ & {\textbackslash}bigvee & N-ary Logical Or \\
\hline
U+022C2 & ⋂ & {\textbackslash}bigcap & N-ary Intersection \\
\hline
U+022C3 & ⋃ & {\textbackslash}bigcup & N-ary Union \\
\hline
U+022C4 & ⋄ & {\textbackslash}diamond & Diamond Operator \\
\hline
U+022C5 & ⋅ & {\textbackslash}cdot & Dot Operator \\
\hline
U+022C6 & ⋆ & {\textbackslash}star & Star Operator \\
\hline
U+022C7 & ⋇ & {\textbackslash}divideontimes & Division Times \\
\hline
U+022C8 & ⋈ & {\textbackslash}bowtie & Bowtie \\
\hline
U+022C9 & ⋉ & {\textbackslash}ltimes & Left Normal Factor Semidirect Product \\
\hline
U+022CA & ⋊ & {\textbackslash}rtimes & Right Normal Factor Semidirect Product \\
\hline
U+022CB & ⋋ & {\textbackslash}leftthreetimes & Left Semidirect Product \\
\hline
U+022CC & ⋌ & {\textbackslash}rightthreetimes & Right Semidirect Product \\
\hline
U+022CD & ⋍ & {\textbackslash}backsimeq & Reversed Tilde Equals \\
\hline
U+022CE & ⋎ & {\textbackslash}curlyvee & Curly Logical Or \\
\hline
U+022CF & ⋏ & {\textbackslash}curlywedge & Curly Logical And \\
\hline
U+022D0 & ⋐ & {\textbackslash}Subset & Double Subset \\
\hline
U+022D1 & ⋑ & {\textbackslash}Supset & Double Superset \\
\hline
U+022D2 & ⋒ & {\textbackslash}Cap & Double Intersection \\
\hline
U+022D3 & ⋓ & {\textbackslash}Cup & Double Union \\
\hline
U+022D4 & ⋔ & {\textbackslash}pitchfork & Pitchfork \\
\hline
U+022D5 & ⋕ & {\textbackslash}equalparallel & Equal And Parallel To \\
\hline
U+022D6 & ⋖ & {\textbackslash}lessdot & Less-than With Dot / Less Than With Dot \\
\hline
U+022D7 & ⋗ & {\textbackslash}gtrdot & Greater-than With Dot / Greater Than With Dot \\
\hline
U+022D8 & ⋘ & {\textbackslash}verymuchless & Very Much Less-than / Very Much Less Than \\
\hline
U+022D9 & ⋙ & {\textbackslash}ggg & Very Much Greater-than / Very Much Greater Than \\
\hline
U+022DA & ⋚ & {\textbackslash}lesseqgtr & Less-than Equal To Or Greater-than / Less Than Equal To Or Greater Than \\
\hline
U+022DB & ⋛ & {\textbackslash}gtreqless & Greater-than Equal To Or Less-than / Greater Than Equal To Or Less Than \\
\hline
U+022DC & ⋜ & {\textbackslash}eqless & Equal To Or Less-than / Equal To Or Less Than \\
\hline
U+022DD & ⋝ & {\textbackslash}eqgtr & Equal To Or Greater-than / Equal To Or Greater Than \\
\hline
U+022DE & ⋞ & {\textbackslash}curlyeqprec & Equal To Or Precedes \\
\hline
U+022DF & ⋟ & {\textbackslash}curlyeqsucc & Equal To Or Succeeds \\
\hline
U+022E0 & ⋠ & {\textbackslash}npreccurlyeq & Does Not Precede Or Equal \\
\hline
U+022E1 & ⋡ & {\textbackslash}nsucccurlyeq & Does Not Succeed Or Equal \\
\hline
U+022E2 & ⋢ & {\textbackslash}nsqsubseteq & Not Square Image Of Or Equal To \\
\hline
U+022E3 & ⋣ & {\textbackslash}nsqsupseteq & Not Square Original Of Or Equal To \\
\hline
U+022E4 & ⋤ & {\textbackslash}sqsubsetneq & Square Image Of Or Not Equal To \\
\hline
U+022E5 & ⋥ & {\textbackslash}Elzsqspne & Square Original Of Or Not Equal To \\
\hline
U+022E6 & ⋦ & {\textbackslash}lnsim & Less-than But Not Equivalent To / Less Than But Not Equivalent To \\
\hline
U+022E7 & ⋧ & {\textbackslash}gnsim & Greater-than But Not Equivalent To / Greater Than But Not Equivalent To \\
\hline
U+022E8 & ⋨ & {\textbackslash}precnsim & Precedes But Not Equivalent To \\
\hline
U+022E9 & ⋩ & {\textbackslash}succnsim & Succeeds But Not Equivalent To \\
\hline
U+022EA & ⋪ & {\textbackslash}ntriangleleft & Not Normal Subgroup Of \\
\hline
U+022EB & ⋫ & {\textbackslash}ntriangleright & Does Not Contain As Normal Subgroup \\
\hline
U+022EC & ⋬ & {\textbackslash}ntrianglelefteq & Not Normal Subgroup Of Or Equal To \\
\hline
U+022ED & ⋭ & {\textbackslash}ntrianglerighteq & Does Not Contain As Normal Subgroup Or Equal \\
\hline
U+022EE & ⋮ & {\textbackslash}vdots & Vertical Ellipsis \\
\hline
U+022EF & ⋯ & {\textbackslash}cdots & Midline Horizontal Ellipsis \\
\hline
U+022F0 & ⋰ & {\textbackslash}adots & Up Right Diagonal Ellipsis \\
\hline
U+022F1 & ⋱ & {\textbackslash}ddots & Down Right Diagonal Ellipsis \\
\hline
U+022F2 & ⋲ & {\textbackslash}disin & Element Of With Long Horizontal Stroke \\
\hline
U+022F3 & ⋳ & {\textbackslash}varisins & Element Of With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022F4 & ⋴ & {\textbackslash}isins & Small Element Of With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022F5 & ⋵ & {\textbackslash}isindot & Element Of With Dot Above \\
\hline
U+022F6 & ⋶ & {\textbackslash}varisinobar & Element Of With Overbar \\
\hline
U+022F7 & ⋷ & {\textbackslash}isinobar & Small Element Of With Overbar \\
\hline
U+022F8 & ⋸ & {\textbackslash}isinvb & Element Of With Underbar \\
\hline
U+022F9 & ⋹ & {\textbackslash}isinE & Element Of With Two Horizontal Strokes \\
\hline
U+022FA & ⋺ & {\textbackslash}nisd & Contains With Long Horizontal Stroke \\
\hline
U+022FB & ⋻ & {\textbackslash}varnis & Contains With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022FC & ⋼ & {\textbackslash}nis & Small Contains With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022FD & ⋽ & {\textbackslash}varniobar & Contains With Overbar \\
\hline
U+022FE & ⋾ & {\textbackslash}niobar & Small Contains With Overbar \\
\hline
U+022FF & ⋿ & {\textbackslash}bagmember & Z Notation Bag Membership \\
\hline
U+02300 & ⌀ & {\textbackslash}diameter & Diameter Sign \\
\hline
U+02302 & ⌂ & {\textbackslash}house & House \\
\hline
U+02305 & ⌅ & {\textbackslash}varbarwedge & Projective \\
\hline
U+02306 & ⌆ & {\textbackslash}vardoublebarwedge & Perspective \\
\hline
U+02308 & ⌈ & {\textbackslash}lceil & Left Ceiling \\
\hline
U+02309 & ⌉ & {\textbackslash}rceil & Right Ceiling \\
\hline
U+0230A & ⌊ & {\textbackslash}lfloor & Left Floor \\
\hline
U+0230B & ⌋ & {\textbackslash}rfloor & Right Floor \\
\hline
U+02310 & ⌐ & {\textbackslash}invnot & Reversed Not Sign \\
\hline
U+02311 & ⌑ & {\textbackslash}sqlozenge & Square Lozenge \\
\hline
U+02312 & ⌒ & {\textbackslash}profline & Arc \\
\hline
U+02313 & ⌓ & {\textbackslash}profsurf & Segment \\
\hline
U+02315 & ⌕ & {\textbackslash}recorder & Telephone Recorder \\
\hline
U+02317 & ⌗ & {\textbackslash}viewdata & Viewdata Square \\
\hline
U+02319 & ⌙ & {\textbackslash}turnednot & Turned Not Sign \\
\hline
U+0231A & ⌚ & {\textbackslash}:watch: & Watch \\
\hline
U+0231B & ⌛ & {\textbackslash}:hourglass: & Hourglass \\
\hline
U+0231C & ⌜ & {\textbackslash}ulcorner & Top Left Corner \\
\hline
U+0231D & ⌝ & {\textbackslash}urcorner & Top Right Corner \\
\hline
U+0231E & ⌞ & {\textbackslash}llcorner & Bottom Left Corner \\
\hline
U+0231F & ⌟ & {\textbackslash}lrcorner & Bottom Right Corner \\
\hline
U+02322 & ⌢ & {\textbackslash}frown & Frown \\
\hline
U+02323 & ⌣ & {\textbackslash}smile & Smile \\
\hline
U+0232C & ⌬ & {\textbackslash}varhexagonlrbonds & Benzene Ring \\
\hline
U+02332 & ⌲ & {\textbackslash}conictaper & Conical Taper \\
\hline
U+02336 & ⌶ & {\textbackslash}topbot & Apl Functional Symbol I-beam \\
\hline
U+0233D & ⌽ & {\textbackslash}obar & Apl Functional Symbol Circle Stile \\
\hline
U+0233F & ⌿ & {\textbackslash}APLnotslash & Apl Functional Symbol Slash Bar \\
\hline
U+02340 & ⍀ & {\textbackslash}APLnotbackslash & Apl Functional Symbol Backslash Bar \\
\hline
U+02353 & ⍓ & {\textbackslash}APLboxupcaret & Apl Functional Symbol Quad Up Caret \\
\hline
U+02370 & ⍰ & {\textbackslash}APLboxquestion & Apl Functional Symbol Quad Question \\
\hline
U+02394 & ⎔ & {\textbackslash}hexagon & Software-function Symbol \\
\hline
U+023A3 & ⎣ & {\textbackslash}Elzdlcorn & Left Square Bracket Lower Corner \\
\hline
U+023B0 & ⎰ & {\textbackslash}lmoustache & Upper Left Or Lower Right Curly Bracket Section \\
\hline
U+023B1 & ⎱ & {\textbackslash}rmoustache & Upper Right Or Lower Left Curly Bracket Section \\
\hline
U+023B4 & ⎴ & {\textbackslash}overbracket & Top Square Bracket \\
\hline
U+023B5 & ⎵ & {\textbackslash}underbracket & Bottom Square Bracket \\
\hline
U+023B6 & ⎶ & {\textbackslash}bbrktbrk & Bottom Square Bracket Over Top Square Bracket \\
\hline
U+023B7 & ⎷ & {\textbackslash}sqrtbottom & Radical Symbol Bottom \\
\hline
U+023B8 & ⎸ & {\textbackslash}lvboxline & Left Vertical Box Line \\
\hline
U+023B9 & ⎹ & {\textbackslash}rvboxline & Right Vertical Box Line \\
\hline
U+023CE & ⏎ & {\textbackslash}varcarriagereturn & Return Symbol \\
\hline
U+023DE & ⏞ & {\textbackslash}overbrace & Top Curly Bracket \\
\hline
U+023DF & ⏟ & {\textbackslash}underbrace & Bottom Curly Bracket \\
\hline
U+023E2 & ⏢ & {\textbackslash}trapezium & White Trapezium \\
\hline
U+023E3 & ⏣ & {\textbackslash}benzenr & Benzene Ring With Circle \\
\hline
U+023E4 & ⏤ & {\textbackslash}strns & Straightness \\
\hline
U+023E5 & ⏥ & {\textbackslash}fltns & Flatness \\
\hline
U+023E6 & ⏦ & {\textbackslash}accurrent & Ac Current \\
\hline
U+023E7 & ⏧ & {\textbackslash}elinters & Electrical Intersection \\
\hline
U+023E9 & ⏩ & {\textbackslash}:fast\_forward: & Black Right-pointing Double Triangle \\
\hline
U+023EA & ⏪ & {\textbackslash}:rewind: & Black Left-pointing Double Triangle \\
\hline
U+023EB & ⏫ & {\textbackslash}:arrow\_double\_up: & Black Up-pointing Double Triangle \\
\hline
U+023EC & ⏬ & {\textbackslash}:arrow\_double\_down: & Black Down-pointing Double Triangle \\
\hline
U+023F0 & ⏰ & {\textbackslash}:alarm\_clock: & Alarm Clock \\
\hline
U+023F3 & ⏳ & {\textbackslash}:hourglass\_flowing\_sand: & Hourglass With Flowing Sand \\
\hline
U+02422 & ␢ & {\textbackslash}blanksymbol & Blank Symbol / Blank \\
\hline
U+02423 & ␣ & {\textbackslash}textvisiblespace & Open Box \\
\hline
U+024C2 & Ⓜ & {\textbackslash}:m: & Circled Latin Capital Letter M \\
\hline
U+024C8 & Ⓢ & {\textbackslash}circledS & Circled Latin Capital Letter S \\
\hline
U+02506 & ┆ & {\textbackslash}Elzdshfnc & Box Drawings Light Triple Dash Vertical / Forms Light Triple Dash Vertical \\
\hline
U+02519 & ┙ & {\textbackslash}Elzsqfnw & Box Drawings Up Light And Left Heavy / Forms Up Light And Left Heavy \\
\hline
U+02571 & ╱ & {\textbackslash}diagup & Box Drawings Light Diagonal Upper Right To Lower Left / Forms Light Diagonal Upper Right To Lower Left \\
\hline
U+02572 & ╲ & {\textbackslash}diagdown & Box Drawings Light Diagonal Upper Left To Lower Right / Forms Light Diagonal Upper Left To Lower Right \\
\hline
U+02580 & ▀ & {\textbackslash}blockuphalf & Upper Half Block \\
\hline
U+02584 & ▄ & {\textbackslash}blocklowhalf & Lower Half Block \\
\hline
U+02588 & █ & {\textbackslash}blockfull & Full Block \\
\hline
U+0258C & ▌ & {\textbackslash}blocklefthalf & Left Half Block \\
\hline
U+02590 & ▐ & {\textbackslash}blockrighthalf & Right Half Block \\
\hline
U+02591 & ░ & {\textbackslash}blockqtrshaded & Light Shade \\
\hline
U+02592 & ▒ & {\textbackslash}blockhalfshaded & Medium Shade \\
\hline
U+02593 & ▓ & {\textbackslash}blockthreeqtrshaded & Dark Shade \\
\hline
U+025A0 & ■ & {\textbackslash}blacksquare & Black Square \\
\hline
U+025A1 & □ & {\textbackslash}square & White Square \\
\hline
U+025A2 & ▢ & {\textbackslash}squoval & White Square With Rounded Corners \\
\hline
U+025A3 & ▣ & {\textbackslash}blackinwhitesquare & White Square Containing Black Small Square \\
\hline
U+025A4 & ▤ & {\textbackslash}squarehfill & Square With Horizontal Fill \\
\hline
U+025A5 & ▥ & {\textbackslash}squarevfill & Square With Vertical Fill \\
\hline
U+025A6 & ▦ & {\textbackslash}squarehvfill & Square With Orthogonal Crosshatch Fill \\
\hline
U+025A7 & ▧ & {\textbackslash}squarenwsefill & Square With Upper Left To Lower Right Fill \\
\hline
U+025A8 & ▨ & {\textbackslash}squareneswfill & Square With Upper Right To Lower Left Fill \\
\hline
U+025A9 & ▩ & {\textbackslash}squarecrossfill & Square With Diagonal Crosshatch Fill \\
\hline
U+025AA & ▪ & {\textbackslash}smblksquare, {\textbackslash}:black\_small\_square: & Black Small Square \\
\hline
U+025AB & ▫ & {\textbackslash}smwhtsquare, {\textbackslash}:white\_small\_square: & White Small Square \\
\hline
U+025AC & ▬ & {\textbackslash}hrectangleblack & Black Rectangle \\
\hline
U+025AD & ▭ & {\textbackslash}hrectangle & White Rectangle \\
\hline
U+025AE & ▮ & {\textbackslash}vrectangleblack & Black Vertical Rectangle \\
\hline
U+025AF & ▯ & {\textbackslash}Elzvrecto & White Vertical Rectangle \\
\hline
U+025B0 & ▰ & {\textbackslash}parallelogramblack & Black Parallelogram \\
\hline
U+025B1 & ▱ & {\textbackslash}parallelogram & White Parallelogram \\
\hline
U+025B2 & ▲ & {\textbackslash}bigblacktriangleup & Black Up-pointing Triangle / Black Up Pointing Triangle \\
\hline
U+025B3 & △ & {\textbackslash}bigtriangleup & White Up-pointing Triangle / White Up Pointing Triangle \\
\hline
U+025B4 & ▴ & {\textbackslash}blacktriangle & Black Up-pointing Small Triangle / Black Up Pointing Small Triangle \\
\hline
U+025B5 & ▵ & {\textbackslash}vartriangle & White Up-pointing Small Triangle / White Up Pointing Small Triangle \\
\hline
U+025B6 & ▶ & {\textbackslash}blacktriangleright, {\textbackslash}:arrow\_forward: & Black Right-pointing Triangle / Black Right Pointing Triangle \\
\hline
U+025B7 & ▷ & {\textbackslash}triangleright & White Right-pointing Triangle / White Right Pointing Triangle \\
\hline
U+025B8 & ▸ & {\textbackslash}smallblacktriangleright & Black Right-pointing Small Triangle / Black Right Pointing Small Triangle \\
\hline
U+025B9 & ▹ & {\textbackslash}smalltriangleright & White Right-pointing Small Triangle / White Right Pointing Small Triangle \\
\hline
U+025BA & ► & {\textbackslash}blackpointerright & Black Right-pointing Pointer / Black Right Pointing Pointer \\
\hline
U+025BB & ▻ & {\textbackslash}whitepointerright & White Right-pointing Pointer / White Right Pointing Pointer \\
\hline
U+025BC & ▼ & {\textbackslash}bigblacktriangledown & Black Down-pointing Triangle / Black Down Pointing Triangle \\
\hline
U+025BD & ▽ & {\textbackslash}bigtriangledown & White Down-pointing Triangle / White Down Pointing Triangle \\
\hline
U+025BE & ▾ & {\textbackslash}blacktriangledown & Black Down-pointing Small Triangle / Black Down Pointing Small Triangle \\
\hline
U+025BF & ▿ & {\textbackslash}triangledown & White Down-pointing Small Triangle / White Down Pointing Small Triangle \\
\hline
U+025C0 & ◀ & {\textbackslash}blacktriangleleft, {\textbackslash}:arrow\_backward: & Black Left-pointing Triangle / Black Left Pointing Triangle \\
\hline
U+025C1 & ◁ & {\textbackslash}triangleleft & White Left-pointing Triangle / White Left Pointing Triangle \\
\hline
U+025C2 & ◂ & {\textbackslash}smallblacktriangleleft & Black Left-pointing Small Triangle / Black Left Pointing Small Triangle \\
\hline
U+025C3 & ◃ & {\textbackslash}smalltriangleleft & White Left-pointing Small Triangle / White Left Pointing Small Triangle \\
\hline
U+025C4 & ◄ & {\textbackslash}blackpointerleft & Black Left-pointing Pointer / Black Left Pointing Pointer \\
\hline
U+025C5 & ◅ & {\textbackslash}whitepointerleft & White Left-pointing Pointer / White Left Pointing Pointer \\
\hline
U+025C6 & ◆ & {\textbackslash}mdlgblkdiamond & Black Diamond \\
\hline
U+025C7 & ◇ & {\textbackslash}mdlgwhtdiamond & White Diamond \\
\hline
U+025C8 & ◈ & {\textbackslash}blackinwhitediamond & White Diamond Containing Black Small Diamond \\
\hline
U+025C9 & ◉ & {\textbackslash}fisheye & Fisheye \\
\hline
U+025CA & ◊ & {\textbackslash}lozenge & Lozenge \\
\hline
U+025CB & ○ & {\textbackslash}bigcirc & White Circle \\
\hline
U+025CC & ◌ & {\textbackslash}dottedcircle & Dotted Circle \\
\hline
U+025CD & ◍ & {\textbackslash}circlevertfill & Circle With Vertical Fill \\
\hline
U+025CE & ◎ & {\textbackslash}bullseye & Bullseye \\
\hline
U+025CF & ● & {\textbackslash}mdlgblkcircle & Black Circle \\
\hline
U+025D0 & ◐ & {\textbackslash}Elzcirfl & Circle With Left Half Black \\
\hline
U+025D1 & ◑ & {\textbackslash}Elzcirfr & Circle With Right Half Black \\
\hline
U+025D2 & ◒ & {\textbackslash}Elzcirfb & Circle With Lower Half Black \\
\hline
U+025D3 & ◓ & {\textbackslash}circletophalfblack & Circle With Upper Half Black \\
\hline
U+025D4 & ◔ & {\textbackslash}circleurquadblack & Circle With Upper Right Quadrant Black \\
\hline
U+025D5 & ◕ & {\textbackslash}blackcircleulquadwhite & Circle With All But Upper Left Quadrant Black \\
\hline
U+025D6 & ◖ & {\textbackslash}blacklefthalfcircle & Left Half Black Circle \\
\hline
U+025D7 & ◗ & {\textbackslash}blackrighthalfcircle & Right Half Black Circle \\
\hline
U+025D8 & ◘ & {\textbackslash}Elzrvbull & Inverse Bullet \\
\hline
U+025D9 & ◙ & {\textbackslash}inversewhitecircle & Inverse White Circle \\
\hline
U+025DA & ◚ & {\textbackslash}invwhiteupperhalfcircle & Upper Half Inverse White Circle \\
\hline
U+025DB & ◛ & {\textbackslash}invwhitelowerhalfcircle & Lower Half Inverse White Circle \\
\hline
U+025DC & ◜ & {\textbackslash}ularc & Upper Left Quadrant Circular Arc \\
\hline
U+025DD & ◝ & {\textbackslash}urarc & Upper Right Quadrant Circular Arc \\
\hline
U+025DE & ◞ & {\textbackslash}lrarc & Lower Right Quadrant Circular Arc \\
\hline
U+025DF & ◟ & {\textbackslash}llarc & Lower Left Quadrant Circular Arc \\
\hline
U+025E0 & ◠ & {\textbackslash}topsemicircle & Upper Half Circle \\
\hline
U+025E1 & ◡ & {\textbackslash}botsemicircle & Lower Half Circle \\
\hline
U+025E2 & ◢ & {\textbackslash}lrblacktriangle & Black Lower Right Triangle \\
\hline
U+025E3 & ◣ & {\textbackslash}llblacktriangle & Black Lower Left Triangle \\
\hline
U+025E4 & ◤ & {\textbackslash}ulblacktriangle & Black Upper Left Triangle \\
\hline
U+025E5 & ◥ & {\textbackslash}urblacktriangle & Black Upper Right Triangle \\
\hline
U+025E6 & ◦ & {\textbackslash}smwhtcircle & White Bullet \\
\hline
U+025E7 & ◧ & {\textbackslash}Elzsqfl & Square With Left Half Black \\
\hline
U+025E8 & ◨ & {\textbackslash}Elzsqfr & Square With Right Half Black \\
\hline
U+025E9 & ◩ & {\textbackslash}squareulblack & Square With Upper Left Diagonal Half Black \\
\hline
U+025EA & ◪ & {\textbackslash}Elzsqfse & Square With Lower Right Diagonal Half Black \\
\hline
U+025EB & ◫ & {\textbackslash}boxbar & White Square With Vertical Bisecting Line \\
\hline
U+025EC & ◬ & {\textbackslash}trianglecdot & White Up-pointing Triangle With Dot / White Up Pointing Triangle With Dot \\
\hline
U+025ED & ◭ & {\textbackslash}triangleleftblack & Up-pointing Triangle With Left Half Black / Up Pointing Triangle With Left Half Black \\
\hline
U+025EE & ◮ & {\textbackslash}trianglerightblack & Up-pointing Triangle With Right Half Black / Up Pointing Triangle With Right Half Black \\
\hline
U+025EF & ◯ & {\textbackslash}lgwhtcircle & Large Circle \\
\hline
U+025F0 & ◰ & {\textbackslash}squareulquad & White Square With Upper Left Quadrant \\
\hline
U+025F1 & ◱ & {\textbackslash}squarellquad & White Square With Lower Left Quadrant \\
\hline
U+025F2 & ◲ & {\textbackslash}squarelrquad & White Square With Lower Right Quadrant \\
\hline
U+025F3 & ◳ & {\textbackslash}squareurquad & White Square With Upper Right Quadrant \\
\hline
U+025F4 & ◴ & {\textbackslash}circleulquad & White Circle With Upper Left Quadrant \\
\hline
U+025F5 & ◵ & {\textbackslash}circlellquad & White Circle With Lower Left Quadrant \\
\hline
U+025F6 & ◶ & {\textbackslash}circlelrquad & White Circle With Lower Right Quadrant \\
\hline
U+025F7 & ◷ & {\textbackslash}circleurquad & White Circle With Upper Right Quadrant \\
\hline
U+025F8 & ◸ & {\textbackslash}ultriangle & Upper Left Triangle \\
\hline
U+025F9 & ◹ & {\textbackslash}urtriangle & Upper Right Triangle \\
\hline
U+025FA & ◺ & {\textbackslash}lltriangle & Lower Left Triangle \\
\hline
U+025FB & ◻ & {\textbackslash}mdwhtsquare, {\textbackslash}:white\_medium\_square: & White Medium Square \\
\hline
U+025FC & ◼ & {\textbackslash}mdblksquare, {\textbackslash}:black\_medium\_square: & Black Medium Square \\
\hline
U+025FD & ◽ & {\textbackslash}mdsmwhtsquare, {\textbackslash}:white\_medium\_small\_square: & White Medium Small Square \\
\hline
U+025FE & ◾ & {\textbackslash}mdsmblksquare, {\textbackslash}:black\_medium\_small\_square: & Black Medium Small Square \\
\hline
U+025FF & ◿ & {\textbackslash}lrtriangle & Lower Right Triangle \\
\hline
U+02600 & ☀ & {\textbackslash}:sunny: & Black Sun With Rays \\
\hline
U+02601 & ☁ & {\textbackslash}:cloud: & Cloud \\
\hline
U+02605 & ★ & {\textbackslash}bigstar & Black Star \\
\hline
U+02606 & ☆ & {\textbackslash}bigwhitestar & White Star \\
\hline
U+02609 & ☉ & {\textbackslash}astrosun & Sun \\
\hline
U+0260E & ☎ & {\textbackslash}:phone: & Black Telephone \\
\hline
U+02611 & ☑ & {\textbackslash}:ballot\_box\_with\_check: & Ballot Box With Check \\
\hline
U+02614 & ☔ & {\textbackslash}:umbrella: & Umbrella With Rain Drops \\
\hline
U+02615 & ☕ & {\textbackslash}:coffee: & Hot Beverage \\
\hline
U+0261D & ☝ & {\textbackslash}:point\_up: & White Up Pointing Index \\
\hline
U+02621 & ☡ & {\textbackslash}danger & Caution Sign \\
\hline
U+0263A & ☺ & {\textbackslash}:relaxed: & White Smiling Face \\
\hline
U+0263B & ☻ & {\textbackslash}blacksmiley & Black Smiling Face \\
\hline
U+0263C & ☼ & {\textbackslash}sun & White Sun With Rays \\
\hline
U+0263D & ☽ & {\textbackslash}rightmoon & First Quarter Moon \\
\hline
U+0263E & ☾ & {\textbackslash}leftmoon & Last Quarter Moon \\
\hline
U+0263F & ☿ & {\textbackslash}mercury & Mercury \\
\hline
U+02640 & ♀ & {\textbackslash}venus, {\textbackslash}female & Female Sign \\
\hline
U+02642 & ♂ & {\textbackslash}male, {\textbackslash}mars & Male Sign \\
\hline
U+02643 & ♃ & {\textbackslash}jupiter & Jupiter \\
\hline
U+02644 & ♄ & {\textbackslash}saturn & Saturn \\
\hline
U+02645 & ♅ & {\textbackslash}uranus & Uranus \\
\hline
U+02646 & ♆ & {\textbackslash}neptune & Neptune \\
\hline
U+02647 & ♇ & {\textbackslash}pluto & Pluto \\
\hline
U+02648 & ♈ & {\textbackslash}aries, {\textbackslash}:aries: & Aries \\
\hline
U+02649 & ♉ & {\textbackslash}taurus, {\textbackslash}:taurus: & Taurus \\
\hline
U+0264A & ♊ & {\textbackslash}gemini, {\textbackslash}:gemini: & Gemini \\
\hline
U+0264B & ♋ & {\textbackslash}cancer, {\textbackslash}:cancer: & Cancer \\
\hline
U+0264C & ♌ & {\textbackslash}leo, {\textbackslash}:leo: & Leo \\
\hline
U+0264D & ♍ & {\textbackslash}virgo, {\textbackslash}:virgo: & Virgo \\
\hline
U+0264E & ♎ & {\textbackslash}libra, {\textbackslash}:libra: & Libra \\
\hline
U+0264F & ♏ & {\textbackslash}scorpio, {\textbackslash}:scorpius: & Scorpius \\
\hline
U+02650 & ♐ & {\textbackslash}sagittarius, {\textbackslash}:sagittarius: & Sagittarius \\
\hline
U+02651 & ♑ & {\textbackslash}capricornus, {\textbackslash}:capricorn: & Capricorn \\
\hline
U+02652 & ♒ & {\textbackslash}aquarius, {\textbackslash}:aquarius: & Aquarius \\
\hline
U+02653 & ♓ & {\textbackslash}pisces, {\textbackslash}:pisces: & Pisces \\
\hline
U+02660 & ♠ & {\textbackslash}spadesuit, {\textbackslash}:spades: & Black Spade Suit \\
\hline
U+02661 & ♡ & {\textbackslash}heartsuit & White Heart Suit \\
\hline
U+02662 & ♢ & {\textbackslash}diamondsuit & White Diamond Suit \\
\hline
U+02663 & ♣ & {\textbackslash}clubsuit, {\textbackslash}:clubs: & Black Club Suit \\
\hline
U+02664 & ♤ & {\textbackslash}varspadesuit & White Spade Suit \\
\hline
U+02665 & ♥ & {\textbackslash}varheartsuit, {\textbackslash}:hearts: & Black Heart Suit \\
\hline
U+02666 & ♦ & {\textbackslash}vardiamondsuit, {\textbackslash}:diamonds: & Black Diamond Suit \\
\hline
U+02667 & ♧ & {\textbackslash}varclubsuit & White Club Suit \\
\hline
U+02668 & ♨ & {\textbackslash}:hotsprings: & Hot Springs \\
\hline
U+02669 & ♩ & {\textbackslash}quarternote & Quarter Note \\
\hline
U+0266A & ♪ & {\textbackslash}eighthnote & Eighth Note \\
\hline
U+0266B & ♫ & {\textbackslash}twonotes & Beamed Eighth Notes / Barred Eighth Notes \\
\hline
U+0266D & ♭ & {\textbackslash}flat & Music Flat Sign / Flat \\
\hline
U+0266E & ♮ & {\textbackslash}natural & Music Natural Sign / Natural \\
\hline
U+0266F & ♯ & {\textbackslash}sharp & Music Sharp Sign / Sharp \\
\hline
U+0267B & ♻ & {\textbackslash}:recycle: & Black Universal Recycling Symbol \\
\hline
U+0267E & ♾ & {\textbackslash}acidfree & Permanent Paper Sign \\
\hline
U+0267F & ♿ & {\textbackslash}:wheelchair: & Wheelchair Symbol \\
\hline
U+02680 & ⚀ & {\textbackslash}dicei & Die Face-1 \\
\hline
U+02681 & ⚁ & {\textbackslash}diceii & Die Face-2 \\
\hline
U+02682 & ⚂ & {\textbackslash}diceiii & Die Face-3 \\
\hline
U+02683 & ⚃ & {\textbackslash}diceiv & Die Face-4 \\
\hline
U+02684 & ⚄ & {\textbackslash}dicev & Die Face-5 \\
\hline
U+02685 & ⚅ & {\textbackslash}dicevi & Die Face-6 \\
\hline
U+02686 & ⚆ & {\textbackslash}circledrightdot & White Circle With Dot Right \\
\hline
U+02687 & ⚇ & {\textbackslash}circledtwodots & White Circle With Two Dots \\
\hline
U+02688 & ⚈ & {\textbackslash}blackcircledrightdot & Black Circle With White Dot Right \\
\hline
U+02689 & ⚉ & {\textbackslash}blackcircledtwodots & Black Circle With Two White Dots \\
\hline
U+02693 & ⚓ & {\textbackslash}:anchor: & Anchor \\
\hline
U+026A0 & ⚠ & {\textbackslash}:warning: & Warning Sign \\
\hline
U+026A1 & ⚡ & {\textbackslash}:zap: & High Voltage Sign \\
\hline
U+026A5 & ⚥ & {\textbackslash}Hermaphrodite & Male And Female Sign \\
\hline
U+026AA & ⚪ & {\textbackslash}mdwhtcircle, {\textbackslash}:white\_circle: & Medium White Circle \\
\hline
U+026AB & ⚫ & {\textbackslash}mdblkcircle, {\textbackslash}:black\_circle: & Medium Black Circle \\
\hline
U+026AC & ⚬ & {\textbackslash}mdsmwhtcircle & Medium Small White Circle \\
\hline
U+026B2 & ⚲ & {\textbackslash}neuter & Neuter \\
\hline
U+026BD & ⚽ & {\textbackslash}:soccer: & Soccer Ball \\
\hline
U+026BE & ⚾ & {\textbackslash}:baseball: & Baseball \\
\hline
U+026C4 & ⛄ & {\textbackslash}:snowman: & Snowman Without Snow \\
\hline
U+026C5 & ⛅ & {\textbackslash}:partly\_sunny: & Sun Behind Cloud \\
\hline
U+026CE & ⛎ & {\textbackslash}:ophiuchus: & Ophiuchus \\
\hline
U+026D4 & ⛔ & {\textbackslash}:no\_entry: & No Entry \\
\hline
U+026EA & ⛪ & {\textbackslash}:church: & Church \\
\hline
U+026F2 & ⛲ & {\textbackslash}:fountain: & Fountain \\
\hline
U+026F3 & ⛳ & {\textbackslash}:golf: & Flag In Hole \\
\hline
U+026F5 & ⛵ & {\textbackslash}:boat: & Sailboat \\
\hline
U+026FA & ⛺ & {\textbackslash}:tent: & Tent \\
\hline
U+026FD & ⛽ & {\textbackslash}:fuelpump: & Fuel Pump \\
\hline
U+02702 & ✂ & {\textbackslash}:scissors: & Black Scissors \\
\hline
U+02705 & ✅ & {\textbackslash}:white\_check\_mark: & White Heavy Check Mark \\
\hline
U+02708 & ✈ & {\textbackslash}:airplane: & Airplane \\
\hline
U+02709 & ✉ & {\textbackslash}:email: & Envelope \\
\hline
U+0270A & ✊ & {\textbackslash}:fist: & Raised Fist \\
\hline
U+0270B & ✋ & {\textbackslash}:hand: & Raised Hand \\
\hline
U+0270C & ✌ & {\textbackslash}:v: & Victory Hand \\
\hline
U+0270F & ✏ & {\textbackslash}:pencil2: & Pencil \\
\hline
U+02712 & ✒ & {\textbackslash}:black\_nib: & Black Nib \\
\hline
U+02713 & ✓ & {\textbackslash}checkmark & Check Mark \\
\hline
U+02714 & ✔ & {\textbackslash}:heavy\_check\_mark: & Heavy Check Mark \\
\hline
U+02716 & ✖ & {\textbackslash}:heavy\_multiplication\_x: & Heavy Multiplication X \\
\hline
U+02720 & ✠ & {\textbackslash}maltese & Maltese Cross \\
\hline
U+02728 & ✨ & {\textbackslash}:sparkles: & Sparkles \\
\hline
U+0272A & ✪ & {\textbackslash}circledstar & Circled White Star \\
\hline
U+02733 & ✳ & {\textbackslash}:eight\_spoked\_asterisk: & Eight Spoked Asterisk \\
\hline
U+02734 & ✴ & {\textbackslash}:eight\_pointed\_black\_star: & Eight Pointed Black Star \\
\hline
U+02736 & ✶ & {\textbackslash}varstar & Six Pointed Black Star \\
\hline
U+0273D & ✽ & {\textbackslash}dingasterisk & Heavy Teardrop-spoked Asterisk \\
\hline
U+02744 & ❄ & {\textbackslash}:snowflake: & Snowflake \\
\hline
U+02747 & ❇ & {\textbackslash}:sparkle: & Sparkle \\
\hline
U+0274C & ❌ & {\textbackslash}:x: & Cross Mark \\
\hline
U+0274E & ❎ & {\textbackslash}:negative\_squared\_cross\_mark: & Negative Squared Cross Mark \\
\hline
U+02753 & ❓ & {\textbackslash}:question: & Black Question Mark Ornament \\
\hline
U+02754 & ❔ & {\textbackslash}:grey\_question: & White Question Mark Ornament \\
\hline
U+02755 & ❕ & {\textbackslash}:grey\_exclamation: & White Exclamation Mark Ornament \\
\hline
U+02757 & ❗ & {\textbackslash}:exclamation: & Heavy Exclamation Mark Symbol \\
\hline
U+02764 & ❤ & {\textbackslash}:heart: & Heavy Black Heart \\
\hline
U+02795 & ➕ & {\textbackslash}:heavy\_plus\_sign: & Heavy Plus Sign \\
\hline
U+02796 & ➖ & {\textbackslash}:heavy\_minus\_sign: & Heavy Minus Sign \\
\hline
U+02797 & ➗ & {\textbackslash}:heavy\_division\_sign: & Heavy Division Sign \\
\hline
U+0279B & ➛ & {\textbackslash}draftingarrow & Drafting Point Rightwards Arrow / Drafting Point Right Arrow \\
\hline
U+027A1 & ➡ & {\textbackslash}:arrow\_right: & Black Rightwards Arrow / Black Right Arrow \\
\hline
U+027B0 & ➰ & {\textbackslash}:curly\_loop: & Curly Loop \\
\hline
U+027BF & ➿ & {\textbackslash}:loop: & Double Curly Loop \\
\hline
U+027C0 & ⟀ & {\textbackslash}threedangle & Three Dimensional Angle \\
\hline
U+027C1 & ⟁ & {\textbackslash}whiteinwhitetriangle & White Triangle Containing Small White Triangle \\
\hline
U+027C2 & ⟂ & {\textbackslash}perp & Perpendicular \\
\hline
U+027C8 & ⟈ & {\textbackslash}bsolhsub & Reverse Solidus Preceding Subset \\
\hline
U+027C9 & ⟉ & {\textbackslash}suphsol & Superset Preceding Solidus \\
\hline
U+027D1 & ⟑ & {\textbackslash}wedgedot & And With Dot \\
\hline
U+027D2 & ⟒ & {\textbackslash}upin & Element Of Opening Upwards \\
\hline
U+027D5 & ⟕ & {\textbackslash}leftouterjoin & Left Outer Join \\
\hline
U+027D6 & ⟖ & {\textbackslash}rightouterjoin & Right Outer Join \\
\hline
U+027D7 & ⟗ & {\textbackslash}fullouterjoin & Full Outer Join \\
\hline
U+027D8 & ⟘ & {\textbackslash}bigbot & Large Up Tack \\
\hline
U+027D9 & ⟙ & {\textbackslash}bigtop & Large Down Tack \\
\hline
U+027E6 & ⟦ & {\textbackslash}llbracket, {\textbackslash}openbracketleft & Mathematical Left White Square Bracket \\
\hline
U+027E7 & ⟧ & {\textbackslash}openbracketright, {\textbackslash}rrbracket & Mathematical Right White Square Bracket \\
\hline
U+027E8 & ⟨ & {\textbackslash}langle & Mathematical Left Angle Bracket \\
\hline
U+027E9 & ⟩ & {\textbackslash}rangle & Mathematical Right Angle Bracket \\
\hline
U+027F0 & ⟰ & {\textbackslash}UUparrow & Upwards Quadruple Arrow \\
\hline
U+027F1 & ⟱ & {\textbackslash}DDownarrow & Downwards Quadruple Arrow \\
\hline
U+027F5 & ⟵ & {\textbackslash}longleftarrow & Long Leftwards Arrow \\
\hline
U+027F6 & ⟶ & {\textbackslash}longrightarrow & Long Rightwards Arrow \\
\hline
U+027F7 & ⟷ & {\textbackslash}longleftrightarrow & Long Left Right Arrow \\
\hline
U+027F8 & ⟸ & {\textbackslash}impliedby, {\textbackslash}Longleftarrow & Long Leftwards Double Arrow \\
\hline
U+027F9 & ⟹ & {\textbackslash}implies, {\textbackslash}Longrightarrow & Long Rightwards Double Arrow \\
\hline
U+027FA & ⟺ & {\textbackslash}Longleftrightarrow, {\textbackslash}iff & Long Left Right Double Arrow \\
\hline
U+027FB & ⟻ & {\textbackslash}longmapsfrom & Long Leftwards Arrow From Bar \\
\hline
U+027FC & ⟼ & {\textbackslash}longmapsto & Long Rightwards Arrow From Bar \\
\hline
U+027FD & ⟽ & {\textbackslash}Longmapsfrom & Long Leftwards Double Arrow From Bar \\
\hline
U+027FE & ⟾ & {\textbackslash}Longmapsto & Long Rightwards Double Arrow From Bar \\
\hline
U+027FF & ⟿ & {\textbackslash}longrightsquigarrow & Long Rightwards Squiggle Arrow \\
\hline
U+02900 & ⤀ & {\textbackslash}nvtwoheadrightarrow & Rightwards Two-headed Arrow With Vertical Stroke \\
\hline
U+02901 & ⤁ & {\textbackslash}nVtwoheadrightarrow & Rightwards Two-headed Arrow With Double Vertical Stroke \\
\hline
U+02902 & ⤂ & {\textbackslash}nvLeftarrow & Leftwards Double Arrow With Vertical Stroke \\
\hline
U+02903 & ⤃ & {\textbackslash}nvRightarrow & Rightwards Double Arrow With Vertical Stroke \\
\hline
U+02904 & ⤄ & {\textbackslash}nvLeftrightarrow & Left Right Double Arrow With Vertical Stroke \\
\hline
U+02905 & ⤅ & {\textbackslash}twoheadmapsto & Rightwards Two-headed Arrow From Bar \\
\hline
U+02906 & ⤆ & {\textbackslash}Mapsfrom & Leftwards Double Arrow From Bar \\
\hline
U+02907 & ⤇ & {\textbackslash}Mapsto & Rightwards Double Arrow From Bar \\
\hline
U+02908 & ⤈ & {\textbackslash}downarrowbarred & Downwards Arrow With Horizontal Stroke \\
\hline
U+02909 & ⤉ & {\textbackslash}uparrowbarred & Upwards Arrow With Horizontal Stroke \\
\hline
U+0290A & ⤊ & {\textbackslash}Uuparrow & Upwards Triple Arrow \\
\hline
U+0290B & ⤋ & {\textbackslash}Ddownarrow & Downwards Triple Arrow \\
\hline
U+0290C & ⤌ & {\textbackslash}leftbkarrow & Leftwards Double Dash Arrow \\
\hline
U+0290D & ⤍ & {\textbackslash}bkarow & Rightwards Double Dash Arrow \\
\hline
U+0290E & ⤎ & {\textbackslash}leftdbkarrow & Leftwards Triple Dash Arrow \\
\hline
U+0290F & ⤏ & {\textbackslash}dbkarow & Rightwards Triple Dash Arrow \\
\hline
U+02910 & ⤐ & {\textbackslash}drbkarrow & Rightwards Two-headed Triple Dash Arrow \\
\hline
U+02911 & ⤑ & {\textbackslash}rightdotarrow & Rightwards Arrow With Dotted Stem \\
\hline
U+02912 & ⤒ & {\textbackslash}UpArrowBar & Upwards Arrow To Bar \\
\hline
U+02913 & ⤓ & {\textbackslash}DownArrowBar & Downwards Arrow To Bar \\
\hline
U+02914 & ⤔ & {\textbackslash}nvrightarrowtail & Rightwards Arrow With Tail With Vertical Stroke \\
\hline
U+02915 & ⤕ & {\textbackslash}nVrightarrowtail & Rightwards Arrow With Tail With Double Vertical Stroke \\
\hline
U+02916 & ⤖ & {\textbackslash}twoheadrightarrowtail & Rightwards Two-headed Arrow With Tail \\
\hline
U+02917 & ⤗ & {\textbackslash}nvtwoheadrightarrowtail & Rightwards Two-headed Arrow With Tail With Vertical Stroke \\
\hline
U+02918 & ⤘ & {\textbackslash}nVtwoheadrightarrowtail & Rightwards Two-headed Arrow With Tail With Double Vertical Stroke \\
\hline
U+0291D & ⤝ & {\textbackslash}diamondleftarrow & Leftwards Arrow To Black Diamond \\
\hline
U+0291E & ⤞ & {\textbackslash}rightarrowdiamond & Rightwards Arrow To Black Diamond \\
\hline
U+0291F & ⤟ & {\textbackslash}diamondleftarrowbar & Leftwards Arrow From Bar To Black Diamond \\
\hline
U+02920 & ⤠ & {\textbackslash}barrightarrowdiamond & Rightwards Arrow From Bar To Black Diamond \\
\hline
U+02925 & ⤥ & {\textbackslash}hksearow & South East Arrow With Hook \\
\hline
U+02926 & ⤦ & {\textbackslash}hkswarow & South West Arrow With Hook \\
\hline
U+02927 & ⤧ & {\textbackslash}tona & North West Arrow And North East Arrow \\
\hline
U+02928 & ⤨ & {\textbackslash}toea & North East Arrow And South East Arrow \\
\hline
U+02929 & ⤩ & {\textbackslash}tosa & South East Arrow And South West Arrow \\
\hline
U+0292A & ⤪ & {\textbackslash}towa & South West Arrow And North West Arrow \\
\hline
U+0292B & ⤫ & {\textbackslash}rdiagovfdiag & Rising Diagonal Crossing Falling Diagonal \\
\hline
U+0292C & ⤬ & {\textbackslash}fdiagovrdiag & Falling Diagonal Crossing Rising Diagonal \\
\hline
U+0292D & ⤭ & {\textbackslash}seovnearrow & South East Arrow Crossing North East Arrow \\
\hline
U+0292E & ⤮ & {\textbackslash}neovsearrow & North East Arrow Crossing South East Arrow \\
\hline
U+0292F & ⤯ & {\textbackslash}fdiagovnearrow & Falling Diagonal Crossing North East Arrow \\
\hline
U+02930 & ⤰ & {\textbackslash}rdiagovsearrow & Rising Diagonal Crossing South East Arrow \\
\hline
U+02931 & ⤱ & {\textbackslash}neovnwarrow & North East Arrow Crossing North West Arrow \\
\hline
U+02932 & ⤲ & {\textbackslash}nwovnearrow & North West Arrow Crossing North East Arrow \\
\hline
U+02934 & ⤴ & {\textbackslash}:arrow\_heading\_up: & Arrow Pointing Rightwards Then Curving Upwards \\
\hline
U+02935 & ⤵ & {\textbackslash}:arrow\_heading\_down: & Arrow Pointing Rightwards Then Curving Downwards \\
\hline
U+02942 & ⥂ & {\textbackslash}ElzRlarr & Rightwards Arrow Above Short Leftwards Arrow \\
\hline
U+02944 & ⥄ & {\textbackslash}ElzrLarr & Short Rightwards Arrow Above Leftwards Arrow \\
\hline
U+02945 & ⥅ & {\textbackslash}rightarrowplus & Rightwards Arrow With Plus Below \\
\hline
U+02946 & ⥆ & {\textbackslash}leftarrowplus & Leftwards Arrow With Plus Below \\
\hline
U+02947 & ⥇ & {\textbackslash}Elzrarrx & Rightwards Arrow Through X \\
\hline
U+02948 & ⥈ & {\textbackslash}leftrightarrowcircle & Left Right Arrow Through Small Circle \\
\hline
U+02949 & ⥉ & {\textbackslash}twoheaduparrowcircle & Upwards Two-headed Arrow From Small Circle \\
\hline
U+0294A & ⥊ & {\textbackslash}leftrightharpoonupdown & Left Barb Up Right Barb Down Harpoon \\
\hline
U+0294B & ⥋ & {\textbackslash}leftrightharpoondownup & Left Barb Down Right Barb Up Harpoon \\
\hline
U+0294C & ⥌ & {\textbackslash}updownharpoonrightleft & Up Barb Right Down Barb Left Harpoon \\
\hline
U+0294D & ⥍ & {\textbackslash}updownharpoonleftright & Up Barb Left Down Barb Right Harpoon \\
\hline
U+0294E & ⥎ & {\textbackslash}LeftRightVector & Left Barb Up Right Barb Up Harpoon \\
\hline
U+0294F & ⥏ & {\textbackslash}RightUpDownVector & Up Barb Right Down Barb Right Harpoon \\
\hline
U+02950 & ⥐ & {\textbackslash}DownLeftRightVector & Left Barb Down Right Barb Down Harpoon \\
\hline
U+02951 & ⥑ & {\textbackslash}LeftUpDownVector & Up Barb Left Down Barb Left Harpoon \\
\hline
U+02952 & ⥒ & {\textbackslash}LeftVectorBar & Leftwards Harpoon With Barb Up To Bar \\
\hline
U+02953 & ⥓ & {\textbackslash}RightVectorBar & Rightwards Harpoon With Barb Up To Bar \\
\hline
U+02954 & ⥔ & {\textbackslash}RightUpVectorBar & Upwards Harpoon With Barb Right To Bar \\
\hline
U+02955 & ⥕ & {\textbackslash}RightDownVectorBar & Downwards Harpoon With Barb Right To Bar \\
\hline
U+02956 & ⥖ & {\textbackslash}DownLeftVectorBar & Leftwards Harpoon With Barb Down To Bar \\
\hline
U+02957 & ⥗ & {\textbackslash}DownRightVectorBar & Rightwards Harpoon With Barb Down To Bar \\
\hline
U+02958 & ⥘ & {\textbackslash}LeftUpVectorBar & Upwards Harpoon With Barb Left To Bar \\
\hline
U+02959 & ⥙ & {\textbackslash}LeftDownVectorBar & Downwards Harpoon With Barb Left To Bar \\
\hline
U+0295A & ⥚ & {\textbackslash}LeftTeeVector & Leftwards Harpoon With Barb Up From Bar \\
\hline
U+0295B & ⥛ & {\textbackslash}RightTeeVector & Rightwards Harpoon With Barb Up From Bar \\
\hline
U+0295C & ⥜ & {\textbackslash}RightUpTeeVector & Upwards Harpoon With Barb Right From Bar \\
\hline
U+0295D & ⥝ & {\textbackslash}RightDownTeeVector & Downwards Harpoon With Barb Right From Bar \\
\hline
U+0295E & ⥞ & {\textbackslash}DownLeftTeeVector & Leftwards Harpoon With Barb Down From Bar \\
\hline
U+0295F & ⥟ & {\textbackslash}DownRightTeeVector & Rightwards Harpoon With Barb Down From Bar \\
\hline
U+02960 & ⥠ & {\textbackslash}LeftUpTeeVector & Upwards Harpoon With Barb Left From Bar \\
\hline
U+02961 & ⥡ & {\textbackslash}LeftDownTeeVector & Downwards Harpoon With Barb Left From Bar \\
\hline
U+02962 & ⥢ & {\textbackslash}leftharpoonsupdown & Leftwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Down \\
\hline
U+02963 & ⥣ & {\textbackslash}upharpoonsleftright & Upwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right \\
\hline
U+02964 & ⥤ & {\textbackslash}rightharpoonsupdown & Rightwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Down \\
\hline
U+02965 & ⥥ & {\textbackslash}downharpoonsleftright & Downwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right \\
\hline
U+02966 & ⥦ & {\textbackslash}leftrightharpoonsup & Leftwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Up \\
\hline
U+02967 & ⥧ & {\textbackslash}leftrightharpoonsdown & Leftwards Harpoon With Barb Down Above Rightwards Harpoon With Barb Down \\
\hline
U+02968 & ⥨ & {\textbackslash}rightleftharpoonsup & Rightwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Up \\
\hline
U+02969 & ⥩ & {\textbackslash}rightleftharpoonsdown & Rightwards Harpoon With Barb Down Above Leftwards Harpoon With Barb Down \\
\hline
U+0296A & ⥪ & {\textbackslash}leftharpoonupdash & Leftwards Harpoon With Barb Up Above Long Dash \\
\hline
U+0296B & ⥫ & {\textbackslash}dashleftharpoondown & Leftwards Harpoon With Barb Down Below Long Dash \\
\hline
U+0296C & ⥬ & {\textbackslash}rightharpoonupdash & Rightwards Harpoon With Barb Up Above Long Dash \\
\hline
U+0296D & ⥭ & {\textbackslash}dashrightharpoondown & Rightwards Harpoon With Barb Down Below Long Dash \\
\hline
U+0296E & ⥮ & {\textbackslash}UpEquilibrium & Upwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right \\
\hline
U+0296F & ⥯ & {\textbackslash}ReverseUpEquilibrium & Downwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right \\
\hline
U+02970 & ⥰ & {\textbackslash}RoundImplies & Right Double Arrow With Rounded Head \\
\hline
U+02980 & ⦀ & {\textbackslash}Vvert & Triple Vertical Bar Delimiter \\
\hline
U+02986 & ⦆ & {\textbackslash}Elroang & Right White Parenthesis \\
\hline
U+02999 & ⦙ & {\textbackslash}Elzddfnc & Dotted Fence \\
\hline
U+0299B & ⦛ & {\textbackslash}measuredangleleft & Measured Angle Opening Left \\
\hline
U+0299C & ⦜ & {\textbackslash}Angle & Right Angle Variant With Square \\
\hline
U+0299D & ⦝ & {\textbackslash}rightanglemdot & Measured Right Angle With Dot \\
\hline
U+0299E & ⦞ & {\textbackslash}angles & Angle With S Inside \\
\hline
U+0299F & ⦟ & {\textbackslash}angdnr & Acute Angle \\
\hline
U+029A0 & ⦠ & {\textbackslash}Elzlpargt & Spherical Angle Opening Left \\
\hline
U+029A1 & ⦡ & {\textbackslash}sphericalangleup & Spherical Angle Opening Up \\
\hline
U+029A2 & ⦢ & {\textbackslash}turnangle & Turned Angle \\
\hline
U+029A3 & ⦣ & {\textbackslash}revangle & Reversed Angle \\
\hline
U+029A4 & ⦤ & {\textbackslash}angleubar & Angle With Underbar \\
\hline
U+029A5 & ⦥ & {\textbackslash}revangleubar & Reversed Angle With Underbar \\
\hline
U+029A6 & ⦦ & {\textbackslash}wideangledown & Oblique Angle Opening Up \\
\hline
U+029A7 & ⦧ & {\textbackslash}wideangleup & Oblique Angle Opening Down \\
\hline
U+029A8 & ⦨ & {\textbackslash}measanglerutone & Measured Angle With Open Arm Ending In Arrow Pointing Up And Right \\
\hline
U+029A9 & ⦩ & {\textbackslash}measanglelutonw & Measured Angle With Open Arm Ending In Arrow Pointing Up And Left \\
\hline
U+029AA & ⦪ & {\textbackslash}measanglerdtose & Measured Angle With Open Arm Ending In Arrow Pointing Down And Right \\
\hline
U+029AB & ⦫ & {\textbackslash}measangleldtosw & Measured Angle With Open Arm Ending In Arrow Pointing Down And Left \\
\hline
U+029AC & ⦬ & {\textbackslash}measangleurtone & Measured Angle With Open Arm Ending In Arrow Pointing Right And Up \\
\hline
U+029AD & ⦭ & {\textbackslash}measangleultonw & Measured Angle With Open Arm Ending In Arrow Pointing Left And Up \\
\hline
U+029AE & ⦮ & {\textbackslash}measangledrtose & Measured Angle With Open Arm Ending In Arrow Pointing Right And Down \\
\hline
U+029AF & ⦯ & {\textbackslash}measangledltosw & Measured Angle With Open Arm Ending In Arrow Pointing Left And Down \\
\hline
U+029B0 & ⦰ & {\textbackslash}revemptyset & Reversed Empty Set \\
\hline
U+029B1 & ⦱ & {\textbackslash}emptysetobar & Empty Set With Overbar \\
\hline
U+029B2 & ⦲ & {\textbackslash}emptysetocirc & Empty Set With Small Circle Above \\
\hline
U+029B3 & ⦳ & {\textbackslash}emptysetoarr & Empty Set With Right Arrow Above \\
\hline
U+029B4 & ⦴ & {\textbackslash}emptysetoarrl & Empty Set With Left Arrow Above \\
\hline
U+029B7 & ⦷ & {\textbackslash}circledparallel & Circled Parallel \\
\hline
U+029B8 & ⦸ & {\textbackslash}obslash & Circled Reverse Solidus \\
\hline
U+029BC & ⦼ & {\textbackslash}odotslashdot & Circled Anticlockwise-rotated Division Sign \\
\hline
U+029BE & ⦾ & {\textbackslash}circledwhitebullet & Circled White Bullet \\
\hline
U+029BF & ⦿ & {\textbackslash}circledbullet & Circled Bullet \\
\hline
U+029C0 & ⧀ & {\textbackslash}olessthan & Circled Less-than \\
\hline
U+029C1 & ⧁ & {\textbackslash}ogreaterthan & Circled Greater-than \\
\hline
U+029C4 & ⧄ & {\textbackslash}boxdiag & Squared Rising Diagonal Slash \\
\hline
U+029C5 & ⧅ & {\textbackslash}boxbslash & Squared Falling Diagonal Slash \\
\hline
U+029C6 & ⧆ & {\textbackslash}boxast & Squared Asterisk \\
\hline
U+029C7 & ⧇ & {\textbackslash}boxcircle & Squared Small Circle \\
\hline
U+029CA & ⧊ & {\textbackslash}ElzLap & Triangle With Dot Above \\
\hline
U+029CB & ⧋ & {\textbackslash}Elzdefas & Triangle With Underbar \\
\hline
U+029CF & ⧏ & {\textbackslash}LeftTriangleBar & Left Triangle Beside Vertical Bar \\
\hline
U+029CF + U+00338 & ⧏̸ & {\textbackslash}NotLeftTriangleBar & Left Triangle Beside Vertical Bar + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+029D0 & ⧐ & {\textbackslash}RightTriangleBar & Vertical Bar Beside Right Triangle \\
\hline
U+029D0 + U+00338 & ⧐̸ & {\textbackslash}NotRightTriangleBar & Vertical Bar Beside Right Triangle + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+029DF & ⧟ & {\textbackslash}dualmap & Double-ended Multimap \\
\hline
U+029E1 & ⧡ & {\textbackslash}lrtriangleeq & Increases As \\
\hline
U+029E2 & ⧢ & {\textbackslash}shuffle & Shuffle Product \\
\hline
U+029E3 & ⧣ & {\textbackslash}eparsl & Equals Sign And Slanted Parallel \\
\hline
U+029E4 & ⧤ & {\textbackslash}smeparsl & Equals Sign And Slanted Parallel With Tilde Above \\
\hline
U+029E5 & ⧥ & {\textbackslash}eqvparsl & Identical To And Slanted Parallel \\
\hline
U+029EB & ⧫ & {\textbackslash}blacklozenge & Black Lozenge \\
\hline
U+029F4 & ⧴ & {\textbackslash}RuleDelayed & Rule-delayed \\
\hline
U+029F6 & ⧶ & {\textbackslash}dsol & Solidus With Overbar \\
\hline
U+029F7 & ⧷ & {\textbackslash}rsolbar & Reverse Solidus With Horizontal Stroke \\
\hline
U+029FA & ⧺ & {\textbackslash}doubleplus & Double Plus \\
\hline
U+029FB & ⧻ & {\textbackslash}tripleplus & Triple Plus \\
\hline
U+02A00 & ⨀ & {\textbackslash}bigodot & N-ary Circled Dot Operator \\
\hline
U+02A01 & ⨁ & {\textbackslash}bigoplus & N-ary Circled Plus Operator \\
\hline
U+02A02 & ⨂ & {\textbackslash}bigotimes & N-ary Circled Times Operator \\
\hline
U+02A03 & ⨃ & {\textbackslash}bigcupdot & N-ary Union Operator With Dot \\
\hline
U+02A04 & ⨄ & {\textbackslash}biguplus & N-ary Union Operator With Plus \\
\hline
U+02A05 & ⨅ & {\textbackslash}bigsqcap & N-ary Square Intersection Operator \\
\hline
U+02A06 & ⨆ & {\textbackslash}bigsqcup & N-ary Square Union Operator \\
\hline
U+02A07 & ⨇ & {\textbackslash}conjquant & Two Logical And Operator \\
\hline
U+02A08 & ⨈ & {\textbackslash}disjquant & Two Logical Or Operator \\
\hline
U+02A09 & ⨉ & {\textbackslash}bigtimes & N-ary Times Operator \\
\hline
U+02A0A & ⨊ & {\textbackslash}modtwosum & Modulo Two Sum \\
\hline
U+02A0B & ⨋ & {\textbackslash}sumint & Summation With Integral \\
\hline
U+02A0C & ⨌ & {\textbackslash}iiiint & Quadruple Integral Operator \\
\hline
U+02A0D & ⨍ & {\textbackslash}intbar & Finite Part Integral \\
\hline
U+02A0E & ⨎ & {\textbackslash}intBar & Integral With Double Stroke \\
\hline
U+02A0F & ⨏ & {\textbackslash}clockoint & Integral Average With Slash \\
\hline
U+02A10 & ⨐ & {\textbackslash}cirfnint & Circulation Function \\
\hline
U+02A11 & ⨑ & {\textbackslash}awint & Anticlockwise Integration \\
\hline
U+02A12 & ⨒ & {\textbackslash}rppolint & Line Integration With Rectangular Path Around Pole \\
\hline
U+02A13 & ⨓ & {\textbackslash}scpolint & Line Integration With Semicircular Path Around Pole \\
\hline
U+02A14 & ⨔ & {\textbackslash}npolint & Line Integration Not Including The Pole \\
\hline
U+02A15 & ⨕ & {\textbackslash}pointint & Integral Around A Point Operator \\
\hline
U+02A16 & ⨖ & {\textbackslash}sqrint & Quaternion Integral Operator \\
\hline
U+02A18 & ⨘ & {\textbackslash}intx & Integral With Times Sign \\
\hline
U+02A19 & ⨙ & {\textbackslash}intcap & Integral With Intersection \\
\hline
U+02A1A & ⨚ & {\textbackslash}intcup & Integral With Union \\
\hline
U+02A1B & ⨛ & {\textbackslash}upint & Integral With Overbar \\
\hline
U+02A1C & ⨜ & {\textbackslash}lowint & Integral With Underbar \\
\hline
U+02A1D & ⨝ & {\textbackslash}Join & Join \\
\hline
U+02A22 & ⨢ & {\textbackslash}ringplus & Plus Sign With Small Circle Above \\
\hline
U+02A23 & ⨣ & {\textbackslash}plushat & Plus Sign With Circumflex Accent Above \\
\hline
U+02A24 & ⨤ & {\textbackslash}simplus & Plus Sign With Tilde Above \\
\hline
U+02A25 & ⨥ & {\textbackslash}plusdot & Plus Sign With Dot Below \\
\hline
U+02A26 & ⨦ & {\textbackslash}plussim & Plus Sign With Tilde Below \\
\hline
U+02A27 & ⨧ & {\textbackslash}plussubtwo & Plus Sign With Subscript Two \\
\hline
U+02A28 & ⨨ & {\textbackslash}plustrif & Plus Sign With Black Triangle \\
\hline
U+02A29 & ⨩ & {\textbackslash}commaminus & Minus Sign With Comma Above \\
\hline
U+02A2A & ⨪ & {\textbackslash}minusdot & Minus Sign With Dot Below \\
\hline
U+02A2B & ⨫ & {\textbackslash}minusfdots & Minus Sign With Falling Dots \\
\hline
U+02A2C & ⨬ & {\textbackslash}minusrdots & Minus Sign With Rising Dots \\
\hline
U+02A2D & ⨭ & {\textbackslash}opluslhrim & Plus Sign In Left Half Circle \\
\hline
U+02A2E & ⨮ & {\textbackslash}oplusrhrim & Plus Sign In Right Half Circle \\
\hline
U+02A2F & ⨯ & {\textbackslash}ElzTimes & Vector Or Cross Product \\
\hline
U+02A30 & ⨰ & {\textbackslash}dottimes & Multiplication Sign With Dot Above \\
\hline
U+02A31 & ⨱ & {\textbackslash}timesbar & Multiplication Sign With Underbar \\
\hline
U+02A32 & ⨲ & {\textbackslash}btimes & Semidirect Product With Bottom Closed \\
\hline
U+02A33 & ⨳ & {\textbackslash}smashtimes & Smash Product \\
\hline
U+02A34 & ⨴ & {\textbackslash}otimeslhrim & Multiplication Sign In Left Half Circle \\
\hline
U+02A35 & ⨵ & {\textbackslash}otimesrhrim & Multiplication Sign In Right Half Circle \\
\hline
U+02A36 & ⨶ & {\textbackslash}otimeshat & Circled Multiplication Sign With Circumflex Accent \\
\hline
U+02A37 & ⨷ & {\textbackslash}Otimes & Multiplication Sign In Double Circle \\
\hline
U+02A38 & ⨸ & {\textbackslash}odiv & Circled Division Sign \\
\hline
U+02A39 & ⨹ & {\textbackslash}triangleplus & Plus Sign In Triangle \\
\hline
U+02A3A & ⨺ & {\textbackslash}triangleminus & Minus Sign In Triangle \\
\hline
U+02A3B & ⨻ & {\textbackslash}triangletimes & Multiplication Sign In Triangle \\
\hline
U+02A3C & ⨼ & {\textbackslash}intprod & Interior Product \\
\hline
U+02A3D & ⨽ & {\textbackslash}intprodr & Righthand Interior Product \\
\hline
U+02A3F & ⨿ & {\textbackslash}amalg & Amalgamation Or Coproduct \\
\hline
U+02A40 & ⩀ & {\textbackslash}capdot & Intersection With Dot \\
\hline
U+02A41 & ⩁ & {\textbackslash}uminus & Union With Minus Sign \\
\hline
U+02A42 & ⩂ & {\textbackslash}barcup & Union With Overbar \\
\hline
U+02A43 & ⩃ & {\textbackslash}barcap & Intersection With Overbar \\
\hline
U+02A44 & ⩄ & {\textbackslash}capwedge & Intersection With Logical And \\
\hline
U+02A45 & ⩅ & {\textbackslash}cupvee & Union With Logical Or \\
\hline
U+02A4A & ⩊ & {\textbackslash}twocups & Union Beside And Joined With Union \\
\hline
U+02A4B & ⩋ & {\textbackslash}twocaps & Intersection Beside And Joined With Intersection \\
\hline
U+02A4C & ⩌ & {\textbackslash}closedvarcup & Closed Union With Serifs \\
\hline
U+02A4D & ⩍ & {\textbackslash}closedvarcap & Closed Intersection With Serifs \\
\hline
U+02A4E & ⩎ & {\textbackslash}Sqcap & Double Square Intersection \\
\hline
U+02A4F & ⩏ & {\textbackslash}Sqcup & Double Square Union \\
\hline
U+02A50 & ⩐ & {\textbackslash}closedvarcupsmashprod & Closed Union With Serifs And Smash Product \\
\hline
U+02A51 & ⩑ & {\textbackslash}wedgeodot & Logical And With Dot Above \\
\hline
U+02A52 & ⩒ & {\textbackslash}veeodot & Logical Or With Dot Above \\
\hline
U+02A53 & ⩓ & {\textbackslash}ElzAnd & Double Logical And \\
\hline
U+02A54 & ⩔ & {\textbackslash}ElzOr & Double Logical Or \\
\hline
U+02A55 & ⩕ & {\textbackslash}wedgeonwedge & Two Intersecting Logical And \\
\hline
U+02A56 & ⩖ & {\textbackslash}ElOr & Two Intersecting Logical Or \\
\hline
U+02A57 & ⩗ & {\textbackslash}bigslopedvee & Sloping Large Or \\
\hline
U+02A58 & ⩘ & {\textbackslash}bigslopedwedge & Sloping Large And \\
\hline
U+02A5A & ⩚ & {\textbackslash}wedgemidvert & Logical And With Middle Stem \\
\hline
U+02A5B & ⩛ & {\textbackslash}veemidvert & Logical Or With Middle Stem \\
\hline
U+02A5C & ⩜ & {\textbackslash}midbarwedge & Logical And With Horizontal Dash \\
\hline
U+02A5D & ⩝ & {\textbackslash}midbarvee & Logical Or With Horizontal Dash \\
\hline
U+02A5E & ⩞ & {\textbackslash}perspcorrespond & Logical And With Double Overbar \\
\hline
U+02A5F & ⩟ & {\textbackslash}Elzminhat & Logical And With Underbar \\
\hline
U+02A60 & ⩠ & {\textbackslash}wedgedoublebar & Logical And With Double Underbar \\
\hline
U+02A61 & ⩡ & {\textbackslash}varveebar & Small Vee With Underbar \\
\hline
U+02A62 & ⩢ & {\textbackslash}doublebarvee & Logical Or With Double Overbar \\
\hline
U+02A63 & ⩣ & {\textbackslash}veedoublebar & Logical Or With Double Underbar \\
\hline
U+02A66 & ⩦ & {\textbackslash}eqdot & Equals Sign With Dot Below \\
\hline
U+02A67 & ⩧ & {\textbackslash}dotequiv & Identical With Dot Above \\
\hline
U+02A6A & ⩪ & {\textbackslash}dotsim & Tilde Operator With Dot Above \\
\hline
U+02A6B & ⩫ & {\textbackslash}simrdots & Tilde Operator With Rising Dots \\
\hline
U+02A6C & ⩬ & {\textbackslash}simminussim & Similar Minus Similar \\
\hline
U+02A6D & ⩭ & {\textbackslash}congdot & Congruent With Dot Above \\
\hline
U+02A6E & ⩮ & {\textbackslash}asteq & Equals With Asterisk \\
\hline
U+02A6F & ⩯ & {\textbackslash}hatapprox & Almost Equal To With Circumflex Accent \\
\hline
U+02A70 & ⩰ & {\textbackslash}approxeqq & Approximately Equal Or Equal To \\
\hline
U+02A71 & ⩱ & {\textbackslash}eqqplus & Equals Sign Above Plus Sign \\
\hline
U+02A72 & ⩲ & {\textbackslash}pluseqq & Plus Sign Above Equals Sign \\
\hline
U+02A73 & ⩳ & {\textbackslash}eqqsim & Equals Sign Above Tilde Operator \\
\hline
U+02A74 & ⩴ & {\textbackslash}Coloneq & Double Colon Equal \\
\hline
U+02A75 & ⩵ & {\textbackslash}Equal & Two Consecutive Equals Signs \\
\hline
U+02A76 & ⩶ & {\textbackslash}eqeqeq & Three Consecutive Equals Signs \\
\hline
U+02A77 & ⩷ & {\textbackslash}ddotseq & Equals Sign With Two Dots Above And Two Dots Below \\
\hline
U+02A78 & ⩸ & {\textbackslash}equivDD & Equivalent With Four Dots Above \\
\hline
U+02A79 & ⩹ & {\textbackslash}ltcir & Less-than With Circle Inside \\
\hline
U+02A7A & ⩺ & {\textbackslash}gtcir & Greater-than With Circle Inside \\
\hline
U+02A7B & ⩻ & {\textbackslash}ltquest & Less-than With Question Mark Above \\
\hline
U+02A7C & ⩼ & {\textbackslash}gtquest & Greater-than With Question Mark Above \\
\hline
U+02A7D & ⩽ & {\textbackslash}leqslant & Less-than Or Slanted Equal To \\
\hline
U+02A7D + U+00338 & ⩽̸ & {\textbackslash}nleqslant & Less-than Or Slanted Equal To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02A7E & ⩾ & {\textbackslash}geqslant & Greater-than Or Slanted Equal To \\
\hline
U+02A7E + U+00338 & ⩾̸ & {\textbackslash}ngeqslant & Greater-than Or Slanted Equal To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02A7F & ⩿ & {\textbackslash}lesdot & Less-than Or Slanted Equal To With Dot Inside \\
\hline
U+02A80 & ⪀ & {\textbackslash}gesdot & Greater-than Or Slanted Equal To With Dot Inside \\
\hline
U+02A81 & ⪁ & {\textbackslash}lesdoto & Less-than Or Slanted Equal To With Dot Above \\
\hline
U+02A82 & ⪂ & {\textbackslash}gesdoto & Greater-than Or Slanted Equal To With Dot Above \\
\hline
U+02A83 & ⪃ & {\textbackslash}lesdotor & Less-than Or Slanted Equal To With Dot Above Right \\
\hline
U+02A84 & ⪄ & {\textbackslash}gesdotol & Greater-than Or Slanted Equal To With Dot Above Left \\
\hline
U+02A85 & ⪅ & {\textbackslash}lessapprox & Less-than Or Approximate \\
\hline
U+02A86 & ⪆ & {\textbackslash}gtrapprox & Greater-than Or Approximate \\
\hline
U+02A87 & ⪇ & {\textbackslash}lneq & Less-than And Single-line Not Equal To \\
\hline
U+02A88 & ⪈ & {\textbackslash}gneq & Greater-than And Single-line Not Equal To \\
\hline
U+02A89 & ⪉ & {\textbackslash}lnapprox & Less-than And Not Approximate \\
\hline
U+02A8A & ⪊ & {\textbackslash}gnapprox & Greater-than And Not Approximate \\
\hline
U+02A8B & ⪋ & {\textbackslash}lesseqqgtr & Less-than Above Double-line Equal Above Greater-than \\
\hline
U+02A8C & ⪌ & {\textbackslash}gtreqqless & Greater-than Above Double-line Equal Above Less-than \\
\hline
U+02A8D & ⪍ & {\textbackslash}lsime & Less-than Above Similar Or Equal \\
\hline
U+02A8E & ⪎ & {\textbackslash}gsime & Greater-than Above Similar Or Equal \\
\hline
U+02A8F & ⪏ & {\textbackslash}lsimg & Less-than Above Similar Above Greater-than \\
\hline
U+02A90 & ⪐ & {\textbackslash}gsiml & Greater-than Above Similar Above Less-than \\
\hline
U+02A91 & ⪑ & {\textbackslash}lgE & Less-than Above Greater-than Above Double-line Equal \\
\hline
U+02A92 & ⪒ & {\textbackslash}glE & Greater-than Above Less-than Above Double-line Equal \\
\hline
U+02A93 & ⪓ & {\textbackslash}lesges & Less-than Above Slanted Equal Above Greater-than Above Slanted Equal \\
\hline
U+02A94 & ⪔ & {\textbackslash}gesles & Greater-than Above Slanted Equal Above Less-than Above Slanted Equal \\
\hline
U+02A95 & ⪕ & {\textbackslash}eqslantless & Slanted Equal To Or Less-than \\
\hline
U+02A96 & ⪖ & {\textbackslash}eqslantgtr & Slanted Equal To Or Greater-than \\
\hline
U+02A97 & ⪗ & {\textbackslash}elsdot & Slanted Equal To Or Less-than With Dot Inside \\
\hline
U+02A98 & ⪘ & {\textbackslash}egsdot & Slanted Equal To Or Greater-than With Dot Inside \\
\hline
U+02A99 & ⪙ & {\textbackslash}eqqless & Double-line Equal To Or Less-than \\
\hline
U+02A9A & ⪚ & {\textbackslash}eqqgtr & Double-line Equal To Or Greater-than \\
\hline
U+02A9B & ⪛ & {\textbackslash}eqqslantless & Double-line Slanted Equal To Or Less-than \\
\hline
U+02A9C & ⪜ & {\textbackslash}eqqslantgtr & Double-line Slanted Equal To Or Greater-than \\
\hline
U+02A9D & ⪝ & {\textbackslash}simless & Similar Or Less-than \\
\hline
U+02A9E & ⪞ & {\textbackslash}simgtr & Similar Or Greater-than \\
\hline
U+02A9F & ⪟ & {\textbackslash}simlE & Similar Above Less-than Above Equals Sign \\
\hline
U+02AA0 & ⪠ & {\textbackslash}simgE & Similar Above Greater-than Above Equals Sign \\
\hline
U+02AA1 & ⪡ & {\textbackslash}NestedLessLess & Double Nested Less-than \\
\hline
U+02AA1 + U+00338 & ⪡̸ & {\textbackslash}NotNestedLessLess & Double Nested Less-than + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AA2 & ⪢ & {\textbackslash}NestedGreaterGreater & Double Nested Greater-than \\
\hline
U+02AA2 + U+00338 & ⪢̸ & {\textbackslash}NotNestedGreaterGreater & Double Nested Greater-than + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AA3 & ⪣ & {\textbackslash}partialmeetcontraction & Double Nested Less-than With Underbar \\
\hline
U+02AA4 & ⪤ & {\textbackslash}glj & Greater-than Overlapping Less-than \\
\hline
U+02AA5 & ⪥ & {\textbackslash}gla & Greater-than Beside Less-than \\
\hline
U+02AA6 & ⪦ & {\textbackslash}ltcc & Less-than Closed By Curve \\
\hline
U+02AA7 & ⪧ & {\textbackslash}gtcc & Greater-than Closed By Curve \\
\hline
U+02AA8 & ⪨ & {\textbackslash}lescc & Less-than Closed By Curve Above Slanted Equal \\
\hline
U+02AA9 & ⪩ & {\textbackslash}gescc & Greater-than Closed By Curve Above Slanted Equal \\
\hline
U+02AAA & ⪪ & {\textbackslash}smt & Smaller Than \\
\hline
U+02AAB & ⪫ & {\textbackslash}lat & Larger Than \\
\hline
U+02AAC & ⪬ & {\textbackslash}smte & Smaller Than Or Equal To \\
\hline
U+02AAD & ⪭ & {\textbackslash}late & Larger Than Or Equal To \\
\hline
U+02AAE & ⪮ & {\textbackslash}bumpeqq & Equals Sign With Bumpy Above \\
\hline
U+02AAF & ⪯ & {\textbackslash}preceq & Precedes Above Single-line Equals Sign \\
\hline
U+02AAF + U+00338 & ⪯̸ & {\textbackslash}npreceq & Precedes Above Single-line Equals Sign + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AB0 & ⪰ & {\textbackslash}succeq & Succeeds Above Single-line Equals Sign \\
\hline
U+02AB0 + U+00338 & ⪰̸ & {\textbackslash}nsucceq & Succeeds Above Single-line Equals Sign + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AB1 & ⪱ & {\textbackslash}precneq & Precedes Above Single-line Not Equal To \\
\hline
U+02AB2 & ⪲ & {\textbackslash}succneq & Succeeds Above Single-line Not Equal To \\
\hline
U+02AB3 & ⪳ & {\textbackslash}preceqq & Precedes Above Equals Sign \\
\hline
U+02AB4 & ⪴ & {\textbackslash}succeqq & Succeeds Above Equals Sign \\
\hline
U+02AB5 & ⪵ & {\textbackslash}precneqq & Precedes Above Not Equal To \\
\hline
U+02AB6 & ⪶ & {\textbackslash}succneqq & Succeeds Above Not Equal To \\
\hline
U+02AB7 & ⪷ & {\textbackslash}precapprox & Precedes Above Almost Equal To \\
\hline
U+02AB8 & ⪸ & {\textbackslash}succapprox & Succeeds Above Almost Equal To \\
\hline
U+02AB9 & ⪹ & {\textbackslash}precnapprox & Precedes Above Not Almost Equal To \\
\hline
U+02ABA & ⪺ & {\textbackslash}succnapprox & Succeeds Above Not Almost Equal To \\
\hline
U+02ABB & ⪻ & {\textbackslash}Prec & Double Precedes \\
\hline
U+02ABC & ⪼ & {\textbackslash}Succ & Double Succeeds \\
\hline
U+02ABD & ⪽ & {\textbackslash}subsetdot & Subset With Dot \\
\hline
U+02ABE & ⪾ & {\textbackslash}supsetdot & Superset With Dot \\
\hline
U+02ABF & ⪿ & {\textbackslash}subsetplus & Subset With Plus Sign Below \\
\hline
U+02AC0 & ⫀ & {\textbackslash}supsetplus & Superset With Plus Sign Below \\
\hline
U+02AC1 & ⫁ & {\textbackslash}submult & Subset With Multiplication Sign Below \\
\hline
U+02AC2 & ⫂ & {\textbackslash}supmult & Superset With Multiplication Sign Below \\
\hline
U+02AC3 & ⫃ & {\textbackslash}subedot & Subset Of Or Equal To With Dot Above \\
\hline
U+02AC4 & ⫄ & {\textbackslash}supedot & Superset Of Or Equal To With Dot Above \\
\hline
U+02AC5 & ⫅ & {\textbackslash}subseteqq & Subset Of Above Equals Sign \\
\hline
U+02AC5 + U+00338 & ⫅̸ & {\textbackslash}nsubseteqq & Subset Of Above Equals Sign + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AC6 & ⫆ & {\textbackslash}supseteqq & Superset Of Above Equals Sign \\
\hline
U+02AC6 + U+00338 & ⫆̸ & {\textbackslash}nsupseteqq & Superset Of Above Equals Sign + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AC7 & ⫇ & {\textbackslash}subsim & Subset Of Above Tilde Operator \\
\hline
U+02AC8 & ⫈ & {\textbackslash}supsim & Superset Of Above Tilde Operator \\
\hline
U+02AC9 & ⫉ & {\textbackslash}subsetapprox & Subset Of Above Almost Equal To \\
\hline
U+02ACA & ⫊ & {\textbackslash}supsetapprox & Superset Of Above Almost Equal To \\
\hline
U+02ACB & ⫋ & {\textbackslash}subsetneqq & Subset Of Above Not Equal To \\
\hline
U+02ACC & ⫌ & {\textbackslash}supsetneqq & Superset Of Above Not Equal To \\
\hline
U+02ACD & ⫍ & {\textbackslash}lsqhook & Square Left Open Box Operator \\
\hline
U+02ACE & ⫎ & {\textbackslash}rsqhook & Square Right Open Box Operator \\
\hline
U+02ACF & ⫏ & {\textbackslash}csub & Closed Subset \\
\hline
U+02AD0 & ⫐ & {\textbackslash}csup & Closed Superset \\
\hline
U+02AD1 & ⫑ & {\textbackslash}csube & Closed Subset Or Equal To \\
\hline
U+02AD2 & ⫒ & {\textbackslash}csupe & Closed Superset Or Equal To \\
\hline
U+02AD3 & ⫓ & {\textbackslash}subsup & Subset Above Superset \\
\hline
U+02AD4 & ⫔ & {\textbackslash}supsub & Superset Above Subset \\
\hline
U+02AD5 & ⫕ & {\textbackslash}subsub & Subset Above Subset \\
\hline
U+02AD6 & ⫖ & {\textbackslash}supsup & Superset Above Superset \\
\hline
U+02AD7 & ⫗ & {\textbackslash}suphsub & Superset Beside Subset \\
\hline
U+02AD8 & ⫘ & {\textbackslash}supdsub & Superset Beside And Joined By Dash With Subset \\
\hline
U+02AD9 & ⫙ & {\textbackslash}forkv & Element Of Opening Downwards \\
\hline
U+02ADB & ⫛ & {\textbackslash}mlcp & Transversal Intersection \\
\hline
U+02ADC & ⫝̸ & {\textbackslash}forks & Forking \\
\hline
U+02ADD & ⫝ & {\textbackslash}forksnot & Nonforking \\
\hline
U+02AE3 & ⫣ & {\textbackslash}dashV & Double Vertical Bar Left Turnstile \\
\hline
U+02AE4 & ⫤ & {\textbackslash}Dashv & Vertical Bar Double Left Turnstile \\
\hline
U+02AF4 & ⫴ & {\textbackslash}interleave & Triple Vertical Bar Binary Relation \\
\hline
U+02AF6 & ⫶ & {\textbackslash}Elztdcol & Triple Colon Operator \\
\hline
U+02AF7 & ⫷ & {\textbackslash}lllnest & Triple Nested Less-than \\
\hline
U+02AF8 & ⫸ & {\textbackslash}gggnest & Triple Nested Greater-than \\
\hline
U+02AF9 & ⫹ & {\textbackslash}leqqslant & Double-line Slanted Less-than Or Equal To \\
\hline
U+02AFA & ⫺ & {\textbackslash}geqqslant & Double-line Slanted Greater-than Or Equal To \\
\hline
U+02B05 & ⬅ & {\textbackslash}:arrow\_left: & Leftwards Black Arrow \\
\hline
U+02B06 & ⬆ & {\textbackslash}:arrow\_up: & Upwards Black Arrow \\
\hline
U+02B07 & ⬇ & {\textbackslash}:arrow\_down: & Downwards Black Arrow \\
\hline
U+02B12 & ⬒ & {\textbackslash}squaretopblack & Square With Top Half Black \\
\hline
U+02B13 & ⬓ & {\textbackslash}squarebotblack & Square With Bottom Half Black \\
\hline
U+02B14 & ⬔ & {\textbackslash}squareurblack & Square With Upper Right Diagonal Half Black \\
\hline
U+02B15 & ⬕ & {\textbackslash}squarellblack & Square With Lower Left Diagonal Half Black \\
\hline
U+02B16 & ⬖ & {\textbackslash}diamondleftblack & Diamond With Left Half Black \\
\hline
U+02B17 & ⬗ & {\textbackslash}diamondrightblack & Diamond With Right Half Black \\
\hline
U+02B18 & ⬘ & {\textbackslash}diamondtopblack & Diamond With Top Half Black \\
\hline
U+02B19 & ⬙ & {\textbackslash}diamondbotblack & Diamond With Bottom Half Black \\
\hline
U+02B1A & ⬚ & {\textbackslash}dottedsquare & Dotted Square \\
\hline
U+02B1B & ⬛ & {\textbackslash}lgblksquare, {\textbackslash}:black\_large\_square: & Black Large Square \\
\hline
U+02B1C & ⬜ & {\textbackslash}lgwhtsquare, {\textbackslash}:white\_large\_square: & White Large Square \\
\hline
U+02B1D & ⬝ & {\textbackslash}vysmblksquare & Black Very Small Square \\
\hline
U+02B1E & ⬞ & {\textbackslash}vysmwhtsquare & White Very Small Square \\
\hline
U+02B1F & ⬟ & {\textbackslash}pentagonblack & Black Pentagon \\
\hline
U+02B20 & ⬠ & {\textbackslash}pentagon & White Pentagon \\
\hline
U+02B21 & ⬡ & {\textbackslash}varhexagon & White Hexagon \\
\hline
U+02B22 & ⬢ & {\textbackslash}varhexagonblack & Black Hexagon \\
\hline
U+02B23 & ⬣ & {\textbackslash}hexagonblack & Horizontal Black Hexagon \\
\hline
U+02B24 & ⬤ & {\textbackslash}lgblkcircle & Black Large Circle \\
\hline
U+02B25 & ⬥ & {\textbackslash}mdblkdiamond & Black Medium Diamond \\
\hline
U+02B26 & ⬦ & {\textbackslash}mdwhtdiamond & White Medium Diamond \\
\hline
U+02B27 & ⬧ & {\textbackslash}mdblklozenge & Black Medium Lozenge \\
\hline
U+02B28 & ⬨ & {\textbackslash}mdwhtlozenge & White Medium Lozenge \\
\hline
U+02B29 & ⬩ & {\textbackslash}smblkdiamond & Black Small Diamond \\
\hline
U+02B2A & ⬪ & {\textbackslash}smblklozenge & Black Small Lozenge \\
\hline
U+02B2B & ⬫ & {\textbackslash}smwhtlozenge & White Small Lozenge \\
\hline
U+02B2C & ⬬ & {\textbackslash}blkhorzoval & Black Horizontal Ellipse \\
\hline
U+02B2D & ⬭ & {\textbackslash}whthorzoval & White Horizontal Ellipse \\
\hline
U+02B2E & ⬮ & {\textbackslash}blkvertoval & Black Vertical Ellipse \\
\hline
U+02B2F & ⬯ & {\textbackslash}whtvertoval & White Vertical Ellipse \\
\hline
U+02B30 & ⬰ & {\textbackslash}circleonleftarrow & Left Arrow With Small Circle \\
\hline
U+02B31 & ⬱ & {\textbackslash}leftthreearrows & Three Leftwards Arrows \\
\hline
U+02B32 & ⬲ & {\textbackslash}leftarrowonoplus & Left Arrow With Circled Plus \\
\hline
U+02B33 & ⬳ & {\textbackslash}longleftsquigarrow & Long Leftwards Squiggle Arrow \\
\hline
U+02B34 & ⬴ & {\textbackslash}nvtwoheadleftarrow & Leftwards Two-headed Arrow With Vertical Stroke \\
\hline
U+02B35 & ⬵ & {\textbackslash}nVtwoheadleftarrow & Leftwards Two-headed Arrow With Double Vertical Stroke \\
\hline
U+02B36 & ⬶ & {\textbackslash}twoheadmapsfrom & Leftwards Two-headed Arrow From Bar \\
\hline
U+02B37 & ⬷ & {\textbackslash}twoheadleftdbkarrow & Leftwards Two-headed Triple Dash Arrow \\
\hline
U+02B38 & ⬸ & {\textbackslash}leftdotarrow & Leftwards Arrow With Dotted Stem \\
\hline
U+02B39 & ⬹ & {\textbackslash}nvleftarrowtail & Leftwards Arrow With Tail With Vertical Stroke \\
\hline
U+02B3A & ⬺ & {\textbackslash}nVleftarrowtail & Leftwards Arrow With Tail With Double Vertical Stroke \\
\hline
U+02B3B & ⬻ & {\textbackslash}twoheadleftarrowtail & Leftwards Two-headed Arrow With Tail \\
\hline
U+02B3C & ⬼ & {\textbackslash}nvtwoheadleftarrowtail & Leftwards Two-headed Arrow With Tail With Vertical Stroke \\
\hline
U+02B3D & ⬽ & {\textbackslash}nVtwoheadleftarrowtail & Leftwards Two-headed Arrow With Tail With Double Vertical Stroke \\
\hline
U+02B3E & ⬾ & {\textbackslash}leftarrowx & Leftwards Arrow Through X \\
\hline
U+02B3F & ⬿ & {\textbackslash}leftcurvedarrow & Wave Arrow Pointing Directly Left \\
\hline
U+02B40 & ⭀ & {\textbackslash}equalleftarrow & Equals Sign Above Leftwards Arrow \\
\hline
U+02B41 & ⭁ & {\textbackslash}bsimilarleftarrow & Reverse Tilde Operator Above Leftwards Arrow \\
\hline
U+02B42 & ⭂ & {\textbackslash}leftarrowbackapprox & Leftwards Arrow Above Reverse Almost Equal To \\
\hline
U+02B43 & ⭃ & {\textbackslash}rightarrowgtr & Rightwards Arrow Through Greater-than \\
\hline
U+02B44 & ⭄ & {\textbackslash}rightarrowsupset & Rightwards Arrow Through Superset \\
\hline
U+02B45 & ⭅ & {\textbackslash}LLeftarrow & Leftwards Quadruple Arrow \\
\hline
U+02B46 & ⭆ & {\textbackslash}RRightarrow & Rightwards Quadruple Arrow \\
\hline
U+02B47 & ⭇ & {\textbackslash}bsimilarrightarrow & Reverse Tilde Operator Above Rightwards Arrow \\
\hline
U+02B48 & ⭈ & {\textbackslash}rightarrowbackapprox & Rightwards Arrow Above Reverse Almost Equal To \\
\hline
U+02B49 & ⭉ & {\textbackslash}similarleftarrow & Tilde Operator Above Leftwards Arrow \\
\hline
U+02B4A & ⭊ & {\textbackslash}leftarrowapprox & Leftwards Arrow Above Almost Equal To \\
\hline
U+02B4B & ⭋ & {\textbackslash}leftarrowbsimilar & Leftwards Arrow Above Reverse Tilde Operator \\
\hline
U+02B4C & ⭌ & {\textbackslash}rightarrowbsimilar & Rightwards Arrow Above Reverse Tilde Operator \\
\hline
U+02B50 & ⭐ & {\textbackslash}medwhitestar, {\textbackslash}:star: & White Medium Star \\
\hline
U+02B51 & ⭑ & {\textbackslash}medblackstar & Black Small Star \\
\hline
U+02B52 & ⭒ & {\textbackslash}smwhitestar & White Small Star \\
\hline
U+02B53 & ⭓ & {\textbackslash}rightpentagonblack & Black Right-pointing Pentagon \\
\hline
U+02B54 & ⭔ & {\textbackslash}rightpentagon & White Right-pointing Pentagon \\
\hline
U+02B55 & ⭕ & {\textbackslash}:o: & Heavy Large Circle \\
\hline
U+02C7C & ⱼ & {\textbackslash}\_j & Latin Subscript Small Letter J \\
\hline
U+02C7D & ⱽ & {\textbackslash}{\textasciicircum}V & Modifier Letter Capital V \\
\hline
U+03012 & 〒 & {\textbackslash}postalmark & Postal Mark \\
\hline
U+03030 & 〰 & {\textbackslash}:wavy\_dash: & Wavy Dash \\
\hline
U+0303D & 〽 & {\textbackslash}:part\_alternation\_mark: & Part Alternation Mark \\
\hline
U+03297 & ㊗ & {\textbackslash}:congratulations: & Circled Ideograph Congratulation \\
\hline
U+03299 & ㊙ & {\textbackslash}:secret: & Circled Ideograph Secret \\
\hline
U+1D400 & 𝐀 & {\textbackslash}mbfA & Mathematical Bold Capital A \\
\hline
U+1D401 & 𝐁 & {\textbackslash}mbfB & Mathematical Bold Capital B \\
\hline
U+1D402 & 𝐂 & {\textbackslash}mbfC & Mathematical Bold Capital C \\
\hline
U+1D403 & 𝐃 & {\textbackslash}mbfD & Mathematical Bold Capital D \\
\hline
U+1D404 & 𝐄 & {\textbackslash}mbfE & Mathematical Bold Capital E \\
\hline
U+1D405 & 𝐅 & {\textbackslash}mbfF & Mathematical Bold Capital F \\
\hline
U+1D406 & 𝐆 & {\textbackslash}mbfG & Mathematical Bold Capital G \\
\hline
U+1D407 & 𝐇 & {\textbackslash}mbfH & Mathematical Bold Capital H \\
\hline
U+1D408 & 𝐈 & {\textbackslash}mbfI & Mathematical Bold Capital I \\
\hline
U+1D409 & 𝐉 & {\textbackslash}mbfJ & Mathematical Bold Capital J \\
\hline
U+1D40A & 𝐊 & {\textbackslash}mbfK & Mathematical Bold Capital K \\
\hline
U+1D40B & 𝐋 & {\textbackslash}mbfL & Mathematical Bold Capital L \\
\hline
U+1D40C & 𝐌 & {\textbackslash}mbfM & Mathematical Bold Capital M \\
\hline
U+1D40D & 𝐍 & {\textbackslash}mbfN & Mathematical Bold Capital N \\
\hline
U+1D40E & 𝐎 & {\textbackslash}mbfO & Mathematical Bold Capital O \\
\hline
U+1D40F & 𝐏 & {\textbackslash}mbfP & Mathematical Bold Capital P \\
\hline
U+1D410 & 𝐐 & {\textbackslash}mbfQ & Mathematical Bold Capital Q \\
\hline
U+1D411 & 𝐑 & {\textbackslash}mbfR & Mathematical Bold Capital R \\
\hline
U+1D412 & 𝐒 & {\textbackslash}mbfS & Mathematical Bold Capital S \\
\hline
U+1D413 & 𝐓 & {\textbackslash}mbfT & Mathematical Bold Capital T \\
\hline
U+1D414 & 𝐔 & {\textbackslash}mbfU & Mathematical Bold Capital U \\
\hline
U+1D415 & 𝐕 & {\textbackslash}mbfV & Mathematical Bold Capital V \\
\hline
U+1D416 & 𝐖 & {\textbackslash}mbfW & Mathematical Bold Capital W \\
\hline
U+1D417 & 𝐗 & {\textbackslash}mbfX & Mathematical Bold Capital X \\
\hline
U+1D418 & 𝐘 & {\textbackslash}mbfY & Mathematical Bold Capital Y \\
\hline
U+1D419 & 𝐙 & {\textbackslash}mbfZ & Mathematical Bold Capital Z \\
\hline
U+1D41A & 𝐚 & {\textbackslash}mbfa & Mathematical Bold Small A \\
\hline
U+1D41B & 𝐛 & {\textbackslash}mbfb & Mathematical Bold Small B \\
\hline
U+1D41C & 𝐜 & {\textbackslash}mbfc & Mathematical Bold Small C \\
\hline
U+1D41D & 𝐝 & {\textbackslash}mbfd & Mathematical Bold Small D \\
\hline
U+1D41E & 𝐞 & {\textbackslash}mbfe & Mathematical Bold Small E \\
\hline
U+1D41F & 𝐟 & {\textbackslash}mbff & Mathematical Bold Small F \\
\hline
U+1D420 & 𝐠 & {\textbackslash}mbfg & Mathematical Bold Small G \\
\hline
U+1D421 & 𝐡 & {\textbackslash}mbfh & Mathematical Bold Small H \\
\hline
U+1D422 & 𝐢 & {\textbackslash}mbfi & Mathematical Bold Small I \\
\hline
U+1D423 & 𝐣 & {\textbackslash}mbfj & Mathematical Bold Small J \\
\hline
U+1D424 & 𝐤 & {\textbackslash}mbfk & Mathematical Bold Small K \\
\hline
U+1D425 & 𝐥 & {\textbackslash}mbfl & Mathematical Bold Small L \\
\hline
U+1D426 & 𝐦 & {\textbackslash}mbfm & Mathematical Bold Small M \\
\hline
U+1D427 & 𝐧 & {\textbackslash}mbfn & Mathematical Bold Small N \\
\hline
U+1D428 & 𝐨 & {\textbackslash}mbfo & Mathematical Bold Small O \\
\hline
U+1D429 & 𝐩 & {\textbackslash}mbfp & Mathematical Bold Small P \\
\hline
U+1D42A & 𝐪 & {\textbackslash}mbfq & Mathematical Bold Small Q \\
\hline
U+1D42B & 𝐫 & {\textbackslash}mbfr & Mathematical Bold Small R \\
\hline
U+1D42C & 𝐬 & {\textbackslash}mbfs & Mathematical Bold Small S \\
\hline
U+1D42D & 𝐭 & {\textbackslash}mbft & Mathematical Bold Small T \\
\hline
U+1D42E & 𝐮 & {\textbackslash}mbfu & Mathematical Bold Small U \\
\hline
U+1D42F & 𝐯 & {\textbackslash}mbfv & Mathematical Bold Small V \\
\hline
U+1D430 & 𝐰 & {\textbackslash}mbfw & Mathematical Bold Small W \\
\hline
U+1D431 & 𝐱 & {\textbackslash}mbfx & Mathematical Bold Small X \\
\hline
U+1D432 & 𝐲 & {\textbackslash}mbfy & Mathematical Bold Small Y \\
\hline
U+1D433 & 𝐳 & {\textbackslash}mbfz & Mathematical Bold Small Z \\
\hline
U+1D434 & 𝐴 & {\textbackslash}mitA & Mathematical Italic Capital A \\
\hline
U+1D435 & 𝐵 & {\textbackslash}mitB & Mathematical Italic Capital B \\
\hline
U+1D436 & 𝐶 & {\textbackslash}mitC & Mathematical Italic Capital C \\
\hline
U+1D437 & 𝐷 & {\textbackslash}mitD & Mathematical Italic Capital D \\
\hline
U+1D438 & 𝐸 & {\textbackslash}mitE & Mathematical Italic Capital E \\
\hline
U+1D439 & 𝐹 & {\textbackslash}mitF & Mathematical Italic Capital F \\
\hline
U+1D43A & 𝐺 & {\textbackslash}mitG & Mathematical Italic Capital G \\
\hline
U+1D43B & 𝐻 & {\textbackslash}mitH & Mathematical Italic Capital H \\
\hline
U+1D43C & 𝐼 & {\textbackslash}mitI & Mathematical Italic Capital I \\
\hline
U+1D43D & 𝐽 & {\textbackslash}mitJ & Mathematical Italic Capital J \\
\hline
U+1D43E & 𝐾 & {\textbackslash}mitK & Mathematical Italic Capital K \\
\hline
U+1D43F & 𝐿 & {\textbackslash}mitL & Mathematical Italic Capital L \\
\hline
U+1D440 & 𝑀 & {\textbackslash}mitM & Mathematical Italic Capital M \\
\hline
U+1D441 & 𝑁 & {\textbackslash}mitN & Mathematical Italic Capital N \\
\hline
U+1D442 & 𝑂 & {\textbackslash}mitO & Mathematical Italic Capital O \\
\hline
U+1D443 & 𝑃 & {\textbackslash}mitP & Mathematical Italic Capital P \\
\hline
U+1D444 & 𝑄 & {\textbackslash}mitQ & Mathematical Italic Capital Q \\
\hline
U+1D445 & 𝑅 & {\textbackslash}mitR & Mathematical Italic Capital R \\
\hline
U+1D446 & 𝑆 & {\textbackslash}mitS & Mathematical Italic Capital S \\
\hline
U+1D447 & 𝑇 & {\textbackslash}mitT & Mathematical Italic Capital T \\
\hline
U+1D448 & 𝑈 & {\textbackslash}mitU & Mathematical Italic Capital U \\
\hline
U+1D449 & 𝑉 & {\textbackslash}mitV & Mathematical Italic Capital V \\
\hline
U+1D44A & 𝑊 & {\textbackslash}mitW & Mathematical Italic Capital W \\
\hline
U+1D44B & 𝑋 & {\textbackslash}mitX & Mathematical Italic Capital X \\
\hline
U+1D44C & 𝑌 & {\textbackslash}mitY & Mathematical Italic Capital Y \\
\hline
U+1D44D & 𝑍 & {\textbackslash}mitZ & Mathematical Italic Capital Z \\
\hline
U+1D44E & 𝑎 & {\textbackslash}mita & Mathematical Italic Small A \\
\hline
U+1D44F & 𝑏 & {\textbackslash}mitb & Mathematical Italic Small B \\
\hline
U+1D450 & 𝑐 & {\textbackslash}mitc & Mathematical Italic Small C \\
\hline
U+1D451 & 𝑑 & {\textbackslash}mitd & Mathematical Italic Small D \\
\hline
U+1D452 & 𝑒 & {\textbackslash}mite & Mathematical Italic Small E \\
\hline
U+1D453 & 𝑓 & {\textbackslash}mitf & Mathematical Italic Small F \\
\hline
U+1D454 & 𝑔 & {\textbackslash}mitg & Mathematical Italic Small G \\
\hline
U+1D456 & 𝑖 & {\textbackslash}miti & Mathematical Italic Small I \\
\hline
U+1D457 & 𝑗 & {\textbackslash}mitj & Mathematical Italic Small J \\
\hline
U+1D458 & 𝑘 & {\textbackslash}mitk & Mathematical Italic Small K \\
\hline
U+1D459 & 𝑙 & {\textbackslash}mitl & Mathematical Italic Small L \\
\hline
U+1D45A & 𝑚 & {\textbackslash}mitm & Mathematical Italic Small M \\
\hline
U+1D45B & 𝑛 & {\textbackslash}mitn & Mathematical Italic Small N \\
\hline
U+1D45C & 𝑜 & {\textbackslash}mito & Mathematical Italic Small O \\
\hline
U+1D45D & 𝑝 & {\textbackslash}mitp & Mathematical Italic Small P \\
\hline
U+1D45E & 𝑞 & {\textbackslash}mitq & Mathematical Italic Small Q \\
\hline
U+1D45F & 𝑟 & {\textbackslash}mitr & Mathematical Italic Small R \\
\hline
U+1D460 & 𝑠 & {\textbackslash}mits & Mathematical Italic Small S \\
\hline
U+1D461 & 𝑡 & {\textbackslash}mitt & Mathematical Italic Small T \\
\hline
U+1D462 & 𝑢 & {\textbackslash}mitu & Mathematical Italic Small U \\
\hline
U+1D463 & 𝑣 & {\textbackslash}mitv & Mathematical Italic Small V \\
\hline
U+1D464 & 𝑤 & {\textbackslash}mitw & Mathematical Italic Small W \\
\hline
U+1D465 & 𝑥 & {\textbackslash}mitx & Mathematical Italic Small X \\
\hline
U+1D466 & 𝑦 & {\textbackslash}mity & Mathematical Italic Small Y \\
\hline
U+1D467 & 𝑧 & {\textbackslash}mitz & Mathematical Italic Small Z \\
\hline
U+1D468 & 𝑨 & {\textbackslash}mbfitA & Mathematical Bold Italic Capital A \\
\hline
U+1D469 & 𝑩 & {\textbackslash}mbfitB & Mathematical Bold Italic Capital B \\
\hline
U+1D46A & 𝑪 & {\textbackslash}mbfitC & Mathematical Bold Italic Capital C \\
\hline
U+1D46B & 𝑫 & {\textbackslash}mbfitD & Mathematical Bold Italic Capital D \\
\hline
U+1D46C & 𝑬 & {\textbackslash}mbfitE & Mathematical Bold Italic Capital E \\
\hline
U+1D46D & 𝑭 & {\textbackslash}mbfitF & Mathematical Bold Italic Capital F \\
\hline
U+1D46E & 𝑮 & {\textbackslash}mbfitG & Mathematical Bold Italic Capital G \\
\hline
U+1D46F & 𝑯 & {\textbackslash}mbfitH & Mathematical Bold Italic Capital H \\
\hline
U+1D470 & 𝑰 & {\textbackslash}mbfitI & Mathematical Bold Italic Capital I \\
\hline
U+1D471 & 𝑱 & {\textbackslash}mbfitJ & Mathematical Bold Italic Capital J \\
\hline
U+1D472 & 𝑲 & {\textbackslash}mbfitK & Mathematical Bold Italic Capital K \\
\hline
U+1D473 & 𝑳 & {\textbackslash}mbfitL & Mathematical Bold Italic Capital L \\
\hline
U+1D474 & 𝑴 & {\textbackslash}mbfitM & Mathematical Bold Italic Capital M \\
\hline
U+1D475 & 𝑵 & {\textbackslash}mbfitN & Mathematical Bold Italic Capital N \\
\hline
U+1D476 & 𝑶 & {\textbackslash}mbfitO & Mathematical Bold Italic Capital O \\
\hline
U+1D477 & 𝑷 & {\textbackslash}mbfitP & Mathematical Bold Italic Capital P \\
\hline
U+1D478 & 𝑸 & {\textbackslash}mbfitQ & Mathematical Bold Italic Capital Q \\
\hline
U+1D479 & 𝑹 & {\textbackslash}mbfitR & Mathematical Bold Italic Capital R \\
\hline
U+1D47A & 𝑺 & {\textbackslash}mbfitS & Mathematical Bold Italic Capital S \\
\hline
U+1D47B & 𝑻 & {\textbackslash}mbfitT & Mathematical Bold Italic Capital T \\
\hline
U+1D47C & 𝑼 & {\textbackslash}mbfitU & Mathematical Bold Italic Capital U \\
\hline
U+1D47D & 𝑽 & {\textbackslash}mbfitV & Mathematical Bold Italic Capital V \\
\hline
U+1D47E & 𝑾 & {\textbackslash}mbfitW & Mathematical Bold Italic Capital W \\
\hline
U+1D47F & 𝑿 & {\textbackslash}mbfitX & Mathematical Bold Italic Capital X \\
\hline
U+1D480 & 𝒀 & {\textbackslash}mbfitY & Mathematical Bold Italic Capital Y \\
\hline
U+1D481 & 𝒁 & {\textbackslash}mbfitZ & Mathematical Bold Italic Capital Z \\
\hline
U+1D482 & 𝒂 & {\textbackslash}mbfita & Mathematical Bold Italic Small A \\
\hline
U+1D483 & 𝒃 & {\textbackslash}mbfitb & Mathematical Bold Italic Small B \\
\hline
U+1D484 & 𝒄 & {\textbackslash}mbfitc & Mathematical Bold Italic Small C \\
\hline
U+1D485 & 𝒅 & {\textbackslash}mbfitd & Mathematical Bold Italic Small D \\
\hline
U+1D486 & 𝒆 & {\textbackslash}mbfite & Mathematical Bold Italic Small E \\
\hline
U+1D487 & 𝒇 & {\textbackslash}mbfitf & Mathematical Bold Italic Small F \\
\hline
U+1D488 & 𝒈 & {\textbackslash}mbfitg & Mathematical Bold Italic Small G \\
\hline
U+1D489 & 𝒉 & {\textbackslash}mbfith & Mathematical Bold Italic Small H \\
\hline
U+1D48A & 𝒊 & {\textbackslash}mbfiti & Mathematical Bold Italic Small I \\
\hline
U+1D48B & 𝒋 & {\textbackslash}mbfitj & Mathematical Bold Italic Small J \\
\hline
U+1D48C & 𝒌 & {\textbackslash}mbfitk & Mathematical Bold Italic Small K \\
\hline
U+1D48D & 𝒍 & {\textbackslash}mbfitl & Mathematical Bold Italic Small L \\
\hline
U+1D48E & 𝒎 & {\textbackslash}mbfitm & Mathematical Bold Italic Small M \\
\hline
U+1D48F & 𝒏 & {\textbackslash}mbfitn & Mathematical Bold Italic Small N \\
\hline
U+1D490 & 𝒐 & {\textbackslash}mbfito & Mathematical Bold Italic Small O \\
\hline
U+1D491 & 𝒑 & {\textbackslash}mbfitp & Mathematical Bold Italic Small P \\
\hline
U+1D492 & 𝒒 & {\textbackslash}mbfitq & Mathematical Bold Italic Small Q \\
\hline
U+1D493 & 𝒓 & {\textbackslash}mbfitr & Mathematical Bold Italic Small R \\
\hline
U+1D494 & 𝒔 & {\textbackslash}mbfits & Mathematical Bold Italic Small S \\
\hline
U+1D495 & 𝒕 & {\textbackslash}mbfitt & Mathematical Bold Italic Small T \\
\hline
U+1D496 & 𝒖 & {\textbackslash}mbfitu & Mathematical Bold Italic Small U \\
\hline
U+1D497 & 𝒗 & {\textbackslash}mbfitv & Mathematical Bold Italic Small V \\
\hline
U+1D498 & 𝒘 & {\textbackslash}mbfitw & Mathematical Bold Italic Small W \\
\hline
U+1D499 & 𝒙 & {\textbackslash}mbfitx & Mathematical Bold Italic Small X \\
\hline
U+1D49A & 𝒚 & {\textbackslash}mbfity & Mathematical Bold Italic Small Y \\
\hline
U+1D49B & 𝒛 & {\textbackslash}mbfitz & Mathematical Bold Italic Small Z \\
\hline
U+1D49C & 𝒜 & {\textbackslash}mscrA & Mathematical Script Capital A \\
\hline
U+1D49E & 𝒞 & {\textbackslash}mscrC & Mathematical Script Capital C \\
\hline
U+1D49F & 𝒟 & {\textbackslash}mscrD & Mathematical Script Capital D \\
\hline
U+1D4A2 & 𝒢 & {\textbackslash}mscrG & Mathematical Script Capital G \\
\hline
U+1D4A5 & 𝒥 & {\textbackslash}mscrJ & Mathematical Script Capital J \\
\hline
U+1D4A6 & 𝒦 & {\textbackslash}mscrK & Mathematical Script Capital K \\
\hline
U+1D4A9 & 𝒩 & {\textbackslash}mscrN & Mathematical Script Capital N \\
\hline
U+1D4AA & 𝒪 & {\textbackslash}mscrO & Mathematical Script Capital O \\
\hline
U+1D4AB & 𝒫 & {\textbackslash}mscrP & Mathematical Script Capital P \\
\hline
U+1D4AC & 𝒬 & {\textbackslash}mscrQ & Mathematical Script Capital Q \\
\hline
U+1D4AE & 𝒮 & {\textbackslash}mscrS & Mathematical Script Capital S \\
\hline
U+1D4AF & 𝒯 & {\textbackslash}mscrT & Mathematical Script Capital T \\
\hline
U+1D4B0 & 𝒰 & {\textbackslash}mscrU & Mathematical Script Capital U \\
\hline
U+1D4B1 & 𝒱 & {\textbackslash}mscrV & Mathematical Script Capital V \\
\hline
U+1D4B2 & 𝒲 & {\textbackslash}mscrW & Mathematical Script Capital W \\
\hline
U+1D4B3 & 𝒳 & {\textbackslash}mscrX & Mathematical Script Capital X \\
\hline
U+1D4B4 & 𝒴 & {\textbackslash}mscrY & Mathematical Script Capital Y \\
\hline
U+1D4B5 & 𝒵 & {\textbackslash}mscrZ & Mathematical Script Capital Z \\
\hline
U+1D4B6 & 𝒶 & {\textbackslash}mscra & Mathematical Script Small A \\
\hline
U+1D4B7 & 𝒷 & {\textbackslash}mscrb & Mathematical Script Small B \\
\hline
U+1D4B8 & 𝒸 & {\textbackslash}mscrc & Mathematical Script Small C \\
\hline
U+1D4B9 & 𝒹 & {\textbackslash}mscrd & Mathematical Script Small D \\
\hline
U+1D4BB & 𝒻 & {\textbackslash}mscrf & Mathematical Script Small F \\
\hline
U+1D4BD & 𝒽 & {\textbackslash}mscrh & Mathematical Script Small H \\
\hline
U+1D4BE & 𝒾 & {\textbackslash}mscri & Mathematical Script Small I \\
\hline
U+1D4BF & 𝒿 & {\textbackslash}mscrj & Mathematical Script Small J \\
\hline
U+1D4C0 & 𝓀 & {\textbackslash}mscrk & Mathematical Script Small K \\
\hline
U+1D4C1 & 𝓁 & {\textbackslash}mscrl & Mathematical Script Small L \\
\hline
U+1D4C2 & 𝓂 & {\textbackslash}mscrm & Mathematical Script Small M \\
\hline
U+1D4C3 & 𝓃 & {\textbackslash}mscrn & Mathematical Script Small N \\
\hline
U+1D4C5 & 𝓅 & {\textbackslash}mscrp & Mathematical Script Small P \\
\hline
U+1D4C6 & 𝓆 & {\textbackslash}mscrq & Mathematical Script Small Q \\
\hline
U+1D4C7 & 𝓇 & {\textbackslash}mscrr & Mathematical Script Small R \\
\hline
U+1D4C8 & 𝓈 & {\textbackslash}mscrs & Mathematical Script Small S \\
\hline
U+1D4C9 & 𝓉 & {\textbackslash}mscrt & Mathematical Script Small T \\
\hline
U+1D4CA & 𝓊 & {\textbackslash}mscru & Mathematical Script Small U \\
\hline
U+1D4CB & 𝓋 & {\textbackslash}mscrv & Mathematical Script Small V \\
\hline
U+1D4CC & 𝓌 & {\textbackslash}mscrw & Mathematical Script Small W \\
\hline
U+1D4CD & 𝓍 & {\textbackslash}mscrx & Mathematical Script Small X \\
\hline
U+1D4CE & 𝓎 & {\textbackslash}mscry & Mathematical Script Small Y \\
\hline
U+1D4CF & 𝓏 & {\textbackslash}mscrz & Mathematical Script Small Z \\
\hline
U+1D4D0 & 𝓐 & {\textbackslash}mbfscrA & Mathematical Bold Script Capital A \\
\hline
U+1D4D1 & 𝓑 & {\textbackslash}mbfscrB & Mathematical Bold Script Capital B \\
\hline
U+1D4D2 & 𝓒 & {\textbackslash}mbfscrC & Mathematical Bold Script Capital C \\
\hline
U+1D4D3 & 𝓓 & {\textbackslash}mbfscrD & Mathematical Bold Script Capital D \\
\hline
U+1D4D4 & 𝓔 & {\textbackslash}mbfscrE & Mathematical Bold Script Capital E \\
\hline
U+1D4D5 & 𝓕 & {\textbackslash}mbfscrF & Mathematical Bold Script Capital F \\
\hline
U+1D4D6 & 𝓖 & {\textbackslash}mbfscrG & Mathematical Bold Script Capital G \\
\hline
U+1D4D7 & 𝓗 & {\textbackslash}mbfscrH & Mathematical Bold Script Capital H \\
\hline
U+1D4D8 & 𝓘 & {\textbackslash}mbfscrI & Mathematical Bold Script Capital I \\
\hline
U+1D4D9 & 𝓙 & {\textbackslash}mbfscrJ & Mathematical Bold Script Capital J \\
\hline
U+1D4DA & 𝓚 & {\textbackslash}mbfscrK & Mathematical Bold Script Capital K \\
\hline
U+1D4DB & 𝓛 & {\textbackslash}mbfscrL & Mathematical Bold Script Capital L \\
\hline
U+1D4DC & 𝓜 & {\textbackslash}mbfscrM & Mathematical Bold Script Capital M \\
\hline
U+1D4DD & 𝓝 & {\textbackslash}mbfscrN & Mathematical Bold Script Capital N \\
\hline
U+1D4DE & 𝓞 & {\textbackslash}mbfscrO & Mathematical Bold Script Capital O \\
\hline
U+1D4DF & 𝓟 & {\textbackslash}mbfscrP & Mathematical Bold Script Capital P \\
\hline
U+1D4E0 & 𝓠 & {\textbackslash}mbfscrQ & Mathematical Bold Script Capital Q \\
\hline
U+1D4E1 & 𝓡 & {\textbackslash}mbfscrR & Mathematical Bold Script Capital R \\
\hline
U+1D4E2 & 𝓢 & {\textbackslash}mbfscrS & Mathematical Bold Script Capital S \\
\hline
U+1D4E3 & 𝓣 & {\textbackslash}mbfscrT & Mathematical Bold Script Capital T \\
\hline
U+1D4E4 & 𝓤 & {\textbackslash}mbfscrU & Mathematical Bold Script Capital U \\
\hline
U+1D4E5 & 𝓥 & {\textbackslash}mbfscrV & Mathematical Bold Script Capital V \\
\hline
U+1D4E6 & 𝓦 & {\textbackslash}mbfscrW & Mathematical Bold Script Capital W \\
\hline
U+1D4E7 & 𝓧 & {\textbackslash}mbfscrX & Mathematical Bold Script Capital X \\
\hline
U+1D4E8 & 𝓨 & {\textbackslash}mbfscrY & Mathematical Bold Script Capital Y \\
\hline
U+1D4E9 & 𝓩 & {\textbackslash}mbfscrZ & Mathematical Bold Script Capital Z \\
\hline
U+1D4EA & 𝓪 & {\textbackslash}mbfscra & Mathematical Bold Script Small A \\
\hline
U+1D4EB & 𝓫 & {\textbackslash}mbfscrb & Mathematical Bold Script Small B \\
\hline
U+1D4EC & 𝓬 & {\textbackslash}mbfscrc & Mathematical Bold Script Small C \\
\hline
U+1D4ED & 𝓭 & {\textbackslash}mbfscrd & Mathematical Bold Script Small D \\
\hline
U+1D4EE & 𝓮 & {\textbackslash}mbfscre & Mathematical Bold Script Small E \\
\hline
U+1D4EF & 𝓯 & {\textbackslash}mbfscrf & Mathematical Bold Script Small F \\
\hline
U+1D4F0 & 𝓰 & {\textbackslash}mbfscrg & Mathematical Bold Script Small G \\
\hline
U+1D4F1 & 𝓱 & {\textbackslash}mbfscrh & Mathematical Bold Script Small H \\
\hline
U+1D4F2 & 𝓲 & {\textbackslash}mbfscri & Mathematical Bold Script Small I \\
\hline
U+1D4F3 & 𝓳 & {\textbackslash}mbfscrj & Mathematical Bold Script Small J \\
\hline
U+1D4F4 & 𝓴 & {\textbackslash}mbfscrk & Mathematical Bold Script Small K \\
\hline
U+1D4F5 & 𝓵 & {\textbackslash}mbfscrl & Mathematical Bold Script Small L \\
\hline
U+1D4F6 & 𝓶 & {\textbackslash}mbfscrm & Mathematical Bold Script Small M \\
\hline
U+1D4F7 & 𝓷 & {\textbackslash}mbfscrn & Mathematical Bold Script Small N \\
\hline
U+1D4F8 & 𝓸 & {\textbackslash}mbfscro & Mathematical Bold Script Small O \\
\hline
U+1D4F9 & 𝓹 & {\textbackslash}mbfscrp & Mathematical Bold Script Small P \\
\hline
U+1D4FA & 𝓺 & {\textbackslash}mbfscrq & Mathematical Bold Script Small Q \\
\hline
U+1D4FB & 𝓻 & {\textbackslash}mbfscrr & Mathematical Bold Script Small R \\
\hline
U+1D4FC & 𝓼 & {\textbackslash}mbfscrs & Mathematical Bold Script Small S \\
\hline
U+1D4FD & 𝓽 & {\textbackslash}mbfscrt & Mathematical Bold Script Small T \\
\hline
U+1D4FE & 𝓾 & {\textbackslash}mbfscru & Mathematical Bold Script Small U \\
\hline
U+1D4FF & 𝓿 & {\textbackslash}mbfscrv & Mathematical Bold Script Small V \\
\hline
U+1D500 & 𝔀 & {\textbackslash}mbfscrw & Mathematical Bold Script Small W \\
\hline
U+1D501 & 𝔁 & {\textbackslash}mbfscrx & Mathematical Bold Script Small X \\
\hline
U+1D502 & 𝔂 & {\textbackslash}mbfscry & Mathematical Bold Script Small Y \\
\hline
U+1D503 & 𝔃 & {\textbackslash}mbfscrz & Mathematical Bold Script Small Z \\
\hline
U+1D504 & 𝔄 & {\textbackslash}mfrakA & Mathematical Fraktur Capital A \\
\hline
U+1D505 & 𝔅 & {\textbackslash}mfrakB & Mathematical Fraktur Capital B \\
\hline
U+1D507 & 𝔇 & {\textbackslash}mfrakD & Mathematical Fraktur Capital D \\
\hline
U+1D508 & 𝔈 & {\textbackslash}mfrakE & Mathematical Fraktur Capital E \\
\hline
U+1D509 & 𝔉 & {\textbackslash}mfrakF & Mathematical Fraktur Capital F \\
\hline
U+1D50A & 𝔊 & {\textbackslash}mfrakG & Mathematical Fraktur Capital G \\
\hline
U+1D50D & 𝔍 & {\textbackslash}mfrakJ & Mathematical Fraktur Capital J \\
\hline
U+1D50E & 𝔎 & {\textbackslash}mfrakK & Mathematical Fraktur Capital K \\
\hline
U+1D50F & 𝔏 & {\textbackslash}mfrakL & Mathematical Fraktur Capital L \\
\hline
U+1D510 & 𝔐 & {\textbackslash}mfrakM & Mathematical Fraktur Capital M \\
\hline
U+1D511 & 𝔑 & {\textbackslash}mfrakN & Mathematical Fraktur Capital N \\
\hline
U+1D512 & 𝔒 & {\textbackslash}mfrakO & Mathematical Fraktur Capital O \\
\hline
U+1D513 & 𝔓 & {\textbackslash}mfrakP & Mathematical Fraktur Capital P \\
\hline
U+1D514 & 𝔔 & {\textbackslash}mfrakQ & Mathematical Fraktur Capital Q \\
\hline
U+1D516 & 𝔖 & {\textbackslash}mfrakS & Mathematical Fraktur Capital S \\
\hline
U+1D517 & 𝔗 & {\textbackslash}mfrakT & Mathematical Fraktur Capital T \\
\hline
U+1D518 & 𝔘 & {\textbackslash}mfrakU & Mathematical Fraktur Capital U \\
\hline
U+1D519 & 𝔙 & {\textbackslash}mfrakV & Mathematical Fraktur Capital V \\
\hline
U+1D51A & 𝔚 & {\textbackslash}mfrakW & Mathematical Fraktur Capital W \\
\hline
U+1D51B & 𝔛 & {\textbackslash}mfrakX & Mathematical Fraktur Capital X \\
\hline
U+1D51C & 𝔜 & {\textbackslash}mfrakY & Mathematical Fraktur Capital Y \\
\hline
U+1D51E & 𝔞 & {\textbackslash}mfraka & Mathematical Fraktur Small A \\
\hline
U+1D51F & 𝔟 & {\textbackslash}mfrakb & Mathematical Fraktur Small B \\
\hline
U+1D520 & 𝔠 & {\textbackslash}mfrakc & Mathematical Fraktur Small C \\
\hline
U+1D521 & 𝔡 & {\textbackslash}mfrakd & Mathematical Fraktur Small D \\
\hline
U+1D522 & 𝔢 & {\textbackslash}mfrake & Mathematical Fraktur Small E \\
\hline
U+1D523 & 𝔣 & {\textbackslash}mfrakf & Mathematical Fraktur Small F \\
\hline
U+1D524 & 𝔤 & {\textbackslash}mfrakg & Mathematical Fraktur Small G \\
\hline
U+1D525 & 𝔥 & {\textbackslash}mfrakh & Mathematical Fraktur Small H \\
\hline
U+1D526 & 𝔦 & {\textbackslash}mfraki & Mathematical Fraktur Small I \\
\hline
U+1D527 & 𝔧 & {\textbackslash}mfrakj & Mathematical Fraktur Small J \\
\hline
U+1D528 & 𝔨 & {\textbackslash}mfrakk & Mathematical Fraktur Small K \\
\hline
U+1D529 & 𝔩 & {\textbackslash}mfrakl & Mathematical Fraktur Small L \\
\hline
U+1D52A & 𝔪 & {\textbackslash}mfrakm & Mathematical Fraktur Small M \\
\hline
U+1D52B & 𝔫 & {\textbackslash}mfrakn & Mathematical Fraktur Small N \\
\hline
U+1D52C & 𝔬 & {\textbackslash}mfrako & Mathematical Fraktur Small O \\
\hline
U+1D52D & 𝔭 & {\textbackslash}mfrakp & Mathematical Fraktur Small P \\
\hline
U+1D52E & 𝔮 & {\textbackslash}mfrakq & Mathematical Fraktur Small Q \\
\hline
U+1D52F & 𝔯 & {\textbackslash}mfrakr & Mathematical Fraktur Small R \\
\hline
U+1D530 & 𝔰 & {\textbackslash}mfraks & Mathematical Fraktur Small S \\
\hline
U+1D531 & 𝔱 & {\textbackslash}mfrakt & Mathematical Fraktur Small T \\
\hline
U+1D532 & 𝔲 & {\textbackslash}mfraku & Mathematical Fraktur Small U \\
\hline
U+1D533 & 𝔳 & {\textbackslash}mfrakv & Mathematical Fraktur Small V \\
\hline
U+1D534 & 𝔴 & {\textbackslash}mfrakw & Mathematical Fraktur Small W \\
\hline
U+1D535 & 𝔵 & {\textbackslash}mfrakx & Mathematical Fraktur Small X \\
\hline
U+1D536 & 𝔶 & {\textbackslash}mfraky & Mathematical Fraktur Small Y \\
\hline
U+1D537 & 𝔷 & {\textbackslash}mfrakz & Mathematical Fraktur Small Z \\
\hline
U+1D538 & 𝔸 & {\textbackslash}BbbA & Mathematical Double-struck Capital A \\
\hline
U+1D539 & 𝔹 & {\textbackslash}BbbB & Mathematical Double-struck Capital B \\
\hline
U+1D53B & 𝔻 & {\textbackslash}BbbD & Mathematical Double-struck Capital D \\
\hline
U+1D53C & 𝔼 & {\textbackslash}BbbE & Mathematical Double-struck Capital E \\
\hline
U+1D53D & 𝔽 & {\textbackslash}BbbF & Mathematical Double-struck Capital F \\
\hline
U+1D53E & 𝔾 & {\textbackslash}BbbG & Mathematical Double-struck Capital G \\
\hline
U+1D540 & 𝕀 & {\textbackslash}BbbI & Mathematical Double-struck Capital I \\
\hline
U+1D541 & 𝕁 & {\textbackslash}BbbJ & Mathematical Double-struck Capital J \\
\hline
U+1D542 & 𝕂 & {\textbackslash}BbbK & Mathematical Double-struck Capital K \\
\hline
U+1D543 & 𝕃 & {\textbackslash}BbbL & Mathematical Double-struck Capital L \\
\hline
U+1D544 & 𝕄 & {\textbackslash}BbbM & Mathematical Double-struck Capital M \\
\hline
U+1D546 & 𝕆 & {\textbackslash}BbbO & Mathematical Double-struck Capital O \\
\hline
U+1D54A & 𝕊 & {\textbackslash}BbbS & Mathematical Double-struck Capital S \\
\hline
U+1D54B & 𝕋 & {\textbackslash}BbbT & Mathematical Double-struck Capital T \\
\hline
U+1D54C & 𝕌 & {\textbackslash}BbbU & Mathematical Double-struck Capital U \\
\hline
U+1D54D & 𝕍 & {\textbackslash}BbbV & Mathematical Double-struck Capital V \\
\hline
U+1D54E & 𝕎 & {\textbackslash}BbbW & Mathematical Double-struck Capital W \\
\hline
U+1D54F & 𝕏 & {\textbackslash}BbbX & Mathematical Double-struck Capital X \\
\hline
U+1D550 & 𝕐 & {\textbackslash}BbbY & Mathematical Double-struck Capital Y \\
\hline
U+1D552 & 𝕒 & {\textbackslash}Bbba & Mathematical Double-struck Small A \\
\hline
U+1D553 & 𝕓 & {\textbackslash}Bbbb & Mathematical Double-struck Small B \\
\hline
U+1D554 & 𝕔 & {\textbackslash}Bbbc & Mathematical Double-struck Small C \\
\hline
U+1D555 & 𝕕 & {\textbackslash}Bbbd & Mathematical Double-struck Small D \\
\hline
U+1D556 & 𝕖 & {\textbackslash}Bbbe & Mathematical Double-struck Small E \\
\hline
U+1D557 & 𝕗 & {\textbackslash}Bbbf & Mathematical Double-struck Small F \\
\hline
U+1D558 & 𝕘 & {\textbackslash}Bbbg & Mathematical Double-struck Small G \\
\hline
U+1D559 & 𝕙 & {\textbackslash}Bbbh & Mathematical Double-struck Small H \\
\hline
U+1D55A & 𝕚 & {\textbackslash}Bbbi & Mathematical Double-struck Small I \\
\hline
U+1D55B & 𝕛 & {\textbackslash}Bbbj & Mathematical Double-struck Small J \\
\hline
U+1D55C & 𝕜 & {\textbackslash}Bbbk & Mathematical Double-struck Small K \\
\hline
U+1D55D & 𝕝 & {\textbackslash}Bbbl & Mathematical Double-struck Small L \\
\hline
U+1D55E & 𝕞 & {\textbackslash}Bbbm & Mathematical Double-struck Small M \\
\hline
U+1D55F & 𝕟 & {\textbackslash}Bbbn & Mathematical Double-struck Small N \\
\hline
U+1D560 & 𝕠 & {\textbackslash}Bbbo & Mathematical Double-struck Small O \\
\hline
U+1D561 & 𝕡 & {\textbackslash}Bbbp & Mathematical Double-struck Small P \\
\hline
U+1D562 & 𝕢 & {\textbackslash}Bbbq & Mathematical Double-struck Small Q \\
\hline
U+1D563 & 𝕣 & {\textbackslash}Bbbr & Mathematical Double-struck Small R \\
\hline
U+1D564 & 𝕤 & {\textbackslash}Bbbs & Mathematical Double-struck Small S \\
\hline
U+1D565 & 𝕥 & {\textbackslash}Bbbt & Mathematical Double-struck Small T \\
\hline
U+1D566 & 𝕦 & {\textbackslash}Bbbu & Mathematical Double-struck Small U \\
\hline
U+1D567 & 𝕧 & {\textbackslash}Bbbv & Mathematical Double-struck Small V \\
\hline
U+1D568 & 𝕨 & {\textbackslash}Bbbw & Mathematical Double-struck Small W \\
\hline
U+1D569 & 𝕩 & {\textbackslash}Bbbx & Mathematical Double-struck Small X \\
\hline
U+1D56A & 𝕪 & {\textbackslash}Bbby & Mathematical Double-struck Small Y \\
\hline
U+1D56B & 𝕫 & {\textbackslash}Bbbz & Mathematical Double-struck Small Z \\
\hline
U+1D56C & 𝕬 & {\textbackslash}mbffrakA & Mathematical Bold Fraktur Capital A \\
\hline
U+1D56D & 𝕭 & {\textbackslash}mbffrakB & Mathematical Bold Fraktur Capital B \\
\hline
U+1D56E & 𝕮 & {\textbackslash}mbffrakC & Mathematical Bold Fraktur Capital C \\
\hline
U+1D56F & 𝕯 & {\textbackslash}mbffrakD & Mathematical Bold Fraktur Capital D \\
\hline
U+1D570 & 𝕰 & {\textbackslash}mbffrakE & Mathematical Bold Fraktur Capital E \\
\hline
U+1D571 & 𝕱 & {\textbackslash}mbffrakF & Mathematical Bold Fraktur Capital F \\
\hline
U+1D572 & 𝕲 & {\textbackslash}mbffrakG & Mathematical Bold Fraktur Capital G \\
\hline
U+1D573 & 𝕳 & {\textbackslash}mbffrakH & Mathematical Bold Fraktur Capital H \\
\hline
U+1D574 & 𝕴 & {\textbackslash}mbffrakI & Mathematical Bold Fraktur Capital I \\
\hline
U+1D575 & 𝕵 & {\textbackslash}mbffrakJ & Mathematical Bold Fraktur Capital J \\
\hline
U+1D576 & 𝕶 & {\textbackslash}mbffrakK & Mathematical Bold Fraktur Capital K \\
\hline
U+1D577 & 𝕷 & {\textbackslash}mbffrakL & Mathematical Bold Fraktur Capital L \\
\hline
U+1D578 & 𝕸 & {\textbackslash}mbffrakM & Mathematical Bold Fraktur Capital M \\
\hline
U+1D579 & 𝕹 & {\textbackslash}mbffrakN & Mathematical Bold Fraktur Capital N \\
\hline
U+1D57A & 𝕺 & {\textbackslash}mbffrakO & Mathematical Bold Fraktur Capital O \\
\hline
U+1D57B & 𝕻 & {\textbackslash}mbffrakP & Mathematical Bold Fraktur Capital P \\
\hline
U+1D57C & 𝕼 & {\textbackslash}mbffrakQ & Mathematical Bold Fraktur Capital Q \\
\hline
U+1D57D & 𝕽 & {\textbackslash}mbffrakR & Mathematical Bold Fraktur Capital R \\
\hline
U+1D57E & 𝕾 & {\textbackslash}mbffrakS & Mathematical Bold Fraktur Capital S \\
\hline
U+1D57F & 𝕿 & {\textbackslash}mbffrakT & Mathematical Bold Fraktur Capital T \\
\hline
U+1D580 & 𝖀 & {\textbackslash}mbffrakU & Mathematical Bold Fraktur Capital U \\
\hline
U+1D581 & 𝖁 & {\textbackslash}mbffrakV & Mathematical Bold Fraktur Capital V \\
\hline
U+1D582 & 𝖂 & {\textbackslash}mbffrakW & Mathematical Bold Fraktur Capital W \\
\hline
U+1D583 & 𝖃 & {\textbackslash}mbffrakX & Mathematical Bold Fraktur Capital X \\
\hline
U+1D584 & 𝖄 & {\textbackslash}mbffrakY & Mathematical Bold Fraktur Capital Y \\
\hline
U+1D585 & 𝖅 & {\textbackslash}mbffrakZ & Mathematical Bold Fraktur Capital Z \\
\hline
U+1D586 & 𝖆 & {\textbackslash}mbffraka & Mathematical Bold Fraktur Small A \\
\hline
U+1D587 & 𝖇 & {\textbackslash}mbffrakb & Mathematical Bold Fraktur Small B \\
\hline
U+1D588 & 𝖈 & {\textbackslash}mbffrakc & Mathematical Bold Fraktur Small C \\
\hline
U+1D589 & 𝖉 & {\textbackslash}mbffrakd & Mathematical Bold Fraktur Small D \\
\hline
U+1D58A & 𝖊 & {\textbackslash}mbffrake & Mathematical Bold Fraktur Small E \\
\hline
U+1D58B & 𝖋 & {\textbackslash}mbffrakf & Mathematical Bold Fraktur Small F \\
\hline
U+1D58C & 𝖌 & {\textbackslash}mbffrakg & Mathematical Bold Fraktur Small G \\
\hline
U+1D58D & 𝖍 & {\textbackslash}mbffrakh & Mathematical Bold Fraktur Small H \\
\hline
U+1D58E & 𝖎 & {\textbackslash}mbffraki & Mathematical Bold Fraktur Small I \\
\hline
U+1D58F & 𝖏 & {\textbackslash}mbffrakj & Mathematical Bold Fraktur Small J \\
\hline
U+1D590 & 𝖐 & {\textbackslash}mbffrakk & Mathematical Bold Fraktur Small K \\
\hline
U+1D591 & 𝖑 & {\textbackslash}mbffrakl & Mathematical Bold Fraktur Small L \\
\hline
U+1D592 & 𝖒 & {\textbackslash}mbffrakm & Mathematical Bold Fraktur Small M \\
\hline
U+1D593 & 𝖓 & {\textbackslash}mbffrakn & Mathematical Bold Fraktur Small N \\
\hline
U+1D594 & 𝖔 & {\textbackslash}mbffrako & Mathematical Bold Fraktur Small O \\
\hline
U+1D595 & 𝖕 & {\textbackslash}mbffrakp & Mathematical Bold Fraktur Small P \\
\hline
U+1D596 & 𝖖 & {\textbackslash}mbffrakq & Mathematical Bold Fraktur Small Q \\
\hline
U+1D597 & 𝖗 & {\textbackslash}mbffrakr & Mathematical Bold Fraktur Small R \\
\hline
U+1D598 & 𝖘 & {\textbackslash}mbffraks & Mathematical Bold Fraktur Small S \\
\hline
U+1D599 & 𝖙 & {\textbackslash}mbffrakt & Mathematical Bold Fraktur Small T \\
\hline
U+1D59A & 𝖚 & {\textbackslash}mbffraku & Mathematical Bold Fraktur Small U \\
\hline
U+1D59B & 𝖛 & {\textbackslash}mbffrakv & Mathematical Bold Fraktur Small V \\
\hline
U+1D59C & 𝖜 & {\textbackslash}mbffrakw & Mathematical Bold Fraktur Small W \\
\hline
U+1D59D & 𝖝 & {\textbackslash}mbffrakx & Mathematical Bold Fraktur Small X \\
\hline
U+1D59E & 𝖞 & {\textbackslash}mbffraky & Mathematical Bold Fraktur Small Y \\
\hline
U+1D59F & 𝖟 & {\textbackslash}mbffrakz & Mathematical Bold Fraktur Small Z \\
\hline
U+1D5A0 & 𝖠 & {\textbackslash}msansA & Mathematical Sans-serif Capital A \\
\hline
U+1D5A1 & 𝖡 & {\textbackslash}msansB & Mathematical Sans-serif Capital B \\
\hline
U+1D5A2 & 𝖢 & {\textbackslash}msansC & Mathematical Sans-serif Capital C \\
\hline
U+1D5A3 & 𝖣 & {\textbackslash}msansD & Mathematical Sans-serif Capital D \\
\hline
U+1D5A4 & 𝖤 & {\textbackslash}msansE & Mathematical Sans-serif Capital E \\
\hline
U+1D5A5 & 𝖥 & {\textbackslash}msansF & Mathematical Sans-serif Capital F \\
\hline
U+1D5A6 & 𝖦 & {\textbackslash}msansG & Mathematical Sans-serif Capital G \\
\hline
U+1D5A7 & 𝖧 & {\textbackslash}msansH & Mathematical Sans-serif Capital H \\
\hline
U+1D5A8 & 𝖨 & {\textbackslash}msansI & Mathematical Sans-serif Capital I \\
\hline
U+1D5A9 & 𝖩 & {\textbackslash}msansJ & Mathematical Sans-serif Capital J \\
\hline
U+1D5AA & 𝖪 & {\textbackslash}msansK & Mathematical Sans-serif Capital K \\
\hline
U+1D5AB & 𝖫 & {\textbackslash}msansL & Mathematical Sans-serif Capital L \\
\hline
U+1D5AC & 𝖬 & {\textbackslash}msansM & Mathematical Sans-serif Capital M \\
\hline
U+1D5AD & 𝖭 & {\textbackslash}msansN & Mathematical Sans-serif Capital N \\
\hline
U+1D5AE & 𝖮 & {\textbackslash}msansO & Mathematical Sans-serif Capital O \\
\hline
U+1D5AF & 𝖯 & {\textbackslash}msansP & Mathematical Sans-serif Capital P \\
\hline
U+1D5B0 & 𝖰 & {\textbackslash}msansQ & Mathematical Sans-serif Capital Q \\
\hline
U+1D5B1 & 𝖱 & {\textbackslash}msansR & Mathematical Sans-serif Capital R \\
\hline
U+1D5B2 & 𝖲 & {\textbackslash}msansS & Mathematical Sans-serif Capital S \\
\hline
U+1D5B3 & 𝖳 & {\textbackslash}msansT & Mathematical Sans-serif Capital T \\
\hline
U+1D5B4 & 𝖴 & {\textbackslash}msansU & Mathematical Sans-serif Capital U \\
\hline
U+1D5B5 & 𝖵 & {\textbackslash}msansV & Mathematical Sans-serif Capital V \\
\hline
U+1D5B6 & 𝖶 & {\textbackslash}msansW & Mathematical Sans-serif Capital W \\
\hline
U+1D5B7 & 𝖷 & {\textbackslash}msansX & Mathematical Sans-serif Capital X \\
\hline
U+1D5B8 & 𝖸 & {\textbackslash}msansY & Mathematical Sans-serif Capital Y \\
\hline
U+1D5B9 & 𝖹 & {\textbackslash}msansZ & Mathematical Sans-serif Capital Z \\
\hline
U+1D5BA & 𝖺 & {\textbackslash}msansa & Mathematical Sans-serif Small A \\
\hline
U+1D5BB & 𝖻 & {\textbackslash}msansb & Mathematical Sans-serif Small B \\
\hline
U+1D5BC & 𝖼 & {\textbackslash}msansc & Mathematical Sans-serif Small C \\
\hline
U+1D5BD & 𝖽 & {\textbackslash}msansd & Mathematical Sans-serif Small D \\
\hline
U+1D5BE & 𝖾 & {\textbackslash}msanse & Mathematical Sans-serif Small E \\
\hline
U+1D5BF & 𝖿 & {\textbackslash}msansf & Mathematical Sans-serif Small F \\
\hline
U+1D5C0 & 𝗀 & {\textbackslash}msansg & Mathematical Sans-serif Small G \\
\hline
U+1D5C1 & 𝗁 & {\textbackslash}msansh & Mathematical Sans-serif Small H \\
\hline
U+1D5C2 & 𝗂 & {\textbackslash}msansi & Mathematical Sans-serif Small I \\
\hline
U+1D5C3 & 𝗃 & {\textbackslash}msansj & Mathematical Sans-serif Small J \\
\hline
U+1D5C4 & 𝗄 & {\textbackslash}msansk & Mathematical Sans-serif Small K \\
\hline
U+1D5C5 & 𝗅 & {\textbackslash}msansl & Mathematical Sans-serif Small L \\
\hline
U+1D5C6 & 𝗆 & {\textbackslash}msansm & Mathematical Sans-serif Small M \\
\hline
U+1D5C7 & 𝗇 & {\textbackslash}msansn & Mathematical Sans-serif Small N \\
\hline
U+1D5C8 & 𝗈 & {\textbackslash}msanso & Mathematical Sans-serif Small O \\
\hline
U+1D5C9 & 𝗉 & {\textbackslash}msansp & Mathematical Sans-serif Small P \\
\hline
U+1D5CA & 𝗊 & {\textbackslash}msansq & Mathematical Sans-serif Small Q \\
\hline
U+1D5CB & 𝗋 & {\textbackslash}msansr & Mathematical Sans-serif Small R \\
\hline
U+1D5CC & 𝗌 & {\textbackslash}msanss & Mathematical Sans-serif Small S \\
\hline
U+1D5CD & 𝗍 & {\textbackslash}msanst & Mathematical Sans-serif Small T \\
\hline
U+1D5CE & 𝗎 & {\textbackslash}msansu & Mathematical Sans-serif Small U \\
\hline
U+1D5CF & 𝗏 & {\textbackslash}msansv & Mathematical Sans-serif Small V \\
\hline
U+1D5D0 & 𝗐 & {\textbackslash}msansw & Mathematical Sans-serif Small W \\
\hline
U+1D5D1 & 𝗑 & {\textbackslash}msansx & Mathematical Sans-serif Small X \\
\hline
U+1D5D2 & 𝗒 & {\textbackslash}msansy & Mathematical Sans-serif Small Y \\
\hline
U+1D5D3 & 𝗓 & {\textbackslash}msansz & Mathematical Sans-serif Small Z \\
\hline
U+1D5D4 & 𝗔 & {\textbackslash}mbfsansA & Mathematical Sans-serif Bold Capital A \\
\hline
U+1D5D5 & 𝗕 & {\textbackslash}mbfsansB & Mathematical Sans-serif Bold Capital B \\
\hline
U+1D5D6 & 𝗖 & {\textbackslash}mbfsansC & Mathematical Sans-serif Bold Capital C \\
\hline
U+1D5D7 & 𝗗 & {\textbackslash}mbfsansD & Mathematical Sans-serif Bold Capital D \\
\hline
U+1D5D8 & 𝗘 & {\textbackslash}mbfsansE & Mathematical Sans-serif Bold Capital E \\
\hline
U+1D5D9 & 𝗙 & {\textbackslash}mbfsansF & Mathematical Sans-serif Bold Capital F \\
\hline
U+1D5DA & 𝗚 & {\textbackslash}mbfsansG & Mathematical Sans-serif Bold Capital G \\
\hline
U+1D5DB & 𝗛 & {\textbackslash}mbfsansH & Mathematical Sans-serif Bold Capital H \\
\hline
U+1D5DC & 𝗜 & {\textbackslash}mbfsansI & Mathematical Sans-serif Bold Capital I \\
\hline
U+1D5DD & 𝗝 & {\textbackslash}mbfsansJ & Mathematical Sans-serif Bold Capital J \\
\hline
U+1D5DE & 𝗞 & {\textbackslash}mbfsansK & Mathematical Sans-serif Bold Capital K \\
\hline
U+1D5DF & 𝗟 & {\textbackslash}mbfsansL & Mathematical Sans-serif Bold Capital L \\
\hline
U+1D5E0 & 𝗠 & {\textbackslash}mbfsansM & Mathematical Sans-serif Bold Capital M \\
\hline
U+1D5E1 & 𝗡 & {\textbackslash}mbfsansN & Mathematical Sans-serif Bold Capital N \\
\hline
U+1D5E2 & 𝗢 & {\textbackslash}mbfsansO & Mathematical Sans-serif Bold Capital O \\
\hline
U+1D5E3 & 𝗣 & {\textbackslash}mbfsansP & Mathematical Sans-serif Bold Capital P \\
\hline
U+1D5E4 & 𝗤 & {\textbackslash}mbfsansQ & Mathematical Sans-serif Bold Capital Q \\
\hline
U+1D5E5 & 𝗥 & {\textbackslash}mbfsansR & Mathematical Sans-serif Bold Capital R \\
\hline
U+1D5E6 & 𝗦 & {\textbackslash}mbfsansS & Mathematical Sans-serif Bold Capital S \\
\hline
U+1D5E7 & 𝗧 & {\textbackslash}mbfsansT & Mathematical Sans-serif Bold Capital T \\
\hline
U+1D5E8 & 𝗨 & {\textbackslash}mbfsansU & Mathematical Sans-serif Bold Capital U \\
\hline
U+1D5E9 & 𝗩 & {\textbackslash}mbfsansV & Mathematical Sans-serif Bold Capital V \\
\hline
U+1D5EA & 𝗪 & {\textbackslash}mbfsansW & Mathematical Sans-serif Bold Capital W \\
\hline
U+1D5EB & 𝗫 & {\textbackslash}mbfsansX & Mathematical Sans-serif Bold Capital X \\
\hline
U+1D5EC & 𝗬 & {\textbackslash}mbfsansY & Mathematical Sans-serif Bold Capital Y \\
\hline
U+1D5ED & 𝗭 & {\textbackslash}mbfsansZ & Mathematical Sans-serif Bold Capital Z \\
\hline
U+1D5EE & 𝗮 & {\textbackslash}mbfsansa & Mathematical Sans-serif Bold Small A \\
\hline
U+1D5EF & 𝗯 & {\textbackslash}mbfsansb & Mathematical Sans-serif Bold Small B \\
\hline
U+1D5F0 & 𝗰 & {\textbackslash}mbfsansc & Mathematical Sans-serif Bold Small C \\
\hline
U+1D5F1 & 𝗱 & {\textbackslash}mbfsansd & Mathematical Sans-serif Bold Small D \\
\hline
U+1D5F2 & 𝗲 & {\textbackslash}mbfsanse & Mathematical Sans-serif Bold Small E \\
\hline
U+1D5F3 & 𝗳 & {\textbackslash}mbfsansf & Mathematical Sans-serif Bold Small F \\
\hline
U+1D5F4 & 𝗴 & {\textbackslash}mbfsansg & Mathematical Sans-serif Bold Small G \\
\hline
U+1D5F5 & 𝗵 & {\textbackslash}mbfsansh & Mathematical Sans-serif Bold Small H \\
\hline
U+1D5F6 & 𝗶 & {\textbackslash}mbfsansi & Mathematical Sans-serif Bold Small I \\
\hline
U+1D5F7 & 𝗷 & {\textbackslash}mbfsansj & Mathematical Sans-serif Bold Small J \\
\hline
U+1D5F8 & 𝗸 & {\textbackslash}mbfsansk & Mathematical Sans-serif Bold Small K \\
\hline
U+1D5F9 & 𝗹 & {\textbackslash}mbfsansl & Mathematical Sans-serif Bold Small L \\
\hline
U+1D5FA & 𝗺 & {\textbackslash}mbfsansm & Mathematical Sans-serif Bold Small M \\
\hline
U+1D5FB & 𝗻 & {\textbackslash}mbfsansn & Mathematical Sans-serif Bold Small N \\
\hline
U+1D5FC & 𝗼 & {\textbackslash}mbfsanso & Mathematical Sans-serif Bold Small O \\
\hline
U+1D5FD & 𝗽 & {\textbackslash}mbfsansp & Mathematical Sans-serif Bold Small P \\
\hline
U+1D5FE & 𝗾 & {\textbackslash}mbfsansq & Mathematical Sans-serif Bold Small Q \\
\hline
U+1D5FF & 𝗿 & {\textbackslash}mbfsansr & Mathematical Sans-serif Bold Small R \\
\hline
U+1D600 & 𝘀 & {\textbackslash}mbfsanss & Mathematical Sans-serif Bold Small S \\
\hline
U+1D601 & 𝘁 & {\textbackslash}mbfsanst & Mathematical Sans-serif Bold Small T \\
\hline
U+1D602 & 𝘂 & {\textbackslash}mbfsansu & Mathematical Sans-serif Bold Small U \\
\hline
U+1D603 & 𝘃 & {\textbackslash}mbfsansv & Mathematical Sans-serif Bold Small V \\
\hline
U+1D604 & 𝘄 & {\textbackslash}mbfsansw & Mathematical Sans-serif Bold Small W \\
\hline
U+1D605 & 𝘅 & {\textbackslash}mbfsansx & Mathematical Sans-serif Bold Small X \\
\hline
U+1D606 & 𝘆 & {\textbackslash}mbfsansy & Mathematical Sans-serif Bold Small Y \\
\hline
U+1D607 & 𝘇 & {\textbackslash}mbfsansz & Mathematical Sans-serif Bold Small Z \\
\hline
U+1D608 & 𝘈 & {\textbackslash}mitsansA & Mathematical Sans-serif Italic Capital A \\
\hline
U+1D609 & 𝘉 & {\textbackslash}mitsansB & Mathematical Sans-serif Italic Capital B \\
\hline
U+1D60A & 𝘊 & {\textbackslash}mitsansC & Mathematical Sans-serif Italic Capital C \\
\hline
U+1D60B & 𝘋 & {\textbackslash}mitsansD & Mathematical Sans-serif Italic Capital D \\
\hline
U+1D60C & 𝘌 & {\textbackslash}mitsansE & Mathematical Sans-serif Italic Capital E \\
\hline
U+1D60D & 𝘍 & {\textbackslash}mitsansF & Mathematical Sans-serif Italic Capital F \\
\hline
U+1D60E & 𝘎 & {\textbackslash}mitsansG & Mathematical Sans-serif Italic Capital G \\
\hline
U+1D60F & 𝘏 & {\textbackslash}mitsansH & Mathematical Sans-serif Italic Capital H \\
\hline
U+1D610 & 𝘐 & {\textbackslash}mitsansI & Mathematical Sans-serif Italic Capital I \\
\hline
U+1D611 & 𝘑 & {\textbackslash}mitsansJ & Mathematical Sans-serif Italic Capital J \\
\hline
U+1D612 & 𝘒 & {\textbackslash}mitsansK & Mathematical Sans-serif Italic Capital K \\
\hline
U+1D613 & 𝘓 & {\textbackslash}mitsansL & Mathematical Sans-serif Italic Capital L \\
\hline
U+1D614 & 𝘔 & {\textbackslash}mitsansM & Mathematical Sans-serif Italic Capital M \\
\hline
U+1D615 & 𝘕 & {\textbackslash}mitsansN & Mathematical Sans-serif Italic Capital N \\
\hline
U+1D616 & 𝘖 & {\textbackslash}mitsansO & Mathematical Sans-serif Italic Capital O \\
\hline
U+1D617 & 𝘗 & {\textbackslash}mitsansP & Mathematical Sans-serif Italic Capital P \\
\hline
U+1D618 & 𝘘 & {\textbackslash}mitsansQ & Mathematical Sans-serif Italic Capital Q \\
\hline
U+1D619 & 𝘙 & {\textbackslash}mitsansR & Mathematical Sans-serif Italic Capital R \\
\hline
U+1D61A & 𝘚 & {\textbackslash}mitsansS & Mathematical Sans-serif Italic Capital S \\
\hline
U+1D61B & 𝘛 & {\textbackslash}mitsansT & Mathematical Sans-serif Italic Capital T \\
\hline
U+1D61C & 𝘜 & {\textbackslash}mitsansU & Mathematical Sans-serif Italic Capital U \\
\hline
U+1D61D & 𝘝 & {\textbackslash}mitsansV & Mathematical Sans-serif Italic Capital V \\
\hline
U+1D61E & 𝘞 & {\textbackslash}mitsansW & Mathematical Sans-serif Italic Capital W \\
\hline
U+1D61F & 𝘟 & {\textbackslash}mitsansX & Mathematical Sans-serif Italic Capital X \\
\hline
U+1D620 & 𝘠 & {\textbackslash}mitsansY & Mathematical Sans-serif Italic Capital Y \\
\hline
U+1D621 & 𝘡 & {\textbackslash}mitsansZ & Mathematical Sans-serif Italic Capital Z \\
\hline
U+1D622 & 𝘢 & {\textbackslash}mitsansa & Mathematical Sans-serif Italic Small A \\
\hline
U+1D623 & 𝘣 & {\textbackslash}mitsansb & Mathematical Sans-serif Italic Small B \\
\hline
U+1D624 & 𝘤 & {\textbackslash}mitsansc & Mathematical Sans-serif Italic Small C \\
\hline
U+1D625 & 𝘥 & {\textbackslash}mitsansd & Mathematical Sans-serif Italic Small D \\
\hline
U+1D626 & 𝘦 & {\textbackslash}mitsanse & Mathematical Sans-serif Italic Small E \\
\hline
U+1D627 & 𝘧 & {\textbackslash}mitsansf & Mathematical Sans-serif Italic Small F \\
\hline
U+1D628 & 𝘨 & {\textbackslash}mitsansg & Mathematical Sans-serif Italic Small G \\
\hline
U+1D629 & 𝘩 & {\textbackslash}mitsansh & Mathematical Sans-serif Italic Small H \\
\hline
U+1D62A & 𝘪 & {\textbackslash}mitsansi & Mathematical Sans-serif Italic Small I \\
\hline
U+1D62B & 𝘫 & {\textbackslash}mitsansj & Mathematical Sans-serif Italic Small J \\
\hline
U+1D62C & 𝘬 & {\textbackslash}mitsansk & Mathematical Sans-serif Italic Small K \\
\hline
U+1D62D & 𝘭 & {\textbackslash}mitsansl & Mathematical Sans-serif Italic Small L \\
\hline
U+1D62E & 𝘮 & {\textbackslash}mitsansm & Mathematical Sans-serif Italic Small M \\
\hline
U+1D62F & 𝘯 & {\textbackslash}mitsansn & Mathematical Sans-serif Italic Small N \\
\hline
U+1D630 & 𝘰 & {\textbackslash}mitsanso & Mathematical Sans-serif Italic Small O \\
\hline
U+1D631 & 𝘱 & {\textbackslash}mitsansp & Mathematical Sans-serif Italic Small P \\
\hline
U+1D632 & 𝘲 & {\textbackslash}mitsansq & Mathematical Sans-serif Italic Small Q \\
\hline
U+1D633 & 𝘳 & {\textbackslash}mitsansr & Mathematical Sans-serif Italic Small R \\
\hline
U+1D634 & 𝘴 & {\textbackslash}mitsanss & Mathematical Sans-serif Italic Small S \\
\hline
U+1D635 & 𝘵 & {\textbackslash}mitsanst & Mathematical Sans-serif Italic Small T \\
\hline
U+1D636 & 𝘶 & {\textbackslash}mitsansu & Mathematical Sans-serif Italic Small U \\
\hline
U+1D637 & 𝘷 & {\textbackslash}mitsansv & Mathematical Sans-serif Italic Small V \\
\hline
U+1D638 & 𝘸 & {\textbackslash}mitsansw & Mathematical Sans-serif Italic Small W \\
\hline
U+1D639 & 𝘹 & {\textbackslash}mitsansx & Mathematical Sans-serif Italic Small X \\
\hline
U+1D63A & 𝘺 & {\textbackslash}mitsansy & Mathematical Sans-serif Italic Small Y \\
\hline
U+1D63B & 𝘻 & {\textbackslash}mitsansz & Mathematical Sans-serif Italic Small Z \\
\hline
U+1D63C & 𝘼 & {\textbackslash}mbfitsansA & Mathematical Sans-serif Bold Italic Capital A \\
\hline
U+1D63D & 𝘽 & {\textbackslash}mbfitsansB & Mathematical Sans-serif Bold Italic Capital B \\
\hline
U+1D63E & 𝘾 & {\textbackslash}mbfitsansC & Mathematical Sans-serif Bold Italic Capital C \\
\hline
U+1D63F & 𝘿 & {\textbackslash}mbfitsansD & Mathematical Sans-serif Bold Italic Capital D \\
\hline
U+1D640 & 𝙀 & {\textbackslash}mbfitsansE & Mathematical Sans-serif Bold Italic Capital E \\
\hline
U+1D641 & 𝙁 & {\textbackslash}mbfitsansF & Mathematical Sans-serif Bold Italic Capital F \\
\hline
U+1D642 & 𝙂 & {\textbackslash}mbfitsansG & Mathematical Sans-serif Bold Italic Capital G \\
\hline
U+1D643 & 𝙃 & {\textbackslash}mbfitsansH & Mathematical Sans-serif Bold Italic Capital H \\
\hline
U+1D644 & 𝙄 & {\textbackslash}mbfitsansI & Mathematical Sans-serif Bold Italic Capital I \\
\hline
U+1D645 & 𝙅 & {\textbackslash}mbfitsansJ & Mathematical Sans-serif Bold Italic Capital J \\
\hline
U+1D646 & 𝙆 & {\textbackslash}mbfitsansK & Mathematical Sans-serif Bold Italic Capital K \\
\hline
U+1D647 & 𝙇 & {\textbackslash}mbfitsansL & Mathematical Sans-serif Bold Italic Capital L \\
\hline
U+1D648 & 𝙈 & {\textbackslash}mbfitsansM & Mathematical Sans-serif Bold Italic Capital M \\
\hline
U+1D649 & 𝙉 & {\textbackslash}mbfitsansN & Mathematical Sans-serif Bold Italic Capital N \\
\hline
U+1D64A & 𝙊 & {\textbackslash}mbfitsansO & Mathematical Sans-serif Bold Italic Capital O \\
\hline
U+1D64B & 𝙋 & {\textbackslash}mbfitsansP & Mathematical Sans-serif Bold Italic Capital P \\
\hline
U+1D64C & 𝙌 & {\textbackslash}mbfitsansQ & Mathematical Sans-serif Bold Italic Capital Q \\
\hline
U+1D64D & 𝙍 & {\textbackslash}mbfitsansR & Mathematical Sans-serif Bold Italic Capital R \\
\hline
U+1D64E & 𝙎 & {\textbackslash}mbfitsansS & Mathematical Sans-serif Bold Italic Capital S \\
\hline
U+1D64F & 𝙏 & {\textbackslash}mbfitsansT & Mathematical Sans-serif Bold Italic Capital T \\
\hline
U+1D650 & 𝙐 & {\textbackslash}mbfitsansU & Mathematical Sans-serif Bold Italic Capital U \\
\hline
U+1D651 & 𝙑 & {\textbackslash}mbfitsansV & Mathematical Sans-serif Bold Italic Capital V \\
\hline
U+1D652 & 𝙒 & {\textbackslash}mbfitsansW & Mathematical Sans-serif Bold Italic Capital W \\
\hline
U+1D653 & 𝙓 & {\textbackslash}mbfitsansX & Mathematical Sans-serif Bold Italic Capital X \\
\hline
U+1D654 & 𝙔 & {\textbackslash}mbfitsansY & Mathematical Sans-serif Bold Italic Capital Y \\
\hline
U+1D655 & 𝙕 & {\textbackslash}mbfitsansZ & Mathematical Sans-serif Bold Italic Capital Z \\
\hline
U+1D656 & 𝙖 & {\textbackslash}mbfitsansa & Mathematical Sans-serif Bold Italic Small A \\
\hline
U+1D657 & 𝙗 & {\textbackslash}mbfitsansb & Mathematical Sans-serif Bold Italic Small B \\
\hline
U+1D658 & 𝙘 & {\textbackslash}mbfitsansc & Mathematical Sans-serif Bold Italic Small C \\
\hline
U+1D659 & 𝙙 & {\textbackslash}mbfitsansd & Mathematical Sans-serif Bold Italic Small D \\
\hline
U+1D65A & 𝙚 & {\textbackslash}mbfitsanse & Mathematical Sans-serif Bold Italic Small E \\
\hline
U+1D65B & 𝙛 & {\textbackslash}mbfitsansf & Mathematical Sans-serif Bold Italic Small F \\
\hline
U+1D65C & 𝙜 & {\textbackslash}mbfitsansg & Mathematical Sans-serif Bold Italic Small G \\
\hline
U+1D65D & 𝙝 & {\textbackslash}mbfitsansh & Mathematical Sans-serif Bold Italic Small H \\
\hline
U+1D65E & 𝙞 & {\textbackslash}mbfitsansi & Mathematical Sans-serif Bold Italic Small I \\
\hline
U+1D65F & 𝙟 & {\textbackslash}mbfitsansj & Mathematical Sans-serif Bold Italic Small J \\
\hline
U+1D660 & 𝙠 & {\textbackslash}mbfitsansk & Mathematical Sans-serif Bold Italic Small K \\
\hline
U+1D661 & 𝙡 & {\textbackslash}mbfitsansl & Mathematical Sans-serif Bold Italic Small L \\
\hline
U+1D662 & 𝙢 & {\textbackslash}mbfitsansm & Mathematical Sans-serif Bold Italic Small M \\
\hline
U+1D663 & 𝙣 & {\textbackslash}mbfitsansn & Mathematical Sans-serif Bold Italic Small N \\
\hline
U+1D664 & 𝙤 & {\textbackslash}mbfitsanso & Mathematical Sans-serif Bold Italic Small O \\
\hline
U+1D665 & 𝙥 & {\textbackslash}mbfitsansp & Mathematical Sans-serif Bold Italic Small P \\
\hline
U+1D666 & 𝙦 & {\textbackslash}mbfitsansq & Mathematical Sans-serif Bold Italic Small Q \\
\hline
U+1D667 & 𝙧 & {\textbackslash}mbfitsansr & Mathematical Sans-serif Bold Italic Small R \\
\hline
U+1D668 & 𝙨 & {\textbackslash}mbfitsanss & Mathematical Sans-serif Bold Italic Small S \\
\hline
U+1D669 & 𝙩 & {\textbackslash}mbfitsanst & Mathematical Sans-serif Bold Italic Small T \\
\hline
U+1D66A & 𝙪 & {\textbackslash}mbfitsansu & Mathematical Sans-serif Bold Italic Small U \\
\hline
U+1D66B & 𝙫 & {\textbackslash}mbfitsansv & Mathematical Sans-serif Bold Italic Small V \\
\hline
U+1D66C & 𝙬 & {\textbackslash}mbfitsansw & Mathematical Sans-serif Bold Italic Small W \\
\hline
U+1D66D & 𝙭 & {\textbackslash}mbfitsansx & Mathematical Sans-serif Bold Italic Small X \\
\hline
U+1D66E & 𝙮 & {\textbackslash}mbfitsansy & Mathematical Sans-serif Bold Italic Small Y \\
\hline
U+1D66F & 𝙯 & {\textbackslash}mbfitsansz & Mathematical Sans-serif Bold Italic Small Z \\
\hline
U+1D670 & 𝙰 & {\textbackslash}mttA & Mathematical Monospace Capital A \\
\hline
U+1D671 & 𝙱 & {\textbackslash}mttB & Mathematical Monospace Capital B \\
\hline
U+1D672 & 𝙲 & {\textbackslash}mttC & Mathematical Monospace Capital C \\
\hline
U+1D673 & 𝙳 & {\textbackslash}mttD & Mathematical Monospace Capital D \\
\hline
U+1D674 & 𝙴 & {\textbackslash}mttE & Mathematical Monospace Capital E \\
\hline
U+1D675 & 𝙵 & {\textbackslash}mttF & Mathematical Monospace Capital F \\
\hline
U+1D676 & 𝙶 & {\textbackslash}mttG & Mathematical Monospace Capital G \\
\hline
U+1D677 & 𝙷 & {\textbackslash}mttH & Mathematical Monospace Capital H \\
\hline
U+1D678 & 𝙸 & {\textbackslash}mttI & Mathematical Monospace Capital I \\
\hline
U+1D679 & 𝙹 & {\textbackslash}mttJ & Mathematical Monospace Capital J \\
\hline
U+1D67A & 𝙺 & {\textbackslash}mttK & Mathematical Monospace Capital K \\
\hline
U+1D67B & 𝙻 & {\textbackslash}mttL & Mathematical Monospace Capital L \\
\hline
U+1D67C & 𝙼 & {\textbackslash}mttM & Mathematical Monospace Capital M \\
\hline
U+1D67D & 𝙽 & {\textbackslash}mttN & Mathematical Monospace Capital N \\
\hline
U+1D67E & 𝙾 & {\textbackslash}mttO & Mathematical Monospace Capital O \\
\hline
U+1D67F & 𝙿 & {\textbackslash}mttP & Mathematical Monospace Capital P \\
\hline
U+1D680 & 𝚀 & {\textbackslash}mttQ & Mathematical Monospace Capital Q \\
\hline
U+1D681 & 𝚁 & {\textbackslash}mttR & Mathematical Monospace Capital R \\
\hline
U+1D682 & 𝚂 & {\textbackslash}mttS & Mathematical Monospace Capital S \\
\hline
U+1D683 & 𝚃 & {\textbackslash}mttT & Mathematical Monospace Capital T \\
\hline
U+1D684 & 𝚄 & {\textbackslash}mttU & Mathematical Monospace Capital U \\
\hline
U+1D685 & 𝚅 & {\textbackslash}mttV & Mathematical Monospace Capital V \\
\hline
U+1D686 & 𝚆 & {\textbackslash}mttW & Mathematical Monospace Capital W \\
\hline
U+1D687 & 𝚇 & {\textbackslash}mttX & Mathematical Monospace Capital X \\
\hline
U+1D688 & 𝚈 & {\textbackslash}mttY & Mathematical Monospace Capital Y \\
\hline
U+1D689 & 𝚉 & {\textbackslash}mttZ & Mathematical Monospace Capital Z \\
\hline
U+1D68A & 𝚊 & {\textbackslash}mtta & Mathematical Monospace Small A \\
\hline
U+1D68B & 𝚋 & {\textbackslash}mttb & Mathematical Monospace Small B \\
\hline
U+1D68C & 𝚌 & {\textbackslash}mttc & Mathematical Monospace Small C \\
\hline
U+1D68D & 𝚍 & {\textbackslash}mttd & Mathematical Monospace Small D \\
\hline
U+1D68E & 𝚎 & {\textbackslash}mtte & Mathematical Monospace Small E \\
\hline
U+1D68F & 𝚏 & {\textbackslash}mttf & Mathematical Monospace Small F \\
\hline
U+1D690 & 𝚐 & {\textbackslash}mttg & Mathematical Monospace Small G \\
\hline
U+1D691 & 𝚑 & {\textbackslash}mtth & Mathematical Monospace Small H \\
\hline
U+1D692 & 𝚒 & {\textbackslash}mtti & Mathematical Monospace Small I \\
\hline
U+1D693 & 𝚓 & {\textbackslash}mttj & Mathematical Monospace Small J \\
\hline
U+1D694 & 𝚔 & {\textbackslash}mttk & Mathematical Monospace Small K \\
\hline
U+1D695 & 𝚕 & {\textbackslash}mttl & Mathematical Monospace Small L \\
\hline
U+1D696 & 𝚖 & {\textbackslash}mttm & Mathematical Monospace Small M \\
\hline
U+1D697 & 𝚗 & {\textbackslash}mttn & Mathematical Monospace Small N \\
\hline
U+1D698 & 𝚘 & {\textbackslash}mtto & Mathematical Monospace Small O \\
\hline
U+1D699 & 𝚙 & {\textbackslash}mttp & Mathematical Monospace Small P \\
\hline
U+1D69A & 𝚚 & {\textbackslash}mttq & Mathematical Monospace Small Q \\
\hline
U+1D69B & 𝚛 & {\textbackslash}mttr & Mathematical Monospace Small R \\
\hline
U+1D69C & 𝚜 & {\textbackslash}mtts & Mathematical Monospace Small S \\
\hline
U+1D69D & 𝚝 & {\textbackslash}mttt & Mathematical Monospace Small T \\
\hline
U+1D69E & 𝚞 & {\textbackslash}mttu & Mathematical Monospace Small U \\
\hline
U+1D69F & 𝚟 & {\textbackslash}mttv & Mathematical Monospace Small V \\
\hline
U+1D6A0 & 𝚠 & {\textbackslash}mttw & Mathematical Monospace Small W \\
\hline
U+1D6A1 & 𝚡 & {\textbackslash}mttx & Mathematical Monospace Small X \\
\hline
U+1D6A2 & 𝚢 & {\textbackslash}mtty & Mathematical Monospace Small Y \\
\hline
U+1D6A3 & 𝚣 & {\textbackslash}mttz & Mathematical Monospace Small Z \\
\hline
U+1D6A4 & 𝚤 & {\textbackslash}imath & Mathematical Italic Small Dotless I \\
\hline
U+1D6A5 & 𝚥 & {\textbackslash}jmath & Mathematical Italic Small Dotless J \\
\hline
U+1D6A8 & 𝚨 & {\textbackslash}mbfAlpha & Mathematical Bold Capital Alpha \\
\hline
U+1D6A9 & 𝚩 & {\textbackslash}mbfBeta & Mathematical Bold Capital Beta \\
\hline
U+1D6AA & 𝚪 & {\textbackslash}mbfGamma & Mathematical Bold Capital Gamma \\
\hline
U+1D6AB & 𝚫 & {\textbackslash}mbfDelta & Mathematical Bold Capital Delta \\
\hline
U+1D6AC & 𝚬 & {\textbackslash}mbfEpsilon & Mathematical Bold Capital Epsilon \\
\hline
U+1D6AD & 𝚭 & {\textbackslash}mbfZeta & Mathematical Bold Capital Zeta \\
\hline
U+1D6AE & 𝚮 & {\textbackslash}mbfEta & Mathematical Bold Capital Eta \\
\hline
U+1D6AF & 𝚯 & {\textbackslash}mbfTheta & Mathematical Bold Capital Theta \\
\hline
U+1D6B0 & 𝚰 & {\textbackslash}mbfIota & Mathematical Bold Capital Iota \\
\hline
U+1D6B1 & 𝚱 & {\textbackslash}mbfKappa & Mathematical Bold Capital Kappa \\
\hline
U+1D6B2 & 𝚲 & {\textbackslash}mbfLambda & Mathematical Bold Capital Lamda \\
\hline
U+1D6B3 & 𝚳 & {\textbackslash}mbfMu & Mathematical Bold Capital Mu \\
\hline
U+1D6B4 & 𝚴 & {\textbackslash}mbfNu & Mathematical Bold Capital Nu \\
\hline
U+1D6B5 & 𝚵 & {\textbackslash}mbfXi & Mathematical Bold Capital Xi \\
\hline
U+1D6B6 & 𝚶 & {\textbackslash}mbfOmicron & Mathematical Bold Capital Omicron \\
\hline
U+1D6B7 & 𝚷 & {\textbackslash}mbfPi & Mathematical Bold Capital Pi \\
\hline
U+1D6B8 & 𝚸 & {\textbackslash}mbfRho & Mathematical Bold Capital Rho \\
\hline
U+1D6B9 & 𝚹 & {\textbackslash}mbfvarTheta & Mathematical Bold Capital Theta Symbol \\
\hline
U+1D6BA & 𝚺 & {\textbackslash}mbfSigma & Mathematical Bold Capital Sigma \\
\hline
U+1D6BB & 𝚻 & {\textbackslash}mbfTau & Mathematical Bold Capital Tau \\
\hline
U+1D6BC & 𝚼 & {\textbackslash}mbfUpsilon & Mathematical Bold Capital Upsilon \\
\hline
U+1D6BD & 𝚽 & {\textbackslash}mbfPhi & Mathematical Bold Capital Phi \\
\hline
U+1D6BE & 𝚾 & {\textbackslash}mbfChi & Mathematical Bold Capital Chi \\
\hline
U+1D6BF & 𝚿 & {\textbackslash}mbfPsi & Mathematical Bold Capital Psi \\
\hline
U+1D6C0 & 𝛀 & {\textbackslash}mbfOmega & Mathematical Bold Capital Omega \\
\hline
U+1D6C1 & 𝛁 & {\textbackslash}mbfnabla & Mathematical Bold Nabla \\
\hline
U+1D6C2 & 𝛂 & {\textbackslash}mbfalpha & Mathematical Bold Small Alpha \\
\hline
U+1D6C3 & 𝛃 & {\textbackslash}mbfbeta & Mathematical Bold Small Beta \\
\hline
U+1D6C4 & 𝛄 & {\textbackslash}mbfgamma & Mathematical Bold Small Gamma \\
\hline
U+1D6C5 & 𝛅 & {\textbackslash}mbfdelta & Mathematical Bold Small Delta \\
\hline
U+1D6C6 & 𝛆 & {\textbackslash}mbfepsilon & Mathematical Bold Small Epsilon \\
\hline
U+1D6C7 & 𝛇 & {\textbackslash}mbfzeta & Mathematical Bold Small Zeta \\
\hline
U+1D6C8 & 𝛈 & {\textbackslash}mbfeta & Mathematical Bold Small Eta \\
\hline
U+1D6C9 & 𝛉 & {\textbackslash}mbftheta & Mathematical Bold Small Theta \\
\hline
U+1D6CA & 𝛊 & {\textbackslash}mbfiota & Mathematical Bold Small Iota \\
\hline
U+1D6CB & 𝛋 & {\textbackslash}mbfkappa & Mathematical Bold Small Kappa \\
\hline
U+1D6CC & 𝛌 & {\textbackslash}mbflambda & Mathematical Bold Small Lamda \\
\hline
U+1D6CD & 𝛍 & {\textbackslash}mbfmu & Mathematical Bold Small Mu \\
\hline
U+1D6CE & 𝛎 & {\textbackslash}mbfnu & Mathematical Bold Small Nu \\
\hline
U+1D6CF & 𝛏 & {\textbackslash}mbfxi & Mathematical Bold Small Xi \\
\hline
U+1D6D0 & 𝛐 & {\textbackslash}mbfomicron & Mathematical Bold Small Omicron \\
\hline
U+1D6D1 & 𝛑 & {\textbackslash}mbfpi & Mathematical Bold Small Pi \\
\hline
U+1D6D2 & 𝛒 & {\textbackslash}mbfrho & Mathematical Bold Small Rho \\
\hline
U+1D6D3 & 𝛓 & {\textbackslash}mbfvarsigma & Mathematical Bold Small Final Sigma \\
\hline
U+1D6D4 & 𝛔 & {\textbackslash}mbfsigma & Mathematical Bold Small Sigma \\
\hline
U+1D6D5 & 𝛕 & {\textbackslash}mbftau & Mathematical Bold Small Tau \\
\hline
U+1D6D6 & 𝛖 & {\textbackslash}mbfupsilon & Mathematical Bold Small Upsilon \\
\hline
U+1D6D7 & 𝛗 & {\textbackslash}mbfvarphi & Mathematical Bold Small Phi \\
\hline
U+1D6D8 & 𝛘 & {\textbackslash}mbfchi & Mathematical Bold Small Chi \\
\hline
U+1D6D9 & 𝛙 & {\textbackslash}mbfpsi & Mathematical Bold Small Psi \\
\hline
U+1D6DA & 𝛚 & {\textbackslash}mbfomega & Mathematical Bold Small Omega \\
\hline
U+1D6DB & 𝛛 & {\textbackslash}mbfpartial & Mathematical Bold Partial Differential \\
\hline
U+1D6DC & 𝛜 & {\textbackslash}mbfvarepsilon & Mathematical Bold Epsilon Symbol \\
\hline
U+1D6DD & 𝛝 & {\textbackslash}mbfvartheta & Mathematical Bold Theta Symbol \\
\hline
U+1D6DE & 𝛞 & {\textbackslash}mbfvarkappa & Mathematical Bold Kappa Symbol \\
\hline
U+1D6DF & 𝛟 & {\textbackslash}mbfphi & Mathematical Bold Phi Symbol \\
\hline
U+1D6E0 & 𝛠 & {\textbackslash}mbfvarrho & Mathematical Bold Rho Symbol \\
\hline
U+1D6E1 & 𝛡 & {\textbackslash}mbfvarpi & Mathematical Bold Pi Symbol \\
\hline
U+1D6E2 & 𝛢 & {\textbackslash}mitAlpha & Mathematical Italic Capital Alpha \\
\hline
U+1D6E3 & 𝛣 & {\textbackslash}mitBeta & Mathematical Italic Capital Beta \\
\hline
U+1D6E4 & 𝛤 & {\textbackslash}mitGamma & Mathematical Italic Capital Gamma \\
\hline
U+1D6E5 & 𝛥 & {\textbackslash}mitDelta & Mathematical Italic Capital Delta \\
\hline
U+1D6E6 & 𝛦 & {\textbackslash}mitEpsilon & Mathematical Italic Capital Epsilon \\
\hline
U+1D6E7 & 𝛧 & {\textbackslash}mitZeta & Mathematical Italic Capital Zeta \\
\hline
U+1D6E8 & 𝛨 & {\textbackslash}mitEta & Mathematical Italic Capital Eta \\
\hline
U+1D6E9 & 𝛩 & {\textbackslash}mitTheta & Mathematical Italic Capital Theta \\
\hline
U+1D6EA & 𝛪 & {\textbackslash}mitIota & Mathematical Italic Capital Iota \\
\hline
U+1D6EB & 𝛫 & {\textbackslash}mitKappa & Mathematical Italic Capital Kappa \\
\hline
U+1D6EC & 𝛬 & {\textbackslash}mitLambda & Mathematical Italic Capital Lamda \\
\hline
U+1D6ED & 𝛭 & {\textbackslash}mitMu & Mathematical Italic Capital Mu \\
\hline
U+1D6EE & 𝛮 & {\textbackslash}mitNu & Mathematical Italic Capital Nu \\
\hline
U+1D6EF & 𝛯 & {\textbackslash}mitXi & Mathematical Italic Capital Xi \\
\hline
U+1D6F0 & 𝛰 & {\textbackslash}mitOmicron & Mathematical Italic Capital Omicron \\
\hline
U+1D6F1 & 𝛱 & {\textbackslash}mitPi & Mathematical Italic Capital Pi \\
\hline
U+1D6F2 & 𝛲 & {\textbackslash}mitRho & Mathematical Italic Capital Rho \\
\hline
U+1D6F3 & 𝛳 & {\textbackslash}mitvarTheta & Mathematical Italic Capital Theta Symbol \\
\hline
U+1D6F4 & 𝛴 & {\textbackslash}mitSigma & Mathematical Italic Capital Sigma \\
\hline
U+1D6F5 & 𝛵 & {\textbackslash}mitTau & Mathematical Italic Capital Tau \\
\hline
U+1D6F6 & 𝛶 & {\textbackslash}mitUpsilon & Mathematical Italic Capital Upsilon \\
\hline
U+1D6F7 & 𝛷 & {\textbackslash}mitPhi & Mathematical Italic Capital Phi \\
\hline
U+1D6F8 & 𝛸 & {\textbackslash}mitChi & Mathematical Italic Capital Chi \\
\hline
U+1D6F9 & 𝛹 & {\textbackslash}mitPsi & Mathematical Italic Capital Psi \\
\hline
U+1D6FA & 𝛺 & {\textbackslash}mitOmega & Mathematical Italic Capital Omega \\
\hline
U+1D6FB & 𝛻 & {\textbackslash}mitnabla & Mathematical Italic Nabla \\
\hline
U+1D6FC & 𝛼 & {\textbackslash}mitalpha & Mathematical Italic Small Alpha \\
\hline
U+1D6FD & 𝛽 & {\textbackslash}mitbeta & Mathematical Italic Small Beta \\
\hline
U+1D6FE & 𝛾 & {\textbackslash}mitgamma & Mathematical Italic Small Gamma \\
\hline
U+1D6FF & 𝛿 & {\textbackslash}mitdelta & Mathematical Italic Small Delta \\
\hline
U+1D700 & 𝜀 & {\textbackslash}mitepsilon & Mathematical Italic Small Epsilon \\
\hline
U+1D701 & 𝜁 & {\textbackslash}mitzeta & Mathematical Italic Small Zeta \\
\hline
U+1D702 & 𝜂 & {\textbackslash}miteta & Mathematical Italic Small Eta \\
\hline
U+1D703 & 𝜃 & {\textbackslash}mittheta & Mathematical Italic Small Theta \\
\hline
U+1D704 & 𝜄 & {\textbackslash}mitiota & Mathematical Italic Small Iota \\
\hline
U+1D705 & 𝜅 & {\textbackslash}mitkappa & Mathematical Italic Small Kappa \\
\hline
U+1D706 & 𝜆 & {\textbackslash}mitlambda & Mathematical Italic Small Lamda \\
\hline
U+1D707 & 𝜇 & {\textbackslash}mitmu & Mathematical Italic Small Mu \\
\hline
U+1D708 & 𝜈 & {\textbackslash}mitnu & Mathematical Italic Small Nu \\
\hline
U+1D709 & 𝜉 & {\textbackslash}mitxi & Mathematical Italic Small Xi \\
\hline
U+1D70A & 𝜊 & {\textbackslash}mitomicron & Mathematical Italic Small Omicron \\
\hline
U+1D70B & 𝜋 & {\textbackslash}mitpi & Mathematical Italic Small Pi \\
\hline
U+1D70C & 𝜌 & {\textbackslash}mitrho & Mathematical Italic Small Rho \\
\hline
U+1D70D & 𝜍 & {\textbackslash}mitvarsigma & Mathematical Italic Small Final Sigma \\
\hline
U+1D70E & 𝜎 & {\textbackslash}mitsigma & Mathematical Italic Small Sigma \\
\hline
U+1D70F & 𝜏 & {\textbackslash}mittau & Mathematical Italic Small Tau \\
\hline
U+1D710 & 𝜐 & {\textbackslash}mitupsilon & Mathematical Italic Small Upsilon \\
\hline
U+1D711 & 𝜑 & {\textbackslash}mitphi & Mathematical Italic Small Phi \\
\hline
U+1D712 & 𝜒 & {\textbackslash}mitchi & Mathematical Italic Small Chi \\
\hline
U+1D713 & 𝜓 & {\textbackslash}mitpsi & Mathematical Italic Small Psi \\
\hline
U+1D714 & 𝜔 & {\textbackslash}mitomega & Mathematical Italic Small Omega \\
\hline
U+1D715 & 𝜕 & {\textbackslash}mitpartial & Mathematical Italic Partial Differential \\
\hline
U+1D716 & 𝜖 & {\textbackslash}mitvarepsilon & Mathematical Italic Epsilon Symbol \\
\hline
U+1D717 & 𝜗 & {\textbackslash}mitvartheta & Mathematical Italic Theta Symbol \\
\hline
U+1D718 & 𝜘 & {\textbackslash}mitvarkappa & Mathematical Italic Kappa Symbol \\
\hline
U+1D719 & 𝜙 & {\textbackslash}mitvarphi & Mathematical Italic Phi Symbol \\
\hline
U+1D71A & 𝜚 & {\textbackslash}mitvarrho & Mathematical Italic Rho Symbol \\
\hline
U+1D71B & 𝜛 & {\textbackslash}mitvarpi & Mathematical Italic Pi Symbol \\
\hline
U+1D71C & 𝜜 & {\textbackslash}mbfitAlpha & Mathematical Bold Italic Capital Alpha \\
\hline
U+1D71D & 𝜝 & {\textbackslash}mbfitBeta & Mathematical Bold Italic Capital Beta \\
\hline
U+1D71E & 𝜞 & {\textbackslash}mbfitGamma & Mathematical Bold Italic Capital Gamma \\
\hline
U+1D71F & 𝜟 & {\textbackslash}mbfitDelta & Mathematical Bold Italic Capital Delta \\
\hline
U+1D720 & 𝜠 & {\textbackslash}mbfitEpsilon & Mathematical Bold Italic Capital Epsilon \\
\hline
U+1D721 & 𝜡 & {\textbackslash}mbfitZeta & Mathematical Bold Italic Capital Zeta \\
\hline
U+1D722 & 𝜢 & {\textbackslash}mbfitEta & Mathematical Bold Italic Capital Eta \\
\hline
U+1D723 & 𝜣 & {\textbackslash}mbfitTheta & Mathematical Bold Italic Capital Theta \\
\hline
U+1D724 & 𝜤 & {\textbackslash}mbfitIota & Mathematical Bold Italic Capital Iota \\
\hline
U+1D725 & 𝜥 & {\textbackslash}mbfitKappa & Mathematical Bold Italic Capital Kappa \\
\hline
U+1D726 & 𝜦 & {\textbackslash}mbfitLambda & Mathematical Bold Italic Capital Lamda \\
\hline
U+1D727 & 𝜧 & {\textbackslash}mbfitMu & Mathematical Bold Italic Capital Mu \\
\hline
U+1D728 & 𝜨 & {\textbackslash}mbfitNu & Mathematical Bold Italic Capital Nu \\
\hline
U+1D729 & 𝜩 & {\textbackslash}mbfitXi & Mathematical Bold Italic Capital Xi \\
\hline
U+1D72A & 𝜪 & {\textbackslash}mbfitOmicron & Mathematical Bold Italic Capital Omicron \\
\hline
U+1D72B & 𝜫 & {\textbackslash}mbfitPi & Mathematical Bold Italic Capital Pi \\
\hline
U+1D72C & 𝜬 & {\textbackslash}mbfitRho & Mathematical Bold Italic Capital Rho \\
\hline
U+1D72D & 𝜭 & {\textbackslash}mbfitvarTheta & Mathematical Bold Italic Capital Theta Symbol \\
\hline
U+1D72E & 𝜮 & {\textbackslash}mbfitSigma & Mathematical Bold Italic Capital Sigma \\
\hline
U+1D72F & 𝜯 & {\textbackslash}mbfitTau & Mathematical Bold Italic Capital Tau \\
\hline
U+1D730 & 𝜰 & {\textbackslash}mbfitUpsilon & Mathematical Bold Italic Capital Upsilon \\
\hline
U+1D731 & 𝜱 & {\textbackslash}mbfitPhi & Mathematical Bold Italic Capital Phi \\
\hline
U+1D732 & 𝜲 & {\textbackslash}mbfitChi & Mathematical Bold Italic Capital Chi \\
\hline
U+1D733 & 𝜳 & {\textbackslash}mbfitPsi & Mathematical Bold Italic Capital Psi \\
\hline
U+1D734 & 𝜴 & {\textbackslash}mbfitOmega & Mathematical Bold Italic Capital Omega \\
\hline
U+1D735 & 𝜵 & {\textbackslash}mbfitnabla & Mathematical Bold Italic Nabla \\
\hline
U+1D736 & 𝜶 & {\textbackslash}mbfitalpha & Mathematical Bold Italic Small Alpha \\
\hline
U+1D737 & 𝜷 & {\textbackslash}mbfitbeta & Mathematical Bold Italic Small Beta \\
\hline
U+1D738 & 𝜸 & {\textbackslash}mbfitgamma & Mathematical Bold Italic Small Gamma \\
\hline
U+1D739 & 𝜹 & {\textbackslash}mbfitdelta & Mathematical Bold Italic Small Delta \\
\hline
U+1D73A & 𝜺 & {\textbackslash}mbfitepsilon & Mathematical Bold Italic Small Epsilon \\
\hline
U+1D73B & 𝜻 & {\textbackslash}mbfitzeta & Mathematical Bold Italic Small Zeta \\
\hline
U+1D73C & 𝜼 & {\textbackslash}mbfiteta & Mathematical Bold Italic Small Eta \\
\hline
U+1D73D & 𝜽 & {\textbackslash}mbfittheta & Mathematical Bold Italic Small Theta \\
\hline
U+1D73E & 𝜾 & {\textbackslash}mbfitiota & Mathematical Bold Italic Small Iota \\
\hline
U+1D73F & 𝜿 & {\textbackslash}mbfitkappa & Mathematical Bold Italic Small Kappa \\
\hline
U+1D740 & 𝝀 & {\textbackslash}mbfitlambda & Mathematical Bold Italic Small Lamda \\
\hline
U+1D741 & 𝝁 & {\textbackslash}mbfitmu & Mathematical Bold Italic Small Mu \\
\hline
U+1D742 & 𝝂 & {\textbackslash}mbfitnu & Mathematical Bold Italic Small Nu \\
\hline
U+1D743 & 𝝃 & {\textbackslash}mbfitxi & Mathematical Bold Italic Small Xi \\
\hline
U+1D744 & 𝝄 & {\textbackslash}mbfitomicron & Mathematical Bold Italic Small Omicron \\
\hline
U+1D745 & 𝝅 & {\textbackslash}mbfitpi & Mathematical Bold Italic Small Pi \\
\hline
U+1D746 & 𝝆 & {\textbackslash}mbfitrho & Mathematical Bold Italic Small Rho \\
\hline
U+1D747 & 𝝇 & {\textbackslash}mbfitvarsigma & Mathematical Bold Italic Small Final Sigma \\
\hline
U+1D748 & 𝝈 & {\textbackslash}mbfitsigma & Mathematical Bold Italic Small Sigma \\
\hline
U+1D749 & 𝝉 & {\textbackslash}mbfittau & Mathematical Bold Italic Small Tau \\
\hline
U+1D74A & 𝝊 & {\textbackslash}mbfitupsilon & Mathematical Bold Italic Small Upsilon \\
\hline
U+1D74B & 𝝋 & {\textbackslash}mbfitphi & Mathematical Bold Italic Small Phi \\
\hline
U+1D74C & 𝝌 & {\textbackslash}mbfitchi & Mathematical Bold Italic Small Chi \\
\hline
U+1D74D & 𝝍 & {\textbackslash}mbfitpsi & Mathematical Bold Italic Small Psi \\
\hline
U+1D74E & 𝝎 & {\textbackslash}mbfitomega & Mathematical Bold Italic Small Omega \\
\hline
U+1D74F & 𝝏 & {\textbackslash}mbfitpartial & Mathematical Bold Italic Partial Differential \\
\hline
U+1D750 & 𝝐 & {\textbackslash}mbfitvarepsilon & Mathematical Bold Italic Epsilon Symbol \\
\hline
U+1D751 & 𝝑 & {\textbackslash}mbfitvartheta & Mathematical Bold Italic Theta Symbol \\
\hline
U+1D752 & 𝝒 & {\textbackslash}mbfitvarkappa & Mathematical Bold Italic Kappa Symbol \\
\hline
U+1D753 & 𝝓 & {\textbackslash}mbfitvarphi & Mathematical Bold Italic Phi Symbol \\
\hline
U+1D754 & 𝝔 & {\textbackslash}mbfitvarrho & Mathematical Bold Italic Rho Symbol \\
\hline
U+1D755 & 𝝕 & {\textbackslash}mbfitvarpi & Mathematical Bold Italic Pi Symbol \\
\hline
U+1D756 & 𝝖 & {\textbackslash}mbfsansAlpha & Mathematical Sans-serif Bold Capital Alpha \\
\hline
U+1D757 & 𝝗 & {\textbackslash}mbfsansBeta & Mathematical Sans-serif Bold Capital Beta \\
\hline
U+1D758 & 𝝘 & {\textbackslash}mbfsansGamma & Mathematical Sans-serif Bold Capital Gamma \\
\hline
U+1D759 & 𝝙 & {\textbackslash}mbfsansDelta & Mathematical Sans-serif Bold Capital Delta \\
\hline
U+1D75A & 𝝚 & {\textbackslash}mbfsansEpsilon & Mathematical Sans-serif Bold Capital Epsilon \\
\hline
U+1D75B & 𝝛 & {\textbackslash}mbfsansZeta & Mathematical Sans-serif Bold Capital Zeta \\
\hline
U+1D75C & 𝝜 & {\textbackslash}mbfsansEta & Mathematical Sans-serif Bold Capital Eta \\
\hline
U+1D75D & 𝝝 & {\textbackslash}mbfsansTheta & Mathematical Sans-serif Bold Capital Theta \\
\hline
U+1D75E & 𝝞 & {\textbackslash}mbfsansIota & Mathematical Sans-serif Bold Capital Iota \\
\hline
U+1D75F & 𝝟 & {\textbackslash}mbfsansKappa & Mathematical Sans-serif Bold Capital Kappa \\
\hline
U+1D760 & 𝝠 & {\textbackslash}mbfsansLambda & Mathematical Sans-serif Bold Capital Lamda \\
\hline
U+1D761 & 𝝡 & {\textbackslash}mbfsansMu & Mathematical Sans-serif Bold Capital Mu \\
\hline
U+1D762 & 𝝢 & {\textbackslash}mbfsansNu & Mathematical Sans-serif Bold Capital Nu \\
\hline
U+1D763 & 𝝣 & {\textbackslash}mbfsansXi & Mathematical Sans-serif Bold Capital Xi \\
\hline
U+1D764 & 𝝤 & {\textbackslash}mbfsansOmicron & Mathematical Sans-serif Bold Capital Omicron \\
\hline
U+1D765 & 𝝥 & {\textbackslash}mbfsansPi & Mathematical Sans-serif Bold Capital Pi \\
\hline
U+1D766 & 𝝦 & {\textbackslash}mbfsansRho & Mathematical Sans-serif Bold Capital Rho \\
\hline
U+1D767 & 𝝧 & {\textbackslash}mbfsansvarTheta & Mathematical Sans-serif Bold Capital Theta Symbol \\
\hline
U+1D768 & 𝝨 & {\textbackslash}mbfsansSigma & Mathematical Sans-serif Bold Capital Sigma \\
\hline
U+1D769 & 𝝩 & {\textbackslash}mbfsansTau & Mathematical Sans-serif Bold Capital Tau \\
\hline
U+1D76A & 𝝪 & {\textbackslash}mbfsansUpsilon & Mathematical Sans-serif Bold Capital Upsilon \\
\hline
U+1D76B & 𝝫 & {\textbackslash}mbfsansPhi & Mathematical Sans-serif Bold Capital Phi \\
\hline
U+1D76C & 𝝬 & {\textbackslash}mbfsansChi & Mathematical Sans-serif Bold Capital Chi \\
\hline
U+1D76D & 𝝭 & {\textbackslash}mbfsansPsi & Mathematical Sans-serif Bold Capital Psi \\
\hline
U+1D76E & 𝝮 & {\textbackslash}mbfsansOmega & Mathematical Sans-serif Bold Capital Omega \\
\hline
U+1D76F & 𝝯 & {\textbackslash}mbfsansnabla & Mathematical Sans-serif Bold Nabla \\
\hline
U+1D770 & 𝝰 & {\textbackslash}mbfsansalpha & Mathematical Sans-serif Bold Small Alpha \\
\hline
U+1D771 & 𝝱 & {\textbackslash}mbfsansbeta & Mathematical Sans-serif Bold Small Beta \\
\hline
U+1D772 & 𝝲 & {\textbackslash}mbfsansgamma & Mathematical Sans-serif Bold Small Gamma \\
\hline
U+1D773 & 𝝳 & {\textbackslash}mbfsansdelta & Mathematical Sans-serif Bold Small Delta \\
\hline
U+1D774 & 𝝴 & {\textbackslash}mbfsansepsilon & Mathematical Sans-serif Bold Small Epsilon \\
\hline
U+1D775 & 𝝵 & {\textbackslash}mbfsanszeta & Mathematical Sans-serif Bold Small Zeta \\
\hline
U+1D776 & 𝝶 & {\textbackslash}mbfsanseta & Mathematical Sans-serif Bold Small Eta \\
\hline
U+1D777 & 𝝷 & {\textbackslash}mbfsanstheta & Mathematical Sans-serif Bold Small Theta \\
\hline
U+1D778 & 𝝸 & {\textbackslash}mbfsansiota & Mathematical Sans-serif Bold Small Iota \\
\hline
U+1D779 & 𝝹 & {\textbackslash}mbfsanskappa & Mathematical Sans-serif Bold Small Kappa \\
\hline
U+1D77A & 𝝺 & {\textbackslash}mbfsanslambda & Mathematical Sans-serif Bold Small Lamda \\
\hline
U+1D77B & 𝝻 & {\textbackslash}mbfsansmu & Mathematical Sans-serif Bold Small Mu \\
\hline
U+1D77C & 𝝼 & {\textbackslash}mbfsansnu & Mathematical Sans-serif Bold Small Nu \\
\hline
U+1D77D & 𝝽 & {\textbackslash}mbfsansxi & Mathematical Sans-serif Bold Small Xi \\
\hline
U+1D77E & 𝝾 & {\textbackslash}mbfsansomicron & Mathematical Sans-serif Bold Small Omicron \\
\hline
U+1D77F & 𝝿 & {\textbackslash}mbfsanspi & Mathematical Sans-serif Bold Small Pi \\
\hline
U+1D780 & 𝞀 & {\textbackslash}mbfsansrho & Mathematical Sans-serif Bold Small Rho \\
\hline
U+1D781 & 𝞁 & {\textbackslash}mbfsansvarsigma & Mathematical Sans-serif Bold Small Final Sigma \\
\hline
U+1D782 & 𝞂 & {\textbackslash}mbfsanssigma & Mathematical Sans-serif Bold Small Sigma \\
\hline
U+1D783 & 𝞃 & {\textbackslash}mbfsanstau & Mathematical Sans-serif Bold Small Tau \\
\hline
U+1D784 & 𝞄 & {\textbackslash}mbfsansupsilon & Mathematical Sans-serif Bold Small Upsilon \\
\hline
U+1D785 & 𝞅 & {\textbackslash}mbfsansphi & Mathematical Sans-serif Bold Small Phi \\
\hline
U+1D786 & 𝞆 & {\textbackslash}mbfsanschi & Mathematical Sans-serif Bold Small Chi \\
\hline
U+1D787 & 𝞇 & {\textbackslash}mbfsanspsi & Mathematical Sans-serif Bold Small Psi \\
\hline
U+1D788 & 𝞈 & {\textbackslash}mbfsansomega & Mathematical Sans-serif Bold Small Omega \\
\hline
U+1D789 & 𝞉 & {\textbackslash}mbfsanspartial & Mathematical Sans-serif Bold Partial Differential \\
\hline
U+1D78A & 𝞊 & {\textbackslash}mbfsansvarepsilon & Mathematical Sans-serif Bold Epsilon Symbol \\
\hline
U+1D78B & 𝞋 & {\textbackslash}mbfsansvartheta & Mathematical Sans-serif Bold Theta Symbol \\
\hline
U+1D78C & 𝞌 & {\textbackslash}mbfsansvarkappa & Mathematical Sans-serif Bold Kappa Symbol \\
\hline
U+1D78D & 𝞍 & {\textbackslash}mbfsansvarphi & Mathematical Sans-serif Bold Phi Symbol \\
\hline
U+1D78E & 𝞎 & {\textbackslash}mbfsansvarrho & Mathematical Sans-serif Bold Rho Symbol \\
\hline
U+1D78F & 𝞏 & {\textbackslash}mbfsansvarpi & Mathematical Sans-serif Bold Pi Symbol \\
\hline
U+1D790 & 𝞐 & {\textbackslash}mbfitsansAlpha & Mathematical Sans-serif Bold Italic Capital Alpha \\
\hline
U+1D791 & 𝞑 & {\textbackslash}mbfitsansBeta & Mathematical Sans-serif Bold Italic Capital Beta \\
\hline
U+1D792 & 𝞒 & {\textbackslash}mbfitsansGamma & Mathematical Sans-serif Bold Italic Capital Gamma \\
\hline
U+1D793 & 𝞓 & {\textbackslash}mbfitsansDelta & Mathematical Sans-serif Bold Italic Capital Delta \\
\hline
U+1D794 & 𝞔 & {\textbackslash}mbfitsansEpsilon & Mathematical Sans-serif Bold Italic Capital Epsilon \\
\hline
U+1D795 & 𝞕 & {\textbackslash}mbfitsansZeta & Mathematical Sans-serif Bold Italic Capital Zeta \\
\hline
U+1D796 & 𝞖 & {\textbackslash}mbfitsansEta & Mathematical Sans-serif Bold Italic Capital Eta \\
\hline
U+1D797 & 𝞗 & {\textbackslash}mbfitsansTheta & Mathematical Sans-serif Bold Italic Capital Theta \\
\hline
U+1D798 & 𝞘 & {\textbackslash}mbfitsansIota & Mathematical Sans-serif Bold Italic Capital Iota \\
\hline
U+1D799 & 𝞙 & {\textbackslash}mbfitsansKappa & Mathematical Sans-serif Bold Italic Capital Kappa \\
\hline
U+1D79A & 𝞚 & {\textbackslash}mbfitsansLambda & Mathematical Sans-serif Bold Italic Capital Lamda \\
\hline
U+1D79B & 𝞛 & {\textbackslash}mbfitsansMu & Mathematical Sans-serif Bold Italic Capital Mu \\
\hline
U+1D79C & 𝞜 & {\textbackslash}mbfitsansNu & Mathematical Sans-serif Bold Italic Capital Nu \\
\hline
U+1D79D & 𝞝 & {\textbackslash}mbfitsansXi & Mathematical Sans-serif Bold Italic Capital Xi \\
\hline
U+1D79E & 𝞞 & {\textbackslash}mbfitsansOmicron & Mathematical Sans-serif Bold Italic Capital Omicron \\
\hline
U+1D79F & 𝞟 & {\textbackslash}mbfitsansPi & Mathematical Sans-serif Bold Italic Capital Pi \\
\hline
U+1D7A0 & 𝞠 & {\textbackslash}mbfitsansRho & Mathematical Sans-serif Bold Italic Capital Rho \\
\hline
U+1D7A1 & 𝞡 & {\textbackslash}mbfitsansvarTheta & Mathematical Sans-serif Bold Italic Capital Theta Symbol \\
\hline
U+1D7A2 & 𝞢 & {\textbackslash}mbfitsansSigma & Mathematical Sans-serif Bold Italic Capital Sigma \\
\hline
U+1D7A3 & 𝞣 & {\textbackslash}mbfitsansTau & Mathematical Sans-serif Bold Italic Capital Tau \\
\hline
U+1D7A4 & 𝞤 & {\textbackslash}mbfitsansUpsilon & Mathematical Sans-serif Bold Italic Capital Upsilon \\
\hline
U+1D7A5 & 𝞥 & {\textbackslash}mbfitsansPhi & Mathematical Sans-serif Bold Italic Capital Phi \\
\hline
U+1D7A6 & 𝞦 & {\textbackslash}mbfitsansChi & Mathematical Sans-serif Bold Italic Capital Chi \\
\hline
U+1D7A7 & 𝞧 & {\textbackslash}mbfitsansPsi & Mathematical Sans-serif Bold Italic Capital Psi \\
\hline
U+1D7A8 & 𝞨 & {\textbackslash}mbfitsansOmega & Mathematical Sans-serif Bold Italic Capital Omega \\
\hline
U+1D7A9 & 𝞩 & {\textbackslash}mbfitsansnabla & Mathematical Sans-serif Bold Italic Nabla \\
\hline
U+1D7AA & 𝞪 & {\textbackslash}mbfitsansalpha & Mathematical Sans-serif Bold Italic Small Alpha \\
\hline
U+1D7AB & 𝞫 & {\textbackslash}mbfitsansbeta & Mathematical Sans-serif Bold Italic Small Beta \\
\hline
U+1D7AC & 𝞬 & {\textbackslash}mbfitsansgamma & Mathematical Sans-serif Bold Italic Small Gamma \\
\hline
U+1D7AD & 𝞭 & {\textbackslash}mbfitsansdelta & Mathematical Sans-serif Bold Italic Small Delta \\
\hline
U+1D7AE & 𝞮 & {\textbackslash}mbfitsansepsilon & Mathematical Sans-serif Bold Italic Small Epsilon \\
\hline
U+1D7AF & 𝞯 & {\textbackslash}mbfitsanszeta & Mathematical Sans-serif Bold Italic Small Zeta \\
\hline
U+1D7B0 & 𝞰 & {\textbackslash}mbfitsanseta & Mathematical Sans-serif Bold Italic Small Eta \\
\hline
U+1D7B1 & 𝞱 & {\textbackslash}mbfitsanstheta & Mathematical Sans-serif Bold Italic Small Theta \\
\hline
U+1D7B2 & 𝞲 & {\textbackslash}mbfitsansiota & Mathematical Sans-serif Bold Italic Small Iota \\
\hline
U+1D7B3 & 𝞳 & {\textbackslash}mbfitsanskappa & Mathematical Sans-serif Bold Italic Small Kappa \\
\hline
U+1D7B4 & 𝞴 & {\textbackslash}mbfitsanslambda & Mathematical Sans-serif Bold Italic Small Lamda \\
\hline
U+1D7B5 & 𝞵 & {\textbackslash}mbfitsansmu & Mathematical Sans-serif Bold Italic Small Mu \\
\hline
U+1D7B6 & 𝞶 & {\textbackslash}mbfitsansnu & Mathematical Sans-serif Bold Italic Small Nu \\
\hline
U+1D7B7 & 𝞷 & {\textbackslash}mbfitsansxi & Mathematical Sans-serif Bold Italic Small Xi \\
\hline
U+1D7B8 & 𝞸 & {\textbackslash}mbfitsansomicron & Mathematical Sans-serif Bold Italic Small Omicron \\
\hline
U+1D7B9 & 𝞹 & {\textbackslash}mbfitsanspi & Mathematical Sans-serif Bold Italic Small Pi \\
\hline
U+1D7BA & 𝞺 & {\textbackslash}mbfitsansrho & Mathematical Sans-serif Bold Italic Small Rho \\
\hline
U+1D7BB & 𝞻 & {\textbackslash}mbfitsansvarsigma & Mathematical Sans-serif Bold Italic Small Final Sigma \\
\hline
U+1D7BC & 𝞼 & {\textbackslash}mbfitsanssigma & Mathematical Sans-serif Bold Italic Small Sigma \\
\hline
U+1D7BD & 𝞽 & {\textbackslash}mbfitsanstau & Mathematical Sans-serif Bold Italic Small Tau \\
\hline
U+1D7BE & 𝞾 & {\textbackslash}mbfitsansupsilon & Mathematical Sans-serif Bold Italic Small Upsilon \\
\hline
U+1D7BF & 𝞿 & {\textbackslash}mbfitsansphi & Mathematical Sans-serif Bold Italic Small Phi \\
\hline
U+1D7C0 & 𝟀 & {\textbackslash}mbfitsanschi & Mathematical Sans-serif Bold Italic Small Chi \\
\hline
U+1D7C1 & 𝟁 & {\textbackslash}mbfitsanspsi & Mathematical Sans-serif Bold Italic Small Psi \\
\hline
U+1D7C2 & 𝟂 & {\textbackslash}mbfitsansomega & Mathematical Sans-serif Bold Italic Small Omega \\
\hline
U+1D7C3 & 𝟃 & {\textbackslash}mbfitsanspartial & Mathematical Sans-serif Bold Italic Partial Differential \\
\hline
U+1D7C4 & 𝟄 & {\textbackslash}mbfitsansvarepsilon & Mathematical Sans-serif Bold Italic Epsilon Symbol \\
\hline
U+1D7C5 & 𝟅 & {\textbackslash}mbfitsansvartheta & Mathematical Sans-serif Bold Italic Theta Symbol \\
\hline
U+1D7C6 & 𝟆 & {\textbackslash}mbfitsansvarkappa & Mathematical Sans-serif Bold Italic Kappa Symbol \\
\hline
U+1D7C7 & 𝟇 & {\textbackslash}mbfitsansvarphi & Mathematical Sans-serif Bold Italic Phi Symbol \\
\hline
U+1D7C8 & 𝟈 & {\textbackslash}mbfitsansvarrho & Mathematical Sans-serif Bold Italic Rho Symbol \\
\hline
U+1D7C9 & 𝟉 & {\textbackslash}mbfitsansvarpi & Mathematical Sans-serif Bold Italic Pi Symbol \\
\hline
U+1D7CA & 𝟊 & {\textbackslash}mbfDigamma & Mathematical Bold Capital Digamma \\
\hline
U+1D7CB & 𝟋 & {\textbackslash}mbfdigamma & Mathematical Bold Small Digamma \\
\hline
U+1D7CE & 𝟎 & {\textbackslash}mbfzero & Mathematical Bold Digit Zero \\
\hline
U+1D7CF & 𝟏 & {\textbackslash}mbfone & Mathematical Bold Digit One \\
\hline
U+1D7D0 & 𝟐 & {\textbackslash}mbftwo & Mathematical Bold Digit Two \\
\hline
U+1D7D1 & 𝟑 & {\textbackslash}mbfthree & Mathematical Bold Digit Three \\
\hline
U+1D7D2 & 𝟒 & {\textbackslash}mbffour & Mathematical Bold Digit Four \\
\hline
U+1D7D3 & 𝟓 & {\textbackslash}mbffive & Mathematical Bold Digit Five \\
\hline
U+1D7D4 & 𝟔 & {\textbackslash}mbfsix & Mathematical Bold Digit Six \\
\hline
U+1D7D5 & 𝟕 & {\textbackslash}mbfseven & Mathematical Bold Digit Seven \\
\hline
U+1D7D6 & 𝟖 & {\textbackslash}mbfeight & Mathematical Bold Digit Eight \\
\hline
U+1D7D7 & 𝟗 & {\textbackslash}mbfnine & Mathematical Bold Digit Nine \\
\hline
U+1D7D8 & 𝟘 & {\textbackslash}Bbbzero & Mathematical Double-struck Digit Zero \\
\hline
U+1D7D9 & 𝟙 & {\textbackslash}Bbbone & Mathematical Double-struck Digit One \\
\hline
U+1D7DA & 𝟚 & {\textbackslash}Bbbtwo & Mathematical Double-struck Digit Two \\
\hline
U+1D7DB & 𝟛 & {\textbackslash}Bbbthree & Mathematical Double-struck Digit Three \\
\hline
U+1D7DC & 𝟜 & {\textbackslash}Bbbfour & Mathematical Double-struck Digit Four \\
\hline
U+1D7DD & 𝟝 & {\textbackslash}Bbbfive & Mathematical Double-struck Digit Five \\
\hline
U+1D7DE & 𝟞 & {\textbackslash}Bbbsix & Mathematical Double-struck Digit Six \\
\hline
U+1D7DF & 𝟟 & {\textbackslash}Bbbseven & Mathematical Double-struck Digit Seven \\
\hline
U+1D7E0 & 𝟠 & {\textbackslash}Bbbeight & Mathematical Double-struck Digit Eight \\
\hline
U+1D7E1 & 𝟡 & {\textbackslash}Bbbnine & Mathematical Double-struck Digit Nine \\
\hline
U+1D7E2 & 𝟢 & {\textbackslash}msanszero & Mathematical Sans-serif Digit Zero \\
\hline
U+1D7E3 & 𝟣 & {\textbackslash}msansone & Mathematical Sans-serif Digit One \\
\hline
U+1D7E4 & 𝟤 & {\textbackslash}msanstwo & Mathematical Sans-serif Digit Two \\
\hline
U+1D7E5 & 𝟥 & {\textbackslash}msansthree & Mathematical Sans-serif Digit Three \\
\hline
U+1D7E6 & 𝟦 & {\textbackslash}msansfour & Mathematical Sans-serif Digit Four \\
\hline
U+1D7E7 & 𝟧 & {\textbackslash}msansfive & Mathematical Sans-serif Digit Five \\
\hline
U+1D7E8 & 𝟨 & {\textbackslash}msanssix & Mathematical Sans-serif Digit Six \\
\hline
U+1D7E9 & 𝟩 & {\textbackslash}msansseven & Mathematical Sans-serif Digit Seven \\
\hline
U+1D7EA & 𝟪 & {\textbackslash}msanseight & Mathematical Sans-serif Digit Eight \\
\hline
U+1D7EB & 𝟫 & {\textbackslash}msansnine & Mathematical Sans-serif Digit Nine \\
\hline
U+1D7EC & 𝟬 & {\textbackslash}mbfsanszero & Mathematical Sans-serif Bold Digit Zero \\
\hline
U+1D7ED & 𝟭 & {\textbackslash}mbfsansone & Mathematical Sans-serif Bold Digit One \\
\hline
U+1D7EE & 𝟮 & {\textbackslash}mbfsanstwo & Mathematical Sans-serif Bold Digit Two \\
\hline
U+1D7EF & 𝟯 & {\textbackslash}mbfsansthree & Mathematical Sans-serif Bold Digit Three \\
\hline
U+1D7F0 & 𝟰 & {\textbackslash}mbfsansfour & Mathematical Sans-serif Bold Digit Four \\
\hline
U+1D7F1 & 𝟱 & {\textbackslash}mbfsansfive & Mathematical Sans-serif Bold Digit Five \\
\hline
U+1D7F2 & 𝟲 & {\textbackslash}mbfsanssix & Mathematical Sans-serif Bold Digit Six \\
\hline
U+1D7F3 & 𝟳 & {\textbackslash}mbfsansseven & Mathematical Sans-serif Bold Digit Seven \\
\hline
U+1D7F4 & 𝟴 & {\textbackslash}mbfsanseight & Mathematical Sans-serif Bold Digit Eight \\
\hline
U+1D7F5 & 𝟵 & {\textbackslash}mbfsansnine & Mathematical Sans-serif Bold Digit Nine \\
\hline
U+1D7F6 & 𝟶 & {\textbackslash}mttzero & Mathematical Monospace Digit Zero \\
\hline
U+1D7F7 & 𝟷 & {\textbackslash}mttone & Mathematical Monospace Digit One \\
\hline
U+1D7F8 & 𝟸 & {\textbackslash}mtttwo & Mathematical Monospace Digit Two \\
\hline
U+1D7F9 & 𝟹 & {\textbackslash}mttthree & Mathematical Monospace Digit Three \\
\hline
U+1D7FA & 𝟺 & {\textbackslash}mttfour & Mathematical Monospace Digit Four \\
\hline
U+1D7FB & 𝟻 & {\textbackslash}mttfive & Mathematical Monospace Digit Five \\
\hline
U+1D7FC & 𝟼 & {\textbackslash}mttsix & Mathematical Monospace Digit Six \\
\hline
U+1D7FD & 𝟽 & {\textbackslash}mttseven & Mathematical Monospace Digit Seven \\
\hline
U+1D7FE & 𝟾 & {\textbackslash}mtteight & Mathematical Monospace Digit Eight \\
\hline
U+1D7FF & 𝟿 & {\textbackslash}mttnine & Mathematical Monospace Digit Nine \\
\hline
U+1F004 & 🀄 & {\textbackslash}:mahjong: & Mahjong Tile Red Dragon \\
\hline
U+1F0CF & 🃏 & {\textbackslash}:black\_joker: & Playing Card Black Joker \\
\hline
U+1F170 & 🅰 & {\textbackslash}:a: & Negative Squared Latin Capital Letter A \\
\hline
U+1F171 & 🅱 & {\textbackslash}:b: & Negative Squared Latin Capital Letter B \\
\hline
U+1F17E & 🅾 & {\textbackslash}:o2: & Negative Squared Latin Capital Letter O \\
\hline
U+1F17F & 🅿 & {\textbackslash}:parking: & Negative Squared Latin Capital Letter P \\
\hline
U+1F18E & 🆎 & {\textbackslash}:ab: & Negative Squared Ab \\
\hline
U+1F191 & 🆑 & {\textbackslash}:cl: & Squared Cl \\
\hline
U+1F192 & 🆒 & {\textbackslash}:cool: & Squared Cool \\
\hline
U+1F193 & 🆓 & {\textbackslash}:free: & Squared Free \\
\hline
U+1F194 & 🆔 & {\textbackslash}:id: & Squared Id \\
\hline
U+1F195 & 🆕 & {\textbackslash}:new: & Squared New \\
\hline
U+1F196 & 🆖 & {\textbackslash}:ng: & Squared Ng \\
\hline
U+1F197 & 🆗 & {\textbackslash}:ok: & Squared Ok \\
\hline
U+1F198 & 🆘 & {\textbackslash}:sos: & Squared Sos \\
\hline
U+1F199 & 🆙 & {\textbackslash}:up: & Squared Up With Exclamation Mark \\
\hline
U+1F19A & 🆚 & {\textbackslash}:vs: & Squared Vs \\
\hline
U+1F201 & 🈁 & {\textbackslash}:koko: & Squared Katakana Koko \\
\hline
U+1F202 & 🈂 & {\textbackslash}:sa: & Squared Katakana Sa \\
\hline
U+1F21A & 🈚 & {\textbackslash}:u7121: & Squared Cjk Unified Ideograph-7121 \\
\hline
U+1F22F & 🈯 & {\textbackslash}:u6307: & Squared Cjk Unified Ideograph-6307 \\
\hline
U+1F232 & 🈲 & {\textbackslash}:u7981: & Squared Cjk Unified Ideograph-7981 \\
\hline
U+1F233 & 🈳 & {\textbackslash}:u7a7a: & Squared Cjk Unified Ideograph-7a7a \\
\hline
U+1F234 & 🈴 & {\textbackslash}:u5408: & Squared Cjk Unified Ideograph-5408 \\
\hline
U+1F235 & 🈵 & {\textbackslash}:u6e80: & Squared Cjk Unified Ideograph-6e80 \\
\hline
U+1F236 & 🈶 & {\textbackslash}:u6709: & Squared Cjk Unified Ideograph-6709 \\
\hline
U+1F237 & 🈷 & {\textbackslash}:u6708: & Squared Cjk Unified Ideograph-6708 \\
\hline
U+1F238 & 🈸 & {\textbackslash}:u7533: & Squared Cjk Unified Ideograph-7533 \\
\hline
U+1F239 & 🈹 & {\textbackslash}:u5272: & Squared Cjk Unified Ideograph-5272 \\
\hline
U+1F23A & 🈺 & {\textbackslash}:u55b6: & Squared Cjk Unified Ideograph-55b6 \\
\hline
U+1F250 & 🉐 & {\textbackslash}:ideograph\_advantage: & Circled Ideograph Advantage \\
\hline
U+1F251 & 🉑 & {\textbackslash}:accept: & Circled Ideograph Accept \\
\hline
U+1F300 & 🌀 & {\textbackslash}:cyclone: & Cyclone \\
\hline
U+1F301 & 🌁 & {\textbackslash}:foggy: & Foggy \\
\hline
U+1F302 & 🌂 & {\textbackslash}:closed\_umbrella: & Closed Umbrella \\
\hline
U+1F303 & 🌃 & {\textbackslash}:night\_with\_stars: & Night With Stars \\
\hline
U+1F304 & 🌄 & {\textbackslash}:sunrise\_over\_mountains: & Sunrise Over Mountains \\
\hline
U+1F305 & 🌅 & {\textbackslash}:sunrise: & Sunrise \\
\hline
U+1F306 & 🌆 & {\textbackslash}:city\_sunset: & Cityscape At Dusk \\
\hline
U+1F307 & 🌇 & {\textbackslash}:city\_sunrise: & Sunset Over Buildings \\
\hline
U+1F308 & 🌈 & {\textbackslash}:rainbow: & Rainbow \\
\hline
U+1F309 & 🌉 & {\textbackslash}:bridge\_at\_night: & Bridge At Night \\
\hline
U+1F30A & 🌊 & {\textbackslash}:ocean: & Water Wave \\
\hline
U+1F30B & 🌋 & {\textbackslash}:volcano: & Volcano \\
\hline
U+1F30C & 🌌 & {\textbackslash}:milky\_way: & Milky Way \\
\hline
U+1F30D & 🌍 & {\textbackslash}:earth\_africa: & Earth Globe Europe-africa \\
\hline
U+1F30E & 🌎 & {\textbackslash}:earth\_americas: & Earth Globe Americas \\
\hline
U+1F30F & 🌏 & {\textbackslash}:earth\_asia: & Earth Globe Asia-australia \\
\hline
U+1F310 & 🌐 & {\textbackslash}:globe\_with\_meridians: & Globe With Meridians \\
\hline
U+1F311 & 🌑 & {\textbackslash}:new\_moon: & New Moon Symbol \\
\hline
U+1F312 & 🌒 & {\textbackslash}:waxing\_crescent\_moon: & Waxing Crescent Moon Symbol \\
\hline
U+1F313 & 🌓 & {\textbackslash}:first\_quarter\_moon: & First Quarter Moon Symbol \\
\hline
U+1F314 & 🌔 & {\textbackslash}:moon: & Waxing Gibbous Moon Symbol \\
\hline
U+1F315 & 🌕 & {\textbackslash}:full\_moon: & Full Moon Symbol \\
\hline
U+1F316 & 🌖 & {\textbackslash}:waning\_gibbous\_moon: & Waning Gibbous Moon Symbol \\
\hline
U+1F317 & 🌗 & {\textbackslash}:last\_quarter\_moon: & Last Quarter Moon Symbol \\
\hline
U+1F318 & 🌘 & {\textbackslash}:waning\_crescent\_moon: & Waning Crescent Moon Symbol \\
\hline
U+1F319 & 🌙 & {\textbackslash}:crescent\_moon: & Crescent Moon \\
\hline
U+1F31A & 🌚 & {\textbackslash}:new\_moon\_with\_face: & New Moon With Face \\
\hline
U+1F31B & 🌛 & {\textbackslash}:first\_quarter\_moon\_with\_face: & First Quarter Moon With Face \\
\hline
U+1F31C & 🌜 & {\textbackslash}:last\_quarter\_moon\_with\_face: & Last Quarter Moon With Face \\
\hline
U+1F31D & 🌝 & {\textbackslash}:full\_moon\_with\_face: & Full Moon With Face \\
\hline
U+1F31E & 🌞 & {\textbackslash}:sun\_with\_face: & Sun With Face \\
\hline
U+1F31F & 🌟 & {\textbackslash}:star2: & Glowing Star \\
\hline
U+1F320 & 🌠 & {\textbackslash}:stars: & Shooting Star \\
\hline
U+1F330 & 🌰 & {\textbackslash}:chestnut: & Chestnut \\
\hline
U+1F331 & 🌱 & {\textbackslash}:seedling: & Seedling \\
\hline
U+1F332 & 🌲 & {\textbackslash}:evergreen\_tree: & Evergreen Tree \\
\hline
U+1F333 & 🌳 & {\textbackslash}:deciduous\_tree: & Deciduous Tree \\
\hline
U+1F334 & 🌴 & {\textbackslash}:palm\_tree: & Palm Tree \\
\hline
U+1F335 & 🌵 & {\textbackslash}:cactus: & Cactus \\
\hline
U+1F337 & 🌷 & {\textbackslash}:tulip: & Tulip \\
\hline
U+1F338 & 🌸 & {\textbackslash}:cherry\_blossom: & Cherry Blossom \\
\hline
U+1F339 & 🌹 & {\textbackslash}:rose: & Rose \\
\hline
U+1F33A & 🌺 & {\textbackslash}:hibiscus: & Hibiscus \\
\hline
U+1F33B & 🌻 & {\textbackslash}:sunflower: & Sunflower \\
\hline
U+1F33C & 🌼 & {\textbackslash}:blossom: & Blossom \\
\hline
U+1F33D & 🌽 & {\textbackslash}:corn: & Ear Of Maize \\
\hline
U+1F33E & 🌾 & {\textbackslash}:ear\_of\_rice: & Ear Of Rice \\
\hline
U+1F33F & 🌿 & {\textbackslash}:herb: & Herb \\
\hline
U+1F340 & 🍀 & {\textbackslash}:four\_leaf\_clover: & Four Leaf Clover \\
\hline
U+1F341 & 🍁 & {\textbackslash}:maple\_leaf: & Maple Leaf \\
\hline
U+1F342 & 🍂 & {\textbackslash}:fallen\_leaf: & Fallen Leaf \\
\hline
U+1F343 & 🍃 & {\textbackslash}:leaves: & Leaf Fluttering In Wind \\
\hline
U+1F344 & 🍄 & {\textbackslash}:mushroom: & Mushroom \\
\hline
U+1F345 & 🍅 & {\textbackslash}:tomato: & Tomato \\
\hline
U+1F346 & 🍆 & {\textbackslash}:eggplant: & Aubergine \\
\hline
U+1F347 & 🍇 & {\textbackslash}:grapes: & Grapes \\
\hline
U+1F348 & 🍈 & {\textbackslash}:melon: & Melon \\
\hline
U+1F349 & 🍉 & {\textbackslash}:watermelon: & Watermelon \\
\hline
U+1F34A & 🍊 & {\textbackslash}:tangerine: & Tangerine \\
\hline
U+1F34B & 🍋 & {\textbackslash}:lemon: & Lemon \\
\hline
U+1F34C & 🍌 & {\textbackslash}:banana: & Banana \\
\hline
U+1F34D & 🍍 & {\textbackslash}:pineapple: & Pineapple \\
\hline
U+1F34E & 🍎 & {\textbackslash}:apple: & Red Apple \\
\hline
U+1F34F & 🍏 & {\textbackslash}:green\_apple: & Green Apple \\
\hline
U+1F350 & 🍐 & {\textbackslash}:pear: & Pear \\
\hline
U+1F351 & 🍑 & {\textbackslash}:peach: & Peach \\
\hline
U+1F352 & 🍒 & {\textbackslash}:cherries: & Cherries \\
\hline
U+1F353 & 🍓 & {\textbackslash}:strawberry: & Strawberry \\
\hline
U+1F354 & 🍔 & {\textbackslash}:hamburger: & Hamburger \\
\hline
U+1F355 & 🍕 & {\textbackslash}:pizza: & Slice Of Pizza \\
\hline
U+1F356 & 🍖 & {\textbackslash}:meat\_on\_bone: & Meat On Bone \\
\hline
U+1F357 & 🍗 & {\textbackslash}:poultry\_leg: & Poultry Leg \\
\hline
U+1F358 & 🍘 & {\textbackslash}:rice\_cracker: & Rice Cracker \\
\hline
U+1F359 & 🍙 & {\textbackslash}:rice\_ball: & Rice Ball \\
\hline
U+1F35A & 🍚 & {\textbackslash}:rice: & Cooked Rice \\
\hline
U+1F35B & 🍛 & {\textbackslash}:curry: & Curry And Rice \\
\hline
U+1F35C & 🍜 & {\textbackslash}:ramen: & Steaming Bowl \\
\hline
U+1F35D & 🍝 & {\textbackslash}:spaghetti: & Spaghetti \\
\hline
U+1F35E & 🍞 & {\textbackslash}:bread: & Bread \\
\hline
U+1F35F & 🍟 & {\textbackslash}:fries: & French Fries \\
\hline
U+1F360 & 🍠 & {\textbackslash}:sweet\_potato: & Roasted Sweet Potato \\
\hline
U+1F361 & 🍡 & {\textbackslash}:dango: & Dango \\
\hline
U+1F362 & 🍢 & {\textbackslash}:oden: & Oden \\
\hline
U+1F363 & 🍣 & {\textbackslash}:sushi: & Sushi \\
\hline
U+1F364 & 🍤 & {\textbackslash}:fried\_shrimp: & Fried Shrimp \\
\hline
U+1F365 & 🍥 & {\textbackslash}:fish\_cake: & Fish Cake With Swirl Design \\
\hline
U+1F366 & 🍦 & {\textbackslash}:icecream: & Soft Ice Cream \\
\hline
U+1F367 & 🍧 & {\textbackslash}:shaved\_ice: & Shaved Ice \\
\hline
U+1F368 & 🍨 & {\textbackslash}:ice\_cream: & Ice Cream \\
\hline
U+1F369 & 🍩 & {\textbackslash}:doughnut: & Doughnut \\
\hline
U+1F36A & 🍪 & {\textbackslash}:cookie: & Cookie \\
\hline
U+1F36B & 🍫 & {\textbackslash}:chocolate\_bar: & Chocolate Bar \\
\hline
U+1F36C & 🍬 & {\textbackslash}:candy: & Candy \\
\hline
U+1F36D & 🍭 & {\textbackslash}:lollipop: & Lollipop \\
\hline
U+1F36E & 🍮 & {\textbackslash}:custard: & Custard \\
\hline
U+1F36F & 🍯 & {\textbackslash}:honey\_pot: & Honey Pot \\
\hline
U+1F370 & 🍰 & {\textbackslash}:cake: & Shortcake \\
\hline
U+1F371 & 🍱 & {\textbackslash}:bento: & Bento Box \\
\hline
U+1F372 & 🍲 & {\textbackslash}:stew: & Pot Of Food \\
\hline
U+1F373 & 🍳 & {\textbackslash}:egg: & Cooking \\
\hline
U+1F374 & 🍴 & {\textbackslash}:fork\_and\_knife: & Fork And Knife \\
\hline
U+1F375 & 🍵 & {\textbackslash}:tea: & Teacup Without Handle \\
\hline
U+1F376 & 🍶 & {\textbackslash}:sake: & Sake Bottle And Cup \\
\hline
U+1F377 & 🍷 & {\textbackslash}:wine\_glass: & Wine Glass \\
\hline
U+1F378 & 🍸 & {\textbackslash}:cocktail: & Cocktail Glass \\
\hline
U+1F379 & 🍹 & {\textbackslash}:tropical\_drink: & Tropical Drink \\
\hline
U+1F37A & 🍺 & {\textbackslash}:beer: & Beer Mug \\
\hline
U+1F37B & 🍻 & {\textbackslash}:beers: & Clinking Beer Mugs \\
\hline
U+1F37C & 🍼 & {\textbackslash}:baby\_bottle: & Baby Bottle \\
\hline
U+1F380 & 🎀 & {\textbackslash}:ribbon: & Ribbon \\
\hline
U+1F381 & 🎁 & {\textbackslash}:gift: & Wrapped Present \\
\hline
U+1F382 & 🎂 & {\textbackslash}:birthday: & Birthday Cake \\
\hline
U+1F383 & 🎃 & {\textbackslash}:jack\_o\_lantern: & Jack-o-lantern \\
\hline
U+1F384 & 🎄 & {\textbackslash}:christmas\_tree: & Christmas Tree \\
\hline
U+1F385 & 🎅 & {\textbackslash}:santa: & Father Christmas \\
\hline
U+1F386 & 🎆 & {\textbackslash}:fireworks: & Fireworks \\
\hline
U+1F387 & 🎇 & {\textbackslash}:sparkler: & Firework Sparkler \\
\hline
U+1F388 & 🎈 & {\textbackslash}:balloon: & Balloon \\
\hline
U+1F389 & 🎉 & {\textbackslash}:tada: & Party Popper \\
\hline
U+1F38A & 🎊 & {\textbackslash}:confetti\_ball: & Confetti Ball \\
\hline
U+1F38B & 🎋 & {\textbackslash}:tanabata\_tree: & Tanabata Tree \\
\hline
U+1F38C & 🎌 & {\textbackslash}:crossed\_flags: & Crossed Flags \\
\hline
U+1F38D & 🎍 & {\textbackslash}:bamboo: & Pine Decoration \\
\hline
U+1F38E & 🎎 & {\textbackslash}:dolls: & Japanese Dolls \\
\hline
U+1F38F & 🎏 & {\textbackslash}:flags: & Carp Streamer \\
\hline
U+1F390 & 🎐 & {\textbackslash}:wind\_chime: & Wind Chime \\
\hline
U+1F391 & 🎑 & {\textbackslash}:rice\_scene: & Moon Viewing Ceremony \\
\hline
U+1F392 & 🎒 & {\textbackslash}:school\_satchel: & School Satchel \\
\hline
U+1F393 & 🎓 & {\textbackslash}:mortar\_board: & Graduation Cap \\
\hline
U+1F3A0 & 🎠 & {\textbackslash}:carousel\_horse: & Carousel Horse \\
\hline
U+1F3A1 & 🎡 & {\textbackslash}:ferris\_wheel: & Ferris Wheel \\
\hline
U+1F3A2 & 🎢 & {\textbackslash}:roller\_coaster: & Roller Coaster \\
\hline
U+1F3A3 & 🎣 & {\textbackslash}:fishing\_pole\_and\_fish: & Fishing Pole And Fish \\
\hline
U+1F3A4 & 🎤 & {\textbackslash}:microphone: & Microphone \\
\hline
U+1F3A5 & 🎥 & {\textbackslash}:movie\_camera: & Movie Camera \\
\hline
U+1F3A6 & 🎦 & {\textbackslash}:cinema: & Cinema \\
\hline
U+1F3A7 & 🎧 & {\textbackslash}:headphones: & Headphone \\
\hline
U+1F3A8 & 🎨 & {\textbackslash}:art: & Artist Palette \\
\hline
U+1F3A9 & 🎩 & {\textbackslash}:tophat: & Top Hat \\
\hline
U+1F3AA & 🎪 & {\textbackslash}:circus\_tent: & Circus Tent \\
\hline
U+1F3AB & 🎫 & {\textbackslash}:ticket: & Ticket \\
\hline
U+1F3AC & 🎬 & {\textbackslash}:clapper: & Clapper Board \\
\hline
U+1F3AD & 🎭 & {\textbackslash}:performing\_arts: & Performing Arts \\
\hline
U+1F3AE & 🎮 & {\textbackslash}:video\_game: & Video Game \\
\hline
U+1F3AF & 🎯 & {\textbackslash}:dart: & Direct Hit \\
\hline
U+1F3B0 & 🎰 & {\textbackslash}:slot\_machine: & Slot Machine \\
\hline
U+1F3B1 & 🎱 & {\textbackslash}:8ball: & Billiards \\
\hline
U+1F3B2 & 🎲 & {\textbackslash}:game\_die: & Game Die \\
\hline
U+1F3B3 & 🎳 & {\textbackslash}:bowling: & Bowling \\
\hline
U+1F3B4 & 🎴 & {\textbackslash}:flower\_playing\_cards: & Flower Playing Cards \\
\hline
U+1F3B5 & 🎵 & {\textbackslash}:musical\_note: & Musical Note \\
\hline
U+1F3B6 & 🎶 & {\textbackslash}:notes: & Multiple Musical Notes \\
\hline
U+1F3B7 & 🎷 & {\textbackslash}:saxophone: & Saxophone \\
\hline
U+1F3B8 & 🎸 & {\textbackslash}:guitar: & Guitar \\
\hline
U+1F3B9 & 🎹 & {\textbackslash}:musical\_keyboard: & Musical Keyboard \\
\hline
U+1F3BA & 🎺 & {\textbackslash}:trumpet: & Trumpet \\
\hline
U+1F3BB & 🎻 & {\textbackslash}:violin: & Violin \\
\hline
U+1F3BC & 🎼 & {\textbackslash}:musical\_score: & Musical Score \\
\hline
U+1F3BD & 🎽 & {\textbackslash}:running\_shirt\_with\_sash: & Running Shirt With Sash \\
\hline
U+1F3BE & 🎾 & {\textbackslash}:tennis: & Tennis Racquet And Ball \\
\hline
U+1F3BF & 🎿 & {\textbackslash}:ski: & Ski And Ski Boot \\
\hline
U+1F3C0 & 🏀 & {\textbackslash}:basketball: & Basketball And Hoop \\
\hline
U+1F3C1 & 🏁 & {\textbackslash}:checkered\_flag: & Chequered Flag \\
\hline
U+1F3C2 & 🏂 & {\textbackslash}:snowboarder: & Snowboarder \\
\hline
U+1F3C3 & 🏃 & {\textbackslash}:runner: & Runner \\
\hline
U+1F3C4 & 🏄 & {\textbackslash}:surfer: & Surfer \\
\hline
U+1F3C6 & 🏆 & {\textbackslash}:trophy: & Trophy \\
\hline
U+1F3C7 & 🏇 & {\textbackslash}:horse\_racing: & Horse Racing \\
\hline
U+1F3C8 & 🏈 & {\textbackslash}:football: & American Football \\
\hline
U+1F3C9 & 🏉 & {\textbackslash}:rugby\_football: & Rugby Football \\
\hline
U+1F3CA & 🏊 & {\textbackslash}:swimmer: & Swimmer \\
\hline
U+1F3E0 & 🏠 & {\textbackslash}:house: & House Building \\
\hline
U+1F3E1 & 🏡 & {\textbackslash}:house\_with\_garden: & House With Garden \\
\hline
U+1F3E2 & 🏢 & {\textbackslash}:office: & Office Building \\
\hline
U+1F3E3 & 🏣 & {\textbackslash}:post\_office: & Japanese Post Office \\
\hline
U+1F3E4 & 🏤 & {\textbackslash}:european\_post\_office: & European Post Office \\
\hline
U+1F3E5 & 🏥 & {\textbackslash}:hospital: & Hospital \\
\hline
U+1F3E6 & 🏦 & {\textbackslash}:bank: & Bank \\
\hline
U+1F3E7 & 🏧 & {\textbackslash}:atm: & Automated Teller Machine \\
\hline
U+1F3E8 & 🏨 & {\textbackslash}:hotel: & Hotel \\
\hline
U+1F3E9 & 🏩 & {\textbackslash}:love\_hotel: & Love Hotel \\
\hline
U+1F3EA & 🏪 & {\textbackslash}:convenience\_store: & Convenience Store \\
\hline
U+1F3EB & 🏫 & {\textbackslash}:school: & School \\
\hline
U+1F3EC & 🏬 & {\textbackslash}:department\_store: & Department Store \\
\hline
U+1F3ED & 🏭 & {\textbackslash}:factory: & Factory \\
\hline
U+1F3EE & 🏮 & {\textbackslash}:izakaya\_lantern: & Izakaya Lantern \\
\hline
U+1F3EF & 🏯 & {\textbackslash}:japanese\_castle: & Japanese Castle \\
\hline
U+1F3F0 & 🏰 & {\textbackslash}:european\_castle: & European Castle \\
\hline
U+1F3FB & 🏻 & {\textbackslash}:skin-tone-2: & Emoji Modifier Fitzpatrick Type-1-2 \\
\hline
U+1F3FC & 🏼 & {\textbackslash}:skin-tone-3: & Emoji Modifier Fitzpatrick Type-3 \\
\hline
U+1F3FD & 🏽 & {\textbackslash}:skin-tone-4: & Emoji Modifier Fitzpatrick Type-4 \\
\hline
U+1F3FE & 🏾 & {\textbackslash}:skin-tone-5: & Emoji Modifier Fitzpatrick Type-5 \\
\hline
U+1F3FF & 🏿 & {\textbackslash}:skin-tone-6: & Emoji Modifier Fitzpatrick Type-6 \\
\hline
U+1F400 & 🐀 & {\textbackslash}:rat: & Rat \\
\hline
U+1F401 & 🐁 & {\textbackslash}:mouse2: & Mouse \\
\hline
U+1F402 & 🐂 & {\textbackslash}:ox: & Ox \\
\hline
U+1F403 & 🐃 & {\textbackslash}:water\_buffalo: & Water Buffalo \\
\hline
U+1F404 & 🐄 & {\textbackslash}:cow2: & Cow \\
\hline
U+1F405 & 🐅 & {\textbackslash}:tiger2: & Tiger \\
\hline
U+1F406 & 🐆 & {\textbackslash}:leopard: & Leopard \\
\hline
U+1F407 & 🐇 & {\textbackslash}:rabbit2: & Rabbit \\
\hline
U+1F408 & 🐈 & {\textbackslash}:cat2: & Cat \\
\hline
U+1F409 & 🐉 & {\textbackslash}:dragon: & Dragon \\
\hline
U+1F40A & 🐊 & {\textbackslash}:crocodile: & Crocodile \\
\hline
U+1F40B & 🐋 & {\textbackslash}:whale2: & Whale \\
\hline
U+1F40C & 🐌 & {\textbackslash}:snail: & Snail \\
\hline
U+1F40D & 🐍 & {\textbackslash}:snake: & Snake \\
\hline
U+1F40E & 🐎 & {\textbackslash}:racehorse: & Horse \\
\hline
U+1F40F & 🐏 & {\textbackslash}:ram: & Ram \\
\hline
U+1F410 & 🐐 & {\textbackslash}:goat: & Goat \\
\hline
U+1F411 & 🐑 & {\textbackslash}:sheep: & Sheep \\
\hline
U+1F412 & 🐒 & {\textbackslash}:monkey: & Monkey \\
\hline
U+1F413 & 🐓 & {\textbackslash}:rooster: & Rooster \\
\hline
U+1F414 & 🐔 & {\textbackslash}:chicken: & Chicken \\
\hline
U+1F415 & 🐕 & {\textbackslash}:dog2: & Dog \\
\hline
U+1F416 & 🐖 & {\textbackslash}:pig2: & Pig \\
\hline
U+1F417 & 🐗 & {\textbackslash}:boar: & Boar \\
\hline
U+1F418 & 🐘 & {\textbackslash}:elephant: & Elephant \\
\hline
U+1F419 & 🐙 & {\textbackslash}:octopus: & Octopus \\
\hline
U+1F41A & 🐚 & {\textbackslash}:shell: & Spiral Shell \\
\hline
U+1F41B & 🐛 & {\textbackslash}:bug: & Bug \\
\hline
U+1F41C & 🐜 & {\textbackslash}:ant: & Ant \\
\hline
U+1F41D & 🐝 & {\textbackslash}:bee: & Honeybee \\
\hline
U+1F41E & 🐞 & {\textbackslash}:beetle: & Lady Beetle \\
\hline
U+1F41F & 🐟 & {\textbackslash}:fish: & Fish \\
\hline
U+1F420 & 🐠 & {\textbackslash}:tropical\_fish: & Tropical Fish \\
\hline
U+1F421 & 🐡 & {\textbackslash}:blowfish: & Blowfish \\
\hline
U+1F422 & 🐢 & {\textbackslash}:turtle: & Turtle \\
\hline
U+1F423 & 🐣 & {\textbackslash}:hatching\_chick: & Hatching Chick \\
\hline
U+1F424 & 🐤 & {\textbackslash}:baby\_chick: & Baby Chick \\
\hline
U+1F425 & 🐥 & {\textbackslash}:hatched\_chick: & Front-facing Baby Chick \\
\hline
U+1F426 & 🐦 & {\textbackslash}:bird: & Bird \\
\hline
U+1F427 & 🐧 & {\textbackslash}:penguin: & Penguin \\
\hline
U+1F428 & 🐨 & {\textbackslash}:koala: & Koala \\
\hline
U+1F429 & 🐩 & {\textbackslash}:poodle: & Poodle \\
\hline
U+1F42A & 🐪 & {\textbackslash}:dromedary\_camel: & Dromedary Camel \\
\hline
U+1F42B & 🐫 & {\textbackslash}:camel: & Bactrian Camel \\
\hline
U+1F42C & 🐬 & {\textbackslash}:dolphin: & Dolphin \\
\hline
U+1F42D & 🐭 & {\textbackslash}:mouse: & Mouse Face \\
\hline
U+1F42E & 🐮 & {\textbackslash}:cow: & Cow Face \\
\hline
U+1F42F & 🐯 & {\textbackslash}:tiger: & Tiger Face \\
\hline
U+1F430 & 🐰 & {\textbackslash}:rabbit: & Rabbit Face \\
\hline
U+1F431 & 🐱 & {\textbackslash}:cat: & Cat Face \\
\hline
U+1F432 & 🐲 & {\textbackslash}:dragon\_face: & Dragon Face \\
\hline
U+1F433 & 🐳 & {\textbackslash}:whale: & Spouting Whale \\
\hline
U+1F434 & 🐴 & {\textbackslash}:horse: & Horse Face \\
\hline
U+1F435 & 🐵 & {\textbackslash}:monkey\_face: & Monkey Face \\
\hline
U+1F436 & 🐶 & {\textbackslash}:dog: & Dog Face \\
\hline
U+1F437 & 🐷 & {\textbackslash}:pig: & Pig Face \\
\hline
U+1F438 & 🐸 & {\textbackslash}:frog: & Frog Face \\
\hline
U+1F439 & 🐹 & {\textbackslash}:hamster: & Hamster Face \\
\hline
U+1F43A & 🐺 & {\textbackslash}:wolf: & Wolf Face \\
\hline
U+1F43B & 🐻 & {\textbackslash}:bear: & Bear Face \\
\hline
U+1F43C & 🐼 & {\textbackslash}:panda\_face: & Panda Face \\
\hline
U+1F43D & 🐽 & {\textbackslash}:pig\_nose: & Pig Nose \\
\hline
U+1F43E & 🐾 & {\textbackslash}:feet: & Paw Prints \\
\hline
U+1F440 & 👀 & {\textbackslash}:eyes: & Eyes \\
\hline
U+1F442 & 👂 & {\textbackslash}:ear: & Ear \\
\hline
U+1F443 & 👃 & {\textbackslash}:nose: & Nose \\
\hline
U+1F444 & 👄 & {\textbackslash}:lips: & Mouth \\
\hline
U+1F445 & 👅 & {\textbackslash}:tongue: & Tongue \\
\hline
U+1F446 & 👆 & {\textbackslash}:point\_up\_2: & White Up Pointing Backhand Index \\
\hline
U+1F447 & 👇 & {\textbackslash}:point\_down: & White Down Pointing Backhand Index \\
\hline
U+1F448 & 👈 & {\textbackslash}:point\_left: & White Left Pointing Backhand Index \\
\hline
U+1F449 & 👉 & {\textbackslash}:point\_right: & White Right Pointing Backhand Index \\
\hline
U+1F44A & 👊 & {\textbackslash}:facepunch: & Fisted Hand Sign \\
\hline
U+1F44B & 👋 & {\textbackslash}:wave: & Waving Hand Sign \\
\hline
U+1F44C & 👌 & {\textbackslash}:ok\_hand: & Ok Hand Sign \\
\hline
U+1F44D & 👍 & {\textbackslash}:+1: & Thumbs Up Sign \\
\hline
U+1F44E & 👎 & {\textbackslash}:-1: & Thumbs Down Sign \\
\hline
U+1F44F & 👏 & {\textbackslash}:clap: & Clapping Hands Sign \\
\hline
U+1F450 & 👐 & {\textbackslash}:open\_hands: & Open Hands Sign \\
\hline
U+1F451 & 👑 & {\textbackslash}:crown: & Crown \\
\hline
U+1F452 & 👒 & {\textbackslash}:womans\_hat: & Womans Hat \\
\hline
U+1F453 & 👓 & {\textbackslash}:eyeglasses: & Eyeglasses \\
\hline
U+1F454 & 👔 & {\textbackslash}:necktie: & Necktie \\
\hline
U+1F455 & 👕 & {\textbackslash}:shirt: & T-shirt \\
\hline
U+1F456 & 👖 & {\textbackslash}:jeans: & Jeans \\
\hline
U+1F457 & 👗 & {\textbackslash}:dress: & Dress \\
\hline
U+1F458 & 👘 & {\textbackslash}:kimono: & Kimono \\
\hline
U+1F459 & 👙 & {\textbackslash}:bikini: & Bikini \\
\hline
U+1F45A & 👚 & {\textbackslash}:womans\_clothes: & Womans Clothes \\
\hline
U+1F45B & 👛 & {\textbackslash}:purse: & Purse \\
\hline
U+1F45C & 👜 & {\textbackslash}:handbag: & Handbag \\
\hline
U+1F45D & 👝 & {\textbackslash}:pouch: & Pouch \\
\hline
U+1F45E & 👞 & {\textbackslash}:mans\_shoe: & Mans Shoe \\
\hline
U+1F45F & 👟 & {\textbackslash}:athletic\_shoe: & Athletic Shoe \\
\hline
U+1F460 & 👠 & {\textbackslash}:high\_heel: & High-heeled Shoe \\
\hline
U+1F461 & 👡 & {\textbackslash}:sandal: & Womans Sandal \\
\hline
U+1F462 & 👢 & {\textbackslash}:boot: & Womans Boots \\
\hline
U+1F463 & 👣 & {\textbackslash}:footprints: & Footprints \\
\hline
U+1F464 & 👤 & {\textbackslash}:bust\_in\_silhouette: & Bust In Silhouette \\
\hline
U+1F465 & 👥 & {\textbackslash}:busts\_in\_silhouette: & Busts In Silhouette \\
\hline
U+1F466 & 👦 & {\textbackslash}:boy: & Boy \\
\hline
U+1F467 & 👧 & {\textbackslash}:girl: & Girl \\
\hline
U+1F468 & 👨 & {\textbackslash}:man: & Man \\
\hline
U+1F469 & 👩 & {\textbackslash}:woman: & Woman \\
\hline
U+1F46A & 👪 & {\textbackslash}:family: & Family \\
\hline
U+1F46B & 👫 & {\textbackslash}:couple: & Man And Woman Holding Hands \\
\hline
U+1F46C & 👬 & {\textbackslash}:two\_men\_holding\_hands: & Two Men Holding Hands \\
\hline
U+1F46D & 👭 & {\textbackslash}:two\_women\_holding\_hands: & Two Women Holding Hands \\
\hline
U+1F46E & 👮 & {\textbackslash}:cop: & Police Officer \\
\hline
U+1F46F & 👯 & {\textbackslash}:dancers: & Woman With Bunny Ears \\
\hline
U+1F470 & 👰 & {\textbackslash}:bride\_with\_veil: & Bride With Veil \\
\hline
U+1F471 & 👱 & {\textbackslash}:person\_with\_blond\_hair: & Person With Blond Hair \\
\hline
U+1F472 & 👲 & {\textbackslash}:man\_with\_gua\_pi\_mao: & Man With Gua Pi Mao \\
\hline
U+1F473 & 👳 & {\textbackslash}:man\_with\_turban: & Man With Turban \\
\hline
U+1F474 & 👴 & {\textbackslash}:older\_man: & Older Man \\
\hline
U+1F475 & 👵 & {\textbackslash}:older\_woman: & Older Woman \\
\hline
U+1F476 & 👶 & {\textbackslash}:baby: & Baby \\
\hline
U+1F477 & 👷 & {\textbackslash}:construction\_worker: & Construction Worker \\
\hline
U+1F478 & 👸 & {\textbackslash}:princess: & Princess \\
\hline
U+1F479 & 👹 & {\textbackslash}:japanese\_ogre: & Japanese Ogre \\
\hline
U+1F47A & 👺 & {\textbackslash}:japanese\_goblin: & Japanese Goblin \\
\hline
U+1F47B & 👻 & {\textbackslash}:ghost: & Ghost \\
\hline
U+1F47C & 👼 & {\textbackslash}:angel: & Baby Angel \\
\hline
U+1F47D & 👽 & {\textbackslash}:alien: & Extraterrestrial Alien \\
\hline
U+1F47E & 👾 & {\textbackslash}:space\_invader: & Alien Monster \\
\hline
U+1F47F & 👿 & {\textbackslash}:imp: & Imp \\
\hline
U+1F480 & 💀 & {\textbackslash}:skull: & Skull \\
\hline
U+1F481 & 💁 & {\textbackslash}:information\_desk\_person: & Information Desk Person \\
\hline
U+1F482 & 💂 & {\textbackslash}:guardsman: & Guardsman \\
\hline
U+1F483 & 💃 & {\textbackslash}:dancer: & Dancer \\
\hline
U+1F484 & 💄 & {\textbackslash}:lipstick: & Lipstick \\
\hline
U+1F485 & 💅 & {\textbackslash}:nail\_care: & Nail Polish \\
\hline
U+1F486 & 💆 & {\textbackslash}:massage: & Face Massage \\
\hline
U+1F487 & 💇 & {\textbackslash}:haircut: & Haircut \\
\hline
U+1F488 & 💈 & {\textbackslash}:barber: & Barber Pole \\
\hline
U+1F489 & 💉 & {\textbackslash}:syringe: & Syringe \\
\hline
U+1F48A & 💊 & {\textbackslash}:pill: & Pill \\
\hline
U+1F48B & 💋 & {\textbackslash}:kiss: & Kiss Mark \\
\hline
U+1F48C & 💌 & {\textbackslash}:love\_letter: & Love Letter \\
\hline
U+1F48D & 💍 & {\textbackslash}:ring: & Ring \\
\hline
U+1F48E & 💎 & {\textbackslash}:gem: & Gem Stone \\
\hline
U+1F48F & 💏 & {\textbackslash}:couplekiss: & Kiss \\
\hline
U+1F490 & 💐 & {\textbackslash}:bouquet: & Bouquet \\
\hline
U+1F491 & 💑 & {\textbackslash}:couple\_with\_heart: & Couple With Heart \\
\hline
U+1F492 & 💒 & {\textbackslash}:wedding: & Wedding \\
\hline
U+1F493 & 💓 & {\textbackslash}:heartbeat: & Beating Heart \\
\hline
U+1F494 & 💔 & {\textbackslash}:broken\_heart: & Broken Heart \\
\hline
U+1F495 & 💕 & {\textbackslash}:two\_hearts: & Two Hearts \\
\hline
U+1F496 & 💖 & {\textbackslash}:sparkling\_heart: & Sparkling Heart \\
\hline
U+1F497 & 💗 & {\textbackslash}:heartpulse: & Growing Heart \\
\hline
U+1F498 & 💘 & {\textbackslash}:cupid: & Heart With Arrow \\
\hline
U+1F499 & 💙 & {\textbackslash}:blue\_heart: & Blue Heart \\
\hline
U+1F49A & 💚 & {\textbackslash}:green\_heart: & Green Heart \\
\hline
U+1F49B & 💛 & {\textbackslash}:yellow\_heart: & Yellow Heart \\
\hline
U+1F49C & 💜 & {\textbackslash}:purple\_heart: & Purple Heart \\
\hline
U+1F49D & 💝 & {\textbackslash}:gift\_heart: & Heart With Ribbon \\
\hline
U+1F49E & 💞 & {\textbackslash}:revolving\_hearts: & Revolving Hearts \\
\hline
U+1F49F & 💟 & {\textbackslash}:heart\_decoration: & Heart Decoration \\
\hline
U+1F4A0 & 💠 & {\textbackslash}:diamond\_shape\_with\_a\_dot\_inside: & Diamond Shape With A Dot Inside \\
\hline
U+1F4A1 & 💡 & {\textbackslash}:bulb: & Electric Light Bulb \\
\hline
U+1F4A2 & 💢 & {\textbackslash}:anger: & Anger Symbol \\
\hline
U+1F4A3 & 💣 & {\textbackslash}:bomb: & Bomb \\
\hline
U+1F4A4 & 💤 & {\textbackslash}:zzz: & Sleeping Symbol \\
\hline
U+1F4A5 & 💥 & {\textbackslash}:boom: & Collision Symbol \\
\hline
U+1F4A6 & 💦 & {\textbackslash}:sweat\_drops: & Splashing Sweat Symbol \\
\hline
U+1F4A7 & 💧 & {\textbackslash}:droplet: & Droplet \\
\hline
U+1F4A8 & 💨 & {\textbackslash}:dash: & Dash Symbol \\
\hline
U+1F4A9 & 💩 & {\textbackslash}:hankey: & Pile Of Poo \\
\hline
U+1F4AA & 💪 & {\textbackslash}:muscle: & Flexed Biceps \\
\hline
U+1F4AB & 💫 & {\textbackslash}:dizzy: & Dizzy Symbol \\
\hline
U+1F4AC & 💬 & {\textbackslash}:speech\_balloon: & Speech Balloon \\
\hline
U+1F4AD & 💭 & {\textbackslash}:thought\_balloon: & Thought Balloon \\
\hline
U+1F4AE & 💮 & {\textbackslash}:white\_flower: & White Flower \\
\hline
U+1F4AF & 💯 & {\textbackslash}:100: & Hundred Points Symbol \\
\hline
U+1F4B0 & 💰 & {\textbackslash}:moneybag: & Money Bag \\
\hline
U+1F4B1 & 💱 & {\textbackslash}:currency\_exchange: & Currency Exchange \\
\hline
U+1F4B2 & 💲 & {\textbackslash}:heavy\_dollar\_sign: & Heavy Dollar Sign \\
\hline
U+1F4B3 & 💳 & {\textbackslash}:credit\_card: & Credit Card \\
\hline
U+1F4B4 & 💴 & {\textbackslash}:yen: & Banknote With Yen Sign \\
\hline
U+1F4B5 & 💵 & {\textbackslash}:dollar: & Banknote With Dollar Sign \\
\hline
U+1F4B6 & 💶 & {\textbackslash}:euro: & Banknote With Euro Sign \\
\hline
U+1F4B7 & 💷 & {\textbackslash}:pound: & Banknote With Pound Sign \\
\hline
U+1F4B8 & 💸 & {\textbackslash}:money\_with\_wings: & Money With Wings \\
\hline
U+1F4B9 & 💹 & {\textbackslash}:chart: & Chart With Upwards Trend And Yen Sign \\
\hline
U+1F4BA & 💺 & {\textbackslash}:seat: & Seat \\
\hline
U+1F4BB & 💻 & {\textbackslash}:computer: & Personal Computer \\
\hline
U+1F4BC & 💼 & {\textbackslash}:briefcase: & Briefcase \\
\hline
U+1F4BD & 💽 & {\textbackslash}:minidisc: & Minidisc \\
\hline
U+1F4BE & 💾 & {\textbackslash}:floppy\_disk: & Floppy Disk \\
\hline
U+1F4BF & 💿 & {\textbackslash}:cd: & Optical Disc \\
\hline
U+1F4C0 & 📀 & {\textbackslash}:dvd: & Dvd \\
\hline
U+1F4C1 & 📁 & {\textbackslash}:file\_folder: & File Folder \\
\hline
U+1F4C2 & 📂 & {\textbackslash}:open\_file\_folder: & Open File Folder \\
\hline
U+1F4C3 & 📃 & {\textbackslash}:page\_with\_curl: & Page With Curl \\
\hline
U+1F4C4 & 📄 & {\textbackslash}:page\_facing\_up: & Page Facing Up \\
\hline
U+1F4C5 & 📅 & {\textbackslash}:date: & Calendar \\
\hline
U+1F4C6 & 📆 & {\textbackslash}:calendar: & Tear-off Calendar \\
\hline
U+1F4C7 & 📇 & {\textbackslash}:card\_index: & Card Index \\
\hline
U+1F4C8 & 📈 & {\textbackslash}:chart\_with\_upwards\_trend: & Chart With Upwards Trend \\
\hline
U+1F4C9 & 📉 & {\textbackslash}:chart\_with\_downwards\_trend: & Chart With Downwards Trend \\
\hline
U+1F4CA & 📊 & {\textbackslash}:bar\_chart: & Bar Chart \\
\hline
U+1F4CB & 📋 & {\textbackslash}:clipboard: & Clipboard \\
\hline
U+1F4CC & 📌 & {\textbackslash}:pushpin: & Pushpin \\
\hline
U+1F4CD & 📍 & {\textbackslash}:round\_pushpin: & Round Pushpin \\
\hline
U+1F4CE & 📎 & {\textbackslash}:paperclip: & Paperclip \\
\hline
U+1F4CF & 📏 & {\textbackslash}:straight\_ruler: & Straight Ruler \\
\hline
U+1F4D0 & 📐 & {\textbackslash}:triangular\_ruler: & Triangular Ruler \\
\hline
U+1F4D1 & 📑 & {\textbackslash}:bookmark\_tabs: & Bookmark Tabs \\
\hline
U+1F4D2 & 📒 & {\textbackslash}:ledger: & Ledger \\
\hline
U+1F4D3 & 📓 & {\textbackslash}:notebook: & Notebook \\
\hline
U+1F4D4 & 📔 & {\textbackslash}:notebook\_with\_decorative\_cover: & Notebook With Decorative Cover \\
\hline
U+1F4D5 & 📕 & {\textbackslash}:closed\_book: & Closed Book \\
\hline
U+1F4D6 & 📖 & {\textbackslash}:book: & Open Book \\
\hline
U+1F4D7 & 📗 & {\textbackslash}:green\_book: & Green Book \\
\hline
U+1F4D8 & 📘 & {\textbackslash}:blue\_book: & Blue Book \\
\hline
U+1F4D9 & 📙 & {\textbackslash}:orange\_book: & Orange Book \\
\hline
U+1F4DA & 📚 & {\textbackslash}:books: & Books \\
\hline
U+1F4DB & 📛 & {\textbackslash}:name\_badge: & Name Badge \\
\hline
U+1F4DC & 📜 & {\textbackslash}:scroll: & Scroll \\
\hline
U+1F4DD & 📝 & {\textbackslash}:memo: & Memo \\
\hline
U+1F4DE & 📞 & {\textbackslash}:telephone\_receiver: & Telephone Receiver \\
\hline
U+1F4DF & 📟 & {\textbackslash}:pager: & Pager \\
\hline
U+1F4E0 & 📠 & {\textbackslash}:fax: & Fax Machine \\
\hline
U+1F4E1 & 📡 & {\textbackslash}:satellite: & Satellite Antenna \\
\hline
U+1F4E2 & 📢 & {\textbackslash}:loudspeaker: & Public Address Loudspeaker \\
\hline
U+1F4E3 & 📣 & {\textbackslash}:mega: & Cheering Megaphone \\
\hline
U+1F4E4 & 📤 & {\textbackslash}:outbox\_tray: & Outbox Tray \\
\hline
U+1F4E5 & 📥 & {\textbackslash}:inbox\_tray: & Inbox Tray \\
\hline
U+1F4E6 & 📦 & {\textbackslash}:package: & Package \\
\hline
U+1F4E7 & 📧 & {\textbackslash}:e-mail: & E-mail Symbol \\
\hline
U+1F4E8 & 📨 & {\textbackslash}:incoming\_envelope: & Incoming Envelope \\
\hline
U+1F4E9 & 📩 & {\textbackslash}:envelope\_with\_arrow: & Envelope With Downwards Arrow Above \\
\hline
U+1F4EA & 📪 & {\textbackslash}:mailbox\_closed: & Closed Mailbox With Lowered Flag \\
\hline
U+1F4EB & 📫 & {\textbackslash}:mailbox: & Closed Mailbox With Raised Flag \\
\hline
U+1F4EC & 📬 & {\textbackslash}:mailbox\_with\_mail: & Open Mailbox With Raised Flag \\
\hline
U+1F4ED & 📭 & {\textbackslash}:mailbox\_with\_no\_mail: & Open Mailbox With Lowered Flag \\
\hline
U+1F4EE & 📮 & {\textbackslash}:postbox: & Postbox \\
\hline
U+1F4EF & 📯 & {\textbackslash}:postal\_horn: & Postal Horn \\
\hline
U+1F4F0 & 📰 & {\textbackslash}:newspaper: & Newspaper \\
\hline
U+1F4F1 & 📱 & {\textbackslash}:iphone: & Mobile Phone \\
\hline
U+1F4F2 & 📲 & {\textbackslash}:calling: & Mobile Phone With Rightwards Arrow At Left \\
\hline
U+1F4F3 & 📳 & {\textbackslash}:vibration\_mode: & Vibration Mode \\
\hline
U+1F4F4 & 📴 & {\textbackslash}:mobile\_phone\_off: & Mobile Phone Off \\
\hline
U+1F4F5 & 📵 & {\textbackslash}:no\_mobile\_phones: & No Mobile Phones \\
\hline
U+1F4F6 & 📶 & {\textbackslash}:signal\_strength: & Antenna With Bars \\
\hline
U+1F4F7 & 📷 & {\textbackslash}:camera: & Camera \\
\hline
U+1F4F9 & 📹 & {\textbackslash}:video\_camera: & Video Camera \\
\hline
U+1F4FA & 📺 & {\textbackslash}:tv: & Television \\
\hline
U+1F4FB & 📻 & {\textbackslash}:radio: & Radio \\
\hline
U+1F4FC & 📼 & {\textbackslash}:vhs: & Videocassette \\
\hline
U+1F500 & 🔀 & {\textbackslash}:twisted\_rightwards\_arrows: & Twisted Rightwards Arrows \\
\hline
U+1F501 & 🔁 & {\textbackslash}:repeat: & Clockwise Rightwards And Leftwards Open Circle Arrows \\
\hline
U+1F502 & 🔂 & {\textbackslash}:repeat\_one: & Clockwise Rightwards And Leftwards Open Circle Arrows With Circled One Overlay \\
\hline
U+1F503 & 🔃 & {\textbackslash}:arrows\_clockwise: & Clockwise Downwards And Upwards Open Circle Arrows \\
\hline
U+1F504 & 🔄 & {\textbackslash}:arrows\_counterclockwise: & Anticlockwise Downwards And Upwards Open Circle Arrows \\
\hline
U+1F505 & 🔅 & {\textbackslash}:low\_brightness: & Low Brightness Symbol \\
\hline
U+1F506 & 🔆 & {\textbackslash}:high\_brightness: & High Brightness Symbol \\
\hline
U+1F507 & 🔇 & {\textbackslash}:mute: & Speaker With Cancellation Stroke \\
\hline
U+1F508 & 🔈 & {\textbackslash}:speaker: & Speaker \\
\hline
U+1F509 & 🔉 & {\textbackslash}:sound: & Speaker With One Sound Wave \\
\hline
U+1F50A & 🔊 & {\textbackslash}:loud\_sound: & Speaker With Three Sound Waves \\
\hline
U+1F50B & 🔋 & {\textbackslash}:battery: & Battery \\
\hline
U+1F50C & 🔌 & {\textbackslash}:electric\_plug: & Electric Plug \\
\hline
U+1F50D & 🔍 & {\textbackslash}:mag: & Left-pointing Magnifying Glass \\
\hline
U+1F50E & 🔎 & {\textbackslash}:mag\_right: & Right-pointing Magnifying Glass \\
\hline
U+1F50F & 🔏 & {\textbackslash}:lock\_with\_ink\_pen: & Lock With Ink Pen \\
\hline
U+1F510 & 🔐 & {\textbackslash}:closed\_lock\_with\_key: & Closed Lock With Key \\
\hline
U+1F511 & 🔑 & {\textbackslash}:key: & Key \\
\hline
U+1F512 & 🔒 & {\textbackslash}:lock: & Lock \\
\hline
U+1F513 & 🔓 & {\textbackslash}:unlock: & Open Lock \\
\hline
U+1F514 & 🔔 & {\textbackslash}:bell: & Bell \\
\hline
U+1F515 & 🔕 & {\textbackslash}:no\_bell: & Bell With Cancellation Stroke \\
\hline
U+1F516 & 🔖 & {\textbackslash}:bookmark: & Bookmark \\
\hline
U+1F517 & 🔗 & {\textbackslash}:link: & Link Symbol \\
\hline
U+1F518 & 🔘 & {\textbackslash}:radio\_button: & Radio Button \\
\hline
U+1F519 & 🔙 & {\textbackslash}:back: & Back With Leftwards Arrow Above \\
\hline
U+1F51A & 🔚 & {\textbackslash}:end: & End With Leftwards Arrow Above \\
\hline
U+1F51B & 🔛 & {\textbackslash}:on: & On With Exclamation Mark With Left Right Arrow Above \\
\hline
U+1F51C & 🔜 & {\textbackslash}:soon: & Soon With Rightwards Arrow Above \\
\hline
U+1F51D & 🔝 & {\textbackslash}:top: & Top With Upwards Arrow Above \\
\hline
U+1F51E & 🔞 & {\textbackslash}:underage: & No One Under Eighteen Symbol \\
\hline
U+1F51F & 🔟 & {\textbackslash}:keycap\_ten: & Keycap Ten \\
\hline
U+1F520 & 🔠 & {\textbackslash}:capital\_abcd: & Input Symbol For Latin Capital Letters \\
\hline
U+1F521 & 🔡 & {\textbackslash}:abcd: & Input Symbol For Latin Small Letters \\
\hline
U+1F522 & 🔢 & {\textbackslash}:1234: & Input Symbol For Numbers \\
\hline
U+1F523 & 🔣 & {\textbackslash}:symbols: & Input Symbol For Symbols \\
\hline
U+1F524 & 🔤 & {\textbackslash}:abc: & Input Symbol For Latin Letters \\
\hline
U+1F525 & 🔥 & {\textbackslash}:fire: & Fire \\
\hline
U+1F526 & 🔦 & {\textbackslash}:flashlight: & Electric Torch \\
\hline
U+1F527 & 🔧 & {\textbackslash}:wrench: & Wrench \\
\hline
U+1F528 & 🔨 & {\textbackslash}:hammer: & Hammer \\
\hline
U+1F529 & 🔩 & {\textbackslash}:nut\_and\_bolt: & Nut And Bolt \\
\hline
U+1F52A & 🔪 & {\textbackslash}:hocho: & Hocho \\
\hline
U+1F52B & 🔫 & {\textbackslash}:gun: & Pistol \\
\hline
U+1F52C & 🔬 & {\textbackslash}:microscope: & Microscope \\
\hline
U+1F52D & 🔭 & {\textbackslash}:telescope: & Telescope \\
\hline
U+1F52E & 🔮 & {\textbackslash}:crystal\_ball: & Crystal Ball \\
\hline
U+1F52F & 🔯 & {\textbackslash}:six\_pointed\_star: & Six Pointed Star With Middle Dot \\
\hline
U+1F530 & 🔰 & {\textbackslash}:beginner: & Japanese Symbol For Beginner \\
\hline
U+1F531 & 🔱 & {\textbackslash}:trident: & Trident Emblem \\
\hline
U+1F532 & 🔲 & {\textbackslash}:black\_square\_button: & Black Square Button \\
\hline
U+1F533 & 🔳 & {\textbackslash}:white\_square\_button: & White Square Button \\
\hline
U+1F534 & 🔴 & {\textbackslash}:red\_circle: & Large Red Circle \\
\hline
U+1F535 & 🔵 & {\textbackslash}:large\_blue\_circle: & Large Blue Circle \\
\hline
U+1F536 & 🔶 & {\textbackslash}:large\_orange\_diamond: & Large Orange Diamond \\
\hline
U+1F537 & 🔷 & {\textbackslash}:large\_blue\_diamond: & Large Blue Diamond \\
\hline
U+1F538 & 🔸 & {\textbackslash}:small\_orange\_diamond: & Small Orange Diamond \\
\hline
U+1F539 & 🔹 & {\textbackslash}:small\_blue\_diamond: & Small Blue Diamond \\
\hline
U+1F53A & 🔺 & {\textbackslash}:small\_red\_triangle: & Up-pointing Red Triangle \\
\hline
U+1F53B & 🔻 & {\textbackslash}:small\_red\_triangle\_down: & Down-pointing Red Triangle \\
\hline
U+1F53C & 🔼 & {\textbackslash}:arrow\_up\_small: & Up-pointing Small Red Triangle \\
\hline
U+1F53D & 🔽 & {\textbackslash}:arrow\_down\_small: & Down-pointing Small Red Triangle \\
\hline
U+1F550 & 🕐 & {\textbackslash}:clock1: & Clock Face One Oclock \\
\hline
U+1F551 & 🕑 & {\textbackslash}:clock2: & Clock Face Two Oclock \\
\hline
U+1F552 & 🕒 & {\textbackslash}:clock3: & Clock Face Three Oclock \\
\hline
U+1F553 & 🕓 & {\textbackslash}:clock4: & Clock Face Four Oclock \\
\hline
U+1F554 & 🕔 & {\textbackslash}:clock5: & Clock Face Five Oclock \\
\hline
U+1F555 & 🕕 & {\textbackslash}:clock6: & Clock Face Six Oclock \\
\hline
U+1F556 & 🕖 & {\textbackslash}:clock7: & Clock Face Seven Oclock \\
\hline
U+1F557 & 🕗 & {\textbackslash}:clock8: & Clock Face Eight Oclock \\
\hline
U+1F558 & 🕘 & {\textbackslash}:clock9: & Clock Face Nine Oclock \\
\hline
U+1F559 & 🕙 & {\textbackslash}:clock10: & Clock Face Ten Oclock \\
\hline
U+1F55A & 🕚 & {\textbackslash}:clock11: & Clock Face Eleven Oclock \\
\hline
U+1F55B & 🕛 & {\textbackslash}:clock12: & Clock Face Twelve Oclock \\
\hline
U+1F55C & 🕜 & {\textbackslash}:clock130: & Clock Face One-thirty \\
\hline
U+1F55D & 🕝 & {\textbackslash}:clock230: & Clock Face Two-thirty \\
\hline
U+1F55E & 🕞 & {\textbackslash}:clock330: & Clock Face Three-thirty \\
\hline
U+1F55F & 🕟 & {\textbackslash}:clock430: & Clock Face Four-thirty \\
\hline
U+1F560 & 🕠 & {\textbackslash}:clock530: & Clock Face Five-thirty \\
\hline
U+1F561 & 🕡 & {\textbackslash}:clock630: & Clock Face Six-thirty \\
\hline
U+1F562 & 🕢 & {\textbackslash}:clock730: & Clock Face Seven-thirty \\
\hline
U+1F563 & 🕣 & {\textbackslash}:clock830: & Clock Face Eight-thirty \\
\hline
U+1F564 & 🕤 & {\textbackslash}:clock930: & Clock Face Nine-thirty \\
\hline
U+1F565 & 🕥 & {\textbackslash}:clock1030: & Clock Face Ten-thirty \\
\hline
U+1F566 & 🕦 & {\textbackslash}:clock1130: & Clock Face Eleven-thirty \\
\hline
U+1F567 & 🕧 & {\textbackslash}:clock1230: & Clock Face Twelve-thirty \\
\hline
U+1F5FB & 🗻 & {\textbackslash}:mount\_fuji: & Mount Fuji \\
\hline
U+1F5FC & 🗼 & {\textbackslash}:tokyo\_tower: & Tokyo Tower \\
\hline
U+1F5FD & 🗽 & {\textbackslash}:statue\_of\_liberty: & Statue Of Liberty \\
\hline
U+1F5FE & 🗾 & {\textbackslash}:japan: & Silhouette Of Japan \\
\hline
U+1F5FF & 🗿 & {\textbackslash}:moyai: & Moyai \\
\hline
U+1F600 & 😀 & {\textbackslash}:grinning: & Grinning Face \\
\hline
U+1F601 & 😁 & {\textbackslash}:grin: & Grinning Face With Smiling Eyes \\
\hline
U+1F602 & 😂 & {\textbackslash}:joy: & Face With Tears Of Joy \\
\hline
U+1F603 & 😃 & {\textbackslash}:smiley: & Smiling Face With Open Mouth \\
\hline
U+1F604 & 😄 & {\textbackslash}:smile: & Smiling Face With Open Mouth And Smiling Eyes \\
\hline
U+1F605 & 😅 & {\textbackslash}:sweat\_smile: & Smiling Face With Open Mouth And Cold Sweat \\
\hline
U+1F606 & 😆 & {\textbackslash}:laughing: & Smiling Face With Open Mouth And Tightly-closed Eyes \\
\hline
U+1F607 & 😇 & {\textbackslash}:innocent: & Smiling Face With Halo \\
\hline
U+1F608 & 😈 & {\textbackslash}:smiling\_imp: & Smiling Face With Horns \\
\hline
U+1F609 & 😉 & {\textbackslash}:wink: & Winking Face \\
\hline
U+1F60A & 😊 & {\textbackslash}:blush: & Smiling Face With Smiling Eyes \\
\hline
U+1F60B & 😋 & {\textbackslash}:yum: & Face Savouring Delicious Food \\
\hline
U+1F60C & 😌 & {\textbackslash}:relieved: & Relieved Face \\
\hline
U+1F60D & 😍 & {\textbackslash}:heart\_eyes: & Smiling Face With Heart-shaped Eyes \\
\hline
U+1F60E & 😎 & {\textbackslash}:sunglasses: & Smiling Face With Sunglasses \\
\hline
U+1F60F & 😏 & {\textbackslash}:smirk: & Smirking Face \\
\hline
U+1F610 & 😐 & {\textbackslash}:neutral\_face: & Neutral Face \\
\hline
U+1F611 & 😑 & {\textbackslash}:expressionless: & Expressionless Face \\
\hline
U+1F612 & 😒 & {\textbackslash}:unamused: & Unamused Face \\
\hline
U+1F613 & 😓 & {\textbackslash}:sweat: & Face With Cold Sweat \\
\hline
U+1F614 & 😔 & {\textbackslash}:pensive: & Pensive Face \\
\hline
U+1F615 & 😕 & {\textbackslash}:confused: & Confused Face \\
\hline
U+1F616 & 😖 & {\textbackslash}:confounded: & Confounded Face \\
\hline
U+1F617 & 😗 & {\textbackslash}:kissing: & Kissing Face \\
\hline
U+1F618 & 😘 & {\textbackslash}:kissing\_heart: & Face Throwing A Kiss \\
\hline
U+1F619 & 😙 & {\textbackslash}:kissing\_smiling\_eyes: & Kissing Face With Smiling Eyes \\
\hline
U+1F61A & 😚 & {\textbackslash}:kissing\_closed\_eyes: & Kissing Face With Closed Eyes \\
\hline
U+1F61B & 😛 & {\textbackslash}:stuck\_out\_tongue: & Face With Stuck-out Tongue \\
\hline
U+1F61C & 😜 & {\textbackslash}:stuck\_out\_tongue\_winking\_eye: & Face With Stuck-out Tongue And Winking Eye \\
\hline
U+1F61D & 😝 & {\textbackslash}:stuck\_out\_tongue\_closed\_eyes: & Face With Stuck-out Tongue And Tightly-closed Eyes \\
\hline
U+1F61E & 😞 & {\textbackslash}:disappointed: & Disappointed Face \\
\hline
U+1F61F & 😟 & {\textbackslash}:worried: & Worried Face \\
\hline
U+1F620 & 😠 & {\textbackslash}:angry: & Angry Face \\
\hline
U+1F621 & 😡 & {\textbackslash}:rage: & Pouting Face \\
\hline
U+1F622 & 😢 & {\textbackslash}:cry: & Crying Face \\
\hline
U+1F623 & 😣 & {\textbackslash}:persevere: & Persevering Face \\
\hline
U+1F624 & 😤 & {\textbackslash}:triumph: & Face With Look Of Triumph \\
\hline
U+1F625 & 😥 & {\textbackslash}:disappointed\_relieved: & Disappointed But Relieved Face \\
\hline
U+1F626 & 😦 & {\textbackslash}:frowning: & Frowning Face With Open Mouth \\
\hline
U+1F627 & 😧 & {\textbackslash}:anguished: & Anguished Face \\
\hline
U+1F628 & 😨 & {\textbackslash}:fearful: & Fearful Face \\
\hline
U+1F629 & 😩 & {\textbackslash}:weary: & Weary Face \\
\hline
U+1F62A & 😪 & {\textbackslash}:sleepy: & Sleepy Face \\
\hline
U+1F62B & 😫 & {\textbackslash}:tired\_face: & Tired Face \\
\hline
U+1F62C & 😬 & {\textbackslash}:grimacing: & Grimacing Face \\
\hline
U+1F62D & 😭 & {\textbackslash}:sob: & Loudly Crying Face \\
\hline
U+1F62E & 😮 & {\textbackslash}:open\_mouth: & Face With Open Mouth \\
\hline
U+1F62F & 😯 & {\textbackslash}:hushed: & Hushed Face \\
\hline
U+1F630 & 😰 & {\textbackslash}:cold\_sweat: & Face With Open Mouth And Cold Sweat \\
\hline
U+1F631 & 😱 & {\textbackslash}:scream: & Face Screaming In Fear \\
\hline
U+1F632 & 😲 & {\textbackslash}:astonished: & Astonished Face \\
\hline
U+1F633 & 😳 & {\textbackslash}:flushed: & Flushed Face \\
\hline
U+1F634 & 😴 & {\textbackslash}:sleeping: & Sleeping Face \\
\hline
U+1F635 & 😵 & {\textbackslash}:dizzy\_face: & Dizzy Face \\
\hline
U+1F636 & 😶 & {\textbackslash}:no\_mouth: & Face Without Mouth \\
\hline
U+1F637 & 😷 & {\textbackslash}:mask: & Face With Medical Mask \\
\hline
U+1F638 & 😸 & {\textbackslash}:smile\_cat: & Grinning Cat Face With Smiling Eyes \\
\hline
U+1F639 & 😹 & {\textbackslash}:joy\_cat: & Cat Face With Tears Of Joy \\
\hline
U+1F63A & 😺 & {\textbackslash}:smiley\_cat: & Smiling Cat Face With Open Mouth \\
\hline
U+1F63B & 😻 & {\textbackslash}:heart\_eyes\_cat: & Smiling Cat Face With Heart-shaped Eyes \\
\hline
U+1F63C & 😼 & {\textbackslash}:smirk\_cat: & Cat Face With Wry Smile \\
\hline
U+1F63D & 😽 & {\textbackslash}:kissing\_cat: & Kissing Cat Face With Closed Eyes \\
\hline
U+1F63E & 😾 & {\textbackslash}:pouting\_cat: & Pouting Cat Face \\
\hline
U+1F63F & 😿 & {\textbackslash}:crying\_cat\_face: & Crying Cat Face \\
\hline
U+1F640 & 🙀 & {\textbackslash}:scream\_cat: & Weary Cat Face \\
\hline
U+1F645 & 🙅 & {\textbackslash}:no\_good: & Face With No Good Gesture \\
\hline
U+1F646 & 🙆 & {\textbackslash}:ok\_woman: & Face With Ok Gesture \\
\hline
U+1F647 & 🙇 & {\textbackslash}:bow: & Person Bowing Deeply \\
\hline
U+1F648 & 🙈 & {\textbackslash}:see\_no\_evil: & See-no-evil Monkey \\
\hline
U+1F649 & 🙉 & {\textbackslash}:hear\_no\_evil: & Hear-no-evil Monkey \\
\hline
U+1F64A & 🙊 & {\textbackslash}:speak\_no\_evil: & Speak-no-evil Monkey \\
\hline
U+1F64B & 🙋 & {\textbackslash}:raising\_hand: & Happy Person Raising One Hand \\
\hline
U+1F64C & 🙌 & {\textbackslash}:raised\_hands: & Person Raising Both Hands In Celebration \\
\hline
U+1F64D & 🙍 & {\textbackslash}:person\_frowning: & Person Frowning \\
\hline
U+1F64E & 🙎 & {\textbackslash}:person\_with\_pouting\_face: & Person With Pouting Face \\
\hline
U+1F64F & 🙏 & {\textbackslash}:pray: & Person With Folded Hands \\
\hline
U+1F680 & 🚀 & {\textbackslash}:rocket: & Rocket \\
\hline
U+1F681 & 🚁 & {\textbackslash}:helicopter: & Helicopter \\
\hline
U+1F682 & 🚂 & {\textbackslash}:steam\_locomotive: & Steam Locomotive \\
\hline
U+1F683 & 🚃 & {\textbackslash}:railway\_car: & Railway Car \\
\hline
U+1F684 & 🚄 & {\textbackslash}:bullettrain\_side: & High-speed Train \\
\hline
U+1F685 & 🚅 & {\textbackslash}:bullettrain\_front: & High-speed Train With Bullet Nose \\
\hline
U+1F686 & 🚆 & {\textbackslash}:train2: & Train \\
\hline
U+1F687 & 🚇 & {\textbackslash}:metro: & Metro \\
\hline
U+1F688 & 🚈 & {\textbackslash}:light\_rail: & Light Rail \\
\hline
U+1F689 & 🚉 & {\textbackslash}:station: & Station \\
\hline
U+1F68A & 🚊 & {\textbackslash}:tram: & Tram \\
\hline
U+1F68B & 🚋 & {\textbackslash}:train: & Tram Car \\
\hline
U+1F68C & 🚌 & {\textbackslash}:bus: & Bus \\
\hline
U+1F68D & 🚍 & {\textbackslash}:oncoming\_bus: & Oncoming Bus \\
\hline
U+1F68E & 🚎 & {\textbackslash}:trolleybus: & Trolleybus \\
\hline
U+1F68F & 🚏 & {\textbackslash}:busstop: & Bus Stop \\
\hline
U+1F690 & 🚐 & {\textbackslash}:minibus: & Minibus \\
\hline
U+1F691 & 🚑 & {\textbackslash}:ambulance: & Ambulance \\
\hline
U+1F692 & 🚒 & {\textbackslash}:fire\_engine: & Fire Engine \\
\hline
U+1F693 & 🚓 & {\textbackslash}:police\_car: & Police Car \\
\hline
U+1F694 & 🚔 & {\textbackslash}:oncoming\_police\_car: & Oncoming Police Car \\
\hline
U+1F695 & 🚕 & {\textbackslash}:taxi: & Taxi \\
\hline
U+1F696 & 🚖 & {\textbackslash}:oncoming\_taxi: & Oncoming Taxi \\
\hline
U+1F697 & 🚗 & {\textbackslash}:car: & Automobile \\
\hline
U+1F698 & 🚘 & {\textbackslash}:oncoming\_automobile: & Oncoming Automobile \\
\hline
U+1F699 & 🚙 & {\textbackslash}:blue\_car: & Recreational Vehicle \\
\hline
U+1F69A & 🚚 & {\textbackslash}:truck: & Delivery Truck \\
\hline
U+1F69B & 🚛 & {\textbackslash}:articulated\_lorry: & Articulated Lorry \\
\hline
U+1F69C & 🚜 & {\textbackslash}:tractor: & Tractor \\
\hline
U+1F69D & 🚝 & {\textbackslash}:monorail: & Monorail \\
\hline
U+1F69E & 🚞 & {\textbackslash}:mountain\_railway: & Mountain Railway \\
\hline
U+1F69F & 🚟 & {\textbackslash}:suspension\_railway: & Suspension Railway \\
\hline
U+1F6A0 & 🚠 & {\textbackslash}:mountain\_cableway: & Mountain Cableway \\
\hline
U+1F6A1 & 🚡 & {\textbackslash}:aerial\_tramway: & Aerial Tramway \\
\hline
U+1F6A2 & 🚢 & {\textbackslash}:ship: & Ship \\
\hline
U+1F6A3 & 🚣 & {\textbackslash}:rowboat: & Rowboat \\
\hline
U+1F6A4 & 🚤 & {\textbackslash}:speedboat: & Speedboat \\
\hline
U+1F6A5 & 🚥 & {\textbackslash}:traffic\_light: & Horizontal Traffic Light \\
\hline
U+1F6A6 & 🚦 & {\textbackslash}:vertical\_traffic\_light: & Vertical Traffic Light \\
\hline
U+1F6A7 & 🚧 & {\textbackslash}:construction: & Construction Sign \\
\hline
U+1F6A8 & 🚨 & {\textbackslash}:rotating\_light: & Police Cars Revolving Light \\
\hline
U+1F6A9 & 🚩 & {\textbackslash}:triangular\_flag\_on\_post: & Triangular Flag On Post \\
\hline
U+1F6AA & 🚪 & {\textbackslash}:door: & Door \\
\hline
U+1F6AB & 🚫 & {\textbackslash}:no\_entry\_sign: & No Entry Sign \\
\hline
U+1F6AC & 🚬 & {\textbackslash}:smoking: & Smoking Symbol \\
\hline
U+1F6AD & 🚭 & {\textbackslash}:no\_smoking: & No Smoking Symbol \\
\hline
U+1F6AE & 🚮 & {\textbackslash}:put\_litter\_in\_its\_place: & Put Litter In Its Place Symbol \\
\hline
U+1F6AF & 🚯 & {\textbackslash}:do\_not\_litter: & Do Not Litter Symbol \\
\hline
U+1F6B0 & 🚰 & {\textbackslash}:potable\_water: & Potable Water Symbol \\
\hline
U+1F6B1 & 🚱 & {\textbackslash}:non-potable\_water: & Non-potable Water Symbol \\
\hline
U+1F6B2 & 🚲 & {\textbackslash}:bike: & Bicycle \\
\hline
U+1F6B3 & 🚳 & {\textbackslash}:no\_bicycles: & No Bicycles \\
\hline
U+1F6B4 & 🚴 & {\textbackslash}:bicyclist: & Bicyclist \\
\hline
U+1F6B5 & 🚵 & {\textbackslash}:mountain\_bicyclist: & Mountain Bicyclist \\
\hline
U+1F6B6 & 🚶 & {\textbackslash}:walking: & Pedestrian \\
\hline
U+1F6B7 & 🚷 & {\textbackslash}:no\_pedestrians: & No Pedestrians \\
\hline
U+1F6B8 & 🚸 & {\textbackslash}:children\_crossing: & Children Crossing \\
\hline
U+1F6B9 & 🚹 & {\textbackslash}:mens: & Mens Symbol \\
\hline
U+1F6BA & 🚺 & {\textbackslash}:womens: & Womens Symbol \\
\hline
U+1F6BB & 🚻 & {\textbackslash}:restroom: & Restroom \\
\hline
U+1F6BC & 🚼 & {\textbackslash}:baby\_symbol: & Baby Symbol \\
\hline
U+1F6BD & 🚽 & {\textbackslash}:toilet: & Toilet \\
\hline
U+1F6BE & 🚾 & {\textbackslash}:wc: & Water Closet \\
\hline
U+1F6BF & 🚿 & {\textbackslash}:shower: & Shower \\
\hline
U+1F6C0 & 🛀 & {\textbackslash}:bath: & Bath \\
\hline
U+1F6C1 & 🛁 & {\textbackslash}:bathtub: & Bathtub \\
\hline
U+1F6C2 & 🛂 & {\textbackslash}:passport\_control: & Passport Control \\
\hline
U+1F6C3 & 🛃 & {\textbackslash}:customs: & Customs \\
\hline
U+1F6C4 & 🛄 & {\textbackslash}:baggage\_claim: & Baggage Claim \\
\hline
U+1F6C5 & 🛅 & {\textbackslash}:left\_luggage: & Left Luggage \\
\hline
\end{tabulary}

\end{table}



\part{Standard Library}


\hypertarget{4709349624826687157}{}


\chapter{Essentials}



\hypertarget{13021703007540981984}{}


\section{Introducción}



La librería estándar de Julia contiene un rango de funciones y maros apropiadas para realizar  computación científica y numérica, pero es también tan amplia como la de muchos lenguajes de  programación de propósito general. También hay funcionalidad adicional disponible en una  colección creciente de paquetes disponibles. Las funciones están agrupadas abajo por temas.



Algunas notas generales:



\begin{itemize}
\item Excepto para las funciones en los módulos predefinidos (\texttt{Pkg}, \texttt{Collections}, \texttt{Test} 

\end{itemize}


y \texttt{Profile}), todas las funciones documentadas aquí están disponibles directamente  para ser usadas en programas.



\begin{itemize}
\item Para usar funciones de módulos, usar \texttt{import Module} para importar el módulo, y \texttt{Module.fn(x)} 

\end{itemize}


para usar las funciones.



\begin{itemize}
\item Alternativamente \texttt{using Module} importará todas las funciones exportadas por el módulo en 

\end{itemize}


el espacio de nombres actual.



\begin{itemize}
\item Por convenio, los nombres de funciones que acaban con un signo de admiración (\texttt{!}) 

\end{itemize}


modifican sus argumentos. Algunas funciones tienen las dos versiones (con y sin modificación  de los argumentos).



\hypertarget{17258528125521332489}{}


\section{Moviéndose}


\hypertarget{14846984688570889934}{} 
\hyperlink{14846984688570889934}{\texttt{Base.exit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exit([code])
\end{lstlisting}

Quit (or control-D at the prompt). The default exit code is zero, indicating that the processes completed successfully.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2486-L2491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14713431028777529629}{} 
\hyperlink{14713431028777529629}{\texttt{Base.quit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
quit()
\end{lstlisting}

Quit the program indicating that the processes completed successfully. This function calls \texttt{exit(0)} (see \hyperlink{14846984688570889934}{\texttt{exit}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1381-L1386}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17479944696971324992}{} 
\hyperlink{17479944696971324992}{\texttt{Base.atexit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atexit(f)
\end{lstlisting}

Register a zero-argument function \texttt{f()} to be called at process exit. \texttt{atexit()} hooks are called in last in first out (LIFO) order and run before object finalizers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1569-L1574}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1741947168860119796}{} 
\hyperlink{1741947168860119796}{\texttt{Base.atreplinit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atreplinit(f)
\end{lstlisting}

Register a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of \texttt{f} is the REPL object. This function should be called from within the \texttt{.juliarc.jl} initialization file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/client.jl#L344-L351}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10304111149900708910}{} 
\hyperlink{10304111149900708910}{\texttt{Base.isinteractive}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isinteractive() -> Bool
\end{lstlisting}

Determine whether Julia is running an interactive session.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L537-L541}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6120892747206868704}{} 
\hyperlink{6120892747206868704}{\texttt{Base.whos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
whos(io::IO=STDOUT, m::Module=current_module(), pattern::Regex=r"")
\end{lstlisting}

Print information about exported global variables in a module, optionally restricted to those matching \texttt{pattern}.

The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L699-L705}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959611366931029689}{} 
\hyperlink{16959611366931029689}{\texttt{Base.summarysize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -> Int
\end{lstlisting}

Compute the amount of memory used by all unique objects reachable from the argument.

\textbf{Keyword Arguments}

\begin{itemize}
\item \texttt{exclude}: specifies the types of objects to exclude from the traversal.


\item \texttt{chargeall}: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/summarysize.jl#L12-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7044880690333675643}{} 
\hyperlink{7044880690333675643}{\texttt{Base.edit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
edit(path::AbstractString, line::Integer=0)
\end{lstlisting}

Edit a file or directory optionally providing a line number to edit the file at. Returns to the \texttt{julia} prompt when you quit the editor. The editor can be changed by setting \texttt{JULIA\_EDITOR}, \texttt{VISUAL} or \texttt{EDITOR} as an environment variable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L26-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{427647396423486761}{} 
\hyperlink{427647396423486761}{\texttt{Base.edit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
edit(function, [types])
\end{lstlisting}

Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. The editor can be changed by setting \texttt{JULIA\_EDITOR}, \texttt{VISUAL} or \texttt{EDITOR} as an environment variable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L80-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17602563839609547712}{} 
\hyperlink{17602563839609547712}{\texttt{Base.@edit}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@edit
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls the \texttt{edit} function on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L469-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2845783434878498384}{} 
\hyperlink{2845783434878498384}{\texttt{Base.less}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
less(file::AbstractString, [line::Integer])
\end{lstlisting}

Show a file using the default pager, optionally providing a starting line number. Returns to the \texttt{julia} prompt when you quit the pager.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L106-L111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13199804309598213666}{} 
\hyperlink{13199804309598213666}{\texttt{Base.less}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
less(function, [types])
\end{lstlisting}

Show the definition of a function using the default pager, optionally specifying a tuple of types to indicate which method to see.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L114-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18315670497626788540}{} 
\hyperlink{18315670497626788540}{\texttt{Base.@less}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@less
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls the \texttt{less} function on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L461-L466}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13156769095888501950}{} 
\hyperlink{13156769095888501950}{\texttt{Base.clipboard}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clipboard(x)
\end{lstlisting}

Send a printed form of \texttt{x} to the operating system clipboard ({\textquotedbl}copy{\textquotedbl}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L203-L207}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13167214404646874260}{} 
\hyperlink{13167214404646874260}{\texttt{Base.clipboard}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clipboard() -> AbstractString
\end{lstlisting}

Return a string with the contents of the operating system clipboard ({\textquotedbl}paste{\textquotedbl}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L210-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6072703247917948688}{} 
\hyperlink{6072703247917948688}{\texttt{Base.reload}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reload(name::AbstractString)
\end{lstlisting}

Force reloading of a package, even if it has been loaded before. This is intended for use during package development as code is modified.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L366-L371}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16690217505788642360}{} 
\hyperlink{16690217505788642360}{\texttt{Base.require}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
require(module::Symbol)
\end{lstlisting}

This function is part of the implementation of \texttt{using} / \texttt{import}, if a module is not already defined in \texttt{Main}. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).

Loads a source file, in the context of the \texttt{Main} module, on every active node, searching standard locations for files. \texttt{require} is considered a top-level operation, so it sets the current \texttt{include} path but does not use it to search for files (see help for \texttt{include}). This function is typically used to load library code, and is implicitly called by \texttt{using} to load packages.

When searching for files, \texttt{require} first looks for package code under \texttt{Pkg.dir()}, then tries paths in the global array \texttt{LOAD\_PATH}. \texttt{require} is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L385-L403}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15403934372637978246}{} 
\hyperlink{15403934372637978246}{\texttt{Base.compilecache}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.compilecache(module::String)
\end{lstlisting}

Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in \texttt{LOAD\_CACHE\_PATH[1]}, which defaults to \texttt{{\textasciitilde}/.julia/lib/VERSION}. See \hyperlink{16026249523986343319}{Module initialization and precompilation} for important notes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L666-L675}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9213488790068613847}{} 
\hyperlink{9213488790068613847}{\texttt{Base.\_\_precompile\_\_}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
__precompile__(isprecompilable::Bool=true)
\end{lstlisting}

Specify whether the file calling this function is precompilable. If \texttt{isprecompilable} is \texttt{true}, then \texttt{\_\_precompile\_\_} throws an exception when the file is loaded by \texttt{using}/\texttt{import}/\texttt{require} \emph{unless} the file is being precompiled, and in a module file it causes the module to be automatically precompiled when it is imported. Typically, \texttt{\_\_precompile\_\_()} should occur before the \texttt{module} declaration in the file, or better yet \texttt{VERSION >= v{\textquotedbl}0.4{\textquotedbl} \&\& \_\_precompile\_\_()} in order to be backward-compatible with Julia 0.3.

If a module or file is \emph{not} safely precompilable, it should call \texttt{\_\_precompile\_\_(false)} in order to throw an error if Julia attempts to precompile it.

\texttt{\_\_precompile\_\_()} should \emph{not} be used in a module unless all of its dependencies are also using \texttt{\_\_precompile\_\_()}. Failure to do so can result in a runtime error when loading the module.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L321-L336}{\texttt{source}}


\end{adjustwidth}
\hypertarget{438355891087818425}{} 
\hyperlink{438355891087818425}{\texttt{Base.include}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
include(path::AbstractString)
\end{lstlisting}

Evaluate the contents of the input source file in the current context. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to \texttt{include} will search relative to that path. All paths refer to files on node 1 when running in parallel, and files will be fetched from node 1. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L591-L600}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2796348696499086186}{} 
\hyperlink{2796348696499086186}{\texttt{Base.include\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
include_string(code::AbstractString, filename::AbstractString="string")
\end{lstlisting}

Like \texttt{include}, except reads code from the given string rather than from a file. Since there is no file path involved, no path processing or fetching from node 1 is done.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L516-L521}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13423629850785876688}{} 
\hyperlink{13423629850785876688}{\texttt{Base.include\_dependency}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
include_dependency(path::AbstractString)
\end{lstlisting}

In a module, declare that the file specified by \texttt{path} (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.

This is only needed if your module depends on a file that is not used via \texttt{include}. It has no effect outside of compilation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L287-L296}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6069714544176255543}{} 
\hyperlink{6069714544176255543}{\texttt{Base.Docs.apropos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
apropos(string)
\end{lstlisting}

Search through all documentation for a string, ignoring case.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/utils.jl#L440-L444}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17355831054812136492}{} 
\hyperlink{17355831054812136492}{\texttt{Base.which}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
which(f, types)
\end{lstlisting}

Returns the method of \texttt{f} (a \texttt{Method} object) that would be called for arguments of the given \texttt{types}.

If \texttt{types} is an abstract type, then the method that would be called by \texttt{invoke} is returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L809-L815}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13771745306106792154}{} 
\hyperlink{13771745306106792154}{\texttt{Base.which}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
which(symbol)
\end{lstlisting}

Return the module in which the binding for the variable referenced by \texttt{symbol} was created.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L841-L845}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1849198515397717858}{} 
\hyperlink{1849198515397717858}{\texttt{Base.@which}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@which
\end{lstlisting}

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the \texttt{Method} object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the \texttt{which} function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L451-L458}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3025953302266245919}{} 
\hyperlink{3025953302266245919}{\texttt{Base.methods}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
methods(f, [types])
\end{lstlisting}

Returns the method table for \texttt{f}.

If \texttt{types} is specified, returns an array of methods whose types match.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L572-L578}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12860964732831752396}{} 
\hyperlink{12860964732831752396}{\texttt{Base.methodswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
methodswith(typ[, module or function][, showparents::Bool=false])
\end{lstlisting}

Return an array of methods with an argument of type \texttt{typ}.

The optional second argument restricts the search to a particular module or function (the default is all modules, starting from Main).

If optional \texttt{showparents} is \texttt{true}, also return arguments with a parent type of \texttt{typ}, excluding type \texttt{Any}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L534-L544}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13133508810150623671}{} 
\hyperlink{13133508810150623671}{\texttt{Base.@show}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@show
\end{lstlisting}

Show an expression and result, returning the result.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L815-L819}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4959604240462971450}{} 
\hyperlink{4959604240462971450}{\texttt{Base.versioninfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
versioninfo(io::IO=STDOUT, verbose::Bool=false)
\end{lstlisting}

Print information about the version of Julia in use. If the \texttt{verbose} argument is \texttt{true}, detailed system information is shown as well.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L247-L252}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7789928938295338947}{} 
\hyperlink{7789928938295338947}{\texttt{Base.workspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
workspace()
\end{lstlisting}

Replace the top-level module (\texttt{Main}) with a new one, providing a clean workspace. The previous \texttt{Main} module is made available as \texttt{LastMain}. A previously-loaded package can be accessed using a statement such as \texttt{using LastMain.Package}.

This function should only be used interactively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L648-L656}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11288188119698492222}{} 
\hyperlink{11288188119698492222}{\texttt{ans}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ans
\end{lstlisting}

A variable referring to the last computed value, automatically set at the interactive prompt.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L684-L688}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14831108203714113824}{}


\section{Todos los Objetos}


\hypertarget{7974744969331231272}{} 
\hyperlink{7974744969331231272}{\texttt{Core.:===}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
===(x,y) -> Bool
≡(x,y) -> Bool
\end{lstlisting}

Determine whether \texttt{x} and \texttt{y} are identical, in the sense that no program could distinguish them. Compares mutable objects by address in memory, and compares immutable objects (such as numbers) by contents at the bit level. This function is sometimes called \texttt{egal}.


\begin{minted}{jlcon}
julia> a = [1, 2]; b = [1, 2];

julia> a == b
true

julia> a === b
false

julia> a === a
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L132-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7066325108767373297}{} 
\hyperlink{7066325108767373297}{\texttt{Core.isa}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isa(x, type) -> Bool
\end{lstlisting}

Determine whether \texttt{x} is of the given \texttt{type}. Can also be used as an infix operator, e.g. \texttt{x isa type}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2146-L2151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12829995639916057841}{} 
\hyperlink{12829995639916057841}{\texttt{Base.isequal}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isequal(x, y)
\end{lstlisting}

Similar to \texttt{==}, except treats all floating-point \texttt{NaN} values as equal to each other, and treats \texttt{-0.0} as unequal to \texttt{0.0}. The default implementation of \texttt{isequal} calls \texttt{==}, so if you have a type that doesn{\textquotesingle}t have these floating-point subtleties then you probably only need to define \texttt{==}.

\texttt{isequal} is the comparison function used by hash tables (\texttt{Dict}). \texttt{isequal(x,y)} must imply that \texttt{hash(x) == hash(y)}.

This typically means that if you define your own \texttt{==} function then you must define a corresponding \texttt{hash} (and vice versa). Collections typically implement \texttt{isequal} by calling \texttt{isequal} recursively on all contents.

Scalar types generally do not need to implement \texttt{isequal} separate from \texttt{==}, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on \texttt{isnan}, \texttt{signbit}, and \texttt{==}).


\begin{minted}{jlcon}
julia> isequal([1., NaN], [1., NaN])
true

julia> [1., NaN] == [1., NaN]
false

julia> 0.0 == -0.0
true

julia> isequal(0.0, -0.0)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L54-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15106114209632897560}{} 
\hyperlink{15106114209632897560}{\texttt{Base.isequal}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isequal(x, y)
\end{lstlisting}

Similar to \texttt{==}, except treats all floating-point \texttt{NaN} values as equal to each other, and treats \texttt{-0.0} as unequal to \texttt{0.0}. The default implementation of \texttt{isequal} calls \texttt{==}, so if you have a type that doesn{\textquotesingle}t have these floating-point subtleties then you probably only need to define \texttt{==}.

\texttt{isequal} is the comparison function used by hash tables (\texttt{Dict}). \texttt{isequal(x,y)} must imply that \texttt{hash(x) == hash(y)}.

This typically means that if you define your own \texttt{==} function then you must define a corresponding \texttt{hash} (and vice versa). Collections typically implement \texttt{isequal} by calling \texttt{isequal} recursively on all contents.

Scalar types generally do not need to implement \texttt{isequal} separate from \texttt{==}, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on \texttt{isnan}, \texttt{signbit}, and \texttt{==}).


\begin{minted}{jlcon}
julia> isequal([1., NaN], [1., NaN])
true

julia> [1., NaN] == [1., NaN]
false

julia> 0.0 == -0.0
true

julia> isequal(0.0, -0.0)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L54-L86}{\texttt{source}}



\begin{lstlisting}
isequal(x::Nullable, y::Nullable)
\end{lstlisting}

If neither \texttt{x} nor \texttt{y} is null, compare them according to their values (i.e. \texttt{isequal(get(x), get(y))}). Else, return \texttt{true} if both arguments are null, and \texttt{false} if one is null but not the other: nulls are considered equal.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L198-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8062916604071842790}{} 
\hyperlink{8062916604071842790}{\texttt{Base.isless}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isless(x, y)
\end{lstlisting}

Test whether \texttt{x} is less than \texttt{y}, according to a canonical total order. Values that are normally unordered, such as \texttt{NaN}, are ordered in an arbitrary but consistent fashion. This is the default comparison used by \hyperlink{8473525809131227606}{\texttt{sort}}. Non-numeric types with a canonical total order should implement this function. Numeric types only need to implement it if they have special values such as \texttt{NaN}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1743-L1751}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16562333801171100234}{} 
\hyperlink{16562333801171100234}{\texttt{Base.isless}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isless(x::Nullable, y::Nullable)
\end{lstlisting}

If neither \texttt{x} nor \texttt{y} is null, compare them according to their values (i.e. \texttt{isless(get(x), get(y))}). Else, return \texttt{true} if only \texttt{y} is null, and \texttt{false} otherwise: nulls are always considered greater than non-nulls, but not greater than another null.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L217-L224}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9861487635347877687}{} 
\hyperlink{9861487635347877687}{\texttt{Base.ifelse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ifelse(condition::Bool, x, y)
\end{lstlisting}

Return \texttt{x} if \texttt{condition} is \texttt{true}, otherwise return \texttt{y}. This differs from \texttt{?} or \texttt{if} in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using \texttt{ifelse} instead of an \texttt{if} statement can eliminate the branch in generated code and provide higher performance in tight loops.


\begin{minted}{jlcon}
julia> ifelse(1 > 2, 1, 2)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L269-L281}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15219532373351781780}{} 
\hyperlink{15219532373351781780}{\texttt{Base.lexcmp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lexcmp(x, y)
\end{lstlisting}

Compare \texttt{x} and \texttt{y} lexicographically and return -1, 0, or 1 depending on whether \texttt{x} is less than, equal to, or greater than \texttt{y}, respectively. This function should be defined for lexicographically comparable types, and \texttt{lexless} will call \texttt{lexcmp} by default.


\begin{minted}{jlcon}
julia> lexcmp("abc", "abd")
-1

julia> lexcmp("abc", "abc")
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L305-L319}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6010337650622228595}{} 
\hyperlink{6010337650622228595}{\texttt{Base.lexless}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lexless(x, y)
\end{lstlisting}

Determine whether \texttt{x} is lexicographically less than \texttt{y}.


\begin{minted}{jlcon}
julia> lexless("abc", "abd")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L322-L331}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13440452181855594120}{} 
\hyperlink{13440452181855594120}{\texttt{Core.typeof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typeof(x)
\end{lstlisting}

Get the concrete type of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1017-L1021}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12342862450082530092}{} 
\hyperlink{12342862450082530092}{\texttt{Core.tuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tuple(xs...)
\end{lstlisting}

Construct a tuple of the given objects.

\textbf{Example}


\begin{minted}{jlcon}
julia> tuple(1, 'a', pi)
(1, 'a', π = 3.1415926535897...)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L580-L590}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11196859324054101444}{} 
\hyperlink{11196859324054101444}{\texttt{Base.ntuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ntuple(f::Function, n::Integer)
\end{lstlisting}

Create a tuple of length \texttt{n}, computing each element as \texttt{f(i)}, where \texttt{i} is the index of the element.


\begin{minted}{jlcon}
julia> ntuple(i -> 2*i, 4)
(2, 4, 6, 8)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/tuple.jl#L96-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16410505889262851104}{} 
\hyperlink{16410505889262851104}{\texttt{Base.object\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
object_id(x)
\end{lstlisting}

Get a hash value for \texttt{x} based on object identity. \texttt{object\_id(x)==object\_id(y)} if \texttt{x === y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1829-L1833}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13797072367283572032}{} 
\hyperlink{13797072367283572032}{\texttt{Base.hash}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hash(x[, h::UInt])
\end{lstlisting}

Compute an integer hash code such that \texttt{isequal(x,y)} implies \texttt{hash(x)==hash(y)}. The optional second argument \texttt{h} is a hash code to be mixed with the result.

New types should implement the 2-argument form, typically by calling the 2-argument \texttt{hash} method recursively in order to mix hashes of the contents with each other (and with \texttt{h}). Typically, any type that implements \texttt{hash} should also implement its own \texttt{==} (hence \texttt{isequal}) to guarantee the property mentioned above.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1469-L1479}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4805357059330171046}{} 
\hyperlink{4805357059330171046}{\texttt{Base.finalizer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
finalizer(x, f)
\end{lstlisting}

Register a function \texttt{f(x)} to be called when there are no program-accessible references to \texttt{x}. The type of \texttt{x} must be a \texttt{mutable struct}, otherwise the behavior of this function is unpredictable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1879-L1885}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6584919147438336166}{} 
\hyperlink{6584919147438336166}{\texttt{Base.finalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
finalize(x)
\end{lstlisting}

Immediately run finalizers registered for object \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1129-L1133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15665284441316555522}{} 
\hyperlink{15665284441316555522}{\texttt{Base.copy}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copy(x)
\end{lstlisting}

Create a shallow copy of \texttt{x}: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1577-L1583}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3259459540194502889}{} 
\hyperlink{3259459540194502889}{\texttt{Base.deepcopy}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deepcopy(x)
\end{lstlisting}

Create a deep copy of \texttt{x}: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling \texttt{deepcopy} on an object should generally have the same effect as serializing and then deserializing it.

As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.

While it isn{\textquotesingle}t normally necessary, user-defined types can override the default \texttt{deepcopy} behavior by defining a specialized version of the function \texttt{deepcopy\_internal(x::T, dict::ObjectIdDict)} (which shouldn{\textquotesingle}t otherwise be used), where \texttt{T} is the type to be specialized for, and \texttt{dict} keeps track of objects copied so far within the recursion. Within the definition, \texttt{deepcopy\_internal} should be used in place of \texttt{deepcopy}, and the \texttt{dict} variable should be updated as appropriate before returning.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2518-L2536}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11212950246505288748}{} 
\hyperlink{11212950246505288748}{\texttt{Core.isdefined}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdefined([m::Module,] s::Symbol)
isdefined(object, s::Symbol)
isdefined(object, index::Int)
\end{lstlisting}

Tests whether an assignable location is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index. With a single symbol argument, tests whether a global variable with that name is defined in \hyperlink{14046118357995428445}{\texttt{current\_module()}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1526-L1534}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1846942650946171605}{} 
\hyperlink{1846942650946171605}{\texttt{Base.convert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
convert(T, x)
\end{lstlisting}

Convert \texttt{x} to a value of type \texttt{T}.

If \texttt{T} is an \hyperlink{8469131683393450448}{\texttt{Integer}} type, an \hyperlink{5399118524830636312}{\texttt{InexactError}} will be raised if \texttt{x} is not representable by \texttt{T}, for example if \texttt{x} is not integer-valued, or is outside the range supported by \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> convert(Int, 3.0)
3

julia> convert(Int, 3.5)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int64}, ::Float64) at ./float.jl:679
\end{minted}

If \texttt{T} is a \hyperlink{11465394427882483091}{\texttt{AbstractFloat}} or \hyperlink{8304566144531167610}{\texttt{Rational}} type, then it will return the closest value to \texttt{x} representable by \texttt{T}.


\begin{minted}{jlcon}
julia> x = 1/3
0.3333333333333333

julia> convert(Float32, x)
0.33333334f0

julia> convert(Rational{Int32}, x)
1//3

julia> convert(Rational{Int64}, x)
6004799503160661//18014398509481984
\end{minted}

If \texttt{T} is a collection type and \texttt{x} a collection, the result of \texttt{convert(T, x)} may alias \texttt{x}.


\begin{minted}{jlcon}
julia> x = Int[1,2,3];

julia> y = convert(Vector{Int}, x);

julia> y === x
true
\end{minted}

Similarly, if \texttt{T} is a composite type and \texttt{x} a related instance, the result of \texttt{convert(T, x)} may alias part or all of \texttt{x}.


\begin{minted}{jlcon}
julia> x = speye(5);

julia> typeof(x)
SparseMatrixCSC{Float64,Int64}

julia> y = convert(SparseMatrixCSC{Float64,Int64}, x);

julia> z = convert(SparseMatrixCSC{Float32,Int64}, y);

julia> y === x
true

julia> z === x
false

julia> z.colptr === x.colptr
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2173-L2241}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1760874576431605095}{} 
\hyperlink{1760874576431605095}{\texttt{Base.promote}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
promote(xs...)
\end{lstlisting}

Convert all arguments to their common promotion type (if any), and return them all (as a tuple).

\textbf{Example}


\begin{minted}{jlcon}
julia> promote(Int8(1), Float16(4.5), Float32(4.1))
(1.0f0, 4.5f0, 4.1f0)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L407-L417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{374166931194490566}{} 
\hyperlink{374166931194490566}{\texttt{Base.oftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
oftype(x, y)
\end{lstlisting}

Convert \texttt{y} to the type of \texttt{x} (\texttt{convert(typeof(x), y)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L377-L381}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18091106262785739128}{} 
\hyperlink{18091106262785739128}{\texttt{Base.widen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
widen(x)
\end{lstlisting}

If \texttt{x} is a type, return a {\textquotedbl}larger{\textquotedbl} type (for numeric types, this will be a type with at least as much range and precision as the argument, and usually more). Otherwise \texttt{x} is converted to \texttt{widen(typeof(x))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> widen(Int32)
Int64

julia> widen(1.5f0)
1.5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2539-L2554}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18150582836499084779}{} 
\hyperlink{18150582836499084779}{\texttt{Base.identity}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
identity(x)
\end{lstlisting}

The identity function. Returns its argument.


\begin{minted}{jlcon}
julia> identity("Well, what did you expect?")
"Well, what did you expect?"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L387-L396}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11424388444523813863}{}


\section{Tipos}


\hypertarget{12192788431675298651}{} 
\hyperlink{12192788431675298651}{\texttt{Base.supertype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
supertype(T::DataType)
\end{lstlisting}

Return the supertype of DataType \texttt{T}.


\begin{minted}{jlcon}
julia> supertype(Int32)
Signed
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L30-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5954612615304731643}{} 
\hyperlink{5954612615304731643}{\texttt{Core.issubtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issubtype(type1, type2)
\end{lstlisting}

Return \texttt{true} if and only if all values of \texttt{type1} are also of \texttt{type2}. Can also be written using the \texttt{<:} infix operator as \texttt{type1 <: type2}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issubtype(Int8, Int32)
false

julia> Int8 <: Integer
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1862-L1876}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10973847109239228196}{} 
\hyperlink{10973847109239228196}{\texttt{Base.:<:}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
<:(T1, T2)
\end{lstlisting}

Subtype operator, equivalent to \texttt{issubtype(T1, T2)}.


\begin{minted}{jlcon}
julia> Float64 <: AbstractFloat
true

julia> Vector{Int} <: AbstractArray
true

julia> Matrix{Float64} <: Matrix{AbstractFloat}
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L5-L20}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13074915255343859584}{} 
\hyperlink{13074915255343859584}{\texttt{Base.:>:}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>:(T1, T2)
\end{lstlisting}

Supertype operator, equivalent to \texttt{issubtype(T2, T1)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L23-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18325429904830593994}{} 
\hyperlink{18325429904830593994}{\texttt{Base.subtypes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
subtypes(T::DataType)
\end{lstlisting}

Return a list of immediate subtypes of DataType \texttt{T}. Note that all currently loaded subtypes are included, including those not visible in the current module.


\begin{minted}{jlcon}
julia> subtypes(Integer)
4-element Array{Union{DataType, UnionAll},1}:
 BigInt
 Bool
 Signed
 Unsigned
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L445-L459}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3613894539247233488}{} 
\hyperlink{3613894539247233488}{\texttt{Base.typemin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typemin(T)
\end{lstlisting}

The lowest value representable by the given (real) numeric DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typemin(Float16)
-Inf16

julia> typemin(Float32)
-Inf32
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1001-L1014}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17760305803764597758}{} 
\hyperlink{17760305803764597758}{\texttt{Base.typemax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typemax(T)
\end{lstlisting}

The highest value representable by the given (real) numeric \texttt{DataType}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1616-L1620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12203155268347273277}{} 
\hyperlink{12203155268347273277}{\texttt{Base.realmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
realmin(T)
\end{lstlisting}

The smallest in absolute value non-subnormal value representable by the given floating-point DataType \texttt{T}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2504-L2508}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1776131488016104529}{} 
\hyperlink{1776131488016104529}{\texttt{Base.realmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
realmax(T)
\end{lstlisting}

The highest finite value representable by the given floating-point DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> realmax(Float16)
Float16(6.55e4)

julia> realmax(Float32)
3.4028235f38
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L974-L987}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5283633936957536148}{} 
\hyperlink{5283633936957536148}{\texttt{Base.maxintfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
maxintfloat(T)
\end{lstlisting}

The largest integer losslessly representable by the given floating-point DataType \texttt{T}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1316-L1320}{\texttt{source}}



\begin{lstlisting}
maxintfloat(T, S)
\end{lstlisting}

The largest integer losslessly representable by the given floating-point DataType \texttt{T} that also does not exceed the maximum integer representable by the integer DataType \texttt{S}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1323-L1328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10394541563305653720}{} 
\hyperlink{10394541563305653720}{\texttt{Base.sizeof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sizeof(T)
\end{lstlisting}

Size, in bytes, of the canonical binary representation of the given DataType \texttt{T}, if any.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sizeof(Float32)
4

julia> sizeof(Complex128)
16
\end{minted}

If \texttt{T} does not have a specific size, an error is thrown.


\begin{minted}{jlcon}
julia> sizeof(Base.LinAlg.LU)
ERROR: argument is an abstract type; size is indeterminate
Stacktrace:
 [1] sizeof(::Type{T} where T) at ./essentials.jl:159
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L332-L354}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11829482654697677043}{} 
\hyperlink{11829482654697677043}{\texttt{Base.eps}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eps(::Type{T}) where T<:AbstractFloat
eps()
\end{lstlisting}

Returns the \emph{machine epsilon} of the floating point type \texttt{T} (\texttt{T = Float64} by default). This is defined as the gap between 1 and the next largest value representable by \texttt{T}, and is equivalent to \texttt{eps(one(T))}.


\begin{minted}{jlcon}
julia> eps()
2.220446049250313e-16

julia> eps(Float32)
1.1920929f-7

julia> 1.0 + eps()
1.0000000000000002

julia> 1.0 + eps()/2
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L718-L739}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8678379894267468692}{} 
\hyperlink{8678379894267468692}{\texttt{Base.eps}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eps(x::AbstractFloat)
\end{lstlisting}

Returns the \emph{unit in last place} (ulp) of \texttt{x}. This is the distance between consecutive representable floating point values at \texttt{x}. In most cases, if the distance on either side of \texttt{x} is different, then the larger of the two is taken, that is


\begin{lstlisting}
eps(x) == max(x-prevfloat(x), nextfloat(x)-x)
\end{lstlisting}

The exceptions to this rule are the smallest and largest finite values (e.g. \texttt{nextfloat(-Inf)} and \texttt{prevfloat(Inf)} for \hyperlink{5027751419500983000}{\texttt{Float64}}), which round to the smaller of the values.

The rationale for this behavior is that \texttt{eps} bounds the floating point rounding error. Under the default \texttt{RoundNearest} rounding mode, if \(y\) is a real number and \(x\) is the nearest floating point number to \(y\), then

\begin{equation*}
\begin{split}|y-x| \leq \operatorname{eps}(x)/2.\end{split}\end{equation*}

\begin{minted}{jlcon}
julia> eps(1.0)
2.220446049250313e-16

julia> eps(prevfloat(2.0))
2.220446049250313e-16

julia> eps(2.0)
4.440892098500626e-16

julia> x = prevfloat(Inf)      # largest finite Float64
1.7976931348623157e308

julia> x + eps(x)/2            # rounds up
Inf

julia> x + prevfloat(eps(x)/2) # rounds down
1.7976931348623157e308
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L742-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15048881762587391286}{} 
\hyperlink{15048881762587391286}{\texttt{Base.promote\_type}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
promote_type(type1, type2)
\end{lstlisting}

Determine a type big enough to hold values of each argument type without loss, whenever possible. In some cases, where no type exists to which both types can be promoted losslessly, some loss is tolerated; for example, \texttt{promote\_type(Int64, Float64)} returns \hyperlink{5027751419500983000}{\texttt{Float64}} even though strictly, not all \hyperlink{7720564657383125058}{\texttt{Int64}} values can be represented exactly as \texttt{Float64} values.


\begin{minted}{jlcon}
julia> promote_type(Int64, Float64)
Float64

julia> promote_type(Int32, Int64)
Int64

julia> promote_type(Float32, BigInt)
BigFloat
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/promotion.jl#L134-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16547112220540026290}{} 
\hyperlink{16547112220540026290}{\texttt{Base.promote\_rule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
promote_rule(type1, type2)
\end{lstlisting}

Specifies what type should be used by \hyperlink{1760874576431605095}{\texttt{promote}} when given values of types \texttt{type1} and \texttt{type2}. This function should not be called directly, but should have definitions added to it for new types as appropriate.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2086-L2092}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13312214354258464709}{} 
\hyperlink{13312214354258464709}{\texttt{Core.getfield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getfield(value, name::Symbol)
\end{lstlisting}

Extract a named field from a \texttt{value} of composite type. The syntax \texttt{a.b} calls \texttt{getfield(a, :b)}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1//2
1//2

julia> getfield(a, :num)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L836-L850}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11796708313392299971}{} 
\hyperlink{11796708313392299971}{\texttt{Core.setfield!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setfield!(value, name::Symbol, x)
\end{lstlisting}

Assign \texttt{x} to a named field in \texttt{value} of composite type. The syntax \texttt{a.b = c} calls \texttt{setfield!(a, :b, c)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1909-L1914}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6956980533195055227}{} 
\hyperlink{6956980533195055227}{\texttt{Base.fieldoffset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fieldoffset(type, i)
\end{lstlisting}

The byte offset of field \texttt{i} of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:


\begin{minted}{jlcon}
julia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:nfields(T)];

julia> structinfo(Base.Filesystem.StatStruct)
12-element Array{Tuple{UInt64,Symbol,DataType},1}:
 (0x0000000000000000, :device, UInt64)
 (0x0000000000000008, :inode, UInt64)
 (0x0000000000000010, :mode, UInt64)
 (0x0000000000000018, :nlink, Int64)
 (0x0000000000000020, :uid, UInt64)
 (0x0000000000000028, :gid, UInt64)
 (0x0000000000000030, :rdev, UInt64)
 (0x0000000000000038, :size, Int64)
 (0x0000000000000040, :blksize, Int64)
 (0x0000000000000048, :blocks, Int64)
 (0x0000000000000050, :mtime, Float64)
 (0x0000000000000058, :ctime, Float64)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L310-L334}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17091563430048909487}{} 
\hyperlink{17091563430048909487}{\texttt{Core.fieldtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fieldtype(T, name::Symbol | index::Int)
\end{lstlisting}

Determine the declared type of a field (specified by name or index) in a composite DataType \texttt{T}.


\begin{minted}{jlcon}
julia> struct Foo
           x::Int64
           y::String
       end

julia> fieldtype(Foo, :x)
Int64

julia> fieldtype(Foo, 2)
String
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L337-L354}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13869545361033105546}{} 
\hyperlink{13869545361033105546}{\texttt{Base.isimmutable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isimmutable(v)
\end{lstlisting}

Return \texttt{true} iff value \texttt{v} is immutable.  See \hyperlink{15660711504809541251}{Mutable Composite Types} for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of \texttt{DataType} is mutable.


\begin{minted}{jlcon}
julia> isimmutable(1)
true

julia> isimmutable([1,2])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L199-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12980593021531333073}{} 
\hyperlink{12980593021531333073}{\texttt{Base.isbits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isbits(T)
\end{lstlisting}

Return \texttt{true} if \texttt{T} is a {\textquotedbl}plain data{\textquotedbl} type, meaning it is immutable and contains no references to other values. Typical examples are numeric types such as \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, and \hyperlink{11302502367029942782}{\texttt{Complex\{Float64\}}}.


\begin{minted}{jlcon}
julia> isbits(Complex{Float64})
true

julia> isbits(Complex)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L218-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4142150919569135392}{} 
\hyperlink{4142150919569135392}{\texttt{Base.isleaftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isleaftype(T)
\end{lstlisting}

Determine whether \texttt{T}{\textquotesingle}s only subtypes are itself and \texttt{Union\{\}}. This means \texttt{T} is a concrete type that can have instances.


\begin{minted}{jlcon}
julia> isleaftype(Complex)
false

julia> isleaftype(Complex{Float32})
true

julia> isleaftype(Vector{Complex})
true

julia> isleaftype(Vector{Complex{Float32}})
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L237-L256}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6895589781245489183}{} 
\hyperlink{6895589781245489183}{\texttt{Base.typejoin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typejoin(T, S)
\end{lstlisting}

Compute a type that contains both \texttt{T} and \texttt{S}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1389-L1393}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1869272868531275554}{} 
\hyperlink{1869272868531275554}{\texttt{Base.typeintersect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typeintersect(T, S)
\end{lstlisting}

Compute a type that contains the intersection of \texttt{T} and \texttt{S}. Usually this will be the smallest such type or one close to it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L301-L306}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1312938105781775871}{} 
\hyperlink{1312938105781775871}{\texttt{Base.Val}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Val{c}
\end{lstlisting}

Create a {\textquotedbl}value type{\textquotedbl} out of \texttt{c}, which must be an \texttt{isbits} value. The intent of this construct is to be able to dispatch on constants, e.g., \texttt{f(Val\{false\})} allows you to dispatch directly (at compile-time) to an implementation \texttt{f(::Type\{Val\{false\}\})}, without having to test the boolean value at runtime.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2574-L2581}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18177775477210803027}{} 
\hyperlink{18177775477210803027}{\texttt{Base.Enums.@enum}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@enum EnumName[::BaseType] value1[=x] value2[=y]
\end{lstlisting}

Create an \texttt{Enum\{BaseType\}} subtype with name \texttt{EnumName} and enum member values of \texttt{value1} and \texttt{value2} with optional assigned values of \texttt{x} and \texttt{y}, respectively. \texttt{EnumName} can be used just like other types and enum member values as regular values, such as


\begin{minted}{jlcon}
julia> @enum Fruit apple=1 orange=2 kiwi=3

julia> f(x::Fruit) = "I'm a Fruit with value: $(Int(x))"
f (generic function with 1 method)

julia> f(apple)
"I'm a Fruit with value: 1"
\end{minted}

\texttt{BaseType}, which defaults to \hyperlink{10103694114785108551}{\texttt{Int32}}, must be a primitive subtype of \texttt{Integer}. Member values can be converted between the enum type and \texttt{BaseType}. \texttt{read} and \texttt{write} perform these conversions automatically.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/Enums.jl#L31-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1621796923312060494}{} 
\hyperlink{1621796923312060494}{\texttt{Base.instances}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
instances(T::Type)
\end{lstlisting}

Return a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see \texttt{@enum}).


\begin{minted}{jlcon}
julia> @enum Color red blue green

julia> instances(Color)
(red::Color = 0, blue::Color = 1, green::Color = 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L386-L398}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14185067953421617661}{}


\section{Funciones Genéricas}


\hypertarget{2744637612596423318}{} 
\hyperlink{2744637612596423318}{\texttt{Core.Function}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Function
\end{lstlisting}

Abstract type of all functions.


\begin{minted}{jlcon}
julia> isa(+, Function)
true

julia> typeof(sin)
Base.#sin

julia> ans <: Function
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L726-L741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7096441800037644952}{} 
\hyperlink{7096441800037644952}{\texttt{Base.method\_exists}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
method_exists(f, Tuple type, world=typemax(UInt)) -> Bool
\end{lstlisting}

Determine whether the given generic function has a method matching the given \texttt{Tuple} of argument types with the upper bound of world age given by \texttt{world}.


\begin{minted}{jlcon}
julia> method_exists(length, Tuple{Array})
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L921-L931}{\texttt{source}}


\end{adjustwidth}
\hypertarget{366019948759111192}{} 
\hyperlink{366019948759111192}{\texttt{Core.applicable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
applicable(f, args...) -> Bool
\end{lstlisting}

Determine whether the given generic function has a method applicable to the given arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function f(x, y)
           x + y
       end;

julia> applicable(f, 1)
false

julia> applicable(f, 1, 2)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2244-L2261}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14356043600121087376}{} 
\hyperlink{14356043600121087376}{\texttt{Core.invoke}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
invoke(f, types <: Tuple, args...)
\end{lstlisting}

Invoke a method for the given generic function matching the specified types, on the specified arguments. The arguments must be compatible with the specified types. This allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1143-L1151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15240876280767285272}{} 
\hyperlink{15240876280767285272}{\texttt{Base.invokelatest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
invokelatest(f, args...)
\end{lstlisting}

Calls \texttt{f(args...)}, but guarantees that the most recent method of \texttt{f} will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function \texttt{f}. (The drawback is that \texttt{invokelatest} is somewhat slower than calling \texttt{f} directly, and the type of the result cannot be inferred by the compiler.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L360-L369}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5135459825603202944}{} 
\hyperlink{5135459825603202944}{\texttt{Base.:|>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
|>(x, f)
\end{lstlisting}

Applies a function to the preceding argument. This allows for easy function chaining.


\begin{minted}{jlcon}
julia> [1:5;] |> x->x.^2 |> sum |> inv
0.01818181818181818
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L852-L861}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8400062617555407555}{} 
\hyperlink{8400062617555407555}{\texttt{Base.:∘}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
f ∘ g
\end{lstlisting}

Compose functions: i.e. \texttt{(f ∘ g)(args...)} means \texttt{f(g(args...))}. The \texttt{∘} symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing \texttt{{\textbackslash}circ<tab>}. Example:


\begin{minted}{jlcon}
julia> map(uppercase∘hex, 250:255)
6-element Array{String,1}:
 "FA"
 "FB"
 "FC"
 "FD"
 "FE"
 "FF"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L866-L883}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7670568709019810759}{}


\section{Sintaxis}


\hypertarget{2345597220715550879}{} 
\hyperlink{2345597220715550879}{\texttt{Core.eval}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eval([m::Module], expr::Expr)
\end{lstlisting}

Evaluate an expression in the given module and return the result. Every \texttt{Module} (except those defined with \texttt{baremodule}) has its own 1-argument definition of \texttt{eval}, which evaluates expressions in that module.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L102-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12895501458291832858}{} 
\hyperlink{12895501458291832858}{\texttt{Base.@eval}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@eval [mod,] ex
\end{lstlisting}

Evaluate an expression with values interpolated into it using \texttt{eval}. If two arguments are provided, the first is the module to evaluate in.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L46-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1049904639707765509}{} 
\hyperlink{1049904639707765509}{\texttt{Base.evalfile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
evalfile(path::AbstractString, args::Vector{String}=String[])
\end{lstlisting}

Load the file using \hyperlink{438355891087818425}{\texttt{include}}, evaluate all expressions, and return the value of the last one.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L603-L608}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17861659594346526773}{} 
\hyperlink{17861659594346526773}{\texttt{Base.esc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
esc(e::ANY)
\end{lstlisting}

Only valid in the context of an \texttt{Expr} returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the \hyperlink{11146454106624591870}{Macros} section of the Metaprogramming chapter of the manual for more details and examples.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L193-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9619263577270933060}{} 
\hyperlink{9619263577270933060}{\texttt{Base.@inbounds}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@inbounds(blk)
\end{lstlisting}

Eliminates array bounds checking within expressions.

In the example below the bound check of array A is skipped to improve performance.


\begin{minted}{julia}
function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end
\end{minted}

\begin{quote}
\textbf{Warning}

Using \texttt{@inbounds} may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L209-L230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18060766522149343036}{} 
\hyperlink{18060766522149343036}{\texttt{Base.@inline}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@inline
\end{lstlisting}

Give a hint to the compiler that this function is worth inlining.

Small functions typically do not need the \texttt{@inline} annotation, as the compiler does it automatically. By using \texttt{@inline} on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:


\begin{minted}{julia}
@inline function bigfunction(x)
    #=
        Function Definition
    =#
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L111-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13090632948127397341}{} 
\hyperlink{13090632948127397341}{\texttt{Base.@noinline}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@noinline
\end{lstlisting}

Prevents the compiler from inlining a function.

Small functions are typically inlined automatically. By using \texttt{@noinline} on small functions, auto-inlining can be prevented. This is shown in the following example:


\begin{minted}{julia}
@noinline function smallfunction(x)
    #=
        Function Definition
    =#
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L133-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3515345868651201289}{} 
\hyperlink{3515345868651201289}{\texttt{Base.gensym}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gensym([tag])
\end{lstlisting}

Generates a symbol which will not conflict with other variable names.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1574260997115674041}{} 
\hyperlink{1574260997115674041}{\texttt{Base.@gensym}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@gensym
\end{lstlisting}

Generates a gensym symbol for a variable. For example, \texttt{@gensym x y} is transformed into \texttt{x = gensym({\textquotedbl}x{\textquotedbl}); y = gensym({\textquotedbl}y{\textquotedbl})}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L18-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17097218075487180587}{} 
\hyperlink{17097218075487180587}{\texttt{Base.@polly}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@polly
\end{lstlisting}

Tells the compiler to apply the polyhedral optimizer Polly to a function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L173-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4644249546022001645}{} 
\hyperlink{4644249546022001645}{\texttt{Base.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parse(str, start; greedy=true, raise=true)
\end{lstlisting}

Parse the expression string and return an expression (which could later be passed to eval for execution). \texttt{start} is the index of the first character to start parsing. If \texttt{greedy} is \texttt{true} (default), \texttt{parse} will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return \texttt{Expr(:incomplete, {\textquotedbl}(error message){\textquotedbl})}. If \texttt{raise} is \texttt{true} (default), syntax errors other than incomplete expressions will raise an error. If \texttt{raise} is \texttt{false}, \texttt{parse} will return an expression that will raise an error upon evaluation.


\begin{minted}{jlcon}
julia> parse("x = 3, y = 5", 7)
(:(y = 5), 13)

julia> parse("x = 3, y = 5", 5)
(:((3, y) = 5), 13)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1154-L1172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12837389312481960786}{} 
\hyperlink{12837389312481960786}{\texttt{Base.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parse(str; raise=true)
\end{lstlisting}

Parse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If \texttt{raise} is \texttt{true} (default), syntax errors will raise an error; otherwise, \texttt{parse} will return an expression that will raise an error upon evaluation.


\begin{minted}{jlcon}
julia> parse("x = 3")
:(x = 3)

julia> parse("x = ")
:($(Expr(:incomplete, "incomplete: premature end of input")))

julia> parse("1.0.2")
ERROR: ParseError("invalid numeric constant \"1.0.\"")
Stacktrace:
[...]

julia> parse("1.0.2"; raise = false)
:($(Expr(:error, "invalid numeric constant \"1.0.\"")))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1175-L1198}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7136056273836631018}{}


\section{\emph{Nullables}}


\hypertarget{2208920129454296646}{} 
\hyperlink{2208920129454296646}{\texttt{Base.Nullable}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Nullable(x, hasvalue::Bool=true)
\end{lstlisting}

Wrap value \texttt{x} in an object of type \texttt{Nullable}, which indicates whether a value is present. \texttt{Nullable(x)} yields a non-empty wrapper and \texttt{Nullable\{T\}()} yields an empty instance of a wrapper that might contain a value of type \texttt{T}.

\texttt{Nullable(x, false)} yields \texttt{Nullable\{typeof(x)\}()} with \texttt{x} stored in the result{\textquotesingle}s \texttt{value} field.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Nullable(1)
Nullable{Int64}(1)

julia> Nullable{Int64}()
Nullable{Int64}()

julia> Nullable(1, false)
Nullable{Int64}()

julia> dump(Nullable(1, false))
Nullable{Int64}
  hasvalue: Bool false
  value: Int64 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L6-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18027826894922685265}{} 
\hyperlink{18027826894922685265}{\texttt{Base.get}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get(x::Nullable[, y])
\end{lstlisting}

Attempt to access the value of \texttt{x}. Returns the value if it is present; otherwise, returns \texttt{y} if provided, or throws a \texttt{NullException} if not.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L78-L83}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16547052476421706505}{} 
\hyperlink{16547052476421706505}{\texttt{Base.isnull}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isnull(x)
\end{lstlisting}

Return whether or not \texttt{x} is null for \hyperlink{2208920129454296646}{\texttt{Nullable}} \texttt{x}; return \texttt{false} for all other \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Nullable(1, false)
Nullable{Int64}()

julia> isnull(x)
true

julia> x = Nullable(1, true)
Nullable{Int64}(1)

julia> isnull(x)
false

julia> x = 1
1

julia> isnull(x)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L128-L155}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3572883435317165937}{} 
\hyperlink{3572883435317165937}{\texttt{Base.unsafe\_get}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_get(x)
\end{lstlisting}

Return the value of \texttt{x} for \hyperlink{2208920129454296646}{\texttt{Nullable}} \texttt{x}; return \texttt{x} for all other \texttt{x}.

This method does not check whether or not \texttt{x} is null before attempting to access the value of \texttt{x} for \texttt{x::Nullable} (hence {\textquotedbl}unsafe{\textquotedbl}).


\begin{minted}{jlcon}
julia> x = Nullable(1)
Nullable{Int64}(1)

julia> unsafe_get(x)
1

julia> x = Nullable{String}()
Nullable{String}()

julia> unsafe_get(x)
ERROR: UndefRefError: access to undefined reference
Stacktrace:
 [1] unsafe_get(::Nullable{String}) at ./nullable.jl:125

julia> x = 1
1

julia> unsafe_get(x)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L94-L124}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11616143092700767042}{}


\section{Sistema}


\hypertarget{18309243184998755104}{} 
\hyperlink{18309243184998755104}{\texttt{Base.run}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
run(command, args...)
\end{lstlisting}

Run a command object, constructed with backticks. Throws an error if anything goes wrong, including the process exiting with a non-zero status.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L643-L648}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16140521581008447772}{} 
\hyperlink{16140521581008447772}{\texttt{Base.spawn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
spawn(command)
\end{lstlisting}

Run a command object asynchronously, returning the resulting \texttt{Process} object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1519-L1523}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4360435189397200427}{} 
\hyperlink{4360435189397200427}{\texttt{Base.DevNull}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DevNull
\end{lstlisting}

Used in a stream redirect to discard all data written to it. Essentially equivalent to /dev/null on Unix or NUL on Windows. Usage:


\begin{minted}{julia}
run(pipeline(`cat test.txt`, DevNull))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L714-L723}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3068527349757478883}{} 
\hyperlink{3068527349757478883}{\texttt{Base.success}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
success(command)
\end{lstlisting}

Run a command object, constructed with backticks, and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L672-L677}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15578977278493337913}{} 
\hyperlink{15578977278493337913}{\texttt{Base.process\_running}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
process_running(p::Process)
\end{lstlisting}

Determine whether a process is currently running.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L728-L732}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13017420786720044448}{} 
\hyperlink{13017420786720044448}{\texttt{Base.process\_exited}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
process_exited(p::Process)
\end{lstlisting}

Determine whether a process has exited.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L737-L741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1615401929219773934}{} 
\hyperlink{1615401929219773934}{\texttt{Base.kill}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
kill(p::Process, signum=SIGTERM)
\end{lstlisting}

Send a signal to a process. The default is to terminate the process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L705-L709}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18437818836884264741}{} 
\hyperlink{18437818836884264741}{\texttt{Base.Sys.set\_process\_title}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.set_process_title(title::AbstractString)
\end{lstlisting}

Set the process title. No-op on some operating systems.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L181-L185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10090978748613293378}{} 
\hyperlink{10090978748613293378}{\texttt{Base.Sys.get\_process\_title}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.get_process_title()
\end{lstlisting}

Get the process title. On some systems, will always return an empty string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L169-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17772484058356229014}{} 
\hyperlink{17772484058356229014}{\texttt{Base.readandwrite}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readandwrite(command)
\end{lstlisting}

Starts running a command asynchronously, and returns a tuple (stdout,stdin,process) of the output stream and input stream of the process, and the process object itself.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L614-L619}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14924556434347277048}{} 
\hyperlink{14924556434347277048}{\texttt{Base.ignorestatus}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ignorestatus(command)
\end{lstlisting}

Mark a command object so that running it will not throw an error if the result code is non-zero.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L180-L184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3965292339357216921}{} 
\hyperlink{3965292339357216921}{\texttt{Base.detach}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
detach(command)
\end{lstlisting}

Mark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L189-L193}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10541952265148699805}{} 
\hyperlink{10541952265148699805}{\texttt{Base.Cmd}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)
\end{lstlisting}

Construct a new \texttt{Cmd} object, representing an external program and arguments, from \texttt{cmd}, while changing the settings of the optional keyword arguments:

\begin{itemize}
\item \texttt{ignorestatus::Bool}: If \texttt{true} (defaults to \texttt{false}), then the \texttt{Cmd} will not throw an error if the return code is nonzero.


\item \texttt{detach::Bool}: If \texttt{true} (defaults to \texttt{false}), then the \texttt{Cmd} will be run in a new process group, allowing it to outlive the \texttt{julia} process and not have Ctrl-C passed to it.


\item \texttt{windows\_verbatim::Bool}: If \texttt{true} (defaults to \texttt{false}), then on Windows the \texttt{Cmd} will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single {\textquotedbl}command-line{\textquotedbl} string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes \texttt{{\textquotedbl}} in the command line, and \texttt{{\textbackslash}} or \texttt{{\textquotedbl}} are preceded by backslashes. \texttt{windows\_verbatim=true} is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.


\item \texttt{windows\_hide::Bool}: If \texttt{true} (defaults to \texttt{false}), then on Windows no new console window is displayed when the \texttt{Cmd} is executed. This has no effect if a console is already open or on non-Windows systems.


\item \texttt{env}: Set environment variables to use when running the \texttt{Cmd}. \texttt{env} is either a dictionary mapping strings to strings, an array of strings of the form \texttt{{\textquotedbl}var=val{\textquotedbl}}, an array or tuple of \texttt{{\textquotedbl}var{\textquotedbl}=>val} pairs, or \texttt{nothing}. In order to modify (rather than replace) the existing environment, create \texttt{env} by \texttt{copy(ENV)} and then set \texttt{env[{\textquotedbl}var{\textquotedbl}]=val} as desired.


\item \texttt{dir::AbstractString}: Specify a working directory for the command (instead of the current directory).

\end{itemize}
For any keywords that are not specified, the current settings from \texttt{cmd} are used. Normally, to create a \texttt{Cmd} object in the first place, one uses backticks, e.g.


\begin{lstlisting}
Cmd(`echo "Hello world"`, ignorestatus=true, detach=false)
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L33-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14476048880059260855}{} 
\hyperlink{14476048880059260855}{\texttt{Base.setenv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setenv(command::Cmd, env; dir="")
\end{lstlisting}

Set environment variables to use when running the given \texttt{command}. \texttt{env} is either a dictionary mapping strings to strings, an array of strings of the form \texttt{{\textquotedbl}var=val{\textquotedbl}}, or zero or more \texttt{{\textquotedbl}var{\textquotedbl}=>val} pair arguments. In order to modify (rather than replace) the existing environment, create \texttt{env} by \texttt{copy(ENV)} and then setting \texttt{env[{\textquotedbl}var{\textquotedbl}]=val} as desired, or use \texttt{withenv}.

The \texttt{dir} keyword argument can be used to specify a working directory for the command.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L214-L224}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16080922180039851128}{} 
\hyperlink{16080922180039851128}{\texttt{Base.withenv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
withenv(f::Function, kv::Pair...)
\end{lstlisting}

Execute \texttt{f()} in an environment that is temporarily modified (not replaced as in \texttt{setenv}) by zero or more \texttt{{\textquotedbl}var{\textquotedbl}=>val} arguments \texttt{kv}. \texttt{withenv} is generally used via the \texttt{withenv(kv...) do ... end} syntax. A value of \texttt{nothing} can be used to temporarily unset an environment variable (if it is set). When \texttt{withenv} returns, the original environment has been restored.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/env.jl#L142-L150}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17710887576380723118}{} 
\hyperlink{17710887576380723118}{\texttt{Base.pipeline}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pipeline(from, to, ...)
\end{lstlisting}

Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other \texttt{pipeline} calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example \texttt{pipeline(a,b,c)} is equivalent to \texttt{pipeline(pipeline(a,b),c)}. This provides a more concise way to specify multi-stage pipelines.

\textbf{Examples}:


\begin{minted}{julia}
run(pipeline(`ls`, `grep xyz`))
run(pipeline(`ls`, "out.txt"))
run(pipeline("out.txt", `grep xyz`))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L283-L300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14749518171354514193}{} 
\hyperlink{14749518171354514193}{\texttt{Base.pipeline}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pipeline(command; stdin, stdout, stderr, append=false)
\end{lstlisting}

Redirect I/O to or from the given \texttt{command}. Keyword arguments specify which of the command{\textquotesingle}s streams should be redirected. \texttt{append} controls whether file output appends to the file. This is a more general version of the 2-argument \texttt{pipeline} function. \texttt{pipeline(from, to)} is equivalent to \texttt{pipeline(from, stdout=to)} when \texttt{from} is a command, and to \texttt{pipeline(to, stdin=from)} when \texttt{from} is another kind of data source.

\textbf{Examples}:


\begin{minted}{julia}
run(pipeline(`dothings`, stdout="out.txt", stderr="errs.txt"))
run(pipeline(`update`, stdout="log.txt", append=true))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L248-L263}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1938096715296079780}{} 
\hyperlink{1938096715296079780}{\texttt{Base.Libc.gethostname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gethostname() -> AbstractString
\end{lstlisting}

Get the local machine{\textquotesingle}s host name.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L236-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10073849928652659753}{} 
\hyperlink{10073849928652659753}{\texttt{Base.getipaddr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getipaddr() -> IPAddr
\end{lstlisting}

Get the IP address of the local machine.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L666-L670}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13507906219795618929}{} 
\hyperlink{13507906219795618929}{\texttt{Base.Libc.getpid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getpid() -> Int32
\end{lstlisting}

Get Julia{\textquotesingle}s process ID.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L227-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2441622941271736623}{} 
\hyperlink{2441622941271736623}{\texttt{Base.Libc.time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
time()
\end{lstlisting}

Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1926-L1930}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3638234932564609978}{} 
\hyperlink{3638234932564609978}{\texttt{Base.time\_ns}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
time_ns()
\end{lstlisting}

Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L9-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15143202356224875278}{} 
\hyperlink{15143202356224875278}{\texttt{Base.tic}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tic()
\end{lstlisting}

Set a timer to be read by the next call to \hyperlink{16488371574475401451}{\texttt{toc}} or \hyperlink{1910653784566466253}{\texttt{toq}}. The macro call \texttt{@time expr} can also be used to time evaluation.


\begin{minted}{jlcon}
julia> tic()
0x0000c45bc7abac95

julia> sleep(0.3)

julia> toc()
elapsed time: 0.302745944 seconds
0.302745944
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L79-L95}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16488371574475401451}{} 
\hyperlink{16488371574475401451}{\texttt{Base.toc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
toc()
\end{lstlisting}

Print and return the time elapsed since the last \hyperlink{15143202356224875278}{\texttt{tic}}. The macro call \texttt{@time expr} can also be used to time evaluation.


\begin{minted}{jlcon}
julia> tic()
0x0000c45bc7abac95

julia> sleep(0.3)

julia> toc()
elapsed time: 0.302745944 seconds
0.302745944
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L129-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1910653784566466253}{} 
\hyperlink{1910653784566466253}{\texttt{Base.toq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
toq()
\end{lstlisting}

Return, but do not print, the time elapsed since the last \hyperlink{15143202356224875278}{\texttt{tic}}. The macro calls \texttt{@timed expr} and \texttt{@elapsed expr} also return evaluation time.


\begin{minted}{jlcon}
julia> tic()
0x0000c46477a9675d

julia> sleep(0.3)

julia> toq()
0.302251004
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L102-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8029752041511656628}{} 
\hyperlink{8029752041511656628}{\texttt{Base.@time}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@time
\end{lstlisting}

A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.

See also \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @time rand(10^6);
  0.001525 seconds (7 allocations: 7.630 MiB)

julia> @time begin
           sleep(0.3)
           1+1
       end
  0.301395 seconds (8 allocations: 336 bytes)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L212-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16435014226257034667}{} 
\hyperlink{16435014226257034667}{\texttt{Base.@timev}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@timev
\end{lstlisting}

This is a verbose version of the \texttt{@time} macro. It first prints the same information as \texttt{@time}, then any non-zero memory allocation counters, and then returns the value of the expression.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @timev rand(10^6);
  0.001006 seconds (7 allocations: 7.630 MiB)
elapsed time (ns): 1005567
bytes allocated:   8000256
pool allocs:       6
malloc() calls:    1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L246-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6506376105249440645}{} 
\hyperlink{6506376105249440645}{\texttt{Base.@timed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@timed
\end{lstlisting}

A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> val, t, bytes, gctime, memallocs = @timed rand(10^6);

julia> t
0.006634834

julia> bytes
8000256

julia> gctime
0.0055765

julia> fieldnames(typeof(memallocs))
9-element Array{Symbol,1}:
 :allocd
 :malloc
 :realloc
 :poolalloc
 :bigalloc
 :freecall
 :total_time
 :pause
 :full_sweep

julia> memallocs.total_time
5576500
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L336-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13321256500037064321}{} 
\hyperlink{13321256500037064321}{\texttt{Base.@elapsed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@elapsed
\end{lstlisting}

A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @elapsed sleep(0.3)
0.301391426
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L276-L289}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5377755456008435782}{} 
\hyperlink{5377755456008435782}{\texttt{Base.@allocated}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@allocated
\end{lstlisting}

A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the \texttt{@time} macros, which do not try to adjust for the effects of compilation.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, and \hyperlink{13321256500037064321}{\texttt{@elapsed}}.


\begin{minted}{jlcon}
julia> @allocated rand(10^6)
8000080
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L304-L321}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15720283866375224773}{} 
\hyperlink{15720283866375224773}{\texttt{Base.EnvHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
EnvHash() -> EnvHash
\end{lstlisting}

A singleton of this type provides a hash table interface to environment variables.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/env.jl#L61-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{196658496437650743}{} 
\hyperlink{196658496437650743}{\texttt{Base.ENV}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ENV
\end{lstlisting}

Reference to the singleton \texttt{EnvHash}, providing a dictionary interface to system environment variables.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/env.jl#L68-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7664224894560703317}{} 
\hyperlink{7664224894560703317}{\texttt{Base.is\_unix}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_unix([os])
\end{lstlisting}

Predicate for testing if the OS provides a Unix-like interface. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13038973210639903213}{} 
\hyperlink{13038973210639903213}{\texttt{Base.is\_apple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_apple([os])
\end{lstlisting}

Predicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L43-L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10663187403531386839}{} 
\hyperlink{10663187403531386839}{\texttt{Base.is\_linux}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_linux([os])
\end{lstlisting}

Predicate for testing if the OS is a derivative of Linux. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L19-L24}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9955919844501906767}{} 
\hyperlink{9955919844501906767}{\texttt{Base.is\_bsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_bsd([os])
\end{lstlisting}

Predicate for testing if the OS is a derivative of BSD. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L27-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14679690639893984598}{} 
\hyperlink{14679690639893984598}{\texttt{Base.is\_windows}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_windows([os])
\end{lstlisting}

Predicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L35-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17167896699654870190}{} 
\hyperlink{17167896699654870190}{\texttt{Base.Sys.windows\_version}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.windows_version()
\end{lstlisting}

Returns the version number for the Windows NT Kernel as a (major, minor) pair, or \texttt{(0, 0)} if this is not running on Windows.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L201-L206}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15508347639286112437}{} 
\hyperlink{15508347639286112437}{\texttt{Base.@static}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@static
\end{lstlisting}

Partially evaluates an expression at parse time.

For example, \texttt{@static is\_windows() ? foo : bar} will evaluate \texttt{is\_windows()} and insert either \texttt{foo} or \texttt{bar} into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a \texttt{ccall} to a non-existent function. \texttt{@static if is\_apple() foo end} and \texttt{@static foo <\&\&,||> bar} are also valid syntax.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L51-L60}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16959204746128130100}{}


\section{Errores}


\hypertarget{17992125292605951734}{} 
\hyperlink{17992125292605951734}{\texttt{Base.error}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
error(message::AbstractString)
\end{lstlisting}

Raise an \texttt{ErrorException} with the given message.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1761-L1765}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16410366672587017456}{} 
\hyperlink{16410366672587017456}{\texttt{Core.throw}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
throw(e)
\end{lstlisting}

Throw an object as an exception.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2319-L2323}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2102349972401293064}{} 
\hyperlink{2102349972401293064}{\texttt{Base.rethrow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rethrow([e])
\end{lstlisting}

Throw an object without changing the current exception backtrace. The default argument is the current exception (if called within a \texttt{catch} block).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6187626674327343338}{} 
\hyperlink{6187626674327343338}{\texttt{Base.backtrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
backtrace()
\end{lstlisting}

Get a backtrace object for the current program point.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L41-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{98342946516168163}{} 
\hyperlink{98342946516168163}{\texttt{Base.catch\_backtrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
catch_backtrace()
\end{lstlisting}

Get the backtrace of the current exception, for use within \texttt{catch} blocks.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L48-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5092756097523818100}{} 
\hyperlink{5092756097523818100}{\texttt{Base.assert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
assert(cond)
\end{lstlisting}

Throw an \hyperlink{5674833187700802207}{\texttt{AssertionError}} if \texttt{cond} is \texttt{false}. Also available as the macro \texttt{@assert expr}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L182-L187}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4796942656392369899}{} 
\hyperlink{4796942656392369899}{\texttt{Base.@assert}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@assert cond [text]
\end{lstlisting}

Throw an \texttt{AssertionError} if \texttt{cond} is \texttt{false}. Preferred syntax for writing assertions. Message \texttt{text} is optionally displayed upon assertion failure.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1989-L1994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1600362634474051736}{} 
\hyperlink{1600362634474051736}{\texttt{Base.ArgumentError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ArgumentError(msg)
\end{lstlisting}

The parameters to a function call do not match a valid signature. Argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L27-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5674833187700802207}{} 
\hyperlink{5674833187700802207}{\texttt{Base.AssertionError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AssertionError([msg])
\end{lstlisting}

The asserted condition did not evaluate to \texttt{true}. Optional argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L79-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9731558909100893938}{} 
\hyperlink{9731558909100893938}{\texttt{Core.BoundsError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BoundsError([a],[i])
\end{lstlisting}

An indexing operation into an array, \texttt{a}, tried to access an out-of-bounds element, \texttt{i}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1136-L1140}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13752533629496758140}{} 
\hyperlink{13752533629496758140}{\texttt{Base.DimensionMismatch}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DimensionMismatch([msg])
\end{lstlisting}

The objects called do not have matching dimensionality. Optional argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L68-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4168463413201806292}{} 
\hyperlink{4168463413201806292}{\texttt{Core.DivideError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DivideError()
\end{lstlisting}

Integer division was attempted with a denominator value of 0.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2661-L2665}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14085880504701688639}{} 
\hyperlink{14085880504701688639}{\texttt{Core.DomainError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DomainError()
\end{lstlisting}

The arguments to a function or constructor are outside the valid domain.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1623-L1627}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2683611566077490148}{} 
\hyperlink{2683611566077490148}{\texttt{Base.EOFError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
EOFError()
\end{lstlisting}

No more data was available to read from a file or stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L61-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12102596058483452470}{} 
\hyperlink{12102596058483452470}{\texttt{Core.ErrorException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ErrorException(msg)
\end{lstlisting}

Generic error type. The error message, in the \texttt{.msg} field, may provide more specific details.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L693-L697}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5399118524830636312}{} 
\hyperlink{5399118524830636312}{\texttt{Core.InexactError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
InexactError()
\end{lstlisting}

Type conversion cannot be done exactly.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1609-L1613}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11255134339055983338}{} 
\hyperlink{11255134339055983338}{\texttt{Core.InterruptException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
InterruptException()
\end{lstlisting}

The process was stopped by a terminal interrupt (CTRL+C).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2048-L2052}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12862287453053981792}{} 
\hyperlink{12862287453053981792}{\texttt{Base.KeyError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
KeyError(key)
\end{lstlisting}

An indexing operation into an \texttt{Associative} (\texttt{Dict}) or \texttt{Set} like object tried to access or delete a non-existent element.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L37-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{943337379161919670}{} 
\hyperlink{943337379161919670}{\texttt{Base.LoadError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LoadError(file::AbstractString, line::Int, error)
\end{lstlisting}

An error occurred while \texttt{include}ing, \texttt{require}ing, or \texttt{using} a file. The error specifics should be available in the \texttt{.error} field.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L95-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14644228586476494020}{} 
\hyperlink{14644228586476494020}{\texttt{Base.MethodError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
MethodError(f, args)
\end{lstlisting}

A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L47-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3710635130313494548}{} 
\hyperlink{3710635130313494548}{\texttt{Base.NullException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
NullException()
\end{lstlisting}

An attempted access to a \hyperlink{2208920129454296646}{\texttt{Nullable}} with no defined value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2062-L2066}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9656432107553099418}{} 
\hyperlink{9656432107553099418}{\texttt{Core.OutOfMemoryError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
OutOfMemoryError()
\end{lstlisting}

An operation allocated too much memory for either the system or the garbage collector to handle properly.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1121-L1126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5617183776424836760}{} 
\hyperlink{5617183776424836760}{\texttt{Core.ReadOnlyMemoryError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ReadOnlyMemoryError()
\end{lstlisting}

An operation tried to write to memory that is read-only.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L357-L361}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10461069697702909970}{} 
\hyperlink{10461069697702909970}{\texttt{Core.OverflowError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
OverflowError()
\end{lstlisting}

The result of an expression is too large for the specified type and will cause a wraparound.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1822-L1826}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17891414672434519487}{} 
\hyperlink{17891414672434519487}{\texttt{Base.ParseError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ParseError(msg)
\end{lstlisting}

The expression passed to the \texttt{parse} function could not be interpreted as a valid Julia expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L17-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8063442678075539898}{} 
\hyperlink{8063442678075539898}{\texttt{Base.Distributed.ProcessExitedException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ProcessExitedException()
\end{lstlisting}

After a client Julia process has exited, further attempts to reference the dead child will throw this exception.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L815-L820}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10362102427170738683}{} 
\hyperlink{10362102427170738683}{\texttt{Core.StackOverflowError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
StackOverflowError()
\end{lstlisting}

The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1666-L1671}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16303515589950241655}{} 
\hyperlink{16303515589950241655}{\texttt{Base.SystemError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SystemError(prefix::AbstractString, [errno::Int32])
\end{lstlisting}

A system call failed with an error code (in the \texttt{errno} global variable).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2622693721821893139}{} 
\hyperlink{2622693721821893139}{\texttt{Core.TypeError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
TypeError(func::Symbol, context::AbstractString, expected::Type, got)
\end{lstlisting}

A type assertion failure, or calling an intrinsic function with an incorrect argument type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1902-L1906}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7764749529861419421}{} 
\hyperlink{7764749529861419421}{\texttt{Core.UndefRefError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UndefRefError()
\end{lstlisting}

The item or field is not defined for the given object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L749-L753}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4452889246677411554}{} 
\hyperlink{4452889246677411554}{\texttt{Core.UndefVarError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UndefVarError(var::Symbol)
\end{lstlisting}

A symbol in the current scope is not defined.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1775-L1779}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9529417803286937185}{} 
\hyperlink{9529417803286937185}{\texttt{Base.InitError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
InitError(mod::Symbol, error)
\end{lstlisting}

An error occurred when running a module{\textquotesingle}s \texttt{\_\_init\_\_} function. The actual error thrown is available in the \texttt{.error} field.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L107-L112}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13615447016541985376}{} 
\hyperlink{13615447016541985376}{\texttt{Base.retry}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
retry(f::Function;  delays=ExponentialBackOff(), check=nothing) -> Function
\end{lstlisting}

Returns an anonymous function that calls function \texttt{f}.  If an exception arises, \texttt{f} is repeatedly called again, each time \texttt{check} returns \texttt{true}, after waiting the number of seconds specified in \texttt{delays}.  \texttt{check} should input \texttt{delays}{\textquotesingle}s current state and the \texttt{Exception}.

\textbf{Examples}


\begin{minted}{julia}
retry(f, delays=fill(5.0, 3))
retry(f, delays=rand(5:10, 2))
retry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))
retry(http_get, check=(s,e)->e.status == "503")(url)
retry(read, check=(s,e)->isa(e, UVError))(io, 128; all=false)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L117-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5330798934113311579}{} 
\hyperlink{5330798934113311579}{\texttt{Base.ExponentialBackOff}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)
\end{lstlisting}

A \hyperlink{5027751419500983000}{\texttt{Float64}} iterator of length \texttt{n} whose elements exponentially increase at a rate in the interval \texttt{factor} * (1 ± \texttt{jitter}).  The first element is \texttt{first\_delay} and all elements are clamped to \texttt{max\_delay}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L98-L104}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7189567184193504348}{}


\section{Eventos}


\hypertarget{6898559495318758836}{} 
\hyperlink{6898559495318758836}{\texttt{Base.Timer}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Timer(callback::Function, delay, repeat=0)
\end{lstlisting}

Create a timer to call the given \texttt{callback} function. The \texttt{callback} is passed one argument, the timer object itself. The callback will be invoked after the specified initial \texttt{delay}, and then repeating with the given \texttt{repeat} interval. If \texttt{repeat} is \texttt{0}, the timer is only triggered once. Times are in seconds. A timer is stopped and has its resources freed by calling \hyperlink{5331333469799487255}{\texttt{close}} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L416-L424}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11288834678466677845}{} 
\hyperlink{11288834678466677845}{\texttt{Base.Timer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Timer(delay, repeat=0)
\end{lstlisting}

Create a timer that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the timer object) at a specified interval.  Times are in seconds.  Waiting tasks are woken with an error when the timer is closed (by \hyperlink{5331333469799487255}{\texttt{close}}. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether a timer is still active.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L316-L322}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6110056827764884232}{} 
\hyperlink{6110056827764884232}{\texttt{Base.AsyncCondition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AsyncCondition()
\end{lstlisting}

Create a async condition that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the object) when notified from C by a call to \texttt{uv\_async\_send}. Waiting tasks are woken with an error when the object is closed (by \hyperlink{5331333469799487255}{\texttt{close}}. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether it is still active.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L259-L267}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11991658286161618588}{} 
\hyperlink{11991658286161618588}{\texttt{Base.AsyncCondition}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AsyncCondition(callback::Function)
\end{lstlisting}

Create a async condition that calls the given \texttt{callback} function. The \texttt{callback} is passed one argument, the async condition object itself.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L289-L294}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4885888444005292595}{}


\section{Reflexión}


\hypertarget{12295122498718682195}{} 
\hyperlink{12295122498718682195}{\texttt{Base.module\_name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
module_name(m::Module) -> Symbol
\end{lstlisting}

Get the name of a \texttt{Module} as a \texttt{Symbol}.


\begin{minted}{jlcon}
julia> module_name(Base.LinAlg)
:LinAlg
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L5-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17894080543604890899}{} 
\hyperlink{17894080543604890899}{\texttt{Base.module\_parent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
module_parent(m::Module) -> Module
\end{lstlisting}

Get a module{\textquotesingle}s enclosing \texttt{Module}. \texttt{Main} is its own parent, as is \texttt{LastMain} after \texttt{workspace()}.


\begin{minted}{jlcon}
julia> module_parent(Main)
Main

julia> module_parent(Base.LinAlg.BLAS)
Base.LinAlg
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L17-L29}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14046118357995428445}{} 
\hyperlink{14046118357995428445}{\texttt{Base.current\_module}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
current_module() -> Module
\end{lstlisting}

Get the \emph{dynamically} current \texttt{Module}, which is the \texttt{Module} code is currently being read from. In general, this is not the same as the module containing the call to this function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17712571889684451973}{} 
\hyperlink{17712571889684451973}{\texttt{Base.fullname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fullname(m::Module)
\end{lstlisting}

Get the fully-qualified name of a module as a tuple of symbols. For example,


\begin{minted}{jlcon}
julia> fullname(Base.Pkg)
(:Base, :Pkg)

julia> fullname(Main)
()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L40-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6473328671144201991}{} 
\hyperlink{6473328671144201991}{\texttt{Base.names}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
names(x::Module, all::Bool=false, imported::Bool=false)
\end{lstlisting}

Get an array of the names exported by a \texttt{Module}, excluding deprecated names. If \texttt{all} is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If \texttt{imported} is true, then names explicitly imported from other modules are also included.

As a special case, all names defined in \texttt{Main} are considered {\textquotedbl}exported{\textquotedbl}, since it is not idiomatic to explicitly export names from \texttt{Main}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L75-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4268493915558726264}{} 
\hyperlink{4268493915558726264}{\texttt{Core.nfields}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nfields(x::DataType) -> Int
\end{lstlisting}

Get the number of fields of a \texttt{DataType}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1698-L1702}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17481253338332315021}{} 
\hyperlink{17481253338332315021}{\texttt{Base.fieldnames}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fieldnames(x::DataType)
\end{lstlisting}

Get an array of the fields of a \texttt{DataType}.


\begin{minted}{jlcon}
julia> fieldnames(Hermitian)
2-element Array{Symbol,1}:
 :data
 :uplo
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L124-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3835503835621011695}{} 
\hyperlink{3835503835621011695}{\texttt{Base.fieldname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fieldname(x::DataType, i::Integer)
\end{lstlisting}

Get the name of field \texttt{i} of a \texttt{DataType}.


\begin{minted}{jlcon}
julia> fieldname(SparseMatrixCSC,1)
:m

julia> fieldname(SparseMatrixCSC,5)
:nzval
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L107-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5224737502013877598}{} 
\hyperlink{5224737502013877598}{\texttt{Base.datatype\_module}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.datatype_module(t::DataType) -> Module
\end{lstlisting}

Determine the module containing the definition of a \texttt{DataType}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L155-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5132196598270925116}{} 
\hyperlink{5132196598270925116}{\texttt{Base.datatype\_name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.datatype_name(t) -> Symbol
\end{lstlisting}

Get the name of a (potentially UnionAll-wrapped) \texttt{DataType} (without its parent module) as a symbol.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L147-L151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15692280320547071693}{} 
\hyperlink{15692280320547071693}{\texttt{Base.isconst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isconst([m::Module], s::Symbol) -> Bool
\end{lstlisting}

Determine whether a global is declared \texttt{const} in a given \texttt{Module}. The default \texttt{Module} argument is \hyperlink{14046118357995428445}{\texttt{current\_module()}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L164-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6543026310027559438}{} 
\hyperlink{6543026310027559438}{\texttt{Base.function\_name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.function_name(f::Function) -> Symbol
\end{lstlisting}

Get the name of a generic \texttt{Function} as a symbol, or \texttt{:anonymous}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L856-L860}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15782281595582274098}{} 
\hyperlink{15782281595582274098}{\texttt{Base.function\_module}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.function_module(f::Function) -> Module
\end{lstlisting}

Determine the module containing the (first) definition of a generic function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L900-L905}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2162167294498760423}{} 
\hyperlink{2162167294498760423}{\texttt{Base.function\_module}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.function_module(f::Function, types) -> Module
\end{lstlisting}

Determine the module containing a given definition of a generic function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L908-L912}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4995931598335689542}{} 
\hyperlink{4995931598335689542}{\texttt{Base.functionloc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
functionloc(f::Function, types)
\end{lstlisting}

Returns a tuple \texttt{(filename,line)} giving the location of a generic \texttt{Function} definition.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L878-L882}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10700244958032489972}{} 
\hyperlink{10700244958032489972}{\texttt{Base.functionloc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
functionloc(m::Method)
\end{lstlisting}

Returns a tuple \texttt{(filename,line)} giving the location of a \texttt{Method} definition.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L865-L869}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9579246293212867177}{} 
\hyperlink{9579246293212867177}{\texttt{Base.@functionloc}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@functionloc
\end{lstlisting}

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple \texttt{(filename,line)} giving the location for the method that would be called for those arguments. It calls out to the \texttt{functionloc} function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L477-L483}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3385721083108370416}{}


\section{Interioridades}


\hypertarget{13037394137368605126}{} 
\hyperlink{13037394137368605126}{\texttt{Base.gc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gc()
\end{lstlisting}

Perform garbage collection. This should not generally be used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1782-L1786}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4474101916623001692}{} 
\hyperlink{4474101916623001692}{\texttt{Base.gc\_enable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gc_enable(on::Bool)
\end{lstlisting}

Control whether garbage collection is enabled using a boolean argument (\texttt{true} for enabled, \texttt{false} for disabled). Returns previous GC state. Disabling garbage collection should be used only with extreme caution, as it can cause memory use to grow without bound.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1806-L1812}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8018172489611994488}{} 
\hyperlink{8018172489611994488}{\texttt{Base.macroexpand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
macroexpand(x)
\end{lstlisting}

Takes the expression \texttt{x} and returns an equivalent expression with all macros removed (expanded).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L56-L60}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14913190777653949565}{} 
\hyperlink{14913190777653949565}{\texttt{Base.@macroexpand}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@macroexpand
\end{lstlisting}

Return equivalent expression with all macros removed (expanded).

There is a subtle difference between \texttt{@macroexpand} and \texttt{macroexpand} in that expansion takes place in different contexts. This is best seen in the following example:


\begin{minted}{jlcon}
julia> module M
           macro m()
               1
           end
           function f()
               (@macroexpand(@m), macroexpand(:(@m)))
           end
       end
M

julia> macro m()
           2
       end
@m (macro with 1 method)

julia> M.f()
(1, 2)
\end{minted}

With \texttt{@macroexpand} the expression expands where \texttt{@macroexpand} appears in the code (module \texttt{M} in the example). With \texttt{macroexpand} the expression expands in the current module where the code was finally called (REPL in the example). Note that when calling \texttt{macroexpand} or \texttt{@macroexpand} directly from the REPL, both of these contexts coincide, hence there is no difference.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L63-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14846157655101111909}{} 
\hyperlink{14846157655101111909}{\texttt{Base.expand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
expand(x)
\end{lstlisting}

Takes the expression \texttt{x} and returns an equivalent expression in lowered form. See also \hyperlink{18235967286596219009}{\texttt{code\_lowered}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L48-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18235967286596219009}{} 
\hyperlink{18235967286596219009}{\texttt{Base.code\_lowered}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_lowered(f, types)
\end{lstlisting}

Returns an array of lowered ASTs for the methods matching the given generic function and type signature.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L479-L483}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10170271820987078660}{} 
\hyperlink{10170271820987078660}{\texttt{Base.@code\_lowered}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_lowered
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{18235967286596219009}{\texttt{code\_lowered}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L502-L507}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14801595959157535515}{} 
\hyperlink{14801595959157535515}{\texttt{Base.code\_typed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_typed(f, types; optimize=true)
\end{lstlisting}

Returns an array of lowered and type-inferred ASTs for the methods matching the given generic function and type signature. The keyword argument \texttt{optimize} controls whether additional optimizations, such as inlining, are also applied.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L766-L772}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12279119633919839581}{} 
\hyperlink{12279119633919839581}{\texttt{Base.@code\_typed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_typed
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{14801595959157535515}{\texttt{code\_typed}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L486-L491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16883039507765569860}{} 
\hyperlink{16883039507765569860}{\texttt{Base.code\_warntype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_warntype([io::IO], f, types)
\end{lstlisting}

Prints lowered and type-inferred ASTs for the methods matching the given generic function and type signature to \texttt{io} which defaults to \texttt{STDOUT}. The ASTs are annotated in such a way as to cause {\textquotedbl}non-leaf{\textquotedbl} types to be emphasized (if color is available, displayed in red). This serves as a warning of potential type instability. Not all non-leaf types are particularly problematic for performance, so the results need to be used judiciously. See \hyperlink{7082991166860772411}{\texttt{@code\_warntype}} for more information.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L316-L325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7509450972834198661}{} 
\hyperlink{7509450972834198661}{\texttt{Base.@code\_warntype}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_warntype
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{16883039507765569860}{\texttt{code\_warntype}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L494-L499}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17587317969597936788}{} 
\hyperlink{17587317969597936788}{\texttt{Base.code\_llvm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_llvm([io], f, types)
\end{lstlisting}

Prints the LLVM bitcodes generated for running the method matching the given generic function and type signature to \texttt{io} which defaults to \texttt{STDOUT}.

All metadata and dbg.* calls are removed from the printed bitcode. Use code\_llvm\_raw for the full IR.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L732-L739}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4715999780877895760}{} 
\hyperlink{4715999780877895760}{\texttt{Base.@code\_llvm}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_llvm
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{17587317969597936788}{\texttt{code\_llvm}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L510-L515}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1731537926898979255}{} 
\hyperlink{1731537926898979255}{\texttt{Base.code\_native}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_native([io], f, types, [syntax])
\end{lstlisting}

Prints the native assembly instructions generated for running the method matching the given generic function and type signature to \texttt{io} which defaults to \texttt{STDOUT}. Switch assembly syntax using \texttt{syntax} symbol parameter set to \texttt{:att} for AT\&T syntax or \texttt{:intel} for Intel syntax. Output is AT\&T syntax by default.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L745-L751}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2366615256687729425}{} 
\hyperlink{2366615256687729425}{\texttt{Base.@code\_native}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_native
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{1731537926898979255}{\texttt{code\_native}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L518-L523}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11532354486541587545}{} 
\hyperlink{11532354486541587545}{\texttt{Base.precompile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
precompile(f,args::Tuple{Vararg{Any}})
\end{lstlisting}

Compile the given function \texttt{f} for the argument tuple (of types) \texttt{args}, but do not execute it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1404-L1408}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4056407506084571511}{}


\chapter{Colecciones y Estructuras de Datos}



\hypertarget{405296213558195800}{}


\section{Iteración}



La iteración secuencial es implementada por los métodos \hyperlink{1075601569170970796}{\texttt{start()}}, \hyperlink{6277510345882109527}{\texttt{done()}} y \hyperlink{11903630693622759236}{\texttt{next()}}. El bucle \texttt{for} general:




\begin{minted}{julia}
for i = I   # or  "for i in I"
    # body
end
\end{minted}



es traducido a:




\begin{minted}{julia}
state = start(I)
while !done(I, state)
    (i, state) = next(I, state)
    # body
end
\end{minted}



El objeto \texttt{state} puede ser cualquier cosa, y debería ser elegido apropiadamente para cada tipo iterable. Ver la \hyperlink{5510379658285713272}{sección de manual sobre la interfaz de iteración} para ms detalles sobre detinir un tipo iterable personalizado.


\hypertarget{1075601569170970796}{} 
\hyperlink{1075601569170970796}{\texttt{Base.start}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
start(iter) -> state
\end{lstlisting}

Get initial iteration state for an iterable object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> start(1:5)
1

julia> start([1;2;3])
1

julia> start([4;2;3])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2119-L2135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6277510345882109527}{} 
\hyperlink{6277510345882109527}{\texttt{Base.done}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
done(iter, state) -> Bool
\end{lstlisting}

Test whether we are done iterating.

\textbf{Examples}


\begin{minted}{jlcon}
julia> done(1:5, 3)
false

julia> done(1:5, 5)
false

julia> done(1:5, 6)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2154-L2170}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11903630693622759236}{} 
\hyperlink{11903630693622759236}{\texttt{Base.next}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
next(iter, state) -> item, state
\end{lstlisting}

For a given iterable object and iteration state, return the current item and the next iteration state.

\textbf{Examples}


\begin{minted}{jlcon}
julia> next(1:5, 3)
(3, 4)

julia> next(1:5, 5)
(5, 6)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1098-L1111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14791729846404811261}{} 
\hyperlink{14791729846404811261}{\texttt{Base.iteratorsize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iteratorsize(itertype::Type) -> IteratorSize
\end{lstlisting}

Given the type of an iterator, returns one of the following values:

\begin{itemize}
\item \texttt{SizeUnknown()} if the length (number of elements) cannot be determined in advance.


\item \texttt{HasLength()} if there is a fixed, finite length.


\item \texttt{HasShape()} if there is a known length plus a notion of multidimensional shape (as for an array).  In this case the \hyperlink{17888996102305087038}{\texttt{size}} function is valid for the iterator.


\item \texttt{IsInfinite()} if the iterator yields values forever.

\end{itemize}
The default value (for iterators that do not define this function) is \texttt{HasLength()}. This means that most iterators are assumed to implement \hyperlink{3699181304419743826}{\texttt{length}}.

This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.


\begin{minted}{jlcon}
julia> Base.iteratorsize(1:5)
Base.HasShape()

julia> Base.iteratorsize((2,3))
Base.HasLength()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/generator.jl#L57-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10753302439396218154}{} 
\hyperlink{10753302439396218154}{\texttt{Base.iteratoreltype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iteratoreltype(itertype::Type) -> IteratorEltype
\end{lstlisting}

Given the type of an iterator, returns one of the following values:

\begin{itemize}
\item \texttt{EltypeUnknown()} if the type of elements yielded by the iterator is not known in advance.


\item \texttt{HasEltype()} if the element type is known, and \hyperlink{6396209842929672718}{\texttt{eltype}} would return a meaningful value.

\end{itemize}
\texttt{HasEltype()} is the default, since iterators are assumed to implement \hyperlink{6396209842929672718}{\texttt{eltype}}.

This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.


\begin{minted}{jlcon}
julia> Base.iteratoreltype(1:5)
Base.HasEltype()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/generator.jl#L89-L107}{\texttt{source}}


\end{adjustwidth}

Completamente implementada por:



\begin{itemize}
\item \texttt{Range}


\item \texttt{UnitRange}


\item \texttt{Tuple}


\item \texttt{Number}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \hyperlink{8428136537376557806}{\texttt{IntSet}}


\item \hyperlink{11235697656281157373}{\texttt{ObjectIdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{EachLine}


\item \texttt{AbstractString}


\item \hyperlink{1143189053501747033}{\texttt{Set}}

\end{itemize}


\hypertarget{9429531226828783809}{}


\section{Colecciones generales}


\hypertarget{16079064795802595318}{} 
\hyperlink{16079064795802595318}{\texttt{Base.isempty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isempty(collection) -> Bool
\end{lstlisting}

Determine whether a collection is empty (has no elements).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isempty([])
true

julia> isempty([1 2 3])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1586-L1599}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014622222736498057}{} 
\hyperlink{11014622222736498057}{\texttt{Base.empty!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
empty!(collection) -> collection
\end{lstlisting}

Remove all elements from a \texttt{collection}.


\begin{minted}{jlcon}
julia> A = Dict("a" => 1, "b" => 2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> empty!(A);

julia> A
Dict{String,Int64} with 0 entries
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L286-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4781133548011803693}{} 
\hyperlink{4781133548011803693}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
length(collection) -> Integer
\end{lstlisting}

For ordered, indexable collections, returns the maximum index \texttt{i} for which \texttt{getindex(collection, i)} is valid. For unordered collections, returns the number of elements.

\textbf{Examples}


\begin{minted}{jlcon}
julia> length(1:5)
5

julia> length([1; 2; 3; 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2008-L2023}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7288835006555308491}{} 
\hyperlink{7288835006555308491}{\texttt{Base.endof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
endof(collection) -> Integer
\end{lstlisting}

Returns the last index of the collection.

\textbf{Example}


\begin{minted}{jlcon}
julia> endof([1,2,4])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1085-L1095}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \texttt{Range}


\item \texttt{UnitRange}


\item \texttt{Tuple}


\item \texttt{Number}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \hyperlink{8428136537376557806}{\texttt{IntSet}}


\item \hyperlink{11235697656281157373}{\texttt{ObjectIdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{AbstractString}


\item \hyperlink{1143189053501747033}{\texttt{Set}}

\end{itemize}


\hypertarget{9478060066348011050}{}


\section{Colecciones Iterables}


\hypertarget{17277603976666670638}{} 
\hyperlink{17277603976666670638}{\texttt{Base.in}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
in(item, collection) -> Bool
∈(item,collection) -> Bool
∋(collection,item) -> Bool
∉(item,collection) -> Bool
∌(collection,item) -> Bool
\end{lstlisting}

Determine whether an item is in the given collection, in the sense that it is \texttt{==} to one of the values generated by iterating over the collection. Some collections need a slightly different definition; for example \hyperlink{1143189053501747033}{\texttt{Set}}s check whether the item \hyperlink{12829995639916057841}{\texttt{isequal}} to one of the elements. \hyperlink{3089397136845322041}{\texttt{Dict}}s look for \texttt{(key,value)} pairs, and the key is compared using \hyperlink{12829995639916057841}{\texttt{isequal}}. To test for the presence of a key in a dictionary, use \hyperlink{16178429961779994033}{\texttt{haskey}} or \texttt{k in keys(dict)}.


\begin{minted}{jlcon}
julia> a = 1:3:20
1:3:19

julia> 4 in a
true

julia> 5 in a
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L606-L630}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6396209842929672718}{} 
\hyperlink{6396209842929672718}{\texttt{Base.eltype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eltype(type)
\end{lstlisting}

Determine the type of the elements generated by iterating a collection of the given \texttt{type}. For associative collection types, this will be a \texttt{Pair\{KeyType,ValType\}}. The definition \texttt{eltype(x) = eltype(typeof(x))} is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.


\begin{minted}{jlcon}
julia> eltype(ones(Float32,2,2))
Float32

julia> eltype(ones(Int8,2,2))
Int8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L26-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16333903346703258373}{} 
\hyperlink{16333903346703258373}{\texttt{Base.indexin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indexin(a, b)
\end{lstlisting}

Returns a vector containing the highest index in \texttt{b} for each value in \texttt{a} that is a member of \texttt{b} . The output vector contains 0 wherever \texttt{a} is not a member of \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = ['a', 'b', 'c', 'b', 'd', 'a'];

julia> b = ['a','b','c'];

julia> indexin(a,b)
6-element Array{Int64,1}:
 1
 2
 3
 2
 0
 1

julia> indexin(b,a)
3-element Array{Int64,1}:
 6
 4
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1779-L1807}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17244150057565634576}{} 
\hyperlink{17244150057565634576}{\texttt{Base.findin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findin(a, b)
\end{lstlisting}

Returns the indices of elements in collection \texttt{a} that appear in collection \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = collect(1:3:15)
5-element Array{Int64,1}:
  1
  4
  7
 10
 13

julia> b = collect(2:4:10)
3-element Array{Int64,1}:
  2
  6
 10

julia> findin(a,b) # 10 is the only common element
1-element Array{Int64,1}:
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1813-L1838}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11470702940123921114}{} 
\hyperlink{11470702940123921114}{\texttt{Base.unique}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unique(itr)
\end{lstlisting}

Returns an array containing one value from \texttt{itr} for each unique value, as determined by \hyperlink{12829995639916057841}{\texttt{isequal}}.


\begin{minted}{jlcon}
julia> unique([1; 2; 2; 6])
3-element Array{Int64,1}:
 1
 2
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/set.jl#L115-L128}{\texttt{source}}



\begin{lstlisting}
unique(f, itr)
\end{lstlisting}

Returns an array containing one value from \texttt{itr} for each unique value produced by \texttt{f} applied to elements of \texttt{itr}.


\begin{minted}{jlcon}
julia> unique(isodd, [1; 2; 2; 6])
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/set.jl#L170-L182}{\texttt{source}}



\begin{lstlisting}
unique(itr[, dim])
\end{lstlisting}

Returns an array containing only the unique elements of the iterable \texttt{itr}, in the order that the first of each set of equivalent elements originally appears. If \texttt{dim} is specified, returns unique regions of the array \texttt{itr} along \texttt{dim}.


\begin{minted}{jlcon}
julia> A = map(isodd, reshape(collect(1:8), (2,2,2)))
2×2×2 Array{Bool,3}:
[:, :, 1] =
  true   true
 false  false

[:, :, 2] =
  true   true
 false  false

julia> unique(A)
2-element Array{Bool,1}:
  true
 false

julia> unique(A, 2)
2×1×2 Array{Bool,3}:
[:, :, 1] =
  true
 false

[:, :, 2] =
  true
 false

julia> unique(A, 3)
2×2×1 Array{Bool,3}:
[:, :, 1] =
  true   true
 false  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L1353-L1392}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7704267519153156361}{} 
\hyperlink{7704267519153156361}{\texttt{Base.allunique}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
allunique(itr) -> Bool
\end{lstlisting}

Return \texttt{true} if all values from \texttt{itr} are distinct when compared with \hyperlink{12829995639916057841}{\texttt{isequal}}.


\begin{minted}{jlcon}
julia> a = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> allunique([a, a])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/set.jl#L196-L211}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2662613255229698805}{} 
\hyperlink{2662613255229698805}{\texttt{Base.reduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reduce(op, v0, itr)
\end{lstlisting}

Reduce the given collection \texttt{ìtr} with the given binary operator \texttt{op}. \texttt{v0} must be a neutral element for \texttt{op} that will be returned for empty collections. It is unspecified whether \texttt{v0} is used for non-empty collections.

Reductions for certain commonly-used operators have special implementations which should be used instead: \texttt{maximum(itr)}, \texttt{minimum(itr)}, \texttt{sum(itr)}, \texttt{prod(itr)}, \texttt{any(itr)}, \texttt{all(itr)}.

The associativity of the reduction is implementation dependent. This means that you can{\textquotesingle}t use non-associative operations like \texttt{-} because it is undefined whether \texttt{reduce(-,[1,2,3])} should be evaluated as \texttt{(1-2)-3} or \texttt{1-(2-3)}. Use \hyperlink{10555237964956281648}{\texttt{foldl}} or \hyperlink{13997312259064792310}{\texttt{foldr}} instead for guaranteed left or right associativity.

Some operations accumulate error, and parallelism will also be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reduce(*, 1, [2; 3; 4])
24
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L289-L315}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12844407765882691496}{} 
\hyperlink{12844407765882691496}{\texttt{Base.reduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reduce(op, itr)
\end{lstlisting}

Like \texttt{reduce(op, v0, itr)}. This cannot be used with empty collections, except for some special cases (e.g. when \texttt{op} is one of \texttt{+}, \texttt{*}, \texttt{max}, \texttt{min}, \texttt{\&}, \texttt{|}) when Julia can determine the neutral element of \texttt{op}.


\begin{minted}{jlcon}
julia> reduce(*, [2; 3; 4])
24
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L318-L329}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10555237964956281648}{} 
\hyperlink{10555237964956281648}{\texttt{Base.foldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foldl(op, v0, itr)
\end{lstlisting}

Like \hyperlink{2662613255229698805}{\texttt{reduce}}, but with guaranteed left associativity. \texttt{v0} will be used exactly once.


\begin{minted}{jlcon}
julia> foldl(-, 1, 2:5)
-13
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L76-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3612301023460122482}{} 
\hyperlink{3612301023460122482}{\texttt{Base.foldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foldl(op, itr)
\end{lstlisting}

Like \texttt{foldl(op, v0, itr)}, but using the first element of \texttt{itr} as \texttt{v0}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).


\begin{minted}{jlcon}
julia> foldl(-, 2:5)
-10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L89-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13997312259064792310}{} 
\hyperlink{13997312259064792310}{\texttt{Base.foldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foldr(op, v0, itr)
\end{lstlisting}

Like \hyperlink{2662613255229698805}{\texttt{reduce}}, but with guaranteed right associativity. \texttt{v0} will be used exactly once.


\begin{minted}{jlcon}
julia> foldr(-, 1, 2:5)
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L142-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4241312416601225037}{} 
\hyperlink{4241312416601225037}{\texttt{Base.foldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foldr(op, itr)
\end{lstlisting}

Like \texttt{foldr(op, v0, itr)}, but using the last element of \texttt{itr} as \texttt{v0}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).


\begin{minted}{jlcon}
julia> foldr(-, 2:5)
-2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L155-L165}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10566500735406837086}{} 
\hyperlink{10566500735406837086}{\texttt{Base.maximum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
maximum(itr)
\end{lstlisting}

Returns the largest element in a collection.


\begin{minted}{jlcon}
julia> maximum(-20.5:10)
9.5

julia> maximum([1,2,3])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L441-L453}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9034891716194434843}{} 
\hyperlink{9034891716194434843}{\texttt{Base.maximum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
maximum(A, dims)
\end{lstlisting}

Compute the maximum value of an array over the given dimensions. See also the \hyperlink{7839419811914289844}{\texttt{max(a,b)}} function to take the maximum of two or more arguments, which can be applied elementwise to arrays via \texttt{max.(a,b)}.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> maximum(A, 1)
1×2 Array{Int64,2}:
 3  4

julia> maximum(A, 2)
2×1 Array{Int64,2}:
 2
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L378-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8410756622363562035}{} 
\hyperlink{8410756622363562035}{\texttt{Base.maximum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
maximum!(r, A)
\end{lstlisting}

Compute the maximum value of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> maximum!([1; 1], A)
2-element Array{Int64,1}:
 2
 4

julia> maximum!([1 1], A)
1×2 Array{Int64,2}:
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L403-L424}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5463833925251886106}{} 
\hyperlink{5463833925251886106}{\texttt{Base.minimum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minimum(itr)
\end{lstlisting}

Returns the smallest element in a collection.


\begin{minted}{jlcon}
julia> minimum(-20.5:10)
-20.5

julia> minimum([1,2,3])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L456-L468}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3689019602970178455}{} 
\hyperlink{3689019602970178455}{\texttt{Base.minimum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minimum(A, dims)
\end{lstlisting}

Compute the minimum value of an array over the given dimensions. See also the \hyperlink{7458766354532817148}{\texttt{min(a,b)}} function to take the minimum of two or more arguments, which can be applied elementwise to arrays via \texttt{min.(a,b)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> minimum(A, 1)
1×2 Array{Int64,2}:
 1  2

julia> minimum(A, 2)
2×1 Array{Int64,2}:
 1
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L427-L450}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15755225581375550665}{} 
\hyperlink{15755225581375550665}{\texttt{Base.minimum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minimum!(r, A)
\end{lstlisting}

Compute the minimum value of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> minimum!([1; 1], A)
2-element Array{Int64,1}:
 1
 3

julia> minimum!([1 1], A)
1×2 Array{Int64,2}:
 1  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L453-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3146721823766527688}{} 
\hyperlink{3146721823766527688}{\texttt{Base.extrema}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
extrema(itr) -> Tuple
\end{lstlisting}

Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.


\begin{minted}{jlcon}
julia> extrema(2:10)
(2, 10)

julia> extrema([9,pi,4.5])
(3.141592653589793, 9.0)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L476-L488}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3049658346780856618}{} 
\hyperlink{3049658346780856618}{\texttt{Base.extrema}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
extrema(A, dims) -> Array{Tuple}
\end{lstlisting}

Compute the minimum and maximum elements of an array over the given dimensions.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = reshape(collect(1:2:16), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  5
 3  7

[:, :, 2] =
  9  13
 11  15

julia> extrema(A, (1,2))
1×1×2 Array{Tuple{Int64,Int64},3}:
[:, :, 1] =
 (1, 7)

[:, :, 2] =
 (9, 15)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L1464-L1489}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9729163628056325681}{} 
\hyperlink{9729163628056325681}{\texttt{Base.indmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indmax(itr) -> Integer
\end{lstlisting}

Returns the index of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned. \texttt{NaN} values are ignored, unless all elements are \texttt{NaN}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> indmax([8,0.1,-9,pi])
1

julia> indmax([1,7,7,6])
2

julia> indmax([1,7,7,NaN])
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1732-L1752}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15078154128225819537}{} 
\hyperlink{15078154128225819537}{\texttt{Base.indmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indmin(itr) -> Integer
\end{lstlisting}

Returns the index of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned. \texttt{NaN} values are ignored, unless all elements are \texttt{NaN}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> indmin([8,0.1,-9,pi])
3

julia> indmin([7,1,1,6])
2

julia> indmin([7,1,1,NaN])
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1755-L1775}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13469499455756199806}{} 
\hyperlink{13469499455756199806}{\texttt{Base.findmax}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmax(itr) -> (x, index)
\end{lstlisting}

Returns the maximum element of the collection \texttt{itr} and its index. If there are multiple maximal elements, then the first one will be returned. \texttt{NaN} values are ignored, unless all elements are \texttt{NaN}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findmax([8,0.1,-9,pi])
(8.0, 1)

julia> findmax([1,7,7,6])
(7, 2)

julia> findmax([1,7,7,NaN])
(7.0, 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1654-L1674}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13261215783822577177}{} 
\hyperlink{13261215783822577177}{\texttt{Base.findmax}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmax(A, region) -> (maxval, index)
\end{lstlisting}

For an array input, returns the value and index of the maximum over the given region.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> findmax(A,1)
([3 4], [2 4])

julia> findmax(A,2)
([2; 4], [3; 4])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L687-L705}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11896407635566615538}{} 
\hyperlink{11896407635566615538}{\texttt{Base.findmin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmin(itr) -> (x, index)
\end{lstlisting}

Returns the minimum element of the collection \texttt{itr} and its index. If there are multiple minimal elements, then the first one will be returned. \texttt{NaN} values are ignored, unless all elements are \texttt{NaN}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findmin([8,0.1,-9,pi])
(-9.0, 3)

julia> findmin([7,1,1,6])
(1, 2)

julia> findmin([7,1,1,NaN])
(1.0, 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1693-L1713}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17274328252977351321}{} 
\hyperlink{17274328252977351321}{\texttt{Base.findmin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmin(A, region) -> (minval, index)
\end{lstlisting}

For an array input, returns the value and index of the minimum over the given region.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> findmin(A, 1)
([1 2], [1 3])

julia> findmin(A, 2)
([1; 3], [1; 2])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L648-L666}{\texttt{source}}


\end{adjustwidth}
\hypertarget{585571988055972211}{} 
\hyperlink{585571988055972211}{\texttt{Base.findmax!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmax!(rval, rind, A, [init=true]) -> (maxval, index)
\end{lstlisting}

Find the maximum of \texttt{A} and the corresponding linear index along singleton dimensions of \texttt{rval} and \texttt{rind}, and store the results in \texttt{rval} and \texttt{rind}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L676-L681}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6616116230203866531}{} 
\hyperlink{6616116230203866531}{\texttt{Base.findmin!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmin!(rval, rind, A, [init=true]) -> (minval, index)
\end{lstlisting}

Find the minimum of \texttt{A} and the corresponding linear index along singleton dimensions of \texttt{rval} and \texttt{rind}, and store the results in \texttt{rval} and \texttt{rind}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L637-L642}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8666686648688281595}{} 
\hyperlink{8666686648688281595}{\texttt{Base.sum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sum(f, itr)
\end{lstlisting}

Sum the results of calling function \texttt{f} on each element of \texttt{itr}.


\begin{minted}{jlcon}
julia> sum(abs2, [2; 3; 4])
29
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L337-L346}{\texttt{source}}



\begin{lstlisting}
sum(itr)
\end{lstlisting}

Returns the sum of all elements in a collection.


\begin{minted}{jlcon}
julia> sum(1:20)
210
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L349-L358}{\texttt{source}}



\begin{lstlisting}
sum(A, dims)
\end{lstlisting}

Sum elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> sum(A, 1)
1×2 Array{Int64,2}:
 4  6

julia> sum(A, 2)
2×1 Array{Int64,2}:
 3
 7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L282-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6277092149981507138}{} 
\hyperlink{6277092149981507138}{\texttt{Base.sum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sum!(r, A)
\end{lstlisting}

Sum elements of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> sum!([1; 1], A)
2-element Array{Int64,1}:
 3
 7

julia> sum!([1 1], A)
1×2 Array{Int64,2}:
 4  6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L306-L327}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13484084847910116333}{} 
\hyperlink{13484084847910116333}{\texttt{Base.prod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prod(f, itr)
\end{lstlisting}

Returns the product of \texttt{f} applied to each element of \texttt{itr}.


\begin{minted}{jlcon}
julia> prod(abs2, [2; 3; 4])
576
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L395-L404}{\texttt{source}}



\begin{lstlisting}
prod(itr)
\end{lstlisting}

Returns the product of all elements of a collection.


\begin{minted}{jlcon}
julia> prod(1:20)
2432902008176640000
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L407-L416}{\texttt{source}}



\begin{lstlisting}
prod(A, dims)
\end{lstlisting}

Multiply elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> prod(A, 1)
1×2 Array{Int64,2}:
 3  8

julia> prod(A, 2)
2×1 Array{Int64,2}:
  2
 12
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L330-L351}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15969471860599880580}{} 
\hyperlink{15969471860599880580}{\texttt{Base.prod!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prod!(r, A)
\end{lstlisting}

Multiply elements of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> prod!([1; 1], A)
2-element Array{Int64,1}:
  2
 12

julia> prod!([1 1], A)
1×2 Array{Int64,2}:
 3  8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L354-L375}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14612039032155203548}{} 
\hyperlink{14612039032155203548}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
any(itr) -> Bool
\end{lstlisting}

Test whether any elements of a boolean collection are \texttt{true}, returning \texttt{true} as soon as the first \texttt{true} value in \texttt{itr} is encountered (short-circuiting).


\begin{minted}{jlcon}
julia> a = [true,false,false,true]
4-element Array{Bool,1}:
  true
 false
 false
  true

julia> any(a)
true

julia> any((println(i); v) for (i, v) in enumerate(a))
1
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L504-L525}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13269987351988461926}{} 
\hyperlink{13269987351988461926}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
any(A, dims)
\end{lstlisting}

Test whether any values along the given dimensions of an array are \texttt{true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia> any(A, 1)
1×2 Array{Bool,2}:
 true  false

julia> any(A, 2)
2×1 Array{Bool,2}:
 true
 true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L525-L546}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8281403281900865383}{} 
\hyperlink{8281403281900865383}{\texttt{Base.any!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
any!(r, A)
\end{lstlisting}

Test whether any values in \texttt{A} along the singleton dimensions of \texttt{r} are \texttt{true}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia> any!([1; 1], A)
2-element Array{Int64,1}:
 1
 1

julia> any!([1 1], A)
1×2 Array{Int64,2}:
 1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L549-L571}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7942004983516218646}{} 
\hyperlink{7942004983516218646}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
all(itr) -> Bool
\end{lstlisting}

Test whether all elements of a boolean collection are \texttt{true}, returning \texttt{false} as soon as the first \texttt{false} value in \texttt{itr} is encountered (short-circuiting).


\begin{minted}{jlcon}
julia> a = [true,false,false,true]
4-element Array{Bool,1}:
  true
 false
 false
  true

julia> all(a)
false

julia> all((println(i); v) for (i, v) in enumerate(a))
1
2
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L528-L550}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2312198897330859084}{} 
\hyperlink{2312198897330859084}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
all(A, dims)
\end{lstlisting}

Test whether all values along the given dimensions of an array are \texttt{true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true true]
2×2 Array{Bool,2}:
 true  false
 true   true

julia> all(A, 1)
1×2 Array{Bool,2}:
 true  false

julia> all(A, 2)
2×1 Array{Bool,2}:
 false
  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L477-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1382810654686121973}{} 
\hyperlink{1382810654686121973}{\texttt{Base.all!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
all!(r, A)
\end{lstlisting}

Test whether all values in \texttt{A} along the singleton dimensions of \texttt{r} are \texttt{true}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia> all!([1; 1], A)
2-element Array{Int64,1}:
 0
 0

julia> all!([1 1], A)
1×2 Array{Int64,2}:
 1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L501-L522}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4123799324867706690}{} 
\hyperlink{4123799324867706690}{\texttt{Base.count}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
count(p, itr) -> Integer
count(itr) -> Integer
\end{lstlisting}

Count the number of elements in \texttt{itr} for which predicate \texttt{p} returns \texttt{true}. If \texttt{p} is omitted, counts the number of \texttt{true} elements in \texttt{itr} (which should be a collection of boolean values).


\begin{minted}{jlcon}
julia> count(i->(4<=i<=6), [2,3,4,5,6])
3

julia> count([true, false, true, true])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L673-L688}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5656508174326485968}{} 
\hyperlink{5656508174326485968}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
any(p, itr) -> Bool
\end{lstlisting}

Determine whether predicate \texttt{p} returns \texttt{true} for any elements of \texttt{itr}, returning \texttt{true} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{true} is encountered (short-circuiting).


\begin{minted}{jlcon}
julia> any(i->(4<=i<=6), [3,5,7])
true

julia> any(i -> (println(i); i > 3), 1:10)
1
2
3
4
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L553-L571}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8835516150928560592}{} 
\hyperlink{8835516150928560592}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
all(p, itr) -> Bool
\end{lstlisting}

Determine whether predicate \texttt{p} returns \texttt{true} for all elements of \texttt{itr}, returning \texttt{false} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{false} is encountered (short-circuiting).


\begin{minted}{jlcon}
julia> all(i->(4<=i<=6), [4,5,6])
true

julia> all(i -> (println(i); i < 3), 1:10)
1
2
3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L579-L596}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8999415072542722396}{} 
\hyperlink{8999415072542722396}{\texttt{Base.foreach}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foreach(f, c...) -> Void
\end{lstlisting}

Call function \texttt{f} on each element of iterable \texttt{c}. For multiple iterable arguments, \texttt{f} is called elementwise. \texttt{foreach} should be used instead of \texttt{map} when the results of \texttt{f} are not needed, for example in \texttt{foreach(println, array)}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1:3:7;

julia> foreach(x -> println(x^2), a)
1
16
49
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1714-L1731}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11483231213869150535}{} 
\hyperlink{11483231213869150535}{\texttt{Base.map}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
map(f, c...) -> collection
\end{lstlisting}

Transform collection \texttt{c} by applying \texttt{f} to each element. For multiple collection arguments, apply \texttt{f} elementwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> map(x -> x * 2, [1, 2, 3])
3-element Array{Int64,1}:
 2
 4
 6

julia> map(+, [1, 2, 3], [10, 20, 30])
3-element Array{Int64,1}:
 11
 22
 33
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1871-L1891}{\texttt{source}}



\begin{lstlisting}
map(f, x::Nullable)
\end{lstlisting}

Return \texttt{f} applied to the value of \texttt{x} if it has one, as a \texttt{Nullable}. If \texttt{x} is null, then return a null value of type \texttt{Nullable\{S\}}. \texttt{S} is guaranteed to be either \texttt{Union\{\}} or a concrete type. Whichever of these is chosen is an implementation detail, but typically the choice that maximizes performance would be used. If \texttt{x} has a value, then the return type is guaranteed to be of type \texttt{Nullable\{typeof(f(x))\}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L270-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11037843636480523134}{} 
\hyperlink{11037843636480523134}{\texttt{Base.map!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
map!(function, destination, collection...)
\end{lstlisting}

Like \hyperlink{11483231213869150535}{\texttt{map}}, but stores the result in \texttt{destination} rather than a new collection. \texttt{destination} must be at least as large as the first collection.

\textbf{Example}


\begin{minted}{jlcon}
julia> x = zeros(3);

julia> map!(x -> x * 2, x, [1, 2, 3]);

julia> x
3-element Array{Float64,1}:
 2.0
 4.0
 6.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1914-L1932}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7665709493711303537}{} 
\hyperlink{7665709493711303537}{\texttt{Base.mapreduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapreduce(f, op, v0, itr)
\end{lstlisting}

Apply function \texttt{f} to each element in \texttt{itr}, and then reduce the result using the binary function \texttt{op}. \texttt{v0} must be a neutral element for \texttt{op} that will be returned for empty collections. It is unspecified whether \texttt{v0} is used for non-empty collections.

\hyperlink{7665709493711303537}{\texttt{mapreduce}} is functionally equivalent to calling \texttt{reduce(op, v0, map(f, itr))}, but will in general execute faster since no intermediate collection needs to be created. See documentation for \hyperlink{2662613255229698805}{\texttt{reduce}} and \hyperlink{11483231213869150535}{\texttt{map}}.


\begin{minted}{jlcon}
julia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9
14
\end{minted}

The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of \texttt{f} for elements that appear multiple times in \texttt{itr}. Use \hyperlink{7201860476364147871}{\texttt{mapfoldl}} or \hyperlink{13917513354174607167}{\texttt{mapfoldr}} instead for guaranteed left or right associativity and invocation of \texttt{f} for every value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L208-L228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10927609949347955937}{} 
\hyperlink{10927609949347955937}{\texttt{Base.mapreduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapreduce(f, op, itr)
\end{lstlisting}

Like \texttt{mapreduce(f, op, v0, itr)}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L200-L205}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7201860476364147871}{} 
\hyperlink{7201860476364147871}{\texttt{Base.mapfoldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapfoldl(f, op, v0, itr)
\end{lstlisting}

Like \hyperlink{7665709493711303537}{\texttt{mapreduce}}, but with guaranteed left associativity, as in \hyperlink{10555237964956281648}{\texttt{foldl}}. \texttt{v0} will be used exactly once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L52-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14886875186313200647}{} 
\hyperlink{14886875186313200647}{\texttt{Base.mapfoldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapfoldl(f, op, itr)
\end{lstlisting}

Like \texttt{mapfoldl(f, op, v0, itr)}, but using the first element of \texttt{itr} as \texttt{v0}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L60-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13917513354174607167}{} 
\hyperlink{13917513354174607167}{\texttt{Base.mapfoldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapfoldr(f, op, v0, itr)
\end{lstlisting}

Like \hyperlink{7665709493711303537}{\texttt{mapreduce}}, but with guaranteed right associativity, as in \hyperlink{13997312259064792310}{\texttt{foldr}}. \texttt{v0} will be used exactly once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L120-L125}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14828426243224858846}{} 
\hyperlink{14828426243224858846}{\texttt{Base.mapfoldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapfoldr(f, op, itr)
\end{lstlisting}

Like \texttt{mapfoldr(f, op, v0, itr)}, but using the first element of \texttt{itr} as \texttt{v0}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L128-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10301663699427216331}{} 
\hyperlink{10301663699427216331}{\texttt{Base.first}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
first(coll)
\end{lstlisting}

Get the first element of an iterable collection. Returns the start point of a \texttt{Range} even if it is empty.


\begin{minted}{jlcon}
julia> first(2:2:10)
2

julia> first([1; 2; 3; 4])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L137-L150}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7482613677577278193}{} 
\hyperlink{7482613677577278193}{\texttt{Base.last}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
last(coll)
\end{lstlisting}

Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling \hyperlink{7288835006555308491}{\texttt{endof}} to get the last index. Returns the end point of a \texttt{Range} even if it is empty.


\begin{minted}{jlcon}
julia> last(1:2:10)
9

julia> last([1; 2; 3; 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L157-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6276843274198881822}{} 
\hyperlink{6276843274198881822}{\texttt{Base.step}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
step(r)
\end{lstlisting}

Get the step size of a \texttt{Range} object.


\begin{minted}{jlcon}
julia> step(1:10)
1

julia> step(1:2:10)
2

julia> step(2.5:0.3:10.9)
0.3

julia> step(linspace(2.5,10.9,85))
0.1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L343-L360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6278865767444641812}{} 
\hyperlink{6278865767444641812}{\texttt{Base.collect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
collect(collection)
\end{lstlisting}

Return an \texttt{Array} of all items in a collection or iterator. For associative collections, returns \texttt{Pair\{KeyType, ValType\}}. If the argument is array-like or is an iterator with the \texttt{HasShape()} trait, the result will have the same shape and number of dimensions as the argument.

\textbf{Example}


\begin{minted}{jlcon}
julia> collect(1:2:13)
7-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11
 13
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L411-L430}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3539644528130741625}{} 
\hyperlink{3539644528130741625}{\texttt{Base.collect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
collect(element_type, collection)
\end{lstlisting}

Return an \texttt{Array} with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as \texttt{collection}.


\begin{minted}{jlcon}
julia> collect(Float64, 1:2:5)
3-element Array{Float64,1}:
 1.0
 3.0
 5.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L379-L392}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4941392674716223104}{} 
\hyperlink{4941392674716223104}{\texttt{Base.issubset}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issubset(a, b)
⊆(a,b) -> Bool
⊈(a,b) -> Bool
⊊(a,b) -> Bool
\end{lstlisting}

Determine whether every element of \texttt{a} is also in \texttt{b}, using \hyperlink{17277603976666670638}{\texttt{in}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issubset([1, 2], [1, 2, 3])
true

julia> issubset([1, 2, 3], [1, 2])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2326-L2342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11445961893478569145}{} 
\hyperlink{11445961893478569145}{\texttt{Base.filter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filter(function, collection)
\end{lstlisting}

Return a copy of \texttt{collection}, removing elements for which \texttt{function} is \texttt{false}. For associative collections, the function is passed two arguments (key and value).

\textbf{Examples}


\begin{lstlisting}
julia> a = 1:10
1:10

julia> filter(isodd, a)
5-element Array{Int64,1}:
 1
 3
 5
 7
 9

julia> d = Dict(1=>"a", 2=>"b")
Dict{Int64,String} with 2 entries:
  2 => "b"
  1 => "a"

julia> filter((x,y)->isodd(x), d)
Dict{Int64,String} with 1 entry:
  1 => "a"
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1874-L1902}{\texttt{source}}



\begin{lstlisting}
filter(p, x::Nullable)
\end{lstlisting}

Return null if either \texttt{x} is null or \texttt{p(get(x))} is false, and \texttt{x} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L251-L255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3384092630307389071}{} 
\hyperlink{3384092630307389071}{\texttt{Base.filter!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filter!(function, collection)
\end{lstlisting}

Update \texttt{collection}, removing elements for which \texttt{function} is \texttt{false}. For associative collections, the function is passed two arguments (key and value).

\textbf{Example}


\begin{minted}{jlcon}
julia> filter!(isodd, collect(1:10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L313-L329}{\texttt{source}}


\end{adjustwidth}

\hypertarget{994871259414187011}{}


\section{Colecciones Indexables}


\hypertarget{13252273446470485800}{} 
\hyperlink{13252273446470485800}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getindex(collection, key...)
\end{lstlisting}

Retrieve the value(s) stored at the given key or index within a collection. The syntax \texttt{a[i,j,...]} is converted by the compiler to \texttt{getindex(a, i, j, ...)}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = Dict("a" => 1, "b" => 2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> getindex(A, "a")
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L150-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17628459644208174650}{} 
\hyperlink{17628459644208174650}{\texttt{Base.setindex!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setindex!(collection, value, key...)
\end{lstlisting}

Store the given value at the given key or index within a collection. The syntax \texttt{a[i,j,...] = x} is converted by the compiler to \texttt{(setindex!(a, x, i, j, ...); x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2295-L2300}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \hyperlink{15492651498431872487}{\texttt{Array}}


\item \hyperlink{18015155802543401629}{\texttt{BitArray}}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \texttt{SubArray}


\item \hyperlink{11235697656281157373}{\texttt{ObjectIdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{AbstractString}

\end{itemize}


Parcialmente implementado por:



\begin{itemize}
\item \texttt{Range}


\item \texttt{UnitRange}


\item \texttt{Tuple}

\end{itemize}


\hypertarget{11647742401605290455}{}


\section{Colecciones asociativas}



\hyperlink{3089397136845322041}{\texttt{Dict}} es la colección asociativa estándar. Su implementación usa \hyperlink{13797072367283572032}{\texttt{hash()}} como función de hashing para la clave, e \hyperlink{12829995639916057841}{\texttt{isequal()}} para determinar la igualdad. Si redefine estas dos funciones en un tipo personalizado sobreescribiran como se almacenan dichos tipos en una tabla hash.



\hyperlink{11235697656281157373}{\texttt{ObjectIdDict}} es una tabla hash especial donde las claves son siempre identidades de objeto.



\href{@ ref}{\texttt{WeakKeyDict}} es una implementación de tabla hash donde las claves son referencias débiles a los objetos y, por lo tanto, permiten recolección de basura recogida incluso cuando se referencian en una tabla hash.



\hyperlink{3089397136845322041}{\texttt{Dict}}s se pueden crear pasando pares de objetos construidos con \texttt{=>()}a un constructor \hyperlink{3089397136845322041}{\texttt{Dict}}: \texttt{Dict ({\textquotedbl}A{\textquotedbl}=> 1,{\textquotedbl} B {\textquotedbl}=> 2)}. Esta llamada intentará inferir información de tipo de las claves y valores (es decir, este ejemplo crea un \texttt{Dict\{String, Int64\}}). Para especificar explícitamente los tipos, use la sintaxis \texttt{Dict\{KeyType,ValueType\}(...)}. Por ejemplo, \texttt{Dict\{String,Int32\}({\textquotedbl} A {\textquotedbl}=> 1,{\textquotedbl} B {\textquotedbl}=> 2)}.



Las colecciones asociativas pueden también ser creadas con generadores. Por ejemplo, \texttt{Dict(i => f(i) for i = 1:10)}.



Dado un diccionario \texttt{D}, la sintaxis\texttt{D[x]} devuelve el valor de la clave \texttt{x} (si existe) o arroja un error, y \texttt{D[x] = y} almacena el par de clave-valor \texttt{x => y} en \texttt{D} (reemplazando cualquier valor existente por la clave\texttt{x}). Múltiples argumentos para \texttt{D [...]} se convierten a tuplas; por ejemplo, la sintaxis \texttt{D[x,y]} es equivalente a \texttt{D[(x,y)]}, es decir, se refiere al valor introducido por la tupla \texttt{(x,y)}.


\hypertarget{3089397136845322041}{} 
\hyperlink{3089397136845322041}{\texttt{Base.Dict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Dict([itr])
\end{lstlisting}

\texttt{Dict\{K,V\}()} constructs a hash table with keys of type \texttt{K} and values of type \texttt{V}.

Given a single iterable argument, constructs a \hyperlink{3089397136845322041}{\texttt{Dict}} whose key-value pairs are taken from 2-tuples \texttt{(key,value)} generated by the argument.


\begin{minted}{jlcon}
julia> Dict([("A", 1), ("B", 2)])
Dict{String,Int64} with 2 entries:
  "B" => 2
  "A" => 1
\end{minted}

Alternatively, a sequence of pair arguments may be passed.


\begin{minted}{jlcon}
julia> Dict("A"=>1, "B"=>2)
Dict{String,Int64} with 2 entries:
  "B" => 2
  "A" => 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L68-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11235697656281157373}{} 
\hyperlink{11235697656281157373}{\texttt{Base.ObjectIdDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ObjectIdDict([itr])
\end{lstlisting}

\texttt{ObjectIdDict()} constructs a hash table where the keys are (always) object identities.  Unlike \texttt{Dict} it is not parameterized on its key and value type and thus its \texttt{eltype} is always \texttt{Pair\{Any,Any\}}.

See \hyperlink{3089397136845322041}{\texttt{Dict}} for further help.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L379-L387}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17958922440222792850}{} 
\hyperlink{17958922440222792850}{\texttt{Base.WeakKeyDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
WeakKeyDict([itr])
\end{lstlisting}

\texttt{WeakKeyDict()} constructs a hash table where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.

See \hyperlink{3089397136845322041}{\texttt{Dict}} for further help.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/weakkeydict.jl#L5-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16178429961779994033}{} 
\hyperlink{16178429961779994033}{\texttt{Base.haskey}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
haskey(collection, key) -> Bool
\end{lstlisting}

Determine whether a collection has a mapping for a given key.


\begin{minted}{jlcon}
julia> a = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'b' => 3
  'a' => 2

julia> haskey(a,'a')
true

julia> haskey(a,'c')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L487-L504}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1600067245044904172}{} 
\hyperlink{1600067245044904172}{\texttt{Base.get}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get(collection, key, default)
\end{lstlisting}

Return the value stored for the given key, or the given default value if no mapping for the key is present.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2);

julia> get(d, "a", 3)
1

julia> get(d, "c", 3)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1418-L1434}{\texttt{source}}


\end{adjustwidth}
\hypertarget{282460992333585641}{} 
\hyperlink{282460992333585641}{\texttt{Base.get}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get(f::Function, collection, key)
\end{lstlisting}

Return the value stored for the given key, or if no mapping for the key is present, return \texttt{f()}.  Use \hyperlink{1533836558345014565}{\texttt{get!}} to also store the default value in the dictionary.

This is intended to be called using \texttt{do} block syntax


\begin{minted}{julia}
get(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1437-L1451}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1533836558345014565}{} 
\hyperlink{1533836558345014565}{\texttt{Base.get!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get!(collection, key, default)
\end{lstlisting}

Return the value stored for the given key, or if no mapping for the key is present, store \texttt{key => default}, and return \texttt{default}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> get!(d, "a", 5)
1

julia> get!(d, "d", 4)
4

julia> d
Dict{String,Int64} with 4 entries:
  "c" => 3
  "b" => 2
  "a" => 1
  "d" => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1947-L1970}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8556034432039635706}{} 
\hyperlink{8556034432039635706}{\texttt{Base.get!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get!(f::Function, collection, key)
\end{lstlisting}

Return the value stored for the given key, or if no mapping for the key is present, store \texttt{key => f()}, and return \texttt{f()}.

This is intended to be called using \texttt{do} block syntax:


\begin{minted}{julia}
get!(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1973-L1986}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7350451602884809264}{} 
\hyperlink{7350451602884809264}{\texttt{Base.getkey}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getkey(collection, key, default)
\end{lstlisting}

Return the key matching argument \texttt{key} if one exists in \texttt{collection}, otherwise return \texttt{default}.


\begin{minted}{jlcon}
julia> a = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'b' => 3
  'a' => 2

julia> getkey(a,'a',1)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> getkey(a,'d','a')
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L508-L525}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2012894417553832980}{} 
\hyperlink{2012894417553832980}{\texttt{Base.delete!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
delete!(collection, key)
\end{lstlisting}

Delete the mapping for the given key in a collection, and return the collection.

\textbf{Example}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> delete!(d, "b")
Dict{String,Int64} with 1 entry:
  "a" => 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1331-L1347}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8214834680518266248}{} 
\hyperlink{8214834680518266248}{\texttt{Base.pop!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pop!(collection, key[, default])
\end{lstlisting}

Delete and return the mapping for \texttt{key} if it exists in \texttt{collection}, otherwise return \texttt{default}, or throw an error if \texttt{default} is not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> pop!(d, "a")
1

julia> pop!(d, "d")
ERROR: KeyError: key "d" not found
Stacktrace:
 [1] pop!(::Dict{String,Int64}, ::String) at ./dict.jl:539

julia> pop!(d, "e", 4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2600-L2621}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6023948435845840069}{} 
\hyperlink{6023948435845840069}{\texttt{Base.keys}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
keys(a::Associative)
\end{lstlisting}

Return an iterator over all keys in a collection. \texttt{collect(keys(a))} returns an array of keys. Since the keys are stored internally in a hash table, the order in which they are returned may vary. But \texttt{keys(a)} and \texttt{values(a)} both iterate \texttt{a} and return the elements in the same order.


\begin{minted}{jlcon}
julia> a = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'b' => 3
  'a' => 2

julia> collect(keys(a))
2-element Array{Char,1}:
 'b'
 'a'
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L63-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14429101350359443046}{} 
\hyperlink{14429101350359443046}{\texttt{Base.values}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
values(a::Associative)
\end{lstlisting}

Return an iterator over all values in a collection. \texttt{collect(values(a))} returns an array of values. Since the values are stored internally in a hash table, the order in which they are returned may vary. But \texttt{keys(a)} and \texttt{values(a)} both iterate \texttt{a} and return the elements in the same order.


\begin{minted}{jlcon}
julia> a = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'b' => 3
  'a' => 2

julia> collect(values(a))
2-element Array{Int64,1}:
 3
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L88-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2980395915971142404}{} 
\hyperlink{2980395915971142404}{\texttt{Base.merge}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
merge(d::Associative, others::Associative...)
\end{lstlisting}

Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.


\begin{minted}{jlcon}
julia> a = Dict("foo" => 0.0, "bar" => 42.0)
Dict{String,Float64} with 2 entries:
  "bar" => 42.0
  "foo" => 0.0

julia> b = Dict("baz" => 17, "bar" => 4711)
Dict{String,Int64} with 2 entries:
  "bar" => 4711
  "baz" => 17

julia> merge(a, b)
Dict{String,Float64} with 3 entries:
  "bar" => 4711.0
  "baz" => 17.0
  "foo" => 0.0

julia> merge(b, a)
Dict{String,Float64} with 3 entries:
  "bar" => 42.0
  "baz" => 17.0
  "foo" => 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L224-L255}{\texttt{source}}



\begin{lstlisting}
merge(combine, d::Associative, others::Associative...)
\end{lstlisting}

Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.


\begin{minted}{jlcon}
julia> a = Dict("foo" => 0.0, "bar" => 42.0)
Dict{String,Float64} with 2 entries:
  "bar" => 42.0
  "foo" => 0.0

julia> b = Dict("baz" => 17, "bar" => 4711)
Dict{String,Int64} with 2 entries:
  "bar" => 4711
  "baz" => 17

julia> merge(+, a, b)
Dict{String,Float64} with 3 entries:
  "bar" => 4753.0
  "baz" => 17.0
  "foo" => 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L259-L284}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6445163593036205863}{} 
\hyperlink{6445163593036205863}{\texttt{Base.merge!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
merge!(d::Associative, others::Associative...)
\end{lstlisting}

Update collection with pairs from the other collections. See also \hyperlink{2980395915971142404}{\texttt{merge}}.


\begin{minted}{jlcon}
julia> d1 = Dict(1 => 2, 3 => 4);

julia> d2 = Dict(1 => 4, 4 => 5);

julia> merge!(d1, d2);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 5
  3 => 4
  1 => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L120-L139}{\texttt{source}}



\begin{lstlisting}
merge!(combine, d::Associative, others::Associative...)
\end{lstlisting}

Update collection with pairs from the other collections. Values with the same key will be combined using the combiner function.


\begin{minted}{jlcon}
julia> d1 = Dict(1 => 2, 3 => 4);

julia> d2 = Dict(1 => 4, 4 => 5);

julia> merge!(+, d1, d2);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 5
  3 => 4
  1 => 6

julia> merge!(-, d1, d1);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 0
  3 => 0
  1 => 0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L149-L177}{\texttt{source}}


Merge changes into current head 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/merge.jl#L66}{\texttt{source}}


Internal implementation of merge. Returns \texttt{true} if merge was successful, otherwise \texttt{false}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/merge.jl#L80-L83}{\texttt{source}}



\begin{lstlisting}
merge!(repo::GitRepo; kwargs...) -> Bool
\end{lstlisting}

Perform a git merge on the repository \texttt{repo}, merging commits with diverging history into the current branch. Returns \texttt{true} if the merge succeeded, \texttt{false} if not.

The keyword arguments are:

\begin{itemize}
\item \texttt{committish::AbstractString={\textquotedbl}{\textquotedbl}}: Merge the named commit(s) in \texttt{committish}.


\item \texttt{branch::AbstractString={\textquotedbl}{\textquotedbl}}: Merge the branch \texttt{branch} and all its commits since it diverged from the current branch.


\item \texttt{fastforward::Bool=false}: If \texttt{fastforward} is \texttt{true}, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return \texttt{false}. This is equivalent to the git CLI option \texttt{--ff-only}.


\item \texttt{merge\_opts::MergeOptions=MergeOptions()}: \texttt{merge\_opts} specifies options for the merge, such as merge strategy in case of conflicts.


\item \texttt{checkout\_opts::CheckoutOptions=CheckoutOptions()}: \texttt{checkout\_opts} specifies options for the checkout step.

\end{itemize}
Equivalent to \texttt{git merge [--ff-only] [<committish> | <branch>]}.

\begin{quote}
\textbf{Note}

If you specify a \texttt{branch}, this must be done in reference format, since the string will be turned into a \texttt{GitReference}. For example, if you wanted to merge branch \texttt{branch\_a}, you would call \texttt{merge!(repo, branch={\textquotedbl}refs/heads/branch\_a{\textquotedbl})}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L625-L652}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15797102328828238137}{} 
\hyperlink{15797102328828238137}{\texttt{Base.sizehint!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sizehint!(s, n)
\end{lstlisting}

Suggest that collection \texttt{s} reserve capacity for at least \texttt{n} elements. This can improve performance.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1114-L1118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7157735428816224008}{} 
\hyperlink{7157735428816224008}{\texttt{Base.keytype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
keytype(type)
\end{lstlisting}

Get the key type of an associative collection type. Behaves similarly to \hyperlink{6396209842929672718}{\texttt{eltype}}.


\begin{minted}{jlcon}
julia> keytype(Dict(Int32(1) => "foo"))
Int32
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L196-L205}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1758642341593311431}{} 
\hyperlink{1758642341593311431}{\texttt{Base.valtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
valtype(type)
\end{lstlisting}

Get the value type of an associative collection type. Behaves similarly to \hyperlink{6396209842929672718}{\texttt{eltype}}.


\begin{minted}{jlcon}
julia> valtype(Dict(Int32(1) => "foo"))
String
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L210-L219}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \hyperlink{11235697656281157373}{\texttt{ObjectIdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}

\end{itemize}


Parcialmente implementado por:



\begin{itemize}
\item \hyperlink{8428136537376557806}{\texttt{IntSet}}


\item \hyperlink{1143189053501747033}{\texttt{Set}}


\item \hyperlink{15720283866375224773}{\texttt{EnvHash}}


\item \hyperlink{15492651498431872487}{\texttt{Array}}


\item \hyperlink{18015155802543401629}{\texttt{BitArray}}

\end{itemize}


\hypertarget{13875310785149923216}{}


\section{Colecciones tipo Conjunto}


\hypertarget{1143189053501747033}{} 
\hyperlink{1143189053501747033}{\texttt{Base.Set}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Set([itr])
\end{lstlisting}

Construct a \hyperlink{1143189053501747033}{\texttt{Set}} of the values generated by the given iterable object, or an empty set. Should be used instead of \hyperlink{8428136537376557806}{\texttt{IntSet}} for sparse integer sets, or for sets of arbitrary objects.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2557-L2563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8428136537376557806}{} 
\hyperlink{8428136537376557806}{\texttt{Base.IntSet}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IntSet([itr])
\end{lstlisting}

Construct a sorted set of positive \texttt{Int}s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. Only \texttt{Int}s greater than 0 can be stored. If the set will be sparse (for example holding a few very large integers), use \hyperlink{1143189053501747033}{\texttt{Set}} instead.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1630-L1637}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6278797112644055704}{} 
\hyperlink{6278797112644055704}{\texttt{Base.union}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
union(s1,s2...)
∪(s1,s2...)
\end{lstlisting}

Construct the union of two or more sets. Maintains order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> union([1, 2], [3, 4])
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> union([1, 2], [2, 4])
3-element Array{Int64,1}:
 1
 2
 4

julia> union([4, 2], [1, 2])
3-element Array{Int64,1}:
 4
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L944-L971}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12706236051336451682}{} 
\hyperlink{12706236051336451682}{\texttt{Base.union!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
union!(s, iterable)
\end{lstlisting}

Union each element of \texttt{iterable} into set \texttt{s} in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2511-L2515}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17029201757338520959}{} 
\hyperlink{17029201757338520959}{\texttt{Base.intersect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
intersect(s1,s2...)
∩(s1,s2)
\end{lstlisting}

Construct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2069-L2075}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11050652365145191041}{} 
\hyperlink{11050652365145191041}{\texttt{Base.setdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setdiff(a, b)
\end{lstlisting}

Construct the set of elements in \texttt{a} but not \texttt{b}. Maintains order with arrays. Note that both arguments must be collections, and both will be iterated over. In particular, \texttt{setdiff(set,element)} where \texttt{element} is a potential member of \texttt{set}, will not work in general.

\textbf{Example}


\begin{minted}{jlcon}
julia> setdiff([1,2,3],[3,4,5])
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1968-L1983}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12326722559100879167}{} 
\hyperlink{12326722559100879167}{\texttt{Base.setdiff!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setdiff!(s, iterable)
\end{lstlisting}

Remove each element of \texttt{iterable} from set \texttt{s} in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L792-L796}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4317834782250216015}{} 
\hyperlink{4317834782250216015}{\texttt{Base.symdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symdiff(a, b, rest...)
\end{lstlisting}

Construct the symmetric difference of elements in the passed in sets or arrays. Maintains order with arrays.

\textbf{Example}


\begin{minted}{jlcon}
julia> symdiff([1,2,3],[3,4,5],[4,5,6])
3-element Array{Int64,1}:
 1
 2
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L2004-L2018}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17482124157118607228}{} 
\hyperlink{17482124157118607228}{\texttt{Base.symdiff!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symdiff!(s, n)
\end{lstlisting}

The set \texttt{s} is destructively modified to toggle the inclusion of integer \texttt{n}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L137-L141}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15071236761362803413}{} 
\hyperlink{15071236761362803413}{\texttt{Base.symdiff!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symdiff!(s, itr)
\end{lstlisting}

For each element in \texttt{itr}, destructively toggle its inclusion in set \texttt{s}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L131-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14588756314269897163}{} 
\hyperlink{14588756314269897163}{\texttt{Base.symdiff!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symdiff!(s, itr)
\end{lstlisting}

For each element in \texttt{itr}, destructively toggle its inclusion in set \texttt{s}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L131-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18401946028185283153}{} 
\hyperlink{18401946028185283153}{\texttt{Base.intersect!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
intersect!(s1::IntSet, s2::IntSet)
\end{lstlisting}

Intersects sets \texttt{s1} and \texttt{s2} and overwrites the set \texttt{s1} with the result. If needed, \texttt{s1} will be expanded to the size of \texttt{s2}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L112-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18158680907243266011}{} 
\hyperlink{18158680907243266011}{\texttt{Base.issubset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issubset(A, S) -> Bool
⊆(A,S) -> Bool
\end{lstlisting}

Return \texttt{true} if \texttt{A} is a subset of or equal to \texttt{S}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2345-L2350}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \hyperlink{8428136537376557806}{\texttt{IntSet}}


\item \hyperlink{1143189053501747033}{\texttt{Set}}

\end{itemize}


Parcialmente implementado por:



\begin{itemize}
\item \hyperlink{15492651498431872487}{\texttt{Array}}

\end{itemize}


\hypertarget{2410535208643837914}{}


\section{Acciones relacionadas con colas}


\hypertarget{18026893834387542681}{} 
\hyperlink{18026893834387542681}{\texttt{Base.push!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
push!(collection, items...) -> collection
\end{lstlisting}

Insert one or more \texttt{items} at the end of \texttt{collection}.

\textbf{Example}


\begin{minted}{jlcon}
julia> push!([1, 2, 3], 4, 5, 6)
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
\end{minted}

Use \hyperlink{2587432243763606566}{\texttt{append!}} to add all the elements of another collection to \texttt{collection}. The result of the preceding example is equivalent to \texttt{append!([1, 2, 3], [4, 5, 6])}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L384-L404}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5793500518919030851}{} 
\hyperlink{5793500518919030851}{\texttt{Base.pop!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pop!(collection) -> item
\end{lstlisting}

Remove the last item in \texttt{collection} and return it.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A=[1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia> pop!(A)
6

julia> A
5-element Array{Int64,1}:
 1
 2
 3
 4
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2624-L2651}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13472234694981819983}{} 
\hyperlink{13472234694981819983}{\texttt{Base.unshift!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unshift!(collection, items...) -> collection
\end{lstlisting}

Insert one or more \texttt{items} at the beginning of \texttt{collection}.

\textbf{Example}


\begin{minted}{jlcon}
julia> unshift!([1, 2, 3, 4], 5, 6)
6-element Array{Int64,1}:
 5
 6
 1
 2
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L798-L814}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9705305782876235366}{} 
\hyperlink{9705305782876235366}{\texttt{Base.shift!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
shift!(collection) -> item
\end{lstlisting}

Remove the first \texttt{item} from \texttt{collection}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia> shift!(A)
1

julia> A
5-element Array{Int64,1}:
 2
 3
 4
 5
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1489-L1516}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2077968578228414845}{} 
\hyperlink{2077968578228414845}{\texttt{Base.insert!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
insert!(a::Vector, index::Integer, item)
\end{lstlisting}

Insert an \texttt{item} into \texttt{a} at the given \texttt{index}. \texttt{index} is the index of \texttt{item} in the resulting \texttt{a}.

\textbf{Example}


\begin{minted}{jlcon}
julia> insert!([6, 5, 4, 2, 1], 4, 3)
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L831-L848}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16790471737745785097}{} 
\hyperlink{16790471737745785097}{\texttt{Base.deleteat!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deleteat!(a::Vector, i::Integer)
\end{lstlisting}

Remove the item at the given \texttt{i} and return the modified \texttt{a}. Subsequent items are shifted to fill the resulting gap.

\textbf{Example}


\begin{minted}{jlcon}
julia> deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Array{Int64,1}:
 6
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L858-L874}{\texttt{source}}



\begin{lstlisting}
deleteat!(a::Vector, inds)
\end{lstlisting}

Remove the items at the indices given by \texttt{inds}, and return the modified \texttt{a}. Subsequent items are shifted to fill the resulting gap.

\texttt{inds} can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as \texttt{a} with \texttt{true} indicating entries to delete.

\textbf{Examples}


\begin{minted}{jlcon}
julia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Array{Int64,1}:
 5
 3
 1

julia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])
3-element Array{Int64,1}:
 5
 3
 1

julia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
Stacktrace:
 [1] _deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:926
 [2] deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:913
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L883-L912}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13785507599688955371}{} 
\hyperlink{13785507599688955371}{\texttt{Base.splice!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
splice!(a::Vector, index::Integer, [replacement]) -> item
\end{lstlisting}

Remove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.

\textbf{Examples}


\begin{lstlisting}
julia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia> A
5-element Array{Int64,1}:
 6
 5
 4
 3
 1

julia> splice!(A, 5, -1)
1

julia> A
5-element Array{Int64,1}:
  6
  5
  4
  3
 -1

julia> splice!(A, 1, [-1, -2, -3])
6

julia> A
7-element Array{Int64,1}:
 -1
 -2
 -3
  5
  4
  3
 -1
\end{lstlisting}

To insert \texttt{replacement} before an index \texttt{n} without removing any items, use \texttt{splice!(collection, n:n-1, replacement)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L960-L1008}{\texttt{source}}



\begin{lstlisting}
splice!(a::Vector, range, [replacement]) -> items
\end{lstlisting}

Remove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.

To insert \texttt{replacement} before an index \texttt{n} without removing any items, use \texttt{splice!(collection, n:n-1, replacement)}.

\textbf{Example}


\begin{lstlisting}
julia> splice!(A, 4:3, 2)
0-element Array{Int64,1}

julia> A
8-element Array{Int64,1}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1027-L1055}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10980093798189218206}{} 
\hyperlink{10980093798189218206}{\texttt{Base.resize!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
resize!(a::Vector, n::Integer) -> Vector
\end{lstlisting}

Resize \texttt{a} to contain \texttt{n} elements. If \texttt{n} is smaller than the current collection length, the first \texttt{n} elements will be retained. If \texttt{n} is larger, the new elements are not guaranteed to be initialized.

\textbf{Examples}


\begin{minted}{jlcon}
julia> resize!([6, 5, 4, 3, 2, 1], 3)
3-element Array{Int64,1}:
 6
 5
 4

julia> a = resize!([6, 5, 4, 3, 2, 1], 8);

julia> length(a)
8

julia> a[1:6]
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L741-L770}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2587432243763606566}{} 
\hyperlink{2587432243763606566}{\texttt{Base.append!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
append!(collection, collection2) -> collection.
\end{lstlisting}

Add the elements of \texttt{collection2} to the end of \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> append!([1],[2,3])
3-element Array{Int64,1}:
 1
 2
 3

julia> append!([1, 2, 3], [4, 5, 6])
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
\end{minted}

Use \hyperlink{18026893834387542681}{\texttt{push!}} to add individual items to \texttt{collection} which are not already themselves in another collection. The result is of the preceding example is equivalent to \texttt{push!([1, 2, 3], 4, 5, 6)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L756-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9292529440147652243}{} 
\hyperlink{9292529440147652243}{\texttt{Base.prepend!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prepend!(a::Vector, items) -> collection
\end{lstlisting}

Insert the elements of \texttt{items} to the beginning of \texttt{a}.

\textbf{Example}


\begin{minted}{jlcon}
julia> prepend!([3],[1,2])
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L690-L703}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \texttt{Vector} (a.k.a. 1-dimensional \hyperlink{15492651498431872487}{\texttt{Array}})


\item \texttt{BitVector} (a.k.a. 1-dimensional \hyperlink{18015155802543401629}{\texttt{BitArray}})

\end{itemize}


\hypertarget{8551667013795262933}{}


\chapter{Mathematics}



\hypertarget{15714690155437633961}{}


\section{Operadores Matemáticos}


\hypertarget{8228207173393714756}{} 
\hyperlink{8228207173393714756}{\texttt{Base.:-}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
-(x)
\end{lstlisting}

Unary minus operator.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L66-L70}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3677358729494553841}{} 
\hyperlink{3677358729494553841}{\texttt{Base.:+}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
+(x, y...)
\end{lstlisting}

Addition operator. \texttt{x+y+z+...} calls this function with all arguments, i.e. \texttt{+(x, y, z, ...)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2281-L2285}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11135345846828585592}{} 
\hyperlink{11135345846828585592}{\texttt{Base.:-}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
-(x, y)
\end{lstlisting}

Subtraction operator.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L73-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7592762607639177347}{} 
\hyperlink{7592762607639177347}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
*(x, y...)
\end{lstlisting}

Multiplication operator. \texttt{x*y*z*...} calls this function with all arguments, i.e. \texttt{*(x, y, z, ...)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1917-L1923}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4103478871488785445}{} 
\hyperlink{4103478871488785445}{\texttt{Base.:/}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
/(x, y)
\end{lstlisting}

Right division operator: multiplication of \texttt{x} by the inverse of \texttt{y} on the right. Gives floating-point results for integer arguments.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L522-L527}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4639577998029770435}{} 
\hyperlink{4639577998029770435}{\texttt{Base.:{\textbackslash}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
\(x, y)
\end{lstlisting}

Left division operator: multiplication of \texttt{y} by the inverse of \texttt{x} on the left. Gives floating-point results for integer arguments.


\begin{minted}{jlcon}
julia> 3 \ 6
2.0

julia> inv(3) * 6
2.0

julia> A = [1 2; 3 4]; x = [5, 6];

julia> A \ x
2-element Array{Float64,1}:
 -4.0
  4.5

julia> inv(A) * x
2-element Array{Float64,1}:
 -4.0
  4.5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L431-L456}{\texttt{source}}


\end{adjustwidth}
\hypertarget{462277561264792021}{} 
\hyperlink{462277561264792021}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
^(x, y)
\end{lstlisting}

Exponentiation operator. If \texttt{x} is a matrix, computes matrix exponentiation.

If \texttt{y} is an \texttt{Int} literal (e.g. \texttt{2} in \texttt{x{\textasciicircum}2} or \texttt{-3} in \texttt{x{\textasciicircum}-3}), the Julia code \texttt{x{\textasciicircum}y} is transformed by the compiler to \texttt{Base.literal\_pow({\textasciicircum}, x, Val\{y\})}, to enable compile-time specialization on the value of the exponent. (As a default fallback we have \texttt{Base.literal\_pow({\textasciicircum}, x, Val\{y\}) = {\textasciicircum}(x,y)}, where usually \texttt{{\textasciicircum} == Base.{\textasciicircum}} unless \texttt{{\textasciicircum}} has been defined in the calling namespace.)


\begin{minted}{jlcon}
julia> 3^5
243

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> A^3
2×2 Array{Int64,2}:
 37   54
 81  118
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/promotion.jl#L254-L280}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17935587874085983500}{} 
\hyperlink{17935587874085983500}{\texttt{Base.fma}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fma(x, y, z)
\end{lstlisting}

Computes \texttt{x*y+z} without rounding the intermediate result \texttt{x*y}. On some systems this is significantly more expensive than \texttt{x*y+z}. \texttt{fma} is used to improve accuracy in certain algorithms. See \hyperlink{7153024527713262493}{\texttt{muladd}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2264-L2270}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7153024527713262493}{} 
\hyperlink{7153024527713262493}{\texttt{Base.muladd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
muladd(x, y, z)
\end{lstlisting}

Combined multiply-add, computes \texttt{x*y+z} in an efficient manner. This may on some systems be equivalent to \texttt{x*y+z}, or to \texttt{fma(x,y,z)}. \texttt{muladd} is used to improve performance. See \hyperlink{17935587874085983500}{\texttt{fma}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> muladd(3, 2, 1)
7

julia> 3 * 2 + 1
7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L927-L942}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8020976424566491334}{} 
\hyperlink{8020976424566491334}{\texttt{Base.div}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
div(x, y)
÷(x, y)
\end{lstlisting}

The quotient from Euclidean division. Computes \texttt{x/y}, truncated to an integer.


\begin{minted}{jlcon}
julia> 9 ÷ 4
2

julia> -5 ÷ 3
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L616-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15067916827074788527}{} 
\hyperlink{15067916827074788527}{\texttt{Base.fld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fld(x, y)
\end{lstlisting}

Largest integer less than or equal to \texttt{x/y}.


\begin{minted}{jlcon}
julia> fld(7.3,5.5)
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L568-L577}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7922388465305816555}{} 
\hyperlink{7922388465305816555}{\texttt{Base.cld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cld(x, y)
\end{lstlisting}

Smallest integer larger than or equal to \texttt{x/y}.


\begin{minted}{jlcon}
julia> cld(5.5,2.2)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L580-L588}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2082041235715276573}{} 
\hyperlink{2082041235715276573}{\texttt{Base.mod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mod(x, y)
rem(x, y, RoundDown)
\end{lstlisting}

The reduction of \texttt{x} modulo \texttt{y}, or equivalently, the remainder of \texttt{x} after floored division by \texttt{y}, i.e.


\begin{minted}{julia}
x - y*fld(x,y)
\end{minted}

if computed without intermediate rounding.

The result will have the same sign as \texttt{y}, and magnitude less than \texttt{abs(y)} (with some exceptions, see note below).

\begin{quote}
\textbf{Note}

When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to \texttt{y}, then it may be rounded to \texttt{y}.

\end{quote}

\begin{minted}{jlcon}
julia> mod(8, 3)
2

julia> mod(9, 3)
0

julia> mod(8.9, 3)
2.9000000000000004

julia> mod(eps(), 3)
2.220446049250313e-16

julia> mod(-eps(), 3)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L132-L168}{\texttt{source}}



\begin{lstlisting}
rem(x::Integer, T::Type{<:Integer}) -> T
mod(x::Integer, T::Type{<:Integer}) -> T
%(x::Integer, T::Type{<:Integer}) -> T
\end{lstlisting}

Find \texttt{y::T} such that \texttt{x} ≡ \texttt{y} (mod n), where n is the number of integers representable in \texttt{T}, and \texttt{y} is an integer in \texttt{[typemin(T),typemax(T)]}. If \texttt{T} can represent any integer (e.g. \texttt{T == BigInt}), then this operation corresponds to a conversion to \texttt{T}.


\begin{minted}{jlcon}
julia> 129 % Int8
-127
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L369-L383}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3827563084771191385}{} 
\hyperlink{3827563084771191385}{\texttt{Base.rem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rem(x, y)
%(x, y)
\end{lstlisting}

Remainder from Euclidean division, returning a value of the same sign as \texttt{x}, and smaller in magnitude than \texttt{y}. This value is always exact.


\begin{minted}{jlcon}
julia> x = 15; y = 4;

julia> x % y
3

julia> x == div(x, y) * y + rem(x, y)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L596-L612}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7552737171387915272}{} 
\hyperlink{7552737171387915272}{\texttt{Base.Math.rem2pi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rem2pi(x, r::RoundingMode)
\end{lstlisting}

Compute the remainder of \texttt{x} after integer division by \texttt{2π}, with the quotient rounded according to the rounding mode \texttt{r}. In other words, the quantity


\begin{lstlisting}
x - 2π*round(x/(2π),r)
\end{lstlisting}

without any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than \texttt{rem(x,2π,r)}

\begin{itemize}
\item if \texttt{r == RoundNearest}, then the result is in the interval \([-π, π]\). This will generally be the most accurate result.


\item if \texttt{r == RoundToZero}, then the result is in the interval \([0, 2π]\) if \texttt{x} is positive,. or \([-2π, 0]\) otherwise.


\item if \texttt{r == RoundDown}, then the result is in the interval \([0, 2π]\).


\item if \texttt{r == RoundUp}, then the result is in the interval \([-2π, 0]\).

\end{itemize}
\textbf{Example}


\begin{minted}{jlcon}
julia> rem2pi(7pi/4, RoundNearest)
-0.7853981633974485

julia> rem2pi(7pi/4, RoundDown)
5.497787143782138
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L761-L790}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15322754370885673769}{} 
\hyperlink{15322754370885673769}{\texttt{Base.Math.mod2pi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mod2pi(x)
\end{lstlisting}

Modulus after division by \texttt{2π}, returning in the range \([0,2π)\).

This function computes a floating point representation of the modulus after division by numerically exact \texttt{2π}, and is therefore not exactly the same as \texttt{mod(x,2π)}, which would compute the modulus of \texttt{x} relative to division by the floating-point number \texttt{2π}.

\textbf{Example}


\begin{minted}{jlcon}
julia> mod2pi(9*pi/4)
0.7853981633974481
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L908-L922}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6106909621813654214}{} 
\hyperlink{6106909621813654214}{\texttt{Base.divrem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
divrem(x, y)
\end{lstlisting}

The quotient and remainder from Euclidean division. Equivalent to \texttt{(div(x,y), rem(x,y))} or \texttt{(x÷y, x\%y)}.


\begin{minted}{jlcon}
julia> divrem(3,7)
(0, 3)

julia> divrem(7,3)
(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L50-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2806360720034558325}{} 
\hyperlink{2806360720034558325}{\texttt{Base.fldmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fldmod(x, y)
\end{lstlisting}

The floored quotient and modulus after division. Equivalent to \texttt{(fld(x,y), mod(x,y))}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L66-L70}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2046682076337602867}{} 
\hyperlink{2046682076337602867}{\texttt{Base.fld1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fld1(x, y)
\end{lstlisting}

Flooring division, returning a value consistent with \texttt{mod1(x,y)}

See also: \hyperlink{13778479217547823795}{\texttt{mod1}}.


\begin{minted}{jlcon}
julia> x = 15; y = 4;

julia> fld1(x, y)
4

julia> x == fld(x, y) * y + mod(x, y)
true

julia> x == (fld1(x, y) - 1) * y + mod1(x, y)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L652-L671}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13778479217547823795}{} 
\hyperlink{13778479217547823795}{\texttt{Base.mod1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mod1(x, y)
\end{lstlisting}

Modulus after flooring division, returning a value \texttt{r} such that \texttt{mod(r, y) == mod(x, y)} in the range \((0, y]\) for positive \texttt{y} and in the range \([y,0)\) for negative \texttt{y}.


\begin{minted}{jlcon}
julia> mod1(4, 2)
2

julia> mod1(4, 3)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L633-L646}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3908876301745770865}{} 
\hyperlink{3908876301745770865}{\texttt{Base.fldmod1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fldmod1(x, y)
\end{lstlisting}

Return \texttt{(fld1(x,y), mod1(x,y))}.

See also: \hyperlink{2046682076337602867}{\texttt{fld1}}, \hyperlink{13778479217547823795}{\texttt{mod1}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L676-L682}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17539582191808611917}{} 
\hyperlink{17539582191808611917}{\texttt{Base.://}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
//(num, den)
\end{lstlisting}

Divide two integers or rational numbers, giving a \hyperlink{8304566144531167610}{\texttt{Rational}} result.


\begin{minted}{jlcon}
julia> 3 // 5
3//5

julia> (3 // 5) // (2 // 1)
3//10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L27-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6368672003928643787}{} 
\hyperlink{6368672003928643787}{\texttt{Base.rationalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rationalize([T<:Integer=Int,] x; tol::Real=eps(x))
\end{lstlisting}

Approximate floating point number \texttt{x} as a \hyperlink{8304566144531167610}{\texttt{Rational}} number with components of the given integer type. The result will differ from \texttt{x} by no more than \texttt{tol}. If \texttt{T} is not provided, it defaults to \texttt{Int}.


\begin{minted}{jlcon}
julia> rationalize(5.6)
28//5

julia> a = rationalize(BigInt, 10.3)
103//10

julia> typeof(numerator(a))
BigInt
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L109-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7885506453580572157}{} 
\hyperlink{7885506453580572157}{\texttt{Base.numerator}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
numerator(x)
\end{lstlisting}

Numerator of the rational representation of \texttt{x}.


\begin{minted}{jlcon}
julia> numerator(2//3)
2

julia> numerator(4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L189-L201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12407209279719593434}{} 
\hyperlink{12407209279719593434}{\texttt{Base.denominator}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
denominator(x)
\end{lstlisting}

Denominator of the rational representation of \texttt{x}.


\begin{minted}{jlcon}
julia> denominator(2//3)
3

julia> denominator(4)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L205-L217}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2724916807067930829}{} 
\hyperlink{2724916807067930829}{\texttt{Base.:<<}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
<<(x, n)
\end{lstlisting}

Left bit shift operator, \texttt{x << n}. For \texttt{n >= 0}, the result is \texttt{x} shifted left by \texttt{n} bits, filling with \texttt{0}s. This is equivalent to \texttt{x * 2{\textasciicircum}n}. For \texttt{n < 0}, this is equivalent to \texttt{x >> -n}.


\begin{minted}{jlcon}
julia> Int8(3) << 2
12

julia> bits(Int8(3))
"00000011"

julia> bits(Int8(12))
"00001100"
\end{minted}

See also \hyperlink{6883264745383491304}{\texttt{>>}}, \hyperlink{16613216773443333487}{\texttt{>>>}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L463-L481}{\texttt{source}}



\begin{lstlisting}
<<(B::BitVector, n) -> BitVector
\end{lstlisting}

Left bit shift operator, \texttt{B << n}. For \texttt{n >= 0}, the result is \texttt{B} with elements shifted \texttt{n} positions backwards, filling with \texttt{false} values. If \texttt{n < 0}, elements are shifted forwards. Equivalent to \texttt{B >> -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia> B << 1
5-element BitArray{1}:
 false
  true
 false
 false
 false

julia> B << -1
5-element BitArray{1}:
 false
  true
 false
  true
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1422-L1457}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6883264745383491304}{} 
\hyperlink{6883264745383491304}{\texttt{Base.:>>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>>(x, n)
\end{lstlisting}

Right bit shift operator, \texttt{x >> n}. For \texttt{n >= 0}, the result is \texttt{x} shifted right by \texttt{n} bits, where \texttt{n >= 0}, filling with \texttt{0}s if \texttt{x >= 0}, \texttt{1}s if \texttt{x < 0}, preserving the sign of \texttt{x}. This is equivalent to \texttt{fld(x, 2{\textasciicircum}n)}. For \texttt{n < 0}, this is equivalent to \texttt{x << -n}.


\begin{minted}{jlcon}
julia> Int8(13) >> 2
3

julia> bits(Int8(13))
"00001101"

julia> bits(Int8(3))
"00000011"

julia> Int8(-14) >> 2
-4

julia> bits(Int8(-14))
"11110010"

julia> bits(Int8(-4))
"11111100"
\end{minted}

See also \hyperlink{16613216773443333487}{\texttt{>>>}}, \hyperlink{2724916807067930829}{\texttt{<<}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L491-L520}{\texttt{source}}



\begin{lstlisting}
>>(B::BitVector, n) -> BitVector
\end{lstlisting}

Right bit shift operator, \texttt{B >> n}. For \texttt{n >= 0}, the result is \texttt{B} with elements shifted \texttt{n} positions forward, filling with \texttt{false} values. If \texttt{n < 0}, elements are shifted backwards. Equivalent to \texttt{B << -n}.

\textbf{Example}


\begin{minted}{jlcon}
julia> B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia> B >> 1
5-element BitArray{1}:
 false
  true
 false
  true
 false

julia> B >> -1
5-element BitArray{1}:
 false
  true
 false
 false
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1383-L1418}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16613216773443333487}{} 
\hyperlink{16613216773443333487}{\texttt{Base.:>>>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>>>(x, n)
\end{lstlisting}

Unsigned right bit shift operator, \texttt{x >>> n}. For \texttt{n >= 0}, the result is \texttt{x} shifted right by \texttt{n} bits, where \texttt{n >= 0}, filling with \texttt{0}s. For \texttt{n < 0}, this is equivalent to \texttt{x << -n}.

For \hyperlink{4780971278803506664}{\texttt{Unsigned}} integer types, this is equivalent to \hyperlink{6883264745383491304}{\texttt{>>}}. For \hyperlink{14154866400772377486}{\texttt{Signed}} integer types, this is equivalent to \texttt{signed(unsigned(x) >> n)}.


\begin{minted}{jlcon}
julia> Int8(-14) >>> 2
60

julia> bits(Int8(-14))
"11110010"

julia> bits(Int8(60))
"00111100"
\end{minted}

\hyperlink{423405808990690832}{\texttt{BigInt}}s are treated as if having infinite size, so no filling is required and this is equivalent to \hyperlink{6883264745383491304}{\texttt{>>}}.

See also \hyperlink{6883264745383491304}{\texttt{>>}}, \hyperlink{2724916807067930829}{\texttt{<<}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L530-L555}{\texttt{source}}



\begin{lstlisting}
>>>(B::BitVector, n) -> BitVector
\end{lstlisting}

Unsigned right bitshift operator, \texttt{B >>> n}. Equivalent to \texttt{B >> n}. See \hyperlink{6883264745383491304}{\texttt{>>}} for details and examples.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1460-L1465}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8118178594303305099}{} 
\hyperlink{8118178594303305099}{\texttt{Base.colon}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
colon(start, [step], stop)
\end{lstlisting}

Called by \texttt{:} syntax for constructing ranges.


\begin{minted}{jlcon}
julia> colon(1, 2, 5)
1:2:5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L18-L27}{\texttt{source}}



\begin{lstlisting}
:(start, [step], stop)
\end{lstlisting}

Range operator. \texttt{a:b} constructs a range from \texttt{a} to \texttt{b} with a step size of 1, and \texttt{a:s:b} is similar but uses a step size of \texttt{s}. These syntaxes call the function \texttt{colon}. The colon is also used in indexing to select whole dimensions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L39-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{737600656772861535}{} 
\hyperlink{737600656772861535}{\texttt{Base.range}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
range(start, [step], length)
\end{lstlisting}

Construct a range by length, given a starting value and optional step (defaults to 1).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L55-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7189994599038205424}{} 
\hyperlink{7189994599038205424}{\texttt{Base.OneTo}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.OneTo(n)
\end{lstlisting}

Define an \texttt{AbstractUnitRange} that behaves like \texttt{1:n}, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L166-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6593444000385137506}{} 
\hyperlink{6593444000385137506}{\texttt{Base.StepRangeLen}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1])
\end{lstlisting}

A range \texttt{r} where \texttt{r[i]} produces values of type \texttt{T}, parametrized by a \texttt{ref}erence value, a \texttt{step}, and the \texttt{len}gth.  By default \texttt{ref} is the starting value \texttt{r[1]}, but alternatively you can supply it as the value of \texttt{r[offset]} for some other index \texttt{1 <= offset <= len}.  In conjunction with \texttt{TwicePrecision} this can be used to implement ranges that are free of roundoff error.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L181-L190}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15143149452920304570}{} 
\hyperlink{15143149452920304570}{\texttt{Base.:==}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
==(x, y)
\end{lstlisting}

Generic equality operator, giving a single \hyperlink{46725311238864537}{\texttt{Bool}} result. Falls back to \texttt{===}. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding.

Follows IEEE semantics for floating-point numbers.

Collections should generally implement \texttt{==} by calling \texttt{==} recursively on all contents.

New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1674-L1688}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3046079188653285114}{} 
\hyperlink{3046079188653285114}{\texttt{Base.:!=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
!=(x, y)
≠(x,y)
\end{lstlisting}

Not-equals comparison operator. Always gives the opposite answer as \texttt{==}. New types should generally not implement this, and rely on the fallback definition \texttt{!=(x,y) = !(x==y)} instead.


\begin{minted}{jlcon}
julia> 3 != 2
true

julia> "foo" ≠ "foo"
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L114-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3509174727635606109}{} 
\hyperlink{3509174727635606109}{\texttt{Base.:!==}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
!==(x, y)
≢(x,y)
\end{lstlisting}

Equivalent to \texttt{!(x === y)}.


\begin{minted}{jlcon}
julia> a = [1, 2]; b = [1, 2];

julia> a ≢ b
true

julia> a ≢ a
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L156-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{702782232449268329}{} 
\hyperlink{702782232449268329}{\texttt{Base.:<}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
<(x, y)
\end{lstlisting}

Less-than comparison operator. New numeric types should implement this function for two arguments of the new type. Because of the behavior of floating-point NaN values, \texttt{<} implements a partial order. Types with a canonical partial order should implement \texttt{<}, and types with a canonical total order should implement \texttt{isless}.


\begin{minted}{jlcon}
julia> 'a' < 'b'
true

julia> "abc" < "abd"
true

julia> 5 < 3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L175-L193}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11411050964021316526}{} 
\hyperlink{11411050964021316526}{\texttt{Base.:<=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
<=(x, y)
≤(x,y)
\end{lstlisting}

Less-than-or-equals comparison operator.


\begin{minted}{jlcon}
julia> 'a' <= 'b'
true

julia> 7 ≤ 7 ≤ 9
true

julia> "abc" ≤ "abc"
true

julia> 5 <= 3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L218-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8677991761303191103}{} 
\hyperlink{8677991761303191103}{\texttt{Base.:>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>(x, y)
\end{lstlisting}

Greater-than comparison operator. Generally, new types should implement \texttt{<} instead of this function, and rely on the fallback definition \texttt{>(x, y) = y < x}.


\begin{minted}{jlcon}
julia> 'a' > 'b'
false

julia> 7 > 3 > 1
true

julia> "abc" > "abd"
false

julia> 5 > 3
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L196-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7019639580556993898}{} 
\hyperlink{7019639580556993898}{\texttt{Base.:>=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>=(x, y)
≥(x,y)
\end{lstlisting}

Greater-than-or-equals comparison operator.


\begin{minted}{jlcon}
julia> 'a' >= 'b'
false

julia> 7 ≥ 7 ≥ 3
true

julia> "abc" ≥ "abc"
true

julia> 5 >= 3
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L241-L260}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8951185024259053949}{} 
\hyperlink{8951185024259053949}{\texttt{Base.cmp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cmp(x,y)
\end{lstlisting}

Return -1, 0, or 1 depending on whether \texttt{x} is less than, equal to, or greater than \texttt{y}, respectively. Uses the total order implemented by \texttt{isless}. For floating-point numbers, uses \texttt{<} but throws an error for unordered arguments.


\begin{minted}{jlcon}
julia> cmp(1, 2)
-1

julia> cmp(2, 1)
1

julia> cmp(2+im, 3-im)
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L284-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2433030275488323500}{} 
\hyperlink{2433030275488323500}{\texttt{Base.:{\textasciitilde}}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
~(x)
\end{lstlisting}

Bitwise not.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ~4
-5

julia> ~10
-11

julia> ~true
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1275-L1291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1494761116451616317}{} 
\hyperlink{1494761116451616317}{\texttt{Base.:\&}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
&(x, y)
\end{lstlisting}

Bitwise and.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 4 & 10
0

julia> 4 & 12
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L639-L652}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9633687763646488853}{} 
\hyperlink{9633687763646488853}{\texttt{Base.:|}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
|(x, y)
\end{lstlisting}

Bitwise or.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 4 | 10
14

julia> 4 | 1
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2584-L2597}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7071880015536674935}{} 
\hyperlink{7071880015536674935}{\texttt{Base.xor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
xor(x, y)
⊻(x, y)
\end{lstlisting}

Bitwise exclusive or of \texttt{x} and \texttt{y}.  The infix operation \texttt{a ⊻ b} is a synonym for \texttt{xor(a,b)}, and \texttt{⊻} can be typed by tab-completing \texttt{{\textbackslash}xor} or \texttt{{\textbackslash}veebar} in the Julia REPL.


\begin{minted}{jlcon}
julia> [true; true; false] .⊻ [true; false; false]
3-element BitArray{1}:
 false
  true
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bool.jl#L44-L60}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4329035214952292986}{} 
\hyperlink{4329035214952292986}{\texttt{Base.:!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
!(x)
\end{lstlisting}

Boolean not.


\begin{minted}{jlcon}
julia> !true
false

julia> !false
true

julia> .![true false true]
1×3 BitArray{2}:
 false  true  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bool.jl#L17-L33}{\texttt{source}}



\begin{lstlisting}
!f::Function
\end{lstlisting}

Predicate function negation: when the argument of \texttt{!} is a function, it returns a function which computes the boolean negation of \texttt{f}. Example:


\begin{minted}{jlcon}
julia> str = "∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"
"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"

julia> filter(isalpha, str)
"εδxyδfxfyε"

julia> filter(!isalpha, str)
"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < "
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L887-L903}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4714012140247170866}{} 
\hyperlink{4714012140247170866}{\texttt{\&\&}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
x && y
\end{lstlisting}

Short-circuiting boolean AND.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L543-L547}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2053797086840563251}{} 
\hyperlink{2053797086840563251}{\texttt{||}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
x || y
\end{lstlisting}

Short-circuiting boolean OR.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L550-L554}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8251612812642852850}{}


\section{Funciones Matemáticas}


\hypertarget{12499503887608197213}{} 
\hyperlink{12499503887608197213}{\texttt{Base.isapprox}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isapprox(x, y; rtol::Real=sqrt(eps), atol::Real=0, nans::Bool=false, norm::Function)
\end{lstlisting}

Inexact equality comparison: \texttt{true} if \texttt{norm(x-y) <= atol + rtol*max(norm(x), norm(y))}. The default \texttt{atol} is zero and the default \texttt{rtol} depends on the types of \texttt{x} and \texttt{y}. The keyword argument \texttt{nans} determines whether or not NaN values are considered equal (defaults to false).

For real or complex floating-point values, \texttt{rtol} defaults to \texttt{sqrt(eps(typeof(real(x-y))))}. This corresponds to requiring equality of about half of the significand digits. For other types, \texttt{rtol} defaults to zero.

\texttt{x} and \texttt{y} may also be arrays of numbers, in which case \texttt{norm} defaults to \texttt{vecnorm} but may be changed by passing a \texttt{norm::Function} keyword argument. (For numbers, \texttt{norm} is the same thing as \texttt{abs}.) When \texttt{x} and \texttt{y} are arrays, if \texttt{norm(x-y)} is not finite (i.e. \texttt{±Inf} or \texttt{NaN}), the comparison falls back to checking whether all elements of \texttt{x} and \texttt{y} are approximately equal component-wise.

The binary operator \texttt{≈} is equivalent to \texttt{isapprox} with the default arguments, and \texttt{x ≉ y} is equivalent to \texttt{!isapprox(x,y)}.


\begin{minted}{jlcon}
julia> 0.1 ≈ (0.1 - 1e-10)
true

julia> isapprox(10, 11; atol = 2)
true

julia> isapprox([10.0^9, 1.0], [10.0^9, 2.0])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/floatfuncs.jl#L173-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1413692256182243634}{} 
\hyperlink{1413692256182243634}{\texttt{Base.sin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sin(x)
\end{lstlisting}

Compute sine of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L303-L307}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3839439755891439510}{} 
\hyperlink{3839439755891439510}{\texttt{Base.cos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cos(x)
\end{lstlisting}

Compute cosine of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L310-L314}{\texttt{source}}


\end{adjustwidth}
\hypertarget{875859158779400131}{} 
\hyperlink{875859158779400131}{\texttt{Base.tan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tan(x)
\end{lstlisting}

Compute tangent of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L317-L321}{\texttt{source}}


\end{adjustwidth}
\hypertarget{38337471195460170}{} 
\hyperlink{38337471195460170}{\texttt{Base.Math.sind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sind(x)
\end{lstlisting}

Compute sine of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L413-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6437354581891939537}{} 
\hyperlink{6437354581891939537}{\texttt{Base.Math.cosd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cosd(x)
\end{lstlisting}

Compute cosine of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L413-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10125316154174803495}{} 
\hyperlink{10125316154174803495}{\texttt{Base.Math.tand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tand(x)
\end{lstlisting}

Compute tangent of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L413-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16554510911661822298}{} 
\hyperlink{16554510911661822298}{\texttt{Base.Math.sinpi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sinpi(x)
\end{lstlisting}

Compute \(\sin(\pi x)\) more accurately than \texttt{sin(pi*x)}, especially for large \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L101-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2974547424856180253}{} 
\hyperlink{2974547424856180253}{\texttt{Base.Math.cospi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cospi(x)
\end{lstlisting}

Compute \(\cos(\pi x)\) more accurately than \texttt{cos(pi*x)}, especially for large \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L164-L168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5181646255621667089}{} 
\hyperlink{5181646255621667089}{\texttt{Base.sinh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sinh(x)
\end{lstlisting}

Compute hyperbolic sine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L195-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3329134313078667573}{} 
\hyperlink{3329134313078667573}{\texttt{Base.cosh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cosh(x)
\end{lstlisting}

Compute hyperbolic cosine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L202-L206}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11556677775153310560}{} 
\hyperlink{11556677775153310560}{\texttt{Base.tanh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tanh(x)
\end{lstlisting}

Compute hyperbolic tangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L209-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2780084174302963520}{} 
\hyperlink{2780084174302963520}{\texttt{Base.asin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asin(x)
\end{lstlisting}

Compute the inverse sine of \texttt{x}, where the output is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L324-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9075308317485607956}{} 
\hyperlink{9075308317485607956}{\texttt{Base.acos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acos(x)
\end{lstlisting}

Compute the inverse cosine of \texttt{x}, where the output is in radians



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L331-L335}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7954015677485259843}{} 
\hyperlink{7954015677485259843}{\texttt{Base.atan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atan(x)
\end{lstlisting}

Compute the inverse tangent of \texttt{x}, where the output is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L216-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14548930143416451643}{} 
\hyperlink{14548930143416451643}{\texttt{Base.Math.atan2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atan2(y, x)
\end{lstlisting}

Compute the inverse tangent of \texttt{y/x}, using the signs of both \texttt{x} and \texttt{y} to determine the quadrant of the return value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L488-L493}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11304354062744129101}{} 
\hyperlink{11304354062744129101}{\texttt{Base.Math.asind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asind(x)
\end{lstlisting}

Compute the inverse sine of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9068426203671659431}{} 
\hyperlink{9068426203671659431}{\texttt{Base.Math.acosd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acosd(x)
\end{lstlisting}

Compute the inverse cosine of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16709452940889335182}{} 
\hyperlink{16709452940889335182}{\texttt{Base.Math.atand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atand(x)
\end{lstlisting}

Compute the inverse tangent of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14099135455017918456}{} 
\hyperlink{14099135455017918456}{\texttt{Base.Math.sec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sec(x)
\end{lstlisting}

Compute the secant of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1895-L1899}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4884849677881797647}{} 
\hyperlink{4884849677881797647}{\texttt{Base.Math.csc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
csc(x)
\end{lstlisting}

Compute the cosecant of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1462-L1466}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3862797501947473111}{} 
\hyperlink{3862797501947473111}{\texttt{Base.Math.cot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cot(x)
\end{lstlisting}

Compute the cotangent of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1411-L1415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3627927627858191087}{} 
\hyperlink{3627927627858191087}{\texttt{Base.Math.secd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
secd(x)
\end{lstlisting}

Compute the secant of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1815-L1819}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5282241990933081613}{} 
\hyperlink{5282241990933081613}{\texttt{Base.Math.cscd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cscd(x)
\end{lstlisting}

Compute the cosecant of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2471-L2475}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10552388625489786427}{} 
\hyperlink{10552388625489786427}{\texttt{Base.Math.cotd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cotd(x)
\end{lstlisting}

Compute the cotangent of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1537-L1541}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11957141737062775737}{} 
\hyperlink{11957141737062775737}{\texttt{Base.Math.asec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asec(x)
\end{lstlisting}

Compute the inverse secant of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L323-L325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4883715079741069599}{} 
\hyperlink{4883715079741069599}{\texttt{Base.Math.acsc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acsc(x)
\end{lstlisting}

Compute the inverse cosecant of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L323-L325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15052830344020086660}{} 
\hyperlink{15052830344020086660}{\texttt{Base.Math.acot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acot(x)
\end{lstlisting}

Compute the inverse cotangent of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L323-L325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11130798465735678102}{} 
\hyperlink{11130798465735678102}{\texttt{Base.Math.asecd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asecd(x)
\end{lstlisting}

Compute the inverse secant of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4156782540452156093}{} 
\hyperlink{4156782540452156093}{\texttt{Base.Math.acscd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acscd(x)
\end{lstlisting}

Compute the inverse cosecant of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8127927203221847430}{} 
\hyperlink{8127927203221847430}{\texttt{Base.Math.acotd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acotd(x)
\end{lstlisting}

Compute the inverse cotangent of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6710905779265456786}{} 
\hyperlink{6710905779265456786}{\texttt{Base.Math.sech}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sech(x)
\end{lstlisting}

Compute the hyperbolic secant of \texttt{x}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L190-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12699005275601525751}{} 
\hyperlink{12699005275601525751}{\texttt{Base.Math.csch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
csch(x)
\end{lstlisting}

Compute the hyperbolic cosecant of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1888-L1892}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15539047088574298259}{} 
\hyperlink{15539047088574298259}{\texttt{Base.Math.coth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
coth(x)
\end{lstlisting}

Compute the hyperbolic cotangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2112-L2116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15539429965228872041}{} 
\hyperlink{15539429965228872041}{\texttt{Base.asinh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asinh(x)
\end{lstlisting}

Compute the inverse hyperbolic sine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L223-L227}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16766917678182986345}{} 
\hyperlink{16766917678182986345}{\texttt{Base.acosh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acosh(x)
\end{lstlisting}

Compute the inverse hyperbolic cosine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L338-L342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7005502320333033073}{} 
\hyperlink{7005502320333033073}{\texttt{Base.atanh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atanh(x)
\end{lstlisting}

Compute the inverse hyperbolic tangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L345-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7333053894423460686}{} 
\hyperlink{7333053894423460686}{\texttt{Base.Math.asech}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asech(x)
\end{lstlisting}

Compute the inverse hyperbolic secant of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L326-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1665506352762766435}{} 
\hyperlink{1665506352762766435}{\texttt{Base.Math.acsch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acsch(x)
\end{lstlisting}

Compute the inverse hyperbolic cosecant of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L326-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6288003572537523273}{} 
\hyperlink{6288003572537523273}{\texttt{Base.Math.acoth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acoth(x)
\end{lstlisting}

Compute the inverse hyperbolic cotangent of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L326-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16625449660258120296}{} 
\hyperlink{16625449660258120296}{\texttt{Base.Math.sinc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sinc(x)
\end{lstlisting}

Compute \(\sin(\pi x) / (\pi x)\) if \(x \neq 0\), and \(1\) if \(x = 0\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L288-L292}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16278225468798010360}{} 
\hyperlink{16278225468798010360}{\texttt{Base.Math.cosc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cosc(x)
\end{lstlisting}

Compute \(\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)\) if \(x \neq 0\), and \(0\) if \(x = 0\). This is the derivative of \texttt{sinc(x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L298-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11016541033238436876}{} 
\hyperlink{11016541033238436876}{\texttt{Base.Math.deg2rad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deg2rad(x)
\end{lstlisting}

Convert \texttt{x} from degrees to radians.


\begin{minted}{jlcon}
julia> deg2rad(90)
1.5707963267948966
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L145-L154}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17164560583584594903}{} 
\hyperlink{17164560583584594903}{\texttt{Base.Math.rad2deg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rad2deg(x)
\end{lstlisting}

Convert \texttt{x} from radians to degrees.


\begin{minted}{jlcon}
julia> rad2deg(pi)
180.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L133-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18304489571285447949}{} 
\hyperlink{18304489571285447949}{\texttt{Base.Math.hypot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hypot(x, y)
\end{lstlisting}

Compute the hypotenuse \(\sqrt{x^2+y^2}\) avoiding overflow and underflow.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 10^10;

julia> hypot(a, a)
1.4142135623730951e10

julia> √(a^2 + a^2) # a^2 overflows
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Int64) at ./math.jl:434
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L436-L454}{\texttt{source}}



\begin{lstlisting}
hypot(x...)
\end{lstlisting}

Compute the hypotenuse \(\sqrt{\sum x_i^2}\) avoiding overflow and underflow.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L481-L485}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8009828793607756367}{} 
\hyperlink{8009828793607756367}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log(x)
\end{lstlisting}

Compute the natural logarithm of \texttt{x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments. Use complex negative arguments to obtain complex results.

There is an experimental variant in the \texttt{Base.Math.JuliaLibm} module, which is typically faster and more accurate.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L352-L360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10582107494419543982}{} 
\hyperlink{10582107494419543982}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log(b,x)
\end{lstlisting}

Compute the base \texttt{b} logarithm of \texttt{x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.


\begin{minted}{jlcon}
julia> log(4,8)
1.5

julia> log(4,2)
0.5
\end{minted}

\begin{quote}
\textbf{Note}

If \texttt{b} is a power of 2 or 10, \hyperlink{18341149201477905713}{\texttt{log2}} or \hyperlink{3481560771470480868}{\texttt{log10}} should be used, as these will typically be faster and more accurate. For example,


\begin{minted}{jlcon}
julia> log(100,1000000)
2.9999999999999996

julia> log10(1000000)/2
3.0
\end{minted}

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L161-L186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18341149201477905713}{} 
\hyperlink{18341149201477905713}{\texttt{Base.log2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log2(x)
\end{lstlisting}

Compute the logarithm of \texttt{x} to base 2. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Example}


\begin{minted}{jlcon}
julia> log2(4)
2.0

julia> log2(10)
3.321928094887362
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L363-L377}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3481560771470480868}{} 
\hyperlink{3481560771470480868}{\texttt{Base.log10}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log10(x)
\end{lstlisting}

Compute the logarithm of \texttt{x} to base 10. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Example}


\begin{minted}{jlcon}
julia> log10(100)
2.0

julia> log10(2)
0.3010299956639812
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L380-L394}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5533050447473188877}{} 
\hyperlink{5533050447473188877}{\texttt{Base.log1p}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log1p(x)
\end{lstlisting}

Accurate natural logarithm of \texttt{1+x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for \hyperlink{6175959395021454412}{\texttt{Real}} arguments less than -1.

There is an experimental variant in the \texttt{Base.Math.JuliaLibm} module, which is typically faster and more accurate.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log1p(-0.5)
-0.6931471805599453

julia> log1p(0)
0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L397-L414}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12570003490345822061}{} 
\hyperlink{12570003490345822061}{\texttt{Base.Math.frexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
frexp(val)
\end{lstlisting}

Return \texttt{(x,exp)} such that \texttt{x} has a magnitude in the interval \([1/2, 1)\) or 0, and \texttt{val} is equal to \(x \times 2^{exp}\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L614-L619}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5754159997488499390}{} 
\hyperlink{5754159997488499390}{\texttt{Base.exp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exp(x)
\end{lstlisting}

Compute the natural base exponential of \texttt{x}, in other words \(e^x\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/exp.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12542609616026627164}{} 
\hyperlink{12542609616026627164}{\texttt{Base.exp2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exp2(x)
\end{lstlisting}

Compute \(2^x\).


\begin{minted}{jlcon}
julia> exp2(5)
32.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L262-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4510833300532946775}{} 
\hyperlink{4510833300532946775}{\texttt{Base.exp10}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exp10(x)
\end{lstlisting}

Compute \(10^x\).

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp10(2)
100.0

julia> exp10(0.2)
1.5848931924611136
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L623-L636}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14721177606508229464}{} 
\hyperlink{14721177606508229464}{\texttt{Base.Math.ldexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ldexp(x, n)
\end{lstlisting}

Compute \(x \times 2^n\).

\textbf{Example}


\begin{minted}{jlcon}
julia> ldexp(5., 2)
20.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L512-L522}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7336011242447784962}{} 
\hyperlink{7336011242447784962}{\texttt{Base.Math.modf}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
modf(x)
\end{lstlisting}

Return a tuple (fpart,ipart) of the fractional and integral parts of a number. Both parts have the same sign as the argument.

\textbf{Example}


\begin{minted}{jlcon}
julia> modf(3.5)
(0.5, 3.0)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L673-L684}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4939309737829480377}{} 
\hyperlink{4939309737829480377}{\texttt{Base.expm1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
expm1(x)
\end{lstlisting}

Accurately compute \(e^x-1\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L230-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12930779325193350739}{} 
\hyperlink{12930779325193350739}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
round([T,] x, [digits, [base]], [r::RoundingMode])
\end{lstlisting}

Rounds \texttt{x} to an integer value according to the provided \hyperlink{16713322195952720212}{\texttt{RoundingMode}}, returning a value of the same type as \texttt{x}. When not specifying a rounding mode the global mode will be used (see \hyperlink{6511778857518292792}{\texttt{rounding}}), which by default is round to the nearest integer (\hyperlink{868115654703135309}{\texttt{RoundNearest}} mode), with ties (fractional values of 0.5) being rounded to the nearest even integer.


\begin{minted}{jlcon}
julia> round(1.7)
2.0

julia> round(1.5)
2.0

julia> round(2.5)
2.0
\end{minted}

The optional \hyperlink{16713322195952720212}{\texttt{RoundingMode}} argument will change how the number gets rounded.

\texttt{round(T, x, [r::RoundingMode])} converts the result to type \texttt{T}, throwing an \hyperlink{5399118524830636312}{\texttt{InexactError}} if the value is not representable.

\texttt{round(x, digits)} rounds to the specified number of digits after the decimal place (or before if negative). \texttt{round(x, digits, base)} rounds using a base other than 10.


\begin{minted}{jlcon}
julia> round(pi, 2)
3.14

julia> round(pi, 3, 2)
3.125
\end{minted}

\begin{quote}
\textbf{Note}

Rounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the \hyperlink{5027751419500983000}{\texttt{Float64}} value represented by \texttt{1.15} is actually \emph{less} than 1.15, yet will be rounded to 1.2.


\begin{minted}{jlcon}
julia> x = 1.15
1.15

julia> @sprintf "%.20f" x
"1.14999999999999991118"

julia> x < 115//100
true

julia> round(x, 1)
1.2
\end{minted}

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/floatfuncs.jl#L42-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16713322195952720212}{} 
\hyperlink{16713322195952720212}{\texttt{Base.Rounding.RoundingMode}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundingMode
\end{lstlisting}

A type used for controlling the rounding mode of floating point operations (via \hyperlink{6511778857518292792}{\texttt{rounding}}/\hyperlink{12025922235501343815}{\texttt{setrounding}} functions), or as optional arguments for rounding to the nearest integer (via the \hyperlink{7894166454005036294}{\texttt{round}} function).

Currently supported rounding modes are:

\begin{itemize}
\item \hyperlink{868115654703135309}{\texttt{RoundNearest}} (default)


\item \hyperlink{975776970636292472}{\texttt{RoundNearestTiesAway}}


\item \hyperlink{9147917195826641690}{\texttt{RoundNearestTiesUp}}


\item \hyperlink{7760059079134067537}{\texttt{RoundToZero}}


\item \texttt{RoundFromZero} (\hyperlink{749816618809421837}{\texttt{BigFloat}} only)


\item \hyperlink{874246484265932239}{\texttt{RoundUp}}


\item \hyperlink{3648739763580508258}{\texttt{RoundDown}}

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L26-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{868115654703135309}{} 
\hyperlink{868115654703135309}{\texttt{Base.Rounding.RoundNearest}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundNearest
\end{lstlisting}

The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L46-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{975776970636292472}{} 
\hyperlink{975776970636292472}{\texttt{Base.Rounding.RoundNearestTiesAway}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundNearestTiesAway
\end{lstlisting}

Rounds to nearest integer, with ties rounded away from zero (C/C++ \hyperlink{7894166454005036294}{\texttt{round}} behaviour).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L77-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9147917195826641690}{} 
\hyperlink{9147917195826641690}{\texttt{Base.Rounding.RoundNearestTiesUp}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundNearestTiesUp
\end{lstlisting}

Rounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript \hyperlink{7894166454005036294}{\texttt{round}} behaviour).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L85-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7760059079134067537}{} 
\hyperlink{7760059079134067537}{\texttt{Base.Rounding.RoundToZero}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundToZero
\end{lstlisting}

\hyperlink{7894166454005036294}{\texttt{round}} using this rounding mode is an alias for \hyperlink{1728363361565303194}{\texttt{trunc}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{874246484265932239}{} 
\hyperlink{874246484265932239}{\texttt{Base.Rounding.RoundUp}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundUp
\end{lstlisting}

\hyperlink{7894166454005036294}{\texttt{round}} using this rounding mode is an alias for \hyperlink{10519509038312853061}{\texttt{ceil}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L61-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3648739763580508258}{} 
\hyperlink{3648739763580508258}{\texttt{Base.Rounding.RoundDown}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundDown
\end{lstlisting}

\hyperlink{7894166454005036294}{\texttt{round}} using this rounding mode is an alias for \hyperlink{11115257331910840693}{\texttt{floor}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L68-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17596897159817666741}{} 
\hyperlink{17596897159817666741}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
round(z, RoundingModeReal, RoundingModeImaginary)
\end{lstlisting}

Returns the nearest integral value of the same type as the complex-valued \texttt{z} to \texttt{z}, breaking ties using the specified \hyperlink{16713322195952720212}{\texttt{RoundingMode}}s. The first \hyperlink{16713322195952720212}{\texttt{RoundingMode}} is used for rounding the real components while the second is used for rounding the imaginary components.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L876-L883}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10519509038312853061}{} 
\hyperlink{10519509038312853061}{\texttt{Base.ceil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ceil([T,] x, [digits, [base]])
\end{lstlisting}

\texttt{ceil(x)} returns the nearest integral value of the same type as \texttt{x} that is greater than or equal to \texttt{x}.

\texttt{ceil(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits} and \texttt{base} work as for \hyperlink{7894166454005036294}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L364-L374}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11115257331910840693}{} 
\hyperlink{11115257331910840693}{\texttt{Base.floor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
floor([T,] x, [digits, [base]])
\end{lstlisting}

\texttt{floor(x)} returns the nearest integral value of the same type as \texttt{x} that is less than or equal to \texttt{x}.

\texttt{floor(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits} and \texttt{base} work as for \hyperlink{7894166454005036294}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L680-L690}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1728363361565303194}{} 
\hyperlink{1728363361565303194}{\texttt{Base.trunc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trunc([T,] x, [digits, [base]])
\end{lstlisting}

\texttt{trunc(x)} returns the nearest integral value of the same type as \texttt{x} whose absolute value is less than or equal to \texttt{x}.

\texttt{trunc(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits} and \texttt{base} work as for \hyperlink{7894166454005036294}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1024-L1034}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6382984648980626356}{} 
\hyperlink{6382984648980626356}{\texttt{Base.unsafe\_trunc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_trunc(T, x)
\end{lstlisting}

\texttt{unsafe\_trunc(T, x)} returns the nearest integral value of type \texttt{T} whose absolute value is less than or equal to \texttt{x}. If the value is not representable by \texttt{T}, an arbitrary value will be returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1789-L1795}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11117199371278593126}{} 
\hyperlink{11117199371278593126}{\texttt{Base.signif}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
signif(x, digits, [base])
\end{lstlisting}

Rounds (in the sense of \hyperlink{7894166454005036294}{\texttt{round}}) \texttt{x} so that there are \texttt{digits} significant digits, under a base \texttt{base} representation, default 10. E.g., \texttt{signif(123.456, 2)} is \texttt{120.0}, and \texttt{signif(357.913, 4, 2)} is \texttt{352.0}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2303-L2309}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7458766354532817148}{} 
\hyperlink{7458766354532817148}{\texttt{Base.min}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
min(x, y, ...)
\end{lstlisting}

Return the minimum of the arguments. See also the \hyperlink{5463833925251886106}{\texttt{minimum}} function to take the minimum element from a collection.


\begin{minted}{jlcon}
julia> min(2, 5, 1)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L350-L360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7839419811914289844}{} 
\hyperlink{7839419811914289844}{\texttt{Base.max}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
max(x, y, ...)
\end{lstlisting}

Return the maximum of the arguments. See also the \hyperlink{10566500735406837086}{\texttt{maximum}} function to take the maximum element from a collection.


\begin{minted}{jlcon}
julia> max(2, 5, 1)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L337-L347}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9004904914922806611}{} 
\hyperlink{9004904914922806611}{\texttt{Base.minmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minmax(x, y)
\end{lstlisting}

Return \texttt{(min(x,y), max(x,y))}. See also: \hyperlink{3146721823766527688}{\texttt{extrema}} that returns \texttt{(minimum(x), maximum(x))}.


\begin{minted}{jlcon}
julia> minmax('c','b')
('b', 'c')
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L363-L372}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2549437629093220350}{} 
\hyperlink{2549437629093220350}{\texttt{Base.Math.clamp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clamp(x, lo, hi)
\end{lstlisting}

Return \texttt{x} if \texttt{lo <= x <= hi}. If \texttt{x < lo}, return \texttt{lo}. If \texttt{x > hi}, return \texttt{hi}. Arguments are promoted to a common type.


\begin{minted}{jlcon}
julia> clamp.([pi, 1.0, big(10.)], 2., 9.)
3-element Array{BigFloat,1}:
 3.141592653589793238462643383279502884197169399375105820974944592307816406286198
 2.000000000000000000000000000000000000000000000000000000000000000000000000000000
 9.000000000000000000000000000000000000000000000000000000000000000000000000000000
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L42-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15974741233540534893}{} 
\hyperlink{15974741233540534893}{\texttt{Base.Math.clamp!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clamp!(array::AbstractArray, lo, hi)
\end{lstlisting}

Restrict values in \texttt{array} to the specified range, in-place. See also \hyperlink{2549437629093220350}{\texttt{clamp}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L62-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9614495866226399167}{} 
\hyperlink{9614495866226399167}{\texttt{Base.abs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
abs(x)
\end{lstlisting}

The absolute value of \texttt{x}.

When \texttt{abs} is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when \texttt{abs} is applied to the minimum representable value of a signed integer. That is, when \texttt{x == typemin(typeof(x))}, \texttt{abs(x) == x < 0}, not \texttt{-x} as might be expected.


\begin{minted}{jlcon}
julia> abs(-3)
3

julia> abs(1 + im)
1.4142135623730951

julia> abs(typemin(Int64))
-9223372036854775808
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L87-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10885135672778604809}{} 
\hyperlink{10885135672778604809}{\texttt{Base.Checked.checked\_abs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_abs(x)
\end{lstlisting}

Calculates \texttt{abs(x)}, checking for overflow errors where applicable. For example, standard two{\textquotesingle}s complement signed integers (e.g. \texttt{Int}) cannot represent \texttt{abs(typemin(Int))}, thus leading to an overflow.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L107-L115}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13229568824844995103}{} 
\hyperlink{13229568824844995103}{\texttt{Base.Checked.checked\_neg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_neg(x)
\end{lstlisting}

Calculates \texttt{-x}, checking for overflow errors where applicable. For example, standard two{\textquotesingle}s complement signed integers (e.g. \texttt{Int}) cannot represent \texttt{-typemin(Int)}, thus leading to an overflow.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L81-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2964592337942314373}{} 
\hyperlink{2964592337942314373}{\texttt{Base.Checked.checked\_add}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_add(x, y)
\end{lstlisting}

Calculates \texttt{x+y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L155-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10268341695343039853}{} 
\hyperlink{10268341695343039853}{\texttt{Base.Checked.checked\_sub}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_sub(x, y)
\end{lstlisting}

Calculates \texttt{x-y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L212-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4390963153143215118}{} 
\hyperlink{4390963153143215118}{\texttt{Base.Checked.checked\_mul}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_mul(x, y)
\end{lstlisting}

Calculates \texttt{x*y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L277-L283}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6689390039928836022}{} 
\hyperlink{6689390039928836022}{\texttt{Base.Checked.checked\_div}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_div(x, y)
\end{lstlisting}

Calculates \texttt{div(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L306-L312}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12129844323919398781}{} 
\hyperlink{12129844323919398781}{\texttt{Base.Checked.checked\_rem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_rem(x, y)
\end{lstlisting}

Calculates \texttt{x\%y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L315-L321}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3745431966407804814}{} 
\hyperlink{3745431966407804814}{\texttt{Base.Checked.checked\_fld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_fld(x, y)
\end{lstlisting}

Calculates \texttt{fld(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L324-L330}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2512435134040972090}{} 
\hyperlink{2512435134040972090}{\texttt{Base.Checked.checked\_mod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_mod(x, y)
\end{lstlisting}

Calculates \texttt{mod(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L333-L339}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1863194407625991652}{} 
\hyperlink{1863194407625991652}{\texttt{Base.Checked.checked\_cld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_cld(x, y)
\end{lstlisting}

Calculates \texttt{cld(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L342-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862869478194651358}{} 
\hyperlink{8862869478194651358}{\texttt{Base.Checked.add\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.add_with_overflow(x, y) -> (r, f)
\end{lstlisting}

Calculates \texttt{r = x+y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L128-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2951243344761333492}{} 
\hyperlink{2951243344761333492}{\texttt{Base.Checked.sub\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.sub_with_overflow(x, y) -> (r, f)
\end{lstlisting}

Calculates \texttt{r = x-y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L187-L191}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9052860252825488939}{} 
\hyperlink{9052860252825488939}{\texttt{Base.Checked.mul\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.mul_with_overflow(x, y) -> (r, f)
\end{lstlisting}

Calculates \texttt{r = x*y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L227-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15686257922156163743}{} 
\hyperlink{15686257922156163743}{\texttt{Base.abs2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
abs2(x)
\end{lstlisting}

Squared absolute value of \texttt{x}.


\begin{minted}{jlcon}
julia> abs2(-3)
9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L84-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6024566200716053110}{} 
\hyperlink{6024566200716053110}{\texttt{Base.copysign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copysign(x, y) -> z
\end{lstlisting}

Return \texttt{z} which has the magnitude of \texttt{x} and the same sign as \texttt{y}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> copysign(1, -2)
-1

julia> copysign(-1, 2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L799-L812}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14349105033929355161}{} 
\hyperlink{14349105033929355161}{\texttt{Base.sign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sign(x)
\end{lstlisting}

Return zero if \texttt{x==0} and \(x/|x|\) otherwise (i.e., ±1 for real \texttt{x}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L74-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9457038569823603490}{} 
\hyperlink{9457038569823603490}{\texttt{Base.signbit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
signbit(x)
\end{lstlisting}

Returns \texttt{true} if the value of the sign of \texttt{x} is negative, otherwise \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> signbit(-4)
true

julia> signbit(5)
false

julia> signbit(5.5)
false

julia> signbit(-4.1)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2449-L2468}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2689022981470151558}{} 
\hyperlink{2689022981470151558}{\texttt{Base.flipsign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flipsign(x, y)
\end{lstlisting}

Return \texttt{x} with its sign flipped if \texttt{y} is negative. For example \texttt{abs(x) = flipsign(x,x)}.


\begin{minted}{jlcon}
julia> flipsign(5, 3)
5

julia> flipsign(5, -3)
-5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L96-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4178506499510800909}{} 
\hyperlink{4178506499510800909}{\texttt{Base.sqrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sqrt(x)
\end{lstlisting}

Return \(\sqrt{x}\). Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments. Use complex negative arguments instead. The prefix operator \texttt{√} is equivalent to \texttt{sqrt}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L428-L433}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13061326033497045577}{} 
\hyperlink{13061326033497045577}{\texttt{Base.isqrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isqrt(n::Integer)
\end{lstlisting}

Integer square root: the largest integer \texttt{m} such that \texttt{m*m <= n}.


\begin{minted}{jlcon}
julia> isqrt(5)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L745-L754}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15104025502404840355}{} 
\hyperlink{15104025502404840355}{\texttt{Base.Math.cbrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cbrt(x::Real)
\end{lstlisting}

Return the cube root of \texttt{x}, i.e. \(x^{1/3}\). Negative values are accepted (returning the negative real root when \(x < 0\)).

The prefix operator \texttt{∛} is equivalent to \texttt{cbrt}.


\begin{minted}{jlcon}
julia> cbrt(big(27))
3.000000000000000000000000000000000000000000000000000000000000000000000000000000
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L247-L259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10579540000886584250}{} 
\hyperlink{10579540000886584250}{\texttt{Base.real}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
real(z)
\end{lstlisting}

Return the real part of the complex number \texttt{z}.


\begin{minted}{jlcon}
julia> real(1 + 3im)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L44-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13331686588901351068}{} 
\hyperlink{13331686588901351068}{\texttt{Base.imag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
imag(z)
\end{lstlisting}

Return the imaginary part of the complex number \texttt{z}.


\begin{minted}{jlcon}
julia> imag(1 + 3im)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L56-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4559968878634602058}{} 
\hyperlink{4559968878634602058}{\texttt{Base.reim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reim(z)
\end{lstlisting}

Return both the real and imaginary parts of the complex number \texttt{z}.


\begin{minted}{jlcon}
julia> reim(1 + 3im)
(1, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L70-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9940023991150673697}{} 
\hyperlink{9940023991150673697}{\texttt{Base.conj}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
conj(z)
\end{lstlisting}

Compute the complex conjugate of a complex number \texttt{z}.


\begin{minted}{jlcon}
julia> conj(1 + 3im)
1 - 3im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L204-L213}{\texttt{source}}



\begin{lstlisting}
conj(v::RowVector)
\end{lstlisting}

Returns a \hyperlink{5185144354217809072}{\texttt{ConjArray}} lazy view of the input, where each element is conjugated.

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [1+im, 1-im].'
1×2 RowVector{Complex{Int64},Array{Complex{Int64},1}}:
 1+1im  1-1im

julia> conj(v)
1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:
 1-1im  1+1im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/rowvector.jl#L88-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9465547375318501186}{} 
\hyperlink{9465547375318501186}{\texttt{Base.angle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
angle(z)
\end{lstlisting}

Compute the phase angle in radians of a complex number \texttt{z}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L444-L448}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4687572676090761946}{} 
\hyperlink{4687572676090761946}{\texttt{Base.cis}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cis(z)
\end{lstlisting}

Return \(\exp(iz)\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L434-L438}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7127784108654808529}{} 
\hyperlink{7127784108654808529}{\texttt{Base.binomial}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
binomial(n, k)
\end{lstlisting}

Number of ways to choose \texttt{k} out of \texttt{n} items.

\textbf{Example}


\begin{minted}{jlcon}
julia> binomial(5, 3)
10

julia> factorial(5) ÷ (factorial(5-3) * factorial(3))
10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L776-L789}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1793920701415589315}{} 
\hyperlink{1793920701415589315}{\texttt{Base.factorial}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
factorial(n)
\end{lstlisting}

Factorial of \texttt{n}. If \texttt{n} is an \hyperlink{8469131683393450448}{\texttt{Integer}}, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if \texttt{n} is not small, but you can use \texttt{factorial(big(n))} to compute the result exactly in arbitrary precision. If \texttt{n} is not an \texttt{Integer}, \texttt{factorial(n)} is equivalent to \hyperlink{12101057483100859108}{\texttt{gamma(n+1)}}.


\begin{minted}{jlcon}
julia> factorial(6)
720

julia> factorial(21)
ERROR: OverflowError()
[...]

julia> factorial(21.0)
5.109094217170944e19

julia> factorial(big(21))
51090942171709440000
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L216-L238}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15906911311436241979}{} 
\hyperlink{15906911311436241979}{\texttt{Base.gcd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gcd(x,y)
\end{lstlisting}

Greatest common (positive) divisor (or zero if \texttt{x} and \texttt{y} are both zero).

\textbf{Examples}


\begin{minted}{jlcon}
julia> gcd(6,9)
3

julia> gcd(6,-9)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L5-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12975400110924105221}{} 
\hyperlink{12975400110924105221}{\texttt{Base.lcm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lcm(x,y)
\end{lstlisting}

Least common (non-negative) multiple.

\textbf{Examples}


\begin{minted}{jlcon}
julia> lcm(2,3)
6

julia> lcm(-2,3)
6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L51-L64}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18359524628605105681}{} 
\hyperlink{18359524628605105681}{\texttt{Base.gcdx}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gcdx(x,y)
\end{lstlisting}

Computes the greatest common (positive) divisor of \texttt{x} and \texttt{y} and their Bézout coefficients, i.e. the integer coefficients \texttt{u} and \texttt{v} that satisfy \(ux+vy = d = gcd(x,y)\). \(gcdx(x,y)\) returns \((d,u,v)\).

\textbf{Examples}


\begin{minted}{jlcon}
julia> gcdx(12, 42)
(6, -3, 1)

julia> gcdx(240, 46)
(2, -9, 47)
\end{minted}

\begin{quote}
\textbf{Note}

Bézout coefficients are \emph{not} uniquely defined. \texttt{gcdx} returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients \texttt{u} and \texttt{v} are minimal in the sense that \(|u| < |y/d|\) and \(|v| < |x/d|\). Furthermore, the signs of \texttt{u} and \texttt{v} are chosen so that \texttt{d} is positive. For unsigned integers, the coefficients \texttt{u} and \texttt{v} might be near their \texttt{typemax}, and the identity then holds only via the unsigned integers{\textquotesingle} modulo arithmetic.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L85-L111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{598817088840034027}{} 
\hyperlink{598817088840034027}{\texttt{Base.ispow2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ispow2(n::Integer) -> Bool
\end{lstlisting}

Test whether \texttt{n} is a power of two.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ispow2(4)
true

julia> ispow2(5)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L311-L324}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4594482809725895873}{} 
\hyperlink{4594482809725895873}{\texttt{Base.nextpow2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextpow2(n::Integer)
\end{lstlisting}

The smallest power of two not less than \texttt{n}. Returns 0 for \texttt{n==0}, and returns \texttt{-nextpow2(-n)} for negative arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nextpow2(16)
16

julia> nextpow2(17)
32
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L275-L289}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16846138768010848855}{} 
\hyperlink{16846138768010848855}{\texttt{Base.prevpow2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prevpow2(n::Integer)
\end{lstlisting}

The largest power of two not greater than \texttt{n}. Returns 0 for \texttt{n==0}, and returns \texttt{-prevpow2(-n)} for negative arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prevpow2(5)
4

julia> prevpow2(0)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L293-L307}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14955572944376366290}{} 
\hyperlink{14955572944376366290}{\texttt{Base.nextpow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextpow(a, x)
\end{lstlisting}

The smallest \texttt{a{\textasciicircum}n} not less than \texttt{x}, where \texttt{n} is a non-negative integer. \texttt{a} must be greater than 1, and \texttt{x} must be greater than 0.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nextpow(2, 7)
8

julia> nextpow(2, 9)
16

julia> nextpow(5, 20)
25

julia> nextpow(4, 16)
16
\end{minted}

See also \hyperlink{488025580584649031}{\texttt{prevpow}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L327-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{488025580584649031}{} 
\hyperlink{488025580584649031}{\texttt{Base.prevpow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prevpow(a, x)
\end{lstlisting}

The largest \texttt{a{\textasciicircum}n} not greater than \texttt{x}, where \texttt{n} is a non-negative integer. \texttt{a} must be greater than 1, and \texttt{x} must not be less than 1.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prevpow(2, 7)
4

julia> prevpow(2, 9)
8

julia> prevpow(5, 20)
5

julia> prevpow(4, 16)
16
\end{minted}

See also \hyperlink{14955572944376366290}{\texttt{nextpow}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L359-L380}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9591900175500358341}{} 
\hyperlink{9591900175500358341}{\texttt{Base.nextprod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextprod([k_1, k_2,...], n)
\end{lstlisting}

Next integer greater than or equal to \texttt{n} that can be written as \(\prod k_i^{p_i}\) for integers \(p_1\), \(p_2\), etc.

\textbf{Example}


\begin{minted}{jlcon}
julia> nextprod([2, 3], 105)
108

julia> 2^2 * 3^3
108
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L234-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17191792848451148355}{} 
\hyperlink{17191792848451148355}{\texttt{Base.invmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
invmod(x,m)
\end{lstlisting}

Take the inverse of \texttt{x} modulo \texttt{m}: \texttt{y} such that \(x y = 1 \pmod m\), with \(div(x,y) = 0\). This is undefined for \(m = 0\), or if \(gcd(x,m) \neq 1\).

\textbf{Examples}


\begin{minted}{jlcon}
julia> invmod(2,5)
3

julia> invmod(2,3)
2

julia> invmod(5,6)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L129-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5886563157147453257}{} 
\hyperlink{5886563157147453257}{\texttt{Base.powermod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
powermod(x::Integer, p::Integer, m)
\end{lstlisting}

Compute \(x^p \pmod m\).

\textbf{Examples}


\begin{minted}{jlcon}
julia> powermod(2, 6, 5)
4

julia> mod(2^6, 5)
4

julia> powermod(5, 2, 20)
5

julia> powermod(5, 2, 19)
6

julia> powermod(5, 3, 19)
11
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L226-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12101057483100859108}{} 
\hyperlink{12101057483100859108}{\texttt{Base.Math.gamma}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gamma(x)
\end{lstlisting}

Compute the gamma function of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L6-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16944460120463679422}{} 
\hyperlink{16944460120463679422}{\texttt{Base.Math.lgamma}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lgamma(x)
\end{lstlisting}

Compute the logarithm of the absolute value of \hyperlink{12101057483100859108}{\texttt{gamma}} for \hyperlink{6175959395021454412}{\texttt{Real}} \texttt{x}, while for \hyperlink{11302502367029942782}{\texttt{Complex}} \texttt{x} compute the principal branch cut of the logarithm of \texttt{gamma(x)} (defined for negative \texttt{real(x)} by analytic continuation from positive \texttt{real(x)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L36-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15642673718348524569}{} 
\hyperlink{15642673718348524569}{\texttt{Base.Math.lfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lfact(x)
\end{lstlisting}

Compute the logarithmic factorial of a nonnegative integer \texttt{x}. Equivalent to \hyperlink{16944460120463679422}{\texttt{lgamma}} of \texttt{x + 1}, but \texttt{lgamma} extends this function to non-integer \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L27-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3070115649335374621}{} 
\hyperlink{3070115649335374621}{\texttt{Base.Math.beta}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
beta(x, y)
\end{lstlisting}

Euler integral of the first kind \(\operatorname{B}(x,y) = \Gamma(x)\Gamma(y)/\Gamma(x+y)\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L139-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15599420217619146595}{} 
\hyperlink{15599420217619146595}{\texttt{Base.Math.lbeta}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lbeta(x, y)
\end{lstlisting}

Natural logarithm of the absolute value of the \hyperlink{3070115649335374621}{\texttt{beta}} function \(\log(|\operatorname{B}(x,y)|)\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L151-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7415013084438358060}{} 
\hyperlink{7415013084438358060}{\texttt{Base.ndigits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ndigits(n::Integer, b::Integer=10)
\end{lstlisting}

Compute the number of digits in integer \texttt{n} written in base \texttt{b}. The base \texttt{b} must not be in \texttt{[-1, 0, 1]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ndigits(12345)
5

julia> ndigits(1022, 16)
3

julia> base(16, 1022)
"3fe"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L481-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4564031682097452426}{} 
\hyperlink{4564031682097452426}{\texttt{Base.widemul}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
widemul(x, y)
\end{lstlisting}

Multiply \texttt{x} and \texttt{y}, giving the result as a larger type.


\begin{minted}{jlcon}
julia> widemul(Float32(3.), 4.)
1.200000000000000000000000000000000000000000000000000000000000000000000000000000e+01
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L118-L127}{\texttt{source}}


\end{adjustwidth}
\hypertarget{552638784001429566}{} 
\hyperlink{552638784001429566}{\texttt{Base.Math.@evalpoly}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@evalpoly(z, c...)
\end{lstlisting}

Evaluate the polynomial \(\sum_k c[k] z^{k-1}\) for the coefficients \texttt{c[1]}, \texttt{c[2]}, ...; that is, the coefficients are given in ascending order by power of \texttt{z}.  This macro expands to efficient inline code that uses either Horner{\textquotesingle}s method or, for complex \texttt{z}, a more efficient Goertzel-like algorithm.


\begin{minted}{jlcon}
julia> @evalpoly(3, 1, 0, 1)
10

julia> @evalpoly(2, 1, 0, 1)
5

julia> @evalpoly(2, 1, 1, 1)
7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L89-L107}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9525826009664353115}{}


\section{Estadística}


\hypertarget{2002825322838319654}{} 
\hyperlink{2002825322838319654}{\texttt{Base.mean}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mean(f::Function, v)
\end{lstlisting}

Apply the function \texttt{f} to each element of \texttt{v} and take the mean.


\begin{minted}{jlcon}
julia> mean(√, [1, 2, 3])
1.3820881233139908

julia> mean([√1, √2, √3])
1.3820881233139908
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L5-L17}{\texttt{source}}



\begin{lstlisting}
mean(v[, region])
\end{lstlisting}

Compute the mean of whole array \texttt{v}, or optionally along the dimensions in \texttt{region}.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L48-L56}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11275601330930982108}{} 
\hyperlink{11275601330930982108}{\texttt{Base.mean!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mean!(r, v)
\end{lstlisting}

Compute the mean of \texttt{v} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1736-L1740}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8821409723106968118}{} 
\hyperlink{8821409723106968118}{\texttt{Base.std}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
std(v[, region]; corrected::Bool=true, mean=nothing)
\end{lstlisting}

Compute the sample standard deviation of a vector or array \texttt{v}, optionally along dimensions in \texttt{region}. The algorithm returns an estimator of the generative distribution{\textquotesingle}s standard deviation under the assumption that each entry of \texttt{v} is an IID drawn from that generative distribution. This computation is equivalent to calculating \texttt{sqrt(sum((v - mean(v)).{\textasciicircum}2) / (length(v) - 1))}. A pre-computed \texttt{mean} may be provided. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L249-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4196140908140297324}{} 
\hyperlink{4196140908140297324}{\texttt{Base.stdm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stdm(v, m::Number; corrected::Bool=true)
\end{lstlisting}

Compute the sample standard deviation of a vector \texttt{v} with known mean \texttt{m}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L271-L283}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7174335757357744571}{} 
\hyperlink{7174335757357744571}{\texttt{Base.var}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
var(v[, region]; corrected::Bool=true, mean=nothing)
\end{lstlisting}

Compute the sample variance of a vector or array \texttt{v}, optionally along dimensions in \texttt{region}. The algorithm will return an estimator of the generative distribution{\textquotesingle}s variance under the assumption that each entry of \texttt{v} is an IID drawn from that generative distribution. This computation is equivalent to calculating \texttt{sum(abs2, v - mean(v)) / (length(v) - 1)}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}. The mean \texttt{mean} over the region may be provided.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L188-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5349278597847317202}{} 
\hyperlink{5349278597847317202}{\texttt{Base.varm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
varm(v, m[, region]; corrected::Bool=true)
\end{lstlisting}

Compute the sample variance of a collection \texttt{v} with known mean(s) \texttt{m}, optionally over \texttt{region}. \texttt{m} may contain means for each dimension of \texttt{v}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L167-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17123713281788045930}{} 
\hyperlink{17123713281788045930}{\texttt{Base.middle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
middle(x)
\end{lstlisting}

Compute the middle of a scalar value, which is equivalent to \texttt{x} itself, but of the type of \texttt{middle(x, x)} for consistency.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L533-L537}{\texttt{source}}



\begin{lstlisting}
middle(x, y)
\end{lstlisting}

Compute the middle of two reals \texttt{x} and \texttt{y}, which is equivalent in both value and type to computing their mean (\texttt{(x + y) / 2}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L543-L548}{\texttt{source}}



\begin{lstlisting}
middle(range)
\end{lstlisting}

Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.


\begin{minted}{jlcon}
julia> middle(1:10)
5.5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L551-L561}{\texttt{source}}



\begin{lstlisting}
middle(a)
\end{lstlisting}

Compute the middle of an array \texttt{a}, which consists of finding its extrema and then computing their mean.


\begin{minted}{jlcon}
julia> a = [1,2,3.6,10.9]
4-element Array{Float64,1}:
  1.0
  2.0
  3.6
 10.9

julia> middle(a)
5.95
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L564-L581}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11179782716658704342}{} 
\hyperlink{11179782716658704342}{\texttt{Base.median}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
median(v[, region])
\end{lstlisting}

Compute the median of an entire array \texttt{v}, or, optionally, along the dimensions in \texttt{region}. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L609-L620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9482186025590628546}{} 
\hyperlink{9482186025590628546}{\texttt{Base.median!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
median!(v)
\end{lstlisting}

Like \hyperlink{11179782716658704342}{\texttt{median}}, but may overwrite the input vector.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L584-L588}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16460295794470869961}{} 
\hyperlink{16460295794470869961}{\texttt{Base.quantile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
quantile(v, p; sorted=false)
\end{lstlisting}

Compute the quantile(s) of a vector \texttt{v} at a specified probability or vector \texttt{p}. The keyword argument \texttt{sorted} indicates whether \texttt{v} can be assumed to be sorted.

The \texttt{p} should be on the interval [0,1], and \texttt{v} should not have any \texttt{NaN} values.

Quantiles are computed via linear interpolation between the points \texttt{((k-1)/(n-1), v[k])}, for \texttt{k = 1:n} where \texttt{n = length(v)}. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended. \texttt{quantile} will throw an \texttt{ArgumentError} in the presence of \texttt{NaN} values in the data array.

\end{quote}
\begin{itemize}
\item Hyndman, R.J and Fan, Y. (1996) {\textquotedbl}Sample Quantiles in Statistical Packages{\textquotedbl}, \emph{The American Statistician}, Vol. 50, No. 4, pp. 361-365

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L719-L738}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8191466670466322000}{} 
\hyperlink{8191466670466322000}{\texttt{Base.quantile!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
quantile!([q, ] v, p; sorted=false)
\end{lstlisting}

Compute the quantile(s) of a vector \texttt{v} at the probabilities \texttt{p}, with optional output into array \texttt{q} (if not provided, a new output array is created). The keyword argument \texttt{sorted} indicates whether \texttt{v} can be assumed to be sorted; if \texttt{false} (the default), then the elements of \texttt{v} may be partially sorted.

The elements of \texttt{p} should be on the interval [0,1], and \texttt{v} should not have any \texttt{NaN} values.

Quantiles are computed via linear interpolation between the points \texttt{((k-1)/(n-1), v[k])}, for \texttt{k = 1:n} where \texttt{n = length(v)}. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended. \texttt{quantile!} will throw an \texttt{ArgumentError} in the presence of \texttt{NaN} values in the data array.

\end{quote}
\begin{itemize}
\item Hyndman, R.J and Fan, Y. (1996) {\textquotedbl}Sample Quantiles in Statistical Packages{\textquotedbl}, \emph{The American Statistician}, Vol. 50, No. 4, pp. 361-365

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L625-L647}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17277490353628239858}{} 
\hyperlink{17277490353628239858}{\texttt{Base.cov}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cov(x[, corrected=true])
\end{lstlisting}

Compute the variance of the vector \texttt{x}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L342-L347}{\texttt{source}}



\begin{lstlisting}
cov(X[, vardim=1, corrected=true])
\end{lstlisting}

Compute the covariance matrix of the matrix \texttt{X} along the dimension \texttt{vardim}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = size(X, vardim)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L352-L358}{\texttt{source}}



\begin{lstlisting}
cov(x, y[, corrected=true])
\end{lstlisting}

Compute the covariance between the vectors \texttt{x} and \texttt{y}. If \texttt{corrected} is \texttt{true} (the default), computes \(\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*\) where \(*\) denotes the complex conjugate and \texttt{n = length(x) = length(y)}. If \texttt{corrected} is \texttt{false}, computes \(rac{1}{n}sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L364-L371}{\texttt{source}}



\begin{lstlisting}
cov(X, Y[, vardim=1, corrected=true])
\end{lstlisting}

Compute the covariance between the vectors or matrices \texttt{X} and \texttt{Y} along the dimension \texttt{vardim}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = size(X, vardim) = size(Y, vardim)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L378-L384}{\texttt{source}}


\end{adjustwidth}
\hypertarget{635640719787866143}{} 
\hyperlink{635640719787866143}{\texttt{Base.cor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cor(x)
\end{lstlisting}

Return the number one.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L494-L498}{\texttt{source}}



\begin{lstlisting}
cor(X[, vardim=1])
\end{lstlisting}

Compute the Pearson correlation matrix of the matrix \texttt{X} along the dimension \texttt{vardim}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L502-L506}{\texttt{source}}



\begin{lstlisting}
cor(x, y)
\end{lstlisting}

Compute the Pearson correlation between the vectors \texttt{x} and \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L511-L515}{\texttt{source}}



\begin{lstlisting}
cor(X, Y[, vardim=1])
\end{lstlisting}

Compute the Pearson correlation between the vectors or matrices \texttt{X} and \texttt{Y} along the dimension \texttt{vardim}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L519-L523}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13906896320449862424}{}


\section{Procesamiento de Señales}



Las funciones de transformada rápida de Fourier (\emph{Fast Fourier transform} – FFT) en Julia están implementadas mediante llamadas a funciones de la librería \href{http://www.fftw.org}{FFTW}.


\hypertarget{3985477341468132593}{} 
\hyperlink{3985477341468132593}{\texttt{Base.DFT.fft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fft(A [, dims])
\end{lstlisting}

Performs a multidimensional FFT of the array \texttt{A}. The optional \texttt{dims} argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of \texttt{A} along the transformed dimensions is a product of small primes; see \texttt{nextprod()}. See also \texttt{plan\_fft()} for even greater efficiency.

A one-dimensional FFT computes the one-dimensional discrete Fourier transform (DFT) as defined by

\begin{equation*}
\begin{split}\operatorname{DFT}(A)[k] =
  \sum_{n=1}^{\operatorname{length}(A)}
  \exp\left(-i\frac{2\pi
  (n-1)(k-1)}{\operatorname{length}(A)} \right) A[n].\end{split}\end{equation*}
A multidimensional FFT simply performs this operation along each transformed dimension of \texttt{A}.

\begin{quote}
\textbf{Note}

\begin{itemize}
\item Julia starts FFTW up with 1 thread by default. Higher performance is usually possible by increasing number of threads. Use \texttt{FFTW.set\_num\_threads(Sys.CPU\_CORES)} to use as many threads as cores on your system.


\item This performs a multidimensional FFT by default. FFT libraries in other languages such as Python and Octave perform a one-dimensional FFT along the first non-singleton dimension of the array. This is worth noting while performing comparisons. For more details, refer to the \hyperlink{16083606765476288441}{Noteworthy Differences from other Languages} section of the manual.

\end{itemize}
\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L401-L431}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5173091226550296763}{} 
\hyperlink{5173091226550296763}{\texttt{Base.DFT.fft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fft!(A [, dims])
\end{lstlisting}

Same as \hyperlink{3985477341468132593}{\texttt{fft}}, but operates in-place on \texttt{A}, which must be an array of complex floating-point numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L169-L174}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13595721344189188463}{} 
\hyperlink{13595721344189188463}{\texttt{Base.DFT.ifft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ifft(A [, dims])
\end{lstlisting}

Multidimensional inverse FFT.

A one-dimensional inverse FFT computes

\begin{equation*}
\begin{split}\operatorname{IDFT}(A)[k] = \frac{1}{\operatorname{length}(A)}
\sum_{n=1}^{\operatorname{length}(A)} \exp\left(+i\frac{2\pi (n-1)(k-1)}
{\operatorname{length}(A)} \right) A[n].\end{split}\end{equation*}
A multidimensional inverse FFT simply performs this operation along each transformed dimension of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L152-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4986013805597074777}{} 
\hyperlink{4986013805597074777}{\texttt{Base.DFT.ifft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ifft!(A [, dims])
\end{lstlisting}

Same as \hyperlink{13595721344189188463}{\texttt{ifft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L145-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17084266922751986269}{} 
\hyperlink{17084266922751986269}{\texttt{Base.DFT.bfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bfft(A [, dims])
\end{lstlisting}

Similar to \hyperlink{13595721344189188463}{\texttt{ifft}}, but computes an unnormalized inverse (backward) transform, which must be divided by the product of the sizes of the transformed dimensions in order to obtain the inverse. (This is slightly more efficient than \hyperlink{13595721344189188463}{\texttt{ifft}} because it omits a scaling step, which in some applications can be combined with other computational steps elsewhere.)

\begin{equation*}
\begin{split}\operatorname{BDFT}(A)[k] = \operatorname{length}(A) \operatorname{IDFT}(A)[k]\end{split}\end{equation*}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L177-L189}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4223518985457844046}{} 
\hyperlink{4223518985457844046}{\texttt{Base.DFT.bfft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bfft!(A [, dims])
\end{lstlisting}

Same as \hyperlink{17084266922751986269}{\texttt{bfft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L192-L196}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5662326709694019683}{} 
\hyperlink{5662326709694019683}{\texttt{Base.DFT.plan\_fft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_fft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Pre-plan an optimized FFT along given dimensions (\texttt{dims}) of arrays matching the shape and type of \texttt{A}.  (The first two arguments have the same meaning as for \hyperlink{3985477341468132593}{\texttt{fft}}.) Returns an object \texttt{P} which represents the linear operator computed by the FFT, and which contains all of the information needed to compute \texttt{fft(A, dims)} quickly.

To apply \texttt{P} to an array \texttt{A}, use \texttt{P * A}; in general, the syntax for applying plans is much like that of matrices.  (A plan can only be applied to arrays of the same size as the \texttt{A} for which the plan was created.)  You can also apply a plan with a preallocated output array \texttt{Â} by calling \texttt{A\_mul\_B!(Â, plan, A)}.  (For \texttt{A\_mul\_B!}, however, the input array \texttt{A} must be a complex floating-point array like the output \texttt{Â}.) You can compute the inverse-transform plan by \texttt{inv(P)} and apply the inverse plan with \texttt{P {\textbackslash} Â} (the inverse plan is cached and reused for subsequent calls to \texttt{inv} or \texttt{{\textbackslash}}), and apply the inverse plan to a pre-allocated output array \texttt{A} with \texttt{A\_ldiv\_B!(A, P, Â)}.

The \texttt{flags} argument is a bitwise-or of FFTW planner flags, defaulting to \texttt{FFTW.ESTIMATE}. e.g. passing \texttt{FFTW.MEASURE} or \texttt{FFTW.PATIENT} will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags.  The optional \texttt{timelimit} argument specifies a rough upper bound on the allowed planning time, in seconds. Passing \texttt{FFTW.MEASURE} or \texttt{FFTW.PATIENT} may cause the input array \texttt{A} to be overwritten with zeros during plan creation.

\hyperlink{4167351963411530120}{\texttt{plan\_fft!}} is the same as \hyperlink{5662326709694019683}{\texttt{plan\_fft}} but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). \hyperlink{11132438775767023322}{\texttt{plan\_ifft}} and so on are similar but produce plans that perform the equivalent of the inverse transforms \hyperlink{13595721344189188463}{\texttt{ifft}} and so on.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L92-L121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11132438775767023322}{} 
\hyperlink{11132438775767023322}{\texttt{Base.DFT.plan\_ifft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_ifft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{5662326709694019683}{\texttt{plan\_fft}}, but produces a plan that performs inverse transforms \hyperlink{13595721344189188463}{\texttt{ifft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L62-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5148058741299398507}{} 
\hyperlink{5148058741299398507}{\texttt{Base.DFT.plan\_bfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_bfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{5662326709694019683}{\texttt{plan\_fft}}, but produces a plan that performs an unnormalized backwards transform \hyperlink{17084266922751986269}{\texttt{bfft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L84-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4167351963411530120}{} 
\hyperlink{4167351963411530120}{\texttt{Base.DFT.plan\_fft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_fft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{5662326709694019683}{\texttt{plan\_fft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L124-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18249851546818355203}{} 
\hyperlink{18249851546818355203}{\texttt{Base.DFT.plan\_ifft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_ifft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{11132438775767023322}{\texttt{plan\_ifft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L70-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6203327325390100148}{} 
\hyperlink{6203327325390100148}{\texttt{Base.DFT.plan\_bfft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_bfft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{5148058741299398507}{\texttt{plan\_bfft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L77-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10962439848710721870}{} 
\hyperlink{10962439848710721870}{\texttt{Base.DFT.rfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rfft(A [, dims])
\end{lstlisting}

Multidimensional FFT of a real array \texttt{A}, exploiting the fact that the transform has conjugate symmetry in order to save roughly half the computational time and storage costs compared with \hyperlink{3985477341468132593}{\texttt{fft}}. If \texttt{A} has size \texttt{(n\_1, ..., n\_d)}, the result has size \texttt{(div(n\_1,2)+1, ..., n\_d)}.

The optional \texttt{dims} argument specifies an iterable subset of one or more dimensions of \texttt{A} to transform, similar to \hyperlink{3985477341468132593}{\texttt{fft}}. Instead of (roughly) halving the first dimension of \texttt{A} in the result, the \texttt{dims[1]} dimension is (roughly) halved in the same way.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L131-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2841119442394337591}{} 
\hyperlink{2841119442394337591}{\texttt{Base.DFT.irfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
irfft(A, d [, dims])
\end{lstlisting}

Inverse of \hyperlink{10962439848710721870}{\texttt{rfft}}: for a complex array \texttt{A}, gives the corresponding real array whose FFT yields \texttt{A} in the first half. As for \hyperlink{10962439848710721870}{\texttt{rfft}}, \texttt{dims} is an optional subset of dimensions to transform, defaulting to \texttt{1:ndims(A)}.

\texttt{d} is the length of the transformed real array along the \texttt{dims[1]} dimension, which must satisfy \texttt{div(d,2)+1 == size(A,dims[1])}. (This parameter cannot be inferred from \texttt{size(A)} since both \texttt{2*size(A,dims[1])-2} as well as \texttt{2*size(A,dims[1])-1} are valid sizes for the transformed real array.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L302-L313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15795936628254264831}{} 
\hyperlink{15795936628254264831}{\texttt{Base.DFT.brfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
brfft(A, d [, dims])
\end{lstlisting}

Similar to \hyperlink{2841119442394337591}{\texttt{irfft}} but computes an unnormalized inverse transform (similar to \hyperlink{17084266922751986269}{\texttt{bfft}}), which must be divided by the product of the sizes of the transformed dimensions (of the real output array) in order to obtain the inverse transform.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L316-L322}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9764256859829273381}{} 
\hyperlink{9764256859829273381}{\texttt{Base.DFT.plan\_rfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_rfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Pre-plan an optimized real-input FFT, similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}} except for \hyperlink{10962439848710721870}{\texttt{rfft}} instead of \hyperlink{3985477341468132593}{\texttt{fft}}. The first two arguments, and the size of the transformed result, are the same as for \hyperlink{10962439848710721870}{\texttt{rfft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L434-L440}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17882312537894422737}{} 
\hyperlink{17882312537894422737}{\texttt{Base.DFT.plan\_brfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_brfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Pre-plan an optimized real-input unnormalized transform, similar to \hyperlink{9764256859829273381}{\texttt{plan\_rfft}} except for \hyperlink{15795936628254264831}{\texttt{brfft}} instead of \hyperlink{10962439848710721870}{\texttt{rfft}}. The first two arguments and the size of the transformed result, are the same as for \hyperlink{15795936628254264831}{\texttt{brfft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L443-L450}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7411543459302942660}{} 
\hyperlink{7411543459302942660}{\texttt{Base.DFT.plan\_irfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_irfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Pre-plan an optimized inverse real-input FFT, similar to \hyperlink{9764256859829273381}{\texttt{plan\_rfft}} except for \hyperlink{2841119442394337591}{\texttt{irfft}} and \hyperlink{15795936628254264831}{\texttt{brfft}}, respectively. The first three arguments have the same meaning as for \hyperlink{2841119442394337591}{\texttt{irfft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L344-L350}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7333038527866016312}{} 
\hyperlink{7333038527866016312}{\texttt{Base.DFT.FFTW.dct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dct(A [, dims])
\end{lstlisting}

Performs a multidimensional type-II discrete cosine transform (DCT) of the array \texttt{A}, using the unitary normalization of the DCT. The optional \texttt{dims} argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along.  Most efficient if the size of \texttt{A} along the transformed dimensions is a product of small primes; see \hyperlink{9591900175500358341}{\texttt{nextprod}}. See also \hyperlink{16521473777634385764}{\texttt{plan\_dct}} for even greater efficiency.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L494-L503}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17481908707827491950}{} 
\hyperlink{17481908707827491950}{\texttt{Base.DFT.FFTW.dct!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dct!(A [, dims])
\end{lstlisting}

Same as \hyperlink{17481908707827491950}{\texttt{dct!}}, except that it operates in-place on \texttt{A}, which must be an array of real or complex floating-point values.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L518-L523}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5888602804203711650}{} 
\hyperlink{5888602804203711650}{\texttt{Base.DFT.FFTW.idct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
idct(A [, dims])
\end{lstlisting}

Computes the multidimensional inverse discrete cosine transform (DCT) of the array \texttt{A} (technically, a type-III DCT with the unitary normalization). The optional \texttt{dims} argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along.  Most efficient if the size of \texttt{A} along the transformed dimensions is a product of small primes; see \hyperlink{9591900175500358341}{\texttt{nextprod}}.  See also \hyperlink{17542025272603481562}{\texttt{plan\_idct}} for even greater efficiency.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L506-L515}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1798327509127332273}{} 
\hyperlink{1798327509127332273}{\texttt{Base.DFT.FFTW.idct!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
idct!(A [, dims])
\end{lstlisting}

Same as \hyperlink{1798327509127332273}{\texttt{idct!}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L526-L530}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16521473777634385764}{} 
\hyperlink{16521473777634385764}{\texttt{Base.DFT.FFTW.plan\_dct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_dct(A [, dims [, flags [, timelimit]]])
\end{lstlisting}

Pre-plan an optimized discrete cosine transform (DCT), similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}} except producing a function that computes \hyperlink{7333038527866016312}{\texttt{dct}}. The first two arguments have the same meaning as for \hyperlink{7333038527866016312}{\texttt{dct}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L477-L484}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11618475594877507716}{} 
\hyperlink{11618475594877507716}{\texttt{Base.DFT.FFTW.plan\_dct!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_dct!(A [, dims [, flags [, timelimit]]])
\end{lstlisting}

Same as \hyperlink{16521473777634385764}{\texttt{plan\_dct}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L460-L464}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17542025272603481562}{} 
\hyperlink{17542025272603481562}{\texttt{Base.DFT.FFTW.plan\_idct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_idct(A [, dims [, flags [, timelimit]]])
\end{lstlisting}

Pre-plan an optimized inverse discrete cosine transform (DCT), similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}} except producing a function that computes \hyperlink{5888602804203711650}{\texttt{idct}}. The first two arguments have the same meaning as for \hyperlink{5888602804203711650}{\texttt{idct}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L467-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3911513489803128060}{} 
\hyperlink{3911513489803128060}{\texttt{Base.DFT.FFTW.plan\_idct!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_idct!(A [, dims [, flags [, timelimit]]])
\end{lstlisting}

Same as \hyperlink{17542025272603481562}{\texttt{plan\_idct}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L487-L491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11783177028290610958}{} 
\hyperlink{11783177028290610958}{\texttt{Base.DFT.fftshift}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fftshift(x)
\end{lstlisting}

Swap the first and second halves of each dimension of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L359-L363}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15316294171790549537}{} 
\hyperlink{15316294171790549537}{\texttt{Base.DFT.fftshift}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fftshift(x,dim)
\end{lstlisting}

Swap the first and second halves of the given dimension or iterable of dimensions of array \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L374-L378}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11093965455991767579}{} 
\hyperlink{11093965455991767579}{\texttt{Base.DFT.ifftshift}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ifftshift(x, [dim])
\end{lstlisting}

Undoes the effect of \texttt{fftshift}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L383-L387}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4032689265202828824}{} 
\hyperlink{4032689265202828824}{\texttt{Base.DSP.filt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filt(b, a, x, [si])
\end{lstlisting}

Apply filter described by vectors \texttt{a} and \texttt{b} to vector \texttt{x}, with an optional initial filter state vector \texttt{si} (defaults to zeros).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L11-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6936084423679867241}{} 
\hyperlink{6936084423679867241}{\texttt{Base.DSP.filt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filt!(out, b, a, x, [si])
\end{lstlisting}

Same as \hyperlink{4032689265202828824}{\texttt{filt}} but writes the result into the \texttt{out} argument, which may alias the input \texttt{x} to modify it in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L25-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3218079418813875795}{} 
\hyperlink{3218079418813875795}{\texttt{Base.DSP.deconv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deconv(b,a) -> c
\end{lstlisting}

Construct vector \texttt{c} such that \texttt{b = conv(a,c) + r}. Equivalent to polynomial division.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L105-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16464652106793971903}{} 
\hyperlink{16464652106793971903}{\texttt{Base.DSP.conv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
conv(u,v)
\end{lstlisting}

Convolution of two vectors. Uses FFT algorithm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L123-L127}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12320048174617111011}{} 
\hyperlink{12320048174617111011}{\texttt{Base.DSP.conv2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
conv2(u,v,A)
\end{lstlisting}

2-D convolution of the matrix \texttt{A} with the 2-D separable kernel generated by the vectors \texttt{u} and \texttt{v}. Uses 2-D FFT algorithm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L148-L154}{\texttt{source}}



\begin{lstlisting}
conv2(B,A)
\end{lstlisting}

2-D convolution of the matrix \texttt{B} with the matrix \texttt{A}. Uses 2-D FFT algorithm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L169-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7370255343750411311}{} 
\hyperlink{7370255343750411311}{\texttt{Base.DSP.xcorr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
xcorr(u,v)
\end{lstlisting}

Compute the cross-correlation of two vectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L192-L196}{\texttt{source}}


\end{adjustwidth}

Las siguientes funciones están definidas dentro del módulo \texttt{Base.FFTW}.


\hypertarget{14687703779290255687}{} 
\hyperlink{14687703779290255687}{\texttt{Base.DFT.FFTW.r2r}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
r2r(A, kind [, dims])
\end{lstlisting}

Performs a multidimensional real-input/real-output (r2r) transform of type \texttt{kind} of the array \texttt{A}, as defined in the FFTW manual. \texttt{kind} specifies either a discrete cosine transform of various types (\texttt{FFTW.REDFT00}, \texttt{FFTW.REDFT01}, \texttt{FFTW.REDFT10}, or \texttt{FFTW.REDFT11}), a discrete sine transform of various types (\texttt{FFTW.RODFT00}, \texttt{FFTW.RODFT01}, \texttt{FFTW.RODFT10}, or \texttt{FFTW.RODFT11}), a real-input DFT with halfcomplex-format output (\texttt{FFTW.R2HC} and its inverse \texttt{FFTW.HC2R}), or a discrete Hartley transform (\texttt{FFTW.DHT}).  The \texttt{kind} argument may be an array or tuple in order to specify different transform types along the different dimensions of \texttt{A}; \texttt{kind[end]} is used for any unspecified dimensions.  See the FFTW manual for precise definitions of these transform types, at http://www.fftw.org/doc.

The optional \texttt{dims} argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. \texttt{kind[i]} is then the transform type for \texttt{dims[i]}, with \texttt{kind[end]} being used for \texttt{i > length(kind)}.

See also \hyperlink{6641116333364172687}{\texttt{plan\_r2r}} to pre-plan optimized r2r transforms.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L533-L556}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14749561168372739927}{} 
\hyperlink{14749561168372739927}{\texttt{Base.DFT.FFTW.r2r!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
r2r!(A, kind [, dims])
\end{lstlisting}

Same as \hyperlink{14687703779290255687}{\texttt{r2r}}, but operates in-place on \texttt{A}, which must be an array of real or complex floating-point numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L559-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6641116333364172687}{} 
\hyperlink{6641116333364172687}{\texttt{Base.DFT.FFTW.plan\_r2r}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_r2r(A, kind [, dims [, flags [, timelimit]]])
\end{lstlisting}

Pre-plan an optimized r2r transform, similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}} except that the transforms (and the first three arguments) correspond to \hyperlink{14687703779290255687}{\texttt{r2r}} and \hyperlink{14749561168372739927}{\texttt{r2r!}}, respectively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L574-L580}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13859363726116484202}{} 
\hyperlink{13859363726116484202}{\texttt{Base.DFT.FFTW.plan\_r2r!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_r2r!(A, kind [, dims [, flags [, timelimit]]])
\end{lstlisting}

Similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}}, but corresponds to \hyperlink{14749561168372739927}{\texttt{r2r!}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L567-L571}{\texttt{source}}


\end{adjustwidth}

\hypertarget{856545484690558276}{}


\chapter{Números}



\hypertarget{5094626598663504020}{}


\section{Tipos Numéricos Estándar}



\hypertarget{2979437205044461587}{}


\subsection{Tipos Numéricos Abstractos}


\hypertarget{1990584313715697055}{} 
\hyperlink{1990584313715697055}{\texttt{Core.Number}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Number
\end{lstlisting}

Abstract supertype for all number types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2668-L2672}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6175959395021454412}{} 
\hyperlink{6175959395021454412}{\texttt{Core.Real}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Real <: Number
\end{lstlisting}

Abstract supertype for all real numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2675-L2679}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11465394427882483091}{} 
\hyperlink{11465394427882483091}{\texttt{Core.AbstractFloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AbstractFloat <: Real
\end{lstlisting}

Abstract supertype for all floating point numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2682-L2686}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8469131683393450448}{} 
\hyperlink{8469131683393450448}{\texttt{Core.Integer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Integer <: Real
\end{lstlisting}

Abstract supertype for all integers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2689-L2693}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14154866400772377486}{} 
\hyperlink{14154866400772377486}{\texttt{Core.Signed}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Signed <: Integer
\end{lstlisting}

Abstract supertype for all signed integers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2696-L2700}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4780971278803506664}{} 
\hyperlink{4780971278803506664}{\texttt{Core.Unsigned}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Unsigned <: Integer
\end{lstlisting}

Abstract supertype for all unsigned integers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2703-L2707}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11572379769881488316}{}


\subsection{Tipos Numéricos Concretos}


\hypertarget{2727296760866702904}{} 
\hyperlink{2727296760866702904}{\texttt{Core.Float16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float16 <: AbstractFloat
\end{lstlisting}

16-bit floating point number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2719-L2723}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8101639384272933082}{} 
\hyperlink{8101639384272933082}{\texttt{Core.Float32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float32 <: AbstractFloat
\end{lstlisting}

32-bit floating point number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2719-L2723}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5027751419500983000}{} 
\hyperlink{5027751419500983000}{\texttt{Core.Float64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float64 <: AbstractFloat
\end{lstlisting}

64-bit floating point number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2719-L2723}{\texttt{source}}


\end{adjustwidth}
\hypertarget{749816618809421837}{} 
\hyperlink{749816618809421837}{\texttt{Base.MPFR.BigFloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat <: AbstractFloat
\end{lstlisting}

Arbitrary precision floating point number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L43-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{46725311238864537}{} 
\hyperlink{46725311238864537}{\texttt{Core.Bool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Bool <: Integer
\end{lstlisting}

Boolean type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2710-L2714}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5857518405103968275}{} 
\hyperlink{5857518405103968275}{\texttt{Core.Int8}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int8 <: Signed
\end{lstlisting}

8-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6609065134969660118}{} 
\hyperlink{6609065134969660118}{\texttt{Core.UInt8}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt8 <: Unsigned
\end{lstlisting}

8-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6667287249103968645}{} 
\hyperlink{6667287249103968645}{\texttt{Core.Int16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int16 <: Signed
\end{lstlisting}

16-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7018610346698168012}{} 
\hyperlink{7018610346698168012}{\texttt{Core.UInt16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt16 <: Unsigned
\end{lstlisting}

16-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10103694114785108551}{} 
\hyperlink{10103694114785108551}{\texttt{Core.Int32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int32 <: Signed
\end{lstlisting}

32-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8690996847580776341}{} 
\hyperlink{8690996847580776341}{\texttt{Core.UInt32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt32 <: Unsigned
\end{lstlisting}

32-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7720564657383125058}{} 
\hyperlink{7720564657383125058}{\texttt{Core.Int64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int64 <: Signed
\end{lstlisting}

64-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5500998675195555601}{} 
\hyperlink{5500998675195555601}{\texttt{Core.UInt64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt64 <: Unsigned
\end{lstlisting}

64-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8012327724714767060}{} 
\hyperlink{8012327724714767060}{\texttt{Core.Int128}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int128 <: Signed
\end{lstlisting}

128-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14811222188335428522}{} 
\hyperlink{14811222188335428522}{\texttt{Core.UInt128}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt128 <: Unsigned
\end{lstlisting}

128-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{423405808990690832}{} 
\hyperlink{423405808990690832}{\texttt{Base.GMP.BigInt}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigInt <: Integer
\end{lstlisting}

Arbitrary precision integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/gmp.jl#L40-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11302502367029942782}{} 
\hyperlink{11302502367029942782}{\texttt{Base.Complex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Complex{T<:Real} <: Number
\end{lstlisting}

Complex number type with real and imaginary part of type \texttt{T}.

\texttt{Complex32}, \texttt{Complex64} and \texttt{Complex128} are aliases for \texttt{Complex\{Float16\}}, \texttt{Complex\{Float32\}} and \texttt{Complex\{Float64\}} respectively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L3-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8304566144531167610}{} 
\hyperlink{8304566144531167610}{\texttt{Base.Rational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Rational{T<:Integer} <: Real
\end{lstlisting}

Rational number type, with numerator and denominator of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5993828909973077529}{} 
\hyperlink{5993828909973077529}{\texttt{Base.Irrational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Irrational <: Real
\end{lstlisting}

Irrational number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7990310119520784797}{}


\section{Formatos de Datos}


\hypertarget{16742420098960517985}{} 
\hyperlink{16742420098960517985}{\texttt{Base.bin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bin(n, pad::Int=1)
\end{lstlisting}

Convert an integer to a binary string, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> bin(10,2)
"1010"

julia> bin(10,8)
"00001010"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L601-L613}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14394143983309720145}{} 
\hyperlink{14394143983309720145}{\texttt{Base.hex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hex(n, pad::Int=1)
\end{lstlisting}

Convert an integer to a hexadecimal string, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> hex(20)
"14"

julia> hex(20, 3)
"014"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L616-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12862597547050958664}{} 
\hyperlink{12862597547050958664}{\texttt{Base.dec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dec(n, pad::Int=1)
\end{lstlisting}

Convert an integer to a decimal string, optionally specifying a number of digits to pad to.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dec(20)
"20"

julia> dec(20, 3)
"020"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L648-L662}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11886519039750543945}{} 
\hyperlink{11886519039750543945}{\texttt{Base.oct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
oct(n, pad::Int=1)
\end{lstlisting}

Convert an integer to an octal string, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> oct(20)
"24"

julia> oct(20, 3)
"024"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L632-L645}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13209172751165879613}{} 
\hyperlink{13209172751165879613}{\texttt{Base.base}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
base(base::Integer, n::Integer, pad::Integer=1)
\end{lstlisting}

Convert an integer \texttt{n} to a string in the given \texttt{base}, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> base(13,5,4)
"0005"

julia> base(5,13,4)
"0023"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L574-L587}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17983913084963570964}{} 
\hyperlink{17983913084963570964}{\texttt{Base.digits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
digits([T<:Integer], n::Integer, base::T=10, pad::Integer=1)
\end{lstlisting}

Returns an array with element type \texttt{T} (default \texttt{Int}) of the digits of \texttt{n} in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indexes, such that \texttt{n == sum([digits[k]*base{\textasciicircum}(k-1) for k=1:length(digits)])}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> digits(10, 10)
2-element Array{Int64,1}:
 0
 1

julia> digits(10, 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia> digits(10, 2, 6)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L671-L701}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18145156230339025572}{} 
\hyperlink{18145156230339025572}{\texttt{Base.digits!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
digits!(array, n::Integer, base::Integer=10)
\end{lstlisting}

Fills an array of the digits of \texttt{n} in the given base. More significant digits are at higher indexes. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.

\textbf{Examples}


\begin{minted}{jlcon}
julia> digits!([2,2,2,2], 10, 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia> digits!([2,2,2,2,2,2], 10, 2)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L709-L734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11853073945412805100}{} 
\hyperlink{11853073945412805100}{\texttt{Base.bits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bits(n)
\end{lstlisting}

A string giving the literal bit representation of a number.

\textbf{Example}


\begin{minted}{jlcon}
julia> bits(4)
"0000000000000000000000000000000000000000000000000000000000000100"

julia> bits(2.2)
"0100000000000001100110011001100110011001100110011001100110011010"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L80-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13108503824143481717}{} 
\hyperlink{13108503824143481717}{\texttt{Base.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parse(type, str, [base])
\end{lstlisting}

Parse a string as a number. If the type is an integer type, then a base can be specified (the default is 10). If the type is a floating point type, the string is parsed as a decimal floating point number. If the string does not contain a valid number, an error is raised.


\begin{minted}{jlcon}
julia> parse(Int, "1234")
1234

julia> parse(Int, "1234", 5)
194

julia> parse(Int, "afc", 16)
2812

julia> parse(Float64, "1.2e-3")
0.0012
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1201-L1221}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16455869400787770938}{} 
\hyperlink{16455869400787770938}{\texttt{Base.tryparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tryparse(type, str, [base])
\end{lstlisting}

Like \hyperlink{13108503824143481717}{\texttt{parse}}, but returns a \hyperlink{2208920129454296646}{\texttt{Nullable}} of the requested type. The result will be null if the string does not contain a valid number.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2478-L2483}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2266887946765468938}{} 
\hyperlink{2266887946765468938}{\texttt{Base.big}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
big(x)
\end{lstlisting}

Convert a number to a maximum precision representation (typically \hyperlink{423405808990690832}{\texttt{BigInt}} or \texttt{BigFloat}). See \hyperlink{749816618809421837}{\texttt{BigFloat}} for information about some pitfalls with floating-point numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1373-L1378}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8153758211648029368}{} 
\hyperlink{8153758211648029368}{\texttt{Base.signed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
signed(x)
\end{lstlisting}

Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2566-L2571}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5348292453497802071}{} 
\hyperlink{5348292453497802071}{\texttt{Base.unsigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsigned(x) -> Unsigned
\end{lstlisting}

Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unsigned(-2)
0xfffffffffffffffe

julia> unsigned(2)
0x0000000000000002

julia> signed(unsigned(-2))
-2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2420-L2437}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6134868769696830446}{} 
\hyperlink{6134868769696830446}{\texttt{Base.float}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
float(x)
\end{lstlisting}

Convert a number or array to a floating point data type. When passed a string, this function is equivalent to \texttt{parse(Float64, x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L252-L257}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11312242195671521747}{} 
\hyperlink{11312242195671521747}{\texttt{Base.Math.significand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
significand(x)
\end{lstlisting}

Extract the \texttt{significand(s)} (a.k.a. mantissa), in binary representation, of a floating-point number. If \texttt{x} is a non-zero finite number, then the result will be a number of the same type on the interval \([1,2)\). Otherwise \texttt{x} is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> significand(15.2)/15.2
0.125

julia> significand(15.2)*8
15.2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L584-L599}{\texttt{source}}


\end{adjustwidth}
\hypertarget{39736318364195845}{} 
\hyperlink{39736318364195845}{\texttt{Base.Math.exponent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exponent(x) -> Int
\end{lstlisting}

Get the exponent of a normalized floating-point number.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L567-L571}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16014240202095271744}{} 
\hyperlink{16014240202095271744}{\texttt{Base.complex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
complex(r, [i])
\end{lstlisting}

Convert real numbers or arrays to complex. \texttt{i} defaults to zero.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L122-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{931573217390904193}{} 
\hyperlink{931573217390904193}{\texttt{Base.bswap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bswap(n)
\end{lstlisting}

Byte-swap an integer. Flip the bits of its binary representation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = bswap(4)
288230376151711744

julia> bswap(a)
4

julia> bin(1)
"1"

julia> bin(bswap(1))
"100000000000000000000000000000000000000000000000000000000"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1294-L1313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12462501897843140144}{} 
\hyperlink{12462501897843140144}{\texttt{Base.num2hex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
num2hex(f)
\end{lstlisting}

Get a hexadecimal string of the binary representation of a floating point number.

\textbf{Example}


\begin{minted}{jlcon}
julia> num2hex(2.2)
"400199999999999a"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L602-L612}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14747299776663320553}{} 
\hyperlink{14747299776663320553}{\texttt{Base.hex2num}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hex2num(str)
\end{lstlisting}

Convert a hexadecimal string to the floating point number it represents.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1602-L1606}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7748090932723143403}{} 
\hyperlink{7748090932723143403}{\texttt{Base.hex2bytes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hex2bytes(s::AbstractString)
\end{lstlisting}

Convert an arbitrarily long hexadecimal string to its binary representation. Returns an \texttt{Array\{UInt8,1\}}, i.e. an array of bytes.


\begin{minted}{jlcon}
julia> a = hex(12345)
"3039"

julia> hex2bytes(a)
2-element Array{UInt8,1}:
 0x30
 0x39
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L408-L423}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14739363105735559529}{} 
\hyperlink{14739363105735559529}{\texttt{Base.bytes2hex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bytes2hex(bin_arr::Array{UInt8, 1}) -> String
\end{lstlisting}

Convert an array of bytes to its hexadecimal representation. All characters are in lower-case.


\begin{minted}{jlcon}
julia> a = hex(12345)
"3039"

julia> b = hex2bytes(a)
2-element Array{UInt8,1}:
 0x30
 0x39

julia> bytes2hex(b)
"3039"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L446-L464}{\texttt{source}}


\end{adjustwidth}

\hypertarget{20674632076187775}{}


\section{Constantes y Funciones de Números Generales}


\hypertarget{11395333326208453101}{} 
\hyperlink{11395333326208453101}{\texttt{Base.one}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
one(x)
one(T::type)
\end{lstlisting}

Return a multiplicative identity for \texttt{x}: a value such that \texttt{one(x)*x == x*one(x) == x}.  Alternatively \texttt{one(T)} can take a type \texttt{T}, in which case \texttt{one} returns a multiplicative identity for any \texttt{x} of type \texttt{T}.

If possible, \texttt{one(x)} returns a value of the same type as \texttt{x}, and \texttt{one(T)} returns a value of type \texttt{T}.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, \texttt{one(x)} should return an identity value of the same precision (and shape, for matrices) as \texttt{x}.

If you want a quantity that is of the same type as \texttt{x}, or of type \texttt{T}, even if \texttt{x} is dimensionful, use \hyperlink{2310843180104103470}{\texttt{oneunit}} instead.


\begin{minted}{jlcon}
julia> one(3.7)
1.0

julia> one(Int)
1

julia> one(Dates.Day(1))
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L159-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2310843180104103470}{} 
\hyperlink{2310843180104103470}{\texttt{Base.oneunit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
oneunit(x::T)
oneunit(T::Type)
\end{lstlisting}

Returns \texttt{T(one(x))}, where \texttt{T} is either the type of the argument or (if a type is passed) the argument.  This differs from \hyperlink{11395333326208453101}{\texttt{one}} for dimensionful quantities: \texttt{one} is dimensionless (a multiplicative identity) while \texttt{oneunit} is dimensionful (of the same type as \texttt{x}, or of type \texttt{T}).


\begin{minted}{jlcon}
julia> oneunit(3.7)
1.0

julia> oneunit(Dates.Day)
1 day
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L194-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{240596739242881814}{} 
\hyperlink{240596739242881814}{\texttt{Base.zero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
zero(x)
\end{lstlisting}

Get the additive identity element for the type of \texttt{x} (\texttt{x} can also specify the type itself).


\begin{minted}{jlcon}
julia> zero(1)
0

julia> zero(big"2.0")
0.000000000000000000000000000000000000000000000000000000000000000000000000000000

julia> zero(rand(2,2))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L138-L155}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13833999108924821801}{} 
\hyperlink{13833999108924821801}{\texttt{Base.pi}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pi
π
\end{lstlisting}

The constant pi.


\begin{minted}{jlcon}
julia> pi
π = 3.1415926535897...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L149-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15097910740298861288}{} 
\hyperlink{15097910740298861288}{\texttt{Base.im}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
im
\end{lstlisting}

The imaginary unit.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L18-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8882024759165097447}{} 
\hyperlink{8882024759165097447}{\texttt{Base.eu}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
e
eu
\end{lstlisting}

The constant e.


\begin{minted}{jlcon}
julia> e
e = 2.7182818284590...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L162-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5865454847212735454}{} 
\hyperlink{5865454847212735454}{\texttt{Base.catalan}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
catalan
\end{lstlisting}

Catalan{\textquotesingle}s constant.


\begin{minted}{jlcon}
julia> catalan
catalan = 0.9159655941772...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L201-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2767346061767229384}{} 
\hyperlink{2767346061767229384}{\texttt{Base.eulergamma}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
γ
eulergamma
\end{lstlisting}

Euler{\textquotesingle}s constant.


\begin{minted}{jlcon}
julia> eulergamma
γ = 0.5772156649015...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L175-L185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2819181135704960927}{} 
\hyperlink{2819181135704960927}{\texttt{Base.golden}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
φ
golden
\end{lstlisting}

The golden ratio.


\begin{minted}{jlcon}
julia> golden
φ = 1.6180339887498...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L188-L198}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1907914141659611007}{} 
\hyperlink{1907914141659611007}{\texttt{Base.Inf}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Inf
\end{lstlisting}

Positive infinity of type \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L32-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7827423203261078742}{} 
\hyperlink{7827423203261078742}{\texttt{Base.Inf32}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Inf32
\end{lstlisting}

Positive infinity of type \hyperlink{8101639384272933082}{\texttt{Float32}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L17-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7656978911755578336}{} 
\hyperlink{7656978911755578336}{\texttt{Base.Inf16}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Inf16
\end{lstlisting}

Positive infinity of type \hyperlink{2727296760866702904}{\texttt{Float16}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11449618129446476597}{} 
\hyperlink{11449618129446476597}{\texttt{Base.NaN}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
NaN
\end{lstlisting}

A not-a-number value of type \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L38-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3173013683234902743}{} 
\hyperlink{3173013683234902743}{\texttt{Base.NaN32}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
NaN32
\end{lstlisting}

A not-a-number value of type \hyperlink{8101639384272933082}{\texttt{Float32}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L23-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1412633859926300302}{} 
\hyperlink{1412633859926300302}{\texttt{Base.NaN16}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
NaN16
\end{lstlisting}

A not-a-number value of type \hyperlink{2727296760866702904}{\texttt{Float16}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L11-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10864939112775145474}{} 
\hyperlink{10864939112775145474}{\texttt{Base.issubnormal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issubnormal(f) -> Bool
\end{lstlisting}

Test whether a floating point number is subnormal.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2055-L2059}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2906021895910968108}{} 
\hyperlink{2906021895910968108}{\texttt{Base.isfinite}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isfinite(f) -> Bool
\end{lstlisting}

Test whether a number is finite.


\begin{minted}{jlcon}
julia> isfinite(5)
true

julia> isfinite(NaN32)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L525-L537}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4492113908831448207}{} 
\hyperlink{4492113908831448207}{\texttt{Base.isinf}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isinf(f) -> Bool
\end{lstlisting}

Test whether a number is infinite.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L543-L547}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6770390199496851634}{} 
\hyperlink{6770390199496851634}{\texttt{Base.isnan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isnan(f) -> Bool
\end{lstlisting}

Test whether a floating point number is not a number (NaN).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L516-L520}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17648248624761612718}{} 
\hyperlink{17648248624761612718}{\texttt{Base.iszero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iszero(x)
\end{lstlisting}

Return \texttt{true} if \texttt{x == zero(x)}; if \texttt{x} is an array, this checks whether all of the elements of \texttt{x} are zero.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L16-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8339500090035450608}{} 
\hyperlink{8339500090035450608}{\texttt{Base.nextfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextfloat(x::AbstractFloat, n::Integer)
\end{lstlisting}

The result of \texttt{n} iterative applications of \texttt{nextfloat} to \texttt{x} if \texttt{n >= 0}, or \texttt{-n} applications of \texttt{prevfloat} if \texttt{n < 0}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L580-L585}{\texttt{source}}



\begin{lstlisting}
nextfloat(x::AbstractFloat)
\end{lstlisting}

Returns the smallest floating point number \texttt{y} of the same type as \texttt{x} such \texttt{x < y}. If no such \texttt{y} exists (e.g. if \texttt{x} is \texttt{Inf} or \texttt{NaN}), then returns \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L624-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14035790731013288499}{} 
\hyperlink{14035790731013288499}{\texttt{Base.prevfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prevfloat(x::AbstractFloat)
\end{lstlisting}

Returns the largest floating point number \texttt{y} of the same type as \texttt{x} such \texttt{y < x}. If no such \texttt{y} exists (e.g. if \texttt{x} is \texttt{-Inf} or \texttt{NaN}), then returns \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L632-L637}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1292047667500506923}{} 
\hyperlink{1292047667500506923}{\texttt{Base.isinteger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isinteger(x) -> Bool
\end{lstlisting}

Test whether \texttt{x} is numerically equal to some integer.


\begin{minted}{jlcon}
julia> isinteger(4.0)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L4-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11869977035061433209}{} 
\hyperlink{11869977035061433209}{\texttt{Base.isreal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isreal(x) -> Bool
\end{lstlisting}

Test whether \texttt{x} or all its elements are numerically equal to some real number.


\begin{minted}{jlcon}
julia> isreal(5.)
true

julia> isreal([4.; complex(0,1)])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L101-L113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11475816161015002523}{} 
\hyperlink{11475816161015002523}{\texttt{Core.Float32}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float32(x [, mode::RoundingMode])
\end{lstlisting}

Create a Float32 from \texttt{x}. If \texttt{x} is not exactly representable then \texttt{mode} determines how \texttt{x} is rounded.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float32(1/3, RoundDown)
0.3333333f0

julia> Float32(1/3, RoundUp)
0.33333334f0
\end{minted}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L221-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5076205197474650253}{} 
\hyperlink{5076205197474650253}{\texttt{Core.Float64}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float64(x [, mode::RoundingMode])
\end{lstlisting}

Create a Float64 from \texttt{x}. If \texttt{x} is not exactly representable then \texttt{mode} determines how \texttt{x} is rounded.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float64(pi, RoundDown)
3.141592653589793

julia> Float64(pi, RoundUp)
3.1415926535897936
\end{minted}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L925-L941}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11702055980905109221}{} 
\hyperlink{11702055980905109221}{\texttt{Base.GMP.BigInt}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigInt(x)
\end{lstlisting}

Create an arbitrary precision integer. \texttt{x} may be an \texttt{Int} (or anything that can be converted to an \texttt{Int}). The usual mathematical operators are defined for this type, and results are promoted to a \hyperlink{423405808990690832}{\texttt{BigInt}}.

Instances can be constructed from strings via \hyperlink{13108503824143481717}{\texttt{parse}}, or using the \texttt{big} string literal.


\begin{minted}{jlcon}
julia> parse(BigInt, "42")
42

julia> big"313"
313
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/gmp.jl#L61-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4271393203106392383}{} 
\hyperlink{4271393203106392383}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x)
\end{lstlisting}

Create an arbitrary precision floating point number. \texttt{x} may be an \hyperlink{8469131683393450448}{\texttt{Integer}}, a \hyperlink{5027751419500983000}{\texttt{Float64}} or a \hyperlink{423405808990690832}{\texttt{BigInt}}. The usual mathematical operators are defined for this type, and results are promoted to a \hyperlink{749816618809421837}{\texttt{BigFloat}}.

Note that because decimal literals are converted to floating point numbers when parsed, \texttt{BigFloat(2.1)} may not yield what you expect. You may instead prefer to initialize constants from strings via \hyperlink{13108503824143481717}{\texttt{parse}}, or using the \texttt{big} string literal.


\begin{minted}{jlcon}
julia> BigFloat(2.1)
2.100000000000000088817841970012523233890533447265625000000000000000000000000000

julia> big"2.1"
2.099999999999999999999999999999999999999999999999999999999999999999999999999986
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L68-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6511778857518292792}{} 
\hyperlink{6511778857518292792}{\texttt{Base.Rounding.rounding}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rounding(T)
\end{lstlisting}

Get the current floating point rounding mode for type \texttt{T}, controlling the rounding of basic arithmetic functions (\hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{8486205126068439173}{\texttt{*}}, \hyperlink{4103478871488785445}{\texttt{/}} and \hyperlink{4178506499510800909}{\texttt{sqrt}}) and type conversion.

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available modes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L131-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12025922235501343815}{} 
\hyperlink{12025922235501343815}{\texttt{Base.Rounding.setrounding}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setrounding(T, mode)
\end{lstlisting}

Set the rounding mode of floating point type \texttt{T}, controlling the rounding of basic arithmetic functions (\hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{8486205126068439173}{\texttt{*}}, \hyperlink{4103478871488785445}{\texttt{/}} and \hyperlink{4178506499510800909}{\texttt{sqrt}}) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default \texttt{RoundNearest}.

Note that this may affect other types, for instance changing the rounding mode of \hyperlink{5027751419500983000}{\texttt{Float64}} will change the rounding mode of \hyperlink{8101639384272933082}{\texttt{Float32}}. See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available modes.

\begin{quote}
\textbf{Warning}

This feature is still experimental, and may give unexpected or incorrect values.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L112-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9774741470027705214}{} 
\hyperlink{9774741470027705214}{\texttt{Base.Rounding.setrounding}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setrounding(f::Function, T, mode)
\end{lstlisting}

Change the rounding mode of floating point type \texttt{T} for the duration of \texttt{f}. It is logically equivalent to:


\begin{lstlisting}
old = rounding(T)
setrounding(T, mode)
f()
setrounding(T, old)
\end{lstlisting}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.

\begin{quote}
\textbf{Warning}

This feature is still experimental, and may give unexpected or incorrect values. A known problem is the interaction with compiler optimisations, e.g.


\begin{lstlisting}
julia> setrounding(Float64,RoundDown) do
           1.1 + 0.1
       end
1.2000000000000002
\end{lstlisting}

Here the compiler is \emph{constant folding}, that is evaluating a known constant expression at compile time, however the rounding mode is only changed at runtime, so this is not reflected in the function result. This can be avoided by moving constants outside the expression, e.g.


\begin{lstlisting}
julia> x = 1.1; y = 0.1;

julia> setrounding(Float64,RoundDown) do
           x + y
       end
1.2
\end{lstlisting}

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L148-L182}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13184231496538414617}{} 
\hyperlink{13184231496538414617}{\texttt{Base.Rounding.get\_zero\_subnormals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get_zero_subnormals() -> Bool
\end{lstlisting}

Returns \texttt{false} if operations on subnormal floating-point values ({\textquotedbl}denormals{\textquotedbl}) obey rules for IEEE arithmetic, and \texttt{true} if they might be converted to zeros.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L235-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2845950135157372113}{} 
\hyperlink{2845950135157372113}{\texttt{Base.Rounding.set\_zero\_subnormals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
set_zero_subnormals(yes::Bool) -> Bool
\end{lstlisting}

If \texttt{yes} is \texttt{false}, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values ({\textquotedbl}denormals{\textquotedbl}). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns \texttt{true} unless \texttt{yes==true} but the hardware does not support zeroing of subnormal numbers.

\texttt{set\_zero\_subnormals(true)} can speed up some computations on some hardware. However, it can break identities such as \texttt{(x-y==0) == (x==y)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L222-L232}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13973154041881077585}{}


\subsection{Enteros}


\hypertarget{4179288755987827924}{} 
\hyperlink{4179288755987827924}{\texttt{Base.count\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
count_ones(x::Integer) -> Integer
\end{lstlisting}

Number of ones in the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> count_ones(7)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L216-L225}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7870666257802898093}{} 
\hyperlink{7870666257802898093}{\texttt{Base.count\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
count_zeros(x::Integer) -> Integer
\end{lstlisting}

Number of zeros in the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> count_zeros(Int32(2 ^ 16 - 1))
16
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L252-L261}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7979293123371436933}{} 
\hyperlink{7979293123371436933}{\texttt{Base.leading\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
leading_zeros(x::Integer) -> Integer
\end{lstlisting}

Number of zeros leading the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> leading_zeros(Int32(1))
31
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L228-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9160604458117919092}{} 
\hyperlink{9160604458117919092}{\texttt{Base.leading\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
leading_ones(x::Integer) -> Integer
\end{lstlisting}

Number of ones leading the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> leading_ones(UInt32(2 ^ 32 - 2))
31
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L264-L273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4757748081622484794}{} 
\hyperlink{4757748081622484794}{\texttt{Base.trailing\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trailing_zeros(x::Integer) -> Integer
\end{lstlisting}

Number of zeros trailing the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> trailing_zeros(2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L240-L249}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1557366507921404436}{} 
\hyperlink{1557366507921404436}{\texttt{Base.trailing\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trailing_ones(x::Integer) -> Integer
\end{lstlisting}

Number of ones trailing the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> trailing_ones(3)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L276-L285}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2288006657111547854}{} 
\hyperlink{2288006657111547854}{\texttt{Base.isodd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isodd(x::Integer) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{x} is odd (that is, not divisible by 2), and \texttt{false} otherwise.


\begin{minted}{jlcon}
julia> isodd(9)
true

julia> isodd(10)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L40-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6755629456808693979}{} 
\hyperlink{6755629456808693979}{\texttt{Base.iseven}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iseven(x::Integer) -> Bool
\end{lstlisting}

Returns \texttt{true} is \texttt{x} is even (that is, divisible by 2), and \texttt{false} otherwise.


\begin{minted}{jlcon}
julia> iseven(9)
false

julia> iseven(10)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L55-L67}{\texttt{source}}


\end{adjustwidth}

\hypertarget{49378622553144223}{}


\section{BigFloats}



El tipo \hyperlink{749816618809421837}{\texttt{BigFloat}} implementa el punto flotante de precisión arbitraria usando la librería \href{http://www.mpfr.org/}{GNU MPFR library}.


\hypertarget{13742359768532654153}{} 
\hyperlink{13742359768532654153}{\texttt{Base.precision}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
precision(num::AbstractFloat)
\end{lstlisting}

Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L58-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6555036846799841969}{} 
\hyperlink{6555036846799841969}{\texttt{Base.precision}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
precision(BigFloat)
\end{lstlisting}

Get the precision (in bits) currently used for \hyperlink{749816618809421837}{\texttt{BigFloat}} arithmetic.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L715-L719}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3543074496498234209}{} 
\hyperlink{3543074496498234209}{\texttt{Base.MPFR.setprecision}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setprecision([T=BigFloat,] precision::Int)
\end{lstlisting}

Set the precision (in bits) to be used for \texttt{T} arithmetic.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L722-L726}{\texttt{source}}



\begin{lstlisting}
setprecision(f::Function, [T=BigFloat,] precision::Integer)
\end{lstlisting}

Change the \texttt{T} arithmetic precision (in bits) for the duration of \texttt{f}. It is logically equivalent to:


\begin{lstlisting}
old = precision(BigFloat)
setprecision(BigFloat, precision)
f()
setprecision(BigFloat, old)
\end{lstlisting}

Often used as \texttt{setprecision(T, precision) do ... end}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L859-L871}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13864548194538713914}{} 
\hyperlink{13864548194538713914}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x, prec::Int)
\end{lstlisting}

Create a representation of \texttt{x} as a \hyperlink{749816618809421837}{\texttt{BigFloat}} with precision \texttt{prec}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L129-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17009103194016650356}{} 
\hyperlink{17009103194016650356}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x, rounding::RoundingMode)
\end{lstlisting}

Create a representation of \texttt{x} as a \hyperlink{749816618809421837}{\texttt{BigFloat}} with the current global precision and rounding mode \texttt{rounding}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L152-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17130792833108028378}{} 
\hyperlink{17130792833108028378}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x, prec::Int, rounding::RoundingMode)
\end{lstlisting}

Create a representation of \texttt{x} as a \hyperlink{749816618809421837}{\texttt{BigFloat}} with precision \texttt{prec} and rounding mode \texttt{rounding}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L140-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16434633818001249494}{} 
\hyperlink{16434633818001249494}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x::String)
\end{lstlisting}

Create a representation of the string \texttt{x} as a \hyperlink{749816618809421837}{\texttt{BigFloat}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L162-L166}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4868036498049031913}{}


\section{Números Aleatorios}



La generación de números aleatorios en Julia utiliza la \href{http://www.math.sci.hiroshima-u.ac.jp/{\textasciitilde}m-mat/MT/SFMT/\#dSFMT}{librería Mersenne Twister} a través de objetos \texttt{MersenneTwister}. Julia tiene un RNG global que es usado por defecto. Pueden conectarse otros tipos RNG heredando del tipo \texttt{AbstractRNG}; ellos pueden ser usados entonces para tener multiples flujos de numeros aleatorios. Ademas de \texttt{MersenneTwister}, Julia proporciona el tipo RNG \texttt{RandomDevice} que es un \emph{wrapper} sobre la entropía proporcionada por el SO.



La mayoría de las funciones relacionadas con la generación aleatoria aceptan un \texttt{AbstractRNG} opcional como primer argumento,\texttt{rng}, que se predetermina al global si no se proporciona. Además, algunos de ellos aceptan opcionalmente especificaciones de dimensión \texttt{dims ...} (que pueden darse como una tupla) para generar matrices de valores aleatorios.



Un RNG de tipo \texttt{MersenneTwister} o \texttt{RandomDevice} puede generar números aleatorios de los siguientes tipos: \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{46725311238864537}{\texttt{Bool}}, \hyperlink{5857518405103968275}{\texttt{Int8}}, \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{6667287249103968645}{\texttt{Int16}}, \hyperlink{7018610346698168012}{\texttt{UInt16}}, \hyperlink{10103694114785108551}{\texttt{Int32}}, \hyperlink{8690996847580776341}{\texttt{UInt32}}, \hyperlink{7720564657383125058}{\texttt{Int64}}, \hyperlink{5500998675195555601}{\texttt{UInt64}}, \hyperlink{8012327724714767060}{\texttt{Int128}}, \hyperlink{14811222188335428522}{\texttt{UInt128}}, \hyperlink{423405808990690832}{\texttt{BigInt}} (o números complejos de estos tipos). Los números aleatorio en punto flotante son generados uniformemente en \([0, 1)\). Como \texttt{BigInt} representa números sin límite, el intervalo debe ser especificado (por ejemplo, \texttt{rand(big(1:6))}).


\hypertarget{17286498223669350061}{} 
\hyperlink{17286498223669350061}{\texttt{Base.Random.srand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
srand([rng=GLOBAL_RNG], [seed]) -> rng
srand([rng=GLOBAL_RNG], filename, n=4) -> rng
\end{lstlisting}

Reseed the random number generator. If a \texttt{seed} is provided, the RNG will give a reproducible sequence of numbers, otherwise Julia will get entropy from the system. For \texttt{MersenneTwister}, the \texttt{seed} may be a non-negative integer, a vector of \hyperlink{8690996847580776341}{\texttt{UInt32}} integers or a filename, in which case the seed is read from a file (\texttt{4n} bytes are read from the file, where \texttt{n} is an optional argument). \texttt{RandomDevice} does not support seeding.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L227-L236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{551200304137770185}{} 
\hyperlink{551200304137770185}{\texttt{Base.Random.MersenneTwister}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
MersenneTwister(seed)
\end{lstlisting}

Create a \texttt{MersenneTwister} RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L91-L101}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5947748412776859033}{} 
\hyperlink{5947748412776859033}{\texttt{Base.Random.RandomDevice}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RandomDevice()
\end{lstlisting}

Create a \texttt{RandomDevice} RNG object. Two such objects will always generate different streams of random numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L58-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{791894090820620170}{} 
\hyperlink{791894090820620170}{\texttt{Base.Random.rand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rand([rng=GLOBAL_RNG], [S], [dims...])
\end{lstlisting}

Pick a random element or array of random elements from the set of values specified by \texttt{S}; \texttt{S} can be

\begin{itemize}
\item an indexable collection (for example \texttt{1:n} or \texttt{[{\textquotesingle}x{\textquotesingle},{\textquotesingle}y{\textquotesingle},{\textquotesingle}z{\textquotesingle}]}), or


\item a type: the set of values to pick from is then equivalent to \texttt{typemin(S):typemax(S)} for integers (this is not applicable to \hyperlink{423405808990690832}{\texttt{BigInt}}), and to \([0, 1)\) for floating point numbers;

\end{itemize}
\texttt{S} defaults to \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L270-L281}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16989846397353234661}{} 
\hyperlink{16989846397353234661}{\texttt{Base.Random.rand!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rand!([rng=GLOBAL_RNG], A, [coll])
\end{lstlisting}

Populate the array \texttt{A} with random values. If the indexable collection \texttt{coll} is specified, the values are picked randomly from \texttt{coll}. This is equivalent to \texttt{copy!(A, rand(rng, coll, size(A)))} or \texttt{copy!(A, rand(rng, eltype(A), size(A)))} but without allocating a new array.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> rand!(rng, zeros(5))
5-element Array{Float64,1}:
 0.590845
 0.766797
 0.566237
 0.460085
 0.794026
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L292-L312}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13054959906721930538}{} 
\hyperlink{13054959906721930538}{\texttt{Base.Random.bitrand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bitrand([rng=GLOBAL_RNG], [dims...])
\end{lstlisting}

Generate a \texttt{BitArray} of random boolean values.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> bitrand(rng, 10)
10-element BitArray{1}:
  true
  true
  true
 false
  true
 false
 false
  true
 false
  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L710-L733}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8153706463199753760}{} 
\hyperlink{8153706463199753760}{\texttt{Base.Random.randn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randn([rng=GLOBAL_RNG], [T=Float64], [dims...])
\end{lstlisting}

Generate a normally-distributed random number of type \texttt{T} with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The \texttt{Base} module currently provides an implementation for the types \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}} (the default).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randn(rng, Float64)
0.8673472019512456

julia> randn(rng, Float32, (2, 4))
2×4 Array{Float32,2}:
 -0.901744  -0.902914  2.21188   -0.271735
 -0.494479   0.864401  0.532813   0.502334
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1234-L1255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2222955760771131822}{} 
\hyperlink{2222955760771131822}{\texttt{Base.Random.randn!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randn!([rng=GLOBAL_RNG], A::AbstractArray) -> A
\end{lstlisting}

Fill the array \texttt{A} with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the \hyperlink{791894090820620170}{\texttt{rand}} function.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randn!(rng, zeros(5))
5-element Array{Float64,1}:
  0.867347
 -0.901744
 -0.494479
 -0.902914
  0.864401
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1325-L1344}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8327808895184947306}{} 
\hyperlink{8327808895184947306}{\texttt{Base.Random.randexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randexp([rng=GLOBAL_RNG], [T=Float64], [dims...])
\end{lstlisting}

Generate a random number of type \texttt{T} according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The \texttt{Base} module currently provides an implementation for the types \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}} (the default).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randexp(rng, Float32)
2.4835055f0

julia> randexp(rng, 3, 3)
3×3 Array{Float64,2}:
 1.5167    1.30652   0.344435
 0.604436  2.78029   0.418516
 0.695867  0.693292  0.643644
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1282-L1304}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16869392479092224800}{} 
\hyperlink{16869392479092224800}{\texttt{Base.Random.randexp!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randexp!([rng=GLOBAL_RNG], A::AbstractArray) -> A
\end{lstlisting}

Fill the array \texttt{A} with random numbers following the exponential distribution (with scale 1).

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randexp!(rng, zeros(5))
5-element Array{Float64,1}:
 2.48351
 1.5167
 0.604436
 0.695867
 1.30652
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1347-L1365}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7925659177712248661}{} 
\hyperlink{7925659177712248661}{\texttt{Base.Random.randjump}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randjump(r::MersenneTwister, jumps::Integer, [jumppoly::AbstractString=dSFMT.JPOLY1e21]) -> Vector{MersenneTwister}
\end{lstlisting}

Create an array of the size \texttt{jumps} of initialized \texttt{MersenneTwister} RNG objects. The first RNG object given as a parameter and following \texttt{MersenneTwister} RNGs in the array are initialized such that a state of the RNG object in the array would be moved forward (without generating numbers) from a previous RNG object array element on a particular number of steps encoded by the jump polynomial \texttt{jumppoly}.

Default jump polynomial moves forward \texttt{MersenneTwister} RNG state by \texttt{10{\textasciicircum}20} steps.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L158-L168}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7104946044181754749}{}


\chapter{Cadenas}


\hypertarget{10635384680993060803}{} 
\hyperlink{10635384680993060803}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
length(s::AbstractString)
\end{lstlisting}

The number of characters in string \texttt{s}.

\textbf{Example}


\begin{minted}{jlcon}
julia> length("jμΛIα")
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L80-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1670208154575640673}{} 
\hyperlink{1670208154575640673}{\texttt{Base.sizeof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sizeof(s::AbstractString)
\end{lstlisting}

The number of bytes in string \texttt{s}.

\textbf{Example}


\begin{minted}{jlcon}
julia> sizeof("❤")
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L44-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8486205126068439173}{} 
\hyperlink{8486205126068439173}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
*(x, y...)
\end{lstlisting}

Multiplication operator. \texttt{x*y*z*...} calls this function with all arguments, i.e. \texttt{*(x, y, z, ...)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1917-L1923}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5729367935110528960}{} 
\hyperlink{5729367935110528960}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
^(s::AbstractString, n::Integer)
\end{lstlisting}

Repeat \texttt{n} times the string \texttt{s}. The \hyperlink{15426606278434194584}{\texttt{repeat}} function is an alias to this operator.


\begin{minted}{jlcon}
julia> "Test "^3
"Test Test Test "
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/types.jl#L143-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7919678712989769360}{} 
\hyperlink{7919678712989769360}{\texttt{Base.string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
string(xs...)
\end{lstlisting}

Create a string from any values using the \hyperlink{8248717042415202230}{\texttt{print}} function.


\begin{minted}{jlcon}
julia> string("a", 1, true)
"a1true"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L110-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8980238867920079536}{} 
\hyperlink{8980238867920079536}{\texttt{Base.repr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
repr(x)
\end{lstlisting}

Create a string from any value using the \hyperlink{16724886348217614039}{\texttt{showall}} function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L139-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2825695355940841177}{} 
\hyperlink{2825695355940841177}{\texttt{Core.String}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
String(s::AbstractString)
\end{lstlisting}

Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L13-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11147209877072452260}{} 
\hyperlink{11147209877072452260}{\texttt{Base.transcode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
transcode(T, src)
\end{lstlisting}

Convert string data between Unicode encodings. \texttt{src} is either a \texttt{String} or a \texttt{Vector\{UIntXX\}} of UTF-XX code units, where \texttt{XX} is 8, 16, or 32. \texttt{T} indicates the encoding of the return value: \texttt{String} to return a (UTF-8 encoded) \texttt{String} or \texttt{UIntXX} to return a \texttt{Vector\{UIntXX\}} of UTF-\texttt{XX} data.   (The alias \texttt{Cwchar\_t} can also be used as the integer type, for converting \texttt{wchar\_t*} strings used by external C libraries.)

The \texttt{transcode} function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.

Only conversion to/from UTF-8 is currently supported.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L159-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12370128473268209010}{} 
\hyperlink{12370128473268209010}{\texttt{Base.unsafe\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_string(p::Ptr{UInt8}, [length::Integer])
\end{lstlisting}

Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If \texttt{length} is specified (the length of the data in bytes), the string does not have to be NUL-terminated.

This function is labelled {\textquotedbl}unsafe{\textquotedbl} because it will crash if \texttt{p} is not a valid memory address to data of the requested length.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/string.jl#L24-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13116468520781826934}{} 
\hyperlink{13116468520781826934}{\texttt{Base.codeunit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
codeunit(s::AbstractString, i::Integer)
\end{lstlisting}

Get the \texttt{i}th code unit of an encoded string. For example, returns the \texttt{i}th byte of the representation of a UTF-8 string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/string.jl#L56-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16934723397501354088}{} 
\hyperlink{16934723397501354088}{\texttt{Base.ascii}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ascii(s::AbstractString)
\end{lstlisting}

Convert a string to \texttt{String} type and check that it contains only ASCII data, otherwise throwing an \texttt{ArgumentError} indicating the position of the first non-ASCII byte.


\begin{minted}{jlcon}
julia> ascii("abcdeγfgh")
ERROR: ArgumentError: invalid ASCII at index 6 in "abcdeγfgh"
Stacktrace:
 [1] ascii(::String) at ./strings/util.jl:479

julia> ascii("abcdefgh")
"abcdefgh"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L484-L499}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8320574829780813411}{} 
\hyperlink{8320574829780813411}{\texttt{Base.@r\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@r_str -> Regex
\end{lstlisting}

Construct a regex, such as \texttt{r{\textquotedbl}{\textasciicircum}[a-z]*\${\textquotedbl}}. The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:

\begin{itemize}
\item \texttt{i} enables case-insensitive matching


\item \texttt{m} treats the \texttt{{\textasciicircum}} and \texttt{\$} tokens as matching the start and end of individual lines, as opposed to the whole string.


\item \texttt{s} allows the \texttt{.} modifier to match newlines.


\item \texttt{x} enables {\textquotedbl}comment mode{\textquotedbl}: whitespace is enabled except when escaped with \texttt{{\textbackslash}}, and \texttt{\#} is treated as starting a comment.

\end{itemize}
For example, this regex has all three flags enabled:


\begin{minted}{jlcon}
julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/regex.jl#L63-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3198534740077872140}{} 
\hyperlink{3198534740077872140}{\texttt{Base.Docs.@html\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@html_str -> Docs.HTML
\end{lstlisting}

Create an \texttt{HTML} object from a literal string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/utils.jl#L37-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4530478957610065001}{} 
\hyperlink{4530478957610065001}{\texttt{Base.Docs.@text\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@text_str -> Docs.Text
\end{lstlisting}

Create a \texttt{Text} object from a literal string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/utils.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17939206388416277411}{} 
\hyperlink{17939206388416277411}{\texttt{Base.UTF8proc.normalize\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
normalize_string(s::AbstractString, normalform::Symbol)
\end{lstlisting}

Normalize the string \texttt{s} according to one of the four {\textquotedbl}normal forms{\textquotedbl} of the Unicode standard: \texttt{normalform} can be \texttt{:NFC}, \texttt{:NFD}, \texttt{:NFKC}, or \texttt{:NFKD}.  Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact.  Normal forms KC and KD additionally canonicalize {\textquotedbl}compatibility equivalents{\textquotedbl}: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.

Alternatively, finer control and additional transformations may be be obtained by calling \texttt{normalize\_string(s; keywords...)}, where any number of the following boolean keywords options (which all default to \texttt{false} except for \texttt{compose}) are specified:

\begin{itemize}
\item \texttt{compose=false}: do not perform canonical composition


\item \texttt{decompose=true}: do canonical decomposition instead of canonical composition (\texttt{compose=true} is ignored if present)


\item \texttt{compat=true}: compatibility equivalents are canonicalized


\item \texttt{casefold=true}: perform Unicode case folding, e.g. for case-insensitive string comparison


\item \texttt{newline2lf=true}, \texttt{newline2ls=true}, or \texttt{newline2ps=true}: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively


\item \texttt{stripmark=true}: strip diacritical marks (e.g. accents)


\item \texttt{stripignore=true}: strip Unicode{\textquotesingle}s {\textquotedbl}default ignorable{\textquotedbl} characters (e.g. the soft hyphen or the left-to-right marker)


\item \texttt{stripcc=true}: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified


\item \texttt{rejectna=true}: throw an error if unassigned code points are found


\item \texttt{stable=true}: enforce Unicode Versioning Stability

\end{itemize}
For example, NFKC corresponds to the options \texttt{compose=true, compat=true, stable=true}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L146-L180}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13702591434765172496}{} 
\hyperlink{13702591434765172496}{\texttt{Base.UTF8proc.graphemes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
graphemes(s::AbstractString) -> GraphemeIterator
\end{lstlisting}

Returns an iterator over substrings of \texttt{s} that correspond to the extended graphemes in the string, as defined by Unicode UAX \#29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L346-L353}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9678448882095016755}{} 
\hyperlink{9678448882095016755}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isvalid(value) -> Bool
\end{lstlisting}

Returns \texttt{true} if the given value is valid for its type, which currently can be either \texttt{Char} or \texttt{String}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2403-L2408}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16014659773986219432}{} 
\hyperlink{16014659773986219432}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isvalid(T, value) -> Bool
\end{lstlisting}

Returns \texttt{true} if the given value is valid for that type. Types currently can be either \texttt{Char} or \texttt{String}. Values for \texttt{Char} can be of type \texttt{Char} or \hyperlink{8690996847580776341}{\texttt{UInt32}}. Values for \texttt{String} can be of that type, or \texttt{Vector\{UInt8\}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2411-L2417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10276715660934277801}{} 
\hyperlink{10276715660934277801}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isvalid(str::AbstractString, i::Integer)
\end{lstlisting}

Tells whether index \texttt{i} is valid for the given string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> isvalid(str, 1)
true

julia> str[1]
'α': Unicode U+03b1 (category Ll: Letter, lowercase)

julia> isvalid(str, 2)
false

julia> str[2]
ERROR: UnicodeError: invalid character index
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L142-L165}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14265600875872242300}{} 
\hyperlink{14265600875872242300}{\texttt{Base.UTF8proc.is\_assigned\_char}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_assigned_char(c) -> Bool
\end{lstlisting}

Returns \texttt{true} if the given char or integer is an assigned Unicode code point.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L213-L217}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12183734646641519159}{} 
\hyperlink{12183734646641519159}{\texttt{Base.ismatch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ismatch(r::Regex, s::AbstractString) -> Bool
\end{lstlisting}

Test whether a string contains a match of the given regular expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1933-L1937}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2695862412477105800}{} 
\hyperlink{2695862412477105800}{\texttt{Base.match}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])
\end{lstlisting}

Search for the first match of the regular expression \texttt{r} in \texttt{s} and return a \texttt{RegexMatch} object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing \texttt{m.match} and the captured sequences can be retrieved by accessing \texttt{m.captures} The optional \texttt{idx} argument specifies an index at which to start the search.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2102-L2109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2810316550892708557}{} 
\hyperlink{2810316550892708557}{\texttt{Base.eachmatch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eachmatch(r::Regex, s::AbstractString[, overlap::Bool=false])
\end{lstlisting}

Search for all matches of a the regular expression \texttt{r} in \texttt{s} and return a iterator over the matches. If overlap is \texttt{true}, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L593-L599}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5181495363849711239}{} 
\hyperlink{5181495363849711239}{\texttt{Base.matchall}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
matchall(r::Regex, s::AbstractString[, overlap::Bool=false]) -> Vector{AbstractString}
\end{lstlisting}

Return a vector of the matching substrings from \hyperlink{2810316550892708557}{\texttt{eachmatch}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1940-L1944}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3722145084740074291}{} 
\hyperlink{3722145084740074291}{\texttt{Base.lpad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lpad(s, n::Integer, p::AbstractString=" ")
\end{lstlisting}

Make a string at least \texttt{n} columns wide when printed by padding \texttt{s} on the left with copies of \texttt{p}.


\begin{minted}{jlcon}
julia> lpad("March",10)
"     March"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L224-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12508684325429723537}{} 
\hyperlink{12508684325429723537}{\texttt{Base.rpad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rpad(s, n::Integer, p::AbstractString=" ")
\end{lstlisting}

Make a string at least \texttt{n} columns wide when printed by padding \texttt{s} on the right with copies of \texttt{p}.


\begin{minted}{jlcon}
julia> rpad("March",20)
"March               "
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L237-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10006050288379145945}{} 
\hyperlink{10006050288379145945}{\texttt{Base.search}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
search(string::AbstractString, chars::Chars, [start::Integer])
\end{lstlisting}

Search for the first occurrence of the given characters within the given string. The second argument may be a single character, a vector or a set of characters, a string, or a regular expression (though regular expressions are only allowed on contiguous strings, such as ASCII or UTF-8 strings). The third argument optionally specifies a starting index. The return value is a range of indexes where the matching sequence is found, such that \texttt{s[search(s,x)] == x}:

\texttt{search(string, {\textquotedbl}substring{\textquotedbl})} = \texttt{start:end} such that \texttt{string[start:end] == {\textquotedbl}substring{\textquotedbl}}, or \texttt{0:-1} if unmatched.

\texttt{search(string, {\textquotesingle}c{\textquotesingle})} = \texttt{index} such that \texttt{string[index] == {\textquotesingle}c{\textquotesingle}}, or \texttt{0} if unmatched.


\begin{minted}{jlcon}
julia> search("Hello to the world", "z")
0:-1

julia> search("JuliaLang","Julia")
1:5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L5-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3355355726219213290}{} 
\hyperlink{3355355726219213290}{\texttt{Base.rsearch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rsearch(s::AbstractString, chars::Chars, [start::Integer])
\end{lstlisting}

Similar to \hyperlink{10006050288379145945}{\texttt{search}}, but returning the last occurrence of the given characters within the given string, searching in reverse from \texttt{start}.


\begin{minted}{jlcon}
julia> rsearch("aaabbb","b")
6:6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L199-L209}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14183102834887354380}{} 
\hyperlink{14183102834887354380}{\texttt{Base.searchindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
searchindex(s::AbstractString, substring, [start::Integer])
\end{lstlisting}

Similar to \hyperlink{10006050288379145945}{\texttt{search}}, but return only the start index at which the substring is found, or \texttt{0} if it is not.


\begin{minted}{jlcon}
julia> searchindex("Hello to the world", "z")
0

julia> searchindex("JuliaLang","Julia")
1

julia> searchindex("JuliaLang","Lang")
6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L149-L165}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8139560711805016124}{} 
\hyperlink{8139560711805016124}{\texttt{Base.rsearchindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rsearchindex(s::AbstractString, substring, [start::Integer])
\end{lstlisting}

Similar to \hyperlink{3355355726219213290}{\texttt{rsearch}}, but return only the start index at which the substring is found, or \texttt{0} if it is not.


\begin{minted}{jlcon}
julia> rsearchindex("aaabbb","b")
6

julia> rsearchindex("aaabbb","a")
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L314-L326}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17633982666065151863}{} 
\hyperlink{17633982666065151863}{\texttt{Base.contains}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
contains(haystack::AbstractString, needle::AbstractString)
\end{lstlisting}

Determine whether the second argument is a substring of the first.


\begin{minted}{jlcon}
julia> contains("JuliaLang is pretty cool!", "Julia")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L368-L377}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17372290750646920644}{} 
\hyperlink{17372290750646920644}{\texttt{Base.reverse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reverse(s::AbstractString) -> AbstractString
\end{lstlisting}

Reverses a string.


\begin{minted}{jlcon}
julia> reverse("JuliaLang")
"gnaLailuJ"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/types.jl#L116-L124}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1718748356383062256}{} 
\hyperlink{1718748356383062256}{\texttt{Base.replace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
replace(string::AbstractString, pat, r[, n::Integer=0])
\end{lstlisting}

Search for the given pattern \texttt{pat}, and replace each occurrence with \texttt{r}. If \texttt{n} is provided, replace at most \texttt{n} occurrences. As with search, the second argument may be a single character, a vector or a set of characters, a string, or a regular expression. If \texttt{r} is a function, each occurrence is replaced with \texttt{r(s)} where \texttt{s} is the matched substring. If \texttt{pat} is a regular expression and \texttt{r} is a \texttt{SubstitutionString}, then capture group references in \texttt{r} are replaced with the corresponding matched text.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L393-L402}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8368077469888537439}{} 
\hyperlink{8368077469888537439}{\texttt{Base.split}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
split(s::AbstractString, [chars]; limit::Integer=0, keep::Bool=true)
\end{lstlisting}

Return an array of substrings by splitting the given string on occurrences of the given character delimiters, which may be specified in any of the formats allowed by \texttt{search}{\textquotesingle}s second argument (i.e. a single character, collection of characters, string, or regular expression). If \texttt{chars} is omitted, it defaults to the set of all space characters, and \texttt{keep} is taken to be \texttt{false}. The two keyword arguments are optional: they are a maximum size for the result and a flag determining whether empty fields should be kept in the result.


\begin{minted}{jlcon}
julia> a = "Ma.rch"
"Ma.rch"

julia> split(a,".")
2-element Array{SubString{String},1}:
 "Ma"
 "rch"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L256-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15507349251888266905}{} 
\hyperlink{15507349251888266905}{\texttt{Base.rsplit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rsplit(s::AbstractString, [chars]; limit::Integer=0, keep::Bool=true)
\end{lstlisting}

Similar to \hyperlink{8368077469888537439}{\texttt{split}}, but starting from the end of the string.


\begin{minted}{jlcon}
julia> a = "M.a.r.c.h"
"M.a.r.c.h"

julia> rsplit(a,".")
5-element Array{SubString{String},1}:
 "M"
 "a"
 "r"
 "c"
 "h"

julia> rsplit(a,".";limit=1)
1-element Array{SubString{String},1}:
 "M.a.r.c.h"

julia> rsplit(a,".";limit=2)
2-element Array{SubString{String},1}:
 "M.a.r.c"
 "h"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L307-L333}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7002432768371197450}{} 
\hyperlink{7002432768371197450}{\texttt{Base.strip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strip(s::AbstractString, [chars::Chars])
\end{lstlisting}

Return \texttt{s} with any leading and trailing whitespace removed. If \texttt{chars} (a character, or vector or set of characters) is provided, instead remove characters contained in it.


\begin{minted}{jlcon}
julia> strip("{3, 5}\n", ['{', '}', '\n'])
"3, 5"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L181-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7433804272240772935}{} 
\hyperlink{7433804272240772935}{\texttt{Base.lstrip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lstrip(s::AbstractString[, chars::Chars])
\end{lstlisting}

Return \texttt{s} with any leading whitespace and delimiters removed. The default delimiters to remove are \texttt{{\textquotesingle} {\textquotesingle}}, \texttt{{\textbackslash}t}, \texttt{{\textbackslash}n}, \texttt{{\textbackslash}v}, \texttt{{\textbackslash}f}, and \texttt{{\textbackslash}r}. If \texttt{chars} (a character, or vector or set of characters) is provided, instead remove characters contained in it.


\begin{minted}{jlcon}
julia> a = lpad("March", 20)
"               March"

julia> lstrip(a)
"March"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L122-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8645844793440900923}{} 
\hyperlink{8645844793440900923}{\texttt{Base.rstrip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rstrip(s::AbstractString[, chars::Chars])
\end{lstlisting}

Return \texttt{s} with any trailing whitespace and delimiters removed. The default delimiters to remove are \texttt{{\textquotesingle} {\textquotesingle}}, \texttt{{\textbackslash}t}, \texttt{{\textbackslash}n}, \texttt{{\textbackslash}v}, \texttt{{\textbackslash}f}, and \texttt{{\textbackslash}r}. If \texttt{chars} (a character, or vector or set of characters) is provided, instead remove characters contained in it.


\begin{minted}{jlcon}
julia> a = rpad("March", 20)
"March               "

julia> rstrip(a)
"March"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L151-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3780640516028077129}{} 
\hyperlink{3780640516028077129}{\texttt{Base.startswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
startswith(s::AbstractString, prefix::AbstractString)
\end{lstlisting}

Returns \texttt{true} if \texttt{s} starts with \texttt{prefix}. If \texttt{prefix} is a vector or set of characters, tests whether the first character of \texttt{s} belongs to that set.

See also \hyperlink{7763134966257769023}{\texttt{endswith}}.


\begin{minted}{jlcon}
julia> startswith("JuliaLang", "Julia")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L5-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7763134966257769023}{} 
\hyperlink{7763134966257769023}{\texttt{Base.endswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
endswith(s::AbstractString, suffix::AbstractString)
\end{lstlisting}

Returns \texttt{true} if \texttt{s} ends with \texttt{suffix}. If \texttt{suffix} is a vector or set of characters, tests whether the last character of \texttt{s} belongs to that set.

See also \hyperlink{3780640516028077129}{\texttt{startswith}}.


\begin{minted}{jlcon}
julia> endswith("Sunday", "day")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L30-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12677983900410542972}{} 
\hyperlink{12677983900410542972}{\texttt{Base.uppercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
uppercase(s::AbstractString)
\end{lstlisting}

Returns \texttt{s} with all characters converted to uppercase.

\textbf{Example}


\begin{minted}{jlcon}
julia> uppercase("Julia")
"JULIA"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L389-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4639905932946362908}{} 
\hyperlink{4639905932946362908}{\texttt{Base.lowercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowercase(s::AbstractString)
\end{lstlisting}

Returns \texttt{s} with all characters converted to lowercase.

\textbf{Example}


\begin{minted}{jlcon}
julia> lowercase("STRINGS AND THINGS")
"strings and things"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L403-L414}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10496416994709882234}{} 
\hyperlink{10496416994709882234}{\texttt{Base.titlecase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
titlecase(s::AbstractString)
\end{lstlisting}

Capitalizes the first character of each word in \texttt{s}.

\textbf{Example}


\begin{minted}{jlcon}
julia> titlecase("the julia programming language")
"The Julia Programming Language"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L417-L428}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17129604125086518189}{} 
\hyperlink{17129604125086518189}{\texttt{Base.ucfirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ucfirst(s::AbstractString)
\end{lstlisting}

Returns \texttt{string} with the first character converted to uppercase.

\textbf{Example}


\begin{minted}{jlcon}
julia> ucfirst("python")
"Python"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L444-L455}{\texttt{source}}


\end{adjustwidth}
\hypertarget{596092241182068434}{} 
\hyperlink{596092241182068434}{\texttt{Base.lcfirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lcfirst(s::AbstractString)
\end{lstlisting}

Returns \texttt{string} with the first character converted to lowercase.

\textbf{Example}


\begin{minted}{jlcon}
julia> lcfirst("Julia")
"julia"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L460-L471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18064910688022011979}{} 
\hyperlink{18064910688022011979}{\texttt{Base.join}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
join(io::IO, strings, delim, [last])
\end{lstlisting}

Join an array of \texttt{strings} into a single string, inserting the given delimiter between adjacent strings. If \texttt{last} is given, it will be used instead of \texttt{delim} between the last two strings. For example,


\begin{minted}{jlcon}
julia> join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"
\end{minted}

\texttt{strings} can be any iterable over elements \texttt{x} which are convertible to strings via \texttt{print(io::IOBuffer, x)}. \texttt{strings} will be printed to \texttt{io}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L172-L186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18002354026785919806}{} 
\hyperlink{18002354026785919806}{\texttt{Base.chop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chop(s::AbstractString)
\end{lstlisting}

Remove the last character from \texttt{s}.


\begin{minted}{jlcon}
julia> a = "March"
"March"

julia> chop(a)
"Marc"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L66-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5360081372937794006}{} 
\hyperlink{5360081372937794006}{\texttt{Base.chomp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chomp(s::AbstractString)
\end{lstlisting}

Remove a single trailing newline from a string.


\begin{minted}{jlcon}
julia> chomp("Hello\n")
"Hello"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L81-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6392662344610705448}{} 
\hyperlink{6392662344610705448}{\texttt{Base.ind2chr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ind2chr(s::AbstractString, i::Integer)
\end{lstlisting}

Convert a byte index \texttt{i} to a character index with respect to string \texttt{s}.

See also \hyperlink{3998544168504071055}{\texttt{chr2ind}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> ind2chr(str, 3)
2

julia> chr2ind(str, 2)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L262-L281}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3998544168504071055}{} 
\hyperlink{3998544168504071055}{\texttt{Base.chr2ind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chr2ind(s::AbstractString, i::Integer)
\end{lstlisting}

Convert a character index \texttt{i} to a byte index.

See also \hyperlink{6392662344610705448}{\texttt{ind2chr}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> chr2ind(str, 2)
3

julia> ind2chr(str, 3)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L296-L314}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7455293228649070526}{} 
\hyperlink{7455293228649070526}{\texttt{Base.nextind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextind(str::AbstractString, i::Integer)
\end{lstlisting}

Get the next valid string index after \texttt{i}. Returns a value greater than \texttt{endof(str)} at or after the end of the string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> nextind(str, 1)
3

julia> endof(str)
9

julia> nextind(str, 9)
10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L215-L235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15871508897466976220}{} 
\hyperlink{15871508897466976220}{\texttt{Base.prevind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prevind(str::AbstractString, i::Integer)
\end{lstlisting}

Get the previous valid string index before \texttt{i}. Returns a value less than \texttt{1} at the beginning of the string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prevind("αβγdef", 3)
1

julia> prevind("αβγdef", 1)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L184-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1835361053788807915}{} 
\hyperlink{1835361053788807915}{\texttt{Base.Random.randstring}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randstring([rng,] len=8)
\end{lstlisting}

Create a random ASCII string of length \texttt{len}, consisting of upper- and lower-case letters and the digits 0-9. The optional \texttt{rng} argument specifies a random number generator, see \hyperlink{4868036498049031913}{Random Numbers}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randstring(rng, 4)
"mbDd"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L907-L922}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10345820167929797351}{} 
\hyperlink{10345820167929797351}{\texttt{Base.UTF8proc.charwidth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
charwidth(c)
\end{lstlisting}

Gives the number of columns needed to print a character.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L193-L197}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10855865814348701897}{} 
\hyperlink{10855865814348701897}{\texttt{Base.strwidth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strwidth(s::AbstractString)
\end{lstlisting}

Gives the number of columns needed to print a string.

\textbf{Example}


\begin{minted}{jlcon}
julia> strwidth("March")
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L342-L353}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10617070106229701570}{} 
\hyperlink{10617070106229701570}{\texttt{Base.UTF8proc.isalnum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isalnum(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is alphanumeric. A character is classified as alphabetic if it belongs to the Unicode general category Letter or Number, i.e. a character whose category code begins with {\textquotesingle}L{\textquotesingle} or {\textquotesingle}N{\textquotesingle}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L270-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2733388318366578098}{} 
\hyperlink{2733388318366578098}{\texttt{Base.UTF8proc.isalpha}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isalpha(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is alphabetic. A character is classified as alphabetic if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with {\textquotesingle}L{\textquotesingle}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L252-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15093956188358440526}{} 
\hyperlink{15093956188358440526}{\texttt{Base.isascii}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isascii(c::Union{Char,AbstractString}) -> Bool
\end{lstlisting}

Tests whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L356-L361}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7046677780358712703}{} 
\hyperlink{7046677780358712703}{\texttt{Base.UTF8proc.iscntrl}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iscntrl(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L285-L290}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2445306399786549198}{} 
\hyperlink{2445306399786549198}{\texttt{Base.UTF8proc.isdigit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdigit(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is a numeric digit (0-9).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L245-L249}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7069613128428293368}{} 
\hyperlink{7069613128428293368}{\texttt{Base.UTF8proc.isgraph}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isgraph(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is printable, and not a space. Any character that would cause a printer to use ink should be classified with \texttt{isgraph(c)==true}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L321-L327}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7556055480265629046}{} 
\hyperlink{7556055480265629046}{\texttt{Base.UTF8proc.islower}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
islower(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L222-L228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18059155338281639030}{} 
\hyperlink{18059155338281639030}{\texttt{Base.UTF8proc.isnumber}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isnumber(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with {\textquotesingle}N{\textquotesingle}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L261-L267}{\texttt{source}}


\end{adjustwidth}
\hypertarget{797129785907717137}{} 
\hyperlink{797129785907717137}{\texttt{Base.UTF8proc.isprint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isprint(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is printable, including spaces, but not a control character.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L312-L316}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7720498622841455852}{} 
\hyperlink{7720498622841455852}{\texttt{Base.UTF8proc.ispunct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ispunct(c::Char) -> Bool
\end{lstlisting}

Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with {\textquotesingle}P{\textquotesingle}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L293-L298}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17667628008481296406}{} 
\hyperlink{17667628008481296406}{\texttt{Base.UTF8proc.isspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isspace(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is any whitespace character. Includes ASCII characters {\textquotesingle}{\textbackslash}t{\textquotesingle}, {\textquotesingle}{\textbackslash}n{\textquotesingle}, {\textquotesingle}{\textbackslash}v{\textquotesingle}, {\textquotesingle}{\textbackslash}f{\textquotesingle}, {\textquotesingle}{\textbackslash}r{\textquotesingle}, and {\textquotesingle} {\textquotesingle}, Latin-1 character U+0085, and characters in Unicode category Zs.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L303-L309}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18233029693907037733}{} 
\hyperlink{18233029693907037733}{\texttt{Base.UTF8proc.isupper}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isupper(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L233-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16472559569885457655}{} 
\hyperlink{16472559569885457655}{\texttt{Base.isxdigit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isxdigit(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is a valid hexadecimal digit. Note that this does not include \texttt{x} (as in the standard \texttt{0x} prefix).

\textbf{Example}


\begin{minted}{jlcon}
julia> isxdigit('a')
true

julia> isxdigit('x')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L369-L384}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18332791376992528422}{} 
\hyperlink{18332791376992528422}{\texttt{Core.Symbol}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Symbol(x...) -> Symbol
\end{lstlisting}

Create a \texttt{Symbol} by concatenating the string representations of the arguments together.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2396-L2400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2720373307114882969}{} 
\hyperlink{2720373307114882969}{\texttt{Base.escape\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
escape_string([io,] str::AbstractString[, esc::AbstractString]) -> AbstractString
\end{lstlisting}

General escaping of traditional C and Unicode escape sequences. Any characters in \texttt{esc} are also escaped (with a backslash). See also \hyperlink{4382494947698149975}{\texttt{unescape\_string}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L225-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4382494947698149975}{} 
\hyperlink{4382494947698149975}{\texttt{Base.unescape\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unescape_string([io,] s::AbstractString) -> AbstractString
\end{lstlisting}

General unescaping of traditional C and Unicode escape sequences. Reverse of \hyperlink{2720373307114882969}{\texttt{escape\_string}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L278-L283}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14629781252390713372}{}


\chapter{Arrays}



\hypertarget{6164914096834691514}{}


\section{Constructores y Tipos}


\hypertarget{6514416309183787338}{} 
\hyperlink{6514416309183787338}{\texttt{Core.AbstractArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AbstractArray{T, N}
\end{lstlisting}

Abstract array supertype which arrays inherit from.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15492651498431872487}{} 
\hyperlink{15492651498431872487}{\texttt{Core.Array}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Array{T}(dims)
Array{T,N}(dims)
\end{lstlisting}

Construct an uninitialized \texttt{N}-dimensional dense array with element type \texttt{T}, where \texttt{N} is determined from the length or number of \texttt{dims}. \texttt{dims} may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank \texttt{N} is supplied explicitly as in \texttt{Array\{T,N\}(dims)}, then it must match the length or number of \texttt{dims}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = Array{Float64, 2}(2, 2);

julia> ndims(A)
2

julia> eltype(A)
Float64
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L51-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2839226020402435013}{} 
\hyperlink{2839226020402435013}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getindex(type[, elements...])
\end{lstlisting}

Construct a 1-d array of the specified type. This is usually called with the syntax \texttt{Type[]}. Element values can be specified using \texttt{Type[a,b,c,...]}.

\textbf{Example}


\begin{minted}{jlcon}
julia> Int8[1, 2, 3]
3-element Array{Int8,1}:
 1
 2
 3

julia> getindex(Int8, 1, 2, 3)
3-element Array{Int8,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L96-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13837674686090348619}{} 
\hyperlink{13837674686090348619}{\texttt{Base.zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
zeros([A::AbstractArray,] [T=eltype(A)::Type,] [dims=size(A)::Tuple])
\end{lstlisting}

Create an array of all zeros with the same layout as \texttt{A}, element type \texttt{T} and size \texttt{dims}. The \texttt{A} argument can be skipped, which behaves like \texttt{Array\{Float64,0\}()} was passed. For convenience \texttt{dims} may also be passed in variadic form.

\textbf{Examples}


\begin{minted}{jlcon}
julia> zeros(1)
1-element Array{Float64,1}:
 0.0

julia> zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> zeros(A)
2×2 Array{Int64,2}:
 0  0
 0  0

julia> zeros(A, Float64)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia> zeros(A, Bool, (3,))
3-element Array{Bool,1}:
 false
 false
 false
\end{minted}

See also \hyperlink{5858390260510292771}{\texttt{ones}}, \hyperlink{18368531196314541873}{\texttt{similar}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2353-L2393}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5858390260510292771}{} 
\hyperlink{5858390260510292771}{\texttt{Base.ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ones([A::AbstractArray,] [T=eltype(A)::Type,] [dims=size(A)::Tuple])
\end{lstlisting}

Create an array of all ones with the same layout as \texttt{A}, element type \texttt{T} and size \texttt{dims}. The \texttt{A} argument can be skipped, which behaves like \texttt{Array\{Float64,0\}()} was passed. For convenience \texttt{dims} may also be passed in variadic form.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ones(Complex128, 2, 3)
2×3 Array{Complex{Float64},2}:
 1.0+0.0im  1.0+0.0im  1.0+0.0im
 1.0+0.0im  1.0+0.0im  1.0+0.0im

julia> ones(1,2)
1×2 Array{Float64,2}:
 1.0  1.0

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> ones(A)
2×2 Array{Int64,2}:
 1  1
 1  1

julia> ones(A, Float64)
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  1.0

julia> ones(A, Bool, (3,))
3-element Array{Bool,1}:
 true
 true
 true
\end{minted}

See also \hyperlink{13837674686090348619}{\texttt{zeros}}, \hyperlink{18368531196314541873}{\texttt{similar}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L429-L469}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18015155802543401629}{} 
\hyperlink{18015155802543401629}{\texttt{Base.BitArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BitArray(dims::Integer...)
BitArray{N}(dims::NTuple{N,Int})
\end{lstlisting}

Construct an uninitialized \texttt{BitArray} with the given dimensions. Behaves identically to the \hyperlink{15492651498431872487}{\texttt{Array}} constructor.


\begin{minted}{jlcon}
julia> BitArray(2, 2)
2×2 BitArray{2}:
 false  false
 false  true

julia> BitArray((3, 1))
3×1 BitArray{2}:
 false
 true
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L31-L50}{\texttt{source}}



\begin{lstlisting}
BitArray(itr)
\end{lstlisting}

Construct a \texttt{BitArray} generated by the given iterable object. The shape is inferred from the \texttt{itr} object.


\begin{minted}{jlcon}
julia> BitArray([1 0; 0 1])
2×2 BitArray{2}:
  true  false
 false   true

julia> BitArray(x+y == 3 for x = 1:2, y = 1:3)
2×3 BitArray{2}:
 false   true  false
  true  false  false

julia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)
6-element BitArray{1}:
 false
  true
 false
  true
 false
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L548-L574}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12844393578243965152}{} 
\hyperlink{12844393578243965152}{\texttt{Base.trues}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trues(dims)
\end{lstlisting}

Create a \texttt{BitArray} with all values set to \texttt{true}.


\begin{minted}{jlcon}
julia> trues(2,3)
2×3 BitArray{2}:
 true  true  true
 true  true  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L393-L404}{\texttt{source}}



\begin{lstlisting}
trues(A)
\end{lstlisting}

Create a \texttt{BitArray} with all values set to \texttt{true} of the same shape as \texttt{A}.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> trues(A)
2×2 BitArray{2}:
 true  true
 true  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L407-L423}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12518029339635756199}{} 
\hyperlink{12518029339635756199}{\texttt{Base.falses}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
falses(dims)
\end{lstlisting}

Create a \texttt{BitArray} with all values set to \texttt{false}.


\begin{minted}{jlcon}
julia> falses(2,3)
2×3 BitArray{2}:
 false  false  false
 false  false  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L360-L371}{\texttt{source}}



\begin{lstlisting}
falses(A)
\end{lstlisting}

Create a \texttt{BitArray} with all values set to \texttt{false} of the same shape as \texttt{A}.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> falses(A)
2×2 BitArray{2}:
 false  false
 false  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L374-L390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2836152204730819918}{} 
\hyperlink{2836152204730819918}{\texttt{Base.fill}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fill(x, dims)
\end{lstlisting}

Create an array filled with the value \texttt{x}. For example, \texttt{fill(1.0, (5,5))} returns a 5×5 array of floats, with each element initialized to \texttt{1.0}.


\begin{minted}{jlcon}
julia> fill(1.0, (5,5))
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
\end{minted}

If \texttt{x} is an object reference, all elements will refer to the same object. \texttt{fill(Foo(), dims)} will return an array filled with the result of evaluating \texttt{Foo()} once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L234-L252}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5162290739791026948}{} 
\hyperlink{5162290739791026948}{\texttt{Base.fill!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fill!(A, x)
\end{lstlisting}

Fill array \texttt{A} with the value \texttt{x}. If \texttt{x} is an object reference, all elements will refer to the same object. \texttt{fill!(A, Foo())} will return \texttt{A} filled with the result of evaluating \texttt{Foo()} once.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = zeros(2,3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> fill!(A, 2.)
2×3 Array{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0

julia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(3), a); a[1] = 2; A
3-element Array{Array{Int64,1},1}:
 [2, 1, 1]
 [2, 1, 1]
 [2, 1, 1]

julia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(3), f())
3-element Array{Int64,1}:
 1
 1
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L5-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18368531196314541873}{} 
\hyperlink{18368531196314541873}{\texttt{Base.similar}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
similar(array, [element_type=eltype(array)], [dims=size(array)])
\end{lstlisting}

Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array{\textquotesingle}s \texttt{eltype} and \texttt{size}. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.

Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an \texttt{Array\{element\_type\}(dims...)}.

For example, \texttt{similar(1:10, 1, 4)} returns an uninitialized \texttt{Array\{Int,2\}} since ranges are neither mutable nor support 2 dimensions:


\begin{minted}{jlcon}
julia> similar(1:10, 1, 4)
1×4 Array{Int64,2}:
 4419743872  4374413872  4419743888  0
\end{minted}

Conversely, \texttt{similar(trues(10,10), 2)} returns an uninitialized \texttt{BitVector} with two elements since \texttt{BitArray}s are both mutable and can support 1-dimensional arrays:


\begin{minted}{jlcon}
julia> similar(trues(10,10), 2)
2-element BitArray{1}:
 false
 false
\end{minted}

Since \texttt{BitArray}s can only store elements of type \hyperlink{46725311238864537}{\texttt{Bool}}, however, if you request a different element type it will create a regular \texttt{Array} instead:


\begin{minted}{jlcon}
julia> similar(falses(10), Float64, 2, 4)
2×4 Array{Float64,2}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L478-L519}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2536022253284800887}{} 
\hyperlink{2536022253284800887}{\texttt{Base.similar}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
similar(storagetype, indices)
\end{lstlisting}

Create an uninitialized mutable array analogous to that specified by \texttt{storagetype}, but with \texttt{indices} specified by the last argument. \texttt{storagetype} might be a type or a function.

\textbf{Examples}:


\begin{lstlisting}
similar(Array{Int}, indices(A))
\end{lstlisting}

creates an array that {\textquotedbl}acts like{\textquotedbl} an \texttt{Array\{Int\}} (and might indeed be backed by one), but which is indexed identically to \texttt{A}. If \texttt{A} has conventional indexing, this will be identical to \texttt{Array\{Int\}(size(A))}, but if \texttt{A} has unconventional indexing then the indices of the result will match \texttt{A}.


\begin{lstlisting}
similar(BitArray, (indices(A, 2),))
\end{lstlisting}

would create a 1-dimensional logical array whose indices match those of the columns of \texttt{A}.


\begin{lstlisting}
similar(dims->zeros(Int, dims), indices(A))
\end{lstlisting}

would create an array of \texttt{Int}, initialized to zero, matching the indices of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L538-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{245874853049830800}{} 
\hyperlink{245874853049830800}{\texttt{Base.eye}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eye([T::Type=Float64,] m::Integer, n::Integer)
\end{lstlisting}

\texttt{m}-by-\texttt{n} identity matrix. The default element type is \hyperlink{5027751419500983000}{\texttt{Float64}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eye(3, 4)
3×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  1.0  0.0

julia> eye(2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia> eye(Int, 2, 2)
2×2 Array{Int64,2}:
 1  0
 0  1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L270-L295}{\texttt{source}}



\begin{lstlisting}
eye(m, n)
\end{lstlisting}

\texttt{m}-by-\texttt{n} identity matrix.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L304-L308}{\texttt{source}}



\begin{lstlisting}
eye([T::Type=Float64,] n::Integer)
\end{lstlisting}

\texttt{n}-by-\texttt{n} identity matrix. The default element type is \hyperlink{5027751419500983000}{\texttt{Float64}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eye(Int, 2)
2×2 Array{Int64,2}:
 1  0
 0  1

julia> eye(2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L311-L329}{\texttt{source}}



\begin{lstlisting}
eye(A)
\end{lstlisting}

Constructs an identity matrix of the same dimensions and type as \texttt{A}.


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> eye(A)
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  1
\end{minted}

Note the difference from \hyperlink{5858390260510292771}{\texttt{ones}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L332-L352}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11519832570242386196}{} 
\hyperlink{11519832570242386196}{\texttt{Base.linspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
linspace(start, stop, n=50)
\end{lstlisting}

Construct a range of \texttt{n} linearly spaced elements from \texttt{start} to \texttt{stop}.


\begin{minted}{jlcon}
julia> linspace(1.3,2.9,9)
1.3:0.2:2.9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L230-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9346157980973735489}{} 
\hyperlink{9346157980973735489}{\texttt{Base.logspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logspace(start::Real, stop::Real, n::Integer=50)
\end{lstlisting}

Construct a vector of \texttt{n} logarithmically spaced numbers from \texttt{10{\textasciicircum}start} to \texttt{10{\textasciicircum}stop}.


\begin{minted}{jlcon}
julia> logspace(1.,10.,5)
5-element Array{Float64,1}:
   10.0
 1778.28
    3.16228e5
    5.62341e7
    1.0e10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L316-L330}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14988757249747540457}{} 
\hyperlink{14988757249747540457}{\texttt{Base.Random.randsubseq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randsubseq(A, p) -> Vector
\end{lstlisting}

Return a vector consisting of a random subsequence of the given array \texttt{A}, where each element of \texttt{A} is included (in order) with independent probability \texttt{p}. (Complexity is linear in \texttt{p*length(A)}, so this function is efficient even if \texttt{p} is small and \texttt{A} is large.) Technically, this process is known as {\textquotedbl}Bernoulli sampling{\textquotedbl} of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1571-L1578}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17159975656568461918}{} 
\hyperlink{17159975656568461918}{\texttt{Base.Random.randsubseq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randsubseq!(S, A, p)
\end{lstlisting}

Like \hyperlink{14988757249747540457}{\texttt{randsubseq}}, but the results are stored in \texttt{S} (which is resized as needed).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L472-L477}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12405966813196017790}{}


\section{Funciones básicas}


\hypertarget{1688406579181746010}{} 
\hyperlink{1688406579181746010}{\texttt{Base.ndims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ndims(A::AbstractArray) -> Integer
\end{lstlisting}

Returns the number of dimensions of \texttt{A}.


\begin{minted}{jlcon}
julia> A = ones(3,4,5);

julia> ndims(A)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L103-L114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17888996102305087038}{} 
\hyperlink{17888996102305087038}{\texttt{Base.size}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
size(A::AbstractArray, [dim...])
\end{lstlisting}

Returns a tuple containing the dimensions of \texttt{A}. Optionally you can specify the dimension(s) you want the length of, and get the length of that dimension, or a tuple of the lengths of dimensions you asked for.


\begin{minted}{jlcon}
julia> A = ones(2,3,4);

julia> size(A, 2)
3

julia> size(A,3,2)
(4, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L12-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16112307926804387301}{} 
\hyperlink{16112307926804387301}{\texttt{Base.indices}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indices(A)
\end{lstlisting}

Returns the tuple of valid indices for array \texttt{A}.


\begin{minted}{jlcon}
julia> A = ones(5,6,7);

julia> indices(A)
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L50-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7894131722758489183}{} 
\hyperlink{7894131722758489183}{\texttt{Base.indices}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indices(A, d)
\end{lstlisting}

Returns the valid range of indices for array \texttt{A} along dimension \texttt{d}.


\begin{minted}{jlcon}
julia> A = ones(5,6,7);

julia> indices(A,2)
Base.OneTo(6)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L33-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3699181304419743826}{} 
\hyperlink{3699181304419743826}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
length(A::AbstractArray) -> Integer
\end{lstlisting}

Returns the number of elements in \texttt{A}.


\begin{minted}{jlcon}
julia> A = ones(3,4,5);

julia> length(A)
60
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L119-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4701773772897287974}{} 
\hyperlink{4701773772897287974}{\texttt{Base.eachindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eachindex(A...)
\end{lstlisting}

Creates an iterable object for visiting each index of an AbstractArray \texttt{A} in an efficient manner. For array types that have opted into fast linear indexing (like \texttt{Array}), this is simply the range \texttt{1:length(A)}. For other array types, this returns a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, this returns an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).

Example for a sparse 2-d array:


\begin{minted}{jlcon}
julia> A = sparse([1, 1, 2], [1, 3, 1], [1, 2, -5])
2×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 1]  =  -5
  [1, 3]  =  2

julia> for iter in eachindex(A)
           @show iter.I[1], iter.I[2]
           @show A[iter]
       end
(iter.I[1], iter.I[2]) = (1, 1)
A[iter] = 1
(iter.I[1], iter.I[2]) = (2, 1)
A[iter] = -5
(iter.I[1], iter.I[2]) = (1, 2)
A[iter] = 0
(iter.I[1], iter.I[2]) = (2, 2)
A[iter] = 0
(iter.I[1], iter.I[2]) = (1, 3)
A[iter] = 2
(iter.I[1], iter.I[2]) = (2, 3)
A[iter] = 0
\end{minted}

If you supply more than one \texttt{AbstractArray} argument, \texttt{eachindex} will create an iterable object that is fast for all arguments (a \texttt{UnitRange} if all inputs have fast linear indexing, a \hyperlink{7200434320514039079}{\texttt{CartesianRange}} otherwise). If the arrays have different sizes and/or dimensionalities, \texttt{eachindex} returns an iterable that spans the largest range along each dimension.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L766-L809}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13300247299461209585}{} 
\hyperlink{13300247299461209585}{\texttt{Base.linearindices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
linearindices(A)
\end{lstlisting}

Returns a \texttt{UnitRange} specifying the valid range of indices for \texttt{A[i]} where \texttt{i} is an \texttt{Int}. For arrays with conventional indexing (indices start at 1), or any multidimensional array, this is \texttt{1:length(A)}; however, for one-dimensional arrays with unconventional indices, this is \texttt{indices(A, 1)}.

Calling this function is the {\textquotedbl}safe{\textquotedbl} way to write algorithms that exploit linear indexing.


\begin{minted}{jlcon}
julia> A = ones(5,6,7);

julia> b = linearindices(A);

julia> extrema(b)
(1, 210)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L77-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7782790551324367092}{} 
\hyperlink{7782790551324367092}{\texttt{Base.IndexStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IndexStyle(A)
IndexStyle(typeof(A))
\end{lstlisting}

\texttt{IndexStyle} specifies the {\textquotedbl}native indexing style{\textquotedbl} for array \texttt{A}. When you define a new \texttt{AbstractArray} type, you can choose to implement either linear indexing or cartesian indexing.  If you decide to implement linear indexing, then you must set this trait for your array type:


\begin{lstlisting}
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()
\end{lstlisting}

The default is \texttt{IndexCartesian()}.

Julia{\textquotesingle}s internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style using \hyperlink{3802607582438455846}{\texttt{sub2ind}} or \hyperlink{15673022236027819944}{\texttt{ind2sub}}. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.

If you define both styles of indexing for your \texttt{AbstractArray}, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, \hyperlink{4701773772897287974}{\texttt{eachindex}} creates an iterator whose type depends on the setting of this trait.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L260-L286}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14756260737478660234}{} 
\hyperlink{14756260737478660234}{\texttt{Base.countnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
countnz(A) -> Integer
\end{lstlisting}

Counts the number of nonzero values in array \texttt{A} (dense or sparse). Note that this is not a constant-time operation. For sparse matrices, one should usually use \hyperlink{6318543341724753931}{\texttt{nnz}}, which returns the number of stored values.


\begin{minted}{jlcon}
julia> A = [1 2 4; 0 0 1; 1 1 0]
3×3 Array{Int64,2}:
 1  2  4
 0  0  1
 1  1  0

julia> countnz(A)
6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L705-L721}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17819607861919666057}{} 
\hyperlink{17819607861919666057}{\texttt{Base.conj!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
conj!(A)
\end{lstlisting}

Transform an array to its complex conjugate in-place.

See also \hyperlink{9940023991150673697}{\texttt{conj}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1+im 2-im; 2+2im 3+im]
2×2 Array{Complex{Int64},2}:
 1+1im  2-1im
 2+2im  3+1im

julia> conj!(A);

julia> A
2×2 Array{Complex{Int64},2}:
 1-1im  2+1im
 2-2im  3-1im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L5-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{97811245619734938}{} 
\hyperlink{97811245619734938}{\texttt{Base.stride}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stride(A, k::Integer)
\end{lstlisting}

Returns the distance in memory (in number of elements) between adjacent elements in dimension \texttt{k}.


\begin{minted}{jlcon}
julia> A = ones(3,4,5);

julia> stride(A,2)
3

julia> stride(A,3)
12
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L174-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13576557637670855932}{} 
\hyperlink{13576557637670855932}{\texttt{Base.strides}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strides(A)
\end{lstlisting}

Returns a tuple of the memory strides in each dimension.


\begin{minted}{jlcon}
julia> A = ones(3,4,5);

julia> strides(A)
(1, 3, 12)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L200-L211}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15673022236027819944}{} 
\hyperlink{15673022236027819944}{\texttt{Base.ind2sub}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ind2sub(a, index) -> subscripts
\end{lstlisting}

Returns a tuple of subscripts into array \texttt{a} corresponding to the linear index \texttt{index}.


\begin{minted}{jlcon}
julia> A = ones(5,6,7);

julia> ind2sub(A,35)
(5, 1, 2)

julia> ind2sub(A,70)
(5, 2, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1542-L1556}{\texttt{source}}



\begin{lstlisting}
ind2sub(dims, index) -> subscripts
\end{lstlisting}

Returns a tuple of subscripts into an array with dimensions \texttt{dims}, corresponding to the linear index \texttt{index}.

\textbf{Example}:


\begin{lstlisting}
i, j, ... = ind2sub(size(A), indmax(A))
\end{lstlisting}

provides the indices of the maximum element.


\begin{minted}{jlcon}
julia> ind2sub((3,4),2)
(2, 1)

julia> ind2sub((3,4),3)
(3, 1)

julia> ind2sub((3,4),4)
(1, 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1609-L1633}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3802607582438455846}{} 
\hyperlink{3802607582438455846}{\texttt{Base.sub2ind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sub2ind(dims, i, j, k...) -> index
\end{lstlisting}

The inverse of \hyperlink{15673022236027819944}{\texttt{ind2sub}}, returns the linear index corresponding to the provided subscripts.


\begin{minted}{jlcon}
julia> sub2ind((5,6,7),1,2,3)
66

julia> sub2ind((5,6,7),1,6,3)
86
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1569-L1581}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3824705473881088503}{} 
\hyperlink{3824705473881088503}{\texttt{Base.LinAlg.checksquare}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LinAlg.checksquare(A)
\end{lstlisting}

Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = ones(4,4); B = zeros(5,5);

julia> LinAlg.checksquare(A, B)
2-element Array{Int64,1}:
 4
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/linalg.jl#L198-L214}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7850493673639296018}{}


\section{Retransmisión y Vectorización}



Ver también la \hyperlink{13590013989415065742}{sintaxis de puntos para vectorizar funciones}; por ejemplo, \texttt{f. (args ...)} llama implícitamente a \texttt{broadcast(f, args...)}. En lugar de confiar en los métodos {\textquotedbl}vectorizados{\textquotedbl} de funciones como \texttt{sin} para operar en arrays, debe usar \texttt{sin.(A)} para vectorizar a través de \texttt{broadcast}.


\hypertarget{1261021074485016178}{} 
\hyperlink{1261021074485016178}{\texttt{Base.broadcast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
broadcast(f, As...)
\end{lstlisting}

Broadcasts the arrays, tuples, \texttt{Ref}s, nullables, and/or scalars \texttt{As} to a container of the appropriate type and dimensions. In this context, anything that is not a subtype of \texttt{AbstractArray}, \texttt{Ref} (except for \texttt{Ptr}s), \texttt{Tuple}, or \texttt{Nullable} is considered a scalar. The resulting container is established by the following rules:

\begin{itemize}
\item If all the arguments are scalars, it returns a scalar.


\item If the arguments are tuples and zero or more scalars, it returns a tuple.


\item If the arguments contain at least one array or \texttt{Ref}, it returns an array (expanding singleton dimensions), and treats \texttt{Ref}s as 0-dimensional arrays, and tuples as 1-dimensional arrays.

\end{itemize}
The following additional rule applies to \texttt{Nullable} arguments: If there is at least one \texttt{Nullable}, and all the arguments are scalars or \texttt{Nullable}, it returns a \texttt{Nullable} treating \texttt{Nullable}s as {\textquotedbl}containers{\textquotedbl}.

A special syntax exists for broadcasting: \texttt{f.(args...)} is equivalent to \texttt{broadcast(f, args...)}, and nested \texttt{f.(g.(args...))} calls are fused into a single broadcast loop.


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia> broadcast(+, A, B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia> parse.(Int, ["1", "2"])
2-element Array{Int64,1}:
 1
 2

julia> abs.((1, -2))
(1, 2)

julia> broadcast(+, 1.0, (0, -2.0))
(1.0, -1.0)

julia> broadcast(+, 1.0, (0, -2.0), Ref(1))
2-element Array{Float64,1}:
 2.0
 0.0

julia> (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))
2-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]

julia> string.(("one","two","three","four"), ": ", 1:4)
4-element Array{String,1}:
 "one: 1"
 "two: 2"
 "three: 3"
 "four: 4"

julia> Nullable("X") .* "Y"
Nullable{String}("XY")

julia> broadcast(/, 1.0, Nullable(2.0))
Nullable{Float64}(0.5)

julia> (1 + im) ./ Nullable{Int}()
Nullable{Complex{Float64}}()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L369-L454}{\texttt{source}}


\end{adjustwidth}
\hypertarget{501355550527574084}{} 
\hyperlink{501355550527574084}{\texttt{Base.broadcast!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
broadcast!(f, dest, As...)
\end{lstlisting}

Like \hyperlink{1261021074485016178}{\texttt{broadcast}}, but store the result of \texttt{broadcast(f, As...)} in the \texttt{dest} array. Note that \texttt{dest} is only used to store the result, and does not supply arguments to \texttt{f} unless it is also listed in the \texttt{As}, as in \texttt{broadcast!(f, A, A, B)} to perform \texttt{A[:] = broadcast(f, A, B)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L197-L205}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16688502228717894452}{} 
\hyperlink{16688502228717894452}{\texttt{Base.Broadcast.@\_\_dot\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@. expr
\end{lstlisting}

Convert every function call or operator in \texttt{expr} into a {\textquotedbl}dot call{\textquotedbl} (e.g. convert \texttt{f(x)} to \texttt{f.(x)}), and convert every assignment in \texttt{expr} to a {\textquotedbl}dot assignment{\textquotedbl} (e.g. convert \texttt{+=} to \texttt{.+=}).

If you want to \emph{avoid} adding dots for selected function calls in \texttt{expr}, splice those function calls in with \texttt{\$}.  For example, \texttt{@. sqrt(abs(\$sort(x)))} is equivalent to \texttt{sqrt.(abs.(sort(x)))} (no dot for \texttt{sort}).

(\texttt{@.} is equivalent to a call to \texttt{@\_\_dot\_\_}.)


\begin{minted}{jlcon}
julia> x = 1.0:3.0; y = similar(x);

julia> @. y = x + 3 * sin(x)
3-element Array{Float64,1}:
 3.52441
 4.72789
 3.42336
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L603-L626}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5896180186078332739}{} 
\hyperlink{5896180186078332739}{\texttt{Base.Broadcast.broadcast\_getindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
broadcast_getindex(A, inds...)
\end{lstlisting}

Broadcasts the \texttt{inds} arrays to a common size like \hyperlink{1261021074485016178}{\texttt{broadcast}} and returns an array of the results \texttt{A[ks...]}, where \texttt{ks} goes over the positions in the broadcast result \texttt{A}.


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia> C = broadcast(+,A,B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia> broadcast_getindex(C,[1,2,10])
3-element Array{Int64,1}:
  2
  5
 15
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L457-L495}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12782056467660082625}{} 
\hyperlink{12782056467660082625}{\texttt{Base.Broadcast.broadcast\_setindex!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
broadcast_setindex!(A, X, inds...)
\end{lstlisting}

Broadcasts the \texttt{X} and \texttt{inds} arrays to a common size and stores the value from each position in \texttt{X} at the indices in \texttt{A} given by the same positions in \texttt{inds}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L513-L518}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14438080058911688735}{}


\section{Indexación y Asignación}


\hypertarget{70337294579126602}{} 
\hyperlink{70337294579126602}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getindex(A, inds...)
\end{lstlisting}

Returns a subset of array \texttt{A} as specified by \texttt{inds}, where each \texttt{ind} may be an \texttt{Int}, a \texttt{Range}, or a \texttt{Vector}. See the manual section on \hyperlink{14469287548874312017}{array indexing} for details.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> getindex(A, 1)
1

julia> getindex(A, [2, 1])
2-element Array{Int64,1}:
 3
 1

julia> getindex(A, 2:4)
3-element Array{Int64,1}:
 3
 2
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L119-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17903591429492118749}{} 
\hyperlink{17903591429492118749}{\texttt{Base.setindex!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setindex!(A, X, inds...)
\end{lstlisting}

Store values from array \texttt{X} within some subset of \texttt{A} as specified by \texttt{inds}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2288-L2292}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17942425127136986264}{} 
\hyperlink{17942425127136986264}{\texttt{Base.copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copy!(dest, Rdest::CartesianRange, src, Rsrc::CartesianRange) -> dest
\end{lstlisting}

Copy the block of \texttt{src} in the range of \texttt{Rsrc} to the block of \texttt{dest} in the range of \texttt{Rdest}. The sizes of the two regions must match.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L887-L892}{\texttt{source}}


\end{adjustwidth}
\hypertarget{976355747478401147}{} 
\hyperlink{976355747478401147}{\texttt{Base.isassigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isassigned(array, i) -> Bool
\end{lstlisting}

Tests whether the given array has a value associated with index \texttt{i}. Returns \texttt{false} if the index is out of bounds, or has an undefined reference.


\begin{minted}{jlcon}
julia> isassigned(rand(3, 3), 5)
true

julia> isassigned(rand(3, 3), 3 * 3 + 1)
false

julia> mutable struct Foo end

julia> v = similar(rand(3), Foo)
3-element Array{Foo,1}:
 #undef
 #undef
 #undef

julia> isassigned(v, 1)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L278-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13649361117037263099}{} 
\hyperlink{13649361117037263099}{\texttt{Base.Colon}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Colon()
\end{lstlisting}

Colons (:) are used to signify indexing entire objects or dimensions at once.

Very few operations are defined on Colons directly; instead they are converted by \hyperlink{10027537986402266830}{\texttt{to\_indices}} to an internal vector type (\texttt{Base.Slice}) to represent the collection of indices they span before being used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L311-L319}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4571802376991525093}{} 
\hyperlink{4571802376991525093}{\texttt{Base.IteratorsMD.CartesianIndex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CartesianIndex(i, j, k...)   -> I
CartesianIndex((i, j, k...)) -> I
\end{lstlisting}

Create a multidimensional index \texttt{I}, which can be used for indexing a multidimensional array \texttt{A}.  In particular, \texttt{A[I]} is equivalent to \texttt{A[i,j,k...]}.  One can freely mix integer and \texttt{CartesianIndex} indices; for example, \texttt{A[Ipre, i, Ipost]} (where \texttt{Ipre} and \texttt{Ipost} are \texttt{CartesianIndex} indices and \texttt{i} is an \texttt{Int}) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.

A \texttt{CartesianIndex} is sometimes produced by \hyperlink{4701773772897287974}{\texttt{eachindex}}, and always when iterating with an explicit \hyperlink{7200434320514039079}{\texttt{CartesianRange}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> A[CartesianIndex((1, 1, 1, 1))]
1

julia> A[CartesianIndex((1, 1, 1, 2))]
9

julia> A[CartesianIndex((1, 1, 2, 1))]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L15-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7200434320514039079}{} 
\hyperlink{7200434320514039079}{\texttt{Base.IteratorsMD.CartesianRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CartesianRange(Istart::CartesianIndex, Istop::CartesianIndex) -> R
CartesianRange(sz::Dims) -> R
CartesianRange(istart:istop, jstart:jstop, ...) -> R
\end{lstlisting}

Define a region \texttt{R} spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where \texttt{for I in R ... end} will return \hyperlink{4571802376991525093}{\texttt{CartesianIndex}} indices \texttt{I} equivalent to the nested loops


\begin{lstlisting}
for j = jstart:jstop
    for i = istart:istop
        ...
    end
end
\end{lstlisting}

Consequently these can be useful for writing algorithms that work in arbitrary dimensions.


\begin{minted}{jlcon}
julia> foreach(println, CartesianRange((2, 2, 2)))
CartesianIndex{3}((1, 1, 1))
CartesianIndex{3}((2, 1, 1))
CartesianIndex{3}((1, 2, 1))
CartesianIndex{3}((2, 2, 1))
CartesianIndex{3}((1, 1, 2))
CartesianIndex{3}((2, 1, 2))
CartesianIndex{3}((1, 2, 2))
CartesianIndex{3}((2, 2, 2))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L137-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10027537986402266830}{} 
\hyperlink{10027537986402266830}{\texttt{Base.to\_indices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
to_indices(A, I::Tuple)
\end{lstlisting}

Convert the tuple \texttt{I} to a tuple of indices for use in indexing into array \texttt{A}.

The returned tuple must only contain either \texttt{Int}s or \texttt{AbstractArray}s of scalar indices that are supported by array \texttt{A}. It will error upon encountering a novel index type that it does not know how to process.

For simple index types, it defers to the unexported \texttt{Base.to\_index(A, i)} to process each index \texttt{i}. While this internal function is not intended to be called directly, \texttt{Base.to\_index} may be extended by custom array or index types to provide custom indexing behaviors.

More complicated index types may require more context about the dimension into which they index. To support those cases, \texttt{to\_indices(A, I)} calls \texttt{to\_indices(A, indices(A), I)}, which then recursively walks through both the given tuple of indices and the dimensional indices of \texttt{A} in tandem. As such, not all index types are guaranteed to propagate to \texttt{Base.to\_index}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/indices.jl#L193-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6593895036014271495}{} 
\hyperlink{6593895036014271495}{\texttt{Base.checkbounds}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
checkbounds(Bool, A, I...)
\end{lstlisting}

Return \texttt{true} if the specified indices \texttt{I} are in bounds for the given array \texttt{A}. Subtypes of \texttt{AbstractArray} should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on \texttt{A}{\textquotesingle}s indices and \hyperlink{4607154172896664089}{\texttt{checkindex}}.

See also \hyperlink{4607154172896664089}{\texttt{checkindex}}.


\begin{minted}{jlcon}
julia> A = rand(3, 3);

julia> checkbounds(Bool, A, 2)
true

julia> checkbounds(Bool, A, 3, 4)
false

julia> checkbounds(Bool, A, 1:3)
true

julia> checkbounds(Bool, A, 1:3, 2:4)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L314-L339}{\texttt{source}}



\begin{lstlisting}
checkbounds(A, I...)
\end{lstlisting}

Throw an error if the specified indices \texttt{I} are not in bounds for the given array \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L355-L359}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4607154172896664089}{} 
\hyperlink{4607154172896664089}{\texttt{Base.checkindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
checkindex(Bool, inds::AbstractUnitRange, index)
\end{lstlisting}

Return \texttt{true} if the given \texttt{index} is within the bounds of \texttt{inds}. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.


\begin{minted}{jlcon}
julia> checkindex(Bool,1:20,8)
true

julia> checkindex(Bool,1:20,21)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L437-L452}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4877859157667011167}{}


\section{Vistas (SubArrays y otros tipos de vistas)}


\hypertarget{4861450464669906845}{} 
\hyperlink{4861450464669906845}{\texttt{Base.view}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
view(A, inds...)
\end{lstlisting}

Like \hyperlink{2839226020402435013}{\texttt{getindex}}, but returns a view into the parent array \texttt{A} with the given indices instead of making a copy.  Calling \hyperlink{2839226020402435013}{\texttt{getindex}} or \hyperlink{17903591429492118749}{\texttt{setindex!}} on the returned \texttt{SubArray} computes the indices to the parent array on the fly without checking bounds.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = view(A, :, 1)
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 1
 3

julia> fill!(b, 0)
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 0
 0

julia> A # Note A has changed even though we modified b
2×2 Array{Int64,2}:
 0  2
 0  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/subarray.jl#L80-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4916348678965327831}{} 
\hyperlink{4916348678965327831}{\texttt{Base.@view}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@view A[inds...]
\end{lstlisting}

Creates a \texttt{SubArray} from an indexing expression. This can only be applied directly to a reference expression (e.g. \texttt{@view A[1,2:end]}), and should \emph{not} be used as the target of an assignment (e.g. \texttt{@view(A[1,2:end]) = ...}).  See also \hyperlink{4544474300423667148}{\texttt{@views}} to switch an entire block of code to use views for slicing.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = @view A[:, 1]
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 1
 3

julia> fill!(b, 0)
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 0
 0

julia> A
2×2 Array{Int64,2}:
 0  2
 0  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/subarray.jl#L418-L447}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4544474300423667148}{} 
\hyperlink{4544474300423667148}{\texttt{Base.@views}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@views expression
\end{lstlisting}

Convert every array-slicing operation in the given expression (which may be a \texttt{begin}/\texttt{end} block, loop, function, etc.) to return a view.   Scalar indices, non-array types, and explicit \texttt{getindex} calls (as opposed to \texttt{array[...]}) are unaffected.

Note that the \texttt{@views} macro only affects \texttt{array[...]} expressions that appear explicitly in the given \texttt{expression}, not array slicing that occurs in functions called by that code.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/subarray.jl#L527-L539}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11732113189086969263}{} 
\hyperlink{11732113189086969263}{\texttt{Base.parent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parent(A)
\end{lstlisting}

Returns the {\textquotedbl}parent array{\textquotedbl} of an array view type (e.g., \texttt{SubArray}), or the array itself if it is not a view.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1798-L1803}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16489373313987716520}{} 
\hyperlink{16489373313987716520}{\texttt{Base.parentindexes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parentindexes(A)
\end{lstlisting}

From an array view \texttt{A}, returns the corresponding indexes in the parent.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/subarray.jl#L64-L68}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13345480578513845480}{} 
\hyperlink{13345480578513845480}{\texttt{Base.slicedim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
slicedim(A, d::Integer, i)
\end{lstlisting}

Return all the data of \texttt{A} where the index for dimension \texttt{d} equals \texttt{i}. Equivalent to \texttt{A[:,:,...,i,:,:,...]} where \texttt{i} is in position \texttt{d}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 5 6 7 8]
2×4 Array{Int64,2}:
 1  2  3  4
 5  6  7  8

julia> slicedim(A,2,3)
2-element Array{Int64,1}:
 3
 7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L100-L118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{293815781001952115}{} 
\hyperlink{293815781001952115}{\texttt{Base.reinterpret}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reinterpret(type, A)
\end{lstlisting}

Change the type-interpretation of a block of memory. For arrays, this constructs an array with the same binary data as the given array, but with the specified element type. For example, \texttt{reinterpret(Float32, UInt32(7))} interprets the 4 bytes corresponding to \texttt{UInt32(7)} as a \hyperlink{8101639384272933082}{\texttt{Float32}}.

\begin{quote}
\textbf{Warning}

It is not allowed to \texttt{reinterpret} an array to an element type with a larger alignment then the alignment of the array. For a normal \texttt{Array}, this is the alignment of its element type. For a reinterpreted array, this is the alignment of the \texttt{Array} it was reinterpreted from. For example, \texttt{reinterpret(UInt32, UInt8[0, 0, 0, 0])} is not allowed but \texttt{reinterpret(UInt32, reinterpret(UInt8, Float32[1.0]))} is allowed.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> reinterpret(Float32, UInt32(7))
1.0f-44

julia> reinterpret(Float32, UInt32[1 2 3 4 5])
1×5 Array{Float32,2}:
 1.4013f-45  2.8026f-45  4.2039f-45  5.60519f-45  7.00649f-45
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1245-L1272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3388738163419525310}{} 
\hyperlink{3388738163419525310}{\texttt{Base.reshape}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reshape(A, dims...) -> R
reshape(A, dims) -> R
\end{lstlisting}

Return an array \texttt{R} with the same data as \texttt{A}, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that setting elements of \texttt{R} alters the values of \texttt{A} and vice versa.

The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a \texttt{:}, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array \texttt{A}. The total number of elements must not change.


\begin{minted}{jlcon}
julia> A = collect(1:16)
16-element Array{Int64,1}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16

julia> reshape(A, (4, 4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> reshape(A, 2, :)
2×8 Array{Int64,2}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reshapedarray.jl#L39-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8564653172595523279}{} 
\hyperlink{8564653172595523279}{\texttt{Base.squeeze}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
squeeze(A, dims)
\end{lstlisting}

Remove the dimensions specified by \texttt{dims} from array \texttt{A}. Elements of \texttt{dims} must be unique and within the range \texttt{1:ndims(A)}. \texttt{size(A,i)} must equal 1 for all \texttt{i} in \texttt{dims}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = reshape(collect(1:4),(2,2,1,1))
2×2×1×1 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

julia> squeeze(a,3)
2×2×1 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L45-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18435874855636770528}{} 
\hyperlink{18435874855636770528}{\texttt{Base.vec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
vec(a::AbstractArray) -> Vector
\end{lstlisting}

Reshape the array \texttt{a} as a one-dimensional column vector. The resulting array shares the same underlying data as \texttt{a}, so modifying one will also modify the other.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> vec(a)
6-element Array{Int64,1}:
 1
 4
 2
 5
 3
 6
\end{minted}

See also \hyperlink{3388738163419525310}{\texttt{reshape}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L12-L37}{\texttt{source}}


\end{adjustwidth}

\hypertarget{873938541684201796}{}


\section{Concatenación and permutación}


\hypertarget{9868138443525443234}{} 
\hyperlink{9868138443525443234}{\texttt{Base.cat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cat(dims, A...)
\end{lstlisting}

Concatenate the input arrays along the specified dimensions in the iterable \texttt{dims}. For dimensions not in \texttt{dims}, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in \texttt{dims}, the size of the output array is the sum of the sizes of the input arrays along that dimension. If \texttt{dims} is a single number, the different arrays are tightly stacked along that dimension. If \texttt{dims} is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, \texttt{cat([1,2], matrices...)} builds a block diagonal matrix, i.e. a block matrix with \texttt{matrices[1]}, \texttt{matrices[2]}, ... as diagonal blocks and matching zero blocks away from the diagonal.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1836-L1850}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14691815416955507876}{} 
\hyperlink{14691815416955507876}{\texttt{Base.vcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
vcat(A...)
\end{lstlisting}

Concatenate along dimension 1.


\begin{minted}{jlcon}
julia> a = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia> b = [6 7 8 9 10; 11 12 13 14 15]
2×5 Array{Int64,2}:
  6   7   8   9  10
 11  12  13  14  15

julia> vcat(a,b)
3×5 Array{Int64,2}:
  1   2   3   4   5
  6   7   8   9  10
 11  12  13  14  15

julia> c = ([1 2 3], [4 5 6])
([1 2 3], [4 5 6])

julia> vcat(c...)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1230-L1259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862791894748483563}{} 
\hyperlink{8862791894748483563}{\texttt{Base.hcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hcat(A...)
\end{lstlisting}

Concatenate along dimension 2.


\begin{minted}{jlcon}
julia> a = [1; 2; 3; 4; 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> b = [6 7; 8 9; 10 11; 12 13; 14 15]
5×2 Array{Int64,2}:
  6   7
  8   9
 10  11
 12  13
 14  15

julia> hcat(a,b)
5×3 Array{Int64,2}:
 1   6   7
 2   8   9
 3  10  11
 4  12  13
 5  14  15

julia> c = ([1; 2; 3], [4; 5; 6])
([1, 2, 3], [4, 5, 6])

julia> hcat(c...)
3×2 Array{Int64,2}:
 1  4
 2  5
 3  6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1261-L1300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16279083053557795116}{} 
\hyperlink{16279083053557795116}{\texttt{Base.hvcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hvcat(rows::Tuple{Vararg{Int}}, values...)
\end{lstlisting}

Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.


\begin{minted}{jlcon}
julia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia> [a b c; d e f]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> hvcat((3,3), a,b,c,d,e,f)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> [a b;c d; e f]
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6

julia> hvcat((2,2,2), a,b,c,d,e,f)
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6
\end{minted}

If the first argument is a single integer \texttt{n}, then all block rows are assumed to have \texttt{n} block columns.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1335-L1371}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12703826416373665531}{} 
\hyperlink{12703826416373665531}{\texttt{Base.flipdim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flipdim(A, d::Integer)
\end{lstlisting}

Reverse \texttt{A} in dimension \texttt{d}.

\textbf{Example}


\begin{minted}{jlcon}
julia> b = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> flipdim(b,2)
2×2 Array{Int64,2}:
 2  1
 4  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L126-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15182910221850902862}{} 
\hyperlink{15182910221850902862}{\texttt{Base.circshift}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
circshift(A, shifts)
\end{lstlisting}

Circularly shift the data in an array. The second argument is a vector giving the amount to shift in each dimension.

\textbf{Example}


\begin{minted}{jlcon}
julia> b = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> circshift(b, (0,2))
4×4 Array{Int64,2}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia> circshift(b, (-1,0))
4×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13
\end{minted}

See also \hyperlink{5319002815154535997}{\texttt{circshift!}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L178-L209}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5319002815154535997}{} 
\hyperlink{5319002815154535997}{\texttt{Base.circshift!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
circshift!(dest, src, shifts)
\end{lstlisting}

Circularly shift the data in \texttt{src}, storing the result in \texttt{dest}. \texttt{shifts} specifies the amount to shift in each dimension.

The \texttt{dest} array must be distinct from the \texttt{src} array (they cannot alias each other).

See also \hyperlink{15182910221850902862}{\texttt{circshift}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L897-L907}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13256910868822648458}{} 
\hyperlink{13256910868822648458}{\texttt{Base.circcopy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
circcopy!(dest, src)
\end{lstlisting}

Copy \texttt{src} to \texttt{dest}, indexing each dimension modulo its length. \texttt{src} and \texttt{dest} must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap \texttt{dest} agrees with \texttt{src}.

\textbf{Example}


\begin{minted}{jlcon}
julia> src = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> dest = OffsetArray{Int}((0:3,2:5))

julia> circcopy!(dest, src)
OffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:
 8  12  16  4
 5   9  13  1
 6  10  14  2
 7  11  15  3

julia> dest[1:3,2:4] == src[1:3,2:4]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L950-L980}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16229508745643032859}{} 
\hyperlink{16229508745643032859}{\texttt{Base.contains}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
contains(fun, itr, x) -> Bool
\end{lstlisting}

Returns \texttt{true} if there is at least one element \texttt{y} in \texttt{itr} such that \texttt{fun(y,x)} is \texttt{true}.


\begin{minted}{jlcon}
julia> vec = [10, 100, 200]
3-element Array{Int64,1}:
  10
 100
 200

julia> contains(==, vec, 200)
true

julia> contains(==, vec, 300)
false

julia> contains(>, vec, 100)
true

julia> contains(>, vec, 200)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L638-L662}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13973031941728195278}{} 
\hyperlink{13973031941728195278}{\texttt{Base.find}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
find(A)
\end{lstlisting}

Return a vector of the linear indexes of the non-zeros in \texttt{A} (determined by \texttt{A[i]!=0}). A common use of this is to convert a boolean array to an array of indexes of the \texttt{true} elements. If there are no non-zero elements of \texttt{A}, \texttt{find} returns an empty array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; false true]
2×2 Array{Bool,2}:
  true  false
 false   true

julia> find(A)
2-element Array{Int64,1}:
 1
 4

julia> find(zeros(3))
0-element Array{Int64,1}
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1532-L1554}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16634642403736312993}{} 
\hyperlink{16634642403736312993}{\texttt{Base.find}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
find(f::Function, A)
\end{lstlisting}

Return a vector \texttt{I} of the linear indexes of \texttt{A} where \texttt{f(A[I])} returns \texttt{true}. If there are no such elements of \texttt{A}, find returns an empty array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> find(isodd,A)
2-element Array{Int64,1}:
 1
 2

julia> find(isodd, [2, 4])
0-element Array{Int64,1}
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1493-L1514}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7762671957301951450}{} 
\hyperlink{7762671957301951450}{\texttt{Base.findn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findn(A)
\end{lstlisting}

Return a vector of indexes for each dimension giving the locations of the non-zeros in \texttt{A} (determined by \texttt{A[i]!=0}). If there are no non-zero elements of \texttt{A}, \texttt{findn} returns a 2-tuple of empty arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 0; 0 0 3; 0 4 0]
3×3 Array{Int64,2}:
 1  2  0
 0  0  3
 0  4  0

julia> findn(A)
([1, 1, 3, 2], [1, 2, 2, 3])

julia> A = zeros(2,2)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia> findn(A)
(Int64[], Int64[])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1574-L1600}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10811968090686169507}{} 
\hyperlink{10811968090686169507}{\texttt{Base.findnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findnz(A)
\end{lstlisting}

Return a tuple \texttt{(I, J, V)} where \texttt{I} and \texttt{J} are the row and column indexes of the non-zero values in matrix \texttt{A}, and \texttt{V} is a vector of the non-zero values.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 0; 0 0 3; 0 4 0]
3×3 Array{Int64,2}:
 1  2  0
 0  0  3
 0  4  0

julia> findnz(A)
([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1616-L1633}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13752961745140943082}{} 
\hyperlink{13752961745140943082}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findfirst(A)
\end{lstlisting}

Return the linear index of the first non-zero value in \texttt{A} (determined by \texttt{A[i]!=0}). Returns \texttt{0} if no such value is found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 0; 1 0]
2×2 Array{Int64,2}:
 0  0
 1  0

julia> findfirst(A)
2

julia> findfirst(zeros(3))
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1219-L1238}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15882391722029874929}{} 
\hyperlink{15882391722029874929}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findfirst(A, v)
\end{lstlisting}

Return the linear index of the first element equal to \texttt{v} in \texttt{A}. Returns \texttt{0} if \texttt{v} is not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 6; 2 2]
2×2 Array{Int64,2}:
 4  6
 2  2

julia> findfirst(A,2)
2

julia> findfirst(A,3)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1268-L1287}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10686327966799324598}{} 
\hyperlink{10686327966799324598}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findfirst(predicate::Function, A)
\end{lstlisting}

Return the linear index of the first element of \texttt{A} for which \texttt{predicate} returns \texttt{true}. Returns \texttt{0} if there is no such element.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia> findfirst(iseven, A)
2

julia> findfirst(x -> x>10, A)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1318-L1337}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16601358451866933976}{} 
\hyperlink{16601358451866933976}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findlast(A)
\end{lstlisting}

Return the linear index of the last non-zero value in \texttt{A} (determined by \texttt{A[i]!=0}). Returns \texttt{0} if there is no non-zero value in \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 1 0]
2×2 Array{Int64,2}:
 1  0
 1  0

julia> findlast(A)
2

julia> A = zeros(2,2)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia> findlast(A)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1366-L1390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9642735754110648594}{} 
\hyperlink{9642735754110648594}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findlast(A, v)
\end{lstlisting}

Return the linear index of the last element equal to \texttt{v} in \texttt{A}. Returns \texttt{0} if there is no element of \texttt{A} equal to \texttt{v}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 1]
2×2 Array{Int64,2}:
 1  2
 2  1

julia> findlast(A,1)
4

julia> findlast(A,2)
3

julia> findlast(A,3)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1419-L1441}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13690191743392331122}{} 
\hyperlink{13690191743392331122}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findlast(predicate::Function, A)
\end{lstlisting}

Return the linear index of the last element of \texttt{A} for which \texttt{predicate} returns \texttt{true}. Returns \texttt{0} if there is no such element.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> findlast(isodd, A)
2

julia> findlast(x -> x > 5, A)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1471-L1490}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9906000186778518011}{} 
\hyperlink{9906000186778518011}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findnext(A, i::Integer)
\end{lstlisting}

Find the next linear index >= \texttt{i} of a non-zero element of \texttt{A}, or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 0; 1 0]
2×2 Array{Int64,2}:
 0  0
 1  0

julia> findnext(A,1)
2

julia> findnext(A,3)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1191-L1209}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2433853860677249610}{} 
\hyperlink{2433853860677249610}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findnext(predicate::Function, A, i::Integer)
\end{lstlisting}

Find the next linear index >= \texttt{i} of an element of \texttt{A} for which \texttt{predicate} returns \texttt{true}, or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia> findnext(isodd, A, 1)
1

julia> findnext(isodd, A, 2)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1290-L1308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8856370662650438441}{} 
\hyperlink{8856370662650438441}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findnext(A, v, i::Integer)
\end{lstlisting}

Find the next linear index >= \texttt{i} of an element of \texttt{A} equal to \texttt{v} (using \texttt{==}), or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia> findnext(A,4,4)
0

julia> findnext(A,4,3)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1241-L1259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3864667477361062614}{} 
\hyperlink{3864667477361062614}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findprev(A, i::Integer)
\end{lstlisting}

Find the previous linear index <= \texttt{i} of a non-zero element of \texttt{A}, or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 0; 1 2]
2×2 Array{Int64,2}:
 0  0
 1  2

julia> findprev(A,2)
2

julia> findprev(A,1)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1340-L1358}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17827047449430918639}{} 
\hyperlink{17827047449430918639}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findprev(predicate::Function, A, i::Integer)
\end{lstlisting}

Find the previous linear index <= \texttt{i} of an element of \texttt{A} for which \texttt{predicate} returns \texttt{true}, or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 6; 1 2]
2×2 Array{Int64,2}:
 4  6
 1  2

julia> findprev(isodd, A, 1)
0

julia> findprev(isodd, A, 3)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1444-L1463}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1979671556370368619}{} 
\hyperlink{1979671556370368619}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findprev(A, v, i::Integer)
\end{lstlisting}

Find the previous linear index <= \texttt{i} of an element of \texttt{A} equal to \texttt{v} (using \texttt{==}), or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 0; 1 2]
2×2 Array{Int64,2}:
 0  0
 1  2

julia> findprev(A, 1, 4)
2

julia> findprev(A, 1, 1)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1393-L1411}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10913801624539723467}{} 
\hyperlink{10913801624539723467}{\texttt{Base.permutedims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permutedims(A, perm)
\end{lstlisting}

Permute the dimensions of array \texttt{A}. \texttt{perm} is a vector specifying a permutation of length \texttt{ndims(A)}. This is a generalization of transpose for multi-dimensional arrays. Transpose is equivalent to \texttt{permutedims(A, [2,1])}.

See also: \hyperlink{16936235724694909186}{\texttt{PermutedDimsArray}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = reshape(collect(1:8), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia> permutedims(A, [3, 2, 1])
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 5  7

[:, :, 2] =
 2  4
 6  8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/permuteddimsarray.jl#L83-L114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15299422200414360384}{} 
\hyperlink{15299422200414360384}{\texttt{Base.permutedims!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permutedims!(dest, src, perm)
\end{lstlisting}

Permute the dimensions of array \texttt{src} and store the result in the array \texttt{dest}. \texttt{perm} is a vector specifying a permutation of length \texttt{ndims(src)}. The preallocated array \texttt{dest} should have \texttt{size(dest) == size(src)[perm]} and is completely overwritten. No in-place permutation is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.

See also \hyperlink{10913801624539723467}{\texttt{permutedims}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/permuteddimsarray.jl#L120-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16936235724694909186}{} 
\hyperlink{16936235724694909186}{\texttt{Base.PermutedDimsArrays.PermutedDimsArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
PermutedDimsArray(A, perm) -> B
\end{lstlisting}

Given an AbstractArray \texttt{A}, create a view \texttt{B} such that the dimensions appear to be permuted. Similar to \texttt{permutedims}, except that no copying occurs (\texttt{B} shares storage with \texttt{A}).

See also: \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = rand(3,5,4);

julia> B = PermutedDimsArray(A, (3,1,2));

julia> size(B)
(4, 3, 5)

julia> B[3,1,2] == A[1,2,3]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/permuteddimsarray.jl#L19-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16545078180547259725}{} 
\hyperlink{16545078180547259725}{\texttt{Base.promote\_shape}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
promote_shape(s1, s2)
\end{lstlisting}

Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.


\begin{minted}{jlcon}
julia> a = ones(3,4,1,1,1);

julia> b = ones(3,4);

julia> promote_shape(a,b)
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))
(2, 3, 1, 4, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/indices.jl#L34-L51}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10164869372455466746}{}


\section{Funciones de Arrays}


\hypertarget{4708508974842578384}{} 
\hyperlink{4708508974842578384}{\texttt{Base.accumulate}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
accumulate(op, A, dim=1)
\end{lstlisting}

Cumulative operation \texttt{op} along a dimension \texttt{dim} (defaults to 1). See also \hyperlink{5431648933624159647}{\texttt{accumulate!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of \texttt{accumulate}, see: \hyperlink{6230751605647278302}{\texttt{cumsum}}, \hyperlink{9956198945051267091}{\texttt{cumprod}}


\begin{minted}{jlcon}
julia> accumulate(+, [1,2,3])
3-element Array{Int64,1}:
 1
 3
 6

julia> accumulate(*, [1,2,3])
3-element Array{Int64,1}:
 1
 2
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L710-L732}{\texttt{source}}



\begin{lstlisting}
accumulate(op, v0, A)
\end{lstlisting}

Like \texttt{accumulate}, but using a starting element \texttt{v0}. The first entry of the result will be \texttt{op(v0, first(A))}. For example:


\begin{minted}{jlcon}
julia> accumulate(+, 100, [1,2,3])
3-element Array{Int64,1}:
 101
 103
 106

julia> accumulate(min, 0, [1,2,-1])
3-element Array{Int64,1}:
  0
  0
 -1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L739-L758}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5431648933624159647}{} 
\hyperlink{5431648933624159647}{\texttt{Base.accumulate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
accumulate!(op, B, A, dim=1)
\end{lstlisting}

Cumulative operation \texttt{op} on \texttt{A} along a dimension, storing the result in \texttt{B}. The dimension defaults to 1. See also \hyperlink{4708508974842578384}{\texttt{accumulate}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L793-L798}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9956198945051267091}{} 
\hyperlink{9956198945051267091}{\texttt{Base.cumprod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumprod(A, dim=1)
\end{lstlisting}

Cumulative product along a dimension \texttt{dim} (defaults to 1). See also \hyperlink{17593173853905042752}{\texttt{cumprod!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> cumprod(a,1)
2×3 Array{Int64,2}:
 1   2   3
 4  10  18

julia> cumprod(a,2)
2×3 Array{Int64,2}:
 1   2    6
 4  20  120
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L676-L699}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17593173853905042752}{} 
\hyperlink{17593173853905042752}{\texttt{Base.cumprod!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumprod!(B, A, dim::Integer=1)
\end{lstlisting}

Cumulative product of \texttt{A} along a dimension, storing the result in \texttt{B}. The dimension defaults to 1. See also \hyperlink{9956198945051267091}{\texttt{cumprod}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L702-L707}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6230751605647278302}{} 
\hyperlink{6230751605647278302}{\texttt{Base.cumsum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumsum(A, dim=1)
\end{lstlisting}

Cumulative sum along a dimension \texttt{dim} (defaults to 1). See also \hyperlink{6880214806638058949}{\texttt{cumsum!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> cumsum(a,1)
2×3 Array{Int64,2}:
 1  2  3
 5  7  9

julia> cumsum(a,2)
2×3 Array{Int64,2}:
 1  3   6
 4  9  15
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L639-L662}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6880214806638058949}{} 
\hyperlink{6880214806638058949}{\texttt{Base.cumsum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumsum!(B, A, dim::Integer=1)
\end{lstlisting}

Cumulative sum of \texttt{A} along a dimension, storing the result in \texttt{B}. The dimension defaults to 1. See also \hyperlink{6230751605647278302}{\texttt{cumsum}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L668-L673}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3417346725052909886}{} 
\hyperlink{3417346725052909886}{\texttt{Base.cumsum\_kbn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumsum_kbn(A, [dim::Integer=1])
\end{lstlisting}

Cumulative sum along a dimension, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy. The dimension defaults to 1.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L240-L245}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4556138751333447681}{} 
\hyperlink{4556138751333447681}{\texttt{Base.LinAlg.diff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diff(A, [dim::Integer=1])
\end{lstlisting}

Finite difference operator of matrix or vector \texttt{A}. If \texttt{A} is a matrix, compute the finite difference over a dimension \texttt{dim} (default \texttt{1}).

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [2 4; 6 16]
2×2 Array{Int64,2}:
 2   4
 6  16

julia> diff(a,2)
2×1 Array{Int64,2}:
  2
 10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L251-L270}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2624058047704463332}{} 
\hyperlink{2624058047704463332}{\texttt{Base.LinAlg.gradient}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gradient(F::AbstractVector, [h::Real])
\end{lstlisting}

Compute differences along vector \texttt{F}, using \texttt{h} as the spacing between points. The default spacing is one.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [2,4,6,8];

julia> gradient(a)
4-element Array{Float64,1}:
 2.0
 2.0
 2.0
 2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L284-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12015243558136741941}{} 
\hyperlink{12015243558136741941}{\texttt{Base.rot180}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rot180(A)
\end{lstlisting}

Rotate matrix \texttt{A} 180 degrees.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rot180(a)
2×2 Array{Int64,2}:
 4  3
 2  1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L170-L187}{\texttt{source}}



\begin{lstlisting}
rot180(A, k)
\end{lstlisting}

Rotate matrix \texttt{A} 180 degrees an integer \texttt{k} number of times. If \texttt{k} is even, this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rot180(a,1)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rot180(a,2)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L272-L295}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3749585719821242612}{} 
\hyperlink{3749585719821242612}{\texttt{Base.rotl90}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rotl90(A)
\end{lstlisting}

Rotate matrix \texttt{A} left 90 degrees.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotl90(a)
2×2 Array{Int64,2}:
 2  4
 1  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L115-L132}{\texttt{source}}



\begin{lstlisting}
rotl90(A, k)
\end{lstlisting}

Rotate matrix \texttt{A} left 90 degrees an integer \texttt{k} number of times. If \texttt{k} is zero or a multiple of four, this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotl90(a,1)
2×2 Array{Int64,2}:
 2  4
 1  3

julia> rotl90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rotl90(a,3)
2×2 Array{Int64,2}:
 3  1
 4  2

julia> rotl90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L197-L230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4661209193738958579}{} 
\hyperlink{4661209193738958579}{\texttt{Base.rotr90}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rotr90(A)
\end{lstlisting}

Rotate matrix \texttt{A} right 90 degrees.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotr90(a)
2×2 Array{Int64,2}:
 3  1
 4  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L143-L160}{\texttt{source}}



\begin{lstlisting}
rotr90(A, k)
\end{lstlisting}

Rotate matrix \texttt{A} right 90 degrees an integer \texttt{k} number of times. If \texttt{k} is zero or a multiple of four, this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotr90(a,1)
2×2 Array{Int64,2}:
 3  1
 4  2

julia> rotr90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rotr90(a,3)
2×2 Array{Int64,2}:
 2  4
 1  3

julia> rotr90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L237-L270}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14026802499766415657}{} 
\hyperlink{14026802499766415657}{\texttt{Base.reducedim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reducedim(f, A, region[, v0])
\end{lstlisting}

Reduce 2-argument function \texttt{f} along dimensions of \texttt{A}. \texttt{region} is a vector specifying the dimensions to reduce, and \texttt{v0} is the initial value to use in the reductions. For \texttt{+}, \texttt{*}, \texttt{max} and \texttt{min} the \texttt{v0} argument is optional.

The associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop. See documentation for \hyperlink{2662613255229698805}{\texttt{reduce}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> reducedim(max, a, 2)
4×1 Array{Int64,2}:
 13
 14
 15
 16

julia> reducedim(max, a, 1)
1×4 Array{Int64,2}:
 4  8  12  16
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L245-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12702549823921106682}{} 
\hyperlink{12702549823921106682}{\texttt{Base.mapreducedim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapreducedim(f, op, A, region[, v0])
\end{lstlisting}

Evaluates to the same as \texttt{reducedim(op, map(f, A), region, f(v0))}, but is generally faster because the intermediate array is avoided.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> mapreducedim(isodd, *, a, 1)
1×4 Array{Bool,2}:
 false  false  false  false

julia> mapreducedim(isodd, |, a, 1, true)
1×4 Array{Bool,2}:
 true  true  true  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L216-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8678396932318499078}{} 
\hyperlink{8678396932318499078}{\texttt{Base.mapslices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapslices(f, A, dims)
\end{lstlisting}

Transform the given dimensions of array \texttt{A} using function \texttt{f}. \texttt{f} is called on each slice of \texttt{A} of the form \texttt{A[...,:,...,:,...]}. \texttt{dims} is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if \texttt{dims} is \texttt{[1,2]} and \texttt{A} is 4-dimensional, \texttt{f} is called on \texttt{A[:,:,i,j]} for all \texttt{i} and \texttt{j}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(collect(1:16),(2,2,2,2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> mapslices(sum, a, [1,2])
1×1×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 10

[:, :, 2, 1] =
 26

[:, :, 1, 2] =
 42

[:, :, 2, 2] =
 58
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1741-L1784}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16119876305082002277}{} 
\hyperlink{16119876305082002277}{\texttt{Base.sum\_kbn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sum_kbn(A)
\end{lstlisting}

Returns the sum of all elements of \texttt{A}, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L366-L371}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5964028120097016418}{}


\section{Combinatoria}


\hypertarget{7064355899480154040}{} 
\hyperlink{7064355899480154040}{\texttt{Base.Random.randperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randperm([rng=GLOBAL_RNG,] n::Integer)
\end{lstlisting}

Construct a random permutation of length \texttt{n}. The optional \texttt{rng} argument specifies a random number generator (see \hyperlink{4868036498049031913}{Random Numbers}). To randomly permute a arbitrary vector, see \hyperlink{7824264039428535103}{\texttt{shuffle}} or \hyperlink{17024043041131293003}{\texttt{shuffle!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randperm(rng, 4)
4-element Array{Int64,1}:
 2
 1
 4
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1666-L1686}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1395642908979377386}{} 
\hyperlink{1395642908979377386}{\texttt{Base.invperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
invperm(v)
\end{lstlisting}

Return the inverse permutation of \texttt{v}. If \texttt{B = A[v]}, then \texttt{A == B[invperm(v)]}.

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [2; 4; 3; 1];

julia> invperm(v)
4-element Array{Int64,1}:
 4
 1
 3
 2

julia> A = ['a','b','c','d'];

julia> B = A[v]
4-element Array{Char,1}:
 'b'
 'd'
 'c'
 'a'

julia> B[invperm(v)]
4-element Array{Char,1}:
 'a'
 'b'
 'c'
 'd'
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L182-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11897566016863942320}{} 
\hyperlink{11897566016863942320}{\texttt{Base.isperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isperm(v) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{v} is a valid permutation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isperm([1; 2])
true

julia> isperm([1; 3])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L59-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17157632988142440888}{} 
\hyperlink{17157632988142440888}{\texttt{Base.permute!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permute!(v, p)
\end{lstlisting}

Permute vector \texttt{v} in-place, according to permutation \texttt{p}. No checking is done to verify that \texttt{p} is a permutation.

To return a new permutation, use \texttt{v[p]}. Note that this is generally faster than \texttt{permute!(v,p)} for large vectors.

See also \hyperlink{9965226686125089381}{\texttt{ipermute!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1, 1, 3, 4];

julia> perm = [2, 4, 3, 1];

julia> permute!(A, perm);

julia> A
4-element Array{Int64,1}:
 1
 4
 3
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L107-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9965226686125089381}{} 
\hyperlink{9965226686125089381}{\texttt{Base.ipermute!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ipermute!(v, p)
\end{lstlisting}

Like \hyperlink{17157632988142440888}{\texttt{permute!}}, but the inverse of the given permutation is applied.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1, 1, 3, 4];

julia> perm = [2, 4, 3, 1];

julia> ipermute!(A, perm);

julia> A
4-element Array{Int64,1}:
 4
 1
 3
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L159-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10211237227429953257}{} 
\hyperlink{10211237227429953257}{\texttt{Base.Random.randcycle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randcycle([rng=GLOBAL_RNG,] n::Integer)
\end{lstlisting}

Construct a random cyclic permutation of length \texttt{n}. The optional \texttt{rng} argument specifies a random number generator, see \hyperlink{4868036498049031913}{Random Numbers}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randcycle(rng, 6)
6-element Array{Int64,1}:
 3
 5
 4
 6
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1707-L1727}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7824264039428535103}{} 
\hyperlink{7824264039428535103}{\texttt{Base.Random.shuffle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
shuffle([rng=GLOBAL_RNG,] v)
\end{lstlisting}

Return a randomly permuted copy of \texttt{v}. The optional \texttt{rng} argument specifies a random number generator (see \hyperlink{4868036498049031913}{Random Numbers}). To permute \texttt{v} in-place, see \hyperlink{17024043041131293003}{\texttt{shuffle!}}.  To obtain randomly permuted indices, see \hyperlink{7064355899480154040}{\texttt{randperm}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> shuffle(rng, collect(1:10))
10-element Array{Int64,1}:
  6
  1
 10
  2
  3
  9
  5
  7
  4
  8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1636-L1662}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17024043041131293003}{} 
\hyperlink{17024043041131293003}{\texttt{Base.Random.shuffle!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
shuffle!([rng=GLOBAL_RNG,] v)
\end{lstlisting}

In-place version of \hyperlink{7824264039428535103}{\texttt{shuffle}}: randomly permute the array \texttt{v} in-place, optionally supplying the random-number generator \texttt{rng}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> shuffle!(rng, collect(1:16))
16-element Array{Int64,1}:
  2
 15
  5
 14
  1
  9
 10
  6
 11
  3
 16
  7
  4
 12
  8
 13
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1591-L1621}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9938769063722328136}{} 
\hyperlink{9938769063722328136}{\texttt{Base.reverse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reverse(v [, start=1 [, stop=length(v) ]] )
\end{lstlisting}

Return a copy of \texttt{v} reversed from start to stop.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = collect(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> reverse(A)
5-element Array{Int64,1}:
 5
 4
 3
 2
 1

julia> reverse(A, 1, 4)
5-element Array{Int64,1}:
 4
 3
 2
 1
 5

julia> reverse(A, 3, 5)
5-element Array{Int64,1}:
 1
 2
 5
 4
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L700-L739}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16812685153025781176}{} 
\hyperlink{16812685153025781176}{\texttt{Base.reverseind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reverseind(v, i)
\end{lstlisting}

Given an index \texttt{i} in \texttt{reverse(v)}, return the corresponding index in \texttt{v} so that \texttt{v[reverseind(v,i)] == reverse(v)[i]}. (This can be nontrivial in the case where \texttt{v} is a Unicode string.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2440-L2446}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9702108366803637048}{} 
\hyperlink{9702108366803637048}{\texttt{Base.reverse!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reverse!(v [, start=1 [, stop=length(v) ]]) -> v
\end{lstlisting}

In-place version of \hyperlink{9938769063722328136}{\texttt{reverse}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L742-L746}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11812832820787663359}{}


\section{BitArrays}



\texttt{BitArray}s son matrices booleanas {\textquotedbl}compactas{\textquotedbl} eficientes en el uso del espacio, que almacenan un bit por valor booleano. Se pueden usar de forma similar a los arrays \texttt{Array\{Bool\}} (que almacenan un byte por valor booleano), y se pueden convertir a/desde este último a través de \texttt{Array(bitarray)} y \texttt{BitArray(array)}, respectivamente.


\hypertarget{2954314498186399761}{} 
\hyperlink{2954314498186399761}{\texttt{Base.flipbits!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flipbits!(B::BitArray{N}) -> BitArray{N}
\end{lstlisting}

Performs a bitwise not operation on \texttt{B}. See \hyperlink{2433030275488323500}{\texttt{{\textasciitilde}}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = trues(2,2)
2×2 BitArray{2}:
 true  true
 true  true

julia> flipbits!(A)
2×2 BitArray{2}:
 false  false
 false  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1143-L1160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8834180677602757313}{} 
\hyperlink{8834180677602757313}{\texttt{Base.rol!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rol!(dest::BitVector, src::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a left rotation operation on \texttt{src} and puts the result into \texttt{dest}. \texttt{i} controls how far to rotate the bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1468-L1473}{\texttt{source}}



\begin{lstlisting}
rol!(B::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a left rotation operation in-place on \texttt{B}. \texttt{i} controls how far to rotate the bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1486-L1491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5525630662564449940}{} 
\hyperlink{5525630662564449940}{\texttt{Base.rol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rol(B::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a left rotation operation, returning a new \texttt{BitVector}. \texttt{i} controls how far to rotate the bits. See also \hyperlink{8834180677602757313}{\texttt{rol!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = BitArray([true, true, false, false, true])
5-element BitArray{1}:
  true
  true
 false
 false
  true

julia> rol(A,1)
5-element BitArray{1}:
  true
 false
 false
  true
  true

julia> rol(A,2)
5-element BitArray{1}:
 false
 false
  true
  true
  true

julia> rol(A,5)
5-element BitArray{1}:
  true
  true
 false
 false
  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1494-L1535}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9497865068299389753}{} 
\hyperlink{9497865068299389753}{\texttt{Base.ror!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ror!(dest::BitVector, src::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a right rotation operation on \texttt{src} and puts the result into \texttt{dest}. \texttt{i} controls how far to rotate the bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1538-L1543}{\texttt{source}}



\begin{lstlisting}
ror!(B::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a right rotation operation in-place on \texttt{B}. \texttt{i} controls how far to rotate the bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1556-L1561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14416357953528155070}{} 
\hyperlink{14416357953528155070}{\texttt{Base.ror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ror(B::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a right rotation operation on \texttt{B}, returning a new \texttt{BitVector}. \texttt{i} controls how far to rotate the bits. See also \hyperlink{9497865068299389753}{\texttt{ror!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = BitArray([true, true, false, false, true])
5-element BitArray{1}:
  true
  true
 false
 false
  true

julia> ror(A,1)
5-element BitArray{1}:
  true
  true
  true
 false
 false

julia> ror(A,2)
5-element BitArray{1}:
 false
  true
  true
  true
 false

julia> ror(A,5)
5-element BitArray{1}:
  true
  true
 false
 false
  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1564-L1605}{\texttt{source}}


\end{adjustwidth}

\hypertarget{2402954669804328212}{}


\section{Matrices y Vectores \emph{Sparse}}



Los vectores y las matrices \emph{sparse} soportan ampliamente el mismo conjunto de operaciones que sus contrapartidas densas. las siguientes funcioens son específicas para arrays \emph{sparse}.


\hypertarget{17278185509996384677}{} 
\hyperlink{17278185509996384677}{\texttt{Base.SparseArrays.SparseVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}
\end{lstlisting}

Vector type for storing sparse vectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L12-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14881587545161853413}{} 
\hyperlink{14881587545161853413}{\texttt{Base.SparseArrays.SparseMatrixCSC}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}
\end{lstlisting}

Matrix type for storing sparse matrices in the \hyperlink{4438718230137239554}{Compressed Sparse Column} format.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L8-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6442735913986985800}{} 
\hyperlink{6442735913986985800}{\texttt{Base.SparseArrays.sparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sparse(A)
\end{lstlisting}

Convert an AbstractMatrix \texttt{A} into a sparse matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = eye(3)
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> sparse(A)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L386-L405}{\texttt{source}}



\begin{lstlisting}
sparse(I, J, V,[ m, n, combine])
\end{lstlisting}

Create a sparse matrix \texttt{S} of dimensions \texttt{m x n} such that \texttt{S[I[k], J[k]] = V[k]}. The \texttt{combine} function is used to combine duplicates. If \texttt{m} and \texttt{n} are not specified, they are set to \texttt{maximum(I)} and \texttt{maximum(J)} respectively. If the \texttt{combine} function is not supplied, \texttt{combine} defaults to \texttt{+} unless the elements of \texttt{V} are Booleans in which case \texttt{combine} defaults to \texttt{|}. All elements of \texttt{I} must satisfy \texttt{1 <= I[k] <= m}, and all elements of \texttt{J} must satisfy \texttt{1 <= J[k] <= n}. Numerical zeros in (\texttt{I}, \texttt{J}, \texttt{V}) are retained as structural nonzeros; to drop numerical zeros, use \hyperlink{4343590179532251994}{\texttt{dropzeros!}}.

For additional documentation and an expert driver, see \texttt{Base.SparseArrays.sparse!}.

\textbf{Example}


\begin{minted}{jlcon}
julia> Is = [1; 2; 3];

julia> Js = [1; 2; 3];

julia> Vs = [1; 2; 3];

julia> sparse(Is, Js, Vs)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 2]  =  2
  [3, 3]  =  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L459-L486}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18161940743946340171}{} 
\hyperlink{18161940743946340171}{\texttt{Base.SparseArrays.sparsevec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sparsevec(I, V, [m, combine])
\end{lstlisting}

Create a sparse vector \texttt{S} of length \texttt{m} such that \texttt{S[I[k]] = V[k]}. Duplicates are combined using the \texttt{combine} function, which defaults to \texttt{+} if no \texttt{combine} argument is provided, unless the elements of \texttt{V} are Booleans in which case \texttt{combine} defaults to \texttt{|}.


\begin{minted}{jlcon}
julia> II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];

julia> sparsevec(II, V)
5-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  0.5
  [5]  =  0.2

julia> sparsevec(II, V, 8, -)
8-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  -0.1
  [5]  =  0.2

julia> sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])
3-element SparseVector{Bool,Int64} with 3 stored entries:
  [1]  =  true
  [2]  =  false
  [3]  =  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L103-L132}{\texttt{source}}



\begin{lstlisting}
sparsevec(d::Dict, [m])
\end{lstlisting}

Create a sparse vector of length \texttt{m} where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.


\begin{minted}{jlcon}
julia> sparsevec(Dict(1 => 3, 2 => 2))
2-element SparseVector{Int64,Int64} with 2 stored entries:
  [1]  =  3
  [2]  =  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L178-L190}{\texttt{source}}



\begin{lstlisting}
sparsevec(A)
\end{lstlisting}

Convert a vector \texttt{A} into a sparse vector of length \texttt{m}.

\textbf{Example}


\begin{minted}{jlcon}
julia> sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])
6-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  2.0
  [5]  =  3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L309-L322}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4718940244439103334}{} 
\hyperlink{4718940244439103334}{\texttt{Base.SparseArrays.issparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issparse(S)
\end{lstlisting}

Returns \texttt{true} if \texttt{S} is sparse, and \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/abstractsparse.jl#L8-L12}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6442668105237896007}{} 
\hyperlink{6442668105237896007}{\texttt{Base.full}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
full(S)
\end{lstlisting}

Convert a sparse matrix or vector \texttt{S} into a dense matrix or vector.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia> full(A)
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L355-L374}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6318543341724753931}{} 
\hyperlink{6318543341724753931}{\texttt{Base.SparseArrays.nnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nnz(A)
\end{lstlisting}

Returns the number of stored (filled) elements in a sparse array.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia> nnz(A)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L36-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7195216781795987163}{} 
\hyperlink{7195216781795987163}{\texttt{Base.SparseArrays.spzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
spzeros([type,]m[,n])
\end{lstlisting}

Create a sparse vector of length \texttt{m} or sparse matrix of size \texttt{m x n}. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to \hyperlink{5027751419500983000}{\texttt{Float64}} if not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> spzeros(3, 3)
3×3 SparseMatrixCSC{Float64,Int64} with 0 stored entries

julia> spzeros(Float32, 4)
4-element SparseVector{Float32,Int64} with 0 stored entries
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1435-L1451}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8792030753977135320}{} 
\hyperlink{8792030753977135320}{\texttt{Base.SparseArrays.spones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
spones(S)
\end{lstlisting}

Create a sparse array with the same structure as that of \texttt{S}, but with every nonzero element having the value \texttt{1.0}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [4, 1]  =  2.0
  [1, 2]  =  5.0
  [3, 3]  =  3.0
  [2, 4]  =  4.0

julia> spones(A)
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [4, 1]  =  1.0
  [1, 2]  =  1.0
  [3, 3]  =  1.0
  [2, 4]  =  1.0
\end{minted}

Note the difference from \hyperlink{15336931858862742282}{\texttt{speye}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1407-L1431}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15336931858862742282}{} 
\hyperlink{15336931858862742282}{\texttt{Base.SparseArrays.speye}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
speye([type,]m[,n])
\end{lstlisting}

Create a sparse identity matrix of size \texttt{m x m}. When \texttt{n} is supplied, create a sparse identity matrix of size \texttt{m x n}. The type defaults to \hyperlink{5027751419500983000}{\texttt{Float64}} if not specified.

\texttt{sparse(I, m, n)} is equivalent to \texttt{speye(Int, m, n)}, and \texttt{sparse(α*I, m, n)} can be used to efficiently create a sparse multiple \texttt{α} of the identity matrix.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1494-L1504}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11934860426109731956}{} 
\hyperlink{11934860426109731956}{\texttt{Base.SparseArrays.speye}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
speye(S)
\end{lstlisting}

Create a sparse identity matrix with the same size as \texttt{S}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [4, 1]  =  2.0
  [1, 2]  =  5.0
  [3, 3]  =  3.0
  [2, 4]  =  4.0

julia> speye(A)
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  1.0
\end{minted}

Note the difference from \hyperlink{8792030753977135320}{\texttt{spones}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1467-L1490}{\texttt{source}}



\begin{lstlisting}
speye([type,]m[,n])
\end{lstlisting}

Create a sparse identity matrix of size \texttt{m x m}. When \texttt{n} is supplied, create a sparse identity matrix of size \texttt{m x n}. The type defaults to \hyperlink{5027751419500983000}{\texttt{Float64}} if not specified.

\texttt{sparse(I, m, n)} is equivalent to \texttt{speye(Int, m, n)}, and \texttt{sparse(α*I, m, n)} can be used to efficiently create a sparse multiple \texttt{α} of the identity matrix.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1494-L1504}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1081045183735911932}{} 
\hyperlink{1081045183735911932}{\texttt{Base.SparseArrays.spdiagm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
spdiagm(B, d[, m, n])
\end{lstlisting}

Construct a sparse diagonal matrix. \texttt{B} is a tuple of vectors containing the diagonals and \texttt{d} is a tuple containing the positions of the diagonals. In the case the input contains only one diagonal, \texttt{B} can be a vector (instead of a tuple) and \texttt{d} can be the diagonal position (instead of a tuple), defaulting to 0 (diagonal). Optionally, \texttt{m} and \texttt{n} specify the size of the resulting sparse matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> spdiagm(([1,2,3,4],[4,3,2,1]),(-1,1))
5×5 SparseMatrixCSC{Int64,Int64} with 8 stored entries:
  [2, 1]  =  1
  [1, 2]  =  4
  [3, 2]  =  2
  [2, 3]  =  3
  [4, 3]  =  3
  [3, 4]  =  2
  [5, 4]  =  4
  [4, 5]  =  1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L3288-L3310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7938626005548874744}{} 
\hyperlink{7938626005548874744}{\texttt{Base.SparseArrays.sprand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])
\end{lstlisting}

Create a random length \texttt{m} sparse vector or \texttt{m} by \texttt{n} sparse matrix, in which the probability of any element being nonzero is independently given by \texttt{p} (and hence the mean density of nonzeros is also exactly \texttt{p}). Nonzero values are sampled from the distribution specified by \texttt{rfn} and have the type \texttt{type}. The uniform distribution is used in case \texttt{rfn} is not specified. The optional \texttt{rng} argument specifies a random number generator, see \hyperlink{4868036498049031913}{Random Numbers}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> sprand(rng, Bool, 2, 2, 0.5)
2×2 SparseMatrixCSC{Bool,Int64} with 2 stored entries:
  [1, 1]  =  true
  [2, 1]  =  true

julia> sprand(rng, Float64, 3, 0.75)
3-element SparseVector{Float64,Int64} with 1 stored entry:
  [3]  =  0.298614
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1330-L1353}{\texttt{source}}


\end{adjustwidth}
\hypertarget{641245889672681934}{} 
\hyperlink{641245889672681934}{\texttt{Base.SparseArrays.sprandn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sprandn([rng], m[,n],p::AbstractFloat)
\end{lstlisting}

Create a random sparse vector of length \texttt{m} or sparse matrix of size \texttt{m} by \texttt{n} with the specified (independent) probability \texttt{p} of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional \texttt{rng} argument specifies a random number generator, see \hyperlink{4868036498049031913}{Random Numbers}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> sprandn(rng, 2, 2, 0.75)
2×2 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  0.532813
  [2, 1]  =  -0.271735
  [2, 2]  =  0.502334
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1384-L1402}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15883692643401464977}{} 
\hyperlink{15883692643401464977}{\texttt{Base.SparseArrays.nonzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nonzeros(A)
\end{lstlisting}

Return a vector of the structural nonzero values in sparse array \texttt{A}. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of \texttt{A}, and any modifications to the returned vector will mutate \texttt{A} as well. See \hyperlink{1153295106359630489}{\texttt{rowvals}} and \hyperlink{6394537172532841781}{\texttt{nzrange}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia> nonzeros(A)
3-element Array{Float64,1}:
 1.0
 1.0
 1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L57-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1153295106359630489}{} 
\hyperlink{1153295106359630489}{\texttt{Base.SparseArrays.rowvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rowvals(A::SparseMatrixCSC)
\end{lstlisting}

Return a vector of the row indices of \texttt{A}. Any modifications to the returned vector will mutate \texttt{A} as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also \hyperlink{15883692643401464977}{\texttt{nonzeros}} and \hyperlink{6394537172532841781}{\texttt{nzrange}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia> rowvals(A)
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L83-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6394537172532841781}{} 
\hyperlink{6394537172532841781}{\texttt{Base.SparseArrays.nzrange}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nzrange(A::SparseMatrixCSC, col::Integer)
\end{lstlisting}

Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with \hyperlink{15883692643401464977}{\texttt{nonzeros}} and \hyperlink{1153295106359630489}{\texttt{rowvals}}, this allows for convenient iterating over a sparse matrix :


\begin{lstlisting}
A = sparse(I,J,V)
rows = rowvals(A)
vals = nonzeros(A)
m, n = size(A)
for i = 1:n
   for j in nzrange(A, i)
      row = rows[j]
      val = vals[j]
      # perform sparse wizardry...
   end
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L108-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4343590179532251994}{} 
\hyperlink{4343590179532251994}{\texttt{Base.SparseArrays.dropzeros!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dropzeros!(A::SparseMatrixCSC, trim::Bool = true)
\end{lstlisting}

Removes stored numerical zeros from \texttt{A}, optionally trimming resulting excess space from \texttt{A.rowval} and \texttt{A.nzval} when \texttt{trim} is \texttt{true}.

For an out-of-place version, see \hyperlink{16980472205632865276}{\texttt{dropzeros}}. For algorithmic information, see \texttt{fkeep!}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1199-L1207}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16980472205632865276}{} 
\hyperlink{16980472205632865276}{\texttt{Base.SparseArrays.dropzeros}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dropzeros(A::SparseMatrixCSC, trim::Bool = true)
\end{lstlisting}

Generates a copy of \texttt{A} and removes stored numerical zeros from that copy, optionally trimming excess space from the result{\textquotesingle}s \texttt{rowval} and \texttt{nzval} arrays when \texttt{trim} is \texttt{true}.

For an in-place version and algorithmic information, see \hyperlink{4343590179532251994}{\texttt{dropzeros!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  0.0
  [3, 3]  =  1.0

julia> dropzeros(A)
3×3 SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  1.0
  [3, 3]  =  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1209-L1230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3702526137302924148}{} 
\hyperlink{3702526137302924148}{\texttt{Base.SparseArrays.dropzeros!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dropzeros!(x::SparseVector, trim::Bool = true)
\end{lstlisting}

Removes stored numerical zeros from \texttt{x}, optionally trimming resulting excess space from \texttt{x.nzind} and \texttt{x.nzval} when \texttt{trim} is \texttt{true}.

For an out-of-place version, see \hyperlink{16980472205632865276}{\texttt{dropzeros}}. For algorithmic information, see \texttt{fkeep!}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L1921-L1929}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18261178615862576834}{} 
\hyperlink{18261178615862576834}{\texttt{Base.SparseArrays.dropzeros}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dropzeros(x::SparseVector, trim::Bool = true)
\end{lstlisting}

Generates a copy of \texttt{x} and removes numerical zeros from that copy, optionally trimming excess space from the result{\textquotesingle}s \texttt{nzind} and \texttt{nzval} arrays when \texttt{trim} is \texttt{true}.

For an in-place version and algorithmic information, see \hyperlink{4343590179532251994}{\texttt{dropzeros!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  0.0
  [3]  =  1.0

julia> dropzeros(A)
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L1931-L1952}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1610845759689502707}{} 
\hyperlink{1610845759689502707}{\texttt{Base.SparseArrays.permute}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permute{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},
    q::AbstractVector{<:Integer})
\end{lstlisting}

Bilaterally permute \texttt{A}, returning \texttt{PAQ} (\texttt{A[p,q]}). Column-permutation \texttt{q}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s column count (\texttt{length(q) == A.n}). Row-permutation \texttt{p}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s row count (\texttt{length(p) == A.m}).

For expert drivers and additional information, see \hyperlink{17157632988142440888}{\texttt{permute!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = spdiagm([1, 2, 3, 4], 0, 4, 4) + spdiagm([5, 6, 7], 1, 4, 4)
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [1, 1]  =  1
  [1, 2]  =  5
  [2, 2]  =  2
  [2, 3]  =  6
  [3, 3]  =  3
  [3, 4]  =  7
  [4, 4]  =  4

julia> permute(A, [4, 3, 2, 1], [1, 2, 3, 4])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [4, 1]  =  1
  [3, 2]  =  2
  [4, 2]  =  5
  [2, 3]  =  3
  [3, 3]  =  6
  [1, 4]  =  4
  [2, 4]  =  7

julia> permute(A, [1, 2, 3, 4], [4, 3, 2, 1])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [3, 1]  =  7
  [4, 1]  =  4
  [2, 2]  =  6
  [3, 2]  =  3
  [1, 3]  =  5
  [2, 3]  =  2
  [1, 4]  =  1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1060-L1102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16133978171333546819}{} 
\hyperlink{16133978171333546819}{\texttt{Base.permute!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permute!{Tv,Ti}(X::SparseMatrixCSC{Tv,Ti}, A::SparseMatrixCSC{Tv,Ti},
    p::AbstractVector{<:Integer}, q::AbstractVector{<:Integer}[, C::SparseMatrixCSC{Tv,Ti}])
\end{lstlisting}

Bilaterally permute \texttt{A}, storing result \texttt{PAQ} (\texttt{A[p,q]}) in \texttt{X}. Stores intermediate result \texttt{(AQ){\textasciicircum}T} (\texttt{transpose(A[:,q])}) in optional argument \texttt{C} if present. Requires that none of \texttt{X}, \texttt{A}, and, if present, \texttt{C} alias each other; to store result \texttt{PAQ} back into \texttt{A}, use the following method lacking \texttt{X}:


\begin{lstlisting}
permute!{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},
    q::AbstractVector{<:Integer}[, C::SparseMatrixCSC{Tv,Ti}[, workcolptr::Vector{Ti}]])
\end{lstlisting}

\texttt{X}{\textquotesingle}s dimensions must match those of \texttt{A} (\texttt{X.m == A.m} and \texttt{X.n == A.n}), and \texttt{X} must have enough storage to accommodate all allocated entries in \texttt{A} (\texttt{length(X.rowval) >= nnz(A)} and \texttt{length(X.nzval) >= nnz(A)}). Column-permutation \texttt{q}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s column count (\texttt{length(q) == A.n}). Row-permutation \texttt{p}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s row count (\texttt{length(p) == A.m}).

\texttt{C}{\textquotesingle}s dimensions must match those of \texttt{transpose(A)} (\texttt{C.m == A.n} and \texttt{C.n == A.m}), and \texttt{C} must have enough storage to accommodate all allocated entries in \texttt{A} (\texttt{length(C.rowval) >= nnz(A)} and \texttt{length(C.nzval) >= nnz(A)}).

For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods \texttt{unchecked\_noalias\_permute!} and \texttt{unchecked\_aliasing\_permute!}.

See also: \hyperlink{1610845759689502707}{\texttt{permute}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L990-L1017}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10924396624761136101}{}


\chapter{Tareas y Computación Paralela}



\hypertarget{10718672723757154799}{}


\section{Tareas}


\hypertarget{7131243650304654155}{} 
\hyperlink{7131243650304654155}{\texttt{Core.Task}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Task(func)
\end{lstlisting}

Create a \texttt{Task} (i.e. coroutine) to execute the given function (which must be callable with no arguments). The task exits when this function returns.

\textbf{Example}


\begin{minted}{jlcon}
julia> a() = det(rand(1000, 1000));

julia> b = Task(a);
\end{minted}

In this example, \texttt{b} is a runnable \texttt{Task} that hasn{\textquotesingle}t started yet.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1640-L1654}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12929971401717674174}{} 
\hyperlink{12929971401717674174}{\texttt{Base.current\_task}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
current_task()
\end{lstlisting}

Get the currently running \hyperlink{7131243650304654155}{\texttt{Task}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L83-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7432450399685996831}{} 
\hyperlink{7432450399685996831}{\texttt{Base.istaskdone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istaskdone(t::Task) -> Bool
\end{lstlisting}

Determine whether a task has exited.


\begin{minted}{jlcon}
julia> a2() = det(rand(1000, 1000));

julia> b = Task(a2);

julia> istaskdone(b)
false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L90-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{188637489024602838}{} 
\hyperlink{188637489024602838}{\texttt{Base.istaskstarted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istaskstarted(t::Task) -> Bool
\end{lstlisting}

Determine whether a task has started executing.


\begin{minted}{jlcon}
julia> a3() = det(rand(1000, 1000));

julia> b = Task(a3);

julia> istaskstarted(b)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L113-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13455314829114364187}{} 
\hyperlink{13455314829114364187}{\texttt{Base.yield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
yield()
\end{lstlisting}

Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L143-L149}{\texttt{source}}



\begin{lstlisting}
yield(t::Task, arg = nothing)
\end{lstlisting}

A fast, unfair-scheduling version of \texttt{schedule(t, arg); yield()} which immediately yields to \texttt{t} before calling the scheduler.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L152-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4920987536368477483}{} 
\hyperlink{4920987536368477483}{\texttt{Base.yieldto}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
yieldto(t::Task, arg = nothing)
\end{lstlisting}

Switch to the given task. The first time a task is switched to, the task{\textquotesingle}s function is called with no arguments. On subsequent switches, \texttt{arg} is returned from the task{\textquotesingle}s last call to \texttt{yieldto}. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L165-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8292907206163344794}{} 
\hyperlink{8292907206163344794}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
task_local_storage(key)
\end{lstlisting}

Look up the value of a key in the current task{\textquotesingle}s task-local storage.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L141-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2485476355246980354}{} 
\hyperlink{2485476355246980354}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
task_local_storage(key, value)
\end{lstlisting}

Assign a value to a key in the current task{\textquotesingle}s task-local storage.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L148-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18380692261281200127}{} 
\hyperlink{18380692261281200127}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
task_local_storage(body, key, value)
\end{lstlisting}

Call the function \texttt{body} with a modified task-local storage, in which \texttt{value} is assigned to \texttt{key}; the previous value of \texttt{key}, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L155-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{286351753995469758}{} 
\hyperlink{286351753995469758}{\texttt{Base.Condition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Condition()
\end{lstlisting}

Create an edge-triggered event source that tasks can wait for. Tasks that call \hyperlink{13761789780433862250}{\texttt{wait}} on a \texttt{Condition} are suspended and queued. Tasks are woken up when \hyperlink{2865179286002578885}{\texttt{notify}} is later called on the \texttt{Condition}. Edge triggering means that only tasks waiting at the time \hyperlink{2865179286002578885}{\texttt{notify}} is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The \hyperlink{12548845729684045604}{\texttt{Channel}} type does this, and so can be used for level-triggered events.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L5-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2865179286002578885}{} 
\hyperlink{2865179286002578885}{\texttt{Base.notify}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
notify(condition, val=nothing; all=true, error=false)
\end{lstlisting}

Wake up tasks waiting for a condition, passing them \texttt{val}. If \texttt{all} is \texttt{true} (the default), all waiting tasks are woken, otherwise only one is. If \texttt{error} is \texttt{true}, the passed value is raised as an exception in the woken tasks.

Returns the count of tasks woken up. Returns 0 if no tasks are waiting on \texttt{condition}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L34-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9185853093207176818}{} 
\hyperlink{9185853093207176818}{\texttt{Base.schedule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
schedule(t::Task, [val]; error=false)
\end{lstlisting}

Add a \hyperlink{7131243650304654155}{\texttt{Task}} to the scheduler{\textquotesingle}s queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as \hyperlink{13761789780433862250}{\texttt{wait}}.

If a second argument \texttt{val} is provided, it will be passed to the task (via the return value of \hyperlink{4920987536368477483}{\texttt{yieldto}}) when it runs again. If \texttt{error} is \texttt{true}, the value is raised as an exception in the woken task.


\begin{minted}{jlcon}
julia> a5() = det(rand(1000, 1000));

julia> b = Task(a5);

julia> istaskstarted(b)
false

julia> schedule(b);

julia> yield();

julia> istaskstarted(b)
true

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L91-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15186286520310132839}{} 
\hyperlink{15186286520310132839}{\texttt{Base.@schedule}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@schedule
\end{lstlisting}

Wrap an expression in a \hyperlink{7131243650304654155}{\texttt{Task}} and add it to the local machine{\textquotesingle}s scheduler queue. Similar to \hyperlink{10770947021537241619}{\texttt{@async}} except that an enclosing \texttt{@sync} does NOT wait for tasks started with an \texttt{@schedule}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L65-L71}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16142823989571622868}{} 
\hyperlink{16142823989571622868}{\texttt{Base.@task}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@task
\end{lstlisting}

Wrap an expression in a \hyperlink{7131243650304654155}{\texttt{Task}} without executing it, and return the \hyperlink{7131243650304654155}{\texttt{Task}}. This only creates a task, and does not run it.


\begin{minted}{jlcon}
julia> a1() = det(rand(1000, 1000));

julia> b = @task a1();

julia> istaskstarted(b)
false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L57-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3231475347583891391}{} 
\hyperlink{3231475347583891391}{\texttt{Base.sleep}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sleep(seconds)
\end{lstlisting}

Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of \texttt{0.001}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L403-L408}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12548845729684045604}{} 
\hyperlink{12548845729684045604}{\texttt{Base.Channel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Channel{T}(sz::Int)
\end{lstlisting}

Constructs a \texttt{Channel} with an internal buffer that can hold a maximum of \texttt{sz} objects of type \texttt{T}. \hyperlink{12719543094136814100}{\texttt{put!}} calls on a full channel block until an object is removed with \hyperlink{4360129174058888556}{\texttt{take!}}.

\texttt{Channel(0)} constructs an unbuffered channel. \texttt{put!} blocks until a matching \texttt{take!} is called. And vice-versa.

Other constructors:

\begin{itemize}
\item \texttt{Channel(Inf)}: equivalent to \texttt{Channel\{Any\}(typemax(Int))}


\item \texttt{Channel(sz)}: equivalent to \texttt{Channel\{Any\}(sz)}

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L5-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12719543094136814100}{} 
\hyperlink{12719543094136814100}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
put!(c::Channel, v)
\end{lstlisting}

Appends an item \texttt{v} to the channel \texttt{c}. Blocks if the channel is full.

For unbuffered channels, blocks until a \hyperlink{4360129174058888556}{\texttt{take!}} is performed by a different task.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L252-L259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6608633734376348608}{} 
\hyperlink{6608633734376348608}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
take!(c::Channel)
\end{lstlisting}

Removes and returns a value from a \hyperlink{12548845729684045604}{\texttt{Channel}}. Blocks until data is available.

For unbuffered channels, blocks until a \hyperlink{12719543094136814100}{\texttt{put!}} is performed by a different task.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L309-L316}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15888554370655089980}{} 
\hyperlink{15888554370655089980}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isready(c::Channel)
\end{lstlisting}

Determine whether a \hyperlink{12548845729684045604}{\texttt{Channel}} has a value stored to it. Returns immediately, does not block.

For unbuffered channels returns \texttt{true} if there are tasks waiting on a \hyperlink{12719543094136814100}{\texttt{put!}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L348-L356}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7098010828229464277}{} 
\hyperlink{7098010828229464277}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch(c::Channel)
\end{lstlisting}

Waits for and gets the first available item from the channel. Does not remove the item. \texttt{fetch} is unsupported on an unbuffered (0-size) channel.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L295-L300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9979143087438478792}{} 
\hyperlink{9979143087438478792}{\texttt{Base.close}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
close(c::Channel)
\end{lstlisting}

Closes a channel. An exception is thrown by:

\begin{itemize}
\item \hyperlink{12719543094136814100}{\texttt{put!}} on a closed channel.


\item \hyperlink{4360129174058888556}{\texttt{take!}} and \hyperlink{7098010828229464277}{\texttt{fetch}} on an empty, closed channel.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L135-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6778875052923307054}{} 
\hyperlink{6778875052923307054}{\texttt{Base.bind}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bind(chnl::Channel, task::Task)
\end{lstlisting}

Associates the lifetime of \texttt{chnl} with a task. Channel \texttt{chnl} is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on \texttt{chnl}.

The \texttt{chnl} object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.

When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @schedule foreach(i->put!(c, i), 1:4);

julia> bind(c,task);

julia> for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia> isopen(c)
false
\end{minted}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @schedule (put!(c,1);error("foo"));

julia> bind(c,task);

julia> take!(c)
1

julia> put!(c,1);
ERROR: foo
Stacktrace:
 [1] check_channel_state(::Channel{Any}) at ./channels.jl:131
 [2] put!(::Channel{Any}, ::Int64) at ./channels.jl:261
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L151-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14148755671315265621}{} 
\hyperlink{14148755671315265621}{\texttt{Base.asyncmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asyncmap(f, c...; ntasks=0, batch_size=nothing)
\end{lstlisting}

Uses multiple concurrent tasks to map \texttt{f} over a collection (or multiple equal length collections). For multiple collection arguments, \texttt{f} is applied elementwise.

\texttt{ntasks} specifies the number of tasks to run concurrently. Depending on the length of the collections, if \texttt{ntasks} is unspecified, up to 100 tasks will be used for concurrent mapping.

\texttt{ntasks} can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of \texttt{ntasks\_func()} is less than the current number of tasks.

If \texttt{batch\_size} is specified, the collection is processed in batch mode. \texttt{f} must then be a function that must accept a \texttt{Vector} of argument tuples and must return a vector of results. The input vector will have a length of \texttt{batch\_size} or less.

The following examples highlight execution in different tasks by returning the \texttt{object\_id} of the tasks in which the mapping function is executed.

First, with \texttt{ntasks} undefined, each element is processed in a different task.


\begin{lstlisting}
julia> tskoid() = object_id(current_task());

julia> asyncmap(x->tskoid(), 1:5)
5-element Array{UInt64,1}:
 0x6e15e66c75c75853
 0x440f8819a1baa682
 0x9fb3eeadd0c83985
 0xebd3e35fe90d4050
 0x29efc93edce2b961

julia> length(unique(asyncmap(x->tskoid(), 1:5)))
5
\end{lstlisting}

With \texttt{ntasks=2} all elements are processed in 2 tasks.


\begin{lstlisting}
julia> asyncmap(x->tskoid(), 1:5; ntasks=2)
5-element Array{UInt64,1}:
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94

julia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))
2
\end{lstlisting}

With \texttt{batch\_size} defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. \texttt{map} is used in the modified mapping function to achieve this.


\begin{lstlisting}
julia> batch_func(input) = map(x->string("args_tuple: ", x, ", element_val: ", x[1], ", task: ", tskoid()), input)
batch_func (generic function with 1 method)

julia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)
5-element Array{String,1}:
 "args_tuple: (1,), element_val: 1, task: 9118321258196414413"
 "args_tuple: (2,), element_val: 2, task: 4904288162898683522"
 "args_tuple: (3,), element_val: 3, task: 9118321258196414413"
 "args_tuple: (4,), element_val: 4, task: 4904288162898683522"
 "args_tuple: (5,), element_val: 5, task: 9118321258196414413"
\end{lstlisting}

\begin{quote}
\textbf{Note}

Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, \texttt{ayncmap} is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/asyncmap.jl#L5-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16469851777080200085}{} 
\hyperlink{16469851777080200085}{\texttt{Base.asyncmap!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)
\end{lstlisting}

Like \hyperlink{14148755671315265621}{\texttt{asyncmap()}}, but stores output in \texttt{results} rather than returning a collection.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/asyncmap.jl#L415-L420}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9206699468753153912}{}


\section{Soporte General a la Computación Paralela}


\hypertarget{1448678099847390}{} 
\hyperlink{1448678099847390}{\texttt{Base.Distributed.addprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers
\end{lstlisting}

Launches worker processes via the specified cluster manager.

For example, Beowulf clusters are supported via a custom cluster manager implemented in the package \texttt{ClusterManagers.jl}.

The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable \texttt{JULIA\_WORKER\_TIMEOUT} in the worker process{\textquotesingle}s environment. Relevant only when using TCP/IP as transport.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L302-L313}{\texttt{source}}



\begin{lstlisting}
addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers
\end{lstlisting}

Add processes on remote machines via SSH. Requires \texttt{julia} to be installed in the same location on each node, or to be available via a shared file system.

\texttt{machines} is a vector of machine specifications. Workers are started for each specification.

A machine specification is either a string \texttt{machine\_spec} or a tuple - \texttt{(machine\_spec, count)}.

\texttt{machine\_spec} is a string of the form \texttt{[user@]host[:port] [bind\_addr[:port]]}. \texttt{user} defaults to current user, \texttt{port} to the standard ssh port. If \texttt{[bind\_addr[:port]]} is specified, other workers will connect to this worker at the specified \texttt{bind\_addr} and \texttt{port}.

\texttt{count} is the number of workers to be launched on the specified host. If specified as \texttt{:auto} it will launch as many workers as the number of cores on the specific host.

Keyword arguments:

\begin{itemize}
\item \texttt{tunnel}: if \texttt{true} then SSH tunneling will be used to connect to the worker from the master process. Default is \texttt{false}.


\item \texttt{sshflags}: specifies additional ssh options, e.g. \texttt{sshflags=`-i /home/foo/bar.pem}`


\item \texttt{max\_parallel}: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.


\item \texttt{dir}: specifies the working directory on the workers. Defaults to the host{\textquotesingle}s current directory (as found by \texttt{pwd()})


\item \texttt{enable\_threaded\_blas}: if \texttt{true} then  BLAS will run on multiple threads in added processes. Default is \texttt{false}.


\item \texttt{exename}: name of the \texttt{julia} executable. Defaults to \texttt{{\textquotedbl}\$JULIA\_HOME/julia{\textquotedbl}} or \texttt{{\textquotedbl}\$JULIA\_HOME/julia-debug{\textquotedbl}} as the case may be.


\item \texttt{exeflags}: additional flags passed to the worker processes.


\item \texttt{topology}: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.

\begin{itemize}
\item \texttt{topology=:all\_to\_all}: All processes are connected to each other. The default.


\item \texttt{topology=:master\_slave}: Only the driver process, i.e. \texttt{pid} 1 connects to the workers. The workers do not connect to each other.


\item \texttt{topology=:custom}: The \texttt{launch} method of the cluster manager specifies the connection topology via fields \texttt{ident} and \texttt{connect\_idents} in \texttt{WorkerConfig}. A worker with a cluster manager identity \texttt{ident} will connect to all workers specified in \texttt{connect\_idents}.

\end{itemize}
\end{itemize}
Environment variables :

If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable \texttt{JULIA\_WORKER\_TIMEOUT}. The value of \texttt{JULIA\_WORKER\_TIMEOUT} on the master process specifies the number of seconds a newly launched worker waits for connection establishment.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L51-L111}{\texttt{source}}



\begin{lstlisting}
addprocs(; kwargs...) -> List of process identifiers
\end{lstlisting}

Equivalent to \texttt{addprocs(Sys.CPU\_CORES; kwargs...)}

Note that workers do not run a \texttt{.juliarc.jl} startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L289-L297}{\texttt{source}}



\begin{lstlisting}
addprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers
\end{lstlisting}

Launches workers using the in-built \texttt{LocalManager} which only launches workers on the local host. This can be used to take advantage of multiple cores. \texttt{addprocs(4)} will add 4 processes on the local machine. If \texttt{restrict} is \texttt{true}, binding is restricted to \texttt{127.0.0.1}. Keyword args \texttt{dir}, \texttt{exename}, \texttt{exeflags}, \texttt{topology}, and \texttt{enable\_threaded\_blas} have the same effect as documented for \texttt{addprocs(machines)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L300-L308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12402227166111076109}{} 
\hyperlink{12402227166111076109}{\texttt{Base.Distributed.nprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nprocs()
\end{lstlisting}

Get the number of available processes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L649-L653}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7337972716564963880}{} 
\hyperlink{7337972716564963880}{\texttt{Base.Distributed.nworkers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nworkers()
\end{lstlisting}

Get the number of available worker processes. This is one less than \texttt{nprocs()}. Equal to \texttt{nprocs()} if \texttt{nprocs() == 1}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L669-L674}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17214181692567267057}{} 
\hyperlink{17214181692567267057}{\texttt{Base.Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
procs()
\end{lstlisting}

Returns a list of all process identifiers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L680-L684}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4820068502451115503}{} 
\hyperlink{4820068502451115503}{\texttt{Base.Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
procs(pid::Integer)
\end{lstlisting}

Returns a list of all process identifiers on the same physical node. Specifically all workers bound to the same ip-address as \texttt{pid} are returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L711-L716}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13629390137500792933}{} 
\hyperlink{13629390137500792933}{\texttt{Base.Distributed.workers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
workers()
\end{lstlisting}

Returns a list of all worker process identifiers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L731-L735}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10441166839192005456}{} 
\hyperlink{10441166839192005456}{\texttt{Base.Distributed.rmprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rmprocs(pids...; waitfor=typemax(Int))
\end{lstlisting}

Removes the specified workers. Note that only process 1 can add or remove workers.

Argument \texttt{waitfor} specifies how long to wait for the workers to shut down:     - If unspecified, \texttt{rmprocs} will wait until all requested \texttt{pids} are removed.     - An \texttt{ErrorException} is raised if all workers cannot be terminated before       the requested \texttt{waitfor} seconds.     - With a \texttt{waitfor} value of 0, the call returns immediately with the workers       scheduled for removal in a different task. The scheduled \texttt{Task} object is       returned. The user should call \texttt{wait} on the task before invoking any other       parallel calls.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L751-L765}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13784302834661046969}{} 
\hyperlink{13784302834661046969}{\texttt{Base.Distributed.interrupt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
interrupt(pids::Integer...)
\end{lstlisting}

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L936-L941}{\texttt{source}}



\begin{lstlisting}
interrupt(pids::AbstractVector=workers())
\end{lstlisting}

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L944-L949}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1193443008958371070}{} 
\hyperlink{1193443008958371070}{\texttt{Base.Distributed.myid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
myid()
\end{lstlisting}

Get the id of the current process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L642-L646}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3190941263759446411}{} 
\hyperlink{3190941263759446411}{\texttt{Base.Distributed.pmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pmap([::AbstractWorkerPool], f, c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[]), retry_check=nothing) -> collection
\end{lstlisting}

Transform collection \texttt{c} by applying \texttt{f} to each element using available workers and tasks.

For multiple collection arguments, apply \texttt{f} elementwise.

Note that \texttt{f} must be made available to all worker processes; see \hyperlink{893674864058732798}{Code Availability and Loading Packages} for details.

If a worker pool is not specified, all available workers, i.e., the default worker pool is used.

By default, \texttt{pmap} distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify \texttt{distributed=false}. This is equivalent to using \hyperlink{14148755671315265621}{\texttt{asyncmap}}. For example, \texttt{pmap(f, c; distributed=false)} is equivalent to \texttt{asyncmap(f,c; ntasks=()->nworkers())}

\texttt{pmap} can also use a mix of processes and tasks via the \texttt{batch\_size} argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length \texttt{batch\_size} or less. A batch is sent as a single request to a free worker, where a local \hyperlink{14148755671315265621}{\texttt{asyncmap}} processes elements from the batch using multiple concurrent tasks.

Any error stops \texttt{pmap} from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument \texttt{on\_error} which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.

Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:


\begin{minted}{jlcon}
julia> pmap(x->iseven(x) ? error("foo") : x, 1:4; on_error=identity)
4-element Array{Any,1}:
 1
  ErrorException("foo")
 3
  ErrorException("foo")

julia> pmap(x->iseven(x) ? error("foo") : x, 1:4; on_error=ex->0)
4-element Array{Int64,1}:
 1
 0
 3
 0
\end{minted}

Errors can also be handled by retrying failed computations. Keyword arguments \texttt{retry\_delays} and \texttt{retry\_check} are passed through to \hyperlink{13615447016541985376}{\texttt{retry}} as keyword arguments \texttt{delays} and \texttt{check} respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.

Note that if both \texttt{on\_error} and \texttt{retry\_delays} are specified, the \texttt{on\_error} hook is called before retrying. If \texttt{on\_error} does not throw (or rethrow) an exception, the element will not be retried.

Example: On errors, retry \texttt{f} on an element a maximum of 3 times without any delay between retries.


\begin{minted}{julia}
pmap(f, c; retry_delays = zeros(3))
\end{minted}

Example: Retry \texttt{f} only if the exception is not of type \texttt{InexactError}, with exponentially increasing delays up to 3 times. Return a \texttt{NaN} in place for all \texttt{InexactError} occurrences.


\begin{minted}{julia}
pmap(f, c; on_error = e->(isa(e, InexactError) ? NaN : rethrow(e)), retry_delays = ExponentialBackOff(n = 3))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/pmap.jl#L32-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13592793980665725371}{} 
\hyperlink{13592793980665725371}{\texttt{Base.Distributed.RemoteException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RemoteException(captured)
\end{lstlisting}

Exceptions on remote computations are captured and rethrown locally.  A \texttt{RemoteException} wraps the \texttt{pid} of the worker and a captured exception. A \texttt{CapturedException} captures the remote exception and a serializable form of the call stack when the exception was raised.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/process_messages.jl#L24-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11214097672600393233}{} 
\hyperlink{11214097672600393233}{\texttt{Base.Distributed.Future}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Future(pid::Integer=myid())
\end{lstlisting}

Create a \texttt{Future} on process \texttt{pid}. The default \texttt{pid} is the current process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L72-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18168838922212360925}{} 
\hyperlink{18168838922212360925}{\texttt{Base.Distributed.RemoteChannel}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RemoteChannel(pid::Integer=myid())
\end{lstlisting}

Make a reference to a \texttt{Channel\{Any\}(1)} on process \texttt{pid}. The default \texttt{pid} is the current process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L80-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5214781515071051930}{} 
\hyperlink{5214781515071051930}{\texttt{Base.Distributed.RemoteChannel}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RemoteChannel(f::Function, pid::Integer=myid())
\end{lstlisting}

Create references to remote channels of a specific size and type. \texttt{f()} is a function that when executed on \texttt{pid} must return an implementation of an \texttt{AbstractChannel}.

For example, \texttt{RemoteChannel(()->Channel\{Int\}(10), pid)}, will return a reference to a channel of type \texttt{Int} and size 10 on \texttt{pid}.

The default \texttt{pid} is the current process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L88-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13761789780433862250}{} 
\hyperlink{13761789780433862250}{\texttt{Base.wait}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
wait([x])
\end{lstlisting}

Block the current task until some event occurs, depending on the type of the argument:

\begin{itemize}
\item \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} : Wait for a value to become available on the specified remote channel.


\item \hyperlink{11214097672600393233}{\texttt{Future}} : Wait for a value to become available for the specified future.


\item \hyperlink{12548845729684045604}{\texttt{Channel}}: Wait for a value to be appended to the channel.


\item \hyperlink{286351753995469758}{\texttt{Condition}}: Wait for \hyperlink{2865179286002578885}{\texttt{notify}} on a condition.


\item \texttt{Process}: Wait for a process or process chain to exit. The \texttt{exitcode} field of a process can be used to determine success or failure.


\item \hyperlink{7131243650304654155}{\texttt{Task}}: Wait for a \texttt{Task} to finish, returning its result value. If the task fails with an exception, the exception is propagated (re-thrown in the task that called \texttt{wait}).


\item \texttt{RawFD}: Wait for changes on a file descriptor (see \hyperlink{3484187138285863365}{\texttt{poll\_fd}} for keyword arguments and return code)

\end{itemize}
If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to \hyperlink{9185853093207176818}{\texttt{schedule}} or \hyperlink{4920987536368477483}{\texttt{yieldto}}.

Often \texttt{wait} is called within a \texttt{while} loop to ensure a waited-for condition is met before proceeding.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1544-L1566}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5432507241688521880}{} 
\hyperlink{5432507241688521880}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch(x)
\end{lstlisting}

Waits and fetches a value from \texttt{x} depending on the type of \texttt{x}:

\begin{itemize}
\item \hyperlink{11214097672600393233}{\texttt{Future}}: Wait for and get the value of a \texttt{Future}. The fetched value is cached locally. Further calls to \texttt{fetch} on the same reference return the cached value. If the remote value is an exception, throws a \hyperlink{13592793980665725371}{\texttt{RemoteException}} which captures the remote exception and backtrace.


\item \hyperlink{18168838922212360925}{\texttt{RemoteChannel}}: Wait for and get the value of a remote reference. Exceptions raised are same as for a \texttt{Future} .

\end{itemize}
Does not remove the item fetched.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L469-L481}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1245601033905961947}{} 
\hyperlink{1245601033905961947}{\texttt{Base.Distributed.remotecall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall(f, id::Integer, args...; kwargs...) -> Future
\end{lstlisting}

Call a function \texttt{f} asynchronously on the given arguments on the specified process. Returns a \hyperlink{11214097672600393233}{\texttt{Future}}. Keyword arguments, if any, are passed through to \texttt{f}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L329-L335}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13031962431312635607}{} 
\hyperlink{13031962431312635607}{\texttt{Base.Distributed.remotecall\_wait}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall_wait(f, id::Integer, args...; kwargs...)
\end{lstlisting}

Perform a faster \texttt{wait(remotecall(...))} in one message on the \texttt{Worker} specified by worker id \texttt{id}. Keyword arguments, if any, are passed through to \texttt{f}.

See also \hyperlink{13761789780433862250}{\texttt{wait}} and \hyperlink{1245601033905961947}{\texttt{remotecall}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L386-L393}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16429337757386989414}{} 
\hyperlink{16429337757386989414}{\texttt{Base.Distributed.remotecall\_fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall_fetch(f, id::Integer, args...; kwargs...)
\end{lstlisting}

Perform \texttt{fetch(remotecall(...))} in one message. Keyword arguments, if any, are passed through to \texttt{f}. Any remote exceptions are captured in a \hyperlink{13592793980665725371}{\texttt{RemoteException}} and thrown.

See also \hyperlink{7098010828229464277}{\texttt{fetch}} and \hyperlink{1245601033905961947}{\texttt{remotecall}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L357-L366}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11257172697035768275}{} 
\hyperlink{11257172697035768275}{\texttt{Base.Distributed.remote\_do}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remote_do(f, id::Integer, args...; kwargs...) -> nothing
\end{lstlisting}

Executes \texttt{f} on worker \texttt{id} asynchronously. Unlike \hyperlink{1245601033905961947}{\texttt{remotecall}}, it does not store the result of computation, nor is there a way to wait for its completion.

A successful invocation indicates that the request has been accepted for execution on the remote node.

While consecutive \texttt{remotecall}s to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, \texttt{remote\_do(f1, 2); remotecall(f2, 2); remote\_do(f3, 2)} will serialize the call to \texttt{f1}, followed by \texttt{f2} and \texttt{f3} in that order. However, it is not guaranteed that \texttt{f1} is executed before \texttt{f3} on worker 2.

Any exceptions thrown by \texttt{f} are printed to \hyperlink{4481879903628924306}{\texttt{STDERR}} on the remote worker.

Keyword arguments, if any, are passed through to \texttt{f}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L412-L431}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2834687666116026096}{} 
\hyperlink{2834687666116026096}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
put!(rr::RemoteChannel, args...)
\end{lstlisting}

Store a set of values to the \hyperlink{18168838922212360925}{\texttt{RemoteChannel}}. If the channel is full, blocks until space is available. Returns its first argument.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L514-L520}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4609812859110888236}{} 
\hyperlink{4609812859110888236}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
put!(rr::Future, v)
\end{lstlisting}

Store a value to a \hyperlink{11214097672600393233}{\texttt{Future}} \texttt{rr}. \texttt{Future}s are write-once remote references. A \texttt{put!} on an already set \texttt{Future} throws an \texttt{Exception}. All asynchronous remote calls return \texttt{Future}s and set the value to the return value of the call upon completion.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L486-L494}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1891403764656916697}{} 
\hyperlink{1891403764656916697}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
take!(rr::RemoteChannel, args...)
\end{lstlisting}

Fetch value(s) from a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} \texttt{rr}, removing the value(s) in the processs.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L532-L537}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6980559591888438300}{} 
\hyperlink{6980559591888438300}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isready(rr::RemoteChannel, args...)
\end{lstlisting}

Determine whether a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a \hyperlink{11214097672600393233}{\texttt{Future}} since they are assigned only once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L187-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10100315526321712686}{} 
\hyperlink{10100315526321712686}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isready(rr::Future)
\end{lstlisting}

Determine whether a \hyperlink{11214097672600393233}{\texttt{Future}} has a value stored to it.

If the argument \texttt{Future} is owned by a different node, this call will block to wait for the answer. It is recommended to wait for \texttt{rr} in a separate task instead or to use a local \hyperlink{12548845729684045604}{\texttt{Channel}} as a proxy:


\begin{lstlisting}
c = Channel(1)
@async put!(c, remotecall_fetch(long_computation, p))
isready(c)  # will not block
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L163-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8368170094868952623}{} 
\hyperlink{8368170094868952623}{\texttt{Base.Distributed.WorkerPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
WorkerPool(workers::Vector{Int})
\end{lstlisting}

Create a WorkerPool from a vector of worker ids.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L32-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8679930550166196253}{} 
\hyperlink{8679930550166196253}{\texttt{Base.Distributed.CachingPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CachingPool(workers::Vector{Int})
\end{lstlisting}

An implementation of an \texttt{AbstractWorkerPool}. \hyperlink{8380052638349282305}{\texttt{remote}}, \hyperlink{16429337757386989414}{\texttt{remotecall\_fetch}}, \hyperlink{3190941263759446411}{\texttt{pmap}} (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).

The remote cache is maintained for the lifetime of the returned \texttt{CachingPool} object. To clear the cache earlier, use \texttt{clear!(pool)}.

For global variables, only the bindings are captured in a closure, not the data. \texttt{let} blocks can be used to capture global data.

For example:


\begin{lstlisting}
const foo=rand(10^8);
wp=CachingPool(workers())
let foo=foo
    pmap(wp, i->sum(foo)+i, 1:100);
end
\end{lstlisting}

The above would transfer \texttt{foo} only once to each worker.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L233-L259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13200137723206461941}{} 
\hyperlink{13200137723206461941}{\texttt{Base.Distributed.default\_worker\_pool}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
default_worker_pool()
\end{lstlisting}

\texttt{WorkerPool} containing idle \texttt{workers()} - used by \texttt{remote(f)} and \hyperlink{3190941263759446411}{\texttt{pmap}} (by default).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L190-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16259780224935483802}{} 
\hyperlink{16259780224935483802}{\texttt{Base.Distributed.clear!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clear!(pool::CachingPool) -> pool
\end{lstlisting}

Removes all cached functions from all participating workers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L268-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8380052638349282305}{} 
\hyperlink{8380052638349282305}{\texttt{Base.Distributed.remote}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remote([::AbstractWorkerPool], f) -> Function
\end{lstlisting}

Returns an anonymous function that executes function \texttt{f} on an available worker using \hyperlink{16429337757386989414}{\texttt{remotecall\_fetch}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L208-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6767221148230310505}{} 
\hyperlink{6767221148230310505}{\texttt{Base.Distributed.remotecall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future
\end{lstlisting}

\texttt{WorkerPool} variant of \texttt{remotecall(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remotecall} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L155-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6787127768037432165}{} 
\hyperlink{6787127768037432165}{\texttt{Base.Distributed.remotecall\_wait}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future
\end{lstlisting}

\texttt{WorkerPool} variant of \texttt{remotecall\_wait(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remotecall\_wait} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L163-L168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6534665661235048702}{} 
\hyperlink{6534665661235048702}{\texttt{Base.Distributed.remotecall\_fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -> result
\end{lstlisting}

\texttt{WorkerPool} variant of \texttt{remotecall\_fetch(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remotecall\_fetch} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L172-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17973648003664616521}{} 
\hyperlink{17973648003664616521}{\texttt{Base.Distributed.remote\_do}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -> nothing
\end{lstlisting}

\texttt{WorkerPool} variant of \texttt{remote\_do(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remote\_do} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L180-L185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6677218100159857934}{} 
\hyperlink{6677218100159857934}{\texttt{Base.timedwait}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)
\end{lstlisting}

Waits until \texttt{testcb} returns \texttt{true} or for \texttt{secs} seconds, whichever is earlier. \texttt{testcb} is polled every \texttt{pollint} seconds.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L340-L345}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2703776722227867458}{} 
\hyperlink{2703776722227867458}{\texttt{Base.Distributed.@spawn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@spawn
\end{lstlisting}

Creates a closure around an expression and runs it on an automatically-chosen process, returning a \hyperlink{11214097672600393233}{\texttt{Future}} to the result.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2078-L2083}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13196020699522784599}{} 
\hyperlink{13196020699522784599}{\texttt{Base.Distributed.@spawnat}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@spawnat
\end{lstlisting}

Accepts two arguments, \texttt{p} and an expression. A closure is created around the expression and run asynchronously on process \texttt{p}. Returns a \hyperlink{11214097672600393233}{\texttt{Future}} to the result.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L564-L569}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1474997561197825789}{} 
\hyperlink{1474997561197825789}{\texttt{Base.Distributed.@fetch}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@fetch
\end{lstlisting}

Equivalent to \texttt{fetch(@spawn expr)}. See \hyperlink{7098010828229464277}{\texttt{fetch}} and \hyperlink{2703776722227867458}{\texttt{@spawn}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/macros.jl#L29-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8163637794457229182}{} 
\hyperlink{8163637794457229182}{\texttt{Base.Distributed.@fetchfrom}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@fetchfrom
\end{lstlisting}

Equivalent to \texttt{fetch(@spawnat p expr)}. See \hyperlink{7098010828229464277}{\texttt{fetch}} and \hyperlink{13196020699522784599}{\texttt{@spawnat}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/macros.jl#L40-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10770947021537241619}{} 
\hyperlink{10770947021537241619}{\texttt{Base.@async}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@async
\end{lstlisting}

Like \texttt{@schedule}, \texttt{@async} wraps an expression in a \texttt{Task} and adds it to the local machine{\textquotesingle}s scheduler queue. Additionally it adds the task to the set of items that the nearest enclosing \texttt{@sync} waits for.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L327-L333}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7188613740509403855}{} 
\hyperlink{7188613740509403855}{\texttt{Base.@sync}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@sync
\end{lstlisting}

Wait until all dynamically-enclosed uses of \texttt{@async}, \texttt{@spawn}, \texttt{@spawnat} and \texttt{@parallel} are complete. All exceptions thrown by enclosed async operations are collected and thrown as a \texttt{CompositeException}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L292-L298}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11870389661093259741}{} 
\hyperlink{11870389661093259741}{\texttt{Base.Distributed.@parallel}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@parallel
\end{lstlisting}

A parallel for loop of the form :


\begin{lstlisting}
@parallel [reducer] for var = range
    body
end
\end{lstlisting}

The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, \texttt{@parallel} performs local reductions on each worker with a final reduction on the calling process.

Note that without a reducer function, \texttt{@parallel} executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with \hyperlink{7188613740509403855}{\texttt{@sync}}, like :


\begin{lstlisting}
@sync @parallel for var = range
    body
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/macros.jl#L180-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12473779098025967223}{} 
\hyperlink{12473779098025967223}{\texttt{Base.Distributed.@everywhere}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@everywhere expr
\end{lstlisting}

Execute an expression under \texttt{Main} everywhere. Equivalent to calling \texttt{eval(Main, expr)} on all processes. Errors on any of the processes are collected into a \texttt{CompositeException} and thrown. For example :


\begin{lstlisting}
@everywhere bar=1
\end{lstlisting}

will define \texttt{Main.bar} on all processes.

Unlike \hyperlink{2703776722227867458}{\texttt{@spawn}} and \hyperlink{13196020699522784599}{\texttt{@spawnat}}, \texttt{@everywhere} does not capture any local variables. Prefixing \texttt{@everywhere} with \hyperlink{12895501458291832858}{\texttt{@eval}} allows us to broadcast local variables using interpolation :


\begin{lstlisting}
foo = 1
@eval @everywhere bar=$foo
\end{lstlisting}

The expression is evaluated under \texttt{Main} irrespective of where \texttt{@everywhere} is called from. For example :


\begin{lstlisting}
module FooBar
    foo() = @everywhere bar()=myid()
end
FooBar.foo()
\end{lstlisting}

will result in \texttt{Main.bar} being defined on all processes and not \texttt{FooBar.bar}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/macros.jl#L67-L95}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1215353657448172824}{} 
\hyperlink{1215353657448172824}{\texttt{Base.Distributed.clear!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clear!(syms, pids=workers(); mod=Main)
\end{lstlisting}

Clears global bindings in modules by initializing them to \texttt{nothing}. \texttt{syms} should be of type \texttt{Symbol} or a collection of \texttt{Symbol}s . \texttt{pids} and \texttt{mod} identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under \texttt{mod} are cleared.

An exception is raised if a global constant is requested to be cleared.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/clusterserialize.jl#L228-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18395570731388646834}{} 
\hyperlink{18395570731388646834}{\texttt{Base.Distributed.remoteref\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.remoteref_id(r::AbstractRemoteRef) -> RRID
\end{lstlisting}

\texttt{Future}s and \texttt{RemoteChannel}s are identified by fields:

\begin{itemize}
\item \texttt{where} - refers to the node where the underlying object/storage referred to by the reference actually exists.


\item \texttt{whence} - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling \texttt{RemoteChannel(2)} from the master process would result in a \texttt{where} value of 2 and a \texttt{whence} value of 1.


\item \texttt{id} is unique across all references created from the worker specified by \texttt{whence}.

\end{itemize}
Taken together,  \texttt{whence} and \texttt{id} uniquely identify a reference across all workers.

\texttt{Base.remoteref\_id} is a low-level API which returns a \texttt{Base.RRID} object that wraps \texttt{whence} and \texttt{id} values of a remote reference.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L109-L129}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8998573007654850595}{} 
\hyperlink{8998573007654850595}{\texttt{Base.Distributed.channel\_from\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.channel_from_id(id) -> c
\end{lstlisting}

A low-level API which returns the backing \texttt{AbstractChannel} for an \texttt{id} returned by \hyperlink{18395570731388646834}{\texttt{remoteref\_id}}. The call is valid only on the node where the backing channel exists.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L132-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6860508881203693771}{} 
\hyperlink{6860508881203693771}{\texttt{Base.Distributed.worker\_id\_from\_socket}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.worker_id_from_socket(s) -> pid
\end{lstlisting}

A low-level API which given a \texttt{IO} connection or a \texttt{Worker}, returns the \texttt{pid} of the worker it is connected to. This is useful when writing custom \hyperlink{11136223858024612210}{\texttt{serialize}} methods for a type, which optimizes the data written out depending on the receiving process id.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L842-L849}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12027223643055649570}{} 
\hyperlink{12027223643055649570}{\texttt{Base.Distributed.cluster\_cookie}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.cluster_cookie() -> cookie
\end{lstlisting}

Returns the cluster cookie.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L569-L573}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14582041898079717841}{} 
\hyperlink{14582041898079717841}{\texttt{Base.Distributed.cluster\_cookie}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.cluster_cookie(cookie) -> cookie
\end{lstlisting}

Sets the passed cookie as the cluster cookie, then returns it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L576-L580}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8266562503080193386}{}


\section{Arrays Compartidos}


\hypertarget{7878126212965430667}{} 
\hyperlink{7878126212965430667}{\texttt{Base.SharedArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SharedArray{T}(dims::NTuple; init=false, pids=Int[])
SharedArray{T,N}(...)
\end{lstlisting}

Construct a \texttt{SharedArray} of a bits type \texttt{T} and size \texttt{dims} across the processes specified by \texttt{pids} - all of which have to be on the same host.  If \texttt{N} is specified by calling \texttt{SharedArray\{T,N\}(dims)}, then \texttt{N} must match the length of \texttt{dims}.

If \texttt{pids} is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, \texttt{localindexes} and \texttt{indexpids} will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.

If an \texttt{init} function of the type \texttt{initfn(S::SharedArray)} is specified, it is called on all the participating workers.

The shared array is valid as long as a reference to the \texttt{SharedArray} object exists on the node which created the mapping.


\begin{lstlisting}
SharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids=Int[])
SharedArray{T,N}(...)
\end{lstlisting}

Construct a \texttt{SharedArray} backed by the file \texttt{filename}, with element type \texttt{T} (must be a bits type) and size \texttt{dims}, across the processes specified by \texttt{pids} - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:

\begin{itemize}
\item The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)


\item Any changes you make to the array values (e.g., \texttt{A[3] = 0}) will also change the values on disk

\end{itemize}
If \texttt{pids} is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, \texttt{localindexes} and \texttt{indexpids} will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.

\texttt{mode} must be one of \texttt{{\textquotedbl}r{\textquotedbl}}, \texttt{{\textquotedbl}r+{\textquotedbl}}, \texttt{{\textquotedbl}w+{\textquotedbl}}, or \texttt{{\textquotedbl}a+{\textquotedbl}}, and defaults to \texttt{{\textquotedbl}r+{\textquotedbl}} if the file specified by \texttt{filename} already exists, or \texttt{{\textquotedbl}w+{\textquotedbl}} if not. If an \texttt{init} function of the type \texttt{initfn(S::SharedArray)} is specified, it is called on all the participating workers. You cannot specify an \texttt{init} function if the file is not writable.

\texttt{offset} allows you to skip the specified number of bytes at the beginning of the file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L37-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11406168328748369296}{} 
\hyperlink{11406168328748369296}{\texttt{Base.Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
procs(S::SharedArray)
\end{lstlisting}

Get the vector of processes mapping the shared array.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L288-L292}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12236070431744516222}{} 
\hyperlink{12236070431744516222}{\texttt{Base.sdata}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sdata(S::SharedArray)
\end{lstlisting}

Returns the actual \texttt{Array} object backing \texttt{S}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L304-L308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7166338227826761370}{} 
\hyperlink{7166338227826761370}{\texttt{Base.indexpids}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indexpids(S::SharedArray)
\end{lstlisting}

Returns the current worker{\textquotesingle}s index in the list of workers mapping the \texttt{SharedArray} (i.e. in the same list returned by \texttt{procs(S)}), or 0 if the \texttt{SharedArray} is not mapped locally.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L295-L301}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6459655385118725622}{} 
\hyperlink{6459655385118725622}{\texttt{Base.localindexes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
localindexes(S::SharedArray)
\end{lstlisting}

Returns a range describing the {\textquotedbl}default{\textquotedbl} indexes to be handled by the current process.  This range should be interpreted in the sense of linear indexing, i.e., as a sub-range of \texttt{1:length(S)}.  In multi-process contexts, returns an empty range in the parent process (or any process for which \hyperlink{7166338227826761370}{\texttt{indexpids}} returns 0).

It{\textquotesingle}s worth emphasizing that \texttt{localindexes} exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a \texttt{SharedArray}, all indexes should be equally fast for each worker process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L312-L325}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11732329196737613388}{}


\section{Multi-Threading}



Este interfaz experimental soporta las capacidades multi-hilo de Julia. Los tipos y funciones descritos aquí pueden cambiar en el futuro (y probablemente lo harán).


\hypertarget{12668125807854133993}{} 
\hyperlink{12668125807854133993}{\texttt{Base.Threads.threadid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.threadid()
\end{lstlisting}

Get the ID number of the current thread of execution. The master thread has ID \texttt{1}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/threadingconstructs.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11061583461116144745}{} 
\hyperlink{11061583461116144745}{\texttt{Base.Threads.nthreads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.nthreads()
\end{lstlisting}

Get the number of threads available to the Julia process. This is the inclusive upper bound on \texttt{threadid()}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/threadingconstructs.jl#L13-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15582842999596899869}{} 
\hyperlink{15582842999596899869}{\texttt{Base.Threads.@threads}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.@threads
\end{lstlisting}

A macro to parallelize a for-loop to run with multiple threads. This spawns \texttt{nthreads()} number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/threadingconstructs.jl#L79-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1140117372581270616}{} 
\hyperlink{1140117372581270616}{\texttt{Base.Threads.Atomic}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.Atomic{T}
\end{lstlisting}

Holds a reference to an object of type \texttt{T}, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.

Only certain {\textquotedbl}simple{\textquotedbl} types can be used atomically, namely the primitive integer and float-point types. These are \texttt{Int8}...\texttt{Int128}, \texttt{UInt8}...\texttt{UInt128}, and \texttt{Float16}...\texttt{Float64}.

New atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.

Atomic objects can be accessed using the \texttt{[]} notation:


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> x[] = 1
1

julia> x[]
1
\end{minted}

Atomic operations use an \texttt{atomic\_} prefix, such as \texttt{atomic\_add!}, \texttt{atomic\_xchg!}, etc.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L35-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6924433775344145551}{} 
\hyperlink{6924433775344145551}{\texttt{Base.Threads.atomic\_cas!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_cas!{T}(x::Atomic{T}, cmp::T, newval::T)
\end{lstlisting}

Atomically compare-and-set \texttt{x}

Atomically compares the value in \texttt{x} with \texttt{cmp}. If equal, write \texttt{newval} to \texttt{x}. Otherwise, leaves \texttt{x} unmodified. Returns the old value in \texttt{x}. By comparing the returned value to \texttt{cmp} (via \texttt{===}) one knows whether \texttt{x} was modified and now holds the new value \texttt{newval}.

For further details, see LLVM{\textquotesingle}s \texttt{cmpxchg} instruction.

This function can be used to implement transactional semantics. Before the transaction, one records the value in \texttt{x}. After the transaction, the new value is stored only if \texttt{x} has not been modified in the mean time.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x, 4, 2);

julia> x
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x, 3, 2);

julia> x
Base.Threads.Atomic{Int64}(2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L72-L103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15583989732166753404}{} 
\hyperlink{15583989732166753404}{\texttt{Base.Threads.atomic\_xchg!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_xchg!{T}(x::Atomic{T}, newval::T)
\end{lstlisting}

Atomically exchange the value in \texttt{x}

Atomically exchanges the value in \texttt{x} with \texttt{newval}. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw xchg} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_xchg!(x, 2)
3

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L106-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4669846204248874730}{} 
\hyperlink{4669846204248874730}{\texttt{Base.Threads.atomic\_add!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_add!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically add \texttt{val} to \texttt{x}

Performs \texttt{x[] += val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw add} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_add!(x, 2)
3

julia> x[]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L129-L148}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17642173571521486894}{} 
\hyperlink{17642173571521486894}{\texttt{Base.Threads.atomic\_sub!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_sub!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically subtract \texttt{val} from \texttt{x}

Performs \texttt{x[] -= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw sub} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_sub!(x, 2)
3

julia> x[]
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L151-L170}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17667453349907943193}{} 
\hyperlink{17667453349907943193}{\texttt{Base.Threads.atomic\_and!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_and!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically bitwise-and \texttt{x} with \texttt{val}

Performs \texttt{x[] \&= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw and} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_and!(x, 2)
3

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L173-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7585036809570134634}{} 
\hyperlink{7585036809570134634}{\texttt{Base.Threads.atomic\_nand!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_nand!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically bitwise-nand (not-and) \texttt{x} with \texttt{val}

Performs \texttt{x[] = {\textasciitilde}(x[] \& val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw nand} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_nand!(x, 2)
3

julia> x[]
-3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L195-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13607043969188851947}{} 
\hyperlink{13607043969188851947}{\texttt{Base.Threads.atomic\_or!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_or!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically bitwise-or \texttt{x} with \texttt{val}

Performs \texttt{x[] |= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw or} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_or!(x, 7)
5

julia> x[]
7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L217-L236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5701145140539338563}{} 
\hyperlink{5701145140539338563}{\texttt{Base.Threads.atomic\_xor!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_xor!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically bitwise-xor (exclusive-or) \texttt{x} with \texttt{val}

Performs \texttt{x[] \$= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw xor} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_xor!(x, 7)
5

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L239-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8102033568033818241}{} 
\hyperlink{8102033568033818241}{\texttt{Base.Threads.atomic\_max!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_max!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically store the maximum of \texttt{x} and \texttt{val} in \texttt{x}

Performs \texttt{x[] = max(x[], val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw max} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_max!(x, 7)
5

julia> x[]
7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L261-L280}{\texttt{source}}


\end{adjustwidth}
\hypertarget{392667369563982661}{} 
\hyperlink{392667369563982661}{\texttt{Base.Threads.atomic\_min!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_min!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically store the minimum of \texttt{x} and \texttt{val} in \texttt{x}

Performs \texttt{x[] = min(x[], val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw min} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(7)
Base.Threads.Atomic{Int64}(7)

julia> Threads.atomic_min!(x, 5)
7

julia> x[]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L283-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6451121520734566874}{} 
\hyperlink{6451121520734566874}{\texttt{Base.Threads.atomic\_fence}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_fence()
\end{lstlisting}

Insert a sequential-consistency memory fence

Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.

This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.

For further details, see LLVM{\textquotesingle}s \texttt{fence} instruction.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L464-L478}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6332880025315332163}{}


\section{ccall using a threadpool (Experimental)}


\hypertarget{4118169676263419404}{} 
\hyperlink{4118169676263419404}{\texttt{Base.@threadcall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)
\end{lstlisting}

The \texttt{@threadcall} macro is called in the same way as \hyperlink{14245046751182637566}{\texttt{ccall}} but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main \texttt{julia} thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the \texttt{UV\_THREADPOOL\_SIZE} environment variable and restarting the \texttt{julia} process.

Note that the called function should never call back into Julia.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/threadcall.jl#L17-L28}{\texttt{source}}


\end{adjustwidth}

\hypertarget{253970398211302716}{}


\section{Primitivas de Sincronización}


\hypertarget{5123005454870250611}{} 
\hyperlink{5123005454870250611}{\texttt{Base.Threads.AbstractLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AbstractLock
\end{lstlisting}

Abstract supertype describing types that implement the thread-safe synchronization primitives: \texttt{lock}, \texttt{trylock}, \texttt{unlock}, and \texttt{islocked}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/locks.jl#L13-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3013795445283337804}{} 
\hyperlink{3013795445283337804}{\texttt{Base.lock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lock(the_lock)
\end{lstlisting}

Acquires the lock when it becomes available. If the lock is already locked by a different task/thread, it waits for it to become available.

Each \texttt{lock} must be matched by an \texttt{unlock}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L54-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7477828718297215912}{} 
\hyperlink{7477828718297215912}{\texttt{Base.unlock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unlock(the_lock)
\end{lstlisting}

Releases ownership of the lock.

If this is a recursive lock which has been acquired before, it just decrements an internal counter and returns immediately.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L78-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8566561467185712956}{} 
\hyperlink{8566561467185712956}{\texttt{Base.trylock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trylock(the_lock) -> Success (Boolean)
\end{lstlisting}

Acquires the lock if it is available, returning \texttt{true} if successful. If the lock is already locked by a different task/thread, returns \texttt{false}.

Each successful \texttt{trylock} must be matched by an \texttt{unlock}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L31-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8304067307715619600}{} 
\hyperlink{8304067307715619600}{\texttt{Base.islocked}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
islocked(the_lock) -> Status (Boolean)
\end{lstlisting}

Check whether the lock is held by any task/thread. This should not be used for synchronization (see instead \texttt{trylock}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L21-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7552896090133941635}{} 
\hyperlink{7552896090133941635}{\texttt{Base.ReentrantLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ReentrantLock()
\end{lstlisting}

Creates a reentrant lock for synchronizing Tasks. The same task can acquire the lock as many times as required. Each \texttt{lock} must be matched with an \texttt{unlock}.

This lock is NOT threadsafe. See \texttt{Threads.Mutex} for a threadsafe lock.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L4-L12}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5247432390476931037}{} 
\hyperlink{5247432390476931037}{\texttt{Base.Threads.Mutex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mutex()
\end{lstlisting}

These are standard system mutexes for locking critical sections of logic.

On Windows, this is a critical section object, on pthreads, this is a \texttt{pthread\_mutex\_t}.

See also SpinLock for a lighter-weight lock.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/locks.jl#L172-L181}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16883834658935510339}{} 
\hyperlink{16883834658935510339}{\texttt{Base.Threads.SpinLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SpinLock()
\end{lstlisting}

Creates a non-reentrant lock. Recursive use will result in a deadlock. Each \texttt{lock} must be matched with an \texttt{unlock}.

Test-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, perhaps a lock is the wrong way to synchronize.

See also RecursiveSpinLock for a version that permits recursion.

See also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/locks.jl#L35-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13921760733857729411}{} 
\hyperlink{13921760733857729411}{\texttt{Base.Threads.RecursiveSpinLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RecursiveSpinLock()
\end{lstlisting}

Creates a reentrant lock. The same thread can acquire the lock as many times as required. Each \texttt{lock} must be matched with an \texttt{unlock}.

See also SpinLock for a slightly faster version.

See also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/locks.jl#L95-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014313312721841609}{} 
\hyperlink{11014313312721841609}{\texttt{Base.Semaphore}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Semaphore(sem_size)
\end{lstlisting}

Creates a counting semaphore that allows at most \texttt{sem\_size} acquires to be in use at any time. Each acquire must be mached with a release.

This construct is NOT threadsafe.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L118-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{733284340937899961}{} 
\hyperlink{733284340937899961}{\texttt{Base.acquire}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acquire(s::Semaphore)
\end{lstlisting}

Wait for one of the \texttt{sem\_size} permits to be available, blocking until one can be acquired.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L134-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8274760602310731764}{} 
\hyperlink{8274760602310731764}{\texttt{Base.release}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
release(s::Semaphore)
\end{lstlisting}

Return one permit to the pool, possibly allowing another task to acquire it and resume execution.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L151-L157}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11106394229907340888}{}


\section{Interfaz de Administración de Cluster}



Esta interfaz proporciona un mecanismo para lanzar y gestionar \emph{workers} Julia sobre diferentes entornos cluster. Hay dos tipos de administrafores presentes en Base: \texttt{LocalManager}, para lanzar \emph{workers} adicionales sobre el mismo host, y \texttt{SSHManager}, para lanzarlos sobre hosts remotos vía \texttt{ssh}. Para conectar y transportar mensajes entre procesos se usan los sockets TCP/IP. Es posible que los administradores de clusters proporcionen un transporte diferente.


\hypertarget{6239708201491318480}{} 
\hyperlink{6239708201491318480}{\texttt{Base.Distributed.launch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)
\end{lstlisting}

Implemented by cluster managers. For every Julia worker launched by this function, it should append a \texttt{WorkerConfig} entry to \texttt{launched} and notify \texttt{launch\_ntfy}. The function MUST exit once all workers, requested by \texttt{manager} have been launched. \texttt{params} is a dictionary of all keyword arguments \hyperlink{1448678099847390}{\texttt{addprocs}} was called with.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L342-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7891835938868853982}{} 
\hyperlink{7891835938868853982}{\texttt{Base.Distributed.manage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)
\end{lstlisting}

Implemented by cluster managers. It is called on the master process, during a worker{\textquotesingle}s lifetime, with appropriate \texttt{op} values:

\begin{itemize}
\item with \texttt{:register}/\texttt{:deregister} when a worker is added / removed from the Julia worker pool.


\item with \texttt{:interrupt} when \texttt{interrupt(workers)} is called. The \texttt{ClusterManager} should signal the appropriate worker with an interrupt signal.


\item with \texttt{:finalize} for cleanup purposes.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L352-L362}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17836284879339877528}{} 
\hyperlink{17836284879339877528}{\texttt{Base.kill}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
kill(manager::ClusterManager, pid::Int, config::WorkerConfig)
\end{lstlisting}

Implemented by cluster managers. It is called on the master process, by \hyperlink{10441166839192005456}{\texttt{rmprocs}}. It should cause the remote worker specified by \texttt{pid} to exit. \texttt{kill(manager::ClusterManager.....)} executes a remote \texttt{exit()} on \texttt{pid}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L517-L525}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7081869897278518002}{} 
\hyperlink{7081869897278518002}{\texttt{Base.Distributed.init\_worker}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())
\end{lstlisting}

Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument \texttt{--worker} has the effect of initializing a process as a worker using TCP/IP sockets for transport. \texttt{cookie} is a \hyperlink{12027223643055649570}{\texttt{cluster\_cookie}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L265-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12692155096250099297}{} 
\hyperlink{12692155096250099297}{\texttt{Base.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -> (instrm::IO, outstrm::IO)
\end{lstlisting}

Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id \texttt{pid}, specified by \texttt{config} and return a pair of \texttt{IO} objects. Messages from \texttt{pid} to current process will be read off \texttt{instrm}, while messages to be sent to \texttt{pid} will be written to \texttt{outstrm}. The custom transport implementation must ensure that messages are delivered and received completely and in order. \texttt{connect(manager::ClusterManager.....)} sets up TCP/IP socket connections in-between workers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L372-L382}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3520563658360039058}{} 
\hyperlink{3520563658360039058}{\texttt{Base.Distributed.process\_messages}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)
\end{lstlisting}

Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two \texttt{IO} objects, one for incoming messages and the other for messages addressed to the remote worker. If \texttt{incoming} is \texttt{true}, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.

See also \hyperlink{12027223643055649570}{\texttt{cluster\_cookie}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/process_messages.jl#L121-L134}{\texttt{source}}


\end{adjustwidth}

\hypertarget{2892037563719910727}{}


\chapter{Álgebra Lineal}



\hypertarget{13065370563019154145}{}


\section{Funciones Estándar}



Las funciones de álgebra lineal en Julia está ampliamente implementadas llamando a funciones de \href{http://www.netlib.org/lapack/}{LAPACK}. Las factorizaciones \emph{sparse} llaman a funciones de \href{http://faculty.cse.tamu.edu/davis/suitesparse.html}{SuiteSparse}


\hypertarget{8926068912300694608}{} 
\hyperlink{8926068912300694608}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
*(x, y...)
\end{lstlisting}

Multiplication operator. \texttt{x*y*z*...} calls this function with all arguments, i.e. \texttt{*(x, y, z, ...)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1917-L1923}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11203908042914658075}{} 
\hyperlink{11203908042914658075}{\texttt{Base.:{\textbackslash}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
\(x, y)
\end{lstlisting}

Left division operator: multiplication of \texttt{y} by the inverse of \texttt{x} on the left. Gives floating-point results for integer arguments.


\begin{minted}{jlcon}
julia> 3 \ 6
2.0

julia> inv(3) * 6
2.0

julia> A = [1 2; 3 4]; x = [5, 6];

julia> A \ x
2-element Array{Float64,1}:
 -4.0
  4.5

julia> inv(A) * x
2-element Array{Float64,1}:
 -4.0
  4.5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L431-L456}{\texttt{source}}


\end{adjustwidth}
\hypertarget{697823138745516979}{} 
\hyperlink{697823138745516979}{\texttt{Base.LinAlg.dot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dot(n, X, incx, Y, incy)
\end{lstlisting}

Dot product of two vectors consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{Y} with stride \texttt{incy}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> dot(10, ones(10), 1, ones(20), 2)
10.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L213-L224}{\texttt{source}}


\end{adjustwidth}
\hypertarget{929868199641061171}{} 
\hyperlink{929868199641061171}{\texttt{Base.LinAlg.vecdot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
vecdot(x, y)
\end{lstlisting}

For any iterable containers \texttt{x} and \texttt{y} (including arrays of any dimension) of numbers (or any element type for which \texttt{dot} is defined), compute the Euclidean dot product (the sum of \texttt{dot(x[i],y[i])}) as if they were vectors.

\textbf{Examples}


\begin{minted}{jlcon}
julia> vecdot(1:5, 2:6)
70

julia> x = fill(2., (5,5));

julia> y = fill(3., (5,5));

julia> vecdot(x, y)
150.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L624-L643}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15390434108937215869}{} 
\hyperlink{15390434108937215869}{\texttt{Base.LinAlg.cross}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cross(x, y)
×(x,y)
\end{lstlisting}

Compute the cross product of two 3-vectors.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [0;1;0]
3-element Array{Int64,1}:
 0
 1
 0

julia> b = [0;0;1]
3-element Array{Int64,1}:
 0
 0
 1

julia> cross(a,b)
3-element Array{Int64,1}:
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L88-L115}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10363263068585650380}{} 
\hyperlink{10363263068585650380}{\texttt{Base.LinAlg.factorize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
factorize(A)
\end{lstlisting}

Compute a convenient factorization of \texttt{A}, based upon the type of the input matrix. \texttt{factorize} checks \texttt{A} to see if it is symmetric/triangular/etc. if \texttt{A} is passed as a generic matrix. \texttt{factorize} checks every element of \texttt{A} to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: \texttt{A=factorize(A); x=A{\textbackslash}b; y=A{\textbackslash}C}.


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Properties of \texttt{A} & type of factorization \\
\hline
Positive-definite & Cholesky (see \hyperlink{12805335348758675309}{\texttt{cholfact}}) \\
\hline
Dense Symmetric/Hermitian & Bunch-Kaufman (see \hyperlink{16689081380067534909}{\texttt{bkfact}}) \\
\hline
Sparse Symmetric/Hermitian & LDLt (see \hyperlink{17696382973019086267}{\texttt{ldltfact}}) \\
\hline
Triangular & Triangular \\
\hline
Diagonal & Diagonal \\
\hline
Bidiagonal & Bidiagonal \\
\hline
Tridiagonal & LU (see \hyperlink{2935598995290090141}{\texttt{lufact}}) \\
\hline
Symmetric real tridiagonal & LDLt (see \hyperlink{17696382973019086267}{\texttt{ldltfact}}) \\
\hline
General square & LU (see \hyperlink{2935598995290090141}{\texttt{lufact}}) \\
\hline
General non-square & QR (see \hyperlink{16170416021894488810}{\texttt{qrfact}}) \\
\hline
\end{tabulary}

\end{table}

If \texttt{factorize} is called on a Hermitian positive-definite matrix, for instance, then \texttt{factorize} will return a Cholesky factorization.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = Array(Bidiagonal(ones(5, 5), true))
5×5 Array{Float64,2}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia> factorize(A) # factorize will check to see that A is already factorized
5×5 Bidiagonal{Float64}:
 1.0  1.0   ⋅    ⋅    ⋅
  ⋅   1.0  1.0   ⋅    ⋅
  ⋅    ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅   1.0  1.0
  ⋅    ⋅    ⋅    ⋅   1.0
\end{minted}

This returns a \texttt{5×5 Bidiagonal\{Float64\}}, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for \texttt{Bidiagonal} types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L664-L711}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14932727513503167130}{} 
\hyperlink{14932727513503167130}{\texttt{Base.LinAlg.Diagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Diagonal(A::AbstractMatrix)
\end{lstlisting}

Constructs a matrix from the diagonal of \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> Diagonal(A)
3×3 Diagonal{Int64}:
 1  ⋅  ⋅
 ⋅  5  ⋅
 ⋅  ⋅  9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/diagonal.jl#L8-L28}{\texttt{source}}



\begin{lstlisting}
Diagonal(V::AbstractVector)
\end{lstlisting}

Constructs a matrix with \texttt{V} as its diagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> V = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia> Diagonal(V)
2×2 Diagonal{Int64}:
 1  ⋅
 ⋅  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/diagonal.jl#L30-L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3712437588055447942}{} 
\hyperlink{3712437588055447942}{\texttt{Base.LinAlg.Bidiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Bidiagonal(dv, ev, isupper::Bool)
\end{lstlisting}

Constructs an upper (\texttt{isupper=true}) or lower (\texttt{isupper=false}) bidiagonal matrix using the given diagonal (\texttt{dv}) and off-diagonal (\texttt{ev}) vectors.  The result is of type \texttt{Bidiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). \texttt{ev}{\textquotesingle}s length must be one less than the length of \texttt{dv}.

\textbf{Example}


\begin{minted}{jlcon}
julia> dv = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7; 8; 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> Bu = Bidiagonal(dv, ev, true) # ev is on the first superdiagonal
4×4 Bidiagonal{Int64}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia> Bl = Bidiagonal(dv, ev, false) # ev is on the first subdiagonal
4×4 Bidiagonal{Int64}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bidiag.jl#L15-L54}{\texttt{source}}



\begin{lstlisting}
Bidiagonal(dv, ev, uplo::Char)
\end{lstlisting}

Constructs an upper (\texttt{uplo={\textquotesingle}U{\textquotesingle}}) or lower (\texttt{uplo={\textquotesingle}L{\textquotesingle}}) bidiagonal matrix using the given diagonal (\texttt{dv}) and off-diagonal (\texttt{ev}) vectors.  The result is of type \texttt{Bidiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). \texttt{ev}{\textquotesingle}s length must be one less than the length of \texttt{dv}.

\textbf{Example}


\begin{minted}{jlcon}
julia> dv = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7; 8; 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> Bu = Bidiagonal(dv, ev, 'U') #e is on the first superdiagonal
4×4 Bidiagonal{Int64}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia> Bl = Bidiagonal(dv, ev, 'L') #e is on the first subdiagonal
4×4 Bidiagonal{Int64}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bidiag.jl#L58-L97}{\texttt{source}}



\begin{lstlisting}
Bidiagonal(A, isupper::Bool)
\end{lstlisting}

Construct a \texttt{Bidiagonal} matrix from the main diagonal of \texttt{A} and its first super- (if \texttt{isupper=true}) or sub-diagonal (if \texttt{isupper=false}).

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4×4 Array{Int64,2}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia> Bidiagonal(A, true) #contains the main diagonal and first superdiagonal of A
4×4 Bidiagonal{Int64}:
 1  1  ⋅  ⋅
 ⋅  2  2  ⋅
 ⋅  ⋅  3  3
 ⋅  ⋅  ⋅  4

julia> Bidiagonal(A, false) #contains the main diagonal and first subdiagonal of A
4×4 Bidiagonal{Int64}:
 1  ⋅  ⋅  ⋅
 2  2  ⋅  ⋅
 ⋅  3  3  ⋅
 ⋅  ⋅  4  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bidiag.jl#L114-L144}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14121197223449931750}{} 
\hyperlink{14121197223449931750}{\texttt{Base.LinAlg.SymTridiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SymTridiagonal(dv, ev)
\end{lstlisting}

Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, respectively. The result is of type \texttt{SymTridiagonal} and provides efficient specialized eigensolvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short).

\textbf{Example}


\begin{minted}{jlcon}
julia> dv = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7; 8; 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> SymTridiagonal(dv, ev)
4×4 SymTridiagonal{Int64}:
 1  7  ⋅  ⋅
 7  2  8  ⋅
 ⋅  8  3  9
 ⋅  ⋅  9  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/tridiag.jl#L17-L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10627817666628508033}{} 
\hyperlink{10627817666628508033}{\texttt{Base.LinAlg.Tridiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Tridiagonal(dl, d, du)
\end{lstlisting}

Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively.  The result is of type \texttt{Tridiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). The lengths of \texttt{dl} and \texttt{du} must be one less than the length of \texttt{d}.

\textbf{Example}


\begin{minted}{jlcon}
julia> dl = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> du = [4; 5; 6]
3-element Array{Int64,1}:
 4
 5
 6

julia> d = [7; 8; 9; 0]
4-element Array{Int64,1}:
 7
 8
 9
 0

julia> Tridiagonal(dl, d, du)
4×4 Tridiagonal{Int64}:
 7  4  ⋅  ⋅
 1  8  5  ⋅
 ⋅  2  9  6
 ⋅  ⋅  3  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/tridiag.jl#L395-L433}{\texttt{source}}



\begin{lstlisting}
Tridiagonal(A)
\end{lstlisting}

returns a \texttt{Tridiagonal} array based on (abstract) matrix \texttt{A}, using its first lower diagonal, main diagonal, and first upper diagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4×4 Array{Int64,2}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia> Tridiagonal(A)
4×4 Tridiagonal{Int64}:
 1  2  ⋅  ⋅
 1  2  3  ⋅
 ⋅  2  3  4
 ⋅  ⋅  3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/tridiag.jl#L449-L472}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10155539409143226179}{} 
\hyperlink{10155539409143226179}{\texttt{Base.LinAlg.Symmetric}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Symmetric(A, uplo=:U)
\end{lstlisting}

Construct a \texttt{Symmetric} view of the upper (if \texttt{uplo = :U}) or lower (if \texttt{uplo = :L}) triangle of the matrix \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]
5×5 Array{Int64,2}:
 1  0  2  0  3
 0  4  0  5  0
 6  0  7  0  8
 0  9  0  1  0
 2  0  3  0  4

julia> Supper = Symmetric(A)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  2  0  3
 0  4  0  5  0
 2  0  7  0  8
 0  5  0  1  0
 3  0  8  0  4

julia> Slower = Symmetric(A, :L)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  6  0  2
 0  4  0  9  0
 6  0  7  0  3
 0  9  0  1  0
 2  0  3  0  4
\end{minted}

Note that \texttt{Supper} will not be equal to \texttt{Slower} unless \texttt{A} is itself symmetric (e.g. if \texttt{A == A.{\textquotesingle}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L8-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11943711269274284831}{} 
\hyperlink{11943711269274284831}{\texttt{Base.LinAlg.Hermitian}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Hermitian(A, uplo=:U)
\end{lstlisting}

Construct a \texttt{Hermitian} view of the upper (if \texttt{uplo = :U}) or lower (if \texttt{uplo = :L}) triangle of the matrix \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia> Hupper = Hermitian(A)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  2+2im  0+0im  3-3im
 0+0im  4+0im  0+0im  5+0im  0+0im
 2-2im  0+0im  7+0im  0+0im  8+8im
 0+0im  5+0im  0+0im  1+0im  0+0im
 3+3im  0+0im  8-8im  0+0im  4+0im

julia> Hlower = Hermitian(A, :L)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  6+6im  0+0im  2-2im
 0+0im  4+0im  0+0im  9+0im  0+0im
 6-6im  0+0im  7+0im  0+0im  3+3im
 0+0im  9+0im  0+0im  1+0im  0+0im
 2+2im  0+0im  3-3im  0+0im  4+0im
\end{minted}

Note that \texttt{Hupper} will not be equal to \texttt{Hlower} unless \texttt{A} is itself Hermitian (e.g. if \texttt{A == A{\textquotesingle}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L58-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17017578003271911360}{} 
\hyperlink{17017578003271911360}{\texttt{Base.LinAlg.LowerTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LowerTriangular(A::AbstractMatrix)
\end{lstlisting}

Construct a \texttt{LowerTriangular} view of the the matrix \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> LowerTriangular(A)
3×3 LowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  5.0   ⋅
 7.0  8.0  9.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/triangular.jl#L53-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1757421215459158076}{} 
\hyperlink{1757421215459158076}{\texttt{Base.LinAlg.UpperTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UpperTriangular(A::AbstractMatrix)
\end{lstlisting}

Construct an \texttt{UpperTriangular} view of the the matrix \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> UpperTriangular(A)
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   5.0  6.0
  ⋅    ⋅   9.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/triangular.jl#L75-L95}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5641050131194212876}{} 
\hyperlink{5641050131194212876}{\texttt{Base.LinAlg.lu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lu(A, pivot=Val{true}) -> L, U, p
\end{lstlisting}

Compute the LU factorization of \texttt{A}, such that \texttt{A[p,:] = L*U}. By default, pivoting is used. This can be overridden by passing \texttt{Val\{false\}} for the second argument.

See also \hyperlink{2935598995290090141}{\texttt{lufact}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4. 3.; 6. 3.]
2×2 Array{Float64,2}:
 4.0  3.0
 6.0  3.0

julia> L, U, p = lu(A)
([1.0 0.0; 0.666667 1.0], [6.0 3.0; 0.0 1.0], [2, 1])

julia> A[p, :] == L * U
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lu.jl#L165-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2935598995290090141}{} 
\hyperlink{2935598995290090141}{\texttt{Base.LinAlg.lufact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lufact(A [,pivot=Val{true}]) -> F::LU
\end{lstlisting}

Compute the LU factorization of \texttt{A}.

In most cases, if \texttt{A} is a subtype \texttt{S} of \texttt{AbstractMatrix\{T\}} with an element type \texttt{T} supporting \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/}, the return type is \texttt{LU\{T,S\{T\}\}}. If pivoting is chosen (default) the element type should also support \texttt{abs} and \texttt{<}.

The individual components of the factorization \texttt{F} can be accessed by indexing:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Component & Description \\
\hline
\texttt{F[:L]} & \texttt{L} (lower triangular) part of \texttt{LU} \\
\hline
\texttt{F[:U]} & \texttt{U} (upper triangular) part of \texttt{LU} \\
\hline
\texttt{F[:p]} & (right) permutation \texttt{Vector} \\
\hline
\texttt{F[:P]} & (right) permutation \texttt{Matrix} \\
\hline
\end{tabulary}

\end{table}

The relationship between \texttt{F} and \texttt{A} is

\texttt{F[:L]*F[:U] == A[F[:p], :]}

\texttt{F} further supports the following functions:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Supported function & \texttt{LU} & \texttt{LU\{T,Tridiagonal\{T\}\}} \\
\hline
\hyperlink{4103478871488785445}{\texttt{/}} & ✓ &  \\
\hline
\hyperlink{11203908042914658075}{\texttt{{\textbackslash}}} & ✓ & ✓ \\
\hline
\hyperlink{3226902477371958750}{\texttt{cond}} & ✓ &  \\
\hline
\hyperlink{9013378623280719296}{\texttt{inv}} & ✓ & ✓ \\
\hline
\hyperlink{1300265042345987014}{\texttt{det}} & ✓ & ✓ \\
\hline
\hyperlink{6649271058375699908}{\texttt{logdet}} & ✓ & ✓ \\
\hline
\hyperlink{17670285292397317614}{\texttt{logabsdet}} & ✓ & ✓ \\
\hline
\hyperlink{17888996102305087038}{\texttt{size}} & ✓ & ✓ \\
\hline
\end{tabulary}

\end{table}

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia> F = lufact(A)
Base.LinAlg.LU{Float64,Array{Float64,2}} with factors L and U:
[1.0 0.0; 1.5 1.0]
[4.0 3.0; 0.0 -1.5]

julia> F[:L] * F[:U] == A[F[:p], :]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lu.jl#L86-L138}{\texttt{source}}



\begin{lstlisting}
lufact(A::SparseMatrixCSC) -> F::UmfpackLU
\end{lstlisting}

Compute the LU factorization of a sparse matrix \texttt{A}.

For sparse \texttt{A} with real or complex element type, the return type of \texttt{F} is \texttt{UmfpackLU\{Tv, Ti\}}, with \texttt{Tv} = \hyperlink{5027751419500983000}{\texttt{Float64}} or \texttt{Complex128} respectively and \texttt{Ti} is an integer type (\hyperlink{10103694114785108551}{\texttt{Int32}} or \hyperlink{7720564657383125058}{\texttt{Int64}}).

The individual components of the factorization \texttt{F} can be accessed by indexing:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Component & Description \\
\hline
\texttt{F[:L]} & \texttt{L} (lower triangular) part of \texttt{LU} \\
\hline
\texttt{F[:U]} & \texttt{U} (upper triangular) part of \texttt{LU} \\
\hline
\texttt{F[:p]} & right permutation \texttt{Vector} \\
\hline
\texttt{F[:q]} & left permutation \texttt{Vector} \\
\hline
\texttt{F[:Rs]} & \texttt{Vector} of scaling factors \\
\hline
\texttt{F[:(:)]} & \texttt{(L,U,p,q,Rs)} components \\
\hline
\end{tabulary}

\end{table}

The relation between \texttt{F} and \texttt{A} is

\texttt{F[:L]*F[:U] == (F[:Rs] .* A)[F[:p], F[:q]]}

\texttt{F} further supports the following functions:

\begin{itemize}
\item \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}


\item \hyperlink{3226902477371958750}{\texttt{cond}}


\item \hyperlink{1300265042345987014}{\texttt{det}}

\end{itemize}
\begin{quote}
\textbf{Note}

\texttt{lufact(A::SparseMatrixCSC)} uses the UMFPACK library that is part of SuiteSparse. As this library only supports sparse matrices with \hyperlink{5027751419500983000}{\texttt{Float64}} or \texttt{Complex128} elements, \texttt{lufact} converts \texttt{A} into a copy that is of type \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/umfpack.jl#L104-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9520029296647984269}{} 
\hyperlink{9520029296647984269}{\texttt{Base.LinAlg.lufact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lufact!(A, pivot=Val{true}) -> LU
\end{lstlisting}

\texttt{lufact!} is the same as \hyperlink{2935598995290090141}{\texttt{lufact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lu.jl#L23-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10590134875878680645}{} 
\hyperlink{10590134875878680645}{\texttt{Base.LinAlg.chol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chol(A) -> U
\end{lstlisting}

Compute the Cholesky factorization of a positive definite matrix \texttt{A} and return the \hyperlink{1757421215459158076}{\texttt{UpperTriangular}} matrix \texttt{U} such that \texttt{A = U{\textquotesingle}U}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 2.; 2. 50.]
2×2 Array{Float64,2}:
 1.0   2.0
 2.0  50.0

julia> U = chol(A)
2×2 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0
  ⋅   6.78233

julia> U'U
2×2 Array{Float64,2}:
 1.0   2.0
 2.0  50.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L159-L183}{\texttt{source}}



\begin{lstlisting}
chol(x::Number) -> y
\end{lstlisting}

Compute the square root of a non-negative number \texttt{x}.

\textbf{Example}


\begin{minted}{jlcon}
julia> chol(16)
4.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L190-L201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12805335348758675309}{} 
\hyperlink{12805335348758675309}{\texttt{Base.LinAlg.cholfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cholfact(A, [uplo::Symbol,] Val{false}) -> Cholesky
\end{lstlisting}

Compute the Cholesky factorization of a dense symmetric positive definite matrix \texttt{A} and return a \texttt{Cholesky} factorization. The matrix \texttt{A} can either be a \hyperlink{10155539409143226179}{\texttt{Symmetric}} or \hyperlink{11943711269274284831}{\texttt{Hermitian}} \texttt{StridedMatrix} or a \emph{perfectly} symmetric or Hermitian \texttt{StridedMatrix}. In the latter case, the optional argument \texttt{uplo} may be \texttt{:L} for using the lower part or \texttt{:U} for the upper part of \texttt{A}. The default is to use \texttt{:U}. The triangular Cholesky factor can be obtained from the factorization \texttt{F} with: \texttt{F[:L]} and \texttt{F[:U]}. The following functions are available for \texttt{Cholesky} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}, \hyperlink{9013378623280719296}{\texttt{inv}}, and \hyperlink{1300265042345987014}{\texttt{det}}. A \texttt{PosDefException} exception is thrown in case the matrix is not positive definite.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia> C = cholfact(A)
Base.LinAlg.Cholesky{Float64,Array{Float64,2}} with factor:
[2.0 6.0 -8.0; 0.0 1.0 5.0; 0.0 0.0 3.0]

julia> C[:U]
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C[:L]
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia> C[:L] * C[:U] == A
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L297-L338}{\texttt{source}}



\begin{lstlisting}
cholfact(A, [uplo::Symbol,] Val{true}; tol = 0.0) -> CholeskyPivoted
\end{lstlisting}

Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix \texttt{A} and return a \texttt{CholeskyPivoted} factorization. The matrix \texttt{A} can either be a \hyperlink{10155539409143226179}{\texttt{Symmetric}} or \hyperlink{11943711269274284831}{\texttt{Hermitian}} \texttt{StridedMatrix} or a \emph{perfectly} symmetric or Hermitian \texttt{StridedMatrix}. In the latter case, the optional argument \texttt{uplo} may be \texttt{:L} for using the lower part or \texttt{:U} for the upper part of \texttt{A}. The default is to use \texttt{:U}. The triangular Cholesky factor can be obtained from the factorization \texttt{F} with: \texttt{F[:L]} and \texttt{F[:U]}. The following functions are available for \texttt{PivotedCholesky} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}, \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{2947138922560424828}{\texttt{rank}}. The argument \texttt{tol} determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L363-L376}{\texttt{source}}



\begin{lstlisting}
cholfact(A; shift = 0.0, perm = Int[]) -> CHOLMOD.Factor
\end{lstlisting}

Compute the Cholesky factorization of a sparse positive definite matrix \texttt{A}. \texttt{A} must be a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} or a \hyperlink{10155539409143226179}{\texttt{Symmetric}}/\hyperlink{11943711269274284831}{\texttt{Hermitian}} view of a \texttt{SparseMatrixCSC}. Note that even if \texttt{A} doesn{\textquotesingle}t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. \texttt{F = cholfact(A)} is most frequently used to solve systems of equations with \texttt{F{\textbackslash}b}, but also the methods \hyperlink{6899395651203530298}{\texttt{diag}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{6649271058375699908}{\texttt{logdet}} are defined for \texttt{F}. You can also extract individual factors from \texttt{F}, using \texttt{F[:L]}. However, since pivoting is on by default, the factorization is internally represented as \texttt{A == P{\textquotesingle}*L*L{\textquotesingle}*P} with a permutation matrix \texttt{P}; using just \texttt{L} without accounting for \texttt{P} will give incorrect answers. To include the effects of permutation, it{\textquotesingle}s typically preferable to extract {\textquotedbl}combined{\textquotedbl} factors like \texttt{PtL = F[:PtL]} (the equivalent of \texttt{P{\textquotesingle}*L}) and \texttt{LtP = F[:UP]} (the equivalent of \texttt{L{\textquotesingle}*P}).

Setting the optional \texttt{shift} keyword argument computes the factorization of \texttt{A+shift*I} instead of \texttt{A}. If the \texttt{perm} argument is nonempty, it should be a permutation of \texttt{1:size(A,1)} giving the ordering to use (instead of CHOLMOD{\textquotesingle}s default AMD ordering).

\begin{quote}
\textbf{Note}

This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

Many other functions from CHOLMOD are wrapped but not exported from the \texttt{Base.SparseArrays.CHOLMOD} module.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/cholmod.jl#L1405-L1437}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10240500374693163240}{} 
\hyperlink{10240500374693163240}{\texttt{Base.LinAlg.cholfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cholfact!(A, [uplo::Symbol,] Val{false}) -> Cholesky
\end{lstlisting}

The same as \hyperlink{12805335348758675309}{\texttt{cholfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia> cholfact!(A)
ERROR: InexactError()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L225-L244}{\texttt{source}}



\begin{lstlisting}
cholfact!(A, [uplo::Symbol,] Val{true}; tol = 0.0) -> CholeskyPivoted
\end{lstlisting}

The same as \hyperlink{12805335348758675309}{\texttt{cholfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L275-L282}{\texttt{source}}



\begin{lstlisting}
cholfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor
\end{lstlisting}

Compute the Cholesky (\(LL'\)) factorization of \texttt{A}, reusing the symbolic factorization \texttt{F}. \texttt{A} must be a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} or a \hyperlink{10155539409143226179}{\texttt{Symmetric}}/ \hyperlink{11943711269274284831}{\texttt{Hermitian}} view of a \texttt{SparseMatrixCSC}. Note that even if \texttt{A} doesn{\textquotesingle}t have the type tag, it must still be symmetric or Hermitian.

See also \hyperlink{12805335348758675309}{\texttt{cholfact}}.

\begin{quote}
\textbf{Note}

This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/cholmod.jl#L1364-L1379}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3937825551363289459}{} 
\hyperlink{3937825551363289459}{\texttt{Base.LinAlg.lowrankupdate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowrankupdate(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{lstlisting}

Update a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C[:U]{\textquotesingle}C[:U]} then \texttt{CC = cholfact(C[:U]{\textquotesingle}C[:U] + v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L653-L659}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13865582258179933244}{} 
\hyperlink{13865582258179933244}{\texttt{Base.LinAlg.lowrankdowndate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowrankdowndate(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{lstlisting}

Downdate a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C[:U]{\textquotesingle}C[:U]} then \texttt{CC = cholfact(C[:U]{\textquotesingle}C[:U] - v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L662-L668}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11734178108783656905}{} 
\hyperlink{11734178108783656905}{\texttt{Base.LinAlg.lowrankupdate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowrankupdate!(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{lstlisting}

Update a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C[:U]{\textquotesingle}C[:U]} then \texttt{CC = cholfact(C[:U]{\textquotesingle}C[:U] + v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations. The input factorization \texttt{C} is updated in place such that on exit \texttt{C == CC}. The vector \texttt{v} is destroyed during the computation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L554-L561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1035472772477102672}{} 
\hyperlink{1035472772477102672}{\texttt{Base.LinAlg.lowrankdowndate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowrankdowndate!(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{lstlisting}

Downdate a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C[:U]{\textquotesingle}C[:U]} then \texttt{CC = cholfact(C[:U]{\textquotesingle}C[:U] - v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations. The input factorization \texttt{C} is updated in place such that on exit \texttt{C == CC}. The vector \texttt{v} is destroyed during the computation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L600-L607}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17696382973019086267}{} 
\hyperlink{17696382973019086267}{\texttt{Base.LinAlg.ldltfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ldltfact(S::SymTridiagonal) -> LDLt
\end{lstlisting}

Compute an \texttt{LDLt} factorization of a real symmetric tridiagonal matrix such that \texttt{A = L*Diagonal(d)*L{\textquotesingle}} where \texttt{L} is a unit lower triangular matrix and \texttt{d} is a vector. The main use of an \texttt{LDLt} factorization \texttt{F = ldltfact(A)} is to solve the linear system of equations \texttt{Ax = b} with \texttt{F{\textbackslash}b}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/ldlt.jl#L35-L41}{\texttt{source}}



\begin{lstlisting}
ldltfact(A; shift = 0.0, perm=Int[]) -> CHOLMOD.Factor
\end{lstlisting}

Compute the \(LDL'\) factorization of a sparse matrix \texttt{A}. \texttt{A} must be a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} or a \hyperlink{10155539409143226179}{\texttt{Symmetric}}/\hyperlink{11943711269274284831}{\texttt{Hermitian}} view of a \texttt{SparseMatrixCSC}. Note that even if \texttt{A} doesn{\textquotesingle}t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. \texttt{F = ldltfact(A)} is most frequently used to solve systems of equations \texttt{A*x = b} with \texttt{F{\textbackslash}b}. The returned factorization object \texttt{F} also supports the methods \hyperlink{6899395651203530298}{\texttt{diag}}, \hyperlink{1300265042345987014}{\texttt{det}}, \hyperlink{6649271058375699908}{\texttt{logdet}}, and \hyperlink{9013378623280719296}{\texttt{inv}}. You can extract individual factors from \texttt{F} using \texttt{F[:L]}. However, since pivoting is on by default, the factorization is internally represented as \texttt{A == P{\textquotesingle}*L*D*L{\textquotesingle}*P} with a permutation matrix \texttt{P}; using just \texttt{L} without accounting for \texttt{P} will give incorrect answers. To include the effects of permutation, it is typically preferable to extract {\textquotedbl}combined{\textquotedbl} factors like \texttt{PtL = F[:PtL]} (the equivalent of \texttt{P{\textquotesingle}*L}) and \texttt{LtP = F[:UP]} (the equivalent of \texttt{L{\textquotesingle}*P}). The complete list of supported factors is \texttt{:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP}.

Setting the optional \texttt{shift} keyword argument computes the factorization of \texttt{A+shift*I} instead of \texttt{A}. If the \texttt{perm} argument is nonempty, it should be a permutation of \texttt{1:size(A,1)} giving the ordering to use (instead of CHOLMOD{\textquotesingle}s default AMD ordering).

\begin{quote}
\textbf{Note}

This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

Many other functions from CHOLMOD are wrapped but not exported from the \texttt{Base.SparseArrays.CHOLMOD} module.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/cholmod.jl#L1504-L1537}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6125312741908639126}{} 
\hyperlink{6125312741908639126}{\texttt{Base.LinAlg.ldltfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ldltfact!(S::SymTridiagonal) -> LDLt
\end{lstlisting}

Same as \hyperlink{17696382973019086267}{\texttt{ldltfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/ldlt.jl#L19-L23}{\texttt{source}}



\begin{lstlisting}
ldltfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor
\end{lstlisting}

Compute the \(LDL'\) factorization of \texttt{A}, reusing the symbolic factorization \texttt{F}. \texttt{A} must be a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} or a \hyperlink{10155539409143226179}{\texttt{Symmetric}}/\hyperlink{11943711269274284831}{\texttt{Hermitian}} view of a \texttt{SparseMatrixCSC}. Note that even if \texttt{A} doesn{\textquotesingle}t have the type tag, it must still be symmetric or Hermitian.

See also \hyperlink{17696382973019086267}{\texttt{ldltfact}}.

\begin{quote}
\textbf{Note}

This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/cholmod.jl#L1456-L1471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{557719280469347572}{} 
\hyperlink{557719280469347572}{\texttt{Base.LinAlg.qr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
qr(A, pivot=Val{false}; thin::Bool=true) -> Q, R, [p]
\end{lstlisting}

Compute the (pivoted) QR factorization of \texttt{A} such that either \texttt{A = Q*R} or \texttt{A[:,p] = Q*R}. Also see \hyperlink{16170416021894488810}{\texttt{qrfact}}. The default is to compute a thin factorization. Note that \texttt{R} is not extended with zeros when the full \texttt{Q} is requested.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L285-L292}{\texttt{source}}



\begin{lstlisting}
qr(v::AbstractVector) -> w, r
\end{lstlisting}

Computes the polar decomposition of a vector. Returns \texttt{w}, a unit vector in the direction of \texttt{v}, and \texttt{r}, the norm of \texttt{v}.

See also \hyperlink{10075112191110723412}{\texttt{normalize}}, \hyperlink{5105121074825158846}{\texttt{normalize!}}, and \hyperlink{18372997142167679564}{\texttt{LinAlg.qr!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia> w, r = qr(v)
([0.447214, 0.894427], 2.23606797749979)

julia> w*r == v
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L304-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18372997142167679564}{} 
\hyperlink{18372997142167679564}{\texttt{Base.LinAlg.qr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LinAlg.qr!(v::AbstractVector) -> w, r
\end{lstlisting}

Computes the polar decomposition of a vector. Instead of returning a new vector as \texttt{qr(v::AbstractVector)}, this function mutates the input vector \texttt{v} in place. Returns \texttt{w}, a unit vector in the direction of \texttt{v} (this is a mutation of \texttt{v}), and \texttt{r}, the norm of \texttt{v}.

See also \hyperlink{10075112191110723412}{\texttt{normalize}}, \hyperlink{5105121074825158846}{\texttt{normalize!}}, and \hyperlink{557719280469347572}{\texttt{qr}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L340-L350}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16170416021894488810}{} 
\hyperlink{16170416021894488810}{\texttt{Base.LinAlg.qrfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
qrfact(A, pivot=Val{false}) -> F
\end{lstlisting}

Compute the QR factorization of the matrix \texttt{A}: an orthogonal (or unitary if \texttt{A} is complex-valued) matrix \texttt{Q}, and an upper triangular matrix \texttt{R} such that

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
The returned object \texttt{F} stores the factorization in a packed format:

\begin{itemize}
\item if \texttt{pivot == Val\{true\}} then \texttt{F} is a \hyperlink{7934860800976993126}{\texttt{QRPivoted}} object,


\item otherwise if the element type of \texttt{A} is a BLAS type (\hyperlink{8101639384272933082}{\texttt{Float32}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, \texttt{Complex64} or \texttt{Complex128}), then \texttt{F} is a \hyperlink{18189258812560098941}{\texttt{QRCompactWY}} object,


\item otherwise \texttt{F} is a \hyperlink{6169365281542139873}{\texttt{QR}} object.

\end{itemize}
The individual components of the factorization \texttt{F} can be accessed by indexing with a symbol:

\begin{itemize}
\item \texttt{F[:Q]}: the orthogonal/unitary matrix \texttt{Q}


\item \texttt{F[:R]}: the upper triangular matrix \texttt{R}


\item \texttt{F[:p]}: the permutation vector of the pivot (\hyperlink{7934860800976993126}{\texttt{QRPivoted}} only)


\item \texttt{F[:P]}: the permutation matrix of the pivot (\hyperlink{7934860800976993126}{\texttt{QRPivoted}} only)

\end{itemize}
The following functions are available for the \texttt{QR} objects: \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{17888996102305087038}{\texttt{size}}, and \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}. When \texttt{A} is rectangular, \texttt{{\textbackslash}} will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.

Multiplication with respect to either thin or full \texttt{Q} is allowed, i.e. both \texttt{F[:Q]*F[:R]} and \texttt{F[:Q]*A} are supported. A \texttt{Q} matrix can be converted into a regular matrix with \hyperlink{6442668105237896007}{\texttt{full}} which has a named argument \texttt{thin}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia> F = qrfact(A)
Base.LinAlg.QRCompactWY{Float64,Array{Float64,2}} with factors Q and R:
[-0.6 0.0 0.8; -0.8 0.0 -0.6; 0.0 -1.0 0.0]
[-5.0 10.0; 0.0 -1.0]

julia> F[:Q] * F[:R] == A
true
\end{minted}

\begin{quote}
\textbf{Note}

\texttt{qrfact} returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the \texttt{Q} and \texttt{R} matrices can be stored compactly rather as two separate dense matrices.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L215-L272}{\texttt{source}}



\begin{lstlisting}
qrfact(A) -> SPQR.Factorization
\end{lstlisting}

Compute the \texttt{QR} factorization of a sparse matrix \texttt{A}. A fill-reducing permutation is used. The main application of this type is to solve least squares problems with \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}. The function calls the C library SPQR and a few additional functions from the library are wrapped but not exported.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/spqr.jl#L142-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17675636264317375637}{} 
\hyperlink{17675636264317375637}{\texttt{Base.LinAlg.qrfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
qrfact!(A, pivot=Val{false})
\end{lstlisting}

\texttt{qrfact!} is the same as \hyperlink{16170416021894488810}{\texttt{qrfact}} when \texttt{A} is a subtype of \texttt{StridedMatrix}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L203-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6169365281542139873}{} 
\hyperlink{6169365281542139873}{\texttt{Base.LinAlg.QR}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
QR <: Factorization
\end{lstlisting}

A QR matrix factorization stored in a packed format, typically obtained from \hyperlink{16170416021894488810}{\texttt{qrfact}}. If \(A\) is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
where \(Q\) is an orthogonal/unitary matrix and \(R\) is upper triangular. The matrix \(Q\) is stored as a sequence of Householder reflectors \(v_i\) and coefficients \(\tau_i\) where:

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\end{split}\end{equation*}
The object has two fields:

\begin{itemize}
\item \texttt{factors} is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of \(R\), that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors \(v_i\) stored in a packed format where \(v_i\) is the \(i\)th column of the matrix \texttt{V = eye(m,n) + tril(F.factors,-1)}.

\end{itemize}

\item \texttt{τ} is a vector  of length \texttt{min(m,n)} containing the coefficients \(au_i\).

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L4-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18189258812560098941}{} 
\hyperlink{18189258812560098941}{\texttt{Base.LinAlg.QRCompactWY}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
QRCompactWY <: Factorization
\end{lstlisting}

A QR matrix factorization stored in a compact blocked format, typically obtained from \hyperlink{16170416021894488810}{\texttt{qrfact}}. If \(A\) is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
where \(Q\) is an orthogonal/unitary matrix and \(R\) is upper triangular. It is similar to the \hyperlink{6169365281542139873}{\texttt{QR}} format except that the orthogonal/unitary matrix \(Q\) is stored in \emph{Compact WY} format \footnotemark[1], as a lower trapezoidal matrix \(V\) and an upper triangular matrix \(T\) where

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T) = I - V T V^T\end{split}\end{equation*}
such that \(v_i\) is the \(i\)th column of \(V\), and \(au_i\) is the \(i\)th diagonal element of \(T\).

The object has two fields:

\begin{itemize}
\item \texttt{factors}, as in the \hyperlink{6169365281542139873}{\texttt{QR}} type, is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of \(R\), that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors \(v_i\) stored in a packed format such that \texttt{V = eye(m,n) + tril(F.factors,-1)}.

\end{itemize}

\item \texttt{T} is a square matrix with \texttt{min(m,n)} columns, whose upper triangular part gives the matrix \(T\) above (the subdiagonal elements are ignored).

\end{itemize}
\begin{quote}
\textbf{Note}

This format should not to be confused with the older \emph{WY} representation \footnotemark[2].

\end{quote}
\footnotetext[2]{C Bischof and C Van Loan, {\textquotedbl}The WY representation for products of Householder matrices{\textquotedbl}, SIAM J Sci Stat Comput 8 (1987), s2-s13. \href{http://dx.doi.org/10.1137/0908009}{doi:10.1137/0908009}

}
\footnotetext[1]{R Schreiber and C Van Loan, {\textquotedbl}A storage-efficient WY representation for products of Householder transformations{\textquotedbl}, SIAM J Sci Stat Comput 10 (1989), 53-57. \href{http://dx.doi.org/10.1137/0910005}{doi:10.1137/0910005}

}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L43-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7934860800976993126}{} 
\hyperlink{7934860800976993126}{\texttt{Base.LinAlg.QRPivoted}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
QRPivoted <: Factorization
\end{lstlisting}

A QR matrix factorization with column pivoting in a packed format, typically obtained from \hyperlink{16170416021894488810}{\texttt{qrfact}}. If \(A\) is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A P = Q R\end{split}\end{equation*}
where \(P\) is a permutation matrix, \(Q\) is an orthogonal/unitary matrix and \(R\) is upper triangular. The matrix \(Q\) is stored as a sequence of Householder reflectors:

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\end{split}\end{equation*}
The object has three fields:

\begin{itemize}
\item \texttt{factors} is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of \(R\), that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors \(v_i\) stored in a packed format where \(v_i\) is the \(i\)th column of the matrix \texttt{V = eye(m,n) + tril(F.factors,-1)}.

\end{itemize}

\item \texttt{τ} is a vector of length \texttt{min(m,n)} containing the coefficients \(au_i\).


\item \texttt{jpvt} is an integer vector of length \texttt{n} corresponding to the permutation \(P\).

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L95-L125}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11443624932714046641}{} 
\hyperlink{11443624932714046641}{\texttt{Base.LinAlg.lqfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lqfact!(A) -> LQ
\end{lstlisting}

Compute the LQ factorization of \texttt{A}, using the input matrix as a workspace. See also \hyperlink{8845557553836336789}{\texttt{lq}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lq.jl#L20-L25}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16205636631154816684}{} 
\hyperlink{16205636631154816684}{\texttt{Base.LinAlg.lqfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lqfact(A) -> LQ
\end{lstlisting}

Compute the LQ factorization of \texttt{A}. See also \hyperlink{8845557553836336789}{\texttt{lq}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lq.jl#L27-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8845557553836336789}{} 
\hyperlink{8845557553836336789}{\texttt{Base.LinAlg.lq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lq(A; [thin=true]) -> L, Q
\end{lstlisting}

Perform an LQ factorization of \texttt{A} such that \texttt{A = L*Q}. The default is to compute a thin factorization. The LQ factorization is the QR factorization of \texttt{A.{\textquotesingle}}. \texttt{L} is not extended with zeros if the full \texttt{Q} is requested.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lq.jl#L35-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16689081380067534909}{} 
\hyperlink{16689081380067534909}{\texttt{Base.LinAlg.bkfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bkfact(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -> BunchKaufman
\end{lstlisting}

Compute the Bunch-Kaufman \footnotemark[3] factorization of a symmetric or Hermitian matrix \texttt{A} and return a \texttt{BunchKaufman} object. \texttt{uplo} indicates which triangle of matrix \texttt{A} to reference. If \texttt{symmetric} is \texttt{true}, \texttt{A} is assumed to be symmetric. If \texttt{symmetric} is \texttt{false}, \texttt{A} is assumed to be Hermitian. If \texttt{rook} is \texttt{true}, rook pivoting is used. If \texttt{rook} is false, rook pivoting is not used. The following functions are available for \texttt{BunchKaufman} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \texttt{{\textbackslash}}, \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{16421003133250542616}{\texttt{issymmetric}}, \hyperlink{12800362927453768899}{\texttt{ishermitian}}.

\footnotetext[3]{J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. \href{http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/}{url}.

}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bunchkaufman.jl#L57-L71}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5215931628001847512}{} 
\hyperlink{5215931628001847512}{\texttt{Base.LinAlg.bkfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bkfact!(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -> BunchKaufman
\end{lstlisting}

\texttt{bkfact!} is the same as \hyperlink{16689081380067534909}{\texttt{bkfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bunchkaufman.jl#L19-L24}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14864609220164435086}{} 
\hyperlink{14864609220164435086}{\texttt{Base.LinAlg.eig}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eig(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> D, V
eig(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> D, V
eig(A, permute::Bool=true, scale::Bool=true) -> D, V
\end{lstlisting}

Computes eigenvalues (\texttt{D}) and eigenvectors (\texttt{V}) of \texttt{A}. See \hyperlink{18133897359296222402}{\texttt{eigfact}} for details on the \texttt{irange}, \texttt{vl}, and \texttt{vu} arguments (for \hyperlink{14121197223449931750}{\texttt{SymTridiagonal}}, \texttt{Hermitian}, and \texttt{Symmetric} matrices) and the \texttt{permute} and \texttt{scale} keyword arguments. The eigenvectors are returned columnwise.

\textbf{Example}


\begin{minted}{jlcon}
julia> eig([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
\end{minted}

\texttt{eig} is a wrapper around \hyperlink{18133897359296222402}{\texttt{eigfact}}, extracting all parts of the factorization to a tuple; where possible, using \hyperlink{18133897359296222402}{\texttt{eigfact}} is recommended.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L112-L134}{\texttt{source}}



\begin{lstlisting}
eig(A, B) -> D, V
\end{lstlisting}

Computes generalized eigenvalues (\texttt{D}) and vectors (\texttt{V}) of \texttt{A} with respect to \texttt{B}.

\texttt{eig} is a wrapper around \hyperlink{18133897359296222402}{\texttt{eigfact}}, extracting all parts of the factorization to a tuple; where possible, using \hyperlink{18133897359296222402}{\texttt{eigfact}} is recommended.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eig(A, B)
(Complex{Float64}[0.0+1.0im, 0.0-1.0im], Complex{Float64}[0.0-1.0im 0.0+1.0im; -1.0-0.0im -1.0+0.0im])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L333-L357}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3176364577236723896}{} 
\hyperlink{3176364577236723896}{\texttt{Base.LinAlg.eigvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigvals(A; permute::Bool=true, scale::Bool=true) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}.

For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is \texttt{true} for both options.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L181-L191}{\texttt{source}}



\begin{lstlisting}
eigvals(A, B) -> values
\end{lstlisting}

Computes the generalized eigenvalues of \texttt{A} and \texttt{B}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eigvals(A,B)
2-element Array{Complex{Float64},1}:
 0.0+1.0im
 0.0-1.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L383-L406}{\texttt{source}}



\begin{lstlisting}
eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}. It is possible to calculate only a subset of the eigenvalues by specifying a \texttt{UnitRange} \texttt{irange} covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A, 2:2)
1-element Array{Float64,1}:
 1.0

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.14005
  1.0
  5.14005
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L366-L390}{\texttt{source}}



\begin{lstlisting}
eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}. It is possible to calculate only a subset of the eigenvalues by specifying a pair \texttt{vl} and \texttt{vu} for the lower and upper boundaries of the eigenvalues.


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A, -1, 2)
1-element Array{Float64,1}:
 1.0

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.14005
  1.0
  5.14005
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L406-L429}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3807894261210511240}{} 
\hyperlink{3807894261210511240}{\texttt{Base.LinAlg.eigvals!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigvals!(A; permute::Bool=true, scale::Bool=true) -> values
\end{lstlisting}

Same as \hyperlink{3176364577236723896}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L163-L170}{\texttt{source}}



\begin{lstlisting}
eigvals!(A, B) -> values
\end{lstlisting}

Same as \hyperlink{3176364577236723896}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A} (and \texttt{B}), instead of creating copies.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L367-L371}{\texttt{source}}



\begin{lstlisting}
eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values
\end{lstlisting}

Same as \hyperlink{3176364577236723896}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. \texttt{irange} is a range of eigenvalue \emph{indices} to search for - for instance, the 2nd to 8th eigenvalues.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L357-L362}{\texttt{source}}



\begin{lstlisting}
eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values
\end{lstlisting}

Same as \hyperlink{3176364577236723896}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. \texttt{vl} is the lower bound of the interval to search for eigenvalues, and \texttt{vu} is the upper bound.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L397-L402}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2002481541828933425}{} 
\hyperlink{2002481541828933425}{\texttt{Base.LinAlg.eigmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigmax(A; permute::Bool=true, scale::Bool=true)
\end{lstlisting}

Returns the largest eigenvalue of \texttt{A}. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of \texttt{A} are complex, this method will fail, since complex numbers cannot be sorted.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia> eigmax(A)
1.0

julia> A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia> eigmax(A)
ERROR: DomainError:
Stacktrace:
 [1] #eigmax#46(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:238
 [2] eigmax(::Array{Complex{Int64},2}) at ./linalg/eigen.jl:236
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L201-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3000514364430926525}{} 
\hyperlink{3000514364430926525}{\texttt{Base.LinAlg.eigmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigmin(A; permute::Bool=true, scale::Bool=true)
\end{lstlisting}

Returns the smallest eigenvalue of \texttt{A}. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of \texttt{A} are complex, this method will fail, since complex numbers cannot be sorted.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia> eigmin(A)
-1.0

julia> A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia> eigmin(A)
ERROR: DomainError:
Stacktrace:
 [1] #eigmin#47(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:280
 [2] eigmin(::Array{Complex{Int64},2}) at ./linalg/eigen.jl:278
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L243-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13341009863130381110}{} 
\hyperlink{13341009863130381110}{\texttt{Base.LinAlg.eigvecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigvecs(A::SymTridiagonal[, eigvals]) -> Matrix
\end{lstlisting}

Returns a matrix \texttt{M} whose columns are the eigenvectors of \texttt{A}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.)

If the optional vector of eigenvalues \texttt{eigvals} is specified, \texttt{eigvecs} returns the specific corresponding eigenvectors.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.14005
  1.0
  5.14005

julia> eigvecs(A)
3×3 Array{Float64,2}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia> eigvecs(A, [1.])
3×1 Array{Float64,2}:
  0.83205
  4.26351e-17
 -0.5547
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/tridiag.jl#L212-L248}{\texttt{source}}



\begin{lstlisting}
eigvecs(A; permute::Bool=true, scale::Bool=true) -> Matrix
\end{lstlisting}

Returns a matrix \texttt{M} whose columns are the eigenvectors of \texttt{A}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.) The \texttt{permute} and \texttt{scale} keywords are the same as for \hyperlink{18133897359296222402}{\texttt{eigfact}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L140-L156}{\texttt{source}}



\begin{lstlisting}
eigvecs(A, B) -> Matrix
\end{lstlisting}

Returns a matrix \texttt{M} whose columns are the generalized eigenvectors of \texttt{A} and \texttt{B}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.)

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eigvecs(A, B)
2×2 Array{Complex{Float64},2}:
  0.0-1.0im   0.0+1.0im
 -1.0-0.0im  -1.0+0.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L412-L436}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18133897359296222402}{} 
\hyperlink{18133897359296222402}{\texttt{Base.LinAlg.eigfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigfact(A; permute::Bool=true, scale::Bool=true) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F[:values]} and the eigenvectors in the columns of the matrix \texttt{F[:vectors]}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F[:vectors][:, k]}.)

The following functions are available for \texttt{Eigen} objects: \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{10141753772895527781}{\texttt{isposdef}}.

For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is \texttt{true} for both options.

\textbf{Example}


\begin{minted}{jlcon}
julia> F = eigfact([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Base.LinAlg.Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia> F[:values]
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia> F[:vectors]
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L68-L100}{\texttt{source}}



\begin{lstlisting}
eigfact(A, B) -> GeneralizedEigen
\end{lstlisting}

Computes the generalized eigenvalue decomposition of \texttt{A} and \texttt{B}, returning a \texttt{GeneralizedEigen} factorization object \texttt{F} which contains the generalized eigenvalues in \texttt{F[:values]} and the generalized eigenvectors in the columns of the matrix \texttt{F[:vectors]}. (The \texttt{k}th generalized eigenvector can be obtained from the slice \texttt{F[:vectors][:, k]}.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L318-L325}{\texttt{source}}



\begin{lstlisting}
eigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F[:values]} and the eigenvectors in the columns of the matrix \texttt{F[:vectors]}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F[:vectors][:, k]}.)

The following functions are available for \texttt{Eigen} objects: \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{10141753772895527781}{\texttt{isposdef}}.

The \texttt{UnitRange} \texttt{irange} specifies indices of the sorted eigenvalues to search for.

\begin{quote}
\textbf{Note}

If \texttt{irange} is not \texttt{1:n}, where \texttt{n} is the dimension of \texttt{A}, then the returned factorization will be a \emph{truncated} factorization.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L303-L317}{\texttt{source}}



\begin{lstlisting}
eigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F[:values]} and the eigenvectors in the columns of the matrix \texttt{F[:vectors]}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F[:vectors][:, k]}.)

The following functions are available for \texttt{Eigen} objects: \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{10141753772895527781}{\texttt{isposdef}}.

\texttt{vl} is the lower bound of the window of eigenvalues to search for, and \texttt{vu} is the upper bound.

\begin{quote}
\textbf{Note}

If [\texttt{vl}, \texttt{vu}] does not contain all eigenvalues of \texttt{A}, then the returned factorization will be a \emph{truncated} factorization.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L327-L341}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14613994766560843660}{} 
\hyperlink{14613994766560843660}{\texttt{Base.LinAlg.eigfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigfact!(A, [B])
\end{lstlisting}

Same as \hyperlink{18133897359296222402}{\texttt{eigfact}}, but saves space by overwriting the input \texttt{A} (and \texttt{B}), instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12358799216183401879}{} 
\hyperlink{12358799216183401879}{\texttt{Base.LinAlg.hessfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hessfact(A) -> Hessenberg
\end{lstlisting}

Compute the Hessenberg decomposition of \texttt{A} and return a \texttt{Hessenberg} object. If \texttt{F} is the factorization object, the unitary matrix can be accessed with \texttt{F[:Q]} and the Hessenberg matrix with \texttt{F[:H]}. When \texttt{Q} is extracted, the resulting type is the \texttt{HessenbergQ} object, and may be converted to a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}}  (or \texttt{Array(\_)} for short).

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia> F = hessfact(A);

julia> F[:Q] * F[:H] * F[:Q]'
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/hessenberg.jl#L24-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10307666610329965165}{} 
\hyperlink{10307666610329965165}{\texttt{Base.LinAlg.hessfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hessfact!(A) -> Hessenberg
\end{lstlisting}

\texttt{hessfact!} is the same as \hyperlink{12358799216183401879}{\texttt{hessfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/hessenberg.jl#L14-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8161465521668732847}{} 
\hyperlink{8161465521668732847}{\texttt{Base.LinAlg.schurfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
schurfact(A::StridedMatrix) -> F::Schur
\end{lstlisting}

Computes the Schur factorization of the matrix \texttt{A}. The (quasi) triangular Schur factor can be obtained from the \texttt{Schur} object \texttt{F} with either \texttt{F[:Schur]} or \texttt{F[:T]} and the orthogonal/unitary Schur vectors can be obtained with \texttt{F[:vectors]} or \texttt{F[:Z]} such that \texttt{A = F[:vectors]*F[:Schur]*F[:vectors]{\textquotesingle}}. The eigenvalues of \texttt{A} can be obtained with \texttt{F[:values]}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [-2. 1. 3.; 2. 1. -1.; -7. 2. 7.]
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0

julia> F = schurfact(A)
Base.LinAlg.Schur{Float64,Array{Float64,2}} with factors T and Z:
[2.0 0.801792 6.63509; -8.55988e-11 2.0 8.08286; 0.0 0.0 1.99999]
[0.577351 0.154299 -0.801784; 0.577346 -0.77152 0.267262; 0.577354 0.617211 0.534522]
and values:
Complex{Float64}[2.0+8.28447e-6im, 2.0-8.28447e-6im, 1.99999+0.0im]

julia> F[:vectors] * F[:Schur] * F[:vectors]'
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L19-L49}{\texttt{source}}



\begin{lstlisting}
schurfact(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur
\end{lstlisting}

Computes the Generalized Schur (or QZ) factorization of the matrices \texttt{A} and \texttt{B}. The (quasi) triangular Schur factors can be obtained from the \texttt{Schur} object \texttt{F} with \texttt{F[:S]} and \texttt{F[:T]}, the left unitary/orthogonal Schur vectors can be obtained with \texttt{F[:left]} or \texttt{F[:Q]} and the right unitary/orthogonal Schur vectors can be obtained with \texttt{F[:right]} or \texttt{F[:Z]} such that \texttt{A=F[:left]*F[:S]*F[:right]{\textquotesingle}} and \texttt{B=F[:left]*F[:T]*F[:right]{\textquotesingle}}. The generalized eigenvalues of \texttt{A} and \texttt{B} can be obtained with \texttt{F[:alpha]./F[:beta]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L187-L196}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1502600911105385632}{} 
\hyperlink{1502600911105385632}{\texttt{Base.LinAlg.schurfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
schurfact!(A::StridedMatrix) -> F::Schur
\end{lstlisting}

Same as \hyperlink{8161465521668732847}{\texttt{schurfact}} but uses the input argument as workspace.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L12-L16}{\texttt{source}}



\begin{lstlisting}
schurfact!(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur
\end{lstlisting}

Same as \hyperlink{8161465521668732847}{\texttt{schurfact}} but uses the input matrices \texttt{A} and \texttt{B} as workspace.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L179-L183}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5448411964655904748}{} 
\hyperlink{5448411964655904748}{\texttt{Base.LinAlg.schur}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
schur(A::StridedMatrix) -> T::Matrix, Z::Matrix, λ::Vector
\end{lstlisting}

Computes the Schur factorization of the matrix \texttt{A}. The methods return the (quasi) triangular Schur factor \texttt{T} and the orthogonal/unitary Schur vectors \texttt{Z} such that \texttt{A = Z*T*Z{\textquotesingle}}. The eigenvalues of \texttt{A} are returned in the vector \texttt{λ}.

See \hyperlink{8161465521668732847}{\texttt{schurfact}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [-2. 1. 3.; 2. 1. -1.; -7. 2. 7.]
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0

julia> T, Z, lambda = schur(A)
([2.0 0.801792 6.63509; -8.55988e-11 2.0 8.08286; 0.0 0.0 1.99999], [0.577351 0.154299 -0.801784; 0.577346 -0.77152 0.267262; 0.577354 0.617211 0.534522], Complex{Float64}[2.0+8.28447e-6im, 2.0-8.28447e-6im, 1.99999+0.0im])

julia> Z * T * Z'
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L78-L105}{\texttt{source}}



\begin{lstlisting}
schur(A::StridedMatrix, B::StridedMatrix) -> S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector
\end{lstlisting}

See \hyperlink{8161465521668732847}{\texttt{schurfact}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L271-L275}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8963710124171619666}{} 
\hyperlink{8963710124171619666}{\texttt{Base.LinAlg.ordschur}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur
\end{lstlisting}

Reorders the Schur factorization \texttt{F} of a matrix \texttt{A = Z*T*Z{\textquotesingle}} according to the logical array \texttt{select} returning the reordered factorization \texttt{F} object. The selected eigenvalues appear in the leading diagonal of \texttt{F[:Schur]} and the corresponding leading columns of \texttt{F[:vectors]} form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via \texttt{select}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L128-L137}{\texttt{source}}



\begin{lstlisting}
ordschur(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -> T::StridedMatrix, Z::StridedMatrix, λ::Vector
\end{lstlisting}

Reorders the Schur factorization of a real matrix \texttt{A = Z*T*Z{\textquotesingle}} according to the logical array \texttt{select} returning the reordered matrices \texttt{T} and \texttt{Z} as well as the vector of eigenvalues \texttt{λ}. The selected eigenvalues appear in the leading diagonal of \texttt{T} and the corresponding leading columns of \texttt{Z} form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via \texttt{select}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L149-L158}{\texttt{source}}



\begin{lstlisting}
ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur
\end{lstlisting}

Reorders the Generalized Schur factorization \texttt{F} of a matrix pair \texttt{(A, B) = (Q*S*Z{\textquotesingle}, Q*T*Z{\textquotesingle})} according to the logical array \texttt{select} and returns a GeneralizedSchur object \texttt{F}. The selected eigenvalues appear in the leading diagonal of both \texttt{F[:S]} and \texttt{F[:T]}, and the left and right orthogonal/unitary Schur vectors are also reordered such that \texttt{(A, B) = F[:Q]*(F[:S], F[:T])*F[:Z]{\textquotesingle}} still holds and the generalized eigenvalues of \texttt{A} and \texttt{B} can still be obtained with \texttt{F[:alpha]./F[:beta]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L215-L224}{\texttt{source}}



\begin{lstlisting}
ordschur(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -> S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector
\end{lstlisting}

Reorders the Generalized Schur factorization of a matrix pair \texttt{(A, B) = (Q*S*Z{\textquotesingle}, Q*T*Z{\textquotesingle})} according to the logical array \texttt{select} and returns the matrices \texttt{S}, \texttt{T}, \texttt{Q}, \texttt{Z} and vectors \texttt{α} and \texttt{β}.  The selected eigenvalues appear in the leading diagonal of both \texttt{S} and \texttt{T}, and the left and right unitary/orthogonal Schur vectors are also reordered such that \texttt{(A, B) = Q*(S, T)*Z{\textquotesingle}} still holds and the generalized eigenvalues of \texttt{A} and \texttt{B} can still be obtained with \texttt{α./β}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L237-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6787239091599290339}{} 
\hyperlink{6787239091599290339}{\texttt{Base.LinAlg.ordschur!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur
\end{lstlisting}

Same as \hyperlink{8963710124171619666}{\texttt{ordschur}} but overwrites the factorization \texttt{F}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L117-L121}{\texttt{source}}



\begin{lstlisting}
ordschur!(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -> T::StridedMatrix, Z::StridedMatrix, λ::Vector
\end{lstlisting}

Same as \hyperlink{8963710124171619666}{\texttt{ordschur}} but overwrites the input arguments.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L141-L145}{\texttt{source}}



\begin{lstlisting}
ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur
\end{lstlisting}

Same as \texttt{ordschur} but overwrites the factorization \texttt{F}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L203-L207}{\texttt{source}}



\begin{lstlisting}
ordschur!(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -> S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector
\end{lstlisting}

Same as \hyperlink{8963710124171619666}{\texttt{ordschur}} but overwrites the factorization the input arguments.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L228-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1135051488165556244}{} 
\hyperlink{1135051488165556244}{\texttt{Base.LinAlg.svdfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svdfact(A; thin::Bool=true) -> SVD
\end{lstlisting}

Compute the singular value decomposition (SVD) of \texttt{A} and return an \texttt{SVD} object.

\texttt{U}, \texttt{S}, \texttt{V} and \texttt{Vt} can be obtained from the factorization \texttt{F} with \texttt{F[:U]}, \texttt{F[:S]}, \texttt{F[:V]} and \texttt{F[:Vt]}, such that \texttt{A = U*diagm(S)*Vt}. The algorithm produces \texttt{Vt} and hence \texttt{Vt} is more efficient to extract than \texttt{V}. The singular values in \texttt{S} are sorted in descending order.

If \texttt{thin=true} (default), a thin SVD is returned. For a \(M \times N\) matrix \texttt{A}, \texttt{U} is \(M \times M\) for a full SVD (\texttt{thin=false}) and \(M \times \min(M, N)\) for a thin SVD.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> F = svdfact(A)
Base.LinAlg.SVD{Float64,Float64,Array{Float64,2}}([0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0; 0.0 0.0 1.0 0.0], [3.0, 2.23607, 2.0, 0.0], [-0.0 0.0 … -0.0 0.0; 0.447214 0.0 … 0.0 0.894427; -0.0 1.0 … -0.0 0.0; 0.0 0.0 … 1.0 0.0])

julia> F[:U] * diagm(F[:S]) * F[:Vt]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L29-L62}{\texttt{source}}



\begin{lstlisting}
svdfact(A, B) -> GeneralizedSVD
\end{lstlisting}

Compute the generalized SVD of \texttt{A} and \texttt{B}, returning a \texttt{GeneralizedSVD} factorization object \texttt{F}, such that \texttt{A = F[:U]*F[:D1]*F[:R0]*F[:Q]{\textquotesingle}} and \texttt{B = F[:V]*F[:D2]*F[:R0]*F[:Q]{\textquotesingle}}.

For an M-by-N matrix \texttt{A} and P-by-N matrix \texttt{B},

\begin{itemize}
\item \texttt{F[:U]} is a M-by-M orthogonal matrix,


\item \texttt{F[:V]} is a P-by-P orthogonal matrix,


\item \texttt{F[:Q]} is a N-by-N orthogonal matrix,


\item \texttt{F[:R0]} is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,


\item \texttt{F[:D1]} is a M-by-(K+L) diagonal matrix with 1s in the first K entries,


\item \texttt{F[:D2]} is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,

\end{itemize}
\texttt{K+L} is the effective numerical rank of the matrix \texttt{[A; B]}.

The entries of \texttt{F[:D1]} and \texttt{F[:D2]} are related, as explained in the LAPACK documentation for the \href{http://www.netlib.org/lapack/lug/node36.html}{generalized SVD} and the \href{http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3\_8f.html}{xGGSVD3} routine which is called underneath (in LAPACK 3.6.0 and newer).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L206-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14902952530454090437}{} 
\hyperlink{14902952530454090437}{\texttt{Base.LinAlg.svdfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svdfact!(A, thin::Bool=true) -> SVD
\end{lstlisting}

\texttt{svdfact!} is the same as \hyperlink{1135051488165556244}{\texttt{svdfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L13-L18}{\texttt{source}}



\begin{lstlisting}
svdfact!(A, B) -> GeneralizedSVD
\end{lstlisting}

\texttt{svdfact!} is the same as \hyperlink{1135051488165556244}{\texttt{svdfact}}, but modifies the arguments \texttt{A} and \texttt{B} in-place, instead of making copies.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L189-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14775973623414930183}{} 
\hyperlink{14775973623414930183}{\texttt{Base.LinAlg.svd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svd(A; thin::Bool=true) -> U, S, V
\end{lstlisting}

Computes the SVD of \texttt{A}, returning \texttt{U}, vector \texttt{S}, and \texttt{V} such that \texttt{A == U*diagm(S)*V{\textquotesingle}}. The singular values in \texttt{S} are sorted in descending order.

If \texttt{thin=true} (default), a thin SVD is returned. For a \(M \times N\) matrix \texttt{A}, \texttt{U} is \(M \times M\) for a full SVD (\texttt{thin=false}) and \(M \times \min(M, N)\) for a thin SVD.

\texttt{svd} is a wrapper around \hyperlink{1135051488165556244}{\texttt{svdfact}}, extracting all parts of the \texttt{SVD} factorization to a tuple. Direct use of \texttt{svdfact} is therefore more efficient.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> U, S, V = svd(A)
([0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0; 0.0 0.0 1.0 0.0], [3.0, 2.23607, 2.0, 0.0], [-0.0 0.447214 -0.0 0.0; 0.0 0.0 1.0 0.0; … ; -0.0 0.0 -0.0 1.0; 0.0 0.894427 0.0 0.0])

julia> U*diagm(S)*V'
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L70-L104}{\texttt{source}}



\begin{lstlisting}
svd(A, B) -> U, V, Q, D1, D2, R0
\end{lstlisting}

Wrapper around \hyperlink{1135051488165556244}{\texttt{svdfact}} extracting all parts of the factorization to a tuple. Direct use of \texttt{svdfact} is therefore generally more efficient. The function returns the generalized SVD of \texttt{A} and \texttt{B}, returning \texttt{U}, \texttt{V}, \texttt{Q}, \texttt{D1}, \texttt{D2}, and \texttt{R0} such that \texttt{A = U*D1*R0*Q{\textquotesingle}} and \texttt{B = V*D2*R0*Q{\textquotesingle}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L235-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15097149969632009300}{} 
\hyperlink{15097149969632009300}{\texttt{Base.LinAlg.svdvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svdvals(A)
\end{lstlisting}

Returns the singular values of \texttt{A} in descending order.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> svdvals(A)
4-element Array{Float64,1}:
 3.0
 2.23607
 2.0
 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L133-L155}{\texttt{source}}



\begin{lstlisting}
svdvals(A, B)
\end{lstlisting}

Return the generalized singular values from the generalized singular value decomposition of \texttt{A} and \texttt{B}. See also \hyperlink{1135051488165556244}{\texttt{svdfact}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L298-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1185041991470936816}{} 
\hyperlink{1185041991470936816}{\texttt{Base.LinAlg.Givens}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LinAlg.Givens(i1,i2,c,s) -> G
\end{lstlisting}

A Givens rotation linear operator. The fields \texttt{c} and \texttt{s} represent the cosine and sine of the rotation angle, respectively. The \texttt{Givens} type supports left multiplication \texttt{G*A} and conjugated transpose right multiplication \texttt{A*G{\textquotesingle}}. The type doesn{\textquotesingle}t have a \texttt{size} and can therefore be multiplied with matrices of arbitrary size as long as \texttt{i2<=size(A,2)} for \texttt{G*A} or \texttt{i2<=size(A,1)} for \texttt{A*G{\textquotesingle}}.

See also: \hyperlink{2236842301743600111}{\texttt{givens}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/givens.jl#L16-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2236842301743600111}{} 
\hyperlink{2236842301743600111}{\texttt{Base.LinAlg.givens}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
givens{T}(f::T, g::T, i1::Integer, i2::Integer) -> (G::Givens, r::T)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that for any vector \texttt{x} where


\begin{lstlisting}
x[i1] = f
x[i2] = g
\end{lstlisting}

the result of the multiplication


\begin{lstlisting}
y = G*x
\end{lstlisting}

has the property that


\begin{lstlisting}
y[i1] = r
y[i2] = 0
\end{lstlisting}

See also: \hyperlink{1185041991470936816}{\texttt{LinAlg.Givens}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/givens.jl#L234-L254}{\texttt{source}}



\begin{lstlisting}
givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -> (G::Givens, r)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that the result of the multiplication


\begin{lstlisting}
B = G*A
\end{lstlisting}

has the property that


\begin{lstlisting}
B[i1,j] = r
B[i2,j] = 0
\end{lstlisting}

See also: \hyperlink{1185041991470936816}{\texttt{LinAlg.Givens}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/givens.jl#L266-L280}{\texttt{source}}



\begin{lstlisting}
givens(x::AbstractVector, i1::Integer, i2::Integer) -> (G::Givens, r)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that the result of the multiplication


\begin{lstlisting}
B = G*x
\end{lstlisting}

has the property that


\begin{lstlisting}
B[i1] = r
B[i2] = 0
\end{lstlisting}

See also: \hyperlink{1185041991470936816}{\texttt{LinAlg.Givens}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/givens.jl#L285-L299}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8330662115675783329}{} 
\hyperlink{8330662115675783329}{\texttt{Base.LinAlg.triu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
triu(M)
\end{lstlisting}

Upper triangle of a matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> triu(a)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L119-L141}{\texttt{source}}



\begin{lstlisting}
triu(M, k::Integer)
\end{lstlisting}

Returns the upper triangle of \texttt{M} starting from the \texttt{k}th superdiagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> triu(a,3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia> triu(a,-3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L169-L198}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9921408020349989976}{} 
\hyperlink{9921408020349989976}{\texttt{Base.LinAlg.triu!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
triu!(M)
\end{lstlisting}

Upper triangle of a matrix, overwriting \texttt{M} in the process. See also \hyperlink{8330662115675783329}{\texttt{triu}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L233-L238}{\texttt{source}}



\begin{lstlisting}
triu!(M, k::Integer)
\end{lstlisting}

Returns the upper triangle of \texttt{M} starting from the \texttt{k}th superdiagonal, overwriting \texttt{M} in the process.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia> triu!(M, 1)
5×5 Array{Int64,2}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L99-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1728419844431457454}{} 
\hyperlink{1728419844431457454}{\texttt{Base.LinAlg.tril}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tril(M)
\end{lstlisting}

Lower triangle of a matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a)
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L144-L166}{\texttt{source}}



\begin{lstlisting}
tril(M, k::Integer)
\end{lstlisting}

Returns the lower triangle of \texttt{M} starting from the \texttt{k}th superdiagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a,3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a,-3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L201-L230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11302024164043301055}{} 
\hyperlink{11302024164043301055}{\texttt{Base.LinAlg.tril!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tril!(M)
\end{lstlisting}

Lower triangle of a matrix, overwriting \texttt{M} in the process. See also \hyperlink{1728419844431457454}{\texttt{tril}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L241-L246}{\texttt{source}}



\begin{lstlisting}
tril!(M, k::Integer)
\end{lstlisting}

Returns the lower triangle of \texttt{M} starting from the \texttt{k}th superdiagonal, overwriting \texttt{M} in the process.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia> tril!(M, 2)
5×5 Array{Int64,2}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L142-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17382904583164206880}{} 
\hyperlink{17382904583164206880}{\texttt{Base.LinAlg.diagind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diagind(M, k::Integer=0)
\end{lstlisting}

A \texttt{Range} giving the indices of the \texttt{k}th diagonal of the matrix \texttt{M}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> diagind(A,-1)
2:4:6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L209-L226}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6899395651203530298}{} 
\hyperlink{6899395651203530298}{\texttt{Base.LinAlg.diag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diag(M, k::Integer=0)
\end{lstlisting}

The \texttt{k}th diagonal of a matrix, as a vector. Use \hyperlink{8563936900334873682}{\texttt{diagm}} to construct a diagonal matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> diag(A,1)
2-element Array{Int64,1}:
 2
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L229-L249}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8563936900334873682}{} 
\hyperlink{8563936900334873682}{\texttt{Base.LinAlg.diagm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diagm(v, k::Integer=0)
\end{lstlisting}

Construct a matrix by placing \texttt{v} on the \texttt{k}th diagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> diagm([1,2,3],1)
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L252-L267}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11656874809199876602}{} 
\hyperlink{11656874809199876602}{\texttt{Base.LinAlg.scale!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
scale!(A, b)
scale!(b, A)
\end{lstlisting}

Scale an array \texttt{A} by a scalar \texttt{b} overwriting \texttt{A} in-place.

If \texttt{A} is a matrix and \texttt{b} is a vector, then \texttt{scale!(A,b)} scales each column \texttt{i} of \texttt{A} by \texttt{b[i]} (similar to \texttt{A*Diagonal(b)}), while \texttt{scale!(b,A)} scales each row \texttt{i} of \texttt{A} by \texttt{b[i]} (similar to \texttt{Diagonal(b)*A}), again operating in-place on \texttt{A}. An \texttt{InexactError} exception is thrown if the scaling produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia> scale!(a,b)
2×2 Array{Int64,2}:
 1  4
 3  8

julia> a = [1 2; 3 4];

julia> b = [1; 2];

julia> scale!(b,a)
2×2 Array{Int64,2}:
 1  2
 6  8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L45-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2947138922560424828}{} 
\hyperlink{2947138922560424828}{\texttt{Base.LinAlg.rank}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rank(M[, tol::Real])
\end{lstlisting}

Compute the rank of a matrix by counting how many singular values of \texttt{M} have magnitude greater than \texttt{tol}. By default, the value of \texttt{tol} is the largest dimension of \texttt{M} multiplied by the \hyperlink{4594213520310841636}{\texttt{eps}} of the \hyperlink{6396209842929672718}{\texttt{eltype}} of \texttt{M}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rank(eye(3))
3

julia> rank(diagm([1, 0, 2]))
2

julia> rank(diagm([1, 0.001, 2]), 0.1)
2

julia> rank(diagm([1, 0.001, 2]), 0.00001)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L697-L720}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4070774273873411828}{} 
\hyperlink{4070774273873411828}{\texttt{Base.LinAlg.norm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
norm(A::AbstractArray, p::Real=2)
\end{lstlisting}

Compute the \texttt{p}-norm of a vector or the operator norm of a matrix \texttt{A}, defaulting to the 2-norm.


\begin{lstlisting}
norm(A::AbstractVector, p::Real=2)
\end{lstlisting}

For vectors, this is equivalent to \hyperlink{9000973936098681781}{\texttt{vecnorm}} and equal to:

\begin{equation*}
\begin{split}\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\end{split}\end{equation*}
with \(a_i\) the entries of \(A\) and \(n\) its length.

\texttt{p} can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, \texttt{norm(A, Inf)} returns the largest value in \texttt{abs(A)}, whereas \texttt{norm(A, -Inf)} returns the smallest.

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [3, -2, 6]
3-element Array{Int64,1}:
  3
 -2
  6

julia> norm(v)
7.0

julia> norm(v, Inf)
6.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L506-L539}{\texttt{source}}



\begin{lstlisting}
norm(A::AbstractMatrix, p::Real=2)
\end{lstlisting}

For matrices, the matrix norm induced by the vector \texttt{p}-norm is used, where valid values of \texttt{p} are \texttt{1}, \texttt{2}, or \texttt{Inf}. (Note that for sparse matrices, \texttt{p=2} is currently not implemented.) Use \hyperlink{9000973936098681781}{\texttt{vecnorm}} to compute the Frobenius norm.

When \texttt{p=1}, the matrix norm is the maximum absolute column sum of \texttt{A}:

\begin{equation*}
\begin{split}\|A\|_1 = \max_{1 ≤ j ≤ n} \sum_{i=1}^m | a_{ij} |\end{split}\end{equation*}
with \(a_{ij}\) the entries of \(A\), and \(m\) and \(n\) its dimensions.

When \texttt{p=2}, the matrix norm is the spectral norm, equal to the largest singular value of \texttt{A}.

When \texttt{p=Inf}, the matrix norm is the maximum absolute row sum of \texttt{A}:

\begin{equation*}
\begin{split}\|A\|_\infty = \max_{1 ≤ i ≤ m} \sum _{j=1}^n | a_{ij} |\end{split}\end{equation*}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 -2 -3; 2 3 -1]
2×3 Array{Int64,2}:
 1  -2  -3
 2   3  -1

julia> norm(A, Inf)
6.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L542-L574}{\texttt{source}}



\begin{lstlisting}
norm(x::Number, p::Real=2)
\end{lstlisting}

For numbers, return \(\left( |x|^p \right)^{1/p}\). This is equivalent to \hyperlink{9000973936098681781}{\texttt{vecnorm}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L587-L592}{\texttt{source}}



\begin{lstlisting}
norm(A::RowVector, q::Real=2)
\end{lstlisting}

For row vectors, return the \(q\)-norm of \texttt{A}, which is equivalent to the p-norm with value \texttt{p = q/(q-1)}. They coincide at \texttt{p = q = 2}.

The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the inner product, and the result is consistent with the p-norm of \texttt{1 × n} matrix.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L597-L606}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9000973936098681781}{} 
\hyperlink{9000973936098681781}{\texttt{Base.LinAlg.vecnorm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
vecnorm(A, p::Real=2)
\end{lstlisting}

For any iterable container \texttt{A} (including arrays of any dimension) of numbers (or any element type for which \texttt{norm} is defined), compute the \texttt{p}-norm (defaulting to \texttt{p=2}) as if \texttt{A} were a vector of the corresponding length.

The \texttt{p}-norm is defined as:

\begin{equation*}
\begin{split}\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\end{split}\end{equation*}
with \(a_i\) the entries of \(A\) and \(n\) its length.

\texttt{p} can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, \texttt{vecnorm(A, Inf)} returns the largest value in \texttt{abs(A)}, whereas \texttt{vecnorm(A, -Inf)} returns the smallest. If \texttt{A} is a matrix and \texttt{p=2}, then this is equivalent to the Frobenius norm.

\textbf{Example}


\begin{minted}{jlcon}
julia> vecnorm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia> vecnorm([1 2 3 4 5 6 7 8 9])
16.881943016134134
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L414-L441}{\texttt{source}}



\begin{lstlisting}
vecnorm(x::Number, p::Real=2)
\end{lstlisting}

For numbers, return \(\left( |x|^p \right) ^{1/p}\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L460-L464}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5105121074825158846}{} 
\hyperlink{5105121074825158846}{\texttt{Base.LinAlg.normalize!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
normalize!(v::AbstractVector, p::Real=2)
\end{lstlisting}

Normalize the vector \texttt{v} in-place so that its \texttt{p}-norm equals unity, i.e. \texttt{norm(v, p) == 1}. See also \hyperlink{10075112191110723412}{\texttt{normalize}} and \hyperlink{9000973936098681781}{\texttt{vecnorm}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1306-L1312}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10075112191110723412}{} 
\hyperlink{10075112191110723412}{\texttt{Base.LinAlg.normalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
normalize(v::AbstractVector, p::Real=2)
\end{lstlisting}

Normalize the vector \texttt{v} so that its \texttt{p}-norm equals unity, i.e. \texttt{norm(v, p) == vecnorm(v, p) == 1}. See also \hyperlink{5105121074825158846}{\texttt{normalize!}} and \hyperlink{9000973936098681781}{\texttt{vecnorm}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1,2,4];

julia> b = normalize(a)
3-element Array{Float64,1}:
 0.218218
 0.436436
 0.872872

julia> norm(b)
1.0

julia> c = normalize(a, 1)
3-element Array{Float64,1}:
 0.142857
 0.285714
 0.571429

julia> norm(c, 1)
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1335-L1365}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3226902477371958750}{} 
\hyperlink{3226902477371958750}{\texttt{Base.LinAlg.cond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cond(M, p::Real=2)
\end{lstlisting}

Condition number of the matrix \texttt{M}, computed using the operator \texttt{p}-norm. Valid values for \texttt{p} are \texttt{1}, \texttt{2} (default), or \texttt{Inf}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L904-L909}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12763865937954037560}{} 
\hyperlink{12763865937954037560}{\texttt{Base.LinAlg.condskeel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
condskeel(M, [x, p::Real=Inf])
\end{lstlisting}

\begin{equation*}
\begin{split}\kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \\
\kappa_S(M, x, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\end{split}\end{equation*}
Skeel condition number \(\kappa_S\) of the matrix \texttt{M}, optionally with respect to the vector \texttt{x}, as computed using the operator \texttt{p}-norm. \(\left\vert M \right\vert\) denotes the matrix of (entry wise) absolute values of \(M\); \(\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert\). Valid values for \texttt{p} are \texttt{1}, \texttt{2} and \texttt{Inf} (default).

This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L848-L864}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4723994450949629907}{} 
\hyperlink{4723994450949629907}{\texttt{Base.LinAlg.trace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trace(M)
\end{lstlisting}

Matrix trace. Sums the diagonal elements of \texttt{M}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> trace(A)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L730-L746}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1300265042345987014}{} 
\hyperlink{1300265042345987014}{\texttt{Base.LinAlg.det}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
det(M)
\end{lstlisting}

Matrix determinant.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia> det(M)
2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1204-L1220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6649271058375699908}{} 
\hyperlink{6649271058375699908}{\texttt{Base.LinAlg.logdet}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logdet(M)
\end{lstlisting}

Log of matrix determinant. Equivalent to \texttt{log(det(M))}, but may provide increased accuracy and/or speed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia> logdet(M)
0.6931471805599453

julia> logdet(eye(3))
0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1238-L1258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17670285292397317614}{} 
\hyperlink{17670285292397317614}{\texttt{Base.LinAlg.logabsdet}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logabsdet(M)
\end{lstlisting}

Log of absolute value of matrix determinant. Equivalent to \texttt{(log(abs(det(M))), sign(det(M)))}, but may provide increased accuracy and/or speed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1230-L1235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9013378623280719296}{} 
\hyperlink{9013378623280719296}{\texttt{Base.inv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
inv(M)
\end{lstlisting}

Matrix inverse. Computes matrix \texttt{N} such that \texttt{M * N = I}, where \texttt{I} is the identity matrix. Computed by solving the left-division \texttt{N = M {\textbackslash} I}.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [2 5; 1 3]
2×2 Array{Int64,2}:
 2  5
 1  3

julia> N = inv(M)
2×2 Array{Float64,2}:
  3.0  -5.0
 -1.0   2.0

julia> M*N == N*M == eye(2)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L758-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10021362295634933964}{} 
\hyperlink{10021362295634933964}{\texttt{Base.LinAlg.pinv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pinv(M[, tol::Real])
\end{lstlisting}

Computes the Moore-Penrose pseudoinverse.

For matrices \texttt{M} with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values above a given threshold, \texttt{tol}.

The optimal choice of \texttt{tol} varies both with the value of \texttt{M} and the intended application of the pseudoinverse. The default value of \texttt{tol} is \texttt{eps(real(float(one(eltype(M)))))*maximum(size(A))}, which is essentially machine epsilon for the real part of a matrix element multiplied by the larger matrix dimension. For inverting dense ill-conditioned matrices in a least-squares sense, \texttt{tol = sqrt(eps(real(float(one(eltype(M))))))} is recommended.

For more information, see \footnotemark[4], \footnotemark[5], \footnotemark[6], \footnotemark[7].

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1.5 1.3; 1.2 1.9]
2×2 Array{Float64,2}:
 1.5  1.3
 1.2  1.9

julia> N = pinv(M)
2×2 Array{Float64,2}:
  1.47287   -1.00775
 -0.930233   1.16279

julia> M * N
2×2 Array{Float64,2}:
 1.0          -2.22045e-16
 4.44089e-16   1.0
\end{minted}

\footnotetext[4]{Issue 8859, {\textquotedbl}Fix least squares{\textquotedbl}, https://github.com/JuliaLang/julia/pull/8859

}
\footnotetext[5]{Åke Björck, {\textquotedbl}Numerical Methods for Least Squares Problems{\textquotedbl},  SIAM Press, Philadelphia, 1996, {\textquotedbl}Other Titles in Applied Mathematics{\textquotedbl}, Vol. 51. \href{http://epubs.siam.org/doi/book/10.1137/1.9781611971484}{doi:10.1137/1.9781611971484}

}
\footnotetext[6]{G. W. Stewart, {\textquotedbl}Rank Degeneracy{\textquotedbl}, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. \href{http://epubs.siam.org/doi/abs/10.1137/0905030}{doi:10.1137/0905030}

}
\footnotetext[7]{Konstantinos Konstantinides and Kung Yao, {\textquotedbl}Statistical analysis of effective singular values in matrix rank determination{\textquotedbl}, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. \href{http://dx.doi.org/10.1109/29.1585}{doi:10.1109/29.1585}

}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L788-L832}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14766516449068242362}{} 
\hyperlink{14766516449068242362}{\texttt{Base.LinAlg.nullspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nullspace(M)
\end{lstlisting}

Basis for nullspace of \texttt{M}.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1 0 0; 0 1 0; 0 0 0]
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  0

julia> nullspace(M)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L874-L894}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7643954538117657889}{} 
\hyperlink{7643954538117657889}{\texttt{Base.repmat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
repmat(A, m::Integer, n::Integer=1)
\end{lstlisting}

Construct a matrix by repeating the given matrix (or vector) \texttt{m} times in dimension 1 and \texttt{n} times in dimension 2.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repmat([1, 2, 3], 2)
6-element Array{Int64,1}:
 1
 2
 3
 1
 2
 3

julia> repmat([1, 2, 3], 2, 3)
6×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L283-L309}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15426606278434194584}{} 
\hyperlink{15426606278434194584}{\texttt{Base.repeat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
repeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))
\end{lstlisting}

Construct an array by repeating the entries of \texttt{A}. The i-th element of \texttt{inner} specifies the number of times that the individual entries of the i-th dimension of \texttt{A} should be repeated. The i-th element of \texttt{outer} specifies the number of times that a slice along the i-th dimension of \texttt{A} should be repeated. If \texttt{inner} or \texttt{outer} are omitted, no repetition is performed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat(1:2, inner=2)
4-element Array{Int64,1}:
 1
 1
 2
 2

julia> repeat(1:2, outer=2)
4-element Array{Int64,1}:
 1
 2
 1
 2

julia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))
4×6 Array{Int64,2}:
 1  2  1  2  1  2
 1  2  1  2  1  2
 3  4  3  4  3  4
 3  4  3  4  3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L337-L369}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14153417388267953812}{} 
\hyperlink{14153417388267953812}{\texttt{Base.kron}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
kron(A, B)
\end{lstlisting}

Kronecker tensor product of two vectors or two matrices.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> B = [im 1; 1 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im

julia> kron(A, B)
4×4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L286-L311}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5571046194962336745}{} 
\hyperlink{5571046194962336745}{\texttt{Base.SparseArrays.blkdiag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
blkdiag(A...)
\end{lstlisting}

Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.

\textbf{Example}


\begin{minted}{jlcon}
julia> blkdiag(speye(3), 2*speye(2))
5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  2.0
  [5, 5]  =  2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L3083-L3098}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13181813568854970573}{} 
\hyperlink{13181813568854970573}{\texttt{Base.LinAlg.linreg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
linreg(x, y)
\end{lstlisting}

Perform simple linear regression using Ordinary Least Squares. Returns \texttt{a} and \texttt{b} such that \texttt{a + b*x} is the closest straight line to the given points \texttt{(x, y)}, i.e., such that the squared error between \texttt{y} and \texttt{a + b*x} is minimized.

\textbf{Examples:}


\begin{lstlisting}
using PyPlot
x = 1.0:12.0
y = [5.5, 6.3, 7.6, 8.8, 10.9, 11.79, 13.48, 15.02, 17.77, 20.81, 22.0, 22.99]
a, b = linreg(x, y)          # Linear regression
plot(x, y, "o")              # Plot (x, y) points
plot(x, a + b*x)             # Plot line determined by linear regression
\end{lstlisting}

See also:

\texttt{{\textbackslash}}, \hyperlink{17277490353628239858}{\texttt{cov}}, \hyperlink{8821409723106968118}{\texttt{std}}, \hyperlink{2002825322838319654}{\texttt{mean}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1048-L1068}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13066189226307440587}{} 
\hyperlink{13066189226307440587}{\texttt{Base.LinAlg.expm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
expm(A)
\end{lstlisting}

Compute the matrix exponential of \texttt{A}, defined by

\begin{equation*}
\begin{split}e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\end{split}\end{equation*}
For symmetric or Hermitian \texttt{A}, an eigendecomposition (\hyperlink{18133897359296222402}{\texttt{eigfact}}) is used, otherwise the scaling and squaring algorithm (see \footnotemark[8]) is chosen.

\footnotetext[8]{Nicholas J. Higham, {\textquotedbl}The squaring and scaling method for the matrix exponential revisited{\textquotedbl}, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. \href{http://dx.doi.org/10.1137/090768539}{doi:10.1137/090768539}

}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = eye(2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia> expm(A)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L395-L422}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11595351670694268933}{} 
\hyperlink{11595351670694268933}{\texttt{Base.LinAlg.logm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logm(A{T}::StridedMatrix{T})
\end{lstlisting}

If \texttt{A} has no negative real eigenvalue, compute the principal matrix logarithm of \texttt{A}, i.e. the unique matrix \(X\) such that \(e^X = A\) and \(-\pi < Im(\lambda) < \pi\) for all the eigenvalues \(\lambda\) of \(X\). If \texttt{A} has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{18133897359296222402}{\texttt{eigfact}}) is used, if \texttt{A} is triangular an improved version of the inverse scaling and squaring method is employed (see \footnotemark[9] and \footnotemark[10]). For general matrices, the complex Schur form (\hyperlink{5448411964655904748}{\texttt{schur}}) is computed and the triangular algorithm is used on the triangular factor.

\footnotetext[9]{Awad H. Al-Mohy and Nicholas J. Higham, {\textquotedbl}Improved inverse  scaling and squaring algorithms for the matrix logarithm{\textquotedbl}, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. \href{http://dx.doi.org/10.1137/110852553}{doi:10.1137/110852553}

}
\footnotetext[10]{Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, {\textquotedbl}Computing the Fréchet derivative of the matrix logarithm and estimating the condition number{\textquotedbl}, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. \href{http://dx.doi.org/10.1137/120885991}{doi:10.1137/120885991}

}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = 2.7182818 * eye(2)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828

julia> logm(A)
2×2 Symmetric{Float64,Array{Float64,2}}:
 1.0  0.0
 0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L522-L553}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16982789562347489346}{} 
\hyperlink{16982789562347489346}{\texttt{Base.LinAlg.sqrtm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sqrtm(A)
\end{lstlisting}

If \texttt{A} has no negative real eigenvalues, compute the principal matrix square root of \texttt{A}, that is the unique matrix \(X\) with eigenvalues having positive real part such that \(X^2 = A\). Otherwise, a nonprincipal square root is returned.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{18133897359296222402}{\texttt{eigfact}}) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method \footnotemark[11], which computes the complex Schur form (\hyperlink{5448411964655904748}{\texttt{schur}}) and then the complex square root of the triangular factor.

\footnotetext[11]{Åke Björck and Sven Hammarling, {\textquotedbl}A Schur method for the square root of a matrix{\textquotedbl}, Linear Algebra and its Applications, 52-53, 1983, 127-140. \href{http://dx.doi.org/10.1016/0024-3795(83)80010-X}{doi:10.1016/0024-3795(83)80010-X}

}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4 0; 0 4]
2×2 Array{Int64,2}:
 4  0
 0  4

julia> sqrtm(A)
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L589-L620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3402540698228000668}{} 
\hyperlink{3402540698228000668}{\texttt{Base.LinAlg.lyap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lyap(A, C)
\end{lstlisting}

Computes the solution \texttt{X} to the continuous Lyapunov equation \texttt{AX + XA{\textquotesingle} + C = 0}, where no eigenvalue of \texttt{A} has a zero real part and no two eigenvalues are negative complex conjugates of each other.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L946-L952}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4391412007091353668}{} 
\hyperlink{4391412007091353668}{\texttt{Base.LinAlg.sylvester}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sylvester(A, B, C)
\end{lstlisting}

Computes the solution \texttt{X} to the Sylvester equation \texttt{AX + XB + C = 0}, where \texttt{A}, \texttt{B} and \texttt{C} have compatible dimensions and \texttt{A} and \texttt{-B} have no eigenvalues with equal real part.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L926-L931}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16421003133250542616}{} 
\hyperlink{16421003133250542616}{\texttt{Base.LinAlg.issymmetric}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issymmetric(A) -> Bool
\end{lstlisting}

Test whether a matrix is symmetric.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> issymmetric(a)
true

julia> b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia> issymmetric(b)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L867-L891}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10141753772895527781}{} 
\hyperlink{10141753772895527781}{\texttt{Base.LinAlg.isposdef}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isposdef(A) -> Bool
\end{lstlisting}

Test whether a matrix is positive definite.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia> isposdef(A)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L60-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8559510279500369522}{} 
\hyperlink{8559510279500369522}{\texttt{Base.LinAlg.isposdef!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isposdef!(A) -> Bool
\end{lstlisting}

Test whether a matrix is positive definite, overwriting \texttt{A} in the process.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 2.; 2. 50.];

julia> isposdef!(A)
true

julia> A
2×2 Array{Float64,2}:
 1.0  2.0
 2.0  6.78233
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L35-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7162781971755030893}{} 
\hyperlink{7162781971755030893}{\texttt{Base.LinAlg.istril}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istril(A) -> Bool
\end{lstlisting}

Test whether a matrix is lower triangular.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> istril(a)
false

julia> b = [1 0; -im -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+0im
 0-1im  -1+0im

julia> istril(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L982-L1006}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8482220121253669068}{} 
\hyperlink{8482220121253669068}{\texttt{Base.LinAlg.istriu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istriu(A) -> Bool
\end{lstlisting}

Test whether a matrix is upper triangular.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> istriu(a)
false

julia> b = [1 im; 0 -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+1im
 0+0im  -1+0im

julia> istriu(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L947-L971}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15753182127953060317}{} 
\hyperlink{15753182127953060317}{\texttt{Base.LinAlg.isdiag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdiag(A) -> Bool
\end{lstlisting}

Test whether a matrix is diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> isdiag(a)
false

julia> b = [im 0; 0 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  0+0im
 0+0im  0-1im

julia> isdiag(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1017-L1041}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12800362927453768899}{} 
\hyperlink{12800362927453768899}{\texttt{Base.LinAlg.ishermitian}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ishermitian(A) -> Bool
\end{lstlisting}

Test whether a matrix is Hermitian.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> ishermitian(a)
true

julia> b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia> ishermitian(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L907-L931}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16991298248158657849}{} 
\hyperlink{16991298248158657849}{\texttt{Base.LinAlg.RowVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RowVector(vector)
\end{lstlisting}

A lazy-view wrapper of an \texttt{AbstractVector}, which turns a length-\texttt{n} vector into a \texttt{1×n} shaped row vector and represents the transpose of a vector (the elements are also transposed recursively). This type is usually constructed (and unwrapped) via the \hyperlink{12700837529519091997}{\texttt{transpose}} function or \texttt{.{\textquotesingle}} operator (or related \hyperlink{5848887074375173050}{\texttt{ctranspose}} or \texttt{{\textquotesingle}} operator).

By convention, a vector can be multiplied by a matrix on its left (\texttt{A * v}) whereas a row vector can be multiplied by a matrix on its right (such that \texttt{v.{\textquotesingle} * A = (A.{\textquotesingle} * v).{\textquotesingle}}). It differs from a \texttt{1×n}-sized matrix by the facts that its transpose returns a vector and the inner product \texttt{v1.{\textquotesingle} * v2} returns a scalar, but will otherwise behave similarly.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/rowvector.jl#L3-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5185144354217809072}{} 
\hyperlink{5185144354217809072}{\texttt{Base.LinAlg.ConjArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ConjArray(array)
\end{lstlisting}

A lazy-view wrapper of an \texttt{AbstractArray}, taking the elementwise complex conjugate. This type is usually constructed (and unwrapped) via the \hyperlink{9940023991150673697}{\texttt{conj}} function (or related \hyperlink{5848887074375173050}{\texttt{ctranspose}}), but currently this is the default behavior for \texttt{RowVector} only. For other arrays, the \texttt{ConjArray} constructor can be used directly.

\textbf{Examples}


\begin{minted}{jlcon}
julia> [1+im, 1-im]'
1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:
 1-1im  1+1im

julia> ConjArray([1+im 0; 0 1-im])
2×2 ConjArray{Complex{Int64},2,Array{Complex{Int64},2}}:
 1-1im  0+0im
 0+0im  1+1im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/conjarray.jl#L3-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12700837529519091997}{} 
\hyperlink{12700837529519091997}{\texttt{Base.transpose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
transpose(A::AbstractMatrix)
\end{lstlisting}

The transposition operator (\texttt{.{\textquotesingle}}).

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> transpose(A)
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/transpose.jl#L97-L117}{\texttt{source}}



\begin{lstlisting}
transpose(v::AbstractVector)
\end{lstlisting}

The transposition operator (\texttt{.{\textquotesingle}}).

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> transpose(v)
1×3 RowVector{Int64,Array{Int64,1}}:
 1  2  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/rowvector.jl#L59-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11995796242466841038}{} 
\hyperlink{11995796242466841038}{\texttt{Base.LinAlg.transpose!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
transpose!(dest,src)
\end{lstlisting}

Transpose array \texttt{src} and store the result in the preallocated array \texttt{dest}, which should have a size corresponding to \texttt{(size(src,2),size(src,1))}. No in-place transposition is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/transpose.jl#L8-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5848887074375173050}{} 
\hyperlink{5848887074375173050}{\texttt{Base.ctranspose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ctranspose(A)
\end{lstlisting}

The conjugate transposition operator (\texttt{{\textquotesingle}}).

\textbf{Example}


\begin{minted}{jlcon}
julia> A =  [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> ctranspose(A)
2×2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L689-L707}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7273872285269730754}{} 
\hyperlink{7273872285269730754}{\texttt{Base.LinAlg.ctranspose!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ctranspose!(dest,src)
\end{lstlisting}

Conjugate transpose array \texttt{src} and store the result in the preallocated array \texttt{dest}, which should have a size corresponding to \texttt{(size(src,2),size(src,1))}. No in-place transposition is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/transpose.jl#L18-L25}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2661699301071873867}{} 
\hyperlink{2661699301071873867}{\texttt{Base.LinAlg.eigs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigs(A; nev=6, ncv=max(20,2*nev+1), which=:LM, tol=0.0, maxiter=300, sigma=nothing, ritzvec=true, v0=zeros((0,))) -> (d,[v,],nconv,niter,nmult,resid)
\end{lstlisting}

Computes eigenvalues \texttt{d} of \texttt{A} using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.

The following keyword arguments are supported:

\begin{itemize}
\item \texttt{nev}: Number of eigenvalues


\item \texttt{ncv}: Number of Krylov vectors used in the computation; should satisfy \texttt{nev+1 <= ncv <= n} for real symmetric problems and \texttt{nev+2 <= ncv <= n} for other problems, where \texttt{n} is the size of the input matrix \texttt{A}. The default is \texttt{ncv = max(20,2*nev+1)}. Note that these restrictions limit the input matrix \texttt{A} to be of dimension at least 2.


\item \texttt{which}: type of eigenvalues to compute. See the note below.

\end{itemize}

\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{which} & type of eigenvalues \\
\hline
\texttt{:LM} & eigenvalues of largest magnitude (default) \\
\hline
\texttt{:SM} & eigenvalues of smallest magnitude \\
\hline
\texttt{:LR} & eigenvalues of largest real part \\
\hline
\texttt{:SR} & eigenvalues of smallest real part \\
\hline
\texttt{:LI} & eigenvalues of largest imaginary part (nonsymmetric or complex \texttt{A} only) \\
\hline
\texttt{:SI} & eigenvalues of smallest imaginary part (nonsymmetric or complex \texttt{A} only) \\
\hline
\texttt{:BE} & compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric \texttt{A} only) \\
\hline
\end{tabulary}

\end{table}

\begin{itemize}
\item \texttt{tol}: parameter defining the relative tolerance for convergence of Ritz values (eigenvalue estimates).    A Ritz value \(θ\) is considered converged when its associated residual    is less than or equal to the product of \texttt{tol} and \(max(ɛ^{2/3}, |θ|)\),    where \texttt{ɛ = eps(real(eltype(A)))/2} is LAPACK{\textquotesingle}s machine epsilon.    The residual associated with \(θ\) and its corresponding Ritz vector \(v\)    is defined as the norm \(||Av - vθ||\).    The specified value of \texttt{tol} should be positive; otherwise, it is ignored    and \(ɛ\) is used instead.    Default: \(ɛ\).


\item \texttt{maxiter}: Maximum number of iterations (default = 300)


\item \texttt{sigma}: Specifies the level shift used in inverse iteration. If \texttt{nothing} (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to \texttt{sigma} using shift and invert iterations.


\item \texttt{ritzvec}: Returns the Ritz vectors \texttt{v} (eigenvectors) if \texttt{true}


\item \texttt{v0}: starting vector from which to start the iterations

\end{itemize}
\texttt{eigs} returns the \texttt{nev} requested eigenvalues in \texttt{d}, the corresponding Ritz vectors \texttt{v} (only if \texttt{ritzvec=true}), the number of converged eigenvalues \texttt{nconv}, the number of iterations \texttt{niter} and the number of matrix vector multiplications \texttt{nmult}, as well as the final residual vector \texttt{resid}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = spdiagm(1:4);

julia> λ, ϕ = eigs(A, nev = 2);

julia> λ
2-element Array{Float64,1}:
 4.0
 3.0
\end{minted}

\begin{quote}
\textbf{Note}

The \texttt{sigma} and \texttt{which} keywords interact: the description of eigenvalues searched for by \texttt{which} do \emph{not} necessarily refer to the eigenvalues of \texttt{A}, but rather the linear operator constructed by the specification of the iteration mode implied by \texttt{sigma}.


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\texttt{sigma} & iteration mode & \texttt{which} refers to eigenvalues of \\
\hline
\texttt{nothing} & ordinary (forward) & \(A\) \\
\hline
real or complex & inverse with level shift \texttt{sigma} & \((A - \sigma I )^{-1}\) \\
\hline
\end{tabulary}

\end{table}

\end{quote}
\begin{quote}
\textbf{Note}

Although \texttt{tol} has a default value, the best choice depends strongly on the matrix \texttt{A}. We recommend that users \_always\_ specify a value for \texttt{tol} which suits their specific needs.

For details of how the errors in the computed eigenvalues are estimated, see:

\begin{itemize}
\item B. N. Parlett, {\textquotedbl}The Symmetric Eigenvalue Problem{\textquotedbl}, SIAM: Philadelphia, 2/e (1998), Ch. 13.2, {\textquotedbl}Accessing Accuracy in Lanczos Problems{\textquotedbl}, pp. 290-292 ff.


\item R. B. Lehoucq and D. C. Sorensen, {\textquotedbl}Deflation Techniques for an Implicitly Restarted Arnoldi Iteration{\textquotedbl}, SIAM Journal on Matrix Analysis and Applications (1996), 17(4), 789–821.  doi:10.1137/S0895479895281484

\end{itemize}
\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/arnoldi.jl#L6-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7995348975812558417}{} 
\hyperlink{7995348975812558417}{\texttt{Base.LinAlg.eigs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigs(A, B; nev=6, ncv=max(20,2*nev+1), which=:LM, tol=0.0, maxiter=300, sigma=nothing, ritzvec=true, v0=zeros((0,))) -> (d,[v,],nconv,niter,nmult,resid)
\end{lstlisting}

Computes generalized eigenvalues \texttt{d} of \texttt{A} and \texttt{B} using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.

The following keyword arguments are supported:

\begin{itemize}
\item \texttt{nev}: Number of eigenvalues


\item \texttt{ncv}: Number of Krylov vectors used in the computation; should satisfy \texttt{nev+1 <= ncv <= n} for real symmetric problems and \texttt{nev+2 <= ncv <= n} for other problems, where \texttt{n} is the size of the input matrices \texttt{A} and \texttt{B}. The default is \texttt{ncv = max(20,2*nev+1)}. Note that these restrictions limit the input matrix \texttt{A} to be of dimension at least 2.


\item \texttt{which}: type of eigenvalues to compute. See the note below.

\end{itemize}

\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{which} & type of eigenvalues \\
\hline
\texttt{:LM} & eigenvalues of largest magnitude (default) \\
\hline
\texttt{:SM} & eigenvalues of smallest magnitude \\
\hline
\texttt{:LR} & eigenvalues of largest real part \\
\hline
\texttt{:SR} & eigenvalues of smallest real part \\
\hline
\texttt{:LI} & eigenvalues of largest imaginary part (nonsymmetric or complex \texttt{A} only) \\
\hline
\texttt{:SI} & eigenvalues of smallest imaginary part (nonsymmetric or complex \texttt{A} only) \\
\hline
\texttt{:BE} & compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric \texttt{A} only) \\
\hline
\end{tabulary}

\end{table}

\begin{itemize}
\item \texttt{tol}: relative tolerance used in the convergence criterion for eigenvalues, similar to    \texttt{tol} in the \hyperlink{2661699301071873867}{\texttt{eigs(A)}} method for the ordinary eigenvalue    problem, but effectively for the eigenvalues of \(B^{-1} A\) instead of \(A\).    See the documentation for the ordinary eigenvalue problem in    \hyperlink{2661699301071873867}{\texttt{eigs(A)}} and the accompanying note about \texttt{tol}.


\item \texttt{maxiter}: Maximum number of iterations (default = 300)


\item \texttt{sigma}: Specifies the level shift used in inverse iteration. If \texttt{nothing} (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to \texttt{sigma} using shift and invert iterations.


\item \texttt{ritzvec}: Returns the Ritz vectors \texttt{v} (eigenvectors) if \texttt{true}


\item \texttt{v0}: starting vector from which to start the iterations

\end{itemize}
\texttt{eigs} returns the \texttt{nev} requested eigenvalues in \texttt{d}, the corresponding Ritz vectors \texttt{v} (only if \texttt{ritzvec=true}), the number of converged eigenvalues \texttt{nconv}, the number of iterations \texttt{niter} and the number of matrix vector multiplications \texttt{nmult}, as well as the final residual vector \texttt{resid}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(4, 4); B = spdiagm(1:4);

julia> λ, ϕ = eigs(A, B, nev = 2);

julia> λ
2-element Array{Float64,1}:
 1.0
 0.5
\end{minted}

\begin{quote}
\textbf{Note}

The \texttt{sigma} and \texttt{which} keywords interact: the description of eigenvalues searched for by \texttt{which} do \emph{not} necessarily refer to the eigenvalue problem \(Av = Bv\lambda\), but rather the linear operator constructed by the specification of the iteration mode implied by \texttt{sigma}.


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\texttt{sigma} & iteration mode & \texttt{which} refers to the problem \\
\hline
\texttt{nothing} & ordinary (forward) & \(Av = Bv\lambda\) \\
\hline
real or complex & inverse with level shift \texttt{sigma} & \((A - \sigma B )^{-1}B = v\nu\) \\
\hline
\end{tabulary}

\end{table}

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/arnoldi.jl#L105-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5570081548278801160}{} 
\hyperlink{5570081548278801160}{\texttt{Base.LinAlg.svds}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svds(A; nsv=6, ritzvec=true, tol=0.0, maxiter=1000, ncv=2*nsv, u0=zeros((0,)), v0=zeros((0,))) -> (SVD([left_sv,] s, [right_sv,]), nconv, niter, nmult, resid)
\end{lstlisting}

Computes the largest singular values \texttt{s} of \texttt{A} using implicitly restarted Lanczos iterations derived from \hyperlink{2661699301071873867}{\texttt{eigs}}.

\textbf{Inputs}

\begin{itemize}
\item \texttt{A}: Linear operator whose singular values are desired. \texttt{A} may be represented as a subtype of \texttt{AbstractArray}, e.g., a sparse matrix, or any other type supporting the four methods \texttt{size(A)}, \texttt{eltype(A)}, \texttt{A * vector}, and \texttt{A{\textquotesingle} * vector}.


\item \texttt{nsv}: Number of singular values. Default: 6.


\item \texttt{ritzvec}: If \texttt{true}, return the left and right singular vectors \texttt{left\_sv} and \texttt{right\_sv}.  If \texttt{false}, omit the singular vectors. Default: \texttt{true}.


\item \texttt{tol}: tolerance, see \hyperlink{2661699301071873867}{\texttt{eigs}}.


\item \texttt{maxiter}: Maximum number of iterations, see \hyperlink{2661699301071873867}{\texttt{eigs}}. Default: 1000.


\item \texttt{ncv}: Maximum size of the Krylov subspace, see \hyperlink{2661699301071873867}{\texttt{eigs}} (there called \texttt{nev}). Default: \texttt{2*nsv}.


\item \texttt{u0}: Initial guess for the first left Krylov vector. It may have length \texttt{m} (the first dimension of \texttt{A}), or 0.


\item \texttt{v0}: Initial guess for the first right Krylov vector. It may have length \texttt{n} (the second dimension of \texttt{A}), or 0.

\end{itemize}
\textbf{Outputs}

\begin{itemize}
\item \texttt{svd}: An \texttt{SVD} object containing the left singular vectors, the requested values, and the right singular vectors. If \texttt{ritzvec = false}, the left and right singular vectors will be empty.


\item \texttt{nconv}: Number of converged singular values.


\item \texttt{niter}: Number of iterations.


\item \texttt{nmult}: Number of matrix–vector products used.


\item \texttt{resid}: Final residual vector.

\end{itemize}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = spdiagm(1:4);

julia> s = svds(A, nsv = 2)[1];

julia> s[:S]
2-element Array{Float64,1}:
 4.0
 3.0
\end{minted}

\begin{quote}
\textbf{Implementation}

\texttt{svds(A)} is formally equivalent to calling \hyperlink{2661699301071873867}{\texttt{eigs}} to perform implicitly restarted Lanczos tridiagonalization on the Hermitian matrix \(\begin{pmatrix} 0 & A^\prime \\ A & 0 \end{pmatrix}\), whose eigenvalues are plus and minus the singular values of \(A\).

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/arnoldi.jl#L333-L381}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16557051226459637517}{} 
\hyperlink{16557051226459637517}{\texttt{Base.LinAlg.peakflops}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
peakflops(n::Integer=2000; parallel::Bool=false)
\end{lstlisting}

\texttt{peakflops} computes the peak flop rate of the computer by using double precision \hyperlink{17677151106024314777}{\texttt{gemm!}}. By default, if no arguments are specified, it multiplies a matrix of size \texttt{n x n}, where \texttt{n = 2000}. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with \hyperlink{3656432689516664548}{\texttt{BLAS.set\_num\_threads(n)}}.

If the keyword argument \texttt{parallel} is set to \texttt{true}, \texttt{peakflops} is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument \texttt{n} still refers to the size of the problem that is solved on each processor.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1103-L1116}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9786923620103438283}{}


\section{Operaciones matriciales de bajo nivel}



Las operaciones de matrices que involucran operaciones de transposición como \texttt{A{\textquotesingle} {\textbackslash} B} son convertidas por el analizador de Julia en llamadas a funciones especialmente nombradas como \hyperlink{9966202373988898888}{\texttt{Ac\_ldiv\_B}}. Si desea sobrecargar estas operaciones para sus propios tipos, será útil conocer los nombres de estas funciones.



Además, en muchos casos, hay versiones in situ de operaciones matriciales que le permiten suministrar un vector o matriz de salida preasignada. Esto es útil cuando se optimiza código crítico para evitar la sobrecarga de las asignaciones repetidas. Estas operaciones in situ tienen el sufijo \texttt{!} a continuación (por ejemplo, \hyperlink{8969873939925166343}{\texttt{A\_mul\_B!}}) de acuerdo con la convención habitual de Julia.


\hypertarget{16784809286794154433}{} 
\hyperlink{16784809286794154433}{\texttt{Base.LinAlg.A\_ldiv\_B!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_ldiv_B!([Y,] A, B) -> Y
\end{lstlisting}

Compute \texttt{A {\textbackslash} B} in-place and store the result in \texttt{Y}, returning the result. If only two arguments are passed, then \texttt{A\_ldiv\_B!(A, B)} overwrites \texttt{B} with the result.

The argument \texttt{A} should \emph{not} be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by \hyperlink{10363263068585650380}{\texttt{factorize}} or \hyperlink{12805335348758675309}{\texttt{cholfact}}). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., \hyperlink{9520029296647984269}{\texttt{lufact!}}), and performance-critical situations requiring \texttt{A\_ldiv\_B!} usually also require fine-grained control over the factorization of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/factorization.jl#L63-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2226896762091701133}{} 
\hyperlink{2226896762091701133}{\texttt{Base.A\_ldiv\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_ldiv_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A\) {\textbackslash} \(Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16902725147803109549}{} 
\hyperlink{16902725147803109549}{\texttt{Base.A\_ldiv\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_ldiv_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A\) {\textbackslash} \(Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L827-L831}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8969873939925166343}{} 
\hyperlink{8969873939925166343}{\texttt{Base.LinAlg.A\_mul\_B!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_mul_B!(Y, A, B) -> Y
\end{lstlisting}

Calculates the matrix-matrix or matrix-vector product \(A⋅B\) and stores the result in \texttt{Y}, overwriting the existing value of \texttt{Y}. Note that \texttt{Y} must not be aliased with either \texttt{A} or \texttt{B}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); A_mul_B!(Y, A, B);

julia> Y
2×2 Array{Float64,2}:
 3.0  3.0
 7.0  7.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/matmul.jl#L160-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16703425411548835564}{} 
\hyperlink{16703425411548835564}{\texttt{Base.A\_mul\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_mul_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A⋅Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L720-L724}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15013997067712207576}{} 
\hyperlink{15013997067712207576}{\texttt{Base.A\_mul\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_mul_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A⋅Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L741-L745}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6739172293198726371}{} 
\hyperlink{6739172293198726371}{\texttt{Base.A\_rdiv\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_rdiv_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A / Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L764-L768}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13605500069324358113}{} 
\hyperlink{13605500069324358113}{\texttt{Base.A\_rdiv\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_rdiv_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A / Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L785-L789}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9966202373988898888}{} 
\hyperlink{9966202373988898888}{\texttt{Base.Ac\_ldiv\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_ldiv_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ\) {\textbackslash} \(B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L799-L803}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12173417613583933911}{} 
\hyperlink{12173417613583933911}{\texttt{Base.LinAlg.Ac\_ldiv\_B!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_ldiv_B!([Y,] A, B) -> Y
\end{lstlisting}

Similar to \hyperlink{16784809286794154433}{\texttt{A\_ldiv\_B!}}, but return \(Aᴴ\) {\textbackslash} \(B\), computing the result in-place in \texttt{Y} (or overwriting \texttt{B} if \texttt{Y} is not supplied).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/factorization.jl#L79-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17063845040932531598}{} 
\hyperlink{17063845040932531598}{\texttt{Base.Ac\_ldiv\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_ldiv_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ\) {\textbackslash} \(Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L813-L817}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12228791725837368547}{} 
\hyperlink{12228791725837368547}{\texttt{Base.Ac\_mul\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_mul_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ⋅B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L713-L717}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8302093914811646736}{} 
\hyperlink{8302093914811646736}{\texttt{Base.Ac\_mul\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_mul_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L727-L731}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9268374614432165456}{} 
\hyperlink{9268374614432165456}{\texttt{Base.Ac\_rdiv\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_rdiv_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ / B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L757-L761}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3522638395450403535}{} 
\hyperlink{3522638395450403535}{\texttt{Base.Ac\_rdiv\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_rdiv_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ / Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L771-L775}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9545826193986876343}{} 
\hyperlink{9545826193986876343}{\texttt{Base.At\_ldiv\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_ldiv_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ\) {\textbackslash} \(B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L820-L824}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5857267823705719337}{} 
\hyperlink{5857267823705719337}{\texttt{Base.LinAlg.At\_ldiv\_B!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_ldiv_B!([Y,] A, B) -> Y
\end{lstlisting}

Similar to \hyperlink{16784809286794154433}{\texttt{A\_ldiv\_B!}}, but return \(Aᵀ\) {\textbackslash} \(B\), computing the result in-place in \texttt{Y} (or overwriting \texttt{B} if \texttt{Y} is not supplied).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/factorization.jl#L87-L92}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13563153742436501281}{} 
\hyperlink{13563153742436501281}{\texttt{Base.At\_ldiv\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_ldiv_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ\) {\textbackslash} \(Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L834-L838}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9448174319368400769}{} 
\hyperlink{9448174319368400769}{\texttt{Base.At\_mul\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_mul_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ⋅B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L734-L738}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15605965573818503001}{} 
\hyperlink{15605965573818503001}{\texttt{Base.At\_mul\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_mul_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ⋅Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L748-L752}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16681540278405777694}{} 
\hyperlink{16681540278405777694}{\texttt{Base.At\_rdiv\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_rdiv_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ / B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L778-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4109140714102921823}{} 
\hyperlink{4109140714102921823}{\texttt{Base.At\_rdiv\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_rdiv_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ / Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L792-L796}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5866228393923359741}{}


\section{Funciones BLAS}



En Julia (como en gran parte de la computación científica), las operaciones  de álgebra lineal densa se basan en la \href{http://www.netlib.org/lapack/}{biblioteca LAPACK}, que a su vez se construye sobre bloques de construcción básicos de álgebra lineal conocidos como \href{http://www.netlib.org/blas/}{BLAS}. Hay implementaciones altamente optimizadas de BLAS disponibles para cada arquitectura de computadora, y algunas veces en rutinas de álgebra lineal de alto rendimiento, es útil llamar directamente a las funciones de BLAS.



\texttt{Base.LinAlg.BLAS} proporciona envoltorios para algunas de las funciones de BLAS. Esas funciones de BLAS que sobrescriben una de las matrices de entrada tienen nombres que terminan en \texttt{{\textquotesingle}!{\textquotesingle}}. Normalmente, una función BLAS tiene cuatro métodos definidos, para las arrays \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \texttt{Complex128} y\texttt{Complex64}.



\hypertarget{11073177327200670825}{}


\subsection{BLAS Character Arguments}



Muchas funciones BLAS aceptan argumentos que determinan si se debe transponer un argumento (\texttt{trans}), qué triángulo de una matriz referenciar (\texttt{uplo} o \texttt{ul}), si se puede suponer que la diagonal de una matriz triangular está formada por unos (\texttt{dA}) o a qué lado de una multiplicación de matrices pertenece el argumento de entrada (\texttt{side}). Las posibilidades son:



\hypertarget{1714685266370616361}{}


\subsubsection{Orden de Multiplicación}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{side} & Meaning \\
\hline
\texttt{{\textquotesingle}L{\textquotesingle}} & El argumento va al lado \emph{izquierdo} de una operación matriz-matriz. \\
\hline
\texttt{{\textquotesingle}R{\textquotesingle}} & El argumento va al lado \emph{derecho} de una operación matriz-matriz. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{5558887752259302145}{}


\subsubsection{Referencia sobre el Triángulo}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{uplo}/\texttt{ul} & Meaning \\
\hline
\texttt{{\textquotesingle}U{\textquotesingle}}       & Sólo se usará el triángulo \emph{superior} de la matriz. \\
\hline
\texttt{{\textquotesingle}L{\textquotesingle}} & Sólo se usará el triángulo \emph{inferior} de la matriz. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{13285421231458545876}{}


\subsubsection{Operación de Transposición}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{trans}/\texttt{tX} & Meaning \\
\hline
\texttt{{\textquotesingle}N{\textquotesingle}} & La matriz de entrada \texttt{X} no es transpuesta ni conjugada. \\
\hline
\texttt{{\textquotesingle}T{\textquotesingle}}       & La matriz de entrada \texttt{X} será transpuesta.              \\
\hline
\texttt{{\textquotesingle}C{\textquotesingle}}       & La matriz de entrada \texttt{X} será conjugada y transpuesta. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{11643333471578083521}{}


\subsubsection{Unidades en la Diagonal}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{diag}/\texttt{dX} & Meaning \\
\hline
\texttt{{\textquotesingle}N{\textquotesingle}}       & Los valores diagonales de la matriz \texttt{X}serán leídos. \\
\hline
\texttt{{\textquotesingle}U{\textquotesingle}} & Se supone que los elementos de la diagonal de la matriz \texttt{X} son todos unos. \\
\hline
\end{tabulary}

\end{table}


\hypertarget{11889274140090253372}{} 
\hyperlink{11889274140090253372}{\texttt{Base.LinAlg.BLAS.dotu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dotu(n, X, incx, Y, incy)
\end{lstlisting}

Dot function for two complex vectors consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{Y} with stride \texttt{incy}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> Base.BLAS.dotu(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)
-10.0 + 10.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L242-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1117830083282379909}{} 
\hyperlink{1117830083282379909}{\texttt{Base.LinAlg.BLAS.dotc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dotc(n, X, incx, U, incy)
\end{lstlisting}

Dot function for two complex vectors, consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{U} with stride \texttt{incy}, conjugating the first vector.

\textbf{Example:}


\begin{minted}{jlcon}
julia> Base.BLAS.dotc(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)
10.0 - 10.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L227-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2147220473907622621}{} 
\hyperlink{2147220473907622621}{\texttt{Base.LinAlg.BLAS.blascopy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
blascopy!(n, X, incx, Y, incy)
\end{lstlisting}

Copy \texttt{n} elements of array \texttt{X} with stride \texttt{incx} to array \texttt{Y} with stride \texttt{incy}. Returns \texttt{Y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L157-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14459800598483653560}{} 
\hyperlink{14459800598483653560}{\texttt{Base.LinAlg.BLAS.nrm2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nrm2(n, X, incx)
\end{lstlisting}

2-norm of a vector consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> Base.BLAS.nrm2(4, ones(8), 2)
2.0

julia> Base.BLAS.nrm2(1, ones(8), 2)
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L335-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13029615432404336289}{} 
\hyperlink{13029615432404336289}{\texttt{Base.LinAlg.BLAS.asum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asum(n, X, incx)
\end{lstlisting}

Sum of the absolute values of the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> Base.BLAS.asum(5, im*ones(10), 2)
5.0

julia> Base.BLAS.asum(2, im*ones(10), 5)
2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L368-L381}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7655786041748989730}{} 
\hyperlink{7655786041748989730}{\texttt{Base.LinAlg.axpy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
axpy!(a, X, Y)
\end{lstlisting}

Overwrite \texttt{Y} with \texttt{a*X + Y}, where \texttt{a} is a scalar. Returns \texttt{Y}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> x = [1; 2; 3];

julia> y = [4; 5; 6];

julia> Base.BLAS.axpy!(2, x, y)
3-element Array{Int64,1}:
  6
  9
 12
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L401-L418}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8034221977708289638}{} 
\hyperlink{8034221977708289638}{\texttt{Base.LinAlg.BLAS.scal!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
scal!(n, a, X, incx)
\end{lstlisting}

Overwrite \texttt{X} with \texttt{a*X} for the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}. Returns \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L181-L185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5238599898608873752}{} 
\hyperlink{5238599898608873752}{\texttt{Base.LinAlg.BLAS.scal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
scal(n, a, X, incx)
\end{lstlisting}

Returns \texttt{X} scaled by \texttt{a} for the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L188-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15135255339747177789}{} 
\hyperlink{15135255339747177789}{\texttt{Base.LinAlg.BLAS.ger!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ger!(alpha, x, y, A)
\end{lstlisting}

Rank-1 update of the matrix \texttt{A} with vectors \texttt{x} and \texttt{y} as \texttt{alpha*x*y{\textquotesingle} + A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L904-L908}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12883861850425780126}{} 
\hyperlink{12883861850425780126}{\texttt{Base.LinAlg.BLAS.syr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syr!(uplo, alpha, x, A)
\end{lstlisting}

Rank-1 update of the symmetric matrix \texttt{A} with vector \texttt{x} as \texttt{alpha*x*x.{\textquotesingle} + A}. \hyperlink{5558887752259302145}{\texttt{uplo}} controls which triangle of \texttt{A} is updated. Returns \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L935-L940}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2548146220821159778}{} 
\hyperlink{2548146220821159778}{\texttt{Base.LinAlg.BLAS.syrk!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syrk!(uplo, trans, alpha, A, beta, C)
\end{lstlisting}

Rank-k update of the symmetric matrix \texttt{C} as \texttt{alpha*A*A.{\textquotesingle} + beta*C} or \texttt{alpha*A.{\textquotesingle}*A + beta*C} according to \hyperlink{13285421231458545876}{\texttt{trans}}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{C} is used. Returns \texttt{C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1169-L1175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13379346712428626149}{} 
\hyperlink{13379346712428626149}{\texttt{Base.LinAlg.BLAS.syrk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syrk(uplo, trans, alpha, A)
\end{lstlisting}

Returns either the upper triangle or the lower triangle of \texttt{A}, according to \hyperlink{5558887752259302145}{\texttt{uplo}}, of \texttt{alpha*A*A.{\textquotesingle}} or \texttt{alpha*A.{\textquotesingle}*A}, according to \hyperlink{13285421231458545876}{\texttt{trans}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1178-L1185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4035484492260995504}{} 
\hyperlink{4035484492260995504}{\texttt{Base.LinAlg.BLAS.her!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
her!(uplo, alpha, x, A)
\end{lstlisting}

Methods for complex arrays only. Rank-1 update of the Hermitian matrix \texttt{A} with vector \texttt{x} as \texttt{alpha*x*x{\textquotesingle} + A}. \hyperlink{5558887752259302145}{\texttt{uplo}} controls which triangle of \texttt{A} is updated. Returns \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L965-L971}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9755412184209766372}{} 
\hyperlink{9755412184209766372}{\texttt{Base.LinAlg.BLAS.herk!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
herk!(uplo, trans, alpha, A, beta, C)
\end{lstlisting}

Methods for complex arrays only. Rank-k update of the Hermitian matrix \texttt{C} as \texttt{alpha*A*A{\textquotesingle} + beta*C} or \texttt{alpha*A{\textquotesingle}*A + beta*C} according to \hyperlink{13285421231458545876}{\texttt{trans}}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{C} is updated. Returns \texttt{C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1225-L1232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12918577395560718283}{} 
\hyperlink{12918577395560718283}{\texttt{Base.LinAlg.BLAS.herk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
herk(uplo, trans, alpha, A)
\end{lstlisting}

Methods for complex arrays only. Returns the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{alpha*A*A{\textquotesingle}} or \texttt{alpha*A{\textquotesingle}*A}, according to \hyperlink{13285421231458545876}{\texttt{trans}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1235-L1241}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18085399308967465076}{} 
\hyperlink{18085399308967465076}{\texttt{Base.LinAlg.BLAS.gbmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)
\end{lstlisting}

Update vector \texttt{y} as \texttt{alpha*A*x + beta*y} or \texttt{alpha*A{\textquotesingle}*x + beta*y} according to \hyperlink{13285421231458545876}{\texttt{trans}}. The matrix \texttt{A} is a general band matrix of dimension \texttt{m} by \texttt{size(A,2)} with \texttt{kl} sub-diagonals and \texttt{ku} super-diagonals. \texttt{alpha} and \texttt{beta} are scalars. Returns the updated \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L547-L553}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4457861111732227628}{} 
\hyperlink{4457861111732227628}{\texttt{Base.LinAlg.BLAS.gbmv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gbmv(trans, m, kl, ku, alpha, A, x)
\end{lstlisting}

Returns \texttt{alpha*A*x} or \texttt{alpha*A{\textquotesingle}*x} according to \hyperlink{13285421231458545876}{\texttt{trans}}. The matrix \texttt{A} is a general band matrix of dimension \texttt{m} by \texttt{size(A,2)} with \texttt{kl} sub-diagonals and \texttt{ku} super-diagonals, and \texttt{alpha} is a scalar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L556-L562}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7105836662435355100}{} 
\hyperlink{7105836662435355100}{\texttt{Base.LinAlg.BLAS.sbmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sbmv!(uplo, k, alpha, A, x, beta, y)
\end{lstlisting}

Update vector \texttt{y} as \texttt{alpha*A*x + beta*y} where \texttt{A} is a a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. The storage layout for \texttt{A} is described the reference BLAS module, level-2 BLAS at \href{http://www.netlib.org/lapack/explore-html/}{http://www.netlib.org/lapack/explore-html/}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{A} is used.

Returns the updated \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L754-L764}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14656835492454293190}{} 
\hyperlink{14656835492454293190}{\texttt{Base.LinAlg.BLAS.sbmv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sbmv(uplo, k, alpha, A, x)
\end{lstlisting}

Returns \texttt{alpha*A*x} where \texttt{A} is a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L736-L742}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3096938461244060610}{} 
\hyperlink{3096938461244060610}{\texttt{Base.LinAlg.BLAS.sbmv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sbmv(uplo, k, A, x)
\end{lstlisting}

Returns \texttt{A*x} where \texttt{A} is a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L745-L751}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17677151106024314777}{} 
\hyperlink{17677151106024314777}{\texttt{Base.LinAlg.BLAS.gemm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemm!(tA, tB, alpha, A, B, beta, C)
\end{lstlisting}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or the other three variants according to \hyperlink{13285421231458545876}{\texttt{tA}} and \texttt{tB}. Returns the updated \texttt{C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L995-L1000}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9806047320196917327}{} 
\hyperlink{9806047320196917327}{\texttt{Base.LinAlg.BLAS.gemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemm(tA, tB, alpha, A, B)
\end{lstlisting}

Returns \texttt{alpha*A*B} or the other three variants according to \hyperlink{13285421231458545876}{\texttt{tA}} and \texttt{tB}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1047-L1051}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12613348301316395147}{} 
\hyperlink{12613348301316395147}{\texttt{Base.LinAlg.BLAS.gemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemm(tA, tB, A, B)
\end{lstlisting}

Returns \texttt{A*B} or the other three variants according to \hyperlink{13285421231458545876}{\texttt{tA}} and \texttt{tB}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1054-L1058}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15736921977878661892}{} 
\hyperlink{15736921977878661892}{\texttt{Base.LinAlg.BLAS.gemv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemv!(tA, alpha, A, x, beta, y)
\end{lstlisting}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y} or \texttt{alpha*A{\textquotesingle}x + beta*y} according to \hyperlink{13285421231458545876}{\texttt{tA}}. \texttt{alpha} and \texttt{beta} are scalars. Returns the updated \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L521-L527}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862317315303978311}{} 
\hyperlink{8862317315303978311}{\texttt{Base.LinAlg.BLAS.gemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemv(tA, alpha, A, x)
\end{lstlisting}

Returns \texttt{alpha*A*x} or \texttt{alpha*A{\textquotesingle}x} according to \hyperlink{13285421231458545876}{\texttt{tA}}. \texttt{alpha} is a scalar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L530-L535}{\texttt{source}}


\end{adjustwidth}
\hypertarget{918742973862313004}{} 
\hyperlink{918742973862313004}{\texttt{Base.LinAlg.BLAS.gemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemv(tA, A, x)
\end{lstlisting}

Returns \texttt{A*x} or \texttt{A{\textquotesingle}x} according to \hyperlink{13285421231458545876}{\texttt{tA}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L538-L542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11740755051464065516}{} 
\hyperlink{11740755051464065516}{\texttt{Base.LinAlg.BLAS.symm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symm!(side, ul, alpha, A, B, beta, C)
\end{lstlisting}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or \texttt{alpha*B*A + beta*C} according to \hyperlink{1714685266370616361}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. Returns the updated \texttt{C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1120-L1126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10057539686574772151}{} 
\hyperlink{10057539686574772151}{\texttt{Base.LinAlg.BLAS.symm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symm(side, ul, alpha, A, B)
\end{lstlisting}

Returns \texttt{alpha*A*B} or \texttt{alpha*B*A} according to \hyperlink{1714685266370616361}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1102-L1108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6490716086535561768}{} 
\hyperlink{6490716086535561768}{\texttt{Base.LinAlg.BLAS.symm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symm(side, ul, A, B)
\end{lstlisting}

Returns \texttt{A*B} or \texttt{B*A} according to \hyperlink{1714685266370616361}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1111-L1117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17354973722854633644}{} 
\hyperlink{17354973722854633644}{\texttt{Base.LinAlg.BLAS.symv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symv!(ul, alpha, A, x, beta, y)
\end{lstlisting}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} and \texttt{beta} are scalars. Returns the updated \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L601-L607}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1810587260758706176}{} 
\hyperlink{1810587260758706176}{\texttt{Base.LinAlg.BLAS.symv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symv(ul, alpha, A, x)
\end{lstlisting}

Returns \texttt{alpha*A*x}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} is a scalar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L652-L658}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11472950060043351908}{} 
\hyperlink{11472950060043351908}{\texttt{Base.LinAlg.BLAS.symv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symv(ul, A, x)
\end{lstlisting}

Returns \texttt{A*x}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L661-L666}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8221607203586908061}{} 
\hyperlink{8221607203586908061}{\texttt{Base.LinAlg.BLAS.trmm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trmm!(side, ul, tA, dA, alpha, A, B)
\end{lstlisting}

Update \texttt{B} as \texttt{alpha*A*B} or one of the other three variants determined by \hyperlink{1714685266370616361}{\texttt{side}} and \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{B}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1358-L1367}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3965394372558143122}{} 
\hyperlink{3965394372558143122}{\texttt{Base.LinAlg.BLAS.trmm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trmm(side, ul, tA, dA, alpha, A, B)
\end{lstlisting}

Returns \texttt{alpha*A*B} or one of the other three variants determined by \hyperlink{1714685266370616361}{\texttt{side}} and \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1370-L1378}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6978592120332459126}{} 
\hyperlink{6978592120332459126}{\texttt{Base.LinAlg.BLAS.trsm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsm!(side, ul, tA, dA, alpha, A, B)
\end{lstlisting}

Overwrite \texttt{B} with the solution to \texttt{A*X = alpha*B} or one of the other three variants determined by \hyperlink{1714685266370616361}{\texttt{side}} and \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{B}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1381-L1390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2754002660974992741}{} 
\hyperlink{2754002660974992741}{\texttt{Base.LinAlg.BLAS.trsm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsm(side, ul, tA, dA, alpha, A, B)
\end{lstlisting}

Returns the solution to \texttt{A*X = alpha*B} or one of the other three variants determined by determined by \hyperlink{1714685266370616361}{\texttt{side}} and \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1393-L1401}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12134943925780536161}{} 
\hyperlink{12134943925780536161}{\texttt{Base.LinAlg.BLAS.trmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trmv!(ul, tA, dA, A, b)
\end{lstlisting}

Returns \texttt{op(A)*b}, where \texttt{op} is determined by \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on \texttt{b}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L810-L818}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9978918795033628060}{} 
\hyperlink{9978918795033628060}{\texttt{Base.LinAlg.BLAS.trmv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trmv(ul, tA, dA, A, b)
\end{lstlisting}

Returns \texttt{op(A)*b}, where \texttt{op} is determined by \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L800-L807}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5394944235299548168}{} 
\hyperlink{5394944235299548168}{\texttt{Base.LinAlg.BLAS.trsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsv!(ul, tA, dA, A, b)
\end{lstlisting}

Overwrite \texttt{b} with the solution to \texttt{A*x = b} or one of the other two variants determined by \hyperlink{13285421231458545876}{\texttt{tA}} and \hyperlink{5558887752259302145}{\texttt{ul}}. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{b}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L852-L860}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17554193298347663786}{} 
\hyperlink{17554193298347663786}{\texttt{Base.LinAlg.BLAS.trsv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsv(ul, tA, dA, A, b)
\end{lstlisting}

Returns the solution to \texttt{A*x = b} or one of the other two variants determined by \hyperlink{13285421231458545876}{\texttt{tA}} and \hyperlink{5558887752259302145}{\texttt{ul}}. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L863-L870}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3656432689516664548}{} 
\hyperlink{3656432689516664548}{\texttt{Base.LinAlg.BLAS.set\_num\_threads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
set_num_threads(n)
\end{lstlisting}

Set the number of threads the BLAS library should use.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L89-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9063715718865527930}{} 
\hyperlink{9063715718865527930}{\texttt{Base.LinAlg.I}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
I
\end{lstlisting}

An object of type \texttt{UniformScaling}, representing an identity matrix of any size.

\textbf{Example}


\begin{minted}{jlcon}
julia> ones(5, 6) * I == ones(5, 6)
true

julia> [1 2im 3; 1im 2 3] * I
2×3 Array{Complex{Int64},2}:
 1+0im  0+2im  3+0im
 0+1im  2+0im  3+0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/uniformscaling.jl#L11-L27}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12804816841327767063}{}


\section{LAPACK Functions}



\texttt{Base.LinAlg.LAPACK} proporciona \emph{wrappers} para algunas de las funciones LAPACK para álgebra lineal. Las funciones que sobrescriben una de las matrices de entrada tienen nombres que terminan en \texttt{{\textquotesingle}!{\textquotesingle}}.



Por lo general, una función tiene 4 métodos definidos, uno para las arrays \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \texttt{Complex128} y \texttt{Complex64}.



Tenga en cuenta que la API LAPACK proporcionada por Julia puede y va a cambiar en el futuro. Dado que esta API no está orientada al usuario, no existe el compromiso de admitir/desaprobar este conjunto específico de funciones en futuras versiones.


\hypertarget{13382327346146829732}{} 
\hyperlink{13382327346146829732}{\texttt{Base.LinAlg.LAPACK.gbtrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gbtrf!(kl, ku, m, AB) -> (AB, ipiv)
\end{lstlisting}

Compute the LU factorization of a banded matrix \texttt{AB}. \texttt{kl} is the first subdiagonal containing a nonzero band, \texttt{ku} is the last superdiagonal containing one, and \texttt{m} is the first dimension of the matrix \texttt{AB}. Returns the LU factorization in-place and \texttt{ipiv}, the vector of pivots used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L161-L168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2900186876933432673}{} 
\hyperlink{2900186876933432673}{\texttt{Base.LinAlg.LAPACK.gbtrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gbtrs!(trans, kl, ku, m, AB, ipiv, B)
\end{lstlisting}

Solve the equation \texttt{AB * X = B}. \texttt{trans} determines the orientation of \texttt{AB}. It may be \texttt{N} (no transpose), \texttt{T} (transpose), or \texttt{C} (conjugate transpose). \texttt{kl} is the first subdiagonal containing a nonzero band, \texttt{ku} is the last superdiagonal containing one, and \texttt{m} is the first dimension of the matrix \texttt{AB}. \texttt{ipiv} is the vector of pivots returned from \texttt{gbtrf!}. Returns the vector or matrix \texttt{X}, overwriting \texttt{B} in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L171-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7129013550098860641}{} 
\hyperlink{7129013550098860641}{\texttt{Base.LinAlg.LAPACK.gebal!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gebal!(job, A) -> (ilo, ihi, scale)
\end{lstlisting}

Balance the matrix \texttt{A} before computing its eigensystem or Schur factorization. \texttt{job} can be one of \texttt{N} (\texttt{A} will not be permuted or scaled), \texttt{P} (\texttt{A} will only be permuted), \texttt{S} (\texttt{A} will only be scaled), or \texttt{B} (\texttt{A} will be both permuted and scaled). Modifies \texttt{A} in-place and returns \texttt{ilo}, \texttt{ihi}, and \texttt{scale}. If permuting was turned on, \texttt{A[i,j] = 0} if \texttt{j > i} and \texttt{1 < j < ilo} or \texttt{j > ihi}. \texttt{scale} contains information about the scaling/permutations performed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L235-L244}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12235933743122843113}{} 
\hyperlink{12235933743122843113}{\texttt{Base.LinAlg.LAPACK.gebak!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gebak!(job, side, ilo, ihi, scale, V)
\end{lstlisting}

Transform the eigenvectors \texttt{V} of a matrix balanced using \texttt{gebal!} to the unscaled/unpermuted eigenvectors of the original matrix. Modifies \texttt{V} in-place. \texttt{side} can be \texttt{L} (left eigenvectors are transformed) or \texttt{R} (right eigenvectors are transformed).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L247-L254}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5206402605985603637}{} 
\hyperlink{5206402605985603637}{\texttt{Base.LinAlg.LAPACK.gebrd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gebrd!(A) -> (A, d, e, tauq, taup)
\end{lstlisting}

Reduce \texttt{A} in-place to bidiagonal form \texttt{A = QBP{\textquotesingle}}. Returns \texttt{A}, containing the bidiagonal matrix \texttt{B}; \texttt{d}, containing the diagonal elements of \texttt{B}; \texttt{e}, containing the off-diagonal elements of \texttt{B}; \texttt{tauq}, containing the elementary reflectors representing \texttt{Q}; and \texttt{taup}, containing the elementary reflectors representing \texttt{P}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L544-L552}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6564335010672307185}{} 
\hyperlink{6564335010672307185}{\texttt{Base.LinAlg.LAPACK.gelqf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gelqf!(A, tau)
\end{lstlisting}

Compute the \texttt{LQ} factorization of \texttt{A}, \texttt{A = LQ}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L555-L564}{\texttt{source}}



\begin{lstlisting}
gelqf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{LQ} factorization of \texttt{A}, \texttt{A = LQ}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L650-L657}{\texttt{source}}


\end{adjustwidth}
\hypertarget{33314455129248297}{} 
\hyperlink{33314455129248297}{\texttt{Base.LinAlg.LAPACK.geqlf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqlf!(A, tau)
\end{lstlisting}

Compute the \texttt{QL} factorization of \texttt{A}, \texttt{A = QL}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L567-L575}{\texttt{source}}



\begin{lstlisting}
geqlf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{QL} factorization of \texttt{A}, \texttt{A = QL}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L660-L667}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15835472245352366559}{} 
\hyperlink{15835472245352366559}{\texttt{Base.LinAlg.LAPACK.geqrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqrf!(A, tau)
\end{lstlisting}

Compute the \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L617-L625}{\texttt{source}}



\begin{lstlisting}
geqrf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L692-L699}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2514050749741159031}{} 
\hyperlink{2514050749741159031}{\texttt{Base.LinAlg.LAPACK.geqp3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqp3!(A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3. \texttt{P} is a pivoting matrix, represented by \texttt{jpvt}. \texttt{tau} stores the elementary reflectors. \texttt{jpvt} must have length length greater than or equal to \texttt{n} if \texttt{A} is an \texttt{(m x n)} matrix. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

\texttt{A}, \texttt{jpvt}, and \texttt{tau} are modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L578-L588}{\texttt{source}}



\begin{lstlisting}
geqp3!(A, jpvt) -> (A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3. \texttt{P} is a pivoting matrix, represented by \texttt{jpvt}. \texttt{jpvt} must have length greater than or equal to \texttt{n} if \texttt{A} is an \texttt{(m x n)} matrix.

Returns \texttt{A} and \texttt{jpvt}, modified in-place, and \texttt{tau}, which stores the elementary reflectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L712-L721}{\texttt{source}}



\begin{lstlisting}
geqp3!(A) -> (A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3.

Returns \texttt{A}, modified in-place, \texttt{jpvt}, which represents the pivoting matrix \texttt{P}, and \texttt{tau}, which stores the elementary reflectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L727-L734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17144300602065123789}{} 
\hyperlink{17144300602065123789}{\texttt{Base.LinAlg.LAPACK.gerqf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gerqf!(A, tau)
\end{lstlisting}

Compute the \texttt{RQ} factorization of \texttt{A}, \texttt{A = RQ}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L628-L636}{\texttt{source}}



\begin{lstlisting}
gerqf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{RQ} factorization of \texttt{A}, \texttt{A = RQ}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L702-L709}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13356609639322528365}{} 
\hyperlink{13356609639322528365}{\texttt{Base.LinAlg.LAPACK.geqrt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqrt!(A, T)
\end{lstlisting}

Compute the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{T} contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of \texttt{T} sets the block size and it must be between 1 and \texttt{n}. The second dimension of \texttt{T} must equal the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{T} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L591-L601}{\texttt{source}}



\begin{lstlisting}
geqrt!(A, nb) -> (A, T)
\end{lstlisting}

Compute the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{nb} sets the block size and it must be between 1 and \texttt{n}, the second dimension of \texttt{A}.

Returns \texttt{A}, modified in-place, and \texttt{T}, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L670-L679}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16820445343879057799}{} 
\hyperlink{16820445343879057799}{\texttt{Base.LinAlg.LAPACK.geqrt3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqrt3!(A, T)
\end{lstlisting}

Recursively computes the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{T} contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of \texttt{T} sets the block size and it must be between 1 and \texttt{n}. The second dimension of \texttt{T} must equal the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{T} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L604-L614}{\texttt{source}}



\begin{lstlisting}
geqrt3!(A) -> (A, T)
\end{lstlisting}

Recursively computes the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}.

Returns \texttt{A}, modified in-place, and \texttt{T}, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L682-L689}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3745186706780328621}{} 
\hyperlink{3745186706780328621}{\texttt{Base.LinAlg.LAPACK.getrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getrf!(A) -> (A, ipiv, info)
\end{lstlisting}

Compute the pivoted \texttt{LU} factorization of \texttt{A}, \texttt{A = LU}.

Returns \texttt{A}, modified in-place, \texttt{ipiv}, the pivoting information, and an \texttt{info} code which indicates success (\texttt{info = 0}), a singular value in \texttt{U} (\texttt{info = i}, in which case \texttt{U[i,i]} is singular), or an error code (\texttt{info < 0}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L639-L647}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16652933518028418584}{} 
\hyperlink{16652933518028418584}{\texttt{Base.LinAlg.LAPACK.tzrzf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tzrzf!(A) -> (A, tau)
\end{lstlisting}

Transforms the upper trapezoidal matrix \texttt{A} to upper triangular form in-place. Returns \texttt{A} and \texttt{tau}, the scalar parameters for the elementary reflectors of the transformation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L834-L840}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12172653101378533786}{} 
\hyperlink{12172653101378533786}{\texttt{Base.LinAlg.LAPACK.ormrz!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormrz!(side, trans, A, tau, C)
\end{lstlisting}

Multiplies the matrix \texttt{C} by \texttt{Q} from the transformation supplied by \texttt{tzrzf!}. Depending on \texttt{side} or \texttt{trans} the multiplication can be left-sided (\texttt{side = L, Q*C}) or right-sided (\texttt{side = R, C*Q}) and \texttt{Q} can be unmodified (\texttt{trans = N}), transposed (\texttt{trans = T}), or conjugate transposed (\texttt{trans = C}). Returns matrix \texttt{C} which is modified in-place with the result of the multiplication.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L822-L831}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2557507265223459634}{} 
\hyperlink{2557507265223459634}{\texttt{Base.LinAlg.LAPACK.gels!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gels!(trans, A, B) -> (F, B, ssr)
\end{lstlisting}

Solves the linear equation \texttt{A * X = B}, \texttt{A.{\textquotesingle} * X =B}, or \texttt{A{\textquotesingle} * X = B} using a QR or LQ factorization. Modifies the matrix/vector \texttt{B} in place with the solution. \texttt{A} is overwritten with its \texttt{QR} or \texttt{LQ} factorization. \texttt{trans} may be one of \texttt{N} (no modification), \texttt{T} (transpose), or \texttt{C} (conjugate transpose). \texttt{gels!} searches for the minimum norm/least squares solution. \texttt{A} may be under or over determined. The solution is returned in \texttt{B}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L970-L979}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6382187281601335905}{} 
\hyperlink{6382187281601335905}{\texttt{Base.LinAlg.LAPACK.gesv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gesv!(A, B) -> (B, A, ipiv)
\end{lstlisting}

Solves the linear equation \texttt{A * X = B} where \texttt{A} is a square matrix using the \texttt{LU} factorization of \texttt{A}. \texttt{A} is overwritten with its \texttt{LU} factorization and \texttt{B} is overwritten with the solution \texttt{X}. \texttt{ipiv} contains the pivoting information for the \texttt{LU} factorization of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L982-L989}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11163778566912090029}{} 
\hyperlink{11163778566912090029}{\texttt{Base.LinAlg.LAPACK.getrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getrs!(trans, A, ipiv, B)
\end{lstlisting}

Solves the linear equation \texttt{A * X = B}, \texttt{A.{\textquotesingle} * X =B}, or \texttt{A{\textquotesingle} * X = B} for square \texttt{A}. Modifies the matrix/vector \texttt{B} in place with the solution. \texttt{A} is the \texttt{LU} factorization from \texttt{getrf!}, with \texttt{ipiv} the pivoting information. \texttt{trans} may be one of \texttt{N} (no modification), \texttt{T} (transpose), or \texttt{C} (conjugate transpose).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L992-L1000}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15848231100569895059}{} 
\hyperlink{15848231100569895059}{\texttt{Base.LinAlg.LAPACK.getri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getri!(A, ipiv)
\end{lstlisting}

Computes the inverse of \texttt{A}, using its \texttt{LU} factorization found by \texttt{getrf!}. \texttt{ipiv} is the pivot information output and \texttt{A} contains the \texttt{LU} factorization of \texttt{getrf!}. \texttt{A} is overwritten with its inverse.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1003-L1010}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14386545452297721776}{} 
\hyperlink{14386545452297721776}{\texttt{Base.LinAlg.LAPACK.gesvx!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)
\end{lstlisting}

Solves the linear equation \texttt{A * X = B} (\texttt{trans = N}), \texttt{A.{\textquotesingle} * X =B} (\texttt{trans = T}), or \texttt{A{\textquotesingle} * X = B} (\texttt{trans = C}) using the \texttt{LU} factorization of \texttt{A}. \texttt{fact} may be \texttt{E}, in which case \texttt{A} will be equilibrated and copied to \texttt{AF}; \texttt{F}, in which case \texttt{AF} and \texttt{ipiv} from a previous \texttt{LU} factorization are inputs; or \texttt{N}, in which case \texttt{A} will be copied to \texttt{AF} and then factored. If \texttt{fact = F}, \texttt{equed} may be \texttt{N}, meaning \texttt{A} has not been equilibrated; \texttt{R}, meaning \texttt{A} was multiplied by \texttt{diagm(R)} from the left; \texttt{C}, meaning \texttt{A} was multiplied by \texttt{diagm(C)} from the right; or \texttt{B}, meaning \texttt{A} was multiplied by \texttt{diagm(R)} from the left and \texttt{diagm(C)} from the right. If \texttt{fact = F} and \texttt{equed = R} or \texttt{B} the elements of \texttt{R} must all be positive. If \texttt{fact = F} and \texttt{equed = C} or \texttt{B} the elements of \texttt{C} must all be positive.

Returns the solution \texttt{X}; \texttt{equed}, which is an output if \texttt{fact} is not \texttt{N}, and describes the equilibration that was performed; \texttt{R}, the row equilibration diagonal; \texttt{C}, the column equilibration diagonal; \texttt{B}, which may be overwritten with its equilibrated form \texttt{diagm(R)*B} (if \texttt{trans = N} and \texttt{equed = R,B}) or \texttt{diagm(C)*B} (if \texttt{trans = T,C} and \texttt{equed = C,B}); \texttt{rcond}, the reciprocal condition number of \texttt{A} after equilbrating; \texttt{ferr}, the forward error bound for each solution vector in \texttt{X}; \texttt{berr}, the forward error bound for each solution vector in \texttt{X}; and \texttt{work}, the reciprocal pivot growth factor.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1153-L1176}{\texttt{source}}



\begin{lstlisting}
gesvx!(A, B)
\end{lstlisting}

The no-equilibration, no-transpose simplification of \texttt{gesvx!}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1180-L1184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12295012331561474310}{} 
\hyperlink{12295012331561474310}{\texttt{Base.LinAlg.LAPACK.gelsd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gelsd!(A, B, rcond) -> (B, rnk)
\end{lstlisting}

Computes the least norm solution of \texttt{A * X = B} by finding the \texttt{SVD} factorization of \texttt{A}, then dividing-and-conquering the problem. \texttt{B} is overwritten with the solution \texttt{X}. Singular values below \texttt{rcond} will be treated as zero. Returns the solution in \texttt{B} and the effective rank of \texttt{A} in \texttt{rnk}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1375-L1383}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2116984319227560409}{} 
\hyperlink{2116984319227560409}{\texttt{Base.LinAlg.LAPACK.gelsy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gelsy!(A, B, rcond) -> (B, rnk)
\end{lstlisting}

Computes the least norm solution of \texttt{A * X = B} by finding the full \texttt{QR} factorization of \texttt{A}, then dividing-and-conquering the problem. \texttt{B} is overwritten with the solution \texttt{X}. Singular values below \texttt{rcond} will be treated as zero. Returns the solution in \texttt{B} and the effective rank of \texttt{A} in \texttt{rnk}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1386-L1394}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17718650948605150276}{} 
\hyperlink{17718650948605150276}{\texttt{Base.LinAlg.LAPACK.gglse!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gglse!(A, c, B, d) -> (X,res)
\end{lstlisting}

Solves the equation \texttt{A * x = c} where \texttt{x} is subject to the equality constraint \texttt{B * x = d}. Uses the formula \texttt{||c - A*x||{\textasciicircum}2 = 0} to solve. Returns \texttt{X} and the residual sum-of-squares.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1447-L1453}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6857267594160515035}{} 
\hyperlink{6857267594160515035}{\texttt{Base.LinAlg.LAPACK.geev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geev!(jobvl, jobvr, A) -> (W, VL, VR)
\end{lstlisting}

Finds the eigensystem of \texttt{A}. If \texttt{jobvl = N}, the left eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed. Returns the eigenvalues in \texttt{W}, the right eigenvectors in \texttt{VR}, and the left eigenvectors in \texttt{VL}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1742-L1750}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15953579614147759298}{} 
\hyperlink{15953579614147759298}{\texttt{Base.LinAlg.LAPACK.gesdd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gesdd!(job, A) -> (U, S, VT)
\end{lstlisting}

Finds the singular value decomposition of \texttt{A}, \texttt{A = U * S * V{\textquotesingle}}, using a divide and conquer approach. If \texttt{job = A}, all the columns of \texttt{U} and the rows of \texttt{V{\textquotesingle}} are computed. If \texttt{job = N}, no columns of \texttt{U} or rows of \texttt{V{\textquotesingle}} are computed. If \texttt{job = O}, \texttt{A} is overwritten with the columns of (thin) \texttt{U} and the rows of (thin) \texttt{V{\textquotesingle}}. If \texttt{job = S}, the columns of (thin) \texttt{U} and the rows of (thin) \texttt{V{\textquotesingle}} are computed and returned separately.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1753-L1762}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10873609947280646096}{} 
\hyperlink{10873609947280646096}{\texttt{Base.LinAlg.LAPACK.gesvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gesvd!(jobu, jobvt, A) -> (U, S, VT)
\end{lstlisting}

Finds the singular value decomposition of \texttt{A}, \texttt{A = U * S * V{\textquotesingle}}. If \texttt{jobu = A}, all the columns of \texttt{U} are computed. If \texttt{jobvt = A} all the rows of \texttt{V{\textquotesingle}} are computed. If \texttt{jobu = N}, no columns of \texttt{U} are computed. If \texttt{jobvt = N} no rows of \texttt{V{\textquotesingle}} are computed. If \texttt{jobu = O}, \texttt{A} is overwritten with the columns of (thin) \texttt{U}. If \texttt{jobvt = O}, \texttt{A} is overwritten with the rows of (thin) \texttt{V{\textquotesingle}}. If \texttt{jobu = S}, the columns of (thin) \texttt{U} are computed and returned separately. If \texttt{jobvt = S} the rows of (thin) \texttt{V{\textquotesingle}} are computed and returned separately. \texttt{jobu} and \texttt{jobvt} can{\textquotesingle}t both be \texttt{O}.

Returns \texttt{U}, \texttt{S}, and \texttt{Vt}, where \texttt{S} are the singular values of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1765-L1778}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16049037685351559706}{} 
\hyperlink{16049037685351559706}{\texttt{Base.LinAlg.LAPACK.ggsvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ggsvd!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)
\end{lstlisting}

Finds the generalized singular value decomposition of \texttt{A} and \texttt{B}, \texttt{U{\textquotesingle}*A*Q = D1*R} and \texttt{V{\textquotesingle}*B*Q = D2*R}. \texttt{D1} has \texttt{alpha} on its diagonal and \texttt{D2} has \texttt{beta} on its diagonal. If \texttt{jobu = U}, the orthogonal/unitary matrix \texttt{U} is computed. If \texttt{jobv = V} the orthogonal/unitary matrix \texttt{V} is computed. If \texttt{jobq = Q}, the orthogonal/unitary matrix \texttt{Q} is computed. If \texttt{jobu}, \texttt{jobv} or \texttt{jobq} is \texttt{N}, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1781-L1791}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1004634299534576501}{} 
\hyperlink{1004634299534576501}{\texttt{Base.LinAlg.LAPACK.ggsvd3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ggsvd3!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)
\end{lstlisting}

Finds the generalized singular value decomposition of \texttt{A} and \texttt{B}, \texttt{U{\textquotesingle}*A*Q = D1*R} and \texttt{V{\textquotesingle}*B*Q = D2*R}. \texttt{D1} has \texttt{alpha} on its diagonal and \texttt{D2} has \texttt{beta} on its diagonal. If \texttt{jobu = U}, the orthogonal/unitary matrix \texttt{U} is computed. If \texttt{jobv = V} the orthogonal/unitary matrix \texttt{V} is computed. If \texttt{jobq = Q}, the orthogonal/unitary matrix \texttt{Q} is computed. If \texttt{jobu}, \texttt{jobv}, or \texttt{jobq} is \texttt{N}, that matrix is not computed. This function requires LAPACK 3.6.0.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1910-L1919}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5080871124512586132}{} 
\hyperlink{5080871124512586132}{\texttt{Base.LinAlg.LAPACK.geevx!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geevx!(balanc, jobvl, jobvr, sense, A) -> (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)
\end{lstlisting}

Finds the eigensystem of \texttt{A} with matrix balancing. If \texttt{jobvl = N}, the left eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed. If \texttt{balanc = N}, no balancing is performed. If \texttt{balanc = P}, \texttt{A} is permuted but not scaled. If \texttt{balanc = S}, \texttt{A} is scaled but not permuted. If \texttt{balanc = B}, \texttt{A} is permuted and scaled. If \texttt{sense = N}, no reciprocal condition numbers are computed. If \texttt{sense = E}, reciprocal condition numbers are computed for the eigenvalues only. If \texttt{sense = V}, reciprocal condition numbers are computed for the right eigenvectors only. If \texttt{sense = B}, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If \texttt{sense = E,B}, the right and left eigenvectors must be computed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2220-L2236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8207476271745139}{} 
\hyperlink{8207476271745139}{\texttt{Base.LinAlg.LAPACK.ggev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ggev!(jobvl, jobvr, A, B) -> (alpha, beta, vl, vr)
\end{lstlisting}

Finds the generalized eigendecomposition of \texttt{A} and \texttt{B}. If \texttt{jobvl = N}, the left eigenvectors aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2239-L2246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18443359303182750902}{} 
\hyperlink{18443359303182750902}{\texttt{Base.LinAlg.LAPACK.gtsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gtsv!(dl, d, du, B)
\end{lstlisting}

Solves the equation \texttt{A * X = B} where \texttt{A} is a tridiagonal matrix with \texttt{dl} on the subdiagonal, \texttt{d} on the diagonal, and \texttt{du} on the superdiagonal.

Overwrites \texttt{B} with the solution \texttt{X} and returns it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2413-L2421}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8852711688651638758}{} 
\hyperlink{8852711688651638758}{\texttt{Base.LinAlg.LAPACK.gttrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gttrf!(dl, d, du) -> (dl, d, du, du2, ipiv)
\end{lstlisting}

Finds the \texttt{LU} factorization of a tridiagonal matrix with \texttt{dl} on the subdiagonal, \texttt{d} on the diagonal, and \texttt{du} on the superdiagonal.

Modifies \texttt{dl}, \texttt{d}, and \texttt{du} in-place and returns them and the second superdiagonal \texttt{du2} and the pivoting vector \texttt{ipiv}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2424-L2432}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4530759117811213169}{} 
\hyperlink{4530759117811213169}{\texttt{Base.LinAlg.LAPACK.gttrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gttrs!(trans, dl, d, du, du2, ipiv, B)
\end{lstlisting}

Solves the equation \texttt{A * X = B} (\texttt{trans = N}), \texttt{A.{\textquotesingle} * X = B} (\texttt{trans = T}), or \texttt{A{\textquotesingle} * X = B} (\texttt{trans = C}) using the \texttt{LU} factorization computed by \texttt{gttrf!}. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2435-L2441}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4035457320125964281}{} 
\hyperlink{4035457320125964281}{\texttt{Base.LinAlg.LAPACK.orglq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orglq!(A, tau, k = length(tau))
\end{lstlisting}

Explicitly finds the matrix \texttt{Q} of a \texttt{LQ} factorization after calling \texttt{gelqf!} on \texttt{A}. Uses the output of \texttt{gelqf!}. \texttt{A} is overwritten by \texttt{Q}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2835-L2840}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3164127450970882180}{} 
\hyperlink{3164127450970882180}{\texttt{Base.LinAlg.LAPACK.orgqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orgqr!(A, tau, k = length(tau))
\end{lstlisting}

Explicitly finds the matrix \texttt{Q} of a \texttt{QR} factorization after calling \texttt{geqrf!} on \texttt{A}. Uses the output of \texttt{geqrf!}. \texttt{A} is overwritten by \texttt{Q}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2843-L2848}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10774109014374486854}{} 
\hyperlink{10774109014374486854}{\texttt{Base.LinAlg.LAPACK.orgql!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orgql!(A, tau, k = length(tau))
\end{lstlisting}

Explicitly finds the matrix \texttt{Q} of a \texttt{QL} factorization after calling \texttt{geqlf!} on \texttt{A}. Uses the output of \texttt{geqlf!}. \texttt{A} is overwritten by \texttt{Q}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2851-L2856}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11757217016830816757}{} 
\hyperlink{11757217016830816757}{\texttt{Base.LinAlg.LAPACK.orgrq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orgrq!(A, tau, k = length(tau))
\end{lstlisting}

Explicitly finds the matrix \texttt{Q} of a \texttt{RQ} factorization after calling \texttt{gerqf!} on \texttt{A}. Uses the output of \texttt{gerqf!}. \texttt{A} is overwritten by \texttt{Q}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2859-L2864}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1467921841608803290}{} 
\hyperlink{1467921841608803290}{\texttt{Base.LinAlg.LAPACK.ormlq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormlq!(side, trans, A, tau, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{LQ} factorization of \texttt{A} computed using \texttt{gelqf!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2867-L2874}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9717935803686995697}{} 
\hyperlink{9717935803686995697}{\texttt{Base.LinAlg.LAPACK.ormqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormqr!(side, trans, A, tau, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QR} factorization of \texttt{A} computed using \texttt{geqrf!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2877-L2884}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5040775879556201882}{} 
\hyperlink{5040775879556201882}{\texttt{Base.LinAlg.LAPACK.ormql!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormql!(side, trans, A, tau, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QL} factorization of \texttt{A} computed using \texttt{geqlf!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2887-L2894}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6079643517217636753}{} 
\hyperlink{6079643517217636753}{\texttt{Base.LinAlg.LAPACK.ormrq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormrq!(side, trans, A, tau, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{RQ} factorization of \texttt{A} computed using \texttt{gerqf!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2897-L2904}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4923525906529176288}{} 
\hyperlink{4923525906529176288}{\texttt{Base.LinAlg.LAPACK.gemqrt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemqrt!(side, trans, V, T, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QR} factorization of \texttt{A} computed using \texttt{geqrt!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2907-L2914}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7933076029998675408}{} 
\hyperlink{7933076029998675408}{\texttt{Base.LinAlg.LAPACK.posv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
posv!(uplo, A, B) -> (A, B)
\end{lstlisting}

Finds the solution to \texttt{A * X = B} where \texttt{A} is a symmetric or Hermitian positive definite matrix. If \texttt{uplo = U} the upper Cholesky decomposition of \texttt{A} is computed. If \texttt{uplo = L} the lower Cholesky decomposition of \texttt{A} is computed. \texttt{A} is overwritten by its Cholesky decomposition. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3045-L3053}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2675600524587319013}{} 
\hyperlink{2675600524587319013}{\texttt{Base.LinAlg.LAPACK.potrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
potrf!(uplo, A)
\end{lstlisting}

Computes the Cholesky (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) decomposition of positive-definite matrix \texttt{A}. \texttt{A} is overwritten and returned with an info code.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3056-L3062}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6335546978791941473}{} 
\hyperlink{6335546978791941473}{\texttt{Base.LinAlg.LAPACK.potri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
potri!(uplo, A)
\end{lstlisting}

Computes the inverse of positive-definite matrix \texttt{A} after calling \texttt{potrf!} to find its (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) Cholesky decomposition.

\texttt{A} is overwritten by its inverse and returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3065-L3073}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7150839328756297092}{} 
\hyperlink{7150839328756297092}{\texttt{Base.LinAlg.LAPACK.potrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
potrs!(uplo, A, B)
\end{lstlisting}

Finds the solution to \texttt{A * X = B} where \texttt{A} is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by \texttt{potrf!}. If \texttt{uplo = U} the upper Cholesky decomposition of \texttt{A} was computed. If \texttt{uplo = L} the lower Cholesky decomposition of \texttt{A} was computed. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3076-L3084}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16513636141865548042}{} 
\hyperlink{16513636141865548042}{\texttt{Base.LinAlg.LAPACK.pstrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pstrf!(uplo, A, tol) -> (A, piv, rank, info)
\end{lstlisting}

Computes the (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) pivoted Cholesky decomposition of positive-definite matrix \texttt{A} with a user-set tolerance \texttt{tol}. \texttt{A} is overwritten by its Cholesky decomposition.

Returns \texttt{A}, the pivots \texttt{piv}, the rank of \texttt{A}, and an \texttt{info} code. If \texttt{info = 0}, the factorization succeeded. If \texttt{info = i > 0}, then \texttt{A} is indefinite or rank-deficient.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3087-L3097}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5267267229624237648}{} 
\hyperlink{5267267229624237648}{\texttt{Base.LinAlg.LAPACK.ptsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ptsv!(D, E, B)
\end{lstlisting}

Solves \texttt{A * X = B} for positive-definite tridiagonal \texttt{A}. \texttt{D} is the diagonal of \texttt{A} and \texttt{E} is the off-diagonal. \texttt{B} is overwritten with the solution \texttt{X} and returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3152-L3158}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1357748730724903659}{} 
\hyperlink{1357748730724903659}{\texttt{Base.LinAlg.LAPACK.pttrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pttrf!(D, E)
\end{lstlisting}

Computes the LDLt factorization of a positive-definite tridiagonal matrix with \texttt{D} as diagonal and \texttt{E} as off-diagonal. \texttt{D} and \texttt{E} are overwritten and returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3161-L3167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11162461964270014949}{} 
\hyperlink{11162461964270014949}{\texttt{Base.LinAlg.LAPACK.pttrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pttrs!(D, E, B)
\end{lstlisting}

Solves \texttt{A * X = B} for positive-definite tridiagonal \texttt{A} with diagonal \texttt{D} and off-diagonal \texttt{E} after computing \texttt{A}{\textquotesingle}s LDLt factorization using \texttt{pttrf!}. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3232-L3238}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11243311595705981759}{} 
\hyperlink{11243311595705981759}{\texttt{Base.LinAlg.LAPACK.trtri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trtri!(uplo, diag, A)
\end{lstlisting}

Finds the inverse of (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{A} is overwritten with its inverse.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3297-L3304}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14919351476976495770}{} 
\hyperlink{14919351476976495770}{\texttt{Base.LinAlg.LAPACK.trtrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trtrs!(uplo, trans, diag, A, B)
\end{lstlisting}

Solves \texttt{A * X = B} (\texttt{trans = N}), \texttt{A.{\textquotesingle} * X = B} (\texttt{trans = T}), or \texttt{A{\textquotesingle} * X = B} (\texttt{trans = C}) for (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3307-L3315}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6868800184560636920}{} 
\hyperlink{6868800184560636920}{\texttt{Base.LinAlg.LAPACK.trcon!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trcon!(norm, uplo, diag, A)
\end{lstlisting}

Finds the reciprocal condition number of (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. If \texttt{norm = I}, the condition number is found in the infinity norm. If \texttt{norm = O} or \texttt{1}, the condition number is found in the one norm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3576-L3584}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1085452937331644402}{} 
\hyperlink{1085452937331644402}{\texttt{Base.LinAlg.LAPACK.trevc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))
\end{lstlisting}

Finds the eigensystem of an upper triangular matrix \texttt{T}. If \texttt{side = R}, the right eigenvectors are computed. If \texttt{side = L}, the left eigenvectors are computed. If \texttt{side = B}, both sets are computed. If \texttt{howmny = A}, all eigenvectors are found. If \texttt{howmny = B}, all eigenvectors are found and backtransformed using \texttt{VL} and \texttt{VR}. If \texttt{howmny = S}, only the eigenvectors corresponding to the values in \texttt{select} are computed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3587-L3597}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2844162264144144079}{} 
\hyperlink{2844162264144144079}{\texttt{Base.LinAlg.LAPACK.trrfs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -> (Ferr, Berr)
\end{lstlisting}

Estimates the error in the solution to \texttt{A * X = B} (\texttt{trans = N}), \texttt{A.{\textquotesingle} * X = B} (\texttt{trans = T}), \texttt{A{\textquotesingle} * X = B} (\texttt{trans = C}) for \texttt{side = L}, or the equivalent equations a right-handed \texttt{side = R} \texttt{X * A} after computing \texttt{X} using \texttt{trtrs!}. If \texttt{uplo = U}, \texttt{A} is upper triangular. If \texttt{uplo = L}, \texttt{A} is lower triangular. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{Ferr} and \texttt{Berr} are optional inputs. \texttt{Ferr} is the forward error and \texttt{Berr} is the backward error, each component-wise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3601-L3612}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1043772728109330061}{} 
\hyperlink{1043772728109330061}{\texttt{Base.LinAlg.LAPACK.stev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stev!(job, dv, ev) -> (dv, Zmat)
\end{lstlisting}

Computes the eigensystem for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{job = N} only the eigenvalues are found and returned in \texttt{dv}. If \texttt{job = V} then the eigenvectors are also found and returned in \texttt{Zmat}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3773-L3780}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4313264135687966731}{} 
\hyperlink{4313264135687966731}{\texttt{Base.LinAlg.LAPACK.stebz!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -> (dv, iblock, isplit)
\end{lstlisting}

Computes the eigenvalues for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. If \texttt{order = B}, eigvalues are ordered within a block. If \texttt{order = E}, they are ordered across all the blocks. \texttt{abstol} can be set as a tolerance for convergence.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3783-L3793}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18264060661441624867}{} 
\hyperlink{18264060661441624867}{\texttt{Base.LinAlg.LAPACK.stegr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stegr!(jobz, range, dv, ev, vl, vu, il, iu) -> (w, Z)
\end{lstlisting}

Computes the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. The eigenvalues are returned in \texttt{w} and the eigenvectors in \texttt{Z}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3796-L3806}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8214743586040698527}{} 
\hyperlink{8214743586040698527}{\texttt{Base.LinAlg.LAPACK.stein!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stein!(dv, ev_in, w_in, iblock_in, isplit_in)
\end{lstlisting}

Computes the eigenvectors for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev\_in} as off-diagonal. \texttt{w\_in} specifies the input eigenvalues for which to find corresponding eigenvectors. \texttt{iblock\_in} specifies the submatrices corresponding to the eigenvalues in \texttt{w\_in}. \texttt{isplit\_in} specifies the splitting points between the submatrix blocks.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3809-L3817}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2236040521224580683}{} 
\hyperlink{2236040521224580683}{\texttt{Base.LinAlg.LAPACK.syconv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syconv!(uplo, A, ipiv) -> (A, work)
\end{lstlisting}

Converts a symmetric matrix \texttt{A} (which has been factorized into a triangular matrix) into two matrices \texttt{L} and \texttt{D}. If \texttt{uplo = U}, \texttt{A} is upper triangular. If \texttt{uplo = L}, it is lower triangular. \texttt{ipiv} is the pivot vector from the triangular factorization. \texttt{A} is overwritten by \texttt{L} and \texttt{D}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4673-L4681}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7843986404244808539}{} 
\hyperlink{7843986404244808539}{\texttt{Base.LinAlg.LAPACK.sysv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sysv!(uplo, A, B) -> (B, A, ipiv)
\end{lstlisting}

Finds the solution to \texttt{A * X = B} for symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}. \texttt{A} is overwritten by its Bunch-Kaufman factorization. \texttt{ipiv} contains pivoting information about the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4684-L4692}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5785135406907595036}{} 
\hyperlink{5785135406907595036}{\texttt{Base.LinAlg.LAPACK.sytrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sytrf!(uplo, A) -> (A, ipiv, info)
\end{lstlisting}

Computes the Bunch-Kaufman factorization of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored.

Returns \texttt{A}, overwritten by the factorization, a pivot vector \texttt{ipiv}, and the error code \texttt{info} which is a non-negative integer. If \texttt{info} is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position \texttt{info}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4695-L4706}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16804210591865514013}{} 
\hyperlink{16804210591865514013}{\texttt{Base.LinAlg.LAPACK.sytri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sytri!(uplo, A, ipiv)
\end{lstlisting}

Computes the inverse of a symmetric matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{A} is overwritten by its inverse.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4709-L4715}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12379871855752390599}{} 
\hyperlink{12379871855752390599}{\texttt{Base.LinAlg.LAPACK.sytrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sytrs!(uplo, A, ipiv, B)
\end{lstlisting}

Solves the equation \texttt{A * X = B} for a symmetric matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4718-L4725}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15891292855935989899}{} 
\hyperlink{15891292855935989899}{\texttt{Base.LinAlg.LAPACK.hesv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hesv!(uplo, A, B) -> (B, A, ipiv)
\end{lstlisting}

Finds the solution to \texttt{A * X = B} for Hermitian matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}. \texttt{A} is overwritten by its Bunch-Kaufman factorization. \texttt{ipiv} contains pivoting information about the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4729-L4737}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15396067459248463}{} 
\hyperlink{15396067459248463}{\texttt{Base.LinAlg.LAPACK.hetrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hetrf!(uplo, A) -> (A, ipiv, info)
\end{lstlisting}

Computes the Bunch-Kaufman factorization of a Hermitian matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored.

Returns \texttt{A}, overwritten by the factorization, a pivot vector \texttt{ipiv}, and the error code \texttt{info} which is a non-negative integer. If \texttt{info} is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position \texttt{info}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4740-L4751}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9905060158086392271}{} 
\hyperlink{9905060158086392271}{\texttt{Base.LinAlg.LAPACK.hetri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hetri!(uplo, A, ipiv)
\end{lstlisting}

Computes the inverse of a Hermitian matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{A} is overwritten by its inverse.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4754-L4760}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6292228243520363864}{} 
\hyperlink{6292228243520363864}{\texttt{Base.LinAlg.LAPACK.hetrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hetrs!(uplo, A, ipiv, B)
\end{lstlisting}

Solves the equation \texttt{A * X = B} for a Hermitian matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4763-L4770}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3513320235373309950}{} 
\hyperlink{3513320235373309950}{\texttt{Base.LinAlg.LAPACK.syev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syev!(jobz, uplo, A)
\end{lstlisting}

Finds the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper triangle of \texttt{A} is used. If \texttt{uplo = L}, the lower triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5072-L5078}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15410150289254004118}{} 
\hyperlink{15410150289254004118}{\texttt{Base.LinAlg.LAPACK.syevr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -> (W, Z)
\end{lstlisting}

Finds the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper triangle of \texttt{A} is used. If \texttt{uplo = L}, the lower triangle of \texttt{A} is used. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. \texttt{abstol} can be set as a tolerance for convergence.

The eigenvalues are returned in \texttt{W} and the eigenvectors in \texttt{Z}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5081-L5093}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2852991601665604457}{} 
\hyperlink{2852991601665604457}{\texttt{Base.LinAlg.LAPACK.sygvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sygvd!(itype, jobz, uplo, A, B) -> (w, A, B)
\end{lstlisting}

Finds the generalized eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A} and symmetric positive-definite matrix \texttt{B}. If \texttt{uplo = U}, the upper triangles of \texttt{A} and \texttt{B} are used. If \texttt{uplo = L}, the lower triangles of \texttt{A} and \texttt{B} are used. If \texttt{itype = 1}, the problem to solve is \texttt{A * x = lambda * B * x}. If \texttt{itype = 2}, the problem to solve is \texttt{A * B * x = lambda * x}. If \texttt{itype = 3}, the problem to solve is \texttt{B * A * x = lambda * x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5097-L5108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5036448080004866989}{} 
\hyperlink{5036448080004866989}{\texttt{Base.LinAlg.LAPACK.bdsqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bdsqr!(uplo, d, e_, Vt, U, C) -> (d, Vt, U, C)
\end{lstlisting}

Computes the singular value decomposition of a bidiagonal matrix with \texttt{d} on the diagonal and \texttt{e\_} on the off-diagonal. If \texttt{uplo = U}, \texttt{e\_} is the superdiagonal. If \texttt{uplo = L}, \texttt{e\_} is the subdiagonal. Can optionally also compute the product \texttt{Q{\textquotesingle} * C}.

Returns the singular values in \texttt{d}, and the matrix \texttt{C} overwritten with \texttt{Q{\textquotesingle} * C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5160-L5169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15016094268647319816}{} 
\hyperlink{15016094268647319816}{\texttt{Base.LinAlg.LAPACK.bdsdc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bdsdc!(uplo, compq, d, e_) -> (d, e, u, vt, q, iq)
\end{lstlisting}

Computes the singular value decomposition of a bidiagonal matrix with \texttt{d} on the diagonal and \texttt{e\_} on the off-diagonal using a divide and conqueq method. If \texttt{uplo = U}, \texttt{e\_} is the superdiagonal. If \texttt{uplo = L}, \texttt{e\_} is the subdiagonal. If \texttt{compq = N}, only the singular values are found. If \texttt{compq = I}, the singular values and vectors are found. If \texttt{compq = P}, the singular values and vectors are found in compact form. Only works for real types.

Returns the singular values in \texttt{d}, and if \texttt{compq = P}, the compact singular vectors in \texttt{iq}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5228-L5240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5267068886550523397}{} 
\hyperlink{5267068886550523397}{\texttt{Base.LinAlg.LAPACK.gecon!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gecon!(normtype, A, anorm)
\end{lstlisting}

Finds the reciprocal condition number of matrix \texttt{A}. If \texttt{normtype = I}, the condition number is found in the infinity norm. If \texttt{normtype = O} or \texttt{1}, the condition number is found in the one norm. \texttt{A} must be the result of \texttt{getrf!} and \texttt{anorm} is the norm of \texttt{A} in the relevant norm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5311-L5318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17999493126378954334}{} 
\hyperlink{17999493126378954334}{\texttt{Base.LinAlg.LAPACK.gehrd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gehrd!(ilo, ihi, A) -> (A, tau)
\end{lstlisting}

Converts a matrix \texttt{A} to Hessenberg form. If \texttt{A} is balanced with \texttt{gebal!} then \texttt{ilo} and \texttt{ihi} are the outputs of \texttt{gebal!}. Otherwise they should be \texttt{ilo = 1} and \texttt{ihi = size(A,2)}. \texttt{tau} contains the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5361-L5368}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4988949518942718103}{} 
\hyperlink{4988949518942718103}{\texttt{Base.LinAlg.LAPACK.orghr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orghr!(ilo, ihi, A, tau)
\end{lstlisting}

Explicitly finds \texttt{Q}, the orthogonal/unitary matrix from \texttt{gehrd!}. \texttt{ilo}, \texttt{ihi}, \texttt{A}, and \texttt{tau} must correspond to the input/output to \texttt{gehrd!}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5410-L5415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1711655311938243223}{} 
\hyperlink{1711655311938243223}{\texttt{Base.LinAlg.LAPACK.gees!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gees!(jobvs, A) -> (A, vs, w)
\end{lstlisting}

Computes the eigenvalues (\texttt{jobvs = N}) or the eigenvalues and Schur vectors (\texttt{jobvs = V}) of matrix \texttt{A}. \texttt{A} is overwritten by its Schur form.

Returns \texttt{A}, \texttt{vs} containing the Schur vectors, and \texttt{w}, containing the eigenvalues.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5656-L5664}{\texttt{source}}


\end{adjustwidth}
\hypertarget{839810087458822727}{} 
\hyperlink{839810087458822727}{\texttt{Base.LinAlg.LAPACK.gges!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gges!(jobvsl, jobvsr, A, B) -> (A, B, alpha, beta, vsl, vsr)
\end{lstlisting}

Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (\texttt{jobsvl = V}), or right Schur vectors (\texttt{jobvsr = V}) of \texttt{A} and \texttt{B}.

The generalized eigenvalues are returned in \texttt{alpha} and \texttt{beta}. The left Schur vectors are returned in \texttt{vsl} and the right Schur vectors are returned in \texttt{vsr}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5668-L5677}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17908599480286718410}{} 
\hyperlink{17908599480286718410}{\texttt{Base.LinAlg.LAPACK.trexc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trexc!(compq, ifst, ilst, T, Q) -> (T, Q)
\end{lstlisting}

Reorder the Schur factorization of a matrix. If \texttt{compq = V}, the Schur vectors \texttt{Q} are reordered. If \texttt{compq = N} they are not modified. \texttt{ifst} and \texttt{ilst} specify the reordering of the vectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5972-L5978}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1707883259747849093}{} 
\hyperlink{1707883259747849093}{\texttt{Base.LinAlg.LAPACK.trsen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsen!(compq, job, select, T, Q) -> (T, Q, w)
\end{lstlisting}

Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If \texttt{job = N}, no condition numbers are found. If \texttt{job = E}, only the condition number for this cluster of eigenvalues is found. If \texttt{job = V}, only the condition number for the invariant subspace is found. If \texttt{job = B} then the condition numbers for the cluster and subspace are found. If \texttt{compq = V} the Schur vectors \texttt{Q} are updated. If \texttt{compq = N} the Schur vectors are not modified. \texttt{select} determines which eigenvalues are in the cluster.

Returns \texttt{T}, \texttt{Q}, and reordered eigenvalues in \texttt{w}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5981-L5994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17096834433503066270}{} 
\hyperlink{17096834433503066270}{\texttt{Base.LinAlg.LAPACK.tgsen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tgsen!(select, S, T, Q, Z) -> (S, T, alpha, beta, Q, Z)
\end{lstlisting}

Reorders the vectors of a generalized Schur decomposition. \texttt{select} specifices the eigenvalues in each cluster.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5997-L6002}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10259061194288213349}{} 
\hyperlink{10259061194288213349}{\texttt{Base.LinAlg.LAPACK.trsyl!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsyl!(transa, transb, A, B, C, isgn=1) -> (C, scale)
\end{lstlisting}

Solves the Sylvester matrix equation \texttt{A * X +/- X * B = scale*C} where \texttt{A} and \texttt{B} are both quasi-upper triangular. If \texttt{transa = N}, \texttt{A} is not modified. If \texttt{transa = T}, \texttt{A} is transposed. If \texttt{transa = C}, \texttt{A} is conjugate transposed. Similarly for \texttt{transb} and \texttt{B}. If \texttt{isgn = 1}, the equation \texttt{A * X + X * B = scale * C} is solved. If \texttt{isgn = -1}, the equation \texttt{A * X - X * B = scale * C} is solved.

Returns \texttt{X} (overwriting \texttt{C}) and \texttt{scale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L6036-L6047}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4380185033557519432}{}


\chapter{Constantes}


\hypertarget{9331422207248206047}{} 
\hyperlink{9331422207248206047}{\texttt{Core.nothing}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nothing
\end{lstlisting}

The singleton instance of type \texttt{Void}, used by convention when there is no value to return (as in a C \texttt{void} function). Can be converted to an empty \texttt{Nullable} value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L691-L696}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9054270179006636705}{} 
\hyperlink{9054270179006636705}{\texttt{Base.PROGRAM\_FILE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
PROGRAM_FILE
\end{lstlisting}

A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see \hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/initdefs.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2567473177880607455}{} 
\hyperlink{2567473177880607455}{\texttt{Base.ARGS}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ARGS
\end{lstlisting}

An array of the command line arguments passed to Julia, as strings.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/initdefs.jl#L14-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11444309529550205492}{} 
\hyperlink{11444309529550205492}{\texttt{Base.C\_NULL}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
C_NULL
\end{lstlisting}

The C null pointer constant, sometimes used when calling external code.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L13-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12605722316331458198}{} 
\hyperlink{12605722316331458198}{\texttt{Base.VERSION}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
VERSION
\end{lstlisting}

A \texttt{VersionNumber} object describing which version of Julia is in use. For details see \hyperlink{10038787961375920908}{Version Number Literals}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/version.jl#L220-L225}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17914149694871263675}{} 
\hyperlink{17914149694871263675}{\texttt{Base.LOAD\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LOAD_PATH
\end{lstlisting}

An array of paths as strings or custom loader objects for the \texttt{require} function and \texttt{using} and \texttt{import} statements to consider when loading code. To create a custom loader type, define the type and then add appropriate methods to the \texttt{Base.load\_hook} function with the following signature:


\begin{lstlisting}
Base.load_hook(loader::Loader, name::String, found::Any)
\end{lstlisting}

The \texttt{loader} argument is the current value in \texttt{LOAD\_PATH}, \texttt{name} is the name of the module to load, and \texttt{found} is the path of any previously found code to provide \texttt{name}. If no provider has been found earlier in \texttt{LOAD\_PATH} then the value of \texttt{found} will be \texttt{nothing}. Custom loader functionality is experimental and may break or change in Julia 1.0.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/initdefs.jl#L30-L46}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15863123579738922895}{} 
\hyperlink{15863123579738922895}{\texttt{Base.JULIA\_HOME}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
JULIA_HOME
\end{lstlisting}

A string containing the full path to the directory containing the \texttt{julia} executable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/initdefs.jl#L71-L75}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2025151930480900450}{} 
\hyperlink{2025151930480900450}{\texttt{Core.ANY}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ANY
\end{lstlisting}

Equivalent to \texttt{Any} for dispatch purposes, but signals the compiler to skip code generation specialization for that field.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L699-L704}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8935415573697237606}{} 
\hyperlink{8935415573697237606}{\texttt{Base.Sys.CPU\_CORES}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.CPU_CORES
\end{lstlisting}

The number of logical CPU cores available in the system.

See the Hwloc.jl package for extended information, including number of physical cores.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L22-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6553323097149877235}{} 
\hyperlink{6553323097149877235}{\texttt{Base.Sys.WORD\_SIZE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.WORD_SIZE
\end{lstlisting}

Standard word size on the current machine, in bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L53-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9866627704997689218}{} 
\hyperlink{9866627704997689218}{\texttt{Base.Sys.KERNEL}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.KERNEL
\end{lstlisting}

A symbol representing the name of the operating system, as returned by \texttt{uname} of the build configuration.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L39-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10411677719248532228}{} 
\hyperlink{10411677719248532228}{\texttt{Base.Sys.ARCH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.ARCH
\end{lstlisting}

A symbol representing the architecture of the build configuration.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L31-L35}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14835867711534070832}{} 
\hyperlink{14835867711534070832}{\texttt{Base.Sys.MACHINE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.MACHINE
\end{lstlisting}

A string containing the build triple.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L46-L50}{\texttt{source}}


\end{adjustwidth}

Ver también:



\begin{itemize}
\item \hyperlink{13806523663202420575}{\texttt{STDIN}}


\item \hyperlink{2784333101804678420}{\texttt{STDOUT}}


\item \hyperlink{4481879903628924306}{\texttt{STDERR}}


\item \hyperlink{196658496437650743}{\texttt{ENV}}


\item \hyperlink{15528013539058180213}{\texttt{ENDIAN\_BOM}}


\item \texttt{Libc.MS\_ASYNC}


\item \texttt{Libc.MS\_INVALIDATE}


\item \texttt{Libc.MS\_SYNC}


\item \hyperlink{17268797014804593519}{\texttt{Libdl.DL\_LOAD\_PATH}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_DEEPBIND}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_LOCAL}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_NOLOAD}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_LAZY}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_NOW}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_GLOBAL}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_NODELETE}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_FIRST}}

\end{itemize}


\hypertarget{2712977310167057511}{}


\chapter{Sistema de Ficheros}


\hypertarget{16313884780490629439}{} 
\hyperlink{16313884780490629439}{\texttt{Base.Filesystem.pwd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pwd() -> AbstractString
\end{lstlisting}

Get the current working directory.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L32-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2737128667296781766}{} 
\hyperlink{2737128667296781766}{\texttt{Base.Filesystem.cd}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cd(dir::AbstractString=homedir())
\end{lstlisting}

Set the current working directory.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L44-L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5425414028590761114}{} 
\hyperlink{5425414028590761114}{\texttt{Base.Filesystem.cd}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cd(f::Function, dir::AbstractString=homedir())
\end{lstlisting}

Temporarily changes the current working directory and applies function \texttt{f} before returning.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L77-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3860759521350595217}{} 
\hyperlink{3860759521350595217}{\texttt{Base.Filesystem.readdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdir(dir::AbstractString=".") -> Vector{String}
\end{lstlisting}

Returns the files and directories in the directory \texttt{dir} (or the current working directory if not given).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L403-L407}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6143720268840384551}{} 
\hyperlink{6143720268840384551}{\texttt{Base.Filesystem.walkdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
walkdir(dir; topdown=true, follow_symlinks=false, onerror=throw)
\end{lstlisting}

The \texttt{walkdir} method returns an iterator that walks the directory tree of a directory. The iterator returns a tuple containing \texttt{(rootpath, dirs, files)}. The directory tree can be traversed top-down or bottom-up. If \texttt{walkdir} encounters a \hyperlink{16303515589950241655}{\texttt{SystemError}} it will rethrow the error by default. A custom error handling function can be provided through \texttt{onerror} keyword argument. \texttt{onerror} is called with a \texttt{SystemError} as argument.


\begin{lstlisting}
for (root, dirs, files) in walkdir(".")
    println("Directories in $root")
    for dir in dirs
        println(joinpath(root, dir)) # path to directories
    end
    println("Files in $root")
    for file in files
        println(joinpath(root, file)) # path to files
    end
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L433-L455}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17495480510333417689}{} 
\hyperlink{17495480510333417689}{\texttt{Base.Filesystem.mkdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mkdir(path::AbstractString, mode::Unsigned=0o777)
\end{lstlisting}

Make a new directory with name \texttt{path} and permissions \texttt{mode}. \texttt{mode} defaults to \texttt{0o777}, modified by the current file creation mask. This function never creates more than one directory. If the directory already exists, or some intermediate directories do not exist, this function throws an error. See \hyperlink{12505165128372133919}{\texttt{mkpath}} for a function which creates all required intermediate directories.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L84-L92}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12505165128372133919}{} 
\hyperlink{12505165128372133919}{\texttt{Base.Filesystem.mkpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mkpath(path::AbstractString, mode::Unsigned=0o777)
\end{lstlisting}

Create all directories in the given \texttt{path}, with permissions \texttt{mode}. \texttt{mode} defaults to \texttt{0o777}, modified by the current file creation mask.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L102-L107}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2547536134326433103}{} 
\hyperlink{2547536134326433103}{\texttt{Base.Filesystem.symlink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symlink(target::AbstractString, link::AbstractString)
\end{lstlisting}

Creates a symbolic link to \texttt{target} with the name \texttt{link}.

\begin{quote}
\textbf{Note}

This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L543-L551}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17144805426178555631}{} 
\hyperlink{17144805426178555631}{\texttt{Base.Filesystem.readlink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readlink(path::AbstractString) -> AbstractString
\end{lstlisting}

Returns the target location a symbolic link \texttt{path} points to.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L574-L578}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11345760495317535206}{} 
\hyperlink{11345760495317535206}{\texttt{Base.Filesystem.chmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chmod(path::AbstractString, mode::Integer; recursive::Bool=false)
\end{lstlisting}

Change the permissions mode of \texttt{path} to \texttt{mode}. Only integer \texttt{mode}s (e.g. \texttt{0o777}) are currently supported. If \texttt{recursive=true} and the path is a directory all permissions in that directory will be recursively changed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L598-L604}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11782125422345839965}{} 
\hyperlink{11782125422345839965}{\texttt{Base.Filesystem.chown}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chown(path::AbstractString, owner::Integer, group::Integer=-1)
\end{lstlisting}

Change the owner and/or group of \texttt{path} to \texttt{owner} and/or \texttt{group}. If the value entered for \texttt{owner} or \texttt{group} is \texttt{-1} the corresponding ID will not change. Only integer \texttt{owner}s and \texttt{group}s are currently supported.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L618-L623}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10861694406169986183}{} 
\hyperlink{10861694406169986183}{\texttt{Base.stat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stat(file)
\end{lstlisting}

Returns a structure whose fields contain information about the file. The fields of the structure are:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Name & Description \\
\hline
size & The size (in bytes) of the file \\
\hline
device & ID of the device that contains the file \\
\hline
inode & The inode number of the file \\
\hline
mode & The protection mode of the file \\
\hline
nlink & The number of hard links to the file \\
\hline
uid & The user id of the owner of the file \\
\hline
gid & The group id of the file owner \\
\hline
rdev & If this file refers to a device, the ID of the device it refers to \\
\hline
blksize & The file-system preferred block size for the file \\
\hline
blocks & The number of such blocks allocated \\
\hline
mtime & Unix timestamp of when the file was last modified \\
\hline
ctime & Unix timestamp of when the file was created \\
\hline
\end{tabulary}

\end{table}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L83-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14136422515630953157}{} 
\hyperlink{14136422515630953157}{\texttt{Base.Filesystem.lstat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lstat(file)
\end{lstlisting}

Like \hyperlink{10861694406169986183}{\texttt{stat}}, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L107-L114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12867604313294084336}{} 
\hyperlink{12867604313294084336}{\texttt{Base.Filesystem.ctime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ctime(file)
\end{lstlisting}

Equivalent to \texttt{stat(file).ctime}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L140-L144}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6000535741376632237}{} 
\hyperlink{6000535741376632237}{\texttt{Base.Filesystem.mtime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mtime(file)
\end{lstlisting}

Equivalent to \texttt{stat(file).mtime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L133-L137}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13483994185565548500}{} 
\hyperlink{13483994185565548500}{\texttt{Base.Filesystem.filemode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filemode(file)
\end{lstlisting}

Equivalent to \texttt{stat(file).mode}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L119-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7772513328501904656}{} 
\hyperlink{7772513328501904656}{\texttt{Base.Filesystem.filesize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filesize(path...)
\end{lstlisting}

Equivalent to \texttt{stat(file).size}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L126-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1627468638377378187}{} 
\hyperlink{1627468638377378187}{\texttt{Base.Filesystem.uperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
uperm(file)
\end{lstlisting}

Gets the permissions of the owner of the file as a bitfield of


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Value & Description \\
\hline
01 & Execute Permission \\
\hline
02 & Write Permission \\
\hline
04 & Read Permission \\
\hline
\end{tabulary}

\end{table}

For allowed arguments, see \hyperlink{10861694406169986183}{\texttt{stat}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L228-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7004818904788863313}{} 
\hyperlink{7004818904788863313}{\texttt{Base.Filesystem.gperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gperm(file)
\end{lstlisting}

Like \hyperlink{1627468638377378187}{\texttt{uperm}} but gets the permissions of the group owning the file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L243-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5276829438522229212}{} 
\hyperlink{5276829438522229212}{\texttt{Base.Filesystem.operm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
operm(file)
\end{lstlisting}

Like \hyperlink{1627468638377378187}{\texttt{uperm}} but gets the permissions for people who neither own the file nor are a member of the group owning the file



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L250-L255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5101460505107133606}{} 
\hyperlink{5101460505107133606}{\texttt{Base.Filesystem.cp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cp(src::AbstractString, dst::AbstractString; remove_destination::Bool=false, follow_symlinks::Bool=false)
\end{lstlisting}

Copy the file, link, or directory from \texttt{src} to \texttt{dest}. \texttt{remove\_destination=true} will first remove an existing \texttt{dst}.

If \texttt{follow\_symlinks=false}, and \texttt{src} is a symbolic link, \texttt{dst} will be created as a symbolic link. If \texttt{follow\_symlinks=true} and \texttt{src} is a symbolic link, \texttt{dst} will be a copy of the file or directory \texttt{src} refers to.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L209-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3963309772903794843}{} 
\hyperlink{3963309772903794843}{\texttt{Base.download}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
download(url::AbstractString, [localfile::AbstractString])
\end{lstlisting}

Download a file from the given url, optionally renaming it to the given local file name. Note that this function relies on the availability of external tools such as \texttt{curl}, \texttt{wget} or \texttt{fetch} to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L635-L643}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5817011497347557360}{} 
\hyperlink{5817011497347557360}{\texttt{Base.Filesystem.mv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mv(src::AbstractString, dst::AbstractString; remove_destination::Bool=false)
\end{lstlisting}

Move the file, link, or directory from \texttt{src} to \texttt{dst}. \texttt{remove\_destination=true} will first remove an existing \texttt{dst}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L231-L236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9379238926612566029}{} 
\hyperlink{9379238926612566029}{\texttt{Base.Filesystem.rm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
\end{lstlisting}

Delete the file, link, or empty directory at the given path. If \texttt{force=true} is passed, a non-existing path is not treated as error. If \texttt{recursive=true} is passed and the path is a directory, then all contents are removed recursively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L129-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12527826024259193863}{} 
\hyperlink{12527826024259193863}{\texttt{Base.Filesystem.touch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
touch(path::AbstractString)
\end{lstlisting}

Update the last-modified timestamp on a file to the current time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L242-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14845808124082506604}{} 
\hyperlink{14845808124082506604}{\texttt{Base.Filesystem.tempname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tempname()
\end{lstlisting}

Generate a unique temporary file path.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L343-L347}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9014859942851246694}{} 
\hyperlink{9014859942851246694}{\texttt{Base.Filesystem.tempdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tempdir()
\end{lstlisting}

Obtain the path of a temporary directory (possibly shared with other processes).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L336-L340}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2973920645063648749}{} 
\hyperlink{2973920645063648749}{\texttt{Base.Filesystem.mktemp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mktemp(parent=tempdir())
\end{lstlisting}

Returns \texttt{(path, io)}, where \texttt{path} is the path of a new temporary file in \texttt{parent} and \texttt{io} is an open file object for this path.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L350-L355}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17153527788740684124}{} 
\hyperlink{17153527788740684124}{\texttt{Base.Filesystem.mktemp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mktemp(f::Function, parent=tempdir())
\end{lstlisting}

Apply the function \texttt{f} to the result of \hyperlink{2973920645063648749}{\texttt{mktemp(parent)}} and remove the temporary file upon completion.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L367-L372}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9834152207629649521}{} 
\hyperlink{9834152207629649521}{\texttt{Base.Filesystem.mktempdir}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mktempdir(parent=tempdir())
\end{lstlisting}

Create a temporary directory in the \texttt{parent} directory and return its path. If \texttt{parent} does not exist, throw an error.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L358-L363}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3895619673373952463}{} 
\hyperlink{3895619673373952463}{\texttt{Base.Filesystem.mktempdir}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mktempdir(f::Function, parent=tempdir())
\end{lstlisting}

Apply the function \texttt{f} to the result of \hyperlink{9834152207629649521}{\texttt{mktempdir(parent)}} and remove the temporary directory upon completion.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L383-L388}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12165280569414957484}{} 
\hyperlink{12165280569414957484}{\texttt{Base.Filesystem.isblockdev}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isblockdev(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a block device, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L177-L181}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16977107907382267368}{} 
\hyperlink{16977107907382267368}{\texttt{Base.Filesystem.ischardev}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ischardev(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a character device, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L163-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3518595943652428720}{} 
\hyperlink{3518595943652428720}{\texttt{Base.Filesystem.isdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdir(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a directory, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L170-L174}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5085310894552406152}{} 
\hyperlink{5085310894552406152}{\texttt{Base.Filesystem.isfifo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isfifo(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a FIFO, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L156-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7436789928697285849}{} 
\hyperlink{7436789928697285849}{\texttt{Base.Filesystem.isfile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isfile(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a regular file, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L184-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4451336630382958860}{} 
\hyperlink{4451336630382958860}{\texttt{Base.Filesystem.islink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
islink(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a symbolic link, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L191-L195}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5555615057884788946}{} 
\hyperlink{5555615057884788946}{\texttt{Base.Filesystem.ismount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ismount(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a mount point, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L296-L300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14301659288222317301}{} 
\hyperlink{14301659288222317301}{\texttt{Base.Filesystem.ispath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ispath(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a valid filesystem path, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L149-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13653840348451879213}{} 
\hyperlink{13653840348451879213}{\texttt{Base.Filesystem.issetgid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issetgid(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} has the setgid flag set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L214-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16213917845195501776}{} 
\hyperlink{16213917845195501776}{\texttt{Base.Filesystem.issetuid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issetuid(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} has the setuid flag set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L207-L211}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17017605444718674714}{} 
\hyperlink{17017605444718674714}{\texttt{Base.Filesystem.issocket}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issocket(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a socket, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L198-L202}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5099487162005794677}{} 
\hyperlink{5099487162005794677}{\texttt{Base.Filesystem.issticky}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issticky(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} has the sticky bit set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L221-L225}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10630566360559889134}{} 
\hyperlink{10630566360559889134}{\texttt{Base.Filesystem.homedir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
homedir() -> AbstractString
\end{lstlisting}

Return the current user{\textquotesingle}s home directory.

\begin{quote}
\textbf{Note}

\texttt{homedir} determines the home directory via \texttt{libuv}{\textquotesingle}s \texttt{uv\_os\_homedir}. For details (for example on how to specify the home directory via environment variables), see the \href{http://docs.libuv.org/en/v1.x/misc.html\#c.uv\_os\_homedir}{\texttt{uv\_os\_homedir} documentation}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L52-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10993431289442855643}{} 
\hyperlink{10993431289442855643}{\texttt{Base.Filesystem.dirname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dirname(path::AbstractString) -> AbstractString
\end{lstlisting}

Get the directory part of a path.


\begin{minted}{jlcon}
julia> dirname("/home/myuser")
"/home"
\end{minted}

See also: \hyperlink{16452154606861459390}{\texttt{basename}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L134-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16452154606861459390}{} 
\hyperlink{16452154606861459390}{\texttt{Base.Filesystem.basename}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
basename(path::AbstractString) -> AbstractString
\end{lstlisting}

Get the file name part of a path.


\begin{minted}{jlcon}
julia> basename("/home/myuser/example.jl")
"example.jl"
\end{minted}

See also: \hyperlink{10993431289442855643}{\texttt{dirname}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L148-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1518763743618824993}{} 
\hyperlink{1518763743618824993}{\texttt{Base.@\_\_FILE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@__FILE__ -> AbstractString
\end{lstlisting}

\texttt{@\_\_FILE\_\_} expands to a string with the absolute file path of the file containing the macro. Returns \texttt{nothing} if run from a REPL or an empty string if evaluated by \texttt{julia -e <expr>}. Alternatively see \hyperlink{9054270179006636705}{\texttt{PROGRAM\_FILE}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L548-L554}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12719499456415901450}{} 
\hyperlink{12719499456415901450}{\texttt{Base.@\_\_DIR\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@__DIR__ -> AbstractString
\end{lstlisting}

\texttt{@\_\_DIR\_\_} expands to a string with the directory part of the absolute path of the file containing the macro. Returns \texttt{nothing} if run from a REPL or an empty string if evaluated by \texttt{julia -e <expr>}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L557-L563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12003659955179127885}{} 
\hyperlink{12003659955179127885}{\texttt{@\_\_LINE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@__LINE__ -> Int
\end{lstlisting}

\texttt{@\_\_LINE\_\_} expands to the line number of the call-site.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L647-L651}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13394819469005127600}{} 
\hyperlink{13394819469005127600}{\texttt{Base.Filesystem.isabspath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isabspath(path::AbstractString) -> Bool
\end{lstlisting}

Determines whether a path is absolute (begins at the root directory).


\begin{minted}{jlcon}
julia> isabspath("/home")
true

julia> isabspath("home")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L86-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7293742883276660783}{} 
\hyperlink{7293742883276660783}{\texttt{Base.Filesystem.isdirpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdirpath(path::AbstractString) -> Bool
\end{lstlisting}

Determines whether a path refers to a directory (for example, ends with a path separator).


\begin{minted}{jlcon}
julia> isdirpath("/home")
false

julia> isdirpath("/home/")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L101-L113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12470257079932202886}{} 
\hyperlink{12470257079932202886}{\texttt{Base.Filesystem.joinpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
joinpath(parts...) -> AbstractString
\end{lstlisting}

Join path components into a full path. If some argument is an absolute path, then prior components are dropped.


\begin{minted}{jlcon}
julia> joinpath("/home/myuser","example.jl")
"/home/myuser/example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L194-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4673100532388501717}{} 
\hyperlink{4673100532388501717}{\texttt{Base.Filesystem.abspath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
abspath(path::AbstractString) -> AbstractString
\end{lstlisting}

Convert a path to an absolute path by adding the current directory if necessary.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L264-L268}{\texttt{source}}



\begin{lstlisting}
abspath(path::AbstractString, paths::AbstractString...) -> AbstractString
\end{lstlisting}

Convert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to \texttt{abspath(joinpath(path, paths...))}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L271-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5019859018770545283}{} 
\hyperlink{5019859018770545283}{\texttt{Base.Filesystem.normpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
normpath(path::AbstractString) -> AbstractString
\end{lstlisting}

Normalize a path, removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries.


\begin{minted}{jlcon}
julia> normpath("/home/myuser/../example.jl")
"/home/example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L219-L228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6055776470592315771}{} 
\hyperlink{6055776470592315771}{\texttt{Base.Filesystem.realpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
realpath(path::AbstractString) -> AbstractString
\end{lstlisting}

Canonicalize a path by expanding symbolic links and removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L319-L323}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16322454670651695984}{} 
\hyperlink{16322454670651695984}{\texttt{Base.Filesystem.relpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
relpath(path::AbstractString, startpath::AbstractString = ".") -> AbstractString
\end{lstlisting}

Return a relative filepath to \texttt{path} either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of \texttt{path} or \texttt{startpath}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L350-L356}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10521892386506791258}{} 
\hyperlink{10521892386506791258}{\texttt{Base.Filesystem.expanduser}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
expanduser(path::AbstractString) -> AbstractString
\end{lstlisting}

On Unix systems, replace a tilde character at the start of a path with the current user{\textquotesingle}s home directory.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L342-L346}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8483950538709909733}{} 
\hyperlink{8483950538709909733}{\texttt{Base.Filesystem.splitdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
splitdir(path::AbstractString) -> (AbstractString, AbstractString)
\end{lstlisting}

Split a path into a tuple of the directory name and file name.


\begin{minted}{jlcon}
julia> splitdir("/home/myuser")
("/home", "myuser")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L116-L125}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14253131097250488223}{} 
\hyperlink{14253131097250488223}{\texttt{Base.Filesystem.splitdrive}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
splitdrive(path::AbstractString) -> (AbstractString, AbstractString)
\end{lstlisting}

On Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L44-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4740094249280549542}{} 
\hyperlink{4740094249280549542}{\texttt{Base.Filesystem.splitext}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
splitext(path::AbstractString) -> (AbstractString, AbstractString)
\end{lstlisting}

If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.


\begin{minted}{jlcon}
julia> splitext("/home/myuser/example.jl")
("/home/myuser/example", ".jl")

julia> splitext("/home/myuser/example")
("/home/myuser/example", "")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L162-L176}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4334683019621329817}{}


\chapter{E/S y Redes}



\hypertarget{17923260793180482441}{}


\section{E/S General}


\hypertarget{2784333101804678420}{} 
\hyperlink{2784333101804678420}{\texttt{Base.STDOUT}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
STDOUT
\end{lstlisting}

Global variable referring to the standard out stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libuv.jl#L114-L118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4481879903628924306}{} 
\hyperlink{4481879903628924306}{\texttt{Base.STDERR}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
STDERR
\end{lstlisting}

Global variable referring to the standard error stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libuv.jl#L121-L125}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13806523663202420575}{} 
\hyperlink{13806523663202420575}{\texttt{Base.STDIN}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
STDIN
\end{lstlisting}

Global variable referring to the standard input stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libuv.jl#L107-L111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{300818094931158296}{} 
\hyperlink{300818094931158296}{\texttt{Base.open}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
open(filename::AbstractString, [read::Bool, write::Bool, create::Bool, truncate::Bool, append::Bool]) -> IOStream
\end{lstlisting}

Open a file in a mode specified by five boolean arguments. The default is to open files for reading only. Returns a stream for accessing the file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L96-L101}{\texttt{source}}



\begin{lstlisting}
open(filename::AbstractString, [mode::AbstractString]) -> IOStream
\end{lstlisting}

Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of \texttt{mode} correspond to those from \texttt{fopen(3)} or Perl \texttt{open}, and are equivalent to setting the following boolean groups:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Mode & Description \\
\hline
r & read \\
\hline
r+ & read, write \\
\hline
w & write, create, truncate \\
\hline
w+ & read, write, create, truncate \\
\hline
a & write, create, append \\
\hline
a+ & read, write, create, append \\
\hline
\end{tabulary}

\end{table}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L115-L130}{\texttt{source}}



\begin{lstlisting}
open(f::Function, args...)
\end{lstlisting}

Apply the function \texttt{f} to the result of \texttt{open(args...)} and close the resulting file descriptor upon completion.

\textbf{Example}: \texttt{open(readstring, {\textquotedbl}file.txt{\textquotedbl})}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L141-L148}{\texttt{source}}



\begin{lstlisting}
open(command, mode::AbstractString="r", stdio=DevNull)
\end{lstlisting}

Start running \texttt{command} asynchronously, and return a tuple \texttt{(stream,process)}.  If \texttt{mode} is \texttt{{\textquotedbl}r{\textquotedbl}}, then \texttt{stream} reads from the process{\textquotesingle}s standard output and \texttt{stdio} optionally specifies the process{\textquotesingle}s standard input stream.  If \texttt{mode} is \texttt{{\textquotedbl}w{\textquotedbl}}, then \texttt{stream} writes to the process{\textquotesingle}s standard input and \texttt{stdio} optionally specifies the process{\textquotesingle}s standard output stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L565-L573}{\texttt{source}}



\begin{lstlisting}
open(f::Function, command, mode::AbstractString="r", stdio=DevNull)
\end{lstlisting}

Similar to \texttt{open(command, mode, stdio)}, but calls \texttt{f(stream)} on the resulting read or write stream, then closes the stream and waits for the process to complete.  Returns the value returned by \texttt{f}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L591-L597}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15789326112236459498}{} 
\hyperlink{15789326112236459498}{\texttt{Base.IOBuffer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IOBuffer([data,],[readable::Bool=true, writable::Bool=true, [maxsize::Int=typemax(Int)]])
\end{lstlisting}

Create an \texttt{IOBuffer}, which may optionally operate on a pre-existing array. If the readable/writable arguments are given, they restrict whether or not the buffer may be read from or written to respectively. The last argument optionally specifies a size beyond which the buffer may not be grown.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L34-L41}{\texttt{source}}



\begin{lstlisting}
IOBuffer() -> IOBuffer
\end{lstlisting}

Create an in-memory I/O stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L51-L55}{\texttt{source}}



\begin{lstlisting}
IOBuffer(size::Int)
\end{lstlisting}

Create a fixed size IOBuffer. The buffer will not grow dynamically.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L58-L62}{\texttt{source}}



\begin{lstlisting}
IOBuffer(string::String)
\end{lstlisting}

Create a read-only \texttt{IOBuffer} on the data underlying the given string.


\begin{minted}{jlcon}
julia> io = IOBuffer("Haho");

julia> String(take!(io))
"Haho"

julia> String(take!(io))
"Haho"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L152-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4360129174058888556}{} 
\hyperlink{4360129174058888556}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
take!(b::IOBuffer)
\end{lstlisting}

Obtain the contents of an \texttt{IOBuffer} as an array, without copying. Afterwards, the \texttt{IOBuffer} is reset to its initial state.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L266-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4200832604380534486}{} 
\hyperlink{4200832604380534486}{\texttt{Base.fdio}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -> IOStream
\end{lstlisting}

Create an \texttt{IOStream} object from an integer file descriptor. If \texttt{own} is \texttt{true}, closing this object will close the underlying descriptor. By default, an \texttt{IOStream} is closed when it is garbage collected. \texttt{name} allows you to associate the descriptor with a named file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L80-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4551926523947041107}{} 
\hyperlink{4551926523947041107}{\texttt{Base.flush}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flush(stream)
\end{lstlisting}

Commit all currently buffered writes to the given stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L641-L645}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5331333469799487255}{} 
\hyperlink{5331333469799487255}{\texttt{Base.close}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
close(stream)
\end{lstlisting}

Close an I/O stream. Performs a \hyperlink{4551926523947041107}{\texttt{flush}} first.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L22-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16947913578760238729}{} 
\hyperlink{16947913578760238729}{\texttt{Base.write}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
write(stream::IO, x)
write(filename::AbstractString, x)
\end{lstlisting}

Write the canonical binary representation of a value to the given I/O stream or file. Returns the number of bytes written into the stream.

You can write multiple values with the same \texttt{write} call. i.e. the following are equivalent:


\begin{lstlisting}
write(stream, x, y...)
write(stream, x) + write(stream, y...)
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L52-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8104134490906192097}{} 
\hyperlink{8104134490906192097}{\texttt{Base.read}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
read(filename::AbstractString, args...)
\end{lstlisting}

Open a file and read its contents. \texttt{args} is passed to \texttt{read}: this is equivalent to \texttt{open(io->read(io, args...), filename)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L154-L159}{\texttt{source}}



\begin{lstlisting}
read(stream::IO, T, dims)
\end{lstlisting}

Read a series of values of type \texttt{T} from \texttt{stream}, in canonical binary representation. \texttt{dims} is either a tuple or a series of integer arguments specifying the size of the \texttt{Array\{T\}} to return.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L377-L383}{\texttt{source}}



\begin{lstlisting}
read(s::IO, nb=typemax(Int))
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{s}, returning a \texttt{Vector\{UInt8\}} of the bytes read.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L520-L524}{\texttt{source}}



\begin{lstlisting}
read(s::IOStream, nb::Integer; all=true)
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{s}, returning a \texttt{Vector\{UInt8\}} of the bytes read.

If \texttt{all} is \texttt{true} (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If \texttt{all} is \texttt{false}, at most one \texttt{read} call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the \texttt{all} option.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L295-L304}{\texttt{source}}



\begin{lstlisting}
read(stream::IO, T)
\end{lstlisting}

Read a single value of type \texttt{T} from \texttt{stream}, in canonical binary representation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1482-L1486}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7305890466159196010}{} 
\hyperlink{7305890466159196010}{\texttt{Base.read!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
read!(stream::IO, array::Union{Array, BitArray})
read!(filename::AbstractString, array::Union{Array, BitArray})
\end{lstlisting}

Read binary data from an I/O stream or file, filling in \texttt{array}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L39-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14376170011353973168}{} 
\hyperlink{14376170011353973168}{\texttt{Base.readbytes!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{stream} into \texttt{b}, returning the number of bytes read. The size of \texttt{b} will be increased if needed (i.e. if \texttt{nb} is greater than \texttt{length(b)} and enough bytes could be read), but it will never be decreased.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L495-L501}{\texttt{source}}



\begin{lstlisting}
readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{stream} into \texttt{b}, returning the number of bytes read. The size of \texttt{b} will be increased if needed (i.e. if \texttt{nb} is greater than \texttt{length(b)} and enough bytes could be read), but it will never be decreased.

See \hyperlink{8104134490906192097}{\texttt{read}} for a description of the \texttt{all} option.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L268-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14873825528169247088}{} 
\hyperlink{14873825528169247088}{\texttt{Base.unsafe\_read}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_read(io::IO, ref, nbytes::UInt)
\end{lstlisting}

Copy \texttt{nbytes} from the \texttt{IO} stream object into \texttt{ref} (converted to a pointer).

It is recommended that subtypes \texttt{T<:IO} override the following method signature to provide more efficient implementations: \texttt{unsafe\_read(s::T, p::Ptr\{UInt8\}, n::UInt)}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L86-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7085957152663564741}{} 
\hyperlink{7085957152663564741}{\texttt{Base.unsafe\_write}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_write(io::IO, ref, nbytes::UInt)
\end{lstlisting}

Copy \texttt{nbytes} from \texttt{ref} (converted to a pointer) into the \texttt{IO} object.

It is recommended that subtypes \texttt{T<:IO} override the following method signature to provide more efficient implementations: \texttt{unsafe\_write(s::T, p::Ptr\{UInt8\}, n::UInt)}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L69-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14999933350742523048}{} 
\hyperlink{14999933350742523048}{\texttt{Base.position}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
position(s)
\end{lstlisting}

Get the current position of a stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1224-L1228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11269748483301652100}{} 
\hyperlink{11269748483301652100}{\texttt{Base.seek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
seek(s, pos)
\end{lstlisting}

Seek a stream to the given position.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1057-L1061}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17809695755202491288}{} 
\hyperlink{17809695755202491288}{\texttt{Base.seekstart}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
seekstart(s)
\end{lstlisting}

Seek a stream to its beginning.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1691-L1695}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7051129712452805515}{} 
\hyperlink{7051129712452805515}{\texttt{Base.seekend}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
seekend(s)
\end{lstlisting}

Seek a stream to its end.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2654-L2658}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3828582500400083834}{} 
\hyperlink{3828582500400083834}{\texttt{Base.skip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
skip(s, offset)
\end{lstlisting}

Seek a stream relative to the current position.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L785-L789}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12695720152576749628}{} 
\hyperlink{12695720152576749628}{\texttt{Base.mark}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mark(s)
\end{lstlisting}

Add a mark at the current position of stream \texttt{s}. Returns the marked position.

See also \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{17642823092929127210}{\texttt{reset}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L589-L595}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1677829146244042320}{} 
\hyperlink{1677829146244042320}{\texttt{Base.unmark}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unmark(s)
\end{lstlisting}

Remove a mark from stream \texttt{s}. Returns \texttt{true} if the stream was marked, \texttt{false} otherwise.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{17642823092929127210}{\texttt{reset}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L600-L606}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17642823092929127210}{} 
\hyperlink{17642823092929127210}{\texttt{Base.reset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reset(s)
\end{lstlisting}

Reset a stream \texttt{s} to a previously marked position, and remove the mark. Returns the previously marked position. Throws an error if the stream is not marked.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L613-L620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5764088774799520350}{} 
\hyperlink{5764088774799520350}{\texttt{Base.ismarked}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ismarked(s)
\end{lstlisting}

Returns \texttt{true} if stream \texttt{s} is marked.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{17642823092929127210}{\texttt{reset}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L629-L635}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1214745596749163873}{} 
\hyperlink{1214745596749163873}{\texttt{Base.eof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eof(stream) -> Bool
\end{lstlisting}

Tests whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return \texttt{false}. Therefore it is always safe to read one byte after seeing \texttt{eof} return \texttt{false}. \texttt{eof} will return \texttt{false} as long as buffered data is still available, even if the remote end of a connection is closed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L137-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3535270730162763546}{} 
\hyperlink{3535270730162763546}{\texttt{Base.isreadonly}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isreadonly(stream) -> Bool
\end{lstlisting}

Determine whether a stream is read-only.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L275-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5354682531169079914}{} 
\hyperlink{5354682531169079914}{\texttt{Base.iswritable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iswritable(io) -> Bool
\end{lstlisting}

Returns \texttt{true} if the specified IO object is writable (if that can be determined).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L43-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7695515320845284530}{} 
\hyperlink{7695515320845284530}{\texttt{Base.isreadable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isreadable(io) -> Bool
\end{lstlisting}

Returns \texttt{true} if the specified IO object is readable (if that can be determined).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L36-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12411519405593851135}{} 
\hyperlink{12411519405593851135}{\texttt{Base.isopen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isopen(object) -> Bool
\end{lstlisting}

Determine whether an object - such as a stream, timer, or mmap – is not yet closed. Once an object is closed, it will never produce a new event. However, a closed stream may still have data to read in its buffer, use \hyperlink{1214745596749163873}{\texttt{eof}} to check for the ability to read data. Use \hyperlink{3484187138285863365}{\texttt{poll\_fd}} to be notified when a stream might be writable or readable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L12-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11136223858024612210}{} 
\hyperlink{11136223858024612210}{\texttt{Base.Serializer.serialize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
serialize(stream, value)
\end{lstlisting}

Write an arbitrary value to a stream in an opaque format, such that it can be read back by \hyperlink{9415765884989850449}{\texttt{deserialize}}. The read-back value will be as identical as possible to the original. In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. \texttt{Ptr} values are serialized as all-zero bit patterns (\texttt{NULL}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L990-L998}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9415765884989850449}{} 
\hyperlink{9415765884989850449}{\texttt{Base.Serializer.deserialize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deserialize(stream)
\end{lstlisting}

Read a value written by \hyperlink{11136223858024612210}{\texttt{serialize}}. \texttt{deserialize} assumes the binary data read from \texttt{stream} is correct and has been serialized by a compatible implementation of \hyperlink{11136223858024612210}{\texttt{serialize}}. It has been designed with simplicity and performance as a goal and does not validate the data read. Malformed data can result in process termination. The caller has to ensure the integrity and correctness of data read from \texttt{stream}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1997-L2005}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13482565886944504957}{} 
\hyperlink{13482565886944504957}{\texttt{Base.Grisu.print\_shortest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
print_shortest(io, x)
\end{lstlisting}

Print the shortest possible representation, with the minimum number of consecutive non-zero digits, of number \texttt{x}, ensuring that it would parse to the exact same number.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L572-L577}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4096210142404798505}{} 
\hyperlink{4096210142404798505}{\texttt{Base.fd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fd(stream)
\end{lstlisting}

Returns the file descriptor backing the stream or file. Note that this function only applies to synchronous \texttt{File}{\textquotesingle}s and \texttt{IOStream}{\textquotesingle}s not to any of the asynchronous streams.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L420-L425}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1112291265677833393}{} 
\hyperlink{1112291265677833393}{\texttt{Base.redirect\_stdout}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stdout([stream]) -> (rd, wr)
\end{lstlisting}

Create a pipe to which all C and Julia level \hyperlink{2784333101804678420}{\texttt{STDOUT}} output will be redirected. Returns a tuple \texttt{(rd, wr)} representing the pipe ends. Data written to \hyperlink{2784333101804678420}{\texttt{STDOUT}} may now be read from the \texttt{rd} end of the pipe. The \texttt{wr} end is given for convenience in case the old \hyperlink{2784333101804678420}{\texttt{STDOUT}} object was cached by the user and needs to be replaced elsewhere.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1042-L1055}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12923908242336925438}{} 
\hyperlink{12923908242336925438}{\texttt{Base.redirect\_stdout}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stdout(f::Function, stream)
\end{lstlisting}

Run the function \texttt{f} while redirecting \hyperlink{2784333101804678420}{\texttt{STDOUT}} to \texttt{stream}. Upon completion, \hyperlink{2784333101804678420}{\texttt{STDOUT}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1094-L1102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17653990356642003163}{} 
\hyperlink{17653990356642003163}{\texttt{Base.redirect\_stderr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stderr([stream]) -> (rd, wr)
\end{lstlisting}

Like \hyperlink{1112291265677833393}{\texttt{redirect\_stdout}}, but for \hyperlink{4481879903628924306}{\texttt{STDERR}}.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1058-L1065}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4630317800478362301}{} 
\hyperlink{4630317800478362301}{\texttt{Base.redirect\_stderr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stderr(f::Function, stream)
\end{lstlisting}

Run the function \texttt{f} while redirecting \hyperlink{4481879903628924306}{\texttt{STDERR}} to \texttt{stream}. Upon completion, \hyperlink{4481879903628924306}{\texttt{STDERR}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1105-L1113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17751303507361009787}{} 
\hyperlink{17751303507361009787}{\texttt{Base.redirect\_stdin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stdin([stream]) -> (rd, wr)
\end{lstlisting}

Like \hyperlink{1112291265677833393}{\texttt{redirect\_stdout}}, but for \hyperlink{13806523663202420575}{\texttt{STDIN}}. Note that the order of the return tuple is still \texttt{(rd, wr)}, i.e. data to be read from \hyperlink{13806523663202420575}{\texttt{STDIN}} may be written to \texttt{wr}.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1068-L1077}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17205945783347532140}{} 
\hyperlink{17205945783347532140}{\texttt{Base.redirect\_stdin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stdin(f::Function, stream)
\end{lstlisting}

Run the function \texttt{f} while redirecting \hyperlink{13806523663202420575}{\texttt{STDIN}} to \texttt{stream}. Upon completion, \hyperlink{13806523663202420575}{\texttt{STDIN}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1116-L1124}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1622401395685476756}{} 
\hyperlink{1622401395685476756}{\texttt{Base.readchomp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readchomp(x)
\end{lstlisting}

Read the entirety of \texttt{x} as a string and remove a single trailing newline. Equivalent to \texttt{chomp!(readstring(x))}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L485-L490}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16572122454613115528}{} 
\hyperlink{16572122454613115528}{\texttt{Base.truncate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
truncate(file,n)
\end{lstlisting}

Resize the file or buffer given by the first argument to exactly \texttt{n} bytes, filling previously unallocated space with {\textquotesingle}{\textbackslash}0{\textquotesingle} if the file or buffer is grown.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L615-L620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6177395059245061697}{} 
\hyperlink{6177395059245061697}{\texttt{Base.skipchars}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
skipchars(stream, predicate; linecomment::Char)
\end{lstlisting}

Advance the stream until before the first character for which \texttt{predicate} returns \texttt{false}. For example \texttt{skipchars(stream, isspace)} will skip all whitespace. If keyword argument \texttt{linecomment} is specified, characters from that character through the end of a line will also be skipped.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2494-L2501}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5045242378447855641}{} 
\hyperlink{5045242378447855641}{\texttt{Base.DataFmt.countlines}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
countlines(io::IO, eol::Char='\n')
\end{lstlisting}

Read \texttt{io} until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than \texttt{{\textquotesingle}{\textbackslash}n{\textquotesingle}} are supported by passing them as the second argument.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L20-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959584405141637900}{} 
\hyperlink{16959584405141637900}{\texttt{Base.PipeBuffer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
PipeBuffer(data::Vector{UInt8}=UInt8[],[maxsize::Int=typemax(Int)])
\end{lstlisting}

An \hyperlink{15789326112236459498}{\texttt{IOBuffer}} that allows reading and performs writes by appending. Seeking and truncating are not supported. See \hyperlink{15789326112236459498}{\texttt{IOBuffer}} for the available constructors. If \texttt{data} is given, creates a \texttt{PipeBuffer} to operate on a data vector, optionally specifying a size beyond which the underlying \texttt{Array} may not be grown.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L67-L75}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11079438348370067557}{} 
\hyperlink{11079438348370067557}{\texttt{Base.readavailable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readavailable(stream)
\end{lstlisting}

Read all available data on the stream, blocking the task only if no data is available. The result is a \texttt{Vector\{UInt8,1\}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2138-L2143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13454403377667762339}{} 
\hyperlink{13454403377667762339}{\texttt{Base.IOContext}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IOContext
\end{lstlisting}

\texttt{IOContext} provides a mechanism for passing output configuration settings among \hyperlink{14071376285304310153}{\texttt{show}} methods.

In short, it is an immutable dictionary that is a subclass of \texttt{IO}. It supports standard dictionary operations such as \hyperlink{2839226020402435013}{\texttt{getindex}}, and can also be used as an I/O stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/show.jl#L5-L12}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15316695504427164836}{} 
\hyperlink{15316695504427164836}{\texttt{Base.IOContext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IOContext(io::IO, KV::Pair)
\end{lstlisting}

Create an \texttt{IOContext} that wraps a given stream, adding the specified \texttt{key=>value} pair to the properties of that stream (note that \texttt{io} can itself be an \texttt{IOContext}).

\begin{itemize}
\item use \texttt{(key => value) in dict} to see if this particular combination is in the properties set


\item use \texttt{get(dict, key, default)} to retrieve the most recent value for a particular key

\end{itemize}
The following properties are in common use:

\begin{itemize}
\item \texttt{:compact}: Boolean specifying that small values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements.


\item \texttt{:limit}: Boolean specifying that containers should be truncated, e.g. showing \texttt{…} in place of most elements.


\item \texttt{:displaysize}: A \texttt{Tuple\{Int,Int\}} giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the \texttt{displaysize} function.

\end{itemize}

\begin{minted}{jlcon}
julia> function f(io::IO)
           if get(io, :short, false)
               print(io, "short")
           else
               print(io, "loooooong")
           end
       end
f (generic function with 1 method)

julia> f(STDOUT)
loooooong
julia> f(IOContext(STDOUT, :short => true))
short
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/show.jl#L54-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9657846139399432866}{} 
\hyperlink{9657846139399432866}{\texttt{Base.IOContext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IOContext(io::IO, context::IOContext)
\end{lstlisting}

Create an \texttt{IOContext} that wraps an alternate \texttt{IO} but inherits the properties of \texttt{context}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/show.jl#L47-L51}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3938862926454188721}{}


\section{E/S Texto}


\hypertarget{14071376285304310153}{} 
\hyperlink{14071376285304310153}{\texttt{Base.show}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
show(x)
\end{lstlisting}

Write an informative text representation of a value to the current output stream. New types should overload \texttt{show(io, x)} where the first argument is a stream. The representation used by \texttt{show} generally includes Julia-specific formatting and type information.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1853-L1859}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5384438952883464143}{} 
\hyperlink{5384438952883464143}{\texttt{Base.showcompact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
showcompact(x)
\end{lstlisting}

Show a compact representation of a value.

This is used for printing array elements without repeating type information (which would be redundant with that printed once for the whole array), and without line breaks inside the representation of an element.

To offer a compact representation different from its standard one, a custom type should test \texttt{get(io, :compact, false)} in its normal \texttt{show} method.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L822-L833}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16724886348217614039}{} 
\hyperlink{16724886348217614039}{\texttt{Base.showall}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
showall(x)
\end{lstlisting}

Similar to \hyperlink{14071376285304310153}{\texttt{show}}, except shows all elements of arrays.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2095-L2099}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17506338626525391609}{} 
\hyperlink{17506338626525391609}{\texttt{Base.summary}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
summary(x)
\end{lstlisting}

Return a string giving a brief description of a value. By default returns \texttt{string(typeof(x))}, e.g. \hyperlink{7720564657383125058}{\texttt{Int64}}.

For arrays, returns a string of size and type info, e.g. \texttt{10-element Array\{Int64,1\}}.


\begin{minted}{jlcon}
julia> summary(1)
"Int64"

julia> summary(zeros(2))
"2-element Array{Float64,1}"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/show.jl#L1544-L1560}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8248717042415202230}{} 
\hyperlink{8248717042415202230}{\texttt{Base.print}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
print(io::IO, x)
\end{lstlisting}

Write to \texttt{io} (or to the default output stream \hyperlink{2784333101804678420}{\texttt{STDOUT}} if \texttt{io} is not given) a canonical (un-decorated) text representation of a value if there is one, otherwise call \hyperlink{14071376285304310153}{\texttt{show}}. The representation used by \texttt{print} includes minimal formatting and tries to avoid Julia-specific details.


\begin{minted}{jlcon}
julia> print("Hello World!")
Hello World!
julia> io = IOBuffer();

julia> print(io, "Hello World!")

julia> String(take!(io))
"Hello World!"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L6-L25}{\texttt{source}}


\end{adjustwidth}
\hypertarget{783803254548423222}{} 
\hyperlink{783803254548423222}{\texttt{Base.println}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
println(io::IO, xs...)
\end{lstlisting}

Print (using \hyperlink{8248717042415202230}{\texttt{print}}) \texttt{xs} followed by a newline. If \texttt{io} is not supplied, prints to \hyperlink{2784333101804678420}{\texttt{STDOUT}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L48-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16954147589040544738}{} 
\hyperlink{16954147589040544738}{\texttt{Base.print\_with\_color}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
print_with_color(color::Union{Symbol, Int}, [io], xs...; bold::Bool = false)
\end{lstlisting}

Print \texttt{xs} in a color specified as a symbol.

\texttt{color} may take any of the values \texttt{:normal}, \texttt{:default}, \texttt{:bold}, \texttt{:black}, \texttt{:blue}, \texttt{:cyan}, \texttt{:green}, \texttt{:light\_black}, \texttt{:light\_blue}, \texttt{:light\_cyan}, \texttt{:light\_green}, \texttt{:light\_magenta}, \texttt{:light\_red}, \texttt{:light\_yellow}, \texttt{:magenta}, \texttt{:nothing}, \texttt{:red}, \texttt{:white}, or  \texttt{:yellow} or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword \texttt{bold} is given as \texttt{true}, the result will be printed in bold.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L408-L416}{\texttt{source}}


\end{adjustwidth}
\hypertarget{356857067498015374}{} 
\hyperlink{356857067498015374}{\texttt{Base.info}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
info([io, ] msg..., [prefix="INFO: "])
\end{lstlisting}

Display an informational message. Argument \texttt{msg} is a string describing the information to be displayed. The \texttt{prefix} keyword argument can be used to override the default prepending of \texttt{msg}.


\begin{minted}{jlcon}
julia> info("hello world")
INFO: hello world

julia> info("hello world"; prefix="MY INFO: ")
MY INFO: hello world
\end{minted}

See also \hyperlink{4663706027956713409}{\texttt{logging}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L508-L525}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9965317267326412304}{} 
\hyperlink{9965317267326412304}{\texttt{Base.warn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
warn([io, ] msg..., [prefix="WARNING: ", once=false, key=nothing, bt=nothing, filename=nothing, lineno::Int=0])
\end{lstlisting}

Display a warning. Argument \texttt{msg} is a string describing the warning to be displayed.  Set \texttt{once} to true and specify a \texttt{key} to only display \texttt{msg} the first time \texttt{warn} is called.  If \texttt{bt} is not \texttt{nothing} a backtrace is displayed. If \texttt{filename} is not \texttt{nothing} both it and \texttt{lineno} are displayed.

See also \hyperlink{4663706027956713409}{\texttt{logging}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L543-L552}{\texttt{source}}



\begin{lstlisting}
warn(msg)
\end{lstlisting}

Display a warning. Argument \texttt{msg} is a string describing the warning to be displayed.


\begin{minted}{jlcon}
julia> warn("Beep Beep")
WARNING: Beep Beep
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L579-L588}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4663706027956713409}{} 
\hyperlink{4663706027956713409}{\texttt{Base.logging}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logging(io [, m [, f]][; kind=:all])
logging([; kind=:all])
\end{lstlisting}

Stream output of informational, warning, and/or error messages to \texttt{io}, overriding what was otherwise specified.  Optionally, divert stream only for module \texttt{m}, or specifically function \texttt{f} within \texttt{m}.  \texttt{kind} can be \texttt{:all} (the default), \texttt{:info}, \texttt{:warn}, or \texttt{:error}.  See \texttt{Base.log\_\{info,warn,error\}\_to} for the current set of redirections.  Call \texttt{logging} with no arguments (or just the \texttt{kind}) to reset everything.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L482-L492}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4087473154660177488}{} 
\hyperlink{4087473154660177488}{\texttt{Base.Printf.@printf}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@printf([io::IOStream], "%Fmt", args...)
\end{lstlisting}

Print \texttt{args} using C \texttt{printf()} style format specification string, with some caveats: \texttt{Inf} and \texttt{NaN} are printed consistently as \texttt{Inf} and \texttt{NaN} for flags \texttt{\%a}, \texttt{\%A}, \texttt{\%e}, \texttt{\%E}, \texttt{\%f}, \texttt{\%F}, \texttt{\%g}, and \texttt{\%G}. Furthermore, if a floating point number is equally close to the numeric values of two possible output strings, the output string further away from zero is chosen.

Optionally, an \texttt{IOStream} may be passed as the first argument to redirect output.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @printf("%f %F %f %F\n", Inf, Inf, NaN, NaN)
Inf Inf NaN NaN


julia> @printf "%.0f %.1f %f\n" 0.5 0.025 -0.0078125
1 0.0 -0.007813
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/printf.jl#L1196-L1218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17601282773395979269}{} 
\hyperlink{17601282773395979269}{\texttt{Base.Printf.@sprintf}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@sprintf("%Fmt", args...)
\end{lstlisting}

Return \texttt{@printf} formatted output as string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> s = @sprintf "this is a %s %15.1f" "test" 34.567;

julia> println(s)
this is a test            34.6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/printf.jl#L1229-L1242}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6652981552509545835}{} 
\hyperlink{6652981552509545835}{\texttt{Base.sprint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sprint(f::Function, args...)
\end{lstlisting}

Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string.


\begin{minted}{jlcon}
julia> sprint(showcompact, 66.66666)
"66.6667"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L71-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{991925725019765935}{} 
\hyperlink{991925725019765935}{\texttt{Base.showerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
showerror(io, e)
\end{lstlisting}

Show a descriptive representation of an exception object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1754-L1758}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15981569052160951906}{} 
\hyperlink{15981569052160951906}{\texttt{Base.dump}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dump(x)
\end{lstlisting}

Show every part of the representation of a value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L530-L534}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6219586633767848672}{} 
\hyperlink{6219586633767848672}{\texttt{Base.readstring}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readstring(stream::IO)
readstring(filename::AbstractString)
\end{lstlisting}

Read the entire contents of an I/O stream or a file as a string. The text is assumed to be encoded in UTF-8.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L533-L539}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14199256323314707596}{} 
\hyperlink{14199256323314707596}{\texttt{Base.readline}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readline(stream::IO=STDIN; chomp::Bool=true)
readline(filename::AbstractString; chomp::Bool=true)
\end{lstlisting}

Read a single line of text from the given I/O stream or file (defaults to \texttt{STDIN}). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with \texttt{{\textquotesingle}{\textbackslash}n{\textquotesingle}} or \texttt{{\textquotedbl}{\textbackslash}r{\textbackslash}n{\textquotedbl}} or the end of an input stream. When \texttt{chomp} is true (as it is by default), these trailing newline characters are removed from the line before it is returned. When \texttt{chomp} is false, they are returned as part of the line.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L172-L182}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16924445721840905654}{} 
\hyperlink{16924445721840905654}{\texttt{Base.readuntil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readuntil(stream::IO, delim)
readuntil(filename::AbstractString, delim)
\end{lstlisting}

Read a string from an I/O stream or a file, up to and including the given delimiter byte. The text is assumed to be encoded in UTF-8.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L163-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2102076388448706590}{} 
\hyperlink{2102076388448706590}{\texttt{Base.readlines}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readlines(stream::IO=STDIN; chomp::Bool=true)
readlines(filename::AbstractString; chomp::Bool=true)
\end{lstlisting}

Read all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading \texttt{readline} repeatedly with the same arguments and saving the resulting lines as a vector of strings.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L201-L208}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3474649815265066504}{} 
\hyperlink{3474649815265066504}{\texttt{Base.eachline}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eachline(stream::IO=STDIN; chomp::Bool=true)
eachline(filename::AbstractString; chomp::Bool=true)
\end{lstlisting}

Create an iterable \texttt{EachLine} object that will yield each line from an I/O stream or a file. Iteration calls \texttt{readline} on the stream argument repeatedly with \texttt{chomp} passed through, determining whether trailing end-of-line characters are removed. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the \texttt{EachLine} object is garbage collected.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L554-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9382495003440185140}{} 
\hyperlink{9382495003440185140}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, delim::Char, T::Type, eol::Char; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=true, comment_char='#')
\end{lstlisting}

Read a matrix from the source where each line (separated by \texttt{eol}) gives one row, with elements separated by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.

If \texttt{T} is a numeric type, the result is an array of that type, with any non-numeric elements as \texttt{NaN} for floating-point types, or zero. Other useful values of \texttt{T} include \texttt{String}, \texttt{AbstractString}, and \texttt{Any}.

If \texttt{header} is \texttt{true}, the first row of data will be read as header and the tuple \texttt{(data\_cells, header\_cells)} is returned instead of only \texttt{data\_cells}.

Specifying \texttt{skipstart} will ignore the corresponding number of initial lines from the input.

If \texttt{skipblanks} is \texttt{true}, blank lines in the input will be ignored.

If \texttt{use\_mmap} is \texttt{true}, the file specified by \texttt{source} is memory mapped for potential speedups. Default is \texttt{true} except on Windows. On Windows, you may want to specify \texttt{true} if the file is large, and is only read once and not written to.

If \texttt{quotes} is \texttt{true}, columns enclosed within double-quote ({\textquotedbl}) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.  Specifying \texttt{dims} as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files.  If \texttt{comments} is \texttt{true}, lines beginning with \texttt{comment\_char} and text following \texttt{comment\_char} in any line are ignored.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L84-L113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2430245096432163029}{} 
\hyperlink{2430245096432163029}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, delim::Char, eol::Char; options...)
\end{lstlisting}

If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L75-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13737782927171831895}{} 
\hyperlink{13737782927171831895}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, delim::Char, T::Type; options...)
\end{lstlisting}

The end of line delimiter is taken as \texttt{{\textbackslash}n}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L49-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16397506814949064411}{} 
\hyperlink{16397506814949064411}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, delim::Char; options...)
\end{lstlisting}

The end of line delimiter is taken as \texttt{{\textbackslash}n}. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L66-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8065367939876398829}{} 
\hyperlink{8065367939876398829}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, T::Type; options...)
\end{lstlisting}

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \texttt{{\textbackslash}n}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L41-L46}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13577128997343551591}{} 
\hyperlink{13577128997343551591}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source; options...)
\end{lstlisting}

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \texttt{{\textbackslash}n}. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L56-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3228819019064430057}{} 
\hyperlink{3228819019064430057}{\texttt{Base.DataFmt.writedlm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
writedlm(f, A, delim='\t'; opts)
\end{lstlisting}

Write \texttt{A} (a vector, matrix, or an iterable collection of iterable rows) as text to \texttt{f} (either a filename string or an \texttt{IO} stream) using the given delimiter \texttt{delim} (which defaults to tab, but can be any printable Julia object, typically a \texttt{Char} or \texttt{AbstractString}).

For example, two vectors \texttt{x} and \texttt{y} of the same length can be written as two columns of tab-delimited text to \texttt{f} by either \texttt{writedlm(f, [x y])} or by \texttt{writedlm(f, zip(x, y))}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L687-L697}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8771248700292165260}{} 
\hyperlink{8771248700292165260}{\texttt{Base.DataFmt.readcsv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readcsv(source, [T::Type]; options...)
\end{lstlisting}

Equivalent to \hyperlink{9382495003440185140}{\texttt{readdlm}} with \texttt{delim} set to comma, and type optionally defined by \texttt{T}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1768-L1772}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1579565529432627071}{} 
\hyperlink{1579565529432627071}{\texttt{Base.DataFmt.writecsv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
writecsv(filename, A; opts)
\end{lstlisting}

Equivalent to \hyperlink{3228819019064430057}{\texttt{writedlm}} with \texttt{delim} set to comma.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L700-L704}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3188538343315807377}{} 
\hyperlink{3188538343315807377}{\texttt{Base.Base64.Base64EncodePipe}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base64EncodePipe(ostream)
\end{lstlisting}

Returns a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes written to \texttt{ostream}. Calling \hyperlink{5331333469799487255}{\texttt{close}} on the \texttt{Base64EncodePipe} stream is necessary to complete the encoding (but does not close \texttt{ostream}).


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> iob64_encode = Base64EncodePipe(io);

julia> write(iob64_encode, "Hello!")
6

julia> close(iob64_encode);

julia> str = String(take!(io))
"SGVsbG8h"

julia> String(base64decode(str))
"Hello!"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base64.jl#L17-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3574609743667104023}{} 
\hyperlink{3574609743667104023}{\texttt{Base.Base64.Base64DecodePipe}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base64DecodePipe(istream)
\end{lstlisting}

Returns a new read-only I/O stream, which decodes base64-encoded data read from \texttt{istream}.


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> iob64_decode = Base64DecodePipe(io);

julia> write(io, "SGVsbG8h")
8

julia> seekstart(io);

julia> String(read(iob64_decode))
"Hello!"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base64.jl#L205-L223}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13087986527599604968}{} 
\hyperlink{13087986527599604968}{\texttt{Base.Base64.base64encode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
base64encode(writefunc, args...)
base64encode(args...)
\end{lstlisting}

Given a \hyperlink{16947913578760238729}{\texttt{write}}-like function \texttt{writefunc}, which takes an I/O stream as its first argument, \texttt{base64encode(writefunc, args...)} calls \texttt{writefunc} to write \texttt{args...} to a base64-encoded string, and returns the string. \texttt{base64encode(args...)} is equivalent to \texttt{base64encode(write, args...)}: it converts its arguments into bytes using the standard \hyperlink{16947913578760238729}{\texttt{write}} functions and returns the base64-encoded string.

See also \hyperlink{16416907859759611603}{\texttt{base64decode}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base64.jl#L182-L193}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16416907859759611603}{} 
\hyperlink{16416907859759611603}{\texttt{Base.Base64.base64decode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
base64decode(string)
\end{lstlisting}

Decodes the base64-encoded \texttt{string} and returns a \texttt{Vector\{UInt8\}} of the decoded bytes.

See also \hyperlink{13087986527599604968}{\texttt{base64encode}}


\begin{minted}{jlcon}
julia> b = base64decode("SGVsbG8h")
6-element Array{UInt8,1}:
 0x48
 0x65
 0x6c
 0x6c
 0x6f
 0x21

julia> String(b)
"Hello!"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base64.jl#L257-L277}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1969380123003883060}{} 
\hyperlink{1969380123003883060}{\texttt{Base.displaysize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
displaysize(io) -> (lines, columns)
\end{lstlisting}

Return the nominal size of the screen that may be used for rendering output to this io object



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L351-L353}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7442676307456961159}{}


\section{E/S Multimedia}



Del mismo modo que la salida de texto se realiza mediante \hyperlink{8248717042415202230}{\texttt{print}} y los tipos definidos por el usuario pueden indicar su representación textual sobrecargando \hyperlink{14071376285304310153}{\texttt{show}}, Julia proporciona un mecanismo estandarizado para una salida multimedia enriquecida (como imágenes, texto formateado, o incluso audio y video) que consta de tres partes:



\begin{itemize}
\item Una función \hyperlink{12073120410747960438}{\texttt{display(x)}} para solicitar la visualización multimedia más completa disponible de un objeto Julia \texttt{x} (con una reserva de texto sin formato).


\item Sobrecargar \hyperlink{14071376285304310153}{\texttt{show}} permite indicar representaciones multimedia arbitrarias (codificadas mediante tipos MIME estándar) de tipos definidos por el usuario.


\item Pueden registrarse backends de visualización con capacidad multimedia subclasificando un tipo genérico de \texttt{Display} y poniéndolos en una pila de backends de visualización mediante \hyperlink{13142233867690107090}{\texttt{pushdisplay}}.

\end{itemize}


El tiempo de ejecución base de Julia proporciona solo visualización de texto sin formato, pero las pantallas más ricas pueden habilitarse cargando módulos externos o utilizando entornos gráficos de Julia (como el \emph{notebook} IJulia, basado en IPython).


\hypertarget{12073120410747960438}{} 
\hyperlink{12073120410747960438}{\texttt{Base.Multimedia.display}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
display(x)
display(d::Display, x)
display(mime, x)
display(d::Display, mime, x)
\end{lstlisting}

Display \texttt{x} using the topmost applicable display in the display stack, typically using the richest supported multimedia output for \texttt{x}, with plain-text \hyperlink{2784333101804678420}{\texttt{STDOUT}} output as a fallback. The \texttt{display(d, x)} variant attempts to display \texttt{x} on the given display \texttt{d} only, throwing a \texttt{MethodError} if \texttt{d} cannot display objects of this type.

There are also two variants with a \texttt{mime} argument (a MIME type string, such as \texttt{{\textquotedbl}image/png{\textquotedbl}}), which attempt to display \texttt{x} using the requested MIME type \emph{only}, throwing a \texttt{MethodError} if this type is not supported by either the display(s) or by \texttt{x}. With these variants, one can also supply the {\textquotedbl}raw{\textquotedbl} data in the requested MIME type by passing \texttt{x::AbstractString} (for MIME types with text-based storage, such as text/html or application/postscript) or \texttt{x::Vector\{UInt8\}} (for binary MIME types).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L544-L561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3747338623378176831}{} 
\hyperlink{3747338623378176831}{\texttt{Base.Multimedia.redisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redisplay(x)
redisplay(d::Display, x)
redisplay(mime, x)
redisplay(d::Display, mime, x)
\end{lstlisting}

By default, the \texttt{redisplay} functions simply call \hyperlink{12073120410747960438}{\texttt{display}}. However, some display backends may override \texttt{redisplay} to modify an existing display of \texttt{x} (if any). Using \texttt{redisplay} is also a hint to the backend that \texttt{x} may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L480-L492}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18261911967873698059}{} 
\hyperlink{18261911967873698059}{\texttt{Base.Multimedia.displayable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
displayable(mime) -> Bool
displayable(d::Display, mime) -> Bool
\end{lstlisting}

Returns a boolean value indicating whether the given \texttt{mime} type (string) is displayable by any of the displays in the current display stack, or specifically by the display \texttt{d} in the second variant.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L128-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{552201489544217829}{} 
\hyperlink{552201489544217829}{\texttt{Base.show}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
show(stream, mime, x)
\end{lstlisting}

The \texttt{display} functions ultimately call \texttt{show} in order to write an object \texttt{x} as a given \texttt{mime} type to a given I/O \texttt{stream} (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type \texttt{T}, it is only necessary to define a new \texttt{show} method for \texttt{T}, via: \texttt{show(stream, ::MIME{\textquotedbl}mime{\textquotedbl}, x::T) = ...}, where \texttt{mime} is a MIME-type string and the function body calls \texttt{write} (or similar) to write that representation of \texttt{x} to \texttt{stream}. (Note that the \texttt{MIME{\textquotedbl}{\textquotedbl}} notation only supports literal strings; to construct \texttt{MIME} types in a more flexible manner use \texttt{MIME\{Symbol({\textquotedbl}{\textquotedbl})\}}.)

For example, if you define a \texttt{MyImage} type and know how to write it to a PNG file, you could define a function \texttt{show(stream, ::MIME{\textquotedbl}image/png{\textquotedbl}, x::MyImage) = ...} to allow your images to be displayed on any PNG-capable \texttt{Display} (such as IJulia). As usual, be sure to \texttt{import Base.show} in order to add new methods to the built-in Julia function \texttt{show}.

The default MIME type is \texttt{MIME{\textquotedbl}text/plain{\textquotedbl}}. There is a fallback definition for \texttt{text/plain} output that calls \texttt{show} with 2 arguments. Therefore, this case should be handled by defining a 2-argument \texttt{show(stream::IO, x::MyType)} method.

Technically, the \texttt{MIME{\textquotedbl}mime{\textquotedbl}} macro defines a singleton type for the given \texttt{mime} string, which allows us to exploit Julia{\textquotesingle}s dispatch mechanisms in determining how to display objects of any given type.

The first argument to \texttt{show} can be an \hyperlink{13454403377667762339}{\texttt{IOContext}} specifying output format properties. See \hyperlink{13454403377667762339}{\texttt{IOContext}} for details.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1705-L1733}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12716323487860336005}{} 
\hyperlink{12716323487860336005}{\texttt{Base.Multimedia.mimewritable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mimewritable(mime, x)
\end{lstlisting}

Returns a boolean value indicating whether or not the object \texttt{x} can be written as the given \texttt{mime} type. (By default, this is determined automatically by the existence of the corresponding \hyperlink{14071376285304310153}{\texttt{show}} method for \texttt{typeof(x)}.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L28-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18010164488978074745}{} 
\hyperlink{18010164488978074745}{\texttt{Base.Multimedia.reprmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reprmime(mime, x)
\end{lstlisting}

Returns an \texttt{AbstractString} or \texttt{Vector\{UInt8\}} containing the representation of \texttt{x} in the requested \texttt{mime} type, as written by \texttt{show} (throwing a \texttt{MethodError} if no appropriate \texttt{show} is available). An \texttt{AbstractString} is returned for MIME types with textual representations (such as \texttt{{\textquotedbl}text/html{\textquotedbl}} or \texttt{{\textquotedbl}application/postscript{\textquotedbl}}), whereas binary data is returned as \texttt{Vector\{UInt8\}}. (The function \texttt{istextmime(mime)} returns whether or not Julia treats a given \texttt{mime} type as text.)

As a special case, if \texttt{x} is an \texttt{AbstractString} (for textual MIME types) or a \texttt{Vector\{UInt8\}} (for binary MIME types), the \texttt{reprmime} function assumes that \texttt{x} is already in the requested \texttt{mime} format and simply returns \texttt{x}. This special case does not apply to the \texttt{{\textquotedbl}text/plain{\textquotedbl}} MIME type. This is useful so that raw data can be passed to \texttt{display(m::MIME, x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L44-L60}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11286854929227524690}{} 
\hyperlink{11286854929227524690}{\texttt{Base.Multimedia.stringmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stringmime(mime, x)
\end{lstlisting}

Returns an \texttt{AbstractString} containing the representation of \texttt{x} in the requested \texttt{mime} type. This is similar to \hyperlink{18010164488978074745}{\texttt{reprmime}} except that binary data is base64-encoded as an ASCII string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L76-L82}{\texttt{source}}


\end{adjustwidth}

Como se mencionó anteriormente, también se pueden definir nuevos backends de pantalla. Por ejemplo, un módulo que puede mostrar imágenes PNG en una ventana puede registrar esta capacidad con Julia, de modo que llamar a \hyperlink{12073120410747960438}{\texttt{display(x)}} en tipos con representaciones PNG mostrará automáticamente la imagen usando la ventana del módulo.



Para definir un nuevo backend de pantalla, primero se debe crear un subtipo \texttt{D} de la clase abstracta \texttt{Display}. Luego, para cada tipo MIME (cadena \texttt{mime}) que se puede mostrar en \texttt{D}, uno debe definir una función \texttt{display(d::D, ::MIME{\textquotedbl}mime{\textquotedbl}, x) = ...} que muestra \texttt{x} como ese tipo MIME, generalmente llamando a \hyperlink{18010164488978074745}{\texttt{reprmime(mime, x)}}. Se debe lanzar \texttt{MethodError} si \texttt{x} no se puede mostrar como ese tipo MIME; esto es automático si uno llama a \hyperlink{18010164488978074745}{\texttt{reprmime}}. Finalmente, se debe definir una función \texttt{display(d::D, x)} que consulte \hyperlink{12716323487860336005}{\texttt{mimewritable(mime,x)}} para los tipos \texttt{mime} soportados por \texttt{D} y muestre el {\textquotedbl}mejor{\textquotedbl}; debe lanzarse un \texttt{MethodError} si no se encuentran tipos MIME soportados para \texttt{x}. Del mismo modo, algunos subtipos pueden sobreescribir \hyperlink{3747338623378176831}{\texttt{redisplay(d::D, ...)}}. (De nuevo, uno debe hacer \texttt{import Base.display} para agregar nuevos métodos a \texttt{display}.) Los valores de retorno de estas funciones dependen de la implementación (ya que en algunos casos puede ser útil devolver un {\textquotedbl}manejador{\textquotedbl} \emph{handle} de visualización de algunos tipo). Las funciones de visualización para \texttt{D} se pueden llamar directamente, pero también se pueden invocar automáticamente desde \hyperlink{12073120410747960438}{\texttt{display(x)}} simplemente presionando una nueva pantalla en la pila display-backend con:


\hypertarget{13142233867690107090}{} 
\hyperlink{13142233867690107090}{\texttt{Base.Multimedia.pushdisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pushdisplay(d::Display)
\end{lstlisting}

Pushes a new display \texttt{d} on top of the global display-backend stack. Calling \texttt{display(x)} or \texttt{display(mime, x)} will display \texttt{x} on the topmost compatible backend in the stack (i.e., the topmost backend that does not throw a \texttt{MethodError}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1657-L1663}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8186818521201126118}{} 
\hyperlink{8186818521201126118}{\texttt{Base.Multimedia.popdisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
popdisplay()
popdisplay(d::Display)
\end{lstlisting}

Pop the topmost backend off of the display-backend stack, or the topmost copy of \texttt{d} in the second variant.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1064-L1070}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15269032442876270904}{} 
\hyperlink{15269032442876270904}{\texttt{Base.Multimedia.TextDisplay}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
TextDisplay(io::IO)
\end{lstlisting}

Returns a \texttt{TextDisplay <: Display}, which displays any object as the text/plain MIME type (by default), writing the text representation to the given I/O stream. (This is how objects are printed in the Julia REPL.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L141-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14215879795817507566}{} 
\hyperlink{14215879795817507566}{\texttt{Base.Multimedia.istextmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istextmime(m::MIME)
\end{lstlisting}

Determine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L88-L93}{\texttt{source}}


\end{adjustwidth}

\hypertarget{1564933839463822836}{}


\section{E/S Mapeada en Memoria}


\hypertarget{9383012227778120639}{} 
\hyperlink{9383012227778120639}{\texttt{Base.Mmap.Anonymous}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mmap.Anonymous(name, readonly, create)
\end{lstlisting}

Create an \texttt{IO}-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in \texttt{Mmap.mmap}. Used by \texttt{SharedArray} for creating shared memory arrays.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L672-L677}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4658285737360128506}{} 
\hyperlink{4658285737360128506}{\texttt{Base.Mmap.mmap}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mmap.mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)
       Mmap.mmap(type::Type{Array{T,N}}, dims)
\end{lstlisting}

Create an \texttt{Array} whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer{\textquotesingle}s memory.

The type is an \texttt{Array\{T,N\}} with a bits-type element of \texttt{T} and dimension \texttt{N} that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).

\texttt{dims} is a tuple or single \hyperlink{8469131683393450448}{\texttt{Integer}} specifying the size or length of the array.

The file is passed via the stream argument, either as an open \texttt{IOStream} or filename string. When you initialize the stream, use \texttt{{\textquotedbl}r{\textquotedbl}} for a {\textquotedbl}read-only{\textquotedbl} array, and \texttt{{\textquotedbl}w+{\textquotedbl}} to create a new array used to write values to disk.

If no \texttt{type} argument is specified, the default is \texttt{Vector\{UInt8\}}.

Optionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an \texttt{IOStream}.

The \texttt{grow} keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is < requested array size). Write privileges are required to grow the file.

The \texttt{shared} keyword argument specifies whether the resulting \texttt{Array} and changes made to it will be visible to other processes mapping the same file.

For example, the following code


\begin{minted}{julia}
# Create a file for mmapping
# (you could alternatively use mmap to do this step, too)
A = rand(1:20, 5, 30)
s = open("/tmp/mmap.bin", "w+")
# We'll write the dimensions of the array as the first two Ints in the file
write(s, size(A,1))
write(s, size(A,2))
# Now write the data
write(s, A)
close(s)

# Test by reading it back in
s = open("/tmp/mmap.bin")   # default is read-only
m = read(s, Int)
n = read(s, Int)
A2 = Mmap.mmap(s, Matrix{Int}, (m,n))
\end{minted}

creates a \texttt{m}-by-\texttt{n} \texttt{Matrix\{Int\}}, linked to the file associated with stream \texttt{s}.

A more portable file would need to encode the word size – 32 bit or 64 bit – and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L240-L297}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17132422346626139321}{} 
\hyperlink{17132422346626139321}{\texttt{Base.Mmap.mmap}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mmap.mmap(io, BitArray, [dims, offset])
\end{lstlisting}

Create a \texttt{BitArray} whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as \hyperlink{4658285737360128506}{\texttt{mmap}}, but the byte representation is different.

\textbf{Example}: \texttt{B = Mmap.mmap(s, BitArray, (25,30000))}

This would create a 25-by-30000 \texttt{BitArray}, linked to the file associated with stream \texttt{s}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L300-L310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4141078992819732828}{} 
\hyperlink{4141078992819732828}{\texttt{Base.Mmap.sync!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mmap.sync!(array)
\end{lstlisting}

Forces synchronization between the in-memory version of a memory-mapped \texttt{Array} or \texttt{BitArray} and the on-disk version.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1454-L1459}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4209570105021842946}{}


\section{E/S por Red}


\hypertarget{9152037818560122293}{} 
\hyperlink{9152037818560122293}{\texttt{Base.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
connect([host], port::Integer) -> TCPSocket
\end{lstlisting}

Connect to the host \texttt{host} on port \texttt{port}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L732-L736}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1353346423333598473}{} 
\hyperlink{1353346423333598473}{\texttt{Base.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
connect(path::AbstractString) -> PipeEndpoint
\end{lstlisting}

Connect to the named pipe / UNIX domain socket at \texttt{path}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L990-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10380677384505520251}{} 
\hyperlink{10380677384505520251}{\texttt{Base.listen}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -> TCPServer
\end{lstlisting}

Listen on port on the address specified by \texttt{addr}. By default this listens on \texttt{localhost} only. To listen on all interfaces pass \texttt{IPv4(0)} or \texttt{IPv6(0)} as appropriate. \texttt{backlog} determines how many connections can be pending (not having called \hyperlink{7162820662735004343}{\texttt{accept}}) before the server will begin to reject them. The default value of \texttt{backlog} is 511.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L760-L769}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14347492126759386648}{} 
\hyperlink{14347492126759386648}{\texttt{Base.listen}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
listen(path::AbstractString) -> PipeServer
\end{lstlisting}

Create and listen on a named pipe / UNIX domain socket.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L961-L965}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8137893525760517927}{} 
\hyperlink{8137893525760517927}{\texttt{Base.getaddrinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getaddrinfo(host::AbstractString) -> IPAddr
\end{lstlisting}

Gets the IP address of the \texttt{host} (may have to do a DNS lookup)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L634-L638}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14708587739545871216}{} 
\hyperlink{14708587739545871216}{\texttt{Base.getsockname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getsockname(sock::Union{TCPServer, TCPSocket}) -> (IPAddr, UInt16)
\end{lstlisting}

Get the IP address and the port that the given \texttt{TCPSocket} is connected to (or bound to, in the case of \texttt{TCPServer}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L845-L850}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5743057836324524757}{} 
\hyperlink{5743057836324524757}{\texttt{Base.IPv4}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IPv4(host::Integer) -> IPv4
\end{lstlisting}

Returns an IPv4 object from ip address \texttt{host} formatted as an \hyperlink{8469131683393450448}{\texttt{Integer}}.


\begin{minted}{jlcon}
julia> IPv4(3223256218)
ip"192.30.252.154"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L24-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5798078005905633860}{} 
\hyperlink{5798078005905633860}{\texttt{Base.IPv6}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IPv6(host::Integer) -> IPv6
\end{lstlisting}

Returns an IPv6 object from ip address \texttt{host} formatted as an \hyperlink{8469131683393450448}{\texttt{Integer}}.


\begin{minted}{jlcon}
julia> IPv6(3223256218)
ip"::c01e:fc9a"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L76-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12266333145421576763}{} 
\hyperlink{12266333145421576763}{\texttt{Base.nb\_available}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nb_available(stream)
\end{lstlisting}

Returns the number of bytes available for reading before a read from this stream or buffer will block.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L130-L134}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7162820662735004343}{} 
\hyperlink{7162820662735004343}{\texttt{Base.accept}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
accept(server[,client])
\end{lstlisting}

Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L663-L669}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7883192476116766616}{} 
\hyperlink{7883192476116766616}{\texttt{Base.listenany}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
listenany([host::IPAddr,] port_hint) -> (UInt16, TCPServer)
\end{lstlisting}

Create a \texttt{TCPServer} on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L818-L823}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3484187138285863365}{} 
\hyperlink{3484187138285863365}{\texttt{Base.Filesystem.poll\_fd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
poll_fd(fd, timeout_s::Real=-1; readable=false, writable=false)
\end{lstlisting}

Monitor a file descriptor \texttt{fd} for changes in the read or write availability, and with a timeout given by \texttt{timeout\_s} seconds.

The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to \texttt{true}.

The returned value is an object with boolean fields \texttt{readable}, \texttt{writable}, and \texttt{timedout}, giving the result of the polling.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/poll.jl#L434-L445}{\texttt{source}}


\end{adjustwidth}
\hypertarget{929081692282555917}{} 
\hyperlink{929081692282555917}{\texttt{Base.Filesystem.poll\_file}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -> (previous::StatStruct, current::StatStruct)
\end{lstlisting}

Monitor a file for changes by polling every \texttt{interval\_s} seconds until a change occurs or \texttt{timeout\_s} seconds have elapsed. The \texttt{interval\_s} should be a long period; the default is 5.007 seconds.

Returns a pair of \texttt{StatStruct} objects \texttt{(previous, current)} when a change is detected.

To determine when a file was modified, compare \texttt{mtime(prev) != mtime(current)} to detect notification of changes. However, using \hyperlink{11014074322803760052}{\texttt{watch\_file}} for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/poll.jl#L514-L526}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014074322803760052}{} 
\hyperlink{11014074322803760052}{\texttt{Base.Filesystem.watch\_file}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
watch_file(path::AbstractString, timeout_s::Real=-1)
\end{lstlisting}

Watch file or directory \texttt{path} for changes until a change occurs or \texttt{timeout\_s} seconds have elapsed.

The returned value is an object with boolean fields \texttt{changed}, \texttt{renamed}, and \texttt{timedout}, giving the result of watching the file.

This behavior of this function varies slightly across platforms. See \href{https://nodejs.org/api/fs.html\#fs\_caveats}{https://nodejs.org/api/fs.html\#fs\_caveats} for more detailed information.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/poll.jl#L474-L485}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13811388816704022260}{} 
\hyperlink{13811388816704022260}{\texttt{Base.bind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bind(socket::Union{UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false, reuseaddr=false, kws...)
\end{lstlisting}

Bind \texttt{socket} to the given \texttt{host:port}. Note that \texttt{0.0.0.0} will listen on all devices.

\begin{itemize}
\item The \texttt{ipv6only} parameter disables dual stack mode. If \texttt{ipv6only=true}, only an IPv6 stack is created.


\item If \texttt{reuseaddr=true}, multiple threads or processes can bind to the same address without error if they all set \texttt{reuseaddr=true}, but only the last to bind will receive any traffic.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L415-L423}{\texttt{source}}



\begin{lstlisting}
bind(chnl::Channel, task::Task)
\end{lstlisting}

Associates the lifetime of \texttt{chnl} with a task. Channel \texttt{chnl} is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on \texttt{chnl}.

The \texttt{chnl} object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.

When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @schedule foreach(i->put!(c, i), 1:4);

julia> bind(c,task);

julia> for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia> isopen(c)
false
\end{minted}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @schedule (put!(c,1);error("foo"));

julia> bind(c,task);

julia> take!(c)
1

julia> put!(c,1);
ERROR: foo
Stacktrace:
 [1] check_channel_state(::Channel{Any}) at ./channels.jl:131
 [2] put!(::Channel{Any}, ::Int64) at ./channels.jl:261
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L151-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12578302244914335012}{} 
\hyperlink{12578302244914335012}{\texttt{Base.send}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
send(socket::UDPSocket, host, port::Integer, msg)
\end{lstlisting}

Send \texttt{msg} over \texttt{socket} to \texttt{host:port}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L551-L555}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10601222310551867735}{} 
\hyperlink{10601222310551867735}{\texttt{Base.recv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
recv(socket::UDPSocket)
\end{lstlisting}

Read a UDP packet from the specified socket, and return the bytes received. This call blocks.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L480-L484}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9185179791660962548}{} 
\hyperlink{9185179791660962548}{\texttt{Base.recvfrom}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
recvfrom(socket::UDPSocket) -> (address, data)
\end{lstlisting}

Read a UDP packet from the specified socket, returning a tuple of \texttt{(address, data)}, where \texttt{address} will be either IPv4 or IPv6 as appropriate.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L490-L495}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3917638683513443755}{} 
\hyperlink{3917638683513443755}{\texttt{Base.setopt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setopt(sock::UDPSocket; multicast_loop = nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)
\end{lstlisting}

Set UDP socket options.

\begin{itemize}
\item \texttt{multicast\_loop}: loopback for multicast packets (default: \texttt{true}).


\item \texttt{multicast\_ttl}: TTL for multicast packets (default: \texttt{nothing}).


\item \texttt{enable\_broadcast}: flag must be set to \texttt{true} if socket will be used for broadcast messages, or else the UDP system will return an access error (default: \texttt{false}).


\item \texttt{ttl}: Time-to-live of packets sent on the socket (default: \texttt{nothing}).

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L451-L461}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17463337378549787661}{} 
\hyperlink{17463337378549787661}{\texttt{Base.ntoh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ntoh(x)
\end{lstlisting}

Converts the endianness of a value from Network byte order (big-endian) to that used by the Host.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L246-L250}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17749829108559566344}{} 
\hyperlink{17749829108559566344}{\texttt{Base.hton}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hton(x)
\end{lstlisting}

Converts the endianness of a value from that used by the Host to Network byte order (big-endian).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L253-L257}{\texttt{source}}


\end{adjustwidth}
\hypertarget{931615445303306874}{} 
\hyperlink{931615445303306874}{\texttt{Base.ltoh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ltoh(x)
\end{lstlisting}

Converts the endianness of a value from Little-endian to that used by the Host.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L260-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6797011189807622497}{} 
\hyperlink{6797011189807622497}{\texttt{Base.htol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
htol(x)
\end{lstlisting}

Converts the endianness of a value from that used by the Host to Little-endian.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L267-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15528013539058180213}{} 
\hyperlink{15528013539058180213}{\texttt{Base.ENDIAN\_BOM}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ENDIAN_BOM
\end{lstlisting}

The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value \texttt{0x04030201}. Big-endian machines will contain the value \texttt{0x01020304}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L237-L243}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15930311186113323480}{}


\chapter{Puntuación}



Puede encontrar documentación extendida sobre símbolos y funciones matemáticas \hyperlink{15714690155437633961}{aquí}.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
symbol & meaning \\
\hline
\texttt{@m} & Invoca la macro \texttt{m}; seguido de expresiones separadas por espacios \\
\hline
\texttt{!} & Operador {\textquotedbl}not{\textquotedbl} prefijo \\
\hline
\texttt{a!( )}     & Al final de un nombre de función, \texttt{!} indica que la función modifica su(s) argumento(s)     \\
\hline
\texttt{\#}         & Inicio de un comentario de una sola línea                                                  \\
\hline
\texttt{\#=} & Inicio de un comentario multilínea (ellos son anidables) \\
\hline
\texttt{=\#} & Final de un comentario multilínea \\
\hline
\texttt{\$}         & Interpolación de cadena y expresión                                                        \\
\hline
\texttt{\%} & Operador resto \\
\hline
\texttt{{\textasciicircum}} & Operador exponenente \\
\hline
\texttt{\&}         & Operador and bit-a-bit                                                                      \\
\hline
\texttt{\&\&} & Operador and booleano (en corto-circuito) \\
\hline
\texttt{|} & Operador or bit-a-bit \\
\hline
\texttt{||} & Operador or booleano (en corto-circuito) \\
\hline
\texttt{⊻} & Operador xor bit-a-bit \\
\hline
\texttt{*}         & Multiplicación o producto matricial                                                          \\
\hline
\texttt{()}       & Tupla vacía                                                                             \\
\hline
\texttt{{\textasciitilde}} & Operador not bit-a-bit \\
\hline
\texttt{{\textbackslash}} & Operador backslash \\
\hline
\texttt{{\textquotesingle}} & Operador transpuesto complejo Aᴴ \\
\hline
\texttt{a[]}       & Indexación de array                                                                        \\
\hline
\texttt{[,]}       & Concatenación vertical                                                                     \\
\hline
\texttt{[;]}       & Concatenación vertical (también)                                                           \\
\hline
\texttt{[    ]}   & Con expresiones separadas por espacios, concatenación horizontal                           \\
\hline
\texttt{T\{ \}}     & Instanciación de tipo paramétrico                                                           \\
\hline
\texttt{;} & Separador de instrucciones \\
\hline
\texttt{,}         & Separador de argumentos de función o de componentes de una tupla                           \\
\hline
\texttt{?} & Operador condicional ternario (conditional ? if\_true : if\_false) \\
\hline
\texttt{{\textquotedbl}{\textquotedbl}} & Delimitador de literales cadena \\
\hline
\texttt{{\textquotesingle}{\textquotesingle}}       & Delimitador de literales carácter                                                           \\
\hline
\texttt{` `} & Delimitador de especificaciones de proceso externo (mandato) \\
\hline
\texttt{...} & splice arguments into a function call or declare a varargs function or type \\
\hline
\texttt{.}         & Acceso nombrado a campos en objectos/módulos, también llamadas a operator/function vectorizadas \\
\hline
\texttt{a:b} & Rango a, a+1, a+2, ..., b \\
\hline
\texttt{a:s:b} & Rango a, a+s, a+2s, ..., b \\
\hline
\texttt{:}         & Indexa una dimensión entera (1:end)                                                         \\
\hline
\texttt{::}       & Anotación de tipo ,dependiendo del contexto                                                 \\
\hline
\texttt{:( )}     & Expresión citada                                                                           \\
\hline
\texttt{:a}       & símbolo a                                                                                  \\
\hline
\texttt{<:} & \hyperlink{10973847109239228196}{\texttt{subtype operator}} \\
\hline
\texttt{>:} & \hyperlink{13074915255343859584}{\texttt{supertype operator}} (reverse of subtype operator) \\
\hline
\texttt{===} & \hyperlink{7974744969331231272}{\texttt{egal comparison operator}} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{7484837696332142133}{}


\chapter{Ordenación y Funciones Relacionadas}



Julia tiene una API amplia y flexible para ordenar e interactuar con matrices de valores ya ordenados. Por defecto, Julia selecciona algoritmos y ordenaciones razonables en orden ascendente estándar:




\begin{minted}{jlcon}
julia> sort([2,3,1])
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



Uno también puede ordenar en orden inverso:




\begin{minted}{jlcon}
julia> sort([2,3,1], rev=true)
3-element Array{Int64,1}:
 3
 2
 1
\end{minted}



Para ordenar un array en el lugar, use la versión con admiración de la función de ordenación:




\begin{minted}{jlcon}
julia> a = [2,3,1];

julia> sort!(a);

julia> a
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



En lugar de ordenar un array directamente, podemos computar una preemutación de los índices del array que ponen el array en un orden determinado:




\begin{minted}{jlcon}
julia> v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia> p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia> v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396
\end{minted}



Los arrays pueden ser ordenados fácilmente de acuerdo a una transformacin arbitraria de sus valores:




\begin{minted}{jlcon}
julia> sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027
\end{minted}



O en orden reverso mediante una transformación




\begin{minted}{jlcon}
julia> sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452
\end{minted}



Si es necesario, puede elegirse el algoritmo de ordenación:




\begin{minted}{jlcon}
julia> sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396
\end{minted}



Todas las funciones de ordenación y relacionadas con orden se basan en una relación {\textquotedbl}menor que{\textquotedbl} que define un orden total sobre los valores que van a manipularse. La función \texttt{isless} es la invocada por defecto, pero la relación puede ser especificada mediante la palabra clave \texttt{lt}.



\hypertarget{5870863367801341187}{}


\section{Funciones de Ordenación}


\hypertarget{12296873681374954808}{} 
\hyperlink{12296873681374954808}{\texttt{Base.sort!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort the vector \texttt{v} in place. \texttt{QuickSort} is used by default for numeric arrays while \texttt{MergeSort} is used for other arrays. You can specify an algorithm to use via the \texttt{alg} keyword (see Sorting Algorithms for available algorithms). The \texttt{by} keyword lets you provide a function that will be applied to each element before comparison; the \texttt{lt} keyword allows providing a custom {\textquotedbl}less than{\textquotedbl} function; use \texttt{rev=true} to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both \texttt{by} and \texttt{lt} are specified, the \texttt{lt} function is applied to the result of the \texttt{by} function; \texttt{rev=true} reverses whatever ordering specified via the \texttt{by} and \texttt{lt} keywords.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2]; sort!(v); v
3-element Array{Int64,1}:
 1
 2
 3

julia> v = [3, 1, 2]; sort!(v, rev = true); v
3-element Array{Int64,1}:
 3
 2
 1

julia> v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -> x[1]); v
3-element Array{Tuple{Int64,String},1}:
 (1, "c")
 (2, "b")
 (3, "a")

julia> v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -> x[2]); v
3-element Array{Tuple{Int64,String},1}:
 (3, "a")
 (2, "b")
 (1, "c")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L439-L478}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8473525809131227606}{} 
\hyperlink{8473525809131227606}{\texttt{Base.sort}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Variant of \hyperlink{12296873681374954808}{\texttt{sort!}} that returns a sorted copy of \texttt{v} leaving \texttt{v} itself unmodified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2];

julia> sort(v)
3-element Array{Int64,1}:
 1
 2
 3

julia> v
3-element Array{Int64,1}:
 3
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L523-L545}{\texttt{source}}



\begin{lstlisting}
sort(A, dim::Integer; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)
\end{lstlisting}

Sort a multidimensional array \texttt{A} along the given dimension. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 1 2]
2×2 Array{Int64,2}:
 4  3
 1  2

julia> sort(A, 1)
2×2 Array{Int64,2}:
 1  2
 4  3

julia> sort(A, 2)
2×2 Array{Int64,2}:
 3  4
 1  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L696-L721}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17035770587913381438}{} 
\hyperlink{17035770587913381438}{\texttt{Base.sortperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Return a permutation vector of indices of \texttt{v} that puts it in sorted order. Specify \texttt{alg} to choose a particular sorting algorithm (see Sorting Algorithms). \texttt{MergeSort} is used by default, and since it is stable, the resulting permutation will be the lexicographically first one that puts the input array into sorted order – i.e. indices of equal elements appear in ascending order. If you choose a non-stable sorting algorithm such as \texttt{QuickSort}, a different permutation that puts the array into order may be returned. The order is specified using the same keywords as \texttt{sort!}.

See also \hyperlink{9803303601105416895}{\texttt{sortperm!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2];

julia> p = sortperm(v)
3-element Array{Int64,1}:
 2
 3
 1

julia> v[p]
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L573-L603}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9803303601105416895}{} 
\hyperlink{9803303601105416895}{\texttt{Base.Sort.sortperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)
\end{lstlisting}

Like \hyperlink{17035770587913381438}{\texttt{sortperm}}, but accepts a preallocated index vector \texttt{ix}.  If \texttt{initialized} is \texttt{false} (the default), \texttt{ix} is initialized to contain the values \texttt{1:length(v)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2]; p = zeros(Int, 3);

julia> sortperm!(p, v); p
3-element Array{Int64,1}:
 2
 3
 1

julia> v[p]
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L630-L653}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13424247807563071005}{} 
\hyperlink{13424247807563071005}{\texttt{Base.Sort.sortrows}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sortrows(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort the rows of matrix \texttt{A} lexicographically. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sortrows([7 3 5; -1 6 4; 9 -2 8])
3×3 Array{Int64,2}:
 -1   6  4
  7   3  5
  9  -2  8

julia> sortrows([7 3 5; -1 6 4; 9 -2 8], lt=(x,y)->isless(x[2],y[2]))
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4

julia> sortrows([7 3 5; -1 6 4; 9 -2 8], rev=true)
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L753-L781}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8489789932053339936}{} 
\hyperlink{8489789932053339936}{\texttt{Base.Sort.sortcols}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sortcols(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort the columns of matrix \texttt{A} lexicographically. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sortcols([7 3 5; 6 -1 -4; 9 -2 8])
3×3 Array{Int64,2}:
  3   5  7
 -1  -4  6
 -2   8  9

julia> sortcols([7 3 5; 6 -1 -4; 9 -2 8], alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))
3×3 Array{Int64,2}:
  5   3  7
 -4  -1  6
  8  -2  9

julia> sortcols([7 3 5; 6 -1 -4; 9 -2 8], rev=true)
3×3 Array{Int64,2}:
 7   5   3
 6  -4  -1
 9   8  -2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L793-L821}{\texttt{source}}


\end{adjustwidth}

\hypertarget{17002760230433575208}{}


\section{Funciones relacionadas con Orden}


\hypertarget{16696594531893143583}{} 
\hyperlink{16696594531893143583}{\texttt{Base.issorted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issorted(v, lt=isless, by=identity, rev:Bool=false, order::Ordering=Forward)
\end{lstlisting}

Test whether a vector is in sorted order. The \texttt{lt}, \texttt{by} and \texttt{rev} keywords modify what order is considered to be sorted just as they do for \hyperlink{8473525809131227606}{\texttt{sort}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issorted([1, 2, 3])
true

julia> issorted([(1, "b"), (2, "a")], by = x -> x[1])
true

julia> issorted([(1, "b"), (2, "a")], by = x -> x[2])
false

julia> issorted([(1, "b"), (2, "a")], by = x -> x[2], rev=true)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L60-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17287969759719368562}{} 
\hyperlink{17287969759719368562}{\texttt{Base.Sort.searchsorted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
searchsorted(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Returns the range of indices of \texttt{a} which compare as equal to \texttt{x} (using binary search) according to the order specified by the \texttt{by}, \texttt{lt} and \texttt{rev} keywords, assuming that \texttt{a} is already sorted in that order. Returns an empty range located at the insertion point if \texttt{a} does not contain values equal to \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [4, 3, 2, 1]
4-element Array{Int64,1}:
 4
 3
 2
 1

julia> searchsorted(a, 4)
5:4

julia> searchsorted(a, 4, rev=true)
1:1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L495-L519}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12786822915971523090}{} 
\hyperlink{12786822915971523090}{\texttt{Base.Sort.searchsortedfirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
searchsortedfirst(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Returns the index of the first value in \texttt{a} greater than or equal to \texttt{x}, according to the specified order. Returns \texttt{length(a)+1} if \texttt{x} is greater than all values in \texttt{a}. \texttt{a} is assumed to be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsortedfirst([1, 2, 4, 5, 14], 4)
3

julia> searchsortedfirst([1, 2, 4, 5, 14], 4, rev=true)
1

julia> searchsortedfirst([1, 2, 4, 5, 14], 15)
6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1351-L1370}{\texttt{source}}


\end{adjustwidth}
\hypertarget{572230519808649943}{} 
\hyperlink{572230519808649943}{\texttt{Base.Sort.searchsortedlast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
searchsortedlast(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Returns the index of the last value in \texttt{a} less than or equal to \texttt{x}, according to the specified order. Returns \texttt{0} if \texttt{x} is less than all values in \texttt{a}. \texttt{a} is assumed to be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsortedlast([1, 2, 4, 5, 14], 4)
3

julia> searchsortedlast([1, 2, 4, 5, 14], 4, rev=true)
5

julia> searchsortedlast([1, 2, 4, 5, 14], -1)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2026-L2045}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16241414476213573420}{} 
\hyperlink{16241414476213573420}{\texttt{Base.Sort.select!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
select!(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Partially sort the vector \texttt{v} in place, according to the order specified by \texttt{by}, \texttt{lt} and \texttt{rev} so that the value at index \texttt{k} (or range of adjacent values if \texttt{k} is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If \texttt{k} is a single index, that value is returned; if \texttt{k} is a range, an array of values at those indices is returned. Note that \texttt{select!} does not fully sort the input array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia> select!(a, 4)
4

julia> a
5-element Array{Int64,1}:
 1
 2
 3
 4
 4

julia> a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia> select!(a, 4, rev=true)
2

julia> a
5-element Array{Int64,1}:
 4
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L853-L904}{\texttt{source}}


\end{adjustwidth}
\hypertarget{420570680150584220}{} 
\hyperlink{420570680150584220}{\texttt{Base.Sort.select}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
select(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Variant of \hyperlink{16241414476213573420}{\texttt{select!}} which copies \texttt{v} before partially sorting it, thereby returning the same thing as \texttt{select!} but leaving \texttt{v} unmodified.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L655-L660}{\texttt{source}}


\end{adjustwidth}
\hypertarget{913507832734228523}{} 
\hyperlink{913507832734228523}{\texttt{Base.Sort.selectperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
selectperm(v, k, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Return a partial permutation of the vector \texttt{v}, according to the order specified by \texttt{by}, \texttt{lt} and \texttt{rev}, so that \texttt{v[output]} returns the first \texttt{k} (or range of adjacent values if \texttt{k} is a range) values of a fully sorted version of \texttt{v}. If \texttt{k} is a single index (Integer), an array of the first \texttt{k} indices is returned; if \texttt{k} is a range, an array of those indices is returned. Note that the handling of integer values for \texttt{k} is different from \hyperlink{420570680150584220}{\texttt{select}} in that it returns a vector of \texttt{k} elements instead of just the \texttt{k} th element. Also note that this is equivalent to, but more efficient than, calling \texttt{sortperm(...)[k]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1231-L1242}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14333533851382646700}{} 
\hyperlink{14333533851382646700}{\texttt{Base.Sort.selectperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
selectperm!(ix, v, k, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false,] [initialized=false])
\end{lstlisting}

Like \hyperlink{913507832734228523}{\texttt{selectperm}}, but accepts a preallocated index vector \texttt{ix}. If \texttt{initialized} is \texttt{false} (the default), ix is initialized to contain the values \texttt{1:length(ix)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1396-L1401}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9249877028219934557}{}


\section{Algoritmos de Ordenación}



Actualmente hay cuatro algoritmos de ordenación disponibles en Julia base:



\begin{itemize}
\item \texttt{InsertionSort}


\item \texttt{QuickSort}


\item \texttt{PartialQuickSort(k)}


\item \texttt{MergeSort}

\end{itemize}


\texttt{InsertionSort} es un algoritmo de ordenación estable cuyo coste es O(n{\textasciicircum}2). Es eficiente para \texttt{n} muy pequeños, y es usado internamente por \texttt{QuickSort}.



\texttt{QuickSort} es un algoritmo de ordenación que es \emph{in-place} muy rápido pero no estable (es decir, los elementos que son considerados iguales no permanecerán en el mismo orden en que se encontraban originalmente en el array antes de ser ordenados. Su coste computacional es O(n log n). \texttt{QuickSort} es el algoritmo por defecto para valores numéricos, incluyendo enteros y punto flotante.



\texttt{PartialQuickSort(k)} es similar a \texttt{QuickSort}, pero el array de salida es sólo ordenado hasta el índice  \texttt{k} si \texttt{k} es un entero, o en el rango de \texttt{k} si \texttt{k} es un \texttt{OrdinalRange}. Por ejemplo:




\begin{minted}{julia}
x = rand(1:500, 100)
k = 50
k2 = 50:100
s = sort(x; alg=QuickSort)
ps = sort(x; alg=PartialQuickSort(k))
qs = sort(x; alg=PartialQuickSort(k2))
map(issorted, (s, ps, qs))             # => (true, false, false)
map(x->issorted(x[1:k]), (s, ps, qs))  # => (true, true, false)
map(x->issorted(x[k2]), (s, ps, qs))   # => (true, false, true)
s[1:k] == ps[1:k]                      # => true
s[k2] == qs[k2]                        # => true
\end{minted}



\texttt{MergeSort} es un algoritmo de ordenación estable, pero no \emph{in-place} (requiere un array temporal de la mitad del tamaño del array de entrada), de coste O(n log n) y no suele ser tan rapido como \texttt{QuickSort}. Es el algoritmo por defecto para datos no numéricos.



Los algoritmos de clasificación por defecto se eligen sobre la base de que son rápidos y estables, o \emph{parezcan} serlo. Para los tipos numéricos, de hecho, se selecciona \texttt{QuickSort} ya que es más rápido e indistinguible en este caso de un tipo estable (a menos que la matriz registre sus mutaciones de alguna manera). La propiedad de estabilidad tiene un costo no despreciable, por lo que si no la necesita, puede especificar explícitamente su algoritmo preferido, p. \texttt{sort!(v, alg=QuickSort)}.



El mecanismo por el cual Julia selecciona los algoritmos de clasificación predeterminados se implementa a través de la función \texttt{Base.Sort.defalg}. Permite que un algoritmo particular se registre como el predeterminado en todas las funciones de ordenación para arrays específicos. Por ejemplo, aquí están los dos métodos predeterminados de \href{https://github.com/JuliaLang/julia/blob/master/base/sort.jl}{\texttt{sort.jl}}:




\begin{minted}{julia}
defalg(v::AbstractArray) = MergeSort
defalg{T<:Number}(v::AbstractArray{T}) = QuickSort
\end{minted}



En cuanto a los arrays numéricos, la elección de un algoritmo predeterminado no estable para los tipos de array para los cuales la noción de ordenación estable no tiene sentido (es decir, cuando dos valores que comparan iguales no se pueden distinguir) puede tener sentido.



\hypertarget{4492327721069002863}{}


\chapter{Funciones del Administrador de Paquetes}



Todas las funciones del administrador de paquetes están definidas en el módulo \texttt{Pkg}. Ninguna de las funciones del módulo  \texttt{Pkg} están exportadas. Por tanto, para usarlas, necesotamps prefijar cada llamada a función con un \texttt{Pkg.} explícito, por ejemplo \hyperlink{7389584356782450249}{\texttt{Pkg.status()}} or \hyperlink{4800223299836980046}{\texttt{Pkg.dir()}}.



Las funciones para desarrollo de de paquetes (por ejemplo, \texttt{tag}, \texttt{publish}, etc.) se han movido al paquete \href{https://github.com/JuliaLang/PkgDev.jl}{PkgDev}. Ver \href{https://github.com/JuliaLang/PkgDev.jl/blob/master/README.md}{PkgDev README} para la documentación de estas funciones.


\hypertarget{4800223299836980046}{} 
\hyperlink{4800223299836980046}{\texttt{Base.Pkg.dir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dir() -> AbstractString
\end{lstlisting}

Returns the absolute path of the package directory. This defaults to \texttt{joinpath(homedir(),{\textquotedbl}.julia{\textquotedbl},{\textquotedbl}v\$(VERSION.major).\$(VERSION.minor){\textquotedbl})} on all platforms (i.e. \texttt{{\textasciitilde}/.julia/v0.6} in UNIX shell syntax). If the \texttt{JULIA\_PKGDIR} environment variable is set, then that path is used in the returned value as \texttt{joinpath(ENV[{\textquotedbl}JULIA\_PKGDIR{\textquotedbl}],{\textquotedbl}v\$(VERSION.major).\$(VERSION.minor){\textquotedbl})}. If \texttt{JULIA\_PKGDIR} is a relative path, it is interpreted relative to whatever the current working directory is.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L55-L64}{\texttt{source}}



\begin{lstlisting}
dir(names...) -> AbstractString
\end{lstlisting}

Equivalent to \texttt{normpath(Pkg.dir(),names...)} – i.e. it appends path components to the package directory and normalizes the resulting path. In particular, \texttt{Pkg.dir(pkg)} returns the path to the package \texttt{pkg}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L67-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8591360307072003924}{} 
\hyperlink{8591360307072003924}{\texttt{Base.Pkg.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
init(meta::AbstractString=DEFAULT_META, branch::AbstractString=META_BRANCH)
\end{lstlisting}

Initialize \texttt{Pkg.dir()} as a package directory. This will be done automatically when the \texttt{JULIA\_PKGDIR} is not set and \texttt{Pkg.dir()} uses its default value. As part of this process, clones a local METADATA git repository from the site and branch specified by its arguments, which are typically not provided. Explicit (non-default) arguments can be used to support a custom METADATA setup.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L76-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{246440786291582695}{} 
\hyperlink{246440786291582695}{\texttt{Base.Pkg.resolve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
resolve()
\end{lstlisting}

Determines an optimal, consistent set of package versions to install or upgrade to. The optimal set of package versions is based on the contents of \texttt{Pkg.dir({\textquotedbl}REQUIRE{\textquotedbl})} and the state of installed packages in \texttt{Pkg.dir()}, Packages that are no longer required are moved into \texttt{Pkg.dir({\textquotedbl}.trash{\textquotedbl})}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L230-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3124493295760422384}{} 
\hyperlink{3124493295760422384}{\texttt{Base.Pkg.edit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
edit()
\end{lstlisting}

Opens \texttt{Pkg.dir({\textquotedbl}REQUIRE{\textquotedbl})} in the editor specified by the \texttt{VISUAL} or \texttt{EDITOR} environment variables; when the editor command returns, it runs \texttt{Pkg.resolve()} to determine and install a new optimal set of installed package versions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L94-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10284711283997279340}{} 
\hyperlink{10284711283997279340}{\texttt{Base.Pkg.add}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
add(pkg, vers...)
\end{lstlisting}

Add a requirement entry for \texttt{pkg} to \texttt{Pkg.dir({\textquotedbl}REQUIRE{\textquotedbl})} and call \texttt{Pkg.resolve()}. If \texttt{vers} are given, they must be \texttt{VersionNumber} objects and they specify acceptable version intervals for \texttt{pkg}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L110-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13989694063022152176}{} 
\hyperlink{13989694063022152176}{\texttt{Base.Pkg.rm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rm(pkg)
\end{lstlisting}

Remove all requirement entries for \texttt{pkg} from \texttt{Pkg.dir({\textquotedbl}REQUIRE{\textquotedbl})} and call \texttt{Pkg.resolve()}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L103-L107}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12404258328199389568}{} 
\hyperlink{12404258328199389568}{\texttt{Base.Pkg.clone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clone(pkg)
\end{lstlisting}

If \texttt{pkg} has a URL registered in \texttt{Pkg.dir({\textquotedbl}METADATA{\textquotedbl})}, clone it from that URL on the default branch. The package does not need to have any registered versions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L163-L168}{\texttt{source}}



\begin{lstlisting}
clone(url, [pkg])
\end{lstlisting}

Clone a package directly from the git URL \texttt{url}. The package does not need to be registered in \texttt{Pkg.dir({\textquotedbl}METADATA{\textquotedbl})}. The package repo is cloned by the name \texttt{pkg} if provided; if not provided, \texttt{pkg} is determined automatically from \texttt{url}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L171-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16637824229915276013}{} 
\hyperlink{16637824229915276013}{\texttt{Base.Pkg.setprotocol!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setprotocol!(proto)
\end{lstlisting}

Set the protocol used to access GitHub-hosted packages. Defaults to {\textquotesingle}https{\textquotesingle}, with a blank \texttt{proto} delegating the choice to the package developer.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L285-L290}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1262148946763636093}{} 
\hyperlink{1262148946763636093}{\texttt{Base.Pkg.available}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
available() -> Vector{String}
\end{lstlisting}

Returns the names of available packages.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L119-L123}{\texttt{source}}



\begin{lstlisting}
available(pkg) -> Vector{VersionNumber}
\end{lstlisting}

Returns the version numbers available for package \texttt{pkg}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L126-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10971725533820181631}{} 
\hyperlink{10971725533820181631}{\texttt{Base.Pkg.installed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
installed() -> Dict{String,VersionNumber}
\end{lstlisting}

Returns a dictionary mapping installed package names to the installed version number of each package.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L133-L138}{\texttt{source}}



\begin{lstlisting}
installed(pkg) -> Void | VersionNumber
\end{lstlisting}

If \texttt{pkg} is installed, return the installed version number. If \texttt{pkg} is registered, but not installed, return \texttt{nothing}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L141-L146}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7389584356782450249}{} 
\hyperlink{7389584356782450249}{\texttt{Base.Pkg.status}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
status()
\end{lstlisting}

Prints out a summary of what packages are installed and what version and state they{\textquotesingle}re in.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L149-L153}{\texttt{source}}



\begin{lstlisting}
status(pkg)
\end{lstlisting}

Prints out a summary of what version and state \texttt{pkg}, specifically, is in.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L156-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14197801802374863313}{} 
\hyperlink{14197801802374863313}{\texttt{Base.Pkg.update}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
update(pkgs...)
\end{lstlisting}

Update the metadata repo – kept in \texttt{Pkg.dir({\textquotedbl}METADATA{\textquotedbl})} – then update any fixed packages that can safely be pulled from their origin; then call \texttt{Pkg.resolve()} to determine a new optimal set of packages versions.

Without arguments, updates all installed packages. When one or more package names are provided as arguments, only those packages and their dependencies are updated.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L218-L227}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13289698592044275412}{} 
\hyperlink{13289698592044275412}{\texttt{Base.Pkg.checkout}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
checkout(pkg, [branch="master"]; merge=true, pull=true)
\end{lstlisting}

Checkout the \texttt{Pkg.dir(pkg)} repo to the branch \texttt{branch}. Defaults to checking out the {\textquotedbl}master{\textquotedbl} branch. To go back to using the newest compatible released version, use \texttt{Pkg.free(pkg)}. Changes are merged (fast-forward only) if the keyword argument \texttt{merge == true}, and the latest version is pulled from the upstream repo if \texttt{pull == true}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L180-L187}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5411776221154476292}{} 
\hyperlink{5411776221154476292}{\texttt{Base.Pkg.pin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pin(pkg)
\end{lstlisting}

Pin \texttt{pkg} at the current version. To go back to using the newest compatible released version, use \texttt{Pkg.free(pkg)}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L203-L208}{\texttt{source}}



\begin{lstlisting}
pin(pkg, version)
\end{lstlisting}

Pin \texttt{pkg} at registered version \texttt{version}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L211-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17638373134027476185}{} 
\hyperlink{17638373134027476185}{\texttt{Base.Pkg.free}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
free(pkg)
\end{lstlisting}

Free the package \texttt{pkg} to be managed by the package manager again. It calls \texttt{Pkg.resolve()} to determine optimal package versions after. This is an inverse for both \texttt{Pkg.checkout} and \texttt{Pkg.pin}.

You can also supply an iterable collection of package names, e.g., \texttt{Pkg.free(({\textquotedbl}Pkg1{\textquotedbl}, {\textquotedbl}Pkg2{\textquotedbl}))} to free multiple packages at once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L191-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8295561239210722937}{} 
\hyperlink{8295561239210722937}{\texttt{Base.Pkg.build}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
build()
\end{lstlisting}

Run the build scripts for all installed packages in depth-first recursive order.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L240-L244}{\texttt{source}}



\begin{lstlisting}
build(pkgs...)
\end{lstlisting}

Run the build script in \texttt{deps/build.jl} for each package in \texttt{pkgs} and all of their dependencies in depth-first recursive order. This is called automatically by \texttt{Pkg.resolve()} on all installed or updated packages.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L247-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9222688485458908711}{} 
\hyperlink{9222688485458908711}{\texttt{Base.Pkg.test}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
test(; coverage=false)
\end{lstlisting}

Run the tests for all installed packages ensuring that each package{\textquotesingle}s test dependencies are installed for the duration of the test. A package is tested by running its \texttt{test/runtests.jl} file and test dependencies are specified in \texttt{test/REQUIRE}. Coverage statistics for the packages may be generated by passing \texttt{coverage=true}. The default behavior is not to run coverage.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L256-L264}{\texttt{source}}



\begin{lstlisting}
test(pkgs...; coverage=false)
\end{lstlisting}

Run the tests for each package in \texttt{pkgs} ensuring that each package{\textquotesingle}s test dependencies are installed for the duration of the test. A package is tested by running its \texttt{test/runtests.jl} file and test dependencies are specified in \texttt{test/REQUIRE}. Coverage statistics for the packages may be generated by passing \texttt{coverage=true}. The default behavior is not to run coverage.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L267-L275}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12831812093472061922}{} 
\hyperlink{12831812093472061922}{\texttt{Base.Pkg.dependents}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dependents(pkg)
\end{lstlisting}

List the packages that have \texttt{pkg} as a dependency.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L278-L282}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11995623453970199783}{}


\chapter{Fechas y  Tiempo}



\hypertarget{6139252078076525667}{}


\section{Tipos para Fechas y Tiempo}


\hypertarget{14377501606406826094}{} 
\hyperlink{14377501606406826094}{\texttt{Base.Dates.Period}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Period
Year
Month
Week
Day
Hour
Minute
Second
Millisecond
Microsecond
Nanosecond
\end{lstlisting}

\texttt{Period} types represent discrete, human representations of time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L5-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{525765720148561137}{} 
\hyperlink{525765720148561137}{\texttt{Base.Dates.CompoundPeriod}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CompoundPeriod
\end{lstlisting}

A \texttt{CompoundPeriod} is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, {\textquotedbl}a year and a  day{\textquotedbl} is not a fixed number of days, but can be expressed using a \texttt{CompoundPeriod}. In fact, a \texttt{CompoundPeriod} is automatically generated by addition of different period types, e.g. \texttt{Year(1) + Day(1)} produces a \texttt{CompoundPeriod} result.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L152-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14059711765239501159}{} 
\hyperlink{14059711765239501159}{\texttt{Base.Dates.Instant}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Instant
\end{lstlisting}

\texttt{Instant} types represent integer-based, machine representations of time as continuous timelines starting from an epoch.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L54-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1207098327812555174}{} 
\hyperlink{1207098327812555174}{\texttt{Base.Dates.UTInstant}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UTInstant{T}
\end{lstlisting}

The \texttt{UTInstant} represents a machine timeline based on UT time (1 day = one revolution of the earth). The \texttt{T} is a \texttt{Period} parameter that indicates the resolution or precision of the instant.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L62-L68}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10402032810188745271}{} 
\hyperlink{10402032810188745271}{\texttt{Base.Dates.TimeType}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
TimeType
\end{lstlisting}

\texttt{TimeType} types wrap \texttt{Instant} machine instances to provide human representations of the machine instant. \texttt{Time}, \texttt{DateTime} and \texttt{Date} are subtypes of \texttt{TimeType}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L89-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8865912400344885633}{} 
\hyperlink{8865912400344885633}{\texttt{Base.Dates.DateTime}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime
\end{lstlisting}

\texttt{DateTime} wraps a \texttt{UTInstant\{Millisecond\}} and interprets it according to the proleptic Gregorian calendar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L97-L102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5911165232663997394}{} 
\hyperlink{5911165232663997394}{\texttt{Base.Dates.Date}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date
\end{lstlisting}

\texttt{Date} wraps a \texttt{UTInstant\{Day\}} and interprets it according to the proleptic Gregorian calendar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L108-L112}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6364266857375791956}{} 
\hyperlink{6364266857375791956}{\texttt{Base.Dates.Time}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time
\end{lstlisting}

\texttt{Time} wraps a \texttt{Nanosecond} and represents a specific moment in a 24-hour day.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L118-L122}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5800310548398482816}{}


\section{Funciones para Fechas}



Todas las funciones para fechas están definidas en el módulo \texttt{Dates}; nótese que sólo se han exportado las funciones \texttt{Date}, \texttt{DateTime} y \texttt{now}; para usar todas las dems funciones de \texttt{Dates}, es necesario prefijar cada llamada a funcion con \texttt{Dates.}, por ejemplo,\texttt{Dates.dayofweek(dt)}. Alternativamente, uno puede escribir \texttt{using Base.Dates} para llevar todas las funciones exportadas en \texttt{Main} para ser usadas sin el prefijo \texttt{Dates.}


\hypertarget{17770402903533631921}{} 
\hyperlink{17770402903533631921}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(y, [m, d, h, mi, s, ms]) -> DateTime
\end{lstlisting}

Construct a \texttt{DateTime} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L173-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10280796272064741669}{} 
\hyperlink{10280796272064741669}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(periods::Period...) -> DateTime
\end{lstlisting}

Construct a \texttt{DateTime} type by \texttt{Period} type parts. Arguments may be in any order. DateTime parts not provided will default to the value of \texttt{Dates.default(period)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L253-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8150038898794109881}{} 
\hyperlink{8150038898794109881}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), limit=10000) -> DateTime
\end{lstlisting}

Create a \texttt{DateTime} through the adjuster API. The starting point will be constructed from the provided \texttt{y, m, d...} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that \texttt{f::Function} is never satisfied).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L167-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{406652776419399630}{} 
\hyperlink{406652776419399630}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(dt::Date) -> DateTime
\end{lstlisting}

Converts a \texttt{Date} to a \texttt{DateTime}. The hour, minute, second, and millisecond parts of the new \texttt{DateTime} are assumed to be zero.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L14-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8065462912440099163}{} 
\hyperlink{8065462912440099163}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(dt::AbstractString, format::AbstractString; locale="english") -> DateTime
\end{lstlisting}

Construct a \texttt{DateTime} by parsing the \texttt{dt} date string following the pattern given in the \texttt{format} string.

This method creates a \texttt{DateFormat} object each time it is called. If you are parsing many date strings of the same format, consider creating a \hyperlink{18366440545577280750}{\texttt{DateFormat}} object once and using that as the second argument instead.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L400-L409}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15700128179736045337}{} 
\hyperlink{15700128179736045337}{\texttt{Base.Dates.format}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
format(dt::TimeType, format::AbstractString; locale="english") -> AbstractString
\end{lstlisting}

Construct a string by using a \texttt{TimeType} object and applying the provided \texttt{format}. The following character codes can be used to construct the \texttt{format} string:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Code & Examples & Comment \\
\hline
\texttt{y} & 6 & Numeric year with a fixed width \\
\hline
\texttt{Y} & 1996 & Numeric year with a minimum width \\
\hline
\texttt{m} & 1, 12 & Numeric month with a minimum width \\
\hline
\texttt{u} & Jan & Month name shortened to 3-chars according to the \texttt{locale} \\
\hline
\texttt{U} & January & Full month name according to the \texttt{locale} keyword \\
\hline
\texttt{d} & 1, 31 & Day of the month with a minimum width \\
\hline
\texttt{H} & 0, 23 & Hour (24-hour clock) with a minimum width \\
\hline
\texttt{M} & 0, 59 & Minute with a minimum width \\
\hline
\texttt{S} & 0, 59 & Second with a minimum width \\
\hline
\texttt{s} & 000, 500 & Millisecond with a minimum width of 3 \\
\hline
\texttt{e} & Mon, Tue & Abbreviated days of the week \\
\hline
\texttt{E} & Monday & Full day of week name \\
\hline
\end{tabulary}

\end{table}

The number of sequential code characters indicate the width of the code. A format of \texttt{yyyy-mm} specifies that the code \texttt{y} should have a width of four while \texttt{m} a width of two. Codes that yield numeric digits have an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros when it is shorter than the specified width and truncates the value when longer. Minimum-width mode works the same as fixed-width except that it does not truncate values longer than the width.

When creating a \texttt{format} you can use any non-code characters as a separator. For example to generate the string {\textquotedbl}1996-01-15T00:00:00{\textquotedbl} you could use \texttt{format}: {\textquotedbl}yyyy-mm-ddTHH:MM:SS{\textquotedbl}. Note that if you need to use a code character as a literal you can use the escape character backslash. The string {\textquotedbl}1996y01m{\textquotedbl} can be produced with the format {\textquotedbl}yyyy{\textbackslash}ymm{\textbackslash}m{\textquotedbl}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L459-L491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18366440545577280750}{} 
\hyperlink{18366440545577280750}{\texttt{Base.Dates.DateFormat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateFormat(format::AbstractString, locale="english") -> DateFormat
\end{lstlisting}

Construct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the \texttt{format} string:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Code & Matches & Comment \\
\hline
\texttt{y} & 1996, 96 & Returns year of 1996, 0096 \\
\hline
\texttt{Y} & 1996, 96 & Returns year of 1996, 0096. Equivalent to \texttt{y} \\
\hline
\texttt{m} & 1, 01 & Matches 1 or 2-digit months \\
\hline
\texttt{u} & Jan & Matches abbreviated months according to the \texttt{locale} keyword \\
\hline
\texttt{U} & January & Matches full month names according to the \texttt{locale} keyword \\
\hline
\texttt{d} & 1, 01 & Matches 1 or 2-digit days \\
\hline
\texttt{H} & 00 & Matches hours \\
\hline
\texttt{M} & 00 & Matches minutes \\
\hline
\texttt{S} & 00 & Matches seconds \\
\hline
\texttt{s} & .500 & Matches milliseconds \\
\hline
\texttt{e} & Mon, Tues & Matches abbreviated days of the week \\
\hline
\texttt{E} & Monday & Matches full name days of the week \\
\hline
\texttt{yyyymmdd} & 19960101 & Matches fixed-width year, month, and day \\
\hline
\end{tabulary}

\end{table}

Characters not listed above are normally treated as delimiters between date and time slots. For example a \texttt{dt} string of {\textquotedbl}1996-01-15T00:00:00.0{\textquotedbl} would have a \texttt{format} string like {\textquotedbl}y-m-dTH:M:S.s{\textquotedbl}. If you need to use a code character as a delimiter you can escape it using backslash. The date {\textquotedbl}1995y01m{\textquotedbl} would have the format {\textquotedbl}y{\textbackslash}ym{\textbackslash}m{\textquotedbl}.

Creating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the \texttt{dateformat{\textquotedbl}{\textquotedbl}} string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see \hyperlink{11988130329055928757}{\texttt{@dateformat\_str}}.

See \hyperlink{8865912400344885633}{\texttt{DateTime}} and \hyperlink{15700128179736045337}{\texttt{format}} for how to use a DateFormat object to parse and write Date strings respectively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L285-L319}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11988130329055928757}{} 
\hyperlink{11988130329055928757}{\texttt{Base.Dates.@dateformat\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dateformat"Y-m-d H:M:S"
\end{lstlisting}

Create a \hyperlink{18366440545577280750}{\texttt{DateFormat}} object. Similar to \texttt{DateFormat({\textquotedbl}Y-m-d H:M:S{\textquotedbl})} but creates the DateFormat object once during macro expansion.

See \hyperlink{18366440545577280750}{\texttt{DateFormat}} for details about format specifiers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L376-L383}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3378067936515397516}{} 
\hyperlink{3378067936515397516}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(dt::AbstractString, df::DateFormat) -> DateTime
\end{lstlisting}

Construct a \texttt{DateTime} by parsing the \texttt{dt} date string following the pattern given in the \hyperlink{18366440545577280750}{\texttt{DateFormat}} object. Similar to \texttt{DateTime(::AbstractString, ::AbstractString)} but more efficient when repeatedly parsing similarly formatted date strings with a pre-created \texttt{DateFormat} object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L414-L421}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5212786329612133584}{} 
\hyperlink{5212786329612133584}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(y, [m, d]) -> Date
\end{lstlisting}

Construct a \texttt{Date} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L197-L201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7589388345185303552}{} 
\hyperlink{7589388345185303552}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(period::Period...) -> Date
\end{lstlisting}

Construct a \texttt{Date} type by \texttt{Period} type parts. Arguments may be in any order. \texttt{Date} parts not provided will default to the value of \texttt{Dates.default(period)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L274-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16815838716805629389}{} 
\hyperlink{16815838716805629389}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(f::Function, y[, m, d]; step=Day(1), limit=10000) -> Date
\end{lstlisting}

Create a \texttt{Date} through the adjuster API. The starting point will be constructed from the provided \texttt{y, m, d} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that \texttt{f::Function} is never satisfied).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L153-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15615328746995105772}{} 
\hyperlink{15615328746995105772}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(dt::DateTime) -> Date
\end{lstlisting}

Converts a \texttt{DateTime} to a \texttt{Date}. The hour, minute, second, and millisecond parts of the \texttt{DateTime} are truncated, so only the year, month and day parts are used in construction.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3304153513123620085}{} 
\hyperlink{3304153513123620085}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(dt::AbstractString, format::AbstractString; locale="english") -> Date
\end{lstlisting}

Construct a \texttt{Date} object by parsing a \texttt{dt} date string following the pattern given in the \texttt{format} string. Follows the same conventions as \texttt{DateTime(::AbstractString, ::AbstractString)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L424-L430}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16265569307671841495}{} 
\hyperlink{16265569307671841495}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(dt::AbstractString, df::DateFormat) -> Date
\end{lstlisting}

Parse a date from a date string \texttt{dt} using a \texttt{DateFormat} object \texttt{df}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L435-L439}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8041094645691458686}{} 
\hyperlink{8041094645691458686}{\texttt{Base.Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time(h, [mi, s, ms, us, ns]) -> Time
\end{lstlisting}

Construct a \texttt{Time} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L214-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16214757854325020955}{} 
\hyperlink{16214757854325020955}{\texttt{Base.Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time(period::TimePeriod...) -> Time
\end{lstlisting}

Construct a \texttt{Time} type by \texttt{Period} type parts. Arguments may be in any order. \texttt{Time} parts not provided will default to the value of \texttt{Dates.default(period)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L290-L295}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10387496882065780352}{} 
\hyperlink{10387496882065780352}{\texttt{Base.Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time(f::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)
Time(f::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)
\end{lstlisting}

Create a \texttt{Time} through the adjuster API. The starting point will be constructed from the provided \texttt{h, mi, s, ms, us} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that \texttt{f::Function} is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be \texttt{Millisecond(1)} instead of \texttt{Second(1)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L199-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8591728813232129299}{} 
\hyperlink{8591728813232129299}{\texttt{Base.Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time(dt::DateTime) -> Time
\end{lstlisting}

Converts a \texttt{DateTime} to a \texttt{Time}. The hour, minute, second, and millisecond parts of the \texttt{DateTime} are used to create the new \texttt{Time}. Microsecond and nanoseconds are zero by default.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L22-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2058673973833808993}{} 
\hyperlink{2058673973833808993}{\texttt{Base.Dates.now}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
now() -> DateTime
\end{lstlisting}

Returns a \texttt{DateTime} corresponding to the user{\textquotesingle}s system time including the system timezone locale.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L60-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11897165750197598573}{} 
\hyperlink{11897165750197598573}{\texttt{Base.Dates.now}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
now(::Type{UTC}) -> DateTime
\end{lstlisting}

Returns a \texttt{DateTime} corresponding to the user{\textquotesingle}s system time as UTC/GMT.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L79-L83}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4594213520310841636}{} 
\hyperlink{4594213520310841636}{\texttt{Base.eps}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eps(::DateTime) -> Millisecond
eps(::Date) -> Day
eps(::Time) -> Nanosecond
\end{lstlisting}

Returns \texttt{Millisecond(1)} for \texttt{DateTime} values, \texttt{Day(1)} for \texttt{Date} values, and \texttt{Nanosecond(1)} for \texttt{Time} values.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L320-L326}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15435597785373204240}{}


\subsection{Funciones Accesoras}


\hypertarget{15622323911053998761}{} 
\hyperlink{15622323911053998761}{\texttt{Base.Dates.year}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
year(dt::TimeType) -> Int64
\end{lstlisting}

The year of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L74-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15592512904688731243}{} 
\hyperlink{15592512904688731243}{\texttt{Base.Dates.month}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
month(dt::TimeType) -> Int64
\end{lstlisting}

The month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L74-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11882200678350221197}{} 
\hyperlink{11882200678350221197}{\texttt{Base.Dates.week}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
week(dt::TimeType) -> Int64
\end{lstlisting}

Return the \href{https://en.wikipedia.org/wiki/ISO\_week\_date}{ISO week date} of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}. Note that the first week of a year is the week that contains the first Thursday of the year which can result in dates prior to January 4th being in the last week of the previous year. For example \texttt{week(Date(2005,1,1))} is the 53rd week of 2004.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L82-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10628053109262927268}{} 
\hyperlink{10628053109262927268}{\texttt{Base.Dates.day}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
day(dt::TimeType) -> Int64
\end{lstlisting}

The day of month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L96-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8147665261575125823}{} 
\hyperlink{8147665261575125823}{\texttt{Base.Dates.hour}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hour(dt::DateTime) -> Int64
\end{lstlisting}

The hour of day of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L104-L108}{\texttt{source}}



\begin{lstlisting}
hour(t::Time) -> Int64
\end{lstlisting}

The hour of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{200178754136690053}{} 
\hyperlink{200178754136690053}{\texttt{Base.Dates.minute}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minute(dt::DateTime) -> Int64
\end{lstlisting}

The minute of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L114-L118}{\texttt{source}}



\begin{lstlisting}
minute(t::Time) -> Int64
\end{lstlisting}

The minute of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11526418270822848975}{} 
\hyperlink{11526418270822848975}{\texttt{Base.Dates.second}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
second(dt::DateTime) -> Int64
\end{lstlisting}

The second of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L114-L118}{\texttt{source}}



\begin{lstlisting}
second(t::Time) -> Int64
\end{lstlisting}

The second of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5543798764014787808}{} 
\hyperlink{5543798764014787808}{\texttt{Base.Dates.millisecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
millisecond(dt::DateTime) -> Int64
\end{lstlisting}

The millisecond of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L114-L118}{\texttt{source}}



\begin{lstlisting}
millisecond(t::Time) -> Int64
\end{lstlisting}

The millisecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14946427435154419045}{} 
\hyperlink{14946427435154419045}{\texttt{Base.Dates.microsecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
microsecond(t::Time) -> Int64
\end{lstlisting}

The microsecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11331076397425122225}{} 
\hyperlink{11331076397425122225}{\texttt{Base.Dates.nanosecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nanosecond(t::Time) -> Int64
\end{lstlisting}

The nanosecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16126769327257486686}{} 
\hyperlink{16126769327257486686}{\texttt{Base.Dates.Year}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Year(v)
\end{lstlisting}

Construct a \texttt{Year} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4856456945508687644}{} 
\hyperlink{4856456945508687644}{\texttt{Base.Dates.Month}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Month(v)
\end{lstlisting}

Construct a \texttt{Month} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10126535084488311230}{} 
\hyperlink{10126535084488311230}{\texttt{Base.Dates.Week}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Week(v)
\end{lstlisting}

Construct a \texttt{Week} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5199769942291019025}{} 
\hyperlink{5199769942291019025}{\texttt{Base.Dates.Day}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Day(v)
\end{lstlisting}

Construct a \texttt{Day} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9687487618909219374}{} 
\hyperlink{9687487618909219374}{\texttt{Base.Dates.Hour}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Hour(dt::DateTime) -> Hour
\end{lstlisting}

The hour part of a DateTime as a \texttt{Hour}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4572058418581891227}{} 
\hyperlink{4572058418581891227}{\texttt{Base.Dates.Minute}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Minute(dt::DateTime) -> Minute
\end{lstlisting}

The minute part of a DateTime as a \texttt{Minute}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16463935583134096940}{} 
\hyperlink{16463935583134096940}{\texttt{Base.Dates.Second}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Second(dt::DateTime) -> Second
\end{lstlisting}

The second part of a DateTime as a \texttt{Second}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2512115765177421351}{} 
\hyperlink{2512115765177421351}{\texttt{Base.Dates.Millisecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Millisecond(dt::DateTime) -> Millisecond
\end{lstlisting}

The millisecond part of a DateTime as a \texttt{Millisecond}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5798823481721317707}{} 
\hyperlink{5798823481721317707}{\texttt{Base.Dates.Microsecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Microsecond(dt::Time) -> Microsecond
\end{lstlisting}

The microsecond part of a Time as a \texttt{Microsecond}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1602344562458791149}{} 
\hyperlink{1602344562458791149}{\texttt{Base.Dates.Nanosecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Nanosecond(dt::Time) -> Nanosecond
\end{lstlisting}

The nanosecond part of a Time as a \texttt{Nanosecond}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18273306122630602024}{} 
\hyperlink{18273306122630602024}{\texttt{Base.Dates.yearmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
yearmonth(dt::TimeType) -> (Int64, Int64)
\end{lstlisting}

Simultaneously return the year and month parts of a \texttt{Date} or \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12711217240943655827}{} 
\hyperlink{12711217240943655827}{\texttt{Base.Dates.monthday}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
monthday(dt::TimeType) -> (Int64, Int64)
\end{lstlisting}

Simultaneously return the month and day parts of a \texttt{Date} or \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4035909562939951459}{} 
\hyperlink{4035909562939951459}{\texttt{Base.Dates.yearmonthday}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
yearmonthday(dt::TimeType) -> (Int64, Int64, Int64)
\end{lstlisting}

Simultaneously return the year, month and day parts of a \texttt{Date} or \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11292476491957707950}{}


\subsection{Funciones de Consulta}


\hypertarget{3340143850480916413}{} 
\hyperlink{3340143850480916413}{\texttt{Base.Dates.dayname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayname(dt::TimeType; locale="english") -> AbstractString
\end{lstlisting}

Return the full day name corresponding to the day of the week of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L116-L121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2563884892429498349}{} 
\hyperlink{2563884892429498349}{\texttt{Base.Dates.dayabbr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayabbr(dt::TimeType; locale="english") -> AbstractString
\end{lstlisting}

Return the abbreviated name corresponding to the day of the week of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8726616416233686609}{} 
\hyperlink{8726616416233686609}{\texttt{Base.Dates.dayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofweek(dt::TimeType) -> Int64
\end{lstlisting}

Returns the day of the week as an \hyperlink{7720564657383125058}{\texttt{Int64}} with \texttt{1 = Monday, 2 = Tuesday, etc.}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L101-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16365330124585758379}{} 
\hyperlink{16365330124585758379}{\texttt{Base.Dates.dayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofmonth(dt::TimeType) -> Int64
\end{lstlisting}

The day of month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L96-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{292232568750400127}{} 
\hyperlink{292232568750400127}{\texttt{Base.Dates.dayofweekofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofweekofmonth(dt::TimeType) -> Int
\end{lstlisting}

For the day of week of \texttt{dt}, returns which number it is in \texttt{dt}{\textquotesingle}s month. So if the day of the week of \texttt{dt} is Monday, then \texttt{1 = First Monday of the month, 2 = Second Monday of the month, etc.} In the range 1:5.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L146-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5674966841159569212}{} 
\hyperlink{5674966841159569212}{\texttt{Base.Dates.daysofweekinmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
daysofweekinmonth(dt::TimeType) -> Int
\end{lstlisting}

For the day of week of \texttt{dt}, returns the total number of that day of the week in \texttt{dt}{\textquotesingle}s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including \texttt{dayofweekofmonth(dt) == daysofweekinmonth(dt)} in the adjuster function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L164-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12803026364514696452}{} 
\hyperlink{12803026364514696452}{\texttt{Base.Dates.monthname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
monthname(dt::TimeType; locale="english") -> AbstractString
\end{lstlisting}

Return the full name of the month of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L190-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1979988737860589713}{} 
\hyperlink{1979988737860589713}{\texttt{Base.Dates.monthabbr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
monthabbr(dt::TimeType; locale="english") -> AbstractString
\end{lstlisting}

Return the abbreviated month name of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L199-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15503119946294889402}{} 
\hyperlink{15503119946294889402}{\texttt{Base.Dates.daysinmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
daysinmonth(dt::TimeType) -> Int
\end{lstlisting}

Returns the number of days in the month of \texttt{dt}. Value will be 28, 29, 30, or 31.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L208-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18025935327355387493}{} 
\hyperlink{18025935327355387493}{\texttt{Base.Dates.isleapyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isleapyear(dt::TimeType) -> Bool
\end{lstlisting}

Returns \texttt{true} if the year of \texttt{dt} is a leap year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L216-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15283021054811681483}{} 
\hyperlink{15283021054811681483}{\texttt{Base.Dates.dayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofyear(dt::TimeType) -> Int
\end{lstlisting}

Returns the day of the year for \texttt{dt} with January 1st being day 1.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L223-L227}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2148579310409606490}{} 
\hyperlink{2148579310409606490}{\texttt{Base.Dates.daysinyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
daysinyear(dt::TimeType) -> Int
\end{lstlisting}

Returns 366 if the year of \texttt{dt} is a leap year, otherwise returns 365.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L89-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13950511459712943725}{} 
\hyperlink{13950511459712943725}{\texttt{Base.Dates.quarterofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
quarterofyear(dt::TimeType) -> Int
\end{lstlisting}

Returns the quarter that \texttt{dt} resides in. Range of value is 1:4.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L233-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15988019016584368016}{} 
\hyperlink{15988019016584368016}{\texttt{Base.Dates.dayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofquarter(dt::TimeType) -> Int
\end{lstlisting}

Returns the day of the current quarter of \texttt{dt}. Range of value is 1:92.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L244-L248}{\texttt{source}}


\end{adjustwidth}

\hypertarget{17953834571670340959}{}


\subsection{Funciones de Ajuste}


\hypertarget{7412479111462927551}{} 
\hyperlink{7412479111462927551}{\texttt{Base.trunc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trunc(dt::TimeType, ::Type{Period}) -> TimeType
\end{lstlisting}

Truncates the value of \texttt{dt} according to the provided \texttt{Period} type. E.g. if \texttt{dt} is \texttt{1996-01-01T12:30:00}, then \texttt{trunc(dt,Day) == 1996-01-01T00:00:00}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L23-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15677981373530139727}{} 
\hyperlink{15677981373530139727}{\texttt{Base.Dates.firstdayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
firstdayofweek(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the Monday of its week.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L32-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8038953726514452417}{} 
\hyperlink{8038953726514452417}{\texttt{Base.Dates.lastdayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lastdayofweek(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the Sunday of its week.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L42-L46}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12743214730484566774}{} 
\hyperlink{12743214730484566774}{\texttt{Base.Dates.firstdayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
firstdayofmonth(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the first day of its month.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L52-L56}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6275133620700325946}{} 
\hyperlink{6275133620700325946}{\texttt{Base.Dates.lastdayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lastdayofmonth(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the last day of its month.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5871349443949523716}{} 
\hyperlink{5871349443949523716}{\texttt{Base.Dates.firstdayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
firstdayofyear(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the first day of its year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L75-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5562822772348873155}{} 
\hyperlink{5562822772348873155}{\texttt{Base.Dates.lastdayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lastdayofyear(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the last day of its year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L85-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2063104864586136689}{} 
\hyperlink{2063104864586136689}{\texttt{Base.Dates.firstdayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
firstdayofquarter(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the first day of its quarter.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L98-L102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5146789007163617957}{} 
\hyperlink{5146789007163617957}{\texttt{Base.Dates.lastdayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lastdayofquarter(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the last day of its quarter.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L112-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17409471999654347609}{} 
\hyperlink{17409471999654347609}{\texttt{Base.Dates.tonext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tonext(dt::TimeType, dow::Int; same::Bool=false) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the next day of week corresponding to \texttt{dow} with \texttt{1 = Monday, 2 = Tuesday, etc}. Setting \texttt{same=true} allows the current \texttt{dt} to be considered as the next \texttt{dow}, allowing for no adjustment to occur.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L242-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7599972091906648015}{} 
\hyperlink{7599972091906648015}{\texttt{Base.Dates.toprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
toprev(dt::TimeType, dow::Int; same::Bool=false) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the previous day of week corresponding to \texttt{dow} with \texttt{1 = Monday, 2 = Tuesday, etc}. Setting \texttt{same=true} allows the current \texttt{dt} to be considered as the previous \texttt{dow}, allowing for no adjustment to occur.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L264-L270}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15320794192333426258}{} 
\hyperlink{15320794192333426258}{\texttt{Base.Dates.tofirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tofirst(dt::TimeType, dow::Int; of=Month) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the first \texttt{dow} of its month. Alternatively, \texttt{of=Year} will adjust to the first \texttt{dow} of the year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L286-L291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5463466470080435101}{} 
\hyperlink{5463466470080435101}{\texttt{Base.Dates.tolast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tolast(dt::TimeType, dow::Int; of=Month) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the last \texttt{dow} of its month. Alternatively, \texttt{of=Year} will adjust to the last \texttt{dow} of the year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L298-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2273056547445243157}{} 
\hyperlink{2273056547445243157}{\texttt{Base.Dates.tonext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tonext(func::Function, dt::TimeType; step=Day(1), limit=10000, same=false) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} by iterating at most \texttt{limit} iterations by \texttt{step} increments until \texttt{func} returns \texttt{true}. \texttt{func} must take a single \texttt{TimeType} argument and return a \hyperlink{46725311238864537}{\texttt{Bool}}. \texttt{same} allows \texttt{dt} to be considered in satisfying \texttt{func}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L252-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12275775027934528278}{} 
\hyperlink{12275775027934528278}{\texttt{Base.Dates.toprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
toprev(func::Function, dt::TimeType; step=Day(-1), limit=10000, same=false) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} by iterating at most \texttt{limit} iterations by \texttt{step} increments until \texttt{func} returns \texttt{true}. \texttt{func} must take a single \texttt{TimeType} argument and return a \hyperlink{46725311238864537}{\texttt{Bool}}. \texttt{same} allows \texttt{dt} to be considered in satisfying \texttt{func}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L273-L279}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14503642401874149528}{}


\subsection{Períodos}


\hypertarget{3700773990165642536}{} 
\hyperlink{3700773990165642536}{\texttt{Base.Dates.Period}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Year(v)
Month(v)
Week(v)
Day(v)
Hour(v)
Minute(v)
Second(v)
Millisecond(v)
Microsecond(v)
Nanosecond(v)
\end{lstlisting}

Construct a \texttt{Period} type with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L37-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3038089337323869002}{} 
\hyperlink{3038089337323869002}{\texttt{Base.Dates.CompoundPeriod}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CompoundPeriod(periods) -> CompoundPeriod
\end{lstlisting}

Construct a \texttt{CompoundPeriod} from a \texttt{Vector} of \texttt{Period}s. All \texttt{Period}s of the same type will be added together.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))
25 hours

julia> Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))
-1 hour, 1 minute

julia> Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))
1 month, -2 weeks

julia> Dates.CompoundPeriod(Dates.Minute(50000))
50000 minutes
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L195-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3502963607865297667}{} 
\hyperlink{3502963607865297667}{\texttt{Base.Dates.default}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
default(p::Period) -> Period
\end{lstlisting}

Returns a sensible {\textquotedbl}default{\textquotedbl} value for the input Period by returning \texttt{T(1)} for Year, Month, and Day, and \texttt{T(0)} for Hour, Minute, Second, and Millisecond.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4298099884550062611}{}


\subsection{Funciones de Redondeo}



\texttt{Date} and \texttt{DateTime} values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with \texttt{floor}, \texttt{ceil}, or \texttt{round}.


\hypertarget{13948277906659863497}{} 
\hyperlink{13948277906659863497}{\texttt{Base.floor}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
floor(dt::TimeType, p::Period) -> TimeType
\end{lstlisting}

Returns the nearest \texttt{Date} or \texttt{DateTime} less than or equal to \texttt{dt} at resolution \texttt{p}.

For convenience, \texttt{p} may be a type instead of a value: \texttt{floor(dt, Dates.Hour)} is a shortcut for \texttt{floor(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> floor(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia> floor(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-06T00:00:00
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L79-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11509984064218511874}{} 
\hyperlink{11509984064218511874}{\texttt{Base.ceil}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ceil(dt::TimeType, p::Period) -> TimeType
\end{lstlisting}

Returns the nearest \texttt{Date} or \texttt{DateTime} greater than or equal to \texttt{dt} at resolution \texttt{p}.

For convenience, \texttt{p} may be a type instead of a value: \texttt{ceil(dt, Dates.Hour)} is a shortcut for \texttt{ceil(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> ceil(Date(1985, 8, 16), Dates.Month)
1985-09-01

julia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia> ceil(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L100-L118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7894166454005036294}{} 
\hyperlink{7894166454005036294}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
round(dt::TimeType, p::Period, [r::RoundingMode]) -> TimeType
\end{lstlisting}

Returns the \texttt{Date} or \texttt{DateTime} nearest to \texttt{dt} at resolution \texttt{p}. By default (\texttt{RoundNearestTiesUp}), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.

For convenience, \texttt{p} may be a type instead of a value: \texttt{round(dt, Dates.Hour)} is a shortcut for \texttt{round(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> round(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> round(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia> round(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
\end{minted}

Valid rounding modes for \texttt{round(::TimeType, ::Period, ::RoundingMode)} are \texttt{RoundNearestTiesUp} (default), \texttt{RoundDown} (\texttt{floor}), and \texttt{RoundUp} (\texttt{ceil}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L135-L157}{\texttt{source}}


\end{adjustwidth}

Las siguientes funciones no están exportadas:


\hypertarget{8367348060461430078}{} 
\hyperlink{8367348060461430078}{\texttt{Base.Dates.floorceil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
floorceil(dt::TimeType, p::Period) -> (TimeType, TimeType)
\end{lstlisting}

Simultaneously return the \texttt{floor} and \texttt{ceil} of a \texttt{Date} or \texttt{DateTime} at resolution \texttt{p}. More efficient than calling both \texttt{floor} and \texttt{ceil} individually.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L124-L129}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3684978517923462707}{} 
\hyperlink{3684978517923462707}{\texttt{Base.Dates.epochdays2date}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
epochdays2date(days) -> Date
\end{lstlisting}

Takes the number of days since the rounding epoch (\texttt{0000-01-01T00:00:00}) and returns the corresponding \texttt{Date}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L10-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1628469795535599119}{} 
\hyperlink{1628469795535599119}{\texttt{Base.Dates.epochms2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
epochms2datetime(milliseconds) -> DateTime
\end{lstlisting}

Takes the number of milliseconds since the rounding epoch (\texttt{0000-01-01T00:00:00}) and returns the corresponding \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L18-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4956356462973552427}{} 
\hyperlink{4956356462973552427}{\texttt{Base.Dates.date2epochdays}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
date2epochdays(dt::Date) -> Int64
\end{lstlisting}

Takes the given \texttt{Date} and returns the number of days since the rounding epoch (\texttt{0000-01-01T00:00:00}) as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L26-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10434598411550666131}{} 
\hyperlink{10434598411550666131}{\texttt{Base.Dates.datetime2epochms}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
datetime2epochms(dt::DateTime) -> Int64
\end{lstlisting}

Takes the given \texttt{DateTime} and returns the number of milliseconds since the rounding epoch (\texttt{0000-01-01T00:00:00}) as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L34-L39}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8333681668355342874}{}


\subsection{Funciones de Conversión}


\hypertarget{14794617941716137009}{} 
\hyperlink{14794617941716137009}{\texttt{Base.Dates.today}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
today() -> Date
\end{lstlisting}

Returns the date portion of \texttt{now()}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L72-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16290614891006602028}{} 
\hyperlink{16290614891006602028}{\texttt{Base.Dates.unix2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unix2datetime(x) -> DateTime
\end{lstlisting}

Takes the number of seconds since unix epoch \texttt{1970-01-01T00:00:00} and converts to the corresponding \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L42-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8673051370538450902}{} 
\hyperlink{8673051370538450902}{\texttt{Base.Dates.datetime2unix}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
datetime2unix(dt::DateTime) -> Float64
\end{lstlisting}

Takes the given \texttt{DateTime} and returns the number of seconds since the unix epoch \texttt{1970-01-01T00:00:00} as a \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L52-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1836114976869278679}{} 
\hyperlink{1836114976869278679}{\texttt{Base.Dates.julian2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
julian2datetime(julian_days) -> DateTime
\end{lstlisting}

Takes the number of Julian calendar days since epoch \texttt{-4713-11-24T12:00:00} and returns the corresponding \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L104-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10255972529610617723}{} 
\hyperlink{10255972529610617723}{\texttt{Base.Dates.datetime2julian}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
datetime2julian(dt::DateTime) -> Float64
\end{lstlisting}

Takes the given \texttt{DateTime} and returns the number of Julian calendar days since the julian epoch \texttt{-4713-11-24T12:00:00} as a \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L115-L120}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16685934354883098672}{} 
\hyperlink{16685934354883098672}{\texttt{Base.Dates.rata2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rata2datetime(days) -> DateTime
\end{lstlisting}

Takes the number of Rata Die days since epoch \texttt{0000-12-31T00:00:00} and returns the corresponding \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L86-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12986995780671236226}{} 
\hyperlink{12986995780671236226}{\texttt{Base.Dates.datetime2rata}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
datetime2rata(dt::TimeType) -> Int64
\end{lstlisting}

Returns the number of Rata Die days since epoch from the given \texttt{Date} or \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L94-L98}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9218040371144180833}{}


\subsection{Constantes}



Días de la semana:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Variable & Abbr. & Value (Int) \\
\hline
\texttt{Monday} & \texttt{Mon} & 1 \\
\hline
\texttt{Tuesday} & \texttt{Tue} & 2 \\
\hline
\texttt{Wednesday} & \texttt{Wed} & 3 \\
\hline
\texttt{Thursday} & \texttt{Thu} & 4 \\
\hline
\texttt{Friday} & \texttt{Fri} & 5 \\
\hline
\texttt{Saturday} & \texttt{Sat} & 6 \\
\hline
\texttt{Sunday} & \texttt{Sun} & 7 \\
\hline
\end{tabulary}

\end{table}



Meses del Año:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Variable & Abbr. & Value (Int) \\
\hline
\texttt{January} & \texttt{Jan} & 1 \\
\hline
\texttt{February} & \texttt{Feb} & 2 \\
\hline
\texttt{March} & \texttt{Mar} & 3 \\
\hline
\texttt{April} & \texttt{Apr} & 4 \\
\hline
\texttt{May} & \texttt{May} & 5 \\
\hline
\texttt{June} & \texttt{Jun} & 6 \\
\hline
\texttt{July} & \texttt{Jul} & 7 \\
\hline
\texttt{August} & \texttt{Aug} & 8 \\
\hline
\texttt{September} & \texttt{Sep} & 9 \\
\hline
\texttt{October} & \texttt{Oct} & 10 \\
\hline
\texttt{November} & \texttt{Nov} & 11 \\
\hline
\texttt{December} & \texttt{Dec} & 12 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{2381796939793458375}{}


\chapter{Utilidades para Iteración}


\hypertarget{11836366300100000234}{} 
\hyperlink{11836366300100000234}{\texttt{Base.Iterators.zip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
zip(iters...)
\end{lstlisting}

For a set of iterable objects, returns an iterable of tuples, where the \texttt{i}th tuple contains the \texttt{i}th component of each input iterable.

Note that \hyperlink{11836366300100000234}{\texttt{zip}} is its own inverse: \texttt{collect(zip(zip(a...)...)) == collect(a)}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1:5
1:5

julia> b = ["e","d","b","c","a"]
5-element Array{String,1}:
 "e"
 "d"
 "b"
 "c"
 "a"

julia> c = zip(a,b)
Base.Iterators.Zip2{UnitRange{Int64},Array{String,1}}(1:5, String["e", "d", "b", "c", "a"])

julia> length(c)
5

julia> first(c)
(1, "e")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L201-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2184606349967262519}{} 
\hyperlink{2184606349967262519}{\texttt{Base.Iterators.enumerate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
enumerate(iter)
\end{lstlisting}

An iterator that yields \texttt{(i, x)} where \texttt{i} is a counter starting at 1, and \texttt{x} is the \texttt{i}th value from the given iterator. It{\textquotesingle}s useful when you need not only the values \texttt{x} over which you are iterating, but also the number of iterations so far. Note that \texttt{i} may not be valid for indexing \texttt{iter}; it{\textquotesingle}s also possible that \texttt{x != iter[i]}, if \texttt{iter} has indices that do not start at 1. See the \texttt{enumerate(IndexLinear(), iter)} method if you want to ensure that \texttt{i} is an index.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ["a", "b", "c"];

julia> for (index, value) in enumerate(a)
           println("$index $value")
       end
1 a
2 b
3 c
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L35-L58}{\texttt{source}}



\begin{lstlisting}
enumerate(IndexLinear(), A)
enumerate(IndexCartesian(), A)
enumerate(IndexStyle(A), A)
\end{lstlisting}

An iterator that accesses each element of the array \texttt{A}, returning \texttt{(i, x)}, where \texttt{i} is the index for the element and \texttt{x = A[i]}.  This is similar to \texttt{enumerate(A)}, except \texttt{i} will always be a valid index for \texttt{A}.

Specifying \texttt{IndexLinear()} ensures that \texttt{i} will be an integer; specifying \texttt{IndexCartesian()} ensures that \texttt{i} will be a \texttt{CartesianIndex}; specifying \texttt{IndexStyle(A)} chooses whichever has been defined as the native indexing style for array \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = ["a" "d"; "b" "e"; "c" "f"];

julia> for (index, value) in enumerate(IndexStyle(A), A)
           println("$index $value")
       end
1 a
2 b
3 c
4 d
5 e
6 f

julia> S = view(A, 1:2, :);

julia> for (index, value) in enumerate(IndexStyle(S), S)
           println("$index $value")
       end
CartesianIndex{2}((1, 1)) a
CartesianIndex{2}((2, 1)) b
CartesianIndex{2}((1, 2)) d
CartesianIndex{2}((2, 2)) e
\end{minted}

Note that \texttt{enumerate(A)} returns \texttt{i} as a \emph{counter} (always starting at 1), whereas \texttt{enumerate(IndexLinear(), A)} returns \texttt{i} as an \emph{index} (starting at the first linear index of \texttt{A}, which may or may not be 1).

See also: \hyperlink{7782790551324367092}{\texttt{IndexStyle}}, \hyperlink{16112307926804387301}{\texttt{indices}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L80-L127}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3784260484755044695}{} 
\hyperlink{3784260484755044695}{\texttt{Base.Iterators.rest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rest(iter, state)
\end{lstlisting}

An iterator that yields the same elements as \texttt{iter}, but starting at the given \texttt{state}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L312-L316}{\texttt{source}}


\end{adjustwidth}
\hypertarget{218851424586263192}{} 
\hyperlink{218851424586263192}{\texttt{Base.Iterators.countfrom}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
countfrom(start=1, step=1)
\end{lstlisting}

An iterator that counts forever, starting at \texttt{start} and incrementing by \texttt{step}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L337-L341}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7844855039511634473}{} 
\hyperlink{7844855039511634473}{\texttt{Base.Iterators.take}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
take(iter, n)
\end{lstlisting}

An iterator that generates at most the first \texttt{n} elements of \texttt{iter}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1:2:11
1:2:11

julia> collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia> collect(Iterators.take(a,3))
3-element Array{Int64,1}:
 1
 3
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L361-L387}{\texttt{source}}


\end{adjustwidth}
\hypertarget{744681231854455039}{} 
\hyperlink{744681231854455039}{\texttt{Base.Iterators.drop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
drop(iter, n)
\end{lstlisting}

An iterator that generates all but the first \texttt{n} elements of \texttt{iter}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1:2:11
1:2:11

julia> collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia> collect(Iterators.drop(a,4))
2-element Array{Int64,1}:
  9
 11
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L418-L443}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13881904186147539554}{} 
\hyperlink{13881904186147539554}{\texttt{Base.Iterators.cycle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cycle(iter)
\end{lstlisting}

An iterator that cycles through \texttt{iter} forever.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L477-L481}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16149631071727159175}{} 
\hyperlink{16149631071727159175}{\texttt{Base.Iterators.repeated}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
repeated(x[, n::Int])
\end{lstlisting}

An iterator that generates the value \texttt{x} forever. If \texttt{n} is specified, generates \texttt{x} that many times (equivalent to \texttt{take(repeated(x), n)}).

\textbf{Example}


\begin{minted}{jlcon}
julia> a = Iterators.repeated([1 2], 4);

julia> collect(a)
4-element Array{Array{Int64,2},1}:
 [1 2]
 [1 2]
 [1 2]
 [1 2]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L512-L530}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12093738197940348056}{} 
\hyperlink{12093738197940348056}{\texttt{Base.Iterators.product}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
product(iters...)
\end{lstlisting}

Returns an iterator over the product of several iterators. Each generated element is a tuple whose \texttt{i}th element comes from the \texttt{i}th argument iterator. The first iterator changes the fastest. Example:

\textbf{Example}


\begin{minted}{jlcon}
julia> collect(Iterators.product(1:2,3:5))
2×3 Array{Tuple{Int64,Int64},2}:
 (1, 3)  (1, 4)  (1, 5)
 (2, 3)  (2, 4)  (2, 5)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L602-L617}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6994420133663892005}{} 
\hyperlink{6994420133663892005}{\texttt{Base.Iterators.flatten}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flatten(iter)
\end{lstlisting}

Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.

\textbf{Example}


\begin{minted}{jlcon}
julia> collect(Iterators.flatten((1:2, 8:9)))
4-element Array{Int64,1}:
 1
 2
 8
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L681-L698}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16897863122939587148}{} 
\hyperlink{16897863122939587148}{\texttt{Base.Iterators.partition}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
partition(collection, n)
\end{lstlisting}

Iterate over a collection \texttt{n} elements at a time.

\textbf{Example}


\begin{minted}{jlcon}
julia> collect(Iterators.partition([1,2,3,4,5], 2))
3-element Array{Array{Int64,1},1}:
 [1, 2]
 [3, 4]
 [5]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L738-L752}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6239948001455396291}{}


\chapter{Haciendo Pruebas Unitarias}





\hypertarget{16317129480609991656}{}


\section{Probando Julia Base}



Julia está en rápido desarrollo y cuenta con un amplio conjunto de pruebas para verificar su funcionalidad en múltiples plataformas. Si compila Julia desde el origen, puede ejecutar este conjunto de pruebas con \texttt{make test}. En una instalación binaria, puede ejecutar el conjunto de pruebas utilizando \texttt{Base.runtests()}.


\hypertarget{2272377293323848310}{} 
\hyperlink{2272377293323848310}{\texttt{Base.runtests}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
runtests([tests=["all"] [, numcores=ceil(Int, Sys.CPU_CORES / 2) ]])
\end{lstlisting}

Run the Julia unit tests listed in \texttt{tests}, which can be either a string or an array of strings, using \texttt{numcores} processors. (not exported)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L673-L678}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6291549838053465149}{}


\section{Pruebas Unitarias Básicas}



El módulo \texttt{Base.Test} proporciona una funcionalidad simple de \emph{realización de pruebas unitarias}. Las pruebas unitarias son una forma de ver si su código es correcto al verificar que los resultados sean los esperados. Puede ser útil asegurarse de que su código aún funcione después de realizar los cambios, y se puede usar al desarrollarlo como una forma de especificar los comportamientos que su código debería tener cuando se complete.



Se pueden realizar pruebas unitarias simples con las macros \texttt{@test ()} y \texttt{@test\_throws ()}:


\hypertarget{15457707572980302311}{} 
\hyperlink{15457707572980302311}{\texttt{Base.Test.@test}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test ex
@test f(args...) key=val ...
\end{lstlisting}

Tests that the expression \texttt{ex} evaluates to \texttt{true}. Returns a \texttt{Pass} \texttt{Result} if it does, a \texttt{Fail} \texttt{Result} if it is \texttt{false}, and an \texttt{Error} \texttt{Result} if it could not be evaluated.

The \texttt{@test f(args...) key=val...} form is equivalent to writing \texttt{@test f(args..., key=val...)} which can be useful when the expression is a call using infix syntax such as approximate comparisons:


\begin{lstlisting}
@test a ≈ b atol=ε
\end{lstlisting}

This is equivalent to the uglier test \texttt{@test ≈(a, b, atol=ε)}. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (\texttt{k=v}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L230-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17077004034353018115}{} 
\hyperlink{17077004034353018115}{\texttt{Base.Test.@test\_throws}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_throws extype ex
\end{lstlisting}

Tests that the expression \texttt{ex} throws an exception of type \texttt{extype}. Note that \texttt{@test\_throws} does not support a trailing keyword form.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L369-L374}{\texttt{source}}


\end{adjustwidth}

Por ejemplo, supongamos que queremos comprobar que nuestra nueva función \texttt{foo(x)} funciona como se esperaba:




\begin{lstlisting}
julia> using Base.Test

julia> foo(x) = length(x)^2
foo (generic function with 1 method)
\end{lstlisting}



Si la condición es cierta, se devuelve un \texttt{Pass}:




\begin{lstlisting}
julia> @test foo("bar") == 9
Test Passed

julia> @test foo("fizz") >= 10
Test Passed
\end{lstlisting}



Si la condición es falsa, se devuelve un \texttt{Fail} y se lanza una excepción:




\begin{lstlisting}
julia> @test foo("f") == 20
Test Failed
  Expression: foo("f") == 20
   Evaluated: 1 == 20
ERROR: There was an error during testing
\end{lstlisting}



Si la condición no pudo ser evaluada porque se lanzó una excepción, lo que ocurre en este caso porque \texttt{length()} no está definido para símbolos, se devuelve un objeto \texttt{Error} y se lanza una excepción:




\begin{minted}{jlcon}
julia> @test foo(:cat) == 1
Error During Test
  Test threw an exception of type MethodError
  Expression: foo(:cat) == 1
  MethodError: no method matching length(::Symbol)
  Closest candidates are:
    length(::SimpleVector) at essentials.jl:256
    length(::Base.MethodList) at reflection.jl:521
    length(::MethodTable) at reflection.jl:597
    ...
  Stacktrace:
   [...]
ERROR: There was an error during testing
\end{minted}



Si esperamos que al evaluar una expresión \emph{deberían} lanzarse una excepción, entonces podemos usar \texttt{@test\_throws()} para comprobar que esto es lo que ocurre:




\begin{lstlisting}
julia> @test_throws MethodError foo(:cat)
Test Passed
      Thrown: MethodError
\end{lstlisting}



\hypertarget{16413745763416488393}{}


\section{Trabajando con Conjuntos de Test}



Normalmente, se utiliza una gran cantidad de pruebas para garantizar que las funciones trabajan correctamente sobre distintas entradas. En el caso de que una prueba falle, el comportamiento predeterminado es lanzar una excepción de inmediato. Sin embargo, normalmente es preferible ejecutar el resto de las pruebas primero para obtener una mejor idea de cuántos errores hay en el código que se prueba.



La macro \texttt{@testset()} se puede usar para agrupar las pruebas en \emph{conjuntos}. En un conjunto de pruebas, se ejecutarán variasy al final de su realización se imprimirá un resumen. Si alguna de las pruebas falla o no se puede evaluar debido a un error, el conjunto de prueba arrojará una \texttt{TestSetException}.


\hypertarget{340190871613779559}{} 
\hyperlink{340190871613779559}{\texttt{Base.Test.@testset}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@testset [CustomTestSet] [option=val  ...] ["description"] begin ... end
@testset [CustomTestSet] [option=val  ...] ["description $v"] for v in (...) ... end
@testset [CustomTestSet] [option=val  ...] ["description $v, $w"] for v in (...), w in (...) ... end
\end{lstlisting}

Starts a new test set, or multiple test sets if a \texttt{for} loop is provided.

If no custom testset type is given it defaults to creating a \texttt{DefaultTestSet}. \texttt{DefaultTestSet} records all the results and, if there are any \texttt{Fail}s or \texttt{Error}s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.

Any custom testset type (subtype of \texttt{AbstractTestSet}) can be given and it will also be used for any nested \texttt{@testset} invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.

The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.

By default the \texttt{@testset} macro will return the testset object itself, though this behavior can be customized in other testset types. If a \texttt{for} loop is used then the macro collects and returns a list of the return values of the \texttt{finish} method, which by default will return a list of the testset objects used in each iteration.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L792-L817}{\texttt{source}}


\end{adjustwidth}

Podemos poner nuestros tests para la función \texttt{foo(x)} en un conjuntos de tests:




\begin{lstlisting}
julia> @testset "Foo Tests" begin
           @test foo("a")   == 1
           @test foo("ab")  == 4
           @test foo("abc") == 9
       end;
Test Summary: | Pass  Total
Foo Tests     |    3      3
\end{lstlisting}



Los conjuntos de pruebas pueden también anidarse:




\begin{lstlisting}
julia> @testset "Foo Tests" begin
           @testset "Animals" begin
               @test foo("cat") == 9
               @test foo("dog") == foo("cat")
           end
           @testset "Arrays $i" for i in 1:3
               @test foo(zeros(i)) == i^2
               @test foo(ones(i)) == i^2
           end
       end;
Test Summary: | Pass  Total
Foo Tests     |    8      8
\end{lstlisting}



En el caso de que un conjunto de pruebas anidado no tenga fallos, como pasa aquí, ello se ocultará en el resumen. Si tenemos un test que falle, sólo se mostrarán los detalles para este conjunto de tests que ha fallado:




\begin{minted}{jlcon}
julia> @testset "Foo Tests" begin
           @testset "Animals" begin
               @testset "Felines" begin
                   @test foo("cat") == 9
               end
               @testset "Canines" begin
                   @test foo("dog") == 9
               end
           end
           @testset "Arrays" begin
               @test foo(zeros(2)) == 4
               @test foo(ones(4)) == 15
           end
       end

Arrays: Test Failed
  Expression: foo(ones(4)) == 15
   Evaluated: 16 == 15
Stacktrace:
    [...]
Test Summary: | Pass  Fail  Total
Foo Tests     |    3     1      4
  Animals     |    2            2
  Arrays      |    1     1      2
ERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.
\end{minted}



\hypertarget{5539964808738051104}{}


\section{Otras Macros para Tests}



Como los cálculos sobre valores en punto flotane pueden ser imprecisos, podemos realizar comprobaciones de igualdad aproximada usando \texttt{@test a ≈ b} (donde \texttt{≈}, se obtiene mediante terminación con tabulador de \texttt{{\textbackslash}approx}, es la función \hyperlink{12499503887608197213}{\texttt{isapprox()}}) o usar directamente \hyperlink{12499503887608197213}{\texttt{isapprox()}}.




\begin{minted}{jlcon}
julia> @test 1 ≈ 0.999999999
Test Passed

julia> @test 1 ≈ 0.999999
Test Failed
  Expression: 1 ≈ 0.999999
   Evaluated: 1 ≈ 0.999999
ERROR: There was an error during testing
\end{minted}


\hypertarget{6965726194489549353}{} 
\hyperlink{6965726194489549353}{\texttt{Base.Test.@inferred}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@inferred f(x)
\end{lstlisting}

Tests that the call expression \texttt{f(x)} returns a value of the same type inferred by the compiler. It is useful to check for type stability.

\texttt{f(x)} can be any call expression. Returns the result of \texttt{f(x)} if the types match, and an \texttt{Error} \texttt{Result} if it finds different types.


\begin{minted}{jlcon}
julia> using Base.Test

julia> f(a,b,c) = b > 1 ? 1 : 1.0
f (generic function with 1 method)

julia> typeof(f(1,2,3))
Int64

julia> @code_warntype f(1,2,3)
Variables:
  #self# <optimized out>
  a <optimized out>
  b::Int64
  c <optimized out>

Body:
  begin
      unless (Base.slt_int)(1, b::Int64)::Bool goto 3
      return 1
      3:
      return 1.0
  end::UNION{FLOAT64, INT64}

julia> @inferred f(1,2,3)
ERROR: return type Int64 does not match inferred return type Union{Float64, Int64}
Stacktrace:
 [1] error(::String) at ./error.jl:21

julia> @inferred max(1,2)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L1023-L1065}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10915695400018210103}{} 
\hyperlink{10915695400018210103}{\texttt{Base.Test.@test\_warn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_warn msg expr
\end{lstlisting}

Test whether evaluating \texttt{expr} results in \hyperlink{4481879903628924306}{\texttt{STDERR}} output that contains the \texttt{msg} string or matches the \texttt{msg} regular expression.  If \texttt{msg} is a boolean function, tests whether \texttt{msg(output)} returns \texttt{true}.  If \texttt{msg} is a tuple or array, checks that the error output contains/matches each item in \texttt{msg}. Returns the result of evaluating \texttt{expr}.

See also \hyperlink{589147025836585250}{\texttt{@test\_nowarn}} to check for the absence of error output.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L412-L422}{\texttt{source}}


\end{adjustwidth}
\hypertarget{589147025836585250}{} 
\hyperlink{589147025836585250}{\texttt{Base.Test.@test\_nowarn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_nowarn expr
\end{lstlisting}

Test whether evaluating \texttt{expr} results in empty \hyperlink{4481879903628924306}{\texttt{STDERR}} output (no warnings or other messages).  Returns the result of evaluating \texttt{expr}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L443-L448}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15498374397048132519}{}


\section{Tests Rotos}



Si un test falla consistentemente puede ser cambiado para utilizar la macro \texttt{@test\_broken()}. Esto denotará el test como Roto  (\texttt{Broken}) si el test continua fallando y alterta al usuaria a traves de un \texttt{Error} si el test tiene éxito.


\hypertarget{641859080742533604}{} 
\hyperlink{641859080742533604}{\texttt{Base.Test.@test\_broken}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_broken ex
@test_broken f(args...) key=val ...
\end{lstlisting}

Indicates a test that should pass but currently consistently fails. Tests that the expression \texttt{ex} evaluates to \texttt{false} or causes an exception. Returns a \texttt{Broken} \texttt{Result} if it does, or an \texttt{Error} \texttt{Result} if the expression evaluates to \texttt{true}.

The \texttt{@test\_broken f(args...) key=val...} form works as for the \texttt{@test} macro.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L255-L265}{\texttt{source}}


\end{adjustwidth}

\texttt{@test\_skip()} está también disponible para saltar un test sin evaluación, pero contando el test que se ha saltado en el informe del conjunto de tests. El test no se ejecutará pero da un \texttt{Broken} \texttt{Result}.


\hypertarget{14114707839034633381}{} 
\hyperlink{14114707839034633381}{\texttt{Base.Test.@test\_skip}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_skip ex
@test_skip f(args...) key=val ...
\end{lstlisting}

Marks a test that should not be executed but should be included in test summary reporting as \texttt{Broken}. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.

The \texttt{@test\_skip f(args...) key=val...} form works as for the \texttt{@test} macro.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L274-L283}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5039756121682966765}{}


\section{Creando Tipos \texttt{AbstractTestSet} Personalizados}



Los paquetes pueden crear sus propios subtipos \texttt{AbstractTestSet} implementando los métodos \texttt{record} y \texttt{finish}. El subtipo debe tener un constructor de un argumento que tome una cadena de descripción, con todas las opciones pasadas como argumentos  palabra clave.


\hypertarget{17372569521044333819}{} 
\hyperlink{17372569521044333819}{\texttt{Base.Test.record}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
record(ts::AbstractTestSet, res::Result)
\end{lstlisting}

Record a result to a testset. This function is called by the \texttt{@testset} infrastructure each time a contained \texttt{@test} macro completes, and is given the test result (which could be an \texttt{Error}). This will also be called with an \texttt{Error} if an exception is thrown inside the test block but outside of a \texttt{@test} context.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L464-L471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14177851825850418080}{} 
\hyperlink{14177851825850418080}{\texttt{Base.Test.finish}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
finish(ts::AbstractTestSet)
\end{lstlisting}

Do any final processing necessary for the given testset. This is called by the \texttt{@testset} infrastructure after a test block executes. One common use for this function is to record the testset to the parent{\textquotesingle}s results list, using \texttt{get\_testset}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L474-L481}{\texttt{source}}


\end{adjustwidth}

\texttt{Base.Test} asume la responsabilidad de mantener una pila de conjuntos de pruebas anidados a medida que se ejecutan, pero cualquier acumulación de resultados es responsabilidad del subtipo\texttt{AbstractTestSet}. Puede acceder a esta pila con los métodos \texttt{get\_testset} y\texttt{get\_testset\_depth}. Tenga en cuenta que estas funciones no se exportan.


\hypertarget{13301674573280065084}{} 
\hyperlink{13301674573280065084}{\texttt{Base.Test.get\_testset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get_testset()
\end{lstlisting}

Retrieve the active test set from the task{\textquotesingle}s local storage. If no test set is active, use the fallback default test set.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L977-L982}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14902980053573349810}{} 
\hyperlink{14902980053573349810}{\texttt{Base.Test.get\_testset\_depth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get_testset_depth()
\end{lstlisting}

Returns the number of active test sets, not including the defaut test set



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L1012-L1016}{\texttt{source}}


\end{adjustwidth}

\texttt{Base.Test} también se asegura de que las invocaciones \texttt{@testset} anidadas utilicen el mismo subtipo \texttt{AbstractTestSet} que sus padres a menos que se establezca explícitamente. Él no propaga ninguna propiedad del conjunto de pruebas. El comportamiento de herencia de opciones se puede implementar mediante paquetes que usan la infraestructura de pila que proporciona \texttt{Base.Test}.



La definición de un subtipo básico de {\textquotesingle}AbstractTestSet` podría verse así:




\begin{minted}{julia}
import Base.Test: record, finish
using Base.Test: AbstractTestSet, Result, Pass, Fail, Error
using Base.Test: get_testset_depth, get_testset
struct CustomTestSet <: Base.Test.AbstractTestSet
    description::AbstractString
    foo::Int
    results::Vector
    # constructor takes a description string and options keyword arguments
    CustomTestSet(desc; foo=1) = new(desc, foo, [])
end

record(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)
record(ts::CustomTestSet, res::Result) = push!(ts.results, res)
function finish(ts::CustomTestSet)
    # just record if we're not the top-level parent
    if get_testset_depth() > 0
        record(get_testset(), ts)
    end
    ts
end
\end{minted}



Y usar este conjunto de test tiene el siguiente aspecto:




\begin{minted}{julia}
@testset CustomTestSet foo=4 "custom testset inner 2" begin
    # this testset should inherit the type, but not the argument.
    @testset "custom testset inner" begin
        @test true
    end
end
\end{minted}





\hypertarget{6196042923468033404}{}


\chapter{Interfaz C}


\hypertarget{14245046751182637566}{} 
\hyperlink{14245046751182637566}{\texttt{ccall}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ccall((symbol, library) or function_pointer, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
\end{lstlisting}

Call function in C-exported shared library, specified by \texttt{(function name, library)} tuple, where each component is a string or symbol.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression. Alternatively, \texttt{ccall} may also be used to call a function pointer, such as one returned by \texttt{dlsym}.

Each \texttt{ArgumentValue} to the \texttt{ccall} will be converted to the corresponding \texttt{ArgumentType}, by automatic insertion of calls to \texttt{unsafe\_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))}. (See also the documentation for each of these functions for further details.) In most cases, this simply results in a call to \texttt{convert(ArgumentType, ArgumentValue)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L557-L572}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2746947069730856184}{} 
\hyperlink{2746947069730856184}{\texttt{Core.Intrinsics.cglobal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cglobal((symbol, library) [, type=Void])
\end{lstlisting}

Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in \hyperlink{14245046751182637566}{\texttt{ccall}}. Returns a \texttt{Ptr\{Type\}}, defaulting to \texttt{Ptr\{Void\}} if no \texttt{Type} argument is supplied. The values can be read or written by \hyperlink{13744149973765810952}{\texttt{unsafe\_load}} or \hyperlink{4579672834750013041}{\texttt{unsafe\_store!}}, respectively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1073-L1082}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13392697678913949769}{} 
\hyperlink{13392697678913949769}{\texttt{Base.cfunction}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cfunction(function::Function, ReturnType::Type, ArgumentTypes::Type)
\end{lstlisting}

Generate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function foo(x::Int, y::Int)
           return x + y
       end

julia> cfunction(foo, Int, Tuple{Int,Int})
Ptr{Void} @0x000000001b82fcd0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L7-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6011318385865707029}{} 
\hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_convert(T,x)
\end{lstlisting}

Convert \texttt{x} to a value of type \texttt{T}

In cases where \hyperlink{1846942650946171605}{\texttt{convert}} would need to take a Julia object and turn it into a \texttt{Ptr}, this function should be used to define and perform that conversion.

Be careful to ensure that a Julia reference to \texttt{x} exists as long as the result of this function will be used. Accordingly, the argument \texttt{x} to this function should never be an expression, only a variable name or field reference. For example, \texttt{x=a.b.c} is acceptable, but \texttt{x=[a,b,c]} is not.

The \texttt{unsafe} prefix on this function indicates that using the result of this function after the \texttt{x} argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1037-L1054}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16487788729383051927}{} 
\hyperlink{16487788729383051927}{\texttt{Base.cconvert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cconvert(T,x)
\end{lstlisting}

Convert \texttt{x} to a value of type \texttt{T}, typically by calling \texttt{convert(T,x)}

In cases where \texttt{x} cannot be safely converted to \texttt{T}, unlike \hyperlink{1846942650946171605}{\texttt{convert}}, \texttt{cconvert} may return an object of a type different from \texttt{T}, which however is suitable for \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} to handle.

Neither \texttt{convert} nor \texttt{cconvert} should take a Julia object and turn it into a \texttt{Ptr}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L169-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13744149973765810952}{} 
\hyperlink{13744149973765810952}{\texttt{Base.unsafe\_load}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_load(p::Ptr{T}, i::Integer=1)
\end{lstlisting}

Load a value of type \texttt{T} from the address of the \texttt{i}th element (1-indexed) starting at \texttt{p}. This is equivalent to the C expression \texttt{p[i-1]}.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointer \texttt{p} to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L73-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4579672834750013041}{} 
\hyperlink{4579672834750013041}{\texttt{Base.unsafe\_store!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_store!(p::Ptr{T}, x, i::Integer=1)
\end{lstlisting}

Store a value of type \texttt{T} to the address of the \texttt{i}th element (1-indexed) starting at \texttt{p}. This is equivalent to the C expression \texttt{p[i-1] = x}.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointer \texttt{p} to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L85-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13418364045170663433}{} 
\hyperlink{13418364045170663433}{\texttt{Base.unsafe\_copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_copy!(dest::Ptr{T}, src::Ptr{T}, N)
\end{lstlisting}

Copy \texttt{N} elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointers \texttt{dest} and \texttt{src} to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L197-L206}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9665289950359655955}{} 
\hyperlink{9665289950359655955}{\texttt{Base.unsafe\_copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_copy!(dest::Array, do, src::Array, so, N)
\end{lstlisting}

Copy \texttt{N} elements from a source array to a destination, starting at offset \texttt{so} in the source and \texttt{do} in the destination (1-indexed).

The \texttt{unsafe} prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L209-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17572907101789489045}{} 
\hyperlink{17572907101789489045}{\texttt{Base.copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copy!(dest, src) -> dest
\end{lstlisting}

Copy all elements from collection \texttt{src} to array \texttt{dest}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L848-L852}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9273029318280862570}{} 
\hyperlink{9273029318280862570}{\texttt{Base.copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copy!(dest, do, src, so, N)
\end{lstlisting}

Copy \texttt{N} elements from collection \texttt{src} starting at offset \texttt{so}, to array \texttt{dest} starting at offset \texttt{do}. Returns \texttt{dest}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2273-L2278}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8901246211940014300}{} 
\hyperlink{8901246211940014300}{\texttt{Base.pointer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pointer(array [, index])
\end{lstlisting}

Get the native address of an array or string element. Be careful to ensure that a Julia reference to \texttt{a} exists as long as this pointer will be used. This function is {\textquotedbl}unsafe{\textquotedbl} like \texttt{unsafe\_convert}.

Calling \texttt{Ref(array[, index])} is generally preferable to this function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L47-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14566494858943689253}{} 
\hyperlink{14566494858943689253}{\texttt{Base.unsafe\_wrap}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_wrap(Array, pointer::Ptr{T}, dims, own=false)
\end{lstlisting}

Wrap a Julia \texttt{Array} object around the data at the address given by \texttt{pointer}, without making a copy.  The pointer element type \texttt{T} determines the array element type. \texttt{dims} is either an integer (for a 1d array) or a tuple of the array dimensions. \texttt{own} optionally specifies whether Julia should take ownership of the memory, calling \texttt{free} on the pointer when the array is no longer referenced.

This function is labelled {\textquotedbl}unsafe{\textquotedbl} because it will crash if \texttt{pointer} is not a valid memory address to data of the requested length.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L48-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9366554937543398846}{} 
\hyperlink{9366554937543398846}{\texttt{Base.pointer\_from\_objref}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pointer_from_objref(x)
\end{lstlisting}

Get the memory address of a Julia object as a \texttt{Ptr}. The existence of the resulting \texttt{Ptr} will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the \texttt{Ptr} will be used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L108-L114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10812596548944930674}{} 
\hyperlink{10812596548944930674}{\texttt{Base.unsafe\_pointer\_to\_objref}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_pointer_to_objref(p::Ptr)
\end{lstlisting}

Convert a \texttt{Ptr} to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered {\textquotedbl}unsafe{\textquotedbl} and should be used with care.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L99-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15284219011001573060}{} 
\hyperlink{15284219011001573060}{\texttt{Base.disable\_sigint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
disable_sigint(f::Function)
\end{lstlisting}

Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using \texttt{do} block syntax as follows:


\begin{lstlisting}
disable_sigint() do
    # interrupt-unsafe code
    ...
end
\end{lstlisting}

This is not needed on worker threads (\texttt{Threads.threadid() != 1}) since the \texttt{InterruptException} will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L321-L337}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1880405387924190637}{} 
\hyperlink{1880405387924190637}{\texttt{Base.reenable\_sigint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reenable_sigint(f::Function)
\end{lstlisting}

Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of \texttt{disable\_sigint}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L346-L351}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16566861134678143754}{} 
\hyperlink{16566861134678143754}{\texttt{Base.systemerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
systemerror(sysfunc, iftrue)
\end{lstlisting}

Raises a \texttt{SystemError} for \texttt{errno} with the descriptive string \texttt{sysfunc} if \texttt{iftrue} is \texttt{true}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L59-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10630331440513004826}{} 
\hyperlink{10630331440513004826}{\texttt{Core.Ptr}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ptr{T}
\end{lstlisting}

A memory address referring to data of type \texttt{T}.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7936024700322877457}{} 
\hyperlink{7936024700322877457}{\texttt{Core.Ref}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ref{T}
\end{lstlisting}

An object that safely references data of type \texttt{T}. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the \texttt{Ref} itself is referenced.

When passed as a \texttt{ccall} argument (either as a \texttt{Ptr} or \texttt{Ref} type), a \texttt{Ref} object will be converted to a native pointer to the data it references.

There is no invalid (NULL) \texttt{Ref}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/refpointer.jl#L3-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1445070667463182719}{} 
\hyperlink{1445070667463182719}{\texttt{Base.Cchar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cchar
\end{lstlisting}

Equivalent to the native \texttt{char} c-type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L31-L35}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8681597464447377029}{} 
\hyperlink{8681597464447377029}{\texttt{Base.Cuchar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cuchar
\end{lstlisting}

Equivalent to the native \texttt{unsigned char} c-type (\hyperlink{6609065134969660118}{\texttt{UInt8}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L6-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15152042474889311053}{} 
\hyperlink{15152042474889311053}{\texttt{Base.Cshort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cshort
\end{lstlisting}

Equivalent to the native \texttt{signed short} c-type (\hyperlink{6667287249103968645}{\texttt{Int16}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L14-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12769525139115944472}{} 
\hyperlink{12769525139115944472}{\texttt{Base.Cushort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cushort
\end{lstlisting}

Equivalent to the native \texttt{unsigned short} c-type (\hyperlink{7018610346698168012}{\texttt{UInt16}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L22-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4506686204672235089}{} 
\hyperlink{4506686204672235089}{\texttt{Base.Cint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cint
\end{lstlisting}

Equivalent to the native \texttt{signed int} c-type (\hyperlink{10103694114785108551}{\texttt{Int32}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L30-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11551219982691686969}{} 
\hyperlink{11551219982691686969}{\texttt{Base.Cuint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cuint
\end{lstlisting}

Equivalent to the native \texttt{unsigned int} c-type (\hyperlink{8690996847580776341}{\texttt{UInt32}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L38-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{634246884863419146}{} 
\hyperlink{634246884863419146}{\texttt{Base.Clong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Clong
\end{lstlisting}

Equivalent to the native \texttt{signed long} c-type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L48-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1371835691073233846}{} 
\hyperlink{1371835691073233846}{\texttt{Base.Culong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Culong
\end{lstlisting}

Equivalent to the native \texttt{unsigned long} c-type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L55-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11934627959417709350}{} 
\hyperlink{11934627959417709350}{\texttt{Base.Clonglong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Clonglong
\end{lstlisting}

Equivalent to the native \texttt{signed long long} c-type (\hyperlink{7720564657383125058}{\texttt{Int64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L86-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12084952472844229160}{} 
\hyperlink{12084952472844229160}{\texttt{Base.Culonglong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Culonglong
\end{lstlisting}

Equivalent to the native \texttt{unsigned long long} c-type (\hyperlink{5500998675195555601}{\texttt{UInt64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L94-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13457418202407416700}{} 
\hyperlink{13457418202407416700}{\texttt{Base.Cintmax\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cintmax_t
\end{lstlisting}

Equivalent to the native \texttt{intmax\_t} c-type (\hyperlink{7720564657383125058}{\texttt{Int64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L70-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11180754709564572253}{} 
\hyperlink{11180754709564572253}{\texttt{Base.Cuintmax\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cuintmax_t
\end{lstlisting}

Equivalent to the native \texttt{uintmax\_t} c-type (\hyperlink{5500998675195555601}{\texttt{UInt64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12059505362233183406}{} 
\hyperlink{12059505362233183406}{\texttt{Base.Csize\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Csize_t
\end{lstlisting}

Equivalent to the native \texttt{size\_t} c-type (\texttt{UInt}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{395962290360403795}{} 
\hyperlink{395962290360403795}{\texttt{Base.Cssize\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cssize_t
\end{lstlisting}

Equivalent to the native \texttt{ssize\_t} c-type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9258508309302754837}{} 
\hyperlink{9258508309302754837}{\texttt{Base.Cptrdiff\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cptrdiff_t
\end{lstlisting}

Equivalent to the native \texttt{ptrdiff\_t} c-type (\texttt{Int}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L46-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2619479148155454993}{} 
\hyperlink{2619479148155454993}{\texttt{Base.Cwchar\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cwchar_t
\end{lstlisting}

Equivalent to the native \texttt{wchar\_t} c-type (\hyperlink{10103694114785108551}{\texttt{Int32}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{899076182665625215}{} 
\hyperlink{899076182665625215}{\texttt{Base.Cfloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cfloat
\end{lstlisting}

Equivalent to the native \texttt{float} c-type (\hyperlink{8101639384272933082}{\texttt{Float32}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L102-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5889169829041130899}{} 
\hyperlink{5889169829041130899}{\texttt{Base.Cdouble}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cdouble
\end{lstlisting}

Equivalent to the native \texttt{double} c-type (\hyperlink{5027751419500983000}{\texttt{Float64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L110-L114}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7895252095502479171}{}


\chapter{Interfaz LLVM}


\hypertarget{12406828992589210838}{} 
\hyperlink{12406828992589210838}{\texttt{Core.Intrinsics.llvmcall}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
llvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
\end{lstlisting}

Call LLVM IR string in the first argument. Similar to an LLVM function \texttt{define} block, arguments are available as consecutive unnamed SSA variables (\%0, \%1, etc.).

The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.

Each \texttt{ArgumentValue} to \texttt{llvmcall} will be converted to the corresponding \texttt{ArgumentType}, by automatic insertion of calls to \texttt{unsafe\_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))}. (see also the documentation for each of these functions for further details). In most cases, this simply results in a call to \texttt{convert(ArgumentType, ArgumentValue)}.

See \texttt{test/llvmcall.jl} for usage examples.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L575-L596}{\texttt{source}}


\end{adjustwidth}

\hypertarget{346568585257401697}{}


\chapter{Librería Estándar C}


\hypertarget{6469711430097433314}{} 
\hyperlink{6469711430097433314}{\texttt{Base.Libc.malloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
malloc(size::Integer) -> Ptr{Void}
\end{lstlisting}

Call \texttt{malloc} from the C standard library.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L323-L327}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13715091851486420318}{} 
\hyperlink{13715091851486420318}{\texttt{Base.Libc.calloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
calloc(num::Integer, size::Integer) -> Ptr{Void}
\end{lstlisting}

Call \texttt{calloc} from the C standard library.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L340-L344}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1243276183164334610}{} 
\hyperlink{1243276183164334610}{\texttt{Base.Libc.realloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
realloc(addr::Ptr, size::Integer) -> Ptr{Void}
\end{lstlisting}

Call \texttt{realloc} from the C standard library.

See warning in the documentation for \texttt{free} regarding only using this on memory originally obtained from \texttt{malloc}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L330-L337}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1633533624062187737}{} 
\hyperlink{1633533624062187737}{\texttt{Base.Libc.free}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
free(addr::Ptr)
\end{lstlisting}

Call \texttt{free} from the C standard library. Only use this on memory obtained from \texttt{malloc}, not on pointers retrieved from other C libraries. \texttt{Ptr} objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple \texttt{libc} libraries exist on the system.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L313-L320}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6265587084343794273}{} 
\hyperlink{6265587084343794273}{\texttt{Base.Libc.errno}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
errno([code])
\end{lstlisting}

Get the value of the C library{\textquotesingle}s \texttt{errno}. If an argument is specified, it is used to set the value of \texttt{errno}.

The value of \texttt{errno} is only valid immediately after a \texttt{ccall} to a C library routine that sets it. Specifically, you cannot call \texttt{errno} at the next prompt in a REPL, because lots of code is executed between prompts.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L254-L263}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5310873199456377483}{} 
\hyperlink{5310873199456377483}{\texttt{Base.Libc.strerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strerror(n=errno())
\end{lstlisting}

Convert a system call error code to a descriptive string



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L267-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5383660591411020262}{} 
\hyperlink{5383660591411020262}{\texttt{Base.Libc.GetLastError}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GetLastError()
\end{lstlisting}

Call the Win32 \texttt{GetLastError} function [only available on Windows].



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L275-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14255728048411856987}{} 
\hyperlink{14255728048411856987}{\texttt{Base.Libc.FormatMessage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
FormatMessage(n=GetLastError())
\end{lstlisting}

Convert a Win32 system call error code to a descriptive string [only available on Windows].



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L282-L286}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2367147567483563544}{} 
\hyperlink{2367147567483563544}{\texttt{Base.Libc.time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
time(t::TmStruct)
\end{lstlisting}

Converts a \texttt{TmStruct} struct to a number of seconds since the epoch.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L217-L221}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14018638426810725597}{} 
\hyperlink{14018638426810725597}{\texttt{Base.Libc.strftime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strftime([format], time)
\end{lstlisting}

Convert time, given as a number of seconds since the epoch or a \texttt{TmStruct}, to a formatted string using the given format. Supported formats are the same as those in the standard C library.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L163-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16724851840034148355}{} 
\hyperlink{16724851840034148355}{\texttt{Base.Libc.strptime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strptime([format], timestr)
\end{lstlisting}

Parse a formatted time string into a \texttt{TmStruct} giving the seconds, minute, hour, date, etc. Supported formats are the same as those in the standard C library. On some platforms, timezones will not be parsed correctly. If the result of this function will be passed to \texttt{time} to convert it to seconds since the epoch, the \texttt{isdst} field should be filled in manually. Setting it to \texttt{-1} will tell the C library to use the current system settings to determine the timezone.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L182-L191}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12094049763760222314}{} 
\hyperlink{12094049763760222314}{\texttt{Base.Libc.TmStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
TmStruct([seconds])
\end{lstlisting}

Convert a number of seconds since the epoch to broken-down format, with fields \texttt{sec}, \texttt{min}, \texttt{hour}, \texttt{mday}, \texttt{month}, \texttt{year}, \texttt{wday}, \texttt{yday}, and \texttt{isdst}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L128-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17297724195103628361}{} 
\hyperlink{17297724195103628361}{\texttt{Base.Libc.flush\_cstdio}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flush_cstdio()
\end{lstlisting}

Flushes the C \texttt{stdout} and \texttt{stderr} streams (which may have been written to by external C code).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L95-L99}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13427841325685013289}{}


\chapter{Enlazador Dinámico}



The names in \texttt{Base.Libdl} are not exported and need to be called e.g. as \texttt{Libdl.dlopen()}.


\hypertarget{6943450904282580385}{} 
\hyperlink{6943450904282580385}{\texttt{Base.Libdl.dlopen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlopen(libfile::AbstractString [, flags::Integer])
\end{lstlisting}

Load a shared library, returning an opaque handle.

The extension given by the constant \texttt{dlext} (\texttt{.so}, \texttt{.dll}, or \texttt{.dylib}) can be omitted from the \texttt{libfile} string, as it is automatically appended if needed.   If \texttt{libfile} is not an absolute path name, then the paths in the array \texttt{DL\_LOAD\_PATH} are searched for \texttt{libfile}, followed by the system load path.

The optional flags argument is a bitwise-or of zero or more of \texttt{RTLD\_LOCAL}, \texttt{RTLD\_GLOBAL}, \texttt{RTLD\_LAZY}, \texttt{RTLD\_NOW}, \texttt{RTLD\_NODELETE}, \texttt{RTLD\_NOLOAD}, \texttt{RTLD\_DEEPBIND}, and \texttt{RTLD\_FIRST}. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default \texttt{dlopen} flags are \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_GLOBAL} while on other platforms the defaults are \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_LOCAL}. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_GLOBAL} allows the library{\textquotesingle}s symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L68-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5991700987653656651}{} 
\hyperlink{5991700987653656651}{\texttt{Base.Libdl.dlopen\_e}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlopen_e(libfile::AbstractString [, flags::Integer])
\end{lstlisting}

Similar to \hyperlink{6943450904282580385}{\texttt{dlopen}}, except returns a \texttt{NULL} pointer instead of raising errors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L100-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9396575996390240710}{} 
\hyperlink{9396575996390240710}{\texttt{Base.Libdl.RTLD\_NOW}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RTLD_DEEPBIND
RTLD_FIRST
RTLD_GLOBAL
RTLD_LAZY
RTLD_LOCAL
RTLD_NODELETE
RTLD_NOLOAD
RTLD_NOW
\end{lstlisting}

Enum constant for \hyperlink{6943450904282580385}{\texttt{dlopen}}. See your platform man page for details, if applicable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L32-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10678331493920544551}{} 
\hyperlink{10678331493920544551}{\texttt{Base.Libdl.dlsym}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlsym(handle, sym)
\end{lstlisting}

Look up a symbol from a shared library handle, return callable function pointer on success.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L48-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9015772327101222088}{} 
\hyperlink{9015772327101222088}{\texttt{Base.Libdl.dlsym\_e}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlsym_e(handle, sym)
\end{lstlisting}

Look up a symbol from a shared library handle, silently return \texttt{NULL} pointer on lookup failure.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L58-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10922755106166135872}{} 
\hyperlink{10922755106166135872}{\texttt{Base.Libdl.dlclose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlclose(handle)
\end{lstlisting}

Close shared library referenced by handle.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L113-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1158768347711175706}{} 
\hyperlink{1158768347711175706}{\texttt{Base.Libdl.dlext}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlext
\end{lstlisting}

File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L175-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{227774243348950736}{} 
\hyperlink{227774243348950736}{\texttt{Base.Libdl.find\_library}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
find_library(names, locations)
\end{lstlisting}

Searches for the first library in \texttt{names} in the paths in the \texttt{locations} list, \texttt{DL\_LOAD\_PATH}, or system library paths (in that order) which can successfully be dlopen{\textquotesingle}d. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a \texttt{global const} and used as the library name in future \texttt{ccall}{\textquotesingle}s. On failure, it returns the empty string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L122-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17268797014804593519}{} 
\hyperlink{17268797014804593519}{\texttt{Base.Libdl.DL\_LOAD\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DL_LOAD_PATH
\end{lstlisting}

When calling \hyperlink{6943450904282580385}{\texttt{dlopen}}, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L9-L14}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13446659783021526147}{}


\chapter{Profiling}


\hypertarget{2219312293287618200}{} 
\hyperlink{2219312293287618200}{\texttt{Base.Profile.@profile}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@profile
\end{lstlisting}

\texttt{@profile <expression>} runs your expression while taking periodic backtraces. These are appended to an internal buffer of backtraces.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L10-L15}{\texttt{source}}


\end{adjustwidth}

The methods in \texttt{Base.Profile} are not exported and need to be called e.g. as \texttt{Profile.print()}.


\hypertarget{11632425935156818951}{} 
\hyperlink{11632425935156818951}{\texttt{Base.Profile.clear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clear()
\end{lstlisting}

Clear any existing backtraces from the internal buffer.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L69-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15011226253236705098}{} 
\hyperlink{15011226253236705098}{\texttt{Base.Profile.print}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
print([io::IO = STDOUT,] [data::Vector]; kwargs...)
\end{lstlisting}

Prints profiling results to \texttt{io} (by default, \texttt{STDOUT}). If you do not supply a \texttt{data} vector, the internal buffer of accumulated backtraces will be used.

The keyword arguments can be any combination of:

\begin{itemize}
\item \texttt{format} – Determines whether backtraces are printed with (default, \texttt{:tree}) or without (\texttt{:flat}) indentation indicating tree structure.


\item \texttt{C} – If \texttt{true}, backtraces from C and Fortran code are shown (normally they are excluded).


\item \texttt{combine} – If \texttt{true} (default), instruction pointers are merged that correspond to the same line of code.


\item \texttt{maxdepth} – Limits the depth higher than \texttt{maxdepth} in the \texttt{:tree} format.


\item \texttt{sortedby} – Controls the order in \texttt{:flat} format. \texttt{:filefuncline} (default) sorts by the source  line, whereas \texttt{:count} sorts in order of number of collected samples.


\item \texttt{noisefloor} – Limits frames that exceed the heuristic noise floor of the sample (only applies to format \texttt{:tree}).  A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which \texttt{n <= noisefloor * √N},  where \texttt{n} is the number of samples on this line, and \texttt{N} is the number of samples for the callee.


\item \texttt{mincount} – Limits the printout to only those lines with at least \texttt{mincount} occurrences.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L97-L123}{\texttt{source}}



\begin{lstlisting}
print([io::IO = STDOUT,] data::Vector, lidict::LineInfoDict; kwargs...)
\end{lstlisting}

Prints profiling results to \texttt{io}. This variant is used to examine results exported by a previous call to \hyperlink{15769908906720781097}{\texttt{retrieve}}. Supply the vector \texttt{data} of backtraces and a dictionary \texttt{lidict} of line information.

See \texttt{Profile.print([io], data)} for an explanation of the valid keyword arguments.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L152-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18079022569292406711}{} 
\hyperlink{18079022569292406711}{\texttt{Base.Profile.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
init(; n::Integer, delay::Float64)
\end{lstlisting}

Configure the \texttt{delay} between backtraces (measured in seconds), and the number \texttt{n} of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order \texttt{(n, delay)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L34-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9770463724510220682}{} 
\hyperlink{9770463724510220682}{\texttt{Base.Profile.fetch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch() -> data
\end{lstlisting}

Returns a reference to the internal buffer of backtraces. Note that subsequent operations, like \hyperlink{11632425935156818951}{\texttt{clear}}, can affect \texttt{data} unless you first make a copy. Note that the values in \texttt{data} have meaning only on this machine in the current session, because it depends on the exact memory addresses used in JIT-compiling. This function is primarily for internal use; \hyperlink{15769908906720781097}{\texttt{retrieve}} may be a better choice for most users.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L292-L300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15769908906720781097}{} 
\hyperlink{15769908906720781097}{\texttt{Base.Profile.retrieve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
retrieve() -> data, lidict
\end{lstlisting}

{\textquotedbl}Exports{\textquotedbl} profiling results in a portable format, returning the set of all backtraces (\texttt{data}) and a dictionary that maps the (session-specific) instruction pointers in \texttt{data} to \texttt{LineInfo} values that store the file name, function name, and line number. This function allows you to save profiling results for future analysis.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L164-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17877106531089533686}{} 
\hyperlink{17877106531089533686}{\texttt{Base.Profile.callers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
callers(funcname, [data, lidict], [filename=<filename>], [linerange=<start:stop>]) -> Vector{Tuple{count, lineinfo}}
\end{lstlisting}

Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace \texttt{data} obtained from \hyperlink{15769908906720781097}{\texttt{retrieve}}; otherwise, the current internal profile buffer is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L226-L235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12267785385121896224}{} 
\hyperlink{12267785385121896224}{\texttt{Base.Profile.clear\_malloc\_data}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clear_malloc_data()
\end{lstlisting}

Clears any stored memory allocation data when running julia with \texttt{--track-allocation}. Execute the command(s) you want to test (to force JIT-compilation), then call \hyperlink{12267785385121896224}{\texttt{clear\_malloc\_data}}. Then execute your command(s) again, quit Julia, and examine the resulting \texttt{*.mem} files.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L262-L269}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5903382401809839120}{}


\chapter{\emph{StackTraces}}


\hypertarget{16824886840215699957}{} 
\hyperlink{16824886840215699957}{\texttt{Base.StackTraces.StackFrame}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
StackFrame
\end{lstlisting}

Stack information representing execution context, with the following fields:

\begin{itemize}
\item \texttt{func::Symbol}

The name of the function containing the execution context.


\item \texttt{linfo::Nullable\{Core.MethodInstance\}}

The MethodInstance containing the execution context (if it could be found).


\item \texttt{file::Symbol}

The path to the file containing the execution context.


\item \texttt{line::Int}

The line number in the file containing the execution context.


\item \texttt{from\_c::Bool}

True if the code is from C.


\item \texttt{inlined::Bool}

True if the code is from an inlined frame.


\item \texttt{pointer::UInt64}

Representation of the pointer to the execution context as returned by \texttt{backtrace}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L11-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12289172590874430030}{} 
\hyperlink{12289172590874430030}{\texttt{Base.StackTraces.StackTrace}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
StackTrace
\end{lstlisting}

An alias for \texttt{Vector\{StackFrame\}} provided for convenience; returned by calls to \texttt{stacktrace} and \texttt{catch\_stacktrace}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L64-L69}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11964270650763140298}{} 
\hyperlink{11964270650763140298}{\texttt{Base.StackTraces.stacktrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stacktrace([trace::Vector{Ptr{Void}},] [c_funcs::Bool=false]) -> StackTrace
\end{lstlisting}

Returns a stack trace in the form of a vector of \texttt{StackFrame}s. (By default stacktrace doesn{\textquotesingle}t return C functions, but this can be enabled.) When called without specifying a trace, \texttt{stacktrace} first calls \texttt{backtrace}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L143-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16506728660892665673}{} 
\hyperlink{16506728660892665673}{\texttt{Base.StackTraces.catch\_stacktrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
catch_stacktrace([c_funcs::Bool=false]) -> StackTrace
\end{lstlisting}

Returns the stack trace for the most recent error thrown, rather than the current execution context.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L171-L176}{\texttt{source}}


\end{adjustwidth}

Los siguientes métodos y tipos de \texttt{Base.StackTraces} no son exportados y, por tanto, deben ser prefijados en sus invocaciones. Por ejemplo, \texttt{StackTraces.lookup(ptr)}.


\hypertarget{1451426077045795515}{} 
\hyperlink{1451426077045795515}{\texttt{Base.StackTraces.lookup}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lookup(pointer::Union{Ptr{Void}, UInt}) -> Vector{StackFrame}
\end{lstlisting}

Given a pointer to an execution context (usually generated by a call to \texttt{backtrace}), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L117-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11320665145957459671}{} 
\hyperlink{11320665145957459671}{\texttt{Base.StackTraces.remove\_frames!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remove_frames!(stack::StackTrace, name::Symbol)
\end{lstlisting}

Takes a \texttt{StackTrace} (a vector of \texttt{StackFrames}) and a function name (a \texttt{Symbol}) and removes the \texttt{StackFrame} specified by the function name from the \texttt{StackTrace} (also removing all frames above the specified function). Primarily used to remove \texttt{StackTraces} functions from the \texttt{StackTrace} prior to returning it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L179-L186}{\texttt{source}}



\begin{lstlisting}
remove_frames!(stack::StackTrace, m::Module)
\end{lstlisting}

Returns the \texttt{StackTrace} with all \texttt{StackFrame}s from the provided \texttt{Module} removed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L197-L201}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13586267588072234536}{}


\chapter{Soporte SIMD}



El tipo \texttt{VecElement\{T\}} está pensado para construir librerías de operaciones SIMD operations. El uso práctico de él requiere usar \texttt{llvmcall}. El tipo está definido como:




\begin{minted}{julia}
struct VecElement{T}
    value::T
end
\end{minted}



Él tiene una regla de compilación especial: una tupla homogénea de \texttt{VecElement\{T\}} se corresponde con un tipo \texttt{vector} LLVM cuando \texttt{T} un tipo de bits primitivo y la longitud de la tupla está en el conjunto \{2-6,8-10,16\}.



En \texttt{-O3}, el compilador \emph{podría} automáticamente vectorizar operaciones sobre tales tuplas. Por ejemplo, el siguiente programa, cuando se compila con \texttt{julia -O3} genera dos instrucciones de adición SIMD (\texttt{addps}) sobre los sistemas x86:




\begin{minted}{julia}
const m128 = NTuple{4,VecElement{Float32}}

function add(a::m128, b::m128)
    (VecElement(a[1].value+b[1].value),
     VecElement(a[2].value+b[2].value),
     VecElement(a[3].value+b[3].value),
     VecElement(a[4].value+b[4].value))
end

triple(c::m128) = add(add(c,c),c)

code_native(triple,(m128,))
\end{minted}



Sin embargo, dado que no se puede confiar en la vectorización automática, el uso futuro se realizará principalmente a través de bibliotecas que usen \texttt{llvmcall}.



\part{Developer Documentation}


\hypertarget{6456620051738632536}{}


\chapter{Reflection and introspection}



Julia provides a variety of runtime reflection capabilities.



\hypertarget{17771187696170422072}{}


\section{Module bindings}



The exported names for a \texttt{Module} are available using \hyperlink{6473328671144201991}{\texttt{names(m::Module)}}, which will return an array of \hyperlink{18332791376992528422}{\texttt{Symbol}} elements representing the exported bindings. \texttt{names(m::Module, true)} returns symbols for all bindings in \texttt{m}, regardless of export status.



\hypertarget{14774754942140904122}{}


\section{DataType fields}



The names of \texttt{DataType} fields may be interrogated using \hyperlink{17481253338332315021}{\texttt{fieldnames()}}. For example, given the following type, \texttt{fieldnames(Point)} returns an arrays of \hyperlink{18332791376992528422}{\texttt{Symbol}} elements representing the field names:




\begin{lstlisting}
julia> struct Point
           x::Int
           y
       end

julia> fieldnames(Point)
2-element Array{Symbol,1}:
 :x
 :y
\end{lstlisting}



The type of each field in a \texttt{Point} object is stored in the \texttt{types} field of the \texttt{Point} variable itself:




\begin{lstlisting}
julia> Point.types
svec(Int64, Any)
\end{lstlisting}



While \texttt{x} is annotated as an \texttt{Int}, \texttt{y} was unannotated in the type definition, therefore \texttt{y} defaults to the \texttt{Any} type.



Types are themselves represented as a structure called \texttt{DataType}:




\begin{lstlisting}
julia> typeof(Point)
DataType
\end{lstlisting}



Note that \texttt{fieldnames(DataType)} gives the names for each field of \texttt{DataType} itself, and one of these fields is the \texttt{types} field observed in the example above.



\hypertarget{11371291537025953368}{}


\section{Subtypes}



The \emph{direct} subtypes of any \texttt{DataType} may be listed using \hyperlink{18325429904830593994}{\texttt{subtypes()}}. For example, the abstract \texttt{DataType} \hyperlink{11465394427882483091}{\texttt{AbstractFloat}} has four (concrete) subtypes:




\begin{minted}{jlcon}
julia> subtypes(AbstractFloat)
4-element Array{Union{DataType, UnionAll},1}:
 BigFloat
 Float16
 Float32
 Float64
\end{minted}



Any abstract subtype will also be included in this list, but further subtypes thereof will not; recursive application of \hyperlink{18325429904830593994}{\texttt{subtypes()}} may be used to inspect the full type tree.



\hypertarget{11957448814310282424}{}


\section{DataType layout}



The internal representation of a \texttt{DataType} is critically important when interfacing with C code and several functions are available to inspect these details. \hyperlink{12980593021531333073}{\texttt{isbits(T::DataType)}} returns true if \texttt{T} is stored with C-compatible alignment. \hyperlink{6956980533195055227}{\texttt{fieldoffset(T::DataType, i::Integer)}} returns the (byte) offset for field \emph{i} relative to the start of the type.



\hypertarget{9741782790992203943}{}


\section{Function methods}



The methods of any generic function may be listed using \hyperlink{3025953302266245919}{\texttt{methods()}}. The method dispatch table may be searched for methods accepting a given type using \hyperlink{12860964732831752396}{\texttt{methodswith()}}.



\hypertarget{10529563115945815287}{}


\section{Expansion and lowering}



As discussed in the \hyperlink{15444528597476882531}{Metaprogramming} section, the \hyperlink{8018172489611994488}{\texttt{macroexpand()}} function gives the unquoted and interpolated expression (\texttt{Expr}) form for a given macro. To use \texttt{macroexpand}, \texttt{quote} the expression block itself (otherwise, the macro will be evaluated and the result will be passed instead!). For example:




\begin{minted}{jlcon}
julia> macroexpand( :(@edit println("")) )
:((Base.edit)(println, (Base.typesof)("")))
\end{minted}



The functions \texttt{Base.Meta.show\_sexpr()} and \hyperlink{15981569052160951906}{\texttt{dump()}} are used to display S-expr style views and depth-nested detail views for any expression.



Finally, the \hyperlink{14846157655101111909}{\texttt{expand()}} function gives the \texttt{lowered} form of any expression and is of particular interest for understanding both macros and top-level statements such as function declarations and variable assignments:




\begin{minted}{jlcon}
julia> expand( :(f() = 1) )
:(begin
        $(Expr(:method, :f))
        $(Expr(:method, :f, :((Core.svec)((Core.svec)((Core.Typeof)(f)), (Core.svec)())), CodeInfo(:(begin  # none, line 1:
        return 1
    end)), false))
        return f
    end)
\end{minted}



\hypertarget{5101839880113461479}{}


\section{Intermediate and compiled representations}



Inspecting the lowered form for functions requires selection of the specific method to display, because generic functions may have many methods with different type signatures. For this purpose, method-specific code-lowering is available using \hyperlink{18235967286596219009}{\texttt{code\_lowered(f::Function, (Argtypes...))}}, and the type-inferred form is available using \hyperlink{14801595959157535515}{\texttt{code\_typed(f::Function, (Argtypes...))}}. \hyperlink{16883039507765569860}{\texttt{code\_warntype(f::Function, (Argtypes...))}} adds highlighting to the output of \hyperlink{14801595959157535515}{\texttt{code\_typed()}} (see \hyperlink{7509450972834198661}{\texttt{@code\_warntype}}).



Closer to the machine, the LLVM intermediate representation of a function may be printed using by \hyperlink{17587317969597936788}{\texttt{code\_llvm(f::Function, (Argtypes...))}}, and finally the compiled machine code is available using \hyperlink{1731537926898979255}{\texttt{code\_native(f::Function, (Argtypes...))}} (this will trigger JIT compilation/code generation for any function which has not previously been called).



For convenience, there are macro versions of the above functions which take standard function calls and expand argument types automatically:




\begin{minted}{jlcon}
julia> @code_llvm +(1,1)

; Function Attrs: sspreq
define i64 @"julia_+_130862"(i64, i64) #0 {
top:
    %2 = add i64 %1, %0, !dbg !8
    ret i64 %2, !dbg !8
}
\end{minted}



(likewise \texttt{@code\_typed}, \texttt{@code\_warntype}, \texttt{@code\_lowered}, and \texttt{@code\_native})



\chapter{Documentation of Julia's Internals}


\hypertarget{1567551262556259173}{}


\section{Initialization of the Julia runtime}



How does the Julia runtime execute \texttt{julia -e {\textquotesingle}println({\textquotedbl}Hello World!{\textquotedbl}){\textquotesingle}} ?



\hypertarget{6651980781302015874}{}


\subsection{main()}



Execution starts at \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{main()} in \texttt{ui/repl.c}}.



\texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/support/libsupportinit.c}{\texttt{libsupport\_init()}} to set the C library locale and to initialize the {\textquotedbl}ios{\textquotedbl} library (see \href{https://github.com/JuliaLang/julia/blob/master/src/support/ios.c}{\texttt{ios\_init\_stdstreams()}} and \hyperlink{15406109399506022628}{Legacy \texttt{ios.c} library}).



Next \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{parse\_opts()}} is called to process command line options. Note that \texttt{parse\_opts()} only deals with options that affect code generation or early initialization. Other options are handled later by \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{process\_options()} in \texttt{base/client.jl}}.



\texttt{parse\_opts()} stores command line options in the \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{global \texttt{jl\_options} struct}.



\hypertarget{10951200599627901176}{}


\subsection{julia\_init()}



\href{https://github.com/JuliaLang/julia/blob/master/src/task.c}{\texttt{julia\_init()} in \texttt{task.c}} is called by \texttt{main()} and calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{\_julia\_init()} in \texttt{init.c}}.



\texttt{\_julia\_init()} begins by calling \texttt{libsupport\_init()} again (it does nothing the second time).



\href{https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c}{\texttt{restore\_signals()}} is called to zero the signal handler mask.



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_resolve\_sysimg\_location()}} searches configured paths for the base system image. See \hyperlink{13880852207471486494}{Building the Julia system image}.



\href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{\texttt{jl\_gc\_init()}} sets up allocation pools and lists for weak refs, preserved values and finalization.



\href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_init\_frontend()}} loads and initializes a pre-compiled femtolisp image containing the scanner/parser.



\href{https://github.com/JuliaLang/julia/blob/master/src/jltypes.c}{\texttt{jl\_init\_types()}} creates \texttt{jl\_datatype\_t} type description objects for the \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{built-in types defined in \texttt{julia.h}}. e.g.




\begin{lstlisting}
jl_any_type = jl_new_abstracttype(jl_symbol("Any"), NULL, jl_null);
jl_any_type->super = jl_any_type;

jl_type_type = jl_new_abstracttype(jl_symbol("Type"), jl_any_type, jl_null);

jl_int32_type = jl_new_bitstype(jl_symbol("Int32"),
                                jl_any_type, jl_null, 32);
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/master/src/task.c}{\texttt{jl\_init\_tasks()}} creates the \texttt{jl\_datatype\_t* jl\_task\_type} object; initializes the global \texttt{jl\_root\_task} struct; and sets \texttt{jl\_current\_task} to the root task.



\href{https://github.com/JuliaLang/julia/blob/master/src/codegen.cpp}{\texttt{jl\_init\_codegen()}} initializes the \href{http://llvm.org}{LLVM library}.



\href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_init\_serializer()}} initializes 8-bit serialization tags for 256 frequently used \texttt{jl\_value\_t} values. The serialization mechanism uses these tags as shorthand (in lieu of storing whole objects) to save storage space.



If there is no sysimg file (\texttt{!jl\_options.image\_file}) then the \texttt{Core} and \texttt{Main} modules are created and \texttt{boot.jl} is evaluated:



\texttt{jl\_core\_module = jl\_new\_module(jl\_symbol({\textquotedbl}Core{\textquotedbl}))} creates the Julia \texttt{Core} module.



\href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{\texttt{jl\_init\_intrinsic\_functions()}} creates a new Julia module \texttt{Intrinsics} containing constant \texttt{jl\_intrinsic\_type} symbols. These define an integer code for each \href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{intrinsic function}. \href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{\texttt{emit\_intrinsic()}} translates these symbols into LLVM instructions during code generation.



\href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_init\_primitives()}} hooks C functions up to Julia function symbols. e.g. the symbol \texttt{Base.is()} is bound to C function pointer \texttt{jl\_f\_is()} by calling \texttt{add\_builtin\_func({\textquotedbl}eval{\textquotedbl}, jl\_f\_top\_eval)}.



\href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_new\_main\_module()}} creates the global {\textquotedbl}Main{\textquotedbl} module and sets \texttt{jl\_current\_task->current\_module = jl\_main\_module}.



Note: \texttt{\_julia\_init()} \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{then sets} \texttt{jl\_root\_task->current\_module = jl\_core\_module}. \texttt{jl\_root\_task} is an alias of \texttt{jl\_current\_task} at this point, so the \texttt{current\_module} set by \texttt{jl\_new\_main\_module()} above is overwritten.



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_load({\textquotedbl}boot.jl{\textquotedbl}, sizeof({\textquotedbl}boot.jl{\textquotedbl}))}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_parse\_eval\_all}} which repeatedly calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}} to execute \href{https://github.com/JuliaLang/julia/blob/master/base/boot.jl}{\texttt{boot.jl}}. <!– TODO – drill down into eval? –>



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_get\_builtin\_hooks()}} initializes global C pointers to Julia globals defined in \texttt{boot.jl}.



\href{https://github.com/JuliaLang/julia/blob/master/src/datatype.c}{\texttt{jl\_init\_box\_caches()}} pre-allocates global boxed integer value objects for values up to 1024. This speeds up allocation of boxed ints later on. e.g.:




\begin{lstlisting}
jl_value_t *jl_box_uint8(uint32_t x)
{
    return boxed_uint8_cache[(uint8_t)x];
}
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{\_julia\_init()} iterates} over the \texttt{jl\_core\_module->bindings.table} looking for \texttt{jl\_datatype\_t} values and sets the type name{\textquotesingle}s module prefix to \texttt{jl\_core\_module}.



\href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_add\_standard\_imports(jl\_main\_module)}} does {\textquotedbl}using Base{\textquotedbl} in the {\textquotedbl}Main{\textquotedbl} module.



Note: \texttt{\_julia\_init()} now reverts to \texttt{jl\_root\_task->current\_module = jl\_main\_module} as it was before being set to \texttt{jl\_core\_module} above.



Platform specific signal handlers are initialized for \texttt{SIGSEGV} (OSX, Linux), and \texttt{SIGFPE} (Windows).



Other signals (\texttt{SIGINFO, SIGBUS, SIGILL, SIGTERM, SIGABRT, SIGQUIT, SIGSYS} and \texttt{SIGPIPE}) are hooked up to \href{https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c}{\texttt{sigdie\_handler()}} which prints a backtrace.



\href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_init\_restored\_modules()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/module.c}{\texttt{jl\_module\_run\_initializer()}} for each deserialized module to run the \texttt{\_\_init\_\_()} function.



Finally \href{https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c}{\texttt{sigint\_handler()}} is hooked up to \texttt{SIGINT} and calls \texttt{jl\_throw(jl\_interrupt\_exception)}.



\texttt{\_julia\_init()} then returns \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{back to \texttt{main()} in \texttt{ui/repl.c}} and \texttt{main()} calls \texttt{true\_main(argc, (char**)argv)}.



\begin{quote}
\textbf{sysimg}

If there is a sysimg file, it contains a pre-cooked image of the \texttt{Core} and \texttt{Main} modules (and whatever else is created by \texttt{boot.jl}). See \hyperlink{13880852207471486494}{Building the Julia system image}.

\href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_restore\_system\_image()}} deserializes the saved sysimg into the current Julia runtime environment and initialization continues after \texttt{jl\_init\_box\_caches()} below...

Note: \href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_restore\_system\_image()} (and \texttt{dump.c} in general)} uses the \hyperlink{15406109399506022628}{Legacy \texttt{ios.c} library}.

\end{quote}


\hypertarget{8052465870854670365}{}


\subsection{true\_main()}



\href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{true\_main()}} loads the contents of \texttt{argv[]} into \hyperlink{2567473177880607455}{\texttt{Base.ARGS}}.



If a \texttt{.jl} {\textquotedbl}program{\textquotedbl} file was supplied on the command line, then \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{exec\_program()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_load(program,len)}} which calls \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_parse\_eval\_all}} which repeatedly calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}} to execute the program.



However, in our example (\texttt{julia -e {\textquotesingle}println({\textquotedbl}Hello World!{\textquotedbl}){\textquotesingle}}), \href{https://github.com/JuliaLang/julia/blob/master/src/module.c}{\texttt{jl\_get\_global(jl\_base\_module, jl\_symbol({\textquotedbl}\_start{\textquotedbl}))}} looks up \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.\_start}} and \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{\texttt{jl\_apply()}} executes it.



\hypertarget{12561163861893339364}{}


\subsection{Base.\_start}



\href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.\_start}} calls \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.process\_options}} which calls \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_parse\_input\_line({\textquotedbl}println({\textquotedbl}Hello World!{\textquotedbl}){\textquotedbl})}} to create an expression object and \hyperlink{2565512592221324751}{\texttt{Base.eval()}} to execute it.



\hypertarget{5161519074100035363}{}


\subsection{Base.eval}



\hyperlink{2565512592221324751}{\texttt{Base.eval()}} was \href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{mapped to \texttt{jl\_f\_top\_eval}} by \texttt{jl\_init\_primitives()}.



\href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_f\_top\_eval()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_toplevel\_eval\_in(jl\_main\_module, ex)}}, where \texttt{ex} is the parsed expression \texttt{println({\textquotedbl}Hello World!{\textquotedbl})}.



\href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_toplevel\_eval\_in()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}} which calls \href{https://github.com/JuliaLang/julia/blob/master/src/interpreter.c}{\texttt{eval()} in \texttt{interpreter.c}}.



The stack dump below shows how the interpreter works its way through various methods of \hyperlink{783803254548423222}{\texttt{Base.println()}} and \hyperlink{8248717042415202230}{\texttt{Base.print()}} before arriving at \href{https://github.com/JuliaLang/julia/blob/master/base/stream.jl}{\texttt{write(s::IO, a::Array\{T\}) where T}}  which does \texttt{ccall(jl\_uv\_write())}.



\href{https://github.com/JuliaLang/julia/blob/master/src/jl\_uv.c}{\texttt{jl\_uv\_write()}} calls \texttt{uv\_write()} to write {\textquotedbl}Hello World!{\textquotedbl} to \texttt{JL\_STDOUT}. See \hyperlink{11306377068338291950}{Libuv wrappers for stdio}.:




\begin{lstlisting}
Hello World!
\end{lstlisting}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Stack frame & Source code & Notes \\
\hline
\texttt{jl\_uv\_write()} & \texttt{jl\_uv.c} & called though \hyperlink{14245046751182637566}{\texttt{ccall}} \\
\hline
\texttt{julia\_write\_282942} & \texttt{stream.jl} & function \texttt{write!(s::IO, a::Array\{T\}) where T} \\
\hline
\texttt{julia\_print\_284639} & \texttt{ascii.jl} & \texttt{print(io::IO, s::String) = (write(io, s); nothing)} \\
\hline
\texttt{jlcall\_print\_284639} &   &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.print(Base.TTY, String)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.print(Base.TTY, String, Char, Char...)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_f\_apply()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.println(Base.TTY, String, String...)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.println(String,)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{do\_call()} & \texttt{interpreter.c} &   \\
\hline
\texttt{eval()} & \texttt{interpreter.c} &   \\
\hline
\texttt{jl\_interpret\_toplevel\_expr()} & \texttt{interpreter.c} &   \\
\hline
\texttt{jl\_toplevel\_eval\_flex()} & \texttt{toplevel.c} &   \\
\hline
\texttt{jl\_toplevel\_eval()} & \texttt{toplevel.c} &   \\
\hline
\texttt{jl\_toplevel\_eval\_in()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_f\_top\_eval()} & \texttt{builtins.c} &   \\
\hline
\end{tabulary}

\end{table}



Since our example has just one function call, which has done its job of printing {\textquotedbl}Hello World!{\textquotedbl}, the stack now rapidly unwinds back to \texttt{main()}.



\hypertarget{8766302654766843311}{}


\subsection{jl\_atexit\_hook()}



\texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_atexit\_hook()}}. This calls \texttt{\_atexit} for each module, then calls \href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{\texttt{jl\_gc\_run\_all\_finalizers()}} and cleans up libuv handles.



\hypertarget{6367994784846959684}{}


\subsection{julia\_save()}



Finally, \texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{julia\_save()}}, which if requested on the command line, saves the runtime state to a new system image. See \href{https://github.com/JuliaLang/julia/blob/master/src/gf.c}{\texttt{jl\_compile\_all()}} and \href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_save\_system\_image()}}.



\hypertarget{92289363194562983}{}


\section{Julia ASTs}



Julia has two representations of code. First there is a surface syntax AST returned by the parser (e.g. the \hyperlink{13108503824143481717}{\texttt{parse()}} function), and manipulated by macros. It is a structured representation of code as it is written, constructed by \texttt{julia-parser.scm} from a character stream. Next there is a lowered form, or IR (intermediate representation), which is used by type inference and code generation. In the lowered form there are fewer types of nodes, all macros are expanded, and all control flow is converted to explicit branches and sequences of statements. The lowered form is constructed by \texttt{julia-syntax.scm}.



First we will focus on the lowered form, since it is more important to the compiler. It is also less obvious to the human, since it results from a significant rearrangement of the input syntax.



\hypertarget{16818744617880081407}{}


\subsection{Lowered form}



The following data types exist in lowered form:



\begin{itemize}
\item \texttt{Expr}

Has a node type indicated by the \texttt{head} field, and an \texttt{args} field which is a \texttt{Vector\{Any\}} of subexpressions.


\item \texttt{Slot}

Identifies arguments and local variables by consecutive numbering. \texttt{Slot} is an abstract type with subtypes \texttt{SlotNumber} and \texttt{TypedSlot}. Both types have an integer-valued \texttt{id} field giving the slot index. Most slots have the same type at all uses, and so are represented with \texttt{SlotNumber}. The types of these slots are found in the \texttt{slottypes} field of their \texttt{MethodInstance} object. Slots that require per-use type annotations are represented with \texttt{TypedSlot}, which has a \texttt{typ} field.


\item \texttt{CodeInfo}

Wraps the IR of a method.


\item \texttt{LineNumberNode}

Contains a single number, specifying the line number the next statement came from.


\item \texttt{LabelNode}

Branch target, a consecutively-numbered integer starting at 0.


\item \texttt{GotoNode}

Unconditional branch.


\item \texttt{QuoteNode}

Wraps an arbitrary value to reference as data. For example, the function \texttt{f() = :a} contains a \texttt{QuoteNode} whose \texttt{value} field is the symbol \texttt{a}, in order to return the symbol itself instead of evaluating it.


\item \texttt{GlobalRef}

Refers to global variable \texttt{name} in module \texttt{mod}.


\item \texttt{SSAValue}

Refers to a consecutively-numbered (starting at 0) static single assignment (SSA) variable inserted by the compiler.


\item \texttt{NewvarNode}

Marks a point where a variable is created. This has the effect of resetting a variable to undefined.

\end{itemize}


\hypertarget{15302433068188215381}{}


\subsubsection{Expr types}



These symbols appear in the \texttt{head} field of \texttt{Expr}s in lowered form.



\begin{itemize}
\item \texttt{call}

Function call (dynamic dispatch). \texttt{args[1]} is the function to call, \texttt{args[2:end]} are the arguments.


\item \texttt{invoke}

Function call (static dispatch). \texttt{args[1]} is the MethodInstance to call, \texttt{args[2:end]} are the arguments (including the function that is being called, at \texttt{args[2]}).


\item \texttt{static\_parameter}

Reference a static parameter by index.


\item \texttt{line}

Line number and file name metadata. Unlike a \texttt{LineNumberNode}, can also contain a file name.


\item \texttt{gotoifnot}

Conditional branch. If \texttt{args[1]} is false, goes to label identified in \texttt{args[2]}.


\item \texttt{=}

Assignment.


\item \texttt{method}

Adds a method to a generic function and assigns the result if necessary.

Has a 1-argument form and a 4-argument form. The 1-argument form arises from the syntax \texttt{function foo end}. In the 1-argument form, the argument is a symbol. If this symbol already names a function in the current scope, nothing happens. If the symbol is undefined, a new function is created and assigned to the identifier specified by the symbol. If the symbol is defined but names a non-function, an error is raised. The definition of {\textquotedbl}names a function{\textquotedbl} is that the binding is constant, and refers to an object of singleton type. The rationale for this is that an instance of a singleton type uniquely identifies the type to add the method to. When the type has fields, it wouldn{\textquotesingle}t be clear whether the method was being added to the instance or its type.

The 4-argument form has the following arguments:

\begin{itemize}
\item \texttt{args[1]}

A function name, or \texttt{false} if unknown. If a symbol, then the expression first behaves like the 1-argument form above. This argument is ignored from then on. When this is \texttt{false}, it means a method is being added strictly by type, \texttt{(::T)(x) = x}.


\item \texttt{args[2]}

A \texttt{SimpleVector} of argument type data. \texttt{args[2][1]} is a \texttt{SimpleVector} of the argument types, and \texttt{args[2][2]} is a \texttt{SimpleVector} of type variables corresponding to the method{\textquotesingle}s static parameters.


\item \texttt{args[3]}

A \texttt{CodeInfo} of the method itself. For {\textquotedbl}out of scope{\textquotedbl} method definitions (adding a method to a function that also has methods defined in different scopes) this is an expression that evaluates to a \texttt{:lambda} expression.


\item \texttt{args[4]}

\texttt{true} or \texttt{false}, identifying whether the method is staged (\texttt{@generated function}).

\end{itemize}

\item \texttt{const}

Declares a (global) variable as constant.


\item \texttt{null}

Has no arguments; simply yields the value \texttt{nothing}.


\item \texttt{new}

Allocates a new struct-like object. First argument is the type. The \texttt{new} pseudo-function is lowered to this, and the type is always inserted by the compiler.  This is very much an internal-only feature, and does no checking. Evaluating arbitrary \texttt{new} expressions can easily segfault.


\item \texttt{return}

Returns its argument as the value of the enclosing function.


\item \texttt{the\_exception}

Yields the caught exception inside a \texttt{catch} block. This is the value of the run time system variable \texttt{jl\_exception\_in\_transit}.


\item \texttt{enter}

Enters an exception handler (\texttt{setjmp}). \texttt{args[1]} is the label of the catch block to jump to on error.


\item \texttt{leave}

Pop exception handlers. \texttt{args[1]} is the number of handlers to pop.


\item \texttt{inbounds}

Controls turning bounds checks on or off. A stack is maintained; if the first argument of this expression is true or false (\texttt{true} means bounds checks are disabled), it is pushed onto the stack. If the first argument is \texttt{:pop}, the stack is popped.


\item \texttt{boundscheck}

Indicates the beginning or end of a section of code that performs a bounds check. Like \texttt{inbounds}, a stack is maintained, and the second argument can be one of: \texttt{true}, \texttt{false}, or \texttt{:pop}.


\item \texttt{copyast}

Part of the implementation of quasi-quote. The argument is a surface syntax AST that is simply copied recursively and returned at run time.


\item \texttt{meta}

Metadata. \texttt{args[1]} is typically a symbol specifying the kind of metadata, and the rest of the arguments are free-form. The following kinds of metadata are commonly used:

\begin{itemize}
\item \texttt{:inline} and \texttt{:noinline}: Inlining hints.


\item \texttt{:push\_loc}: enters a sequence of statements from a specified source location.

\begin{itemize}
\item \texttt{args[2]} specifies a filename, as a symbol.


\item \texttt{args[3]} optionally specifies the name of an (inlined) function that originally contained the code.

\end{itemize}

\item \texttt{:pop\_loc}: returns to the source location before the matching \texttt{:push\_loc}.

\end{itemize}
\end{itemize}


\hypertarget{11059186909242156655}{}


\subsubsection{Method}



A unique{\textquotesingle}d container describing the shared metadata for a single method.



\begin{itemize}
\item \texttt{name}, \texttt{module}, \texttt{file}, \texttt{line}, \texttt{sig}

Metadata to uniquely identify the method for the computer and the human.


\item \texttt{ambig}

Cache of other methods that may be ambiguous with this one.


\item \texttt{specializations}

Cache of all MethodInstance ever created for this Method, used to ensure uniqueness. Uniqueness is required for efficiency, especially for incremental precompile and tracking of method invalidation.


\item \texttt{source}

The original source code (usually compressed).


\item \texttt{roots}

Pointers to non-AST things that have been interpolated into the AST, required by compression of the AST, type-inference, or the generation of native code.


\item \texttt{nargs}, \texttt{isva}, \texttt{called}, \texttt{isstaged}, \texttt{pure}

Descriptive bit-fields for the source code of this Method.


\item \texttt{min\_world} / \texttt{max\_world}

The range of world ages for which this method is visible to dispatch.

\end{itemize}


\hypertarget{2584833319372808594}{}


\subsubsection{MethodInstance}



A unique{\textquotesingle}d container describing a single callable signature for a Method. See especially \hyperlink{16029610522337323518}{Proper maintenance and care of multi-threading locks} for important details on how to modify these fields safely.



\begin{itemize}
\item \texttt{specTypes}

The primary key for this MethodInstance. Uniqueness is guaranteed through a \texttt{def.specializations} lookup.


\item \texttt{def}

The \texttt{Method} that this function describes a specialization of. Or \texttt{\#undef}, if this is a top-level Lambda that is not part of a Method.


\item \texttt{sparam\_vals}

The values of the static parameters in \texttt{specTypes} indexed by \texttt{def.sparam\_syms}. For the \texttt{MethodInstance} at \texttt{Method.unspecialized}, this is the empty \texttt{SimpleVector}. But for a runtime \texttt{MethodInstance} from the \texttt{MethodTable} cache, this will always be defined and indexable.


\item \texttt{rettype}

The inferred return type for the \texttt{specFunctionObject} field, which (in most cases) is also the computed return type for the function in general.


\item \texttt{inferred}

May contain a cache of the inferred source for this function, or other information about the inference result such as a constant return value may be put here (if \texttt{jlcall\_api == 2}), or it could be set to \texttt{nothing} to just indicate \texttt{rettype} is inferred.


\item \texttt{ftpr}

The generic jlcall entry point.


\item \texttt{jlcall\_api}

The ABI to use when calling \texttt{fptr}. Some significant ones include:

\begin{itemize}
\item 0 - Not compiled yet


\item 1 - JL\_CALLABLE \texttt{jl\_value\_t *(*)(jl\_function\_t *f, jl\_value\_t *args[nargs], uint32\_t nargs)}


\item 2 - Constant (value stored in \texttt{inferred})


\item 3 - With Static-parameters forwarded \texttt{jl\_value\_t *(*)(jl\_svec\_t *sparams, jl\_function\_t *f, jl\_value\_t *args[nargs], uint32\_t nargs)}


\item 4 - Run in interpreter \texttt{jl\_value\_t *(*)(jl\_method\_instance\_t *meth, jl\_function\_t *f, jl\_value\_t *args[nargs], uint32\_t nargs)}

\end{itemize}

\item \texttt{min\_world} / \texttt{max\_world}

The range of world ages for which this method instance is valid to be called.

\end{itemize}


\hypertarget{15595975163128328315}{}


\subsubsection{CodeInfo}



A temporary container for holding lowered source code.



\begin{itemize}
\item \texttt{code}

An \texttt{Any} array of statements


\item \texttt{slotnames}

An array of symbols giving the name of each slot (argument or local variable).


\item \texttt{slottypes}

An array of types for the slots.


\item \texttt{slotflags}

A \texttt{UInt8} array of slot properties, represented as bit flags:

\begin{itemize}
\item 2  - assigned (only false if there are \emph{no} assignment statements with this var on the left)


\item 8  - const (currently unused for local variables)


\item 16 - statically assigned once


\item 32 - might be used before assigned. This flag is only valid after type inference.

\end{itemize}

\item \texttt{ssavaluetypes}

Either an array or an \texttt{Int}.

If an \texttt{Int}, it gives the number of compiler-inserted temporary locations in the function. If an array, specifies a type for each location.

\end{itemize}


Boolean properties:



\begin{itemize}
\item \texttt{inferred}

Whether this has been produced by type inference.


\item \texttt{inlineable}

Whether this should be inlined.


\item \texttt{propagate\_inbounds}

Whether this should should propagate \texttt{@inbounds} when inlined for the purpose of eliding \texttt{@boundscheck} blocks.


\item \texttt{pure}

Whether this is known to be a pure function of its arguments, without respect to the state of the method caches or other mutable global state.

\end{itemize}


\hypertarget{6198433338459689204}{}


\subsection{Surface syntax AST}



Front end ASTs consist entirely of \texttt{Expr}s and atoms (e.g. symbols, numbers). There is generally a different expression head for each visually distinct syntactic form. Examples will be given in s-expression syntax. Each parenthesized list corresponds to an Expr, where the first element is the head. For example \texttt{(call f x)} corresponds to \texttt{Expr(:call, :f, :x)} in Julia.



\hypertarget{13191950853363974893}{}


\subsubsection{Calls}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{f(x)} & \texttt{(call f x)} \\
\hline
\texttt{f(x, y=1, z=2)} & \texttt{(call f x (kw y 1) (kw z 2))} \\
\hline
\texttt{f(x; y=1)} & \texttt{(call f (parameters (kw y 1)) x)} \\
\hline
\texttt{f(x...)} & \texttt{(call f (... x))} \\
\hline
\end{tabulary}

\end{table}



\texttt{do} syntax:




\begin{minted}{julia}
f(x) do a,b
    body
end
\end{minted}



parses as \texttt{(call f (-> (tuple a b) (block body)) x)}.



\hypertarget{16991843071018324380}{}


\subsubsection{Operators}



Most uses of operators are just function calls, so they are parsed with the head \texttt{call}. However some operators are special forms (not necessarily function calls), and in those cases the operator itself is the expression head. In julia-parser.scm these are referred to as {\textquotedbl}syntactic operators{\textquotedbl}. Some operators (\texttt{+} and \texttt{*}) use N-ary parsing; chained calls are parsed as a single N-argument call. Finally, chains of comparisons have their own special expression structure.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{x+y} & \texttt{(call + x y)} \\
\hline
\texttt{a+b+c+d} & \texttt{(call + a b c d)} \\
\hline
\texttt{2x} & \texttt{(call * 2 x)} \\
\hline
\texttt{a\&\&b} & \texttt{(\&\& a b)} \\
\hline
\texttt{x += 1} & \texttt{(+= x 1)} \\
\hline
\texttt{a ? 1 : 2} & \texttt{(if a 1 2)} \\
\hline
\texttt{a:b} & \texttt{(: a b)} \\
\hline
\texttt{a:b:c} & \texttt{(: a b c)} \\
\hline
\texttt{a,b} & \texttt{(tuple a b)} \\
\hline
\texttt{a==b} & \texttt{(call == a b)} \\
\hline
\texttt{1<i<=n} & \texttt{(comparison 1 < i <= n)} \\
\hline
\texttt{a.b} & \texttt{(. a (quote b))} \\
\hline
\texttt{a.(b)} & \texttt{(. a b)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{15884526073773577025}{}


\subsubsection{Bracketed forms}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{a[i]} & \texttt{(ref a i)} \\
\hline
\texttt{t[i;j]} & \texttt{(typed\_vcat t i j)} \\
\hline
\texttt{t[i j]} & \texttt{(typed\_hcat t i j)} \\
\hline
\texttt{t[a b; c d]} & \texttt{(typed\_vcat t (row a b) (row c d))} \\
\hline
\texttt{a\{b\}} & \texttt{(curly a b)} \\
\hline
\texttt{a\{b;c\}} & \texttt{(curly a (parameters c) b)} \\
\hline
\texttt{[x]} & \texttt{(vect x)} \\
\hline
\texttt{[x,y]} & \texttt{(vect x y)} \\
\hline
\texttt{[x;y]} & \texttt{(vcat x y)} \\
\hline
\texttt{[x y]} & \texttt{(hcat x y)} \\
\hline
\texttt{[x y; z t]} & \texttt{(vcat (row x y) (row z t))} \\
\hline
\texttt{[x for y in z, a in b]} & \texttt{(comprehension x (= y z) (= a b))} \\
\hline
\texttt{T[x for y in z]} & \texttt{(typed\_comprehension T x (= y z))} \\
\hline
\texttt{(a, b, c)} & \texttt{(tuple a b c)} \\
\hline
\texttt{(a; b; c)} & \texttt{(block a (block b c))} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{7735912728489467540}{}


\subsubsection{Macros}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{@m x y} & \texttt{(macrocall @m x y)} \\
\hline
\texttt{Base.@m x y} & \texttt{(macrocall (. Base (quote @m)) x y)} \\
\hline
\texttt{@Base.m x y} & \texttt{(macrocall (. Base (quote @m)) x y)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{5278796056388981234}{}


\subsubsection{Strings}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{{\textquotedbl}a{\textquotedbl}} & \texttt{{\textquotedbl}a{\textquotedbl}} \\
\hline
\texttt{x{\textquotedbl}y{\textquotedbl}} & \texttt{(macrocall @x\_str {\textquotedbl}y{\textquotedbl})} \\
\hline
\texttt{x{\textquotedbl}y{\textquotedbl}z} & \texttt{(macrocall @x\_str {\textquotedbl}y{\textquotedbl} {\textquotedbl}z{\textquotedbl})} \\
\hline
\texttt{{\textquotedbl}x = \$x{\textquotedbl}} & \texttt{(string {\textquotedbl}x = {\textquotedbl} x)} \\
\hline
\texttt{`a b c`} & \texttt{(macrocall @cmd {\textquotedbl}a b c{\textquotedbl})} \\
\hline
\end{tabulary}

\end{table}



Doc string syntax:




\begin{minted}{julia}
"some docs"
f(x) = x
\end{minted}



parses as \texttt{(macrocall (|.| Core {\textquotesingle}@doc) {\textquotedbl}some docs{\textquotedbl} (= (call f x) (block x)))}.



\hypertarget{13863161852089184826}{}


\subsubsection{Imports and such}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{import a} & \texttt{(import a)} \\
\hline
\texttt{import a.b.c} & \texttt{(import a b c)} \\
\hline
\texttt{import ...a} & \texttt{(import . . . a)} \\
\hline
\texttt{import a.b, c.d} & \texttt{(toplevel (import a b) (import c d))} \\
\hline
\texttt{import Base: x} & \texttt{(import Base x)} \\
\hline
\texttt{import Base: x, y} & \texttt{(toplevel (import Base x) (import Base y))} \\
\hline
\texttt{export a, b} & \texttt{(export a b)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{13439801024488074381}{}


\subsubsection{Numbers}



Julia supports more number types than many scheme implementations, so not all numbers are represented directly as scheme numbers in the AST.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{11111111111111111111} & \texttt{(macrocall @int128\_str {\textquotedbl}11111111111111111111{\textquotedbl})} \\
\hline
\texttt{0xfffffffffffffffff} & \texttt{(macrocall @uint128\_str {\textquotedbl}0xfffffffffffffffff{\textquotedbl})} \\
\hline
\texttt{1111...many digits...} & \texttt{(macrocall @big\_str {\textquotedbl}1111....{\textquotedbl})} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12573206411049142153}{}


\subsubsection{Block forms}



A block of statements is parsed as \texttt{(block stmt1 stmt2 ...)}.



If statement:




\begin{minted}{julia}
if a
    b
elseif c
    d
else e
    f
end
\end{minted}



parses as:




\begin{lstlisting}
(if a (block (line 2) b)
    (block (line 3) (if c (block (line 4) d)
                        (block (line 5) e (line 6) f))))
\end{lstlisting}



A \texttt{while} loop parses as \texttt{(while condition body)}.



A \texttt{for} loop parses as \texttt{(for (= var iter) body)}. If there is more than one iteration specification, they are parsed as a block: \texttt{(for (block (= v1 iter1) (= v2 iter2)) body)}.



\texttt{break} and \texttt{continue} are parsed as 0-argument expressions \texttt{(break)} and \texttt{(continue)}.



\texttt{let} is parsed as \texttt{(let body (= var1 val1) (= var2 val2) ...)}.



A basic function definition is parsed as \texttt{(function (call f x) body)}. A more complex example:




\begin{minted}{julia}
function f{T}(x::T; k = 1)
    return x+1
end
\end{minted}



parses as:




\begin{lstlisting}
(function (call (curly f T) (parameters (kw k 1))
                (:: x T))
          (block (line 2 file.jl) (return (call + x 1))))
\end{lstlisting}



Type definition:




\begin{minted}{julia}
mutable struct Foo{T<:S}
    x::T
end
\end{minted}



parses as:




\begin{lstlisting}
(type #t (curly Foo (<: T S))
      (block (line 2 none) (:: x T)))
\end{lstlisting}



The first argument is a boolean telling whether the type is mutable.



\texttt{try} blocks parse as \texttt{(try try\_block var catch\_block finally\_block)}. If no variable is present after \texttt{catch}, \texttt{var} is \texttt{\#f}. If there is no \texttt{finally} clause, then the last argument is not present.



\hypertarget{7872161424372847354}{}


\section{Más sobre tipos}



Si ha usado Julia durante un tiempo, comprenderá el papel fundamental que juegan los tipos. Aquí intentamos meternos debajo del capó, centrándonos fundamentalmente en los \hyperlink{15542027490314302254}{Tipos Paramétricos}.



\hypertarget{13235606386613972466}{}


\subsection{Tipos y conjuntos (y \texttt{Any} y \texttt{Union\{\}}/\texttt{Bottom})}



Tal vez sea ms sencillo concebir el sistema de tipos de Julia en términos de conjuntos. Aunque los programas pueden manipular los valores individuales, un tipo se refiere a un conjunto de valores. Esto no es la misma cosa que una colección; por ejemplo, un \texttt{Set} de valores es en sí mismo un solo valor de tipo \texttt{Set}. En lugar de ello, un tipo describe un conjunto de  \emph{posible} valores, expresando incertidumbre sobre qué valor tenemos.



Un tipo \emph{concreto} \texttt{T} describe el conjunto de valores cuya etiqueta directa, tal y como es obtenida por la función \texttt{typeof} es \texttt{T}. Un tipo \emph{abstracto} describe un conjunto de valores posiblemente más grande.



\texttt{Any} describe el universo completo de valores posibles. \hyperlink{8469131683393450448}{\texttt{Integer}} es un subconjunto de \texttt{Any} que incluye \texttt{Int}, \hyperlink{5857518405103968275}{\texttt{Int8}}, y otros tipos concretos. Internamente, Julia también hace un uso intensivo de otro tipo conocido como  \texttt{Bottom}, que puede también ser escrito como \texttt{Union\{\}}. Esto corresponde al conjunto vacío.



Los tipos de Julia soportan las operaciones estándar de la teora de conjuntos: uno puede preguntar si \texttt{T1} es un {\textquotedbl}subconjunto{\textquotedbl} de \texttt{T2} con \texttt{T1 <: T2}. Análogamente, uno intersecta dos tipos usando \texttt{typeintersect}, realiza su unión con \texttt{Union}, y calcula un tipo que contiene su unión con \texttt{typejoin}:




\begin{minted}{jlcon}
julia> typeintersect(Int, Float64)
Union{}

julia> Union{Int, Float64}
Union{Float64, Int64}

julia> typejoin(Int, Float64)
Real

julia> typeintersect(Signed, Union{UInt8, Int8})
Int8

julia> Union{Signed, Union{UInt8, Int8}}
Union{Signed, UInt8}

julia> typejoin(Signed, Union{UInt8, Int8})
Integer

julia> typeintersect(Tuple{Integer,Float64}, Tuple{Int,Real})
Tuple{Int64,Float64}

julia> Union{Tuple{Integer,Float64}, Tuple{Int,Real}}
Union{Tuple{Int64,Real}, Tuple{Integer,Float64}}

julia> typejoin(Tuple{Integer,Float64}, Tuple{Int,Real})
Tuple{Integer,Real}
\end{minted}



While these operations may seem abstract, they lie at the heart of Julia.  For example, method dispatch is implemented by stepping through the items in a method list until reaching one for which the type of the argument tuple is a subtype of the method signature. For this algorithm to work, it{\textquotesingle}s important that methods be sorted by their specificity, and that the search begins with the most specific methods. Consequently, Julia also implements a partial order on types; this is achieved by functionality that is similar to \texttt{<:}, but with differences that will be discussed below.



\hypertarget{11911810306869937851}{}


\subsection{UnionAll types}



Julia{\textquotesingle}s type system can also express an \emph{iterated union} of types: a union of types over all values of some variable. This is needed to describe parametric types where the values of some parameters are not known.



For example, :obj:\texttt{Array} has two parameters as in \texttt{Array\{Int,2\}}. If we did not know the element type, we could write \texttt{Array\{T,2\} where T}, which is the union of \texttt{Array\{T,2\}} for all values of \texttt{T}: \texttt{Union\{Array\{Int8,2\}, Array\{Int16,2\}, ...\}}.



Such a type is represented by a \texttt{UnionAll} object, which contains a variable (\texttt{T} in this example, of type \texttt{TypeVar}), and a wrapped type (\texttt{Array\{T,2\}} in this example).



Consider the following methods:




\begin{minted}{julia}
f1(A::Array) = 1
f2(A::Array{Int}) = 2
f3(A::Array{T}) where {T<:Any} = 3
f4(A::Array{Any}) = 4
\end{minted}



The signature of \texttt{f3} is a \texttt{UnionAll} type wrapping a tuple type. All but \texttt{f4} can be called with \texttt{a = [1,2]}; all but \texttt{f2} can be called with \texttt{b = Any[1,2]}.



Let{\textquotesingle}s look at these types a little more closely:




\begin{minted}{jlcon}
julia> dump(Array)
UnionAll
  var: TypeVar
    name: Symbol T
    lb: Core.TypeofBottom Union{}
    ub: Any
  body: UnionAll
    var: TypeVar
      name: Symbol N
      lb: Core.TypeofBottom Union{}
      ub: Any
    body: Array{T,N} <: DenseArray{T,N}
\end{minted}



This indicates that \texttt{Array} actually names a \texttt{UnionAll} type. There is one \texttt{UnionAll} type for each parameter, nested. The syntax \texttt{Array\{Int,2\}} is equivalent to \texttt{Array\{Int\}\{2\}}; internally each \texttt{UnionAll} is instantiated with a particular variable value, one at a time, outermost-first. This gives a natural meaning to the omission of trailing type parameters; \texttt{Array\{Int\}} gives a type equivalent to \texttt{Array\{Int,N\} where N}.



A \texttt{TypeVar} is not itself a type, but rather should be considered part of the structure of a \texttt{UnionAll} type. Type variables have lower and upper bounds on their values (in the fields \texttt{lb} and \texttt{ub}). The symbol \texttt{name} is purely cosmetic. Internally, \texttt{TypeVar}s are compared by address, so they are defined as mutable types to ensure that {\textquotedbl}different{\textquotedbl} type variables can be distinguished. However, by convention they should not be mutated.



One can construct \texttt{TypeVar}s manually:




\begin{minted}{jlcon}
julia> TypeVar(:V, Signed, Real)
Signed<:V<:Real
\end{minted}



There are convenience versions that allow you to omit any of these arguments except the \texttt{name} symbol.



The syntax \texttt{Array\{T\} where T<:Integer} is lowered to




\begin{minted}{julia}
let T = TypeVar(:T,Integer)
    UnionAll(T, Array{T})
end
\end{minted}



so it is seldom necessary to construct a \texttt{TypeVar} manually (indeed, this is to be avoided).



\hypertarget{10862279169779752699}{}


\subsection{Free variables}



The concept of a \emph{free} type variable is extremely important in the type system. We say that a variable \texttt{V} is free in type \texttt{T} if \texttt{T} does not contain the \texttt{UnionAll} that introduces variable \texttt{V}. For example, the type \texttt{Array\{Array\{V\} where V<:Integer\}} has no free variables, but the \texttt{Array\{V\}} part inside of it does have a free variable, \texttt{V}.



A type with free variables is, in some sense, not really a type at all. Consider the type \texttt{Array\{Array\{T\}\} where T}, which refers to all homogeneous arrays of arrays. The inner type \texttt{Array\{T\}}, seen by itself, might seem to refer to any kind of array. However, every element of the outer array must have the \emph{same} array type, so \texttt{Array\{T\}} cannot refer to just any old array. One could say that \texttt{Array\{T\}} effectively {\textquotedbl}occurs{\textquotedbl} multiple times, and \texttt{T} must have the same value each {\textquotedbl}time{\textquotedbl}.



For this reason, the function \texttt{jl\_has\_free\_typevars} in the C API is very important. Types for which it returns true will not give meaningful answers in subtyping and other type functions.



\hypertarget{9475610527503799038}{}


\subsection{TypeNames}



The following two \hyperlink{15492651498431872487}{\texttt{Array}} types are functionally equivalent, yet print differently:




\begin{minted}{jlcon}
julia> TV, NV = TypeVar(:T), TypeVar(:N)
(T, N)

julia> Array
Array

julia> Array{TV,NV}
Array{T,N}
\end{minted}



These can be distinguished by examining the \texttt{name} field of the type, which is an object of type \texttt{TypeName}:




\begin{minted}{jlcon}
julia> dump(Array{Int,1}.name)
TypeName
  name: Symbol Array
  module: Module Core
  names: empty SimpleVector
  wrapper: UnionAll
    var: TypeVar
      name: Symbol T
      lb: Core.TypeofBottom Union{}
      ub: Any
    body: UnionAll
      var: TypeVar
        name: Symbol N
        lb: Core.TypeofBottom Union{}
        ub: Any
      body: Array{T,N} <: DenseArray{T,N}
  cache: SimpleVector
    ...

  linearcache: SimpleVector
    ...

  hash: Int64 -7900426068641098781
  mt: MethodTable
    name: Symbol Array
    defs: Void nothing
    cache: Void nothing
    max_args: Int64 0
    kwsorter: #undef
    module: Module Core
    : Int64 0
    : Int64 0
\end{minted}



In this case, the relevant field is \texttt{wrapper}, which holds a reference to the top-level type used to make new \texttt{Array} types.




\begin{minted}{jlcon}
julia> pointer_from_objref(Array)
Ptr{Void} @0x00007fcc7de64850

julia> pointer_from_objref(Array.body.body.name.wrapper)
Ptr{Void} @0x00007fcc7de64850

julia> pointer_from_objref(Array{TV,NV})
Ptr{Void} @0x00007fcc80c4d930

julia> pointer_from_objref(Array{TV,NV}.name.wrapper)
Ptr{Void} @0x00007fcc7de64850
\end{minted}



The \texttt{wrapper} field of \hyperlink{15492651498431872487}{\texttt{Array}} points to itself, but for \texttt{Array\{TV,NV\}} it points back to the original definition of the type.



What about the other fields? \texttt{hash} assigns an integer to each type.  To examine the \texttt{cache} field, it{\textquotesingle}s helpful to pick a type that is less heavily used than Array. Let{\textquotesingle}s first create our own type:




\begin{minted}{jlcon}
julia> struct MyType{T,N} end

julia> MyType{Int,2}
MyType{Int64,2}

julia> MyType{Float32, 5}
MyType{Float32,5}

julia> MyType.body.body.name.cache
svec(MyType{Float32,5}, MyType{Int64,2}, #undef, #undef, #undef, #undef, #undef, #undef)
\end{minted}



(The cache is pre-allocated to have length 8, but only the first two entries are populated.) Consequently, when you instantiate a parametric type, each concrete type gets saved in a type cache.  However, instances containing free type variables are not cached.



\hypertarget{15137612054834825471}{}


\subsection{Tuple types}



Tuple types constitute an interesting special case.  For dispatch to work on declarations like \texttt{x::Tuple}, the type has to be able to accommodate any tuple.  Let{\textquotesingle}s check the parameters:




\begin{minted}{jlcon}
julia> Tuple
Tuple

julia> Tuple.parameters
svec(Vararg{Any,N} where N)
\end{minted}



Unlike other types, tuple types are covariant in their parameters, so this definition permits \texttt{Tuple} to match any type of tuple:




\begin{minted}{jlcon}
julia> typeintersect(Tuple, Tuple{Int,Float64})
Tuple{Int64,Float64}

julia> typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})
Tuple{Int64,Float64}
\end{minted}



However, if a variadic (\texttt{Vararg}) tuple type has free variables it can describe different kinds of tuples:




\begin{minted}{jlcon}
julia> typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})
Tuple{Int64,Float64}

julia> typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})
Union{}
\end{minted}



Notice that when \texttt{T} is free with respect to the \texttt{Tuple} type (i.e. its binding \texttt{UnionAll} type is outside the \texttt{Tuple} type), only one \texttt{T} value must work over the whole type. Therefore a heterogeneous tuple does not match.



Finally, it{\textquotesingle}s worth noting that \texttt{Tuple\{\}} is distinct:




\begin{minted}{jlcon}
julia> Tuple{}
Tuple{}

julia> Tuple{}.parameters
svec()

julia> typeintersect(Tuple{}, Tuple{Int})
Union{}
\end{minted}



What is the {\textquotedbl}primary{\textquotedbl} tuple-type?




\begin{minted}{jlcon}
julia> pointer_from_objref(Tuple)
Ptr{Void} @0x00007f5998a04370

julia> pointer_from_objref(Tuple{})
Ptr{Void} @0x00007f5998a570d0

julia> pointer_from_objref(Tuple.name.wrapper)
Ptr{Void} @0x00007f5998a04370

julia> pointer_from_objref(Tuple{}.name.wrapper)
Ptr{Void} @0x00007f5998a04370
\end{minted}



so \texttt{Tuple == Tuple\{Vararg\{Any\}\}} is indeed the primary type.



\hypertarget{5206945150982308765}{}


\subsection{Diagonal types}



Consider the type \texttt{Tuple\{T,T\} where T}. A method with this signature would look like:




\begin{minted}{julia}
f(x::T, y::T) where {T} = ...
\end{minted}



According to the usual interpretation of a \texttt{UnionAll} type, this \texttt{T} ranges over all types, including \texttt{Any}, so this type should be equivalent to \texttt{Tuple\{Any,Any\}}. However, this interpretation causes some practical problems.



First, a value of \texttt{T} needs to be available inside the method definition. For a call like \texttt{f(1, 1.0)}, it{\textquotesingle}s not clear what \texttt{T} should be. It could be \texttt{Union\{Int,Float64\}}, or perhaps \hyperlink{6175959395021454412}{\texttt{Real}}. Intuitively, we expect the declaration \texttt{x::T} to mean \texttt{T === typeof(x)}. To make sure that invariant holds, we need \texttt{typeof(x) === typeof(y) === T} in this method. That implies the method should only be called for arguments of the exact same type.



It turns out that being able to dispatch on whether two values have the same type is very useful (this is used by the promotion system for example), so we have multiple reasons to want a different interpretation of \texttt{Tuple\{T,T\} where T}. To make this work we add the following rule to subtyping: if a variable occurs more than once in covariant position, it is restricted to ranging over only concrete types. ({\textquotedbl}Covariant position{\textquotedbl} means that only \texttt{Tuple} and \texttt{Union} types occur between an occurrence of a variable and the \texttt{UnionAll} type that introduces it.) Such variables are called {\textquotedbl}diagonal variables{\textquotedbl} or {\textquotedbl}concrete variables{\textquotedbl}.



So for example, \texttt{Tuple\{T,T\} where T} can be seen as \texttt{Union\{Tuple\{Int8,Int8\}, Tuple\{Int16,Int16\}, ...\}}, where \texttt{T} ranges over all concrete types. This gives rise to some interesting subtyping results. For example \texttt{Tuple\{Real,Real\}} is not a subtype of \texttt{Tuple\{T,T\} where T}, because it includes some types like \texttt{Tuple\{Int8,Int16\}} where the two elements have different types. \texttt{Tuple\{Real,Real\}} and \texttt{Tuple\{T,T\} where T} have the non-trivial intersection \texttt{Tuple\{T,T\} where T<:Real}. However, \texttt{Tuple\{Real\}} \emph{is} a subtype of \texttt{Tuple\{T\} where T}, because in that case \texttt{T} occurs only once and so is not diagonal.



Next consider a signature like the following:




\begin{minted}{julia}
f(a::Array{T}, x::T, y::T) where {T} = ...
\end{minted}



In this case, \texttt{T} occurs in invariant position inside \texttt{Array\{T\}}. That means whatever type of array is passed unambiguously determines the value of \texttt{T} –- we say \texttt{T} has an \emph{equality constraint} on it. Therefore in this case the diagonal rule is not really necessary, since the array determines \texttt{T} and we can then allow \texttt{x} and \texttt{y} to be of any subtypes of \texttt{T}. So variables that occur in invariant position are never considered diagonal. This choice of behavior is slightly controversial –- some feel this definition should be written as




\begin{minted}{julia}
f(a::Array{T}, x::S, y::S) where {T, S<:T} = ...
\end{minted}



to clarify whether \texttt{x} and \texttt{y} need to have the same type. In this version of the signature they would, or we could introduce a third variable for the type of \texttt{y} if \texttt{x} and \texttt{y} can have different types.



The next complication is the interaction of unions and diagonal variables, e.g.




\begin{minted}{julia}
f(x::Union{Void,T}, y::T) where {T} = ...
\end{minted}



Consider what this declaration means. \texttt{y} has type \texttt{T}. \texttt{x} then can have either the same type \texttt{T}, or else be of type \texttt{Void}. So all of the following calls should match:




\begin{minted}{julia}
f(1, 1)
f("", "")
f(2.0, 2.0)
f(nothing, 1)
f(nothing, "")
f(nothing, 2.0)
\end{minted}



These examples are telling us something: when \texttt{x} is \texttt{nothing::Void}, there are no extra constraints on \texttt{y}. It is as if the method signature had \texttt{y::Any}. This means that whether a variable is diagonal is not a static property based on where it appears in a type. Rather, it depends on where a variable appears when the subtyping algorithm \emph{uses} it. When \texttt{x} has type \texttt{Void}, we don{\textquotesingle}t need to use the \texttt{T} in \texttt{Union\{Void,T\}}, so \texttt{T} does not {\textquotedbl}occur{\textquotedbl}. Indeed, we have the following type equivalence:




\begin{minted}{julia}
(Tuple{Union{Void,T},T} where T) == Union{Tuple{Void,Any}, Tuple{T,T} where T}
\end{minted}



\hypertarget{12600482412457091491}{}


\subsection{Subtyping diagonal variables}



The subtyping algorithm for diagonal variables has two components: (1) identifying variable occurrences, and (2) ensuring that diagonal variables range over concrete types only.



The first task is accomplished by keeping counters \texttt{occurs\_inv} and \texttt{occurs\_cov} (in \texttt{src/subtype.c}) for each variable in the environment, tracking the number of invariant and covariant occurrences, respectively. A variable is diagonal when \texttt{occurs\_inv == 0 \&\& occurs\_cov > 1}.



The second task is accomplished by imposing a condition on a variable{\textquotesingle}s lower bound. As the subtyping algorithm runs, it narrows the bounds of each variable (raising lower bounds and lowering upper bounds) to keep track of the range of variable values for which the subtype relation would hold. When we are done evaluating the body of a \texttt{UnionAll} type whose variable is diagonal, we look at the final values of the bounds. Since the variable must be concrete, a contradiction occurs if its lower bound could not be a subtype of a concrete type. For example, an abstract type like \hyperlink{6514416309183787338}{\texttt{AbstractArray}} cannot be a subtype of a concrete type, but a concrete type like \texttt{Int} can be, and the empty type \texttt{Bottom} can be as well. If a lower bound fails this test the algorithm stops with the answer \texttt{false}.



For example, in the problem \texttt{Tuple\{Int,String\} <: Tuple\{T,T\} where T}, we derive that this would be true if \texttt{T} were a supertype of \texttt{Union\{Int,String\}}. However, \texttt{Union\{Int,String\}} is an abstract type, so the relation does not hold.



This concreteness test is done by the function \texttt{is\_leaf\_bound}. Note that this test is slightly different from \texttt{jl\_is\_leaf\_type}, since it also returns \texttt{true} for \texttt{Bottom}. Currently this function is heuristic, and does not catch all possible concrete types. The difficulty is that whether a lower bound is concrete might depend on the values of other type variable bounds. For example, \texttt{Vector\{T\}} is equivalent to the concrete type \texttt{Vector\{Int\}} only if both the upper and lower bounds of \texttt{T} equal \texttt{Int}. We have not yet worked out a complete algorithm for this.



\hypertarget{37604590457653524}{}


\subsection{Introduction to the internal machinery}



Most operations for dealing with types are found in the files \texttt{jltypes.c} and \texttt{subtype.c}. A good way to start is to watch subtyping in action. Build Julia with \texttt{make debug} and fire up Julia within a debugger. \hyperlink{10298426124440583682}{gdb debugging tips} has some tips which may be useful.



Because the subtyping code is used heavily in the REPL itself–and hence breakpoints in this code get triggered often–it will be easiest if you make the following definition:




\begin{minted}{jlcon}
julia> function mysubtype(a,b)
           ccall(:jl_breakpoint, Void, (Any,), nothing)
           issubtype(a, b)
       end
\end{minted}



and then set a breakpoint in \texttt{jl\_breakpoint}.  Once this breakpoint gets triggered, you can set breakpoints in other functions.



As a warm-up, try the following:




\begin{minted}{julia}
mysubtype(Tuple{Int,Float64}, Tuple{Integer,Real})
\end{minted}



We can make it more interesting by trying a more complex case:




\begin{minted}{julia}
mysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)
\end{minted}



\hypertarget{9271541181781970079}{}


\subsection{Subtyping and method sorting}



The \texttt{type\_morespecific} functions are used for imposing a partial order on functions in method tables (from most-to-least specific). Specificity is strict; if \texttt{a} is more specific than \texttt{b}, then \texttt{a} does not equal \texttt{b} and \texttt{b} is not more specific than \texttt{a}.



If \texttt{a} is a strict subtype of \texttt{b}, then it is automatically considered more specific. From there, \texttt{type\_morespecific} employs some less formal rules. For example, \texttt{subtype} is sensitive to the number of arguments, but \texttt{type\_morespecific} may not be. In particular, \texttt{Tuple\{Int,AbstractFloat\}} is more specific than \texttt{Tuple\{Integer\}}, even though it is not a subtype.  (Of \texttt{Tuple\{Int,AbstractFloat\}} and \texttt{Tuple\{Integer,Float64\}}, neither is more specific than the other.)  Likewise, \texttt{Tuple\{Int,Vararg\{Int\}\}} is not a subtype of \texttt{Tuple\{Integer\}}, but it is considered more specific. However, \texttt{morespecific} does get a bonus for length: in particular, \texttt{Tuple\{Int,Int\}} is more specific than \texttt{Tuple\{Int,Vararg\{Int\}\}}.



If you{\textquotesingle}re debugging how methods get sorted, it can be convenient to define the function:




\begin{minted}{julia}
type_morespecific(a, b) = ccall(:jl_type_morespecific, Cint, (Any,Any), a, b)
\end{minted}



which allows you to test whether tuple type \texttt{a} is more specific than tuple type \texttt{b}.



\hypertarget{11666441878855849549}{}


\section{Memory layout of Julia Objects}



\hypertarget{9050896398576860708}{}


\subsection{Object layout (jl\_value\_t)}



The \texttt{jl\_value\_t} struct is the name for a block of memory owned by the Julia Garbage Collector, representing the data associated with a Julia object in memory. Absent any type information, it is simply an opaque pointer:




\begin{lstlisting}
typedef struct jl_value_t* jl_pvalue_t;
\end{lstlisting}



Each \texttt{jl\_value\_t} struct is contained in a \texttt{jl\_typetag\_t} struct that contains metadata information about the Julia object, such as its type and garbage collector (gc) reachability:




\begin{lstlisting}
typedef struct {
    opaque metadata;
    jl_value_t value;
} jl_typetag_t;
\end{lstlisting}



The type of any Julia object is an instance of a leaf \texttt{jl\_datatype\_t} object. The \texttt{jl\_typeof()} function can be used to query for it:




\begin{lstlisting}
jl_value_t *jl_typeof(jl_value_t *v);
\end{lstlisting}



The layout of the object depends on its type. Reflection methods can be used to inspect that layout. A field can be accessed by calling one of the get-field methods:




\begin{lstlisting}
jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);
jl_value_t *jl_get_field(jl_value_t *o, char *fld);
\end{lstlisting}



If the field types are known, a priori, to be all pointers, the values can also be extracted directly as an array access:




\begin{lstlisting}
jl_value_t *v = value->fieldptr[n];
\end{lstlisting}



As an example, a {\textquotedbl}boxed{\textquotedbl} \texttt{uint16\_t} is stored as follows:




\begin{lstlisting}
struct {
    opaque metadata;
    struct {
        uint16_t data;        // -- 2 bytes
    } jl_value_t;
};
\end{lstlisting}



This object is created by \texttt{jl\_box\_uint16()}. Note that the \texttt{jl\_value\_t} pointer references the data portion, not the metadata at the top of the struct.



A value may be stored {\textquotedbl}unboxed{\textquotedbl} in many circumstances (just the data, without the metadata, and possibly not even stored but just kept in registers), so it is unsafe to assume that the address of a box is a unique identifier. The {\textquotedbl}egal{\textquotedbl} test (corresponding to the \texttt{===} function in Julia), should instead be used to compare two unknown objects for equivalence:




\begin{lstlisting}
int jl_egal(jl_value_t *a, jl_value_t *b);
\end{lstlisting}



This optimization should be relatively transparent to the API, since the object will be {\textquotedbl}boxed{\textquotedbl} on-demand, whenever a \texttt{jl\_value\_t} pointer is needed.



Note that modification of a \texttt{jl\_value\_t} pointer in memory is permitted only if the object is mutable. Otherwise, modification of the value may corrupt the program and the result will be undefined. The mutability property of a value can be queried for with:




\begin{lstlisting}
int jl_is_mutable(jl_value_t *v);
\end{lstlisting}



If the object being stored is a \texttt{jl\_value\_t}, the Julia garbage collector must be notified also:




\begin{lstlisting}
void jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);
\end{lstlisting}



However, the \hyperlink{7688715278401899796}{Embedding Julia} section of the manual is also required reading at this point, for covering other details of boxing and unboxing various types, and understanding the gc interactions.



Mirror structs for some of the built-in types are \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{defined in \texttt{julia.h}}. The corresponding global \texttt{jl\_datatype\_t} objects are created by \href{https://github.com/JuliaLang/julia/blob/master/src/jltypes.c}{\texttt{jl\_init\_types} in \texttt{jltypes.c}}.



\hypertarget{660883080955975432}{}


\subsection{Garbage collector mark bits}



The garbage collector uses several bits from the metadata portion of the \texttt{jl\_typetag\_t} to track each object in the system. Further details about this algorithm can be found in the comments of the \href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{garbage collector implementation in \texttt{gc.c}}.



\hypertarget{14420252243983980472}{}


\subsection{Object allocation}



Most new objects are allocated by \texttt{jl\_new\_structv()}:




\begin{lstlisting}
jl_value_t *jl_new_struct(jl_datatype_t *type, ...);
jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);
\end{lstlisting}



Although, \hyperlink{12980593021531333073}{\texttt{isbits}} objects can be also constructed directly from memory:




\begin{lstlisting}
jl_value_t *jl_new_bits(jl_value_t *bt, void *data)
\end{lstlisting}



And some objects have special constructors that must be used instead of the above functions:



Types:




\begin{lstlisting}
jl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);
jl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);
jl_uniontype_t *jl_new_uniontype(jl_tuple_t *types);
\end{lstlisting}



While these are the most commonly used options, there are more low-level constructors too, which you can find declared in \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{\texttt{julia.h}}. These are used in \texttt{jl\_init\_types()} to create the initial types needed to bootstrap the creation of the Julia system image.



Tuples:




\begin{lstlisting}
jl_tuple_t *jl_tuple(size_t n, ...);
jl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);
jl_tuple_t *jl_alloc_tuple(size_t n);
\end{lstlisting}



The representation of tuples is highly unique in the Julia object representation ecosystem. In some cases, a \hyperlink{12342862450082530092}{\texttt{Base.tuple()}} object may be an array of pointers to the objects contained by the tuple equivalent to:




\begin{lstlisting}
typedef struct {
    size_t length;
    jl_value_t *data[length];
} jl_tuple_t;
\end{lstlisting}



However, in other cases, the tuple may be converted to an anonymous \hyperlink{12980593021531333073}{\texttt{isbits}} type and stored unboxed, or it may not stored at all (if it is not being used in a generic context as a \texttt{jl\_value\_t*}).



Symbols:




\begin{lstlisting}
jl_sym_t *jl_symbol(const char *str);
\end{lstlisting}



Functions and MethodInstance:




\begin{lstlisting}
jl_function_t *jl_new_generic_function(jl_sym_t *name);
jl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);
\end{lstlisting}



Arrays:




\begin{lstlisting}
jl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);
jl_array_t *jl_new_arrayv(jl_value_t *atype, ...);
jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);
jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr, size_t nc);
jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr, size_t nc, size_t z);
jl_array_t *jl_alloc_vec_any(size_t n);
\end{lstlisting}



Note that many of these have alternative allocation functions for various special-purposes. The list here reflects the more common usages, but a more complete list can be found by reading the \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{\texttt{julia.h} header file}.



Internal to Julia, storage is typically allocated by \texttt{newstruct()} (or \texttt{newobj()} for the special types):




\begin{lstlisting}
jl_value_t *newstruct(jl_value_t *type);
jl_value_t *newobj(jl_value_t *type, size_t nfields);
\end{lstlisting}



And at the lowest level, memory is getting allocated by a call to the garbage collector (in \texttt{gc.c}), then tagged with its type:




\begin{lstlisting}
jl_value_t *jl_gc_allocobj(size_t nbytes);
void jl_set_typeof(jl_value_t *v, jl_datatype_t *type);
\end{lstlisting}



Note that all objects are allocated in multiples of 4 bytes and aligned to the platform pointer size. Memory is allocated from a pool for smaller objects, or directly with \texttt{malloc()} for large objects.



\begin{quote}
\textbf{Singleton Types}

Singleton types have only one instance and no data fields. Singleton instances have a size of 0 bytes, and consist only of their metadata. e.g. \texttt{nothing::Void}.

See \hyperlink{647919389478144252}{Singleton Types} and \hyperlink{259296306383383012}{Nothingness and missing values}

\end{quote}


\hypertarget{2565512592221324751}{}


\section{Eval of Julia code}



One of the hardest parts about learning how the Julia Language runs code is learning how all of the pieces work together to execute a block of code.



Each chunk of code typically makes a trip through many steps with potentially unfamiliar names, such as (in no particular order): flisp, AST, C++, LLVM, \texttt{eval}, \texttt{typeinf}, \texttt{macroexpand}, sysimg (or system image), bootstrapping, compile, parse, execute, JIT, interpret, box, unbox, intrinsic function, and primitive function, before turning into the desired result (hopefully).



\begin{quote}
\textbf{Definitions}

\begin{itemize}
\item REPL

REPL stands for Read-Eval-Print Loop. It{\textquotesingle}s just what we call the command line environment for short.


\item AST

Abstract Syntax Tree The AST is the digital representation of the code structure. In this form the code has been tokenized for meaning so that it is more suitable for manipulation and execution.

\end{itemize}
\end{quote}


\hypertarget{12349293482799060845}{}


\subsection{Julia Execution}



The 10,000 foot view of the whole process is as follows:



\begin{itemize}
\item[1.  ] The user starts \texttt{julia}.


\item[2.  ] The C function \texttt{main()} from \texttt{ui/repl.c} gets called. This function processes the command line arguments, filling in the \texttt{jl\_options} struct and setting the variable \texttt{ARGS}. It then initializes Julia (by calling \href{https://github.com/JuliaLang/julia/blob/master/src/task.c}{\texttt{julia\_init} in \texttt{task.c}}, which may load a previously compiled \hyperlink{9959120445934014648}{sysimg}). Finally, it passes off control to Julia by calling \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.\_start()}}.


\item[3.  ] When \texttt{\_start()} takes over control, the subsequent sequence of commands depends on the command line arguments given. For example, if a filename was supplied, it will proceed to execute that file. Otherwise, it will start an interactive REPL.


\item[4.  ] Skipping the details about how the REPL interacts with the user, let{\textquotesingle}s just say the program ends up with a block of code that it wants to run.


\item[5.  ] If the block of code to run is in a file, \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_load(char *filename)}} gets invoked to load the file and \hyperlink{6801832859572424777}{parse} it. Each fragment of code is then passed to \texttt{eval} to execute.


\item[6.  ] Each fragment of code (or AST), is handed off to \hyperlink{2345597220715550879}{\texttt{eval()}} to turn into results.


\item[7.  ] \hyperlink{2345597220715550879}{\texttt{eval()}} takes each code fragment and tries to run it in \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}}.


\item[8.  ] \texttt{jl\_toplevel\_eval\_flex()} decides whether the code is a {\textquotedbl}toplevel{\textquotedbl} action (such as \texttt{using} or \texttt{module}), which would be invalid inside a function. If so, it passes off the code to the toplevel interpreter.


\item[9.  ] \texttt{jl\_toplevel\_eval\_flex()} then \hyperlink{13925460440315781353}{expands} the code to eliminate any macros and to {\textquotedbl}lower{\textquotedbl} the AST to make it simpler to execute.


\item[10. ] \texttt{jl\_toplevel\_eval\_flex()} then uses some simple heuristics to decide whether to JIT compiler the  AST or to interpret it directly.


\item[11. ] The bulk of the work to interpret code is handled by \href{https://github.com/JuliaLang/julia/blob/master/src/interpreter.c}{\texttt{eval} in \texttt{interpreter.c}}.


\item[12. ] If instead, the code is compiled, the bulk of the work is handled by \texttt{codegen.cpp}. Whenever a  Julia function is called for the first time with a given set of argument types, \hyperlink{5553247398724394157}{type inference}  will be run on that function. This information is used by the \hyperlink{16251221274618963128}{codegen} step to generate  faster code.


\item[13. ] Eventually, the user quits the REPL, or the end of the program is reached, and the \texttt{\_start()}  method returns.


\item[14. ] Just before exiting, \texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_atexit\_hook(exit\_code)}}.  This calls \texttt{Base.\_atexit()} (which calls any functions registered to \hyperlink{17479944696971324992}{\texttt{atexit()}} inside  Julia). Then it calls \href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{\texttt{jl\_gc\_run\_all\_finalizers()}}.  Finally, it gracefully cleans up all \texttt{libuv} handles and waits for them to flush and close.

\end{itemize}


\hypertarget{6801832859572424777}{}


\subsection{Parsing}



The Julia parser is a small lisp program written in femtolisp, the source-code for which is distributed inside Julia in \href{https://github.com/JuliaLang/julia/tree/master/src/flisp}{src/flisp}.



The interface functions for this are primarily defined in \href{https://github.com/JuliaLang/julia/blob/master/src/jlfrontend.scm}{\texttt{jlfrontend.scm}}. The code in \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{ast.c}} handles this handoff on the Julia side.



The other relevant files at this stage are \href{https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm}{\texttt{julia-parser.scm}}, which handles tokenizing Julia code and turning it into an AST, and \href{https://github.com/JuliaLang/julia/blob/master/src/julia-syntax.scm}{\texttt{julia-syntax.scm}}, which handles transforming complex AST representations into simpler, {\textquotedbl}lowered{\textquotedbl} AST representations which are more suitable for analysis and execution.



\hypertarget{13925460440315781353}{}


\subsection{Macro Expansion}



When \hyperlink{2345597220715550879}{\texttt{eval()}} encounters a macro, it expands that AST node before attempting to evaluate the expression. Macro expansion involves a handoff from \hyperlink{2345597220715550879}{\texttt{eval()}} (in Julia), to the parser function \texttt{jl\_macroexpand()} (written in \texttt{flisp}) to the Julia macro itself (written in - what else - Julia) via \texttt{fl\_invoke\_julia\_macro()}, and back.



Typically, macro expansion is invoked as a first step during a call to \hyperlink{14846157655101111909}{\texttt{expand()}}/\texttt{jl\_expand()}, although it can also be invoked directly by a call to \hyperlink{8018172489611994488}{\texttt{macroexpand()}}/\texttt{jl\_macroexpand()}.



\hypertarget{5553247398724394157}{}


\subsection{Type Inference}



Type inference is implemented in Julia by \href{https://github.com/JuliaLang/julia/blob/master/base/inference.jl}{\texttt{typeinf()} in \texttt{inference.jl}}. Type inference is the process of examining a Julia function and determining bounds for the types of each of its variables, as well as bounds on the type of the return value from the function. This enables many future optimizations, such as unboxing of known immutable values, and compile-time hoisting of various run-time operations such as computing field offsets and function pointers. Type inference may also include other steps such as constant propagation and inlining.



\begin{quote}
\textbf{More Definitions}

\begin{itemize}
\item JIT

Just-In-Time Compilation The process of generating native-machine code into memory right when it is needed.


\item LLVM

Low-Level Virtual Machine (a compiler) The Julia JIT compiler is a program/library called libLLVM. Codegen in Julia refers both to the process of taking a Julia AST and turning it into LLVM instructions, and the process of LLVM optimizing that and turning it into native assembly instructions.


\item C++

The programming language that LLVM is implemented in, which means that codegen is also implemented in this language. The rest of Julia{\textquotesingle}s library is implemented in C, in part because its smaller feature set makes it more usable as a cross-language interface layer.


\item box

This term is used to describe the process of taking a value and allocating a wrapper around the data that is tracked by the garbage collector (gc) and is tagged with the object{\textquotesingle}s type.


\item unbox

The reverse of boxing a value. This operation enables more efficient manipulation of data when the type of that data is fully known at compile-time (through type inference).


\item generic function

A Julia function composed of multiple {\textquotedbl}methods{\textquotedbl} that are selected for dynamic dispatch based on the argument type-signature


\item anonymous function or {\textquotedbl}method{\textquotedbl}

A Julia function without a name and without type-dispatch capabilities


\item primitive function

A function implemented in C but exposed in Julia as a named function {\textquotedbl}method{\textquotedbl} (albeit without generic function dispatch capabilities, similar to a anonymous function)


\item intrinsic function

A low-level operation exposed as a function in Julia. These pseudo-functions implement operations on raw bits such as add and sign extend that cannot be expressed directly in any other way. Since they operate on bits directly, they must be compiled into a function and surrounded by a call to \texttt{Core.Intrinsics.box(T, ...)} to reassign type information to the value.

\end{itemize}
\end{quote}


\hypertarget{16251221274618963128}{}


\subsection{JIT Code Generation}



Codegen is the process of turning a Julia AST into native machine code.



The JIT environment is initialized by an early call to \href{https://github.com/JuliaLang/julia/blob/master/src/codegen.cpp}{\texttt{jl\_init\_codegen} in \texttt{codegen.cpp}}.



On demand, a Julia method is converted into a native function by the function \texttt{emit\_function(jl\_method\_instance\_t*)}. (note, when using the MCJIT (in LLVM v3.4+), each function must be JIT into a new module.) This function recursively calls \texttt{emit\_expr()} until the entire function has been emitted.



Much of the remaining bulk of this file is devoted to various manual optimizations of specific code patterns. For example, \texttt{emit\_known\_call()} knows how to inline many of the primitive functions (defined in \href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{builtins.c}}) for various combinations of argument types.



Other parts of codegen are handled by various helper files:



\begin{itemize}
\item \href{https://github.com/JuliaLang/julia/blob/master/src/debuginfo.cpp}{\texttt{debuginfo.cpp}}

Handles backtraces for JIT functions


\item \href{https://github.com/JuliaLang/julia/blob/master/src/ccall.cpp}{\texttt{ccall.cpp}}

Handles the ccall and llvmcall FFI, along with various \texttt{abi\_*.cpp} files


\item \href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{\texttt{intrinsics.cpp}}

Handles the emission of various low-level intrinsic functions

\end{itemize}


\begin{quote}
\textbf{Bootstrapping}

The process of creating a new system image is called {\textquotedbl}bootstrapping{\textquotedbl}.

The etymology of this word comes from the phrase {\textquotedbl}pulling oneself up by the bootstraps{\textquotedbl}, and refers to the idea of starting from a very limited set of available functions and definitions and ending with the creation of a full-featured environment.

\end{quote}


\hypertarget{9959120445934014648}{}


\subsection{System Image}



The system image is a precompiled archive of a set of Julia files. The \texttt{sys.ji} file distributed with Julia is one such system image, generated by executing the file \href{https://github.com/JuliaLang/julia/blob/master/base/sysimg.jl}{\texttt{sysimg.jl}}, and serializing the resulting environment (including Types, Functions, Modules, and all other defined values) into a file. Therefore, it contains a frozen version of the \texttt{Main}, \texttt{Core}, and \texttt{Base} modules (and whatever else was in the environment at the end of bootstrapping). This serializer/deserializer is implemented by \href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_save\_system\_image}/\texttt{jl\_restore\_system\_image} in \texttt{dump.c}}.



If there is no sysimg file (\texttt{jl\_options.image\_file == NULL}), this also implies that \texttt{--build} was given on the command line, so the final result should be a new sysimg file. During Julia initialization, minimal \texttt{Core} and \texttt{Main} modules are created. Then a file named \texttt{boot.jl} is evaluated from the current directory. Julia then evaluates any file given as a command line argument until it reaches the end. Finally, it saves the resulting environment to a {\textquotedbl}sysimg{\textquotedbl} file for use as a starting point for a future Julia run.



\hypertarget{3417049897160160290}{}


\section{Calling Conventions}



Julia uses three calling conventions for four distinct purposes:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Name & Prefix & Purpose \\
\hline
Native & \texttt{julia\_} & Speed via specialized signatures \\
\hline
JL Call & \texttt{jlcall\_} & Wrapper for generic calls \\
\hline
JL Call & \texttt{jl\_} & Builtins \\
\hline
C ABI & \texttt{jlcapi\_} & Wrapper callable from C \\
\hline
\end{tabulary}

\end{table}



\hypertarget{4788166660204734834}{}


\subsection{Julia Native Calling Convention}



The native calling convention is designed for fast non-generic calls. It usually uses a specialized signature.



\begin{itemize}
\item LLVM ghosts (zero-length types) are omitted.


\item LLVM scalars and vectors are passed by value.


\item LLVM aggregates (arrays and structs) are passed by reference.

\end{itemize}


A small return values is returned as LLVM return values. A large return values is returned via the {\textquotedbl}structure return{\textquotedbl} (\texttt{sret}) convention, where the caller provides a pointer to a return slot.



An argument or return values thta is a homogeneous tuple is sometimes represented as an LLVM vector instead of an LLVM array.



\hypertarget{10962628785392118342}{}


\subsection{JL Call Convention}



The JL Call convention is for builtins and generic dispatch. Hand-written functions using this convention are declared via the macro \texttt{JL\_CALLABLE}. The convention uses exactly 3 parameters:



\begin{itemize}
\item \texttt{F}  - Julia representation of function that is being applied


\item \texttt{args} - pointer to array of pointers to boxes


\item \texttt{nargs} - length of the array

\end{itemize}


The return value is a pointer to a box.



\hypertarget{16764615067045412370}{}


\subsection{C ABI}



C ABI wrappers enable calling Julia from C. The wrapper calls a function using the native calling convention.



Tuples are always represented as C arrays.



\hypertarget{2265182675689203812}{}


\section{High-level Overview of the Native-Code Generation Process}



\hypertarget{6164157073495091365}{}


\subsection{Representation of Pointers}



When emitting code to an object file, pointers will be emitted as relocations. The deserialization code will ensure any object that pointed to one of these constants gets recreated and contains the right runtime pointer.



Otherwise, they will be emitted as literal constants.



To emit one of these objects, call \texttt{literal\_pointer\_val}. It{\textquotesingle}ll handle tracking the Julia value and the LLVM global, ensuring they are valid both for the current runtime and after deserialization.



When emitted into the object file, these globals are stored as references in a large \texttt{gvals} table. This allows the deserializer to reference them by index, and implement a custom manual mechanism similar to a Global Offset Table (GOT) to restore them.



Function pointers are handled similarly. They are stored as values in a large \texttt{fvals} table. Like globals, this allows the deserializer to reference them by index.



Note that \texttt{extern} functions are handled separately, with names, via the usual symbol resolution mechanism in the linker.



Note too that \texttt{ccall} functions are also handled separately, via a manual GOT and Procedure Linkage Table (PLT).



\hypertarget{9352283582715079729}{}


\subsection{Representation of Intermediate Values}



Values are passed around in a \texttt{jl\_cgval\_t} struct. This represents an R-value, and includes enough information to determine how to assign or pass it somewhere.



They are created via one of the helper constructors, usually: \texttt{mark\_julia\_type} (for immediate values) and \texttt{mark\_julia\_slot} (for pointers to values).



The function \texttt{convert\_julia\_type} can transform between any two types. It returns an R-value with \texttt{cgval.typ} set to \texttt{typ}. It{\textquotesingle}ll cast the object to the requested representation, making heap boxes, allocating stack copies, and computing tagged unions as needed to change the representation.



By contrast \texttt{update\_julia\_type} will change \texttt{cgval.typ} to \texttt{typ}, only if it can be done at zero-cost (i.e. without emitting any code).



\hypertarget{3738811278233217209}{}


\subsection{Union representation}



Inferred union types may be stack allocated via a tagged type representation.



The primitive routines that need to be able to handle tagged unions are:



\begin{itemize}
\item mark-type


\item load-local


\item store-local


\item isa


\item is


\item emit\_typeof


\item emit\_sizeof


\item boxed


\item unbox


\item specialized cc-ret

\end{itemize}


Everything else should be possible to handle in inference by using these primitives to implement union-splitting.



The representation of the tagged-union is as a pair of \texttt{< void* union, byte selector >}. The selector is fixed-size as \texttt{byte \& 0x7f}, and will union-tag the first 126 isbits. It records the one-based depth-first count into the type-union of the isbits objects inside. An index of zero indicates that the \texttt{union*} is actually a tagged heap-allocated \texttt{jl\_value\_t*}, and needs to be treated as normal for a boxed object rather than as a tagged union.



The high bit of the selector (\texttt{byte \& 0x80}) can be tested to determine if the \texttt{void*} is actually a heap-allocated (\texttt{jl\_value\_t*}) box, thus avoiding the cost of re-allocating a box, while maintaining the ability to efficiently handle union-splitting based on the low bits.



It is guaranteed that \texttt{byte \& 0x7f} is an exact test for the type, if the value can be represented by a tag – it will never be marked \texttt{byte = 0x80}. It is not necessary to also test the type-tag when testing \texttt{isa}.



The \texttt{union*} memory region may be allocated at \emph{any} size. The only constraint is that it is big enough to contain the data currently specified by \texttt{selector}. It might not be big enough to contain the union of all types that could be stored there according to the associated Union type field. Use appropriate care when copying.



\hypertarget{5801902447580234191}{}


\subsection{Specialized Calling Convention Signature Representation}



A \texttt{jl\_returninfo\_t} object describes the calling convention details of any callable.



If any of the arguments or return type of a method can be represented unboxed, and the method is not varargs, it{\textquotesingle}ll be given an optimized calling convention signature based on its \texttt{specTypes} and \texttt{rettype} fields.



The general principles are that:



\begin{itemize}
\item Primitive types get passed in int/float registers.


\item Tuples of VecElement types get passed in vector registers.


\item Structs get passed on the stack.


\item Return values are handle similarly to arguments, with a size-cutoff at which they will instead be returned via a hidden sret argument.

\end{itemize}


The total logic for this is implemented by \texttt{get\_specsig\_function} and \texttt{deserves\_sret}.



Additionally, if the return type is a union, it may be returned as a pair of values (a pointer and a tag). If the union values can be stack-allocated, then sufficient space to store them will also be passed as a hidden first argument. It is up to the callee whether the returned pointer will point to this space, a boxed object, or even other constant memory.



\hypertarget{8538207326577378342}{}


\section{Julia Functions}



This document will explain how functions, method definitions, and method tables work.



\hypertarget{791619394702824269}{}


\subsection{Method Tables}



Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of many definitions, or methods. The methods of a generic function are stored in a method table. Method tables (type \texttt{MethodTable}) are associated with \texttt{TypeName}s. A \texttt{TypeName} describes a family of parameterized types. For example \texttt{Complex\{Float32\}} and \texttt{Complex\{Float64\}} share the same \texttt{Complex} type name object.



All objects in Julia are potentially callable, because every object has a type, which in turn has a \texttt{TypeName}.



\hypertarget{5677321158644388515}{}


\subsection{Function calls}



Given the call \texttt{f(x,y)}, the following steps are performed: first, the method table to use is accessed as \texttt{typeof(f).name.mt}. Second, an argument tuple type is formed, \texttt{Tuple\{typeof(f), typeof(x), typeof(y)\}}. Note that the type of the function itself is the first element. This is because the type might have parameters, and so needs to take part in dispatch. This tuple type is looked up in the method table.



This dispatch process is performed by \texttt{jl\_apply\_generic}, which takes two arguments: a pointer to an array of the values f, x, and y, and the number of values (in this case 3).



Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept the function and arguments separately, and those that accept a single argument structure. In the first kind of API, the {\textquotedbl}arguments{\textquotedbl} part does \emph{not} contain information about the function, since that is passed separately. In the second kind of API, the function is the first element of the argument structure.



For example, the following function for performing a call accepts just an \texttt{args} pointer, so the first element of the args array will be the function to call:




\begin{lstlisting}
jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)
\end{lstlisting}



This entry point for the same functionality accepts the function separately, so the \texttt{args} array does not contain the function:




\begin{lstlisting}
jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);
\end{lstlisting}



\hypertarget{17618724806250544535}{}


\subsection{Adding methods}



Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the method. \texttt{jl\_method\_def} implements this operation. \texttt{jl\_first\_argument\_datatype} is called to extract the relevant method table from what would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument tuple type might be abstract. For example, we can define:




\begin{minted}{julia}
(::Union{Foo{Int},Foo{Int8}})(x) = 0
\end{minted}



which works since all possible matching methods would belong to the same method table.



\hypertarget{16014622082824674579}{}


\subsection{Creating generic functions}



Since every object is callable, nothing special is needed to create a generic function. Therefore \texttt{jl\_new\_generic\_function} simply creates a new singleton (0 size) subtype of \texttt{Function} and returns its instance. A function can have a mnemonic {\textquotedbl}display name{\textquotedbl} which is used in debug info and when printing objects. For example the name of \texttt{Base.sin} is \texttt{sin}. By convention, the name of the created \emph{type} is the same as the function name, with a \texttt{\#} prepended. So \texttt{typeof(sin)} is \texttt{Base.\#sin}.



\hypertarget{5087486620251640638}{}


\subsection{Closures}



A closure is simply a callable object with field names corresponding to captured variables. For example, the following code:




\begin{minted}{julia}
function adder(x)
    return y->x+y
end
\end{minted}



is lowered to (roughly):




\begin{minted}{julia}
struct ##1{T}
    x::T
end

(_::##1)(y) = _.x + y

function adder(x)
    return ##1(x)
end
\end{minted}



\hypertarget{3597362352537600414}{}


\subsection{Constructors}



A constructor call is just a call to a type. The type of most types is \texttt{DataType}, so the method table for \texttt{DataType} contains most constructor definitions. One wrinkle is the fallback definition that makes all types callable via \texttt{convert}:




\begin{minted}{julia}
(::Type{T}){T}(args...) = convert(T, args...)::T
\end{minted}



In this definition the function type is abstract, which is not normally supported. To make this work, all subtypes of \texttt{Type} (\texttt{Type}, \texttt{UnionAll}, \texttt{Union}, and \texttt{DataType}) currently share a method table via special arrangement.



\hypertarget{4994602509934264781}{}


\subsection{Builtins}



The {\textquotedbl}builtin{\textquotedbl} functions, defined in the \texttt{Core} module, are:




\begin{lstlisting}
=== typeof sizeof issubtype isa typeassert throw tuple getfield setfield! fieldtype
nfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply
_expr svec
\end{lstlisting}



These are all singleton objects whose types are subtypes of \texttt{Builtin}, which is a subtype of \texttt{Function}. Their purpose is to expose entry points in the run time that use the {\textquotedbl}jlcall{\textquotedbl} calling convention:




\begin{lstlisting}
jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)
\end{lstlisting}



The method tables of builtins are empty. Instead, they have a single catch-all method cache entry (\texttt{Tuple\{Vararg\{Any\}\}}) whose jlcall fptr points to the correct function. This is kind of a hack but works reasonably well.



\hypertarget{51534660369225743}{}


\subsection{Keyword arguments}



Keyword arguments work by associating a special, hidden function object with each method table that has definitions with keyword arguments. This function is called the {\textquotedbl}keyword argument sorter{\textquotedbl} or {\textquotedbl}keyword sorter{\textquotedbl}, or {\textquotedbl}kwsorter{\textquotedbl}, and is stored in the \texttt{kwsorter} field of \texttt{MethodTable} objects. Every definition in the kwsorter function has the same arguments as some definition in the normal method table, except with a single \texttt{Array} argument prepended. This array contains alternating symbols and values that represent the passed keyword arguments. The kwsorter{\textquotesingle}s job is to move keyword arguments into their canonical positions based on name, plus evaluate and substite any needed default value expressions. The result is a normal positional argument list, which is then passed to yet another function.



The easiest way to understand the process is to look at how a keyword argument method definition is lowered. The code:




\begin{minted}{julia}
function circle(center, radius; color = black, fill::Bool = true, options...)
    # draw
end
\end{minted}



actually produces \emph{three} method definitions. The first is a function that accepts all arguments (including keywords) as positional arguments, and includes the code for the method body. It has an auto-generated name:




\begin{minted}{julia}
function #circle#1(color, fill::Bool, options, circle, center, radius)
    # draw
end
\end{minted}



The second method is an ordinary definition for the original \texttt{circle} function, which handles the case where no keyword arguments are passed:




\begin{minted}{julia}
function circle(center, radius)
    #circle#1(black, true, Any[], circle, center, radius)
end
\end{minted}



This simply dispatches to the first method, passing along default values. Finally there is the kwsorter definition:




\begin{lstlisting}
function (::Core.kwftype(typeof(circle)))(kw::Array, circle, center, radius)
    options = Any[]
    color = arg associated with :color, or black if not found
    fill = arg associated with :fill, or true if not found
    # push remaining elements of kw into options array
    #circle#1(color, fill, options, circle, center, radius)
end
\end{lstlisting}



The front end generates code to loop over the \texttt{kw} array and pick out arguments in the right order, evaluating default expressions when an argument is not found.



The function \texttt{Core.kwftype(t)} fetches (and creates, if necessary) the field \texttt{t.name.mt.kwsorter}.



This design has the feature that call sites that don{\textquotesingle}t use keyword arguments require no special handling; everything works as if they were not part of the language at all. Call sites that do use keyword arguments are dispatched directly to the called function{\textquotesingle}s kwsorter. For example the call:




\begin{minted}{julia}
circle((0,0), 1.0, color = red; other...)
\end{minted}



is lowered to:




\begin{minted}{julia}
kwfunc(circle)(Any[:color,red,other...], circle, (0,0), 1.0)
\end{minted}



The unpacking procedure represented here as \texttt{other...} actually further unpacks each \emph{element} of \texttt{other}, expecting each one to contain two values (a symbol and a value). \texttt{kwfunc} (also in \texttt{Core}) fetches the kwsorter for the called function. Notice that the original \texttt{circle} function is passed through, to handle closures.



\hypertarget{13873351321632979877}{}


\subsection{Compiler efficiency issues}



Generating a new type for every function has potentially serious consequences for compiler resource use when combined with Julia{\textquotesingle}s {\textquotedbl}specialize on all arguments by default{\textquotedbl} design. Indeed, the initial implementation of this design suffered from much longer build and test times, higher memory use, and a system image nearly 2x larger than the baseline. In a naive implementation, the problem is bad enough to make the system nearly unusable. Several significant optimizations were needed to make the design practical.



The first issue is excessive specialization of functions for different values of function-valued arguments. Many functions simply {\textquotedbl}pass through{\textquotedbl} an argument to somewhere else, e.g. to another function or to a storage location. Such functions do not need to be specialized for every closure that might be passed in. Fortunately this case is easy to distinguish by simply considering whether a function \emph{calls} one of its arguments (i.e. the argument appears in {\textquotedbl}head position{\textquotedbl} somewhere). Performance-critical higher-order functions like \texttt{map} certainly call their argument function and so will still be specialized as expected. This optimization is implemented by recording which arguments are called during the \texttt{analyze-variables} pass in the front end. When \texttt{cache\_method} sees an argument in the \texttt{Function} type hierarchy passed to a slot declared as \texttt{Any} or \texttt{Function}, it pretends the slot was declared as \texttt{ANY} (the {\textquotedbl}don{\textquotesingle}t specialize{\textquotedbl} hint). This heuristic seems to be extremely effective in practice.



The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast majority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases can be resolved by considering only the first argument. (Aside: proponents of single dispatch would not be surprised by this at all. However, this argument means {\textquotedbl}multiple dispatch is easy to optimize in practice{\textquotedbl}, and that we should therefore use it, \emph{not} {\textquotedbl}we should use single dispatch{\textquotedbl}!) So the method cache uses the type of the first argument as its primary key. Note, however, that this corresponds to the \emph{second} element of the tuple type for a function call (the first element being the type of the function itself). Typically, type variation in head position is extremely low – indeed, the majority of functions belong to singleton types with no parameters. However, this is not the case for constructors, where a single method table holds constructors for every type. Therefore the \texttt{Type} method table is special-cased to use the \emph{first} tuple type element instead of the second.



The front end generates type declarations for all closures. Initially, this was implemented by generating normal type declarations. However, this produced an extremely large number of constructors, all of which were trivial (simply passing all arguments through to \texttt{new}). Since methods are partially ordered, inserting all of these methods is O(n{\textasciicircum}2), plus there are just too many of them to keep around. This was optimized by generating \texttt{composite\_type} expressions directly (bypassing default constructor generation), and using \texttt{new} directly to create closure instances. Not the prettiest thing ever, but you do what you gotta do.



The next problem was the \texttt{@test} macro, which generated a 0-argument closure for each test case. This is not really necessary, since each test case is simply run once in place. Therefore I modified \texttt{@test} to expand to a try-catch block that records the test result (true, false, or exception raised) and calls the test suite handler on it.



However this caused a new problem. When many tests are grouped together in a single function, e.g. a single top level expression, or some other test grouping function, that function could have a very large number of exception handlers. This triggered a kind of dataflow analysis worst case, where type inference spun around for minutes enumerating possible paths through the forest of handlers. This was fixed by simply bailing out of type inference when it encounters more than some number of handlers (currently 25). Presumably no performance-critical function will have more than 25 exception handlers. If one ever does, I{\textquotesingle}m willing to raise the limit to 26.



A minor issue occurs during the bootstrap process due to storing all constructors in a single method table. In the second bootstrap step, where \texttt{inference.ji} is compiled using \texttt{inference0.ji}, constructors for \texttt{inference0}{\textquotesingle}s types remain in the table, so there are still references to the old inference module and \texttt{inference.ji} is 2x the size it should be. This was fixed in \texttt{dump.c} by filtering definitions from {\textquotedbl}replaced modules{\textquotedbl} out of method tables and caches before saving a system image. A {\textquotedbl}replaced module{\textquotedbl} is one that satisfies the condition \texttt{m != jl\_get\_global(m->parent, m->name)} – in other words, some newer module has taken its name and place.



Another type inference worst case was triggered by the following code from the \href{https://github.com/JuliaMath/QuadGK.jl}{QuadGK.jl package}, formerly part of Base:




\begin{minted}{julia}
function do_quadgk(f, s, n, ::Type{Tw}, abstol, reltol, maxevals, nrm) where Tw
    if eltype(s) <: Real # check for infinite or semi-infinite intervals
        s1 = s[1]; s2 = s[end]; inf1 = isinf(s1); inf2 = isinf(s2)
        if inf1 || inf2
            if inf1 && inf2 # x = t/(1-t^2) coordinate transformation
                return do_quadgk(t -> begin t2 = t*t; den = 1 / (1 - t2);
                                            f(t*den) * (1+t2)*den*den; end,
                                 map(x -> isinf(x) ? copysign(one(x), x) : 2x / (1+hypot(1,2x)), s),
                                 n, Tw, abstol, reltol, maxevals, nrm)
            end
            s0,si = inf1 ? (s2,s1) : (s1,s2)
            if si < 0 # x = s0 - t/(1-t)
                return do_quadgk(t -> begin den = 1 / (1 - t);
                                            f(s0 - t*den) * den*den; end,
                                 reverse!(map(x -> 1 / (1 + 1 / (s0 - x)), s)),
                                 n, Tw, abstol, reltol, maxevals, nrm)
            else # x = s0 + t/(1-t)
                return do_quadgk(t -> begin den = 1 / (1 - t);
                                            f(s0 + t*den) * den*den; end,
                                 map(x -> 1 / (1 + 1 / (x - s0)), s),
                                 n, Tw, abstol, reltol, maxevals, nrm)
            end
        end
    end
\end{minted}



This code has a 3-way tail recursion, where each call wraps the current function argument \texttt{f} in a different new closure. Inference must consider 3{\textasciicircum}n (where n is the call depth) possible signatures. This blows up way too quickly, so logic was added to \texttt{typeinf\_uncached} to immediately widen any argument that is a subtype of \texttt{Function} and that grows in depth down the stack.



\hypertarget{10117343183210038440}{}


\section{Base.Cartesian}



El módulo \texttt{Cartesian} (no exportado) proporciona macros que facilitan escribir algoritmos multidimensionales. Es deseable que, a largo plazo, este módulo \texttt{Cartesian} no sea necesario; sin embargo, en la actualidad es una de las pocas formas de escribir código multidimensional compacto y con rendimiento.



\hypertarget{15280008707083756492}{}


\subsection{Principios de uso}



Un ejemplo de uso simple podría ser:




\begin{minted}{julia}
@nloops 3 i A begin
    s += @nref 3 A i
end
\end{minted}



que genera el siguiente código:




\begin{minted}{julia}
for i_3 = 1:size(A,3)
    for i_2 = 1:size(A,2)
        for i_1 = 1:size(A,1)
            s += A[i_1,i_2,i_3]
        end
    end
end
\end{minted}



En general, \texttt{Cartesian} permitirá escribir código que contiene elementos repetitivos, como los bucles anidados de este ejemplo. Otras aplicaciones incluyen expresiones repetidas (por ejemplo, desenrollado de bucles) o crear llamadas a función con números variables de argumentos sin usar la construcción {\textquotedbl}\emph{splat}{\textquotedbl} (\texttt{i...}).



\hypertarget{1420361062452440412}{}


\subsection{Sintaxis Básica}



La sintaxis básica de \texttt{@nloops} es la siguiente:



 * El primer argumento debe ser un entero (\emph{no} una variable) que especifica el número de bucles.   * El segundo argumento es el prefijo simbólico que se utilizará para la variable iteradora. De este modo, en el ejemplo anterior usamos \texttt{i}, y se generaron las variables  \texttt{i\_1, i\_2, i\_3}.   * El tercer argumento especifica el rango para cada variable iteradora. Si se usa una variable (símbolo) aquí, es considerado como \texttt{1:size(A,dim)}. De forma más flexible, se puede usar la sintaxis de expresiones basadas en funciones anónimas que se decribe más adelante.   * El último argumento es el cuerpo del bucle. En el ejemplo anterior, lo que aparece entre \texttt{begin...end}.



Hay otras características adicionales de \texttt{@nloops} descritas en la \hyperlink{908996570436533510}{sección de referencia}.



\texttt{@nref} sigue un patrn similar, generando \texttt{A[i\_1,i\_2,i\_3]} a partir de \texttt{@nref 3 A i}. La práctica general es leer de izquierda a derecha, por lo que \texttt{@nloops} es \texttt{@nloops 3 i A expr} (como en el bucle \texttt{for i\_2 = 1:size(A,2)}, donde \texttt{i\_2} está a la izquierda y el rango a la derecha) mientras que \texttt{@nref} es \texttt{@nref 3 A i} (como en \texttt{A[i\_1,i\_2,i\_3]}, donde el array va primero).



Si ests desarrollando código con Cartesian, puedes encontrar que depurar es más sencillo cuando examinas el código generado, usando \texttt{macroexpand}:






\begin{minted}{jlcon}
julia> macroexpand(:(@nref 2 A i))
:(A[i_1, i_2])
\end{minted}





\hypertarget{18123024058319139620}{}


\subsubsection{Proporcionando el número de expresiones}



El primer argumentos de estas dos macros es el número de expresiones, que debe ser un entero. Cuando estás escribiendo una funcin que pretendes que trabaje en múltiples dimensiones, esto puede no ser algo que desees codificar. Si estás escribiendo código que necesitas que trabaje con versiones antiguas de Julia, deberías usar la macro \texttt{@ngenerate} descrita en \href{https://docs.julialang.org/en/release-0.3/devdocs/cartesian/\#supplying-the-number-of-expressions}{una versión más antigua de esta documentación}.



Empezando en Julia 0.4-pre, el enfoque recomendado es usar una \texttt{@generated function}.  He aquí un ejemplo:




\begin{minted}{julia}
@generated function mysum(A::Array{T,N}) where {T,N}
    quote
        s = zero(T)
        @nloops $N i A begin
            s += @nref $N A i
        end
        s
    end
end
\end{minted}



Naturalmente, también podemos preparar expresiones o realizar cálculos antes del bloque \texttt{quote}.



\hypertarget{14061868401232608428}{}


\subsubsection{Expresiones función anónima como argumentos de macros}



Quizás la característica más potente de \texttt{Cartesian} es la capacidad de proporcionar expresiones función-anónima que son evaluadas en tiempo de análisis sintáctico. Consideremos un ejemplo sencillo:




\begin{minted}{julia}
@nexprs 2 j->(i_j = 1)
\end{minted}



\texttt{@nexprs} genera \texttt{n} expresiones que siguen un patrón. Este código generaría las siguientes instrucciones:




\begin{minted}{julia}
i_1 = 1
i_2 = 1
\end{minted}



En cada instrucción generada un \texttt{j} aislado (la variable de la función anónima) es reemplazada por valores en el rango \texttt{1:2}. Hablando de forma general, Cartesian emplea una sintaxis parecida a LaTeX. Esto te permite hacer operaciones sobre el índice \texttt{j}.  He aquí un ejemplo que calcula los pasos de un array:




\begin{minted}{julia}
s_1 = 1
@nexprs 3 j->(s_{j+1} = s_j * size(A, j))
\end{minted}



generará las expresiones




\begin{minted}{julia}
s_1 = 1
s_2 = s_1 * size(A, 1)
s_3 = s_2 * size(A, 2)
s_4 = s_3 * size(A, 3)
\end{minted}



Las expresiones función anónima tienen muchos usos en la práctica.



\hypertarget{908996570436533510}{}


\paragraph{Referencia de las Macros}


\hypertarget{4938945836201444124}{} 
\hyperlink{4938945836201444124}{\texttt{Base.Cartesian.@nloops}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nloops N itersym rangeexpr bodyexpr
@nloops N itersym rangeexpr preexpr bodyexpr
@nloops N itersym rangeexpr preexpr postexpr bodyexpr
\end{lstlisting}

Generate \texttt{N} nested loops, using \texttt{itersym} as the prefix for the iteration variables. \texttt{rangeexpr} may be an anonymous-function expression, or a simple symbol \texttt{var} in which case the range is \texttt{indices(var, d)} for dimension \texttt{d}.

Optionally, you can provide {\textquotedbl}pre{\textquotedbl} and {\textquotedbl}post{\textquotedbl} expressions. These get executed first and last, respectively, in the body of each loop. For example:


\begin{lstlisting}
@nloops 2 i A d -> j_d = min(i_d, 5) begin
    s += @nref 2 A j
end
\end{lstlisting}

would generate:


\begin{lstlisting}
for i_2 = indices(A, 2)
    j_2 = min(i_2, 5)
    for i_1 = indices(A, 1)
        j_1 = min(i_1, 5)
        s += A[j_1, j_2]
    end
end
\end{lstlisting}

If you want just a post-expression, supply \texttt{nothing} for the pre-expression. Using parentheses and semicolons, you can supply multi-statement expressions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L9-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5318613607184308860}{} 
\hyperlink{5318613607184308860}{\texttt{Base.Cartesian.@nref}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nref N A indexexpr
\end{lstlisting}

Generate expressions like \texttt{A[i\_1, i\_2, ...]}. \texttt{indexexpr} can either be an iteration-symbol prefix, or an anonymous-function expression.


\begin{minted}{jlcon}
julia> @macroexpand Base.Cartesian.@nref 3 A i
:(A[i_1, i_2, i_3])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L72-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5592996802344748158}{} 
\hyperlink{5592996802344748158}{\texttt{Base.Cartesian.@nextract}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nextract N esym isym
\end{lstlisting}

Generate \texttt{N} variables \texttt{esym\_1}, \texttt{esym\_2}, ..., \texttt{esym\_N} to extract values from \texttt{isym}. \texttt{isym} can be either a \texttt{Symbol} or anonymous-function expression.

\texttt{@nextract 2 x y} would generate


\begin{lstlisting}
x_1 = y[1]
x_2 = y[2]
\end{lstlisting}

while \texttt{@nextract 3 x d->y[2d-1]} yields


\begin{lstlisting}
x_1 = y[1]
x_2 = y[3]
x_3 = y[5]
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L142-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17386123129446980507}{} 
\hyperlink{17386123129446980507}{\texttt{Base.Cartesian.@nexprs}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nexprs N expr
\end{lstlisting}

Generate \texttt{N} expressions. \texttt{expr} should be an anonymous-function expression.


\begin{minted}{jlcon}
julia> @macroexpand Base.Cartesian.@nexprs 4 i -> y[i] = A[i+j]
quote
    y[1] = A[1 + j]
    y[2] = A[2 + j]
    y[3] = A[3 + j]
    y[4] = A[4 + j]
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L118-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16431416314224139891}{} 
\hyperlink{16431416314224139891}{\texttt{Base.Cartesian.@ncall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@ncall N f sym...
\end{lstlisting}

Generate a function call expression. \texttt{sym} represents any number of function arguments, the last of which may be an anonymous-function expression and is expanded into \texttt{N} arguments.

For example \texttt{@ncall 3 func a} generates


\begin{lstlisting}
func(a_1, a_2, a_3)
\end{lstlisting}

while \texttt{@ncall 2 func a b i->c[i]} yields


\begin{lstlisting}
func(a, b, c[1], c[2])
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L92-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4425932542618492714}{} 
\hyperlink{4425932542618492714}{\texttt{Base.Cartesian.@ntuple}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@ntuple N expr
\end{lstlisting}

Generates an \texttt{N}-tuple. \texttt{@ntuple 2 i} would generate \texttt{(i\_1, i\_2)}, and \texttt{@ntuple 2 k->k+1} would generate \texttt{(2,3)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L215-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5463798602076286002}{} 
\hyperlink{5463798602076286002}{\texttt{Base.Cartesian.@nall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nall N expr
\end{lstlisting}

Check whether all of the expressions generated by the anonymous-function expression \texttt{expr} evaluate to \texttt{true}.

\texttt{@nall 3 d->(i\_d > 1)} would generate the expression \texttt{(i\_1 > 1 \&\& i\_2 > 1 \&\& i\_3 > 1)}. This can be convenient for bounds-checking.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L174-L182}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11114957141394185901}{} 
\hyperlink{11114957141394185901}{\texttt{Base.Cartesian.@nany}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nany N expr
\end{lstlisting}

Check whether any of the expressions generated by the anonymous-function expression \texttt{expr} evaluate to \texttt{true}.

\texttt{@nany 3 d->(i\_d > 1)} would generate the expression \texttt{(i\_1 > 1 || i\_2 > 1 || i\_3 > 1)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L195-L202}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2428714678347040919}{} 
\hyperlink{2428714678347040919}{\texttt{Base.Cartesian.@nif}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nif N conditionexpr expr
@nif N conditionexpr expr elseexpr
\end{lstlisting}

Generates a sequence of \texttt{if ... elseif ... else ... end} statements. For example:


\begin{lstlisting}
@nif 3 d->(i_d >= size(A,d)) d->(error("Dimension ", d, " too big")) d->println("All OK")
\end{lstlisting}

would generate:


\begin{lstlisting}
if i_1 > size(A, 1)
    error("Dimension ", 1, " too big")
elseif i_2 > size(A, 2)
    error("Dimension ", 2, " too big")
else
    println("All OK")
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L230-L247}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11367980138716686905}{}


\section{Talking to the compiler (the \texttt{:meta} mechanism)}



In some circumstances, one might wish to provide hints or instructions that a given block of code has special properties: you might always want to inline it, or you might want to turn on special compiler optimization passes.  Starting with version 0.4, Julia has a convention that these instructions can be placed inside a \texttt{:meta} expression, which is typically (but not necessarily) the first expression in the body of a function.



\texttt{:meta} expressions are created with macros. As an example, consider the implementation of the \texttt{@inline} macro:




\begin{minted}{julia}
macro inline(ex)
    esc(isa(ex, Expr) ? pushmeta!(ex, :inline) : ex)
end
\end{minted}



Here, \texttt{ex} is expected to be an expression defining a function. A statement like this:




\begin{minted}{julia}
@inline function myfunction(x)
    x*(x+3)
end
\end{minted}



gets turned into an expression like this:




\begin{minted}{julia}
quote
    function myfunction(x)
        Expr(:meta, :inline)
        x*(x+3)
    end
end
\end{minted}



\texttt{Base.pushmeta!(ex, :symbol, args...)} appends \texttt{:symbol} to the end of the \texttt{:meta} expression, creating a new \texttt{:meta} expression if necessary. If \texttt{args} is specified, a nested expression containing \texttt{:symbol} and these arguments is appended instead, which can be used to specify additional information.



To use the metadata, you have to parse these \texttt{:meta} expressions. If your implementation can be performed within Julia, \texttt{Base.popmeta!} is very handy: \texttt{Base.popmeta!(body, :symbol)} will scan a function \emph{body} expression (one without the function signature) for the first \texttt{:meta} expression containing \texttt{:symbol}, extract any arguments, and return a tuple \texttt{(found::Bool, args::Array\{Any\})}. If the metadata did not have any arguments, or \texttt{:symbol} was not found, the \texttt{args} array will be empty.



Not yet provided is a convenient infrastructure for parsing \texttt{:meta} expressions from C++.



\hypertarget{2417900207528599820}{}


\section{SubArrays}



El tipo \texttt{SubArray} de Julia es un contenedor que codifica una {\textquotedbl}vista{\textquotedbl} de un \hyperlink{6514416309183787338}{\texttt{AbstractArray}} padre.  Esta pagina documenta algunos de los principios de diseño e implementación de \texttt{SubArray}.



\hypertarget{15623661382317001704}{}


\subsection{Indexación: indexación cartesiana vs. lineal}



Ampliamente hablando, hay dos formas principales de acceder a los datos en un array. La primera, frecuentemente llamada indexación cartesiana, usa \texttt{N} índices para un \texttt{AbstractArray} \texttt{N} -dimensional. Por ejemlo, una matriz \texttt{A} (bidimensional) puede ser indexada en estilo cartesiano como \texttt{A[i,j]}. El segundo método de indexación, denominado indexación lineal, usa un solo índice incluso para objetos de mayor dimensión. Por ejemplo si \texttt{A = reshape(1:12, 3, 4)}, la expresión \texttt{A[5]} devuelve el valor 5. Julia nos permite combinar estos estilos de indexación: por ejemplo, un array 3d \texttt{A3} puede ser indexado como \texttt{A3[i,j]}, en cuyo caso \texttt{i} es interpretado como un índice cartesiano para la primera dimensión, y \texttt{j} es un índice lineal sobre las dimensiones 2 y 3.



Para los \texttt{Array}s, la indexación lineal apela al formato subyacente de almacenamiento: un array se presenta como un bloque contiguo de memoria, y por tanto el índice lineal es justo el desplazamiento (+1) de la correspondiente entrada relativa al principio del array. Sin embargo, esto no es cierto para muchos otros tipos \texttt{AbstractArray}: ejemplos de ello incluyen \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}}, unos arrays que requieren alguna clase de cálculo (tal como interpolación), y el tipo bajo discusión aquí, \texttt{SubArray}. Para estos tipos, la información subyacente es descrita más naturalmente en términos de índices cartesianos. 



Uno puede convertir manualmente un índice cartesiano a uno lineal con \texttt{sub2ind}, y viceversa usando ìnd2sub\texttt{. Las funciones}getindex\texttt{and}setindex!\texttt{de los tipos}AbstractArray` puden incluir operaciones similares.



Aunque convertir de un índice cartesiano a uno lineal es rápido (es justo una multiplicación y una suma), convertir de un índice lineal a uno cartesiano es muy lento: se basa en la operación \texttt{div}, que es una de las operacions de bajo nivel más lentas que uno puede realizar con una CPU. Por esta razón, cualquier código que trate con tipos \texttt{AbstractArray} está mejor diseñado en términos de indexación cartesiana en lugar de lineal.



\hypertarget{17220314819735693845}{}


\subsection{Reemplazo de Índices}



Considere hacer rebanadas bidimensionales de un array tridimensional:




\begin{minted}{julia}
S1 = view(A, :, 5, 2:6)
S2 = view(A, 5, :, 2:6)
\end{minted}



\texttt{view} elimina las dimensiones {\textquotedbl}singleton{\textquotedbl} (las que están especificadas por un \texttt{Int}), por lo que tanto \texttt{S1} como \texttt{S2} son \texttt{SubArray}s bidimensionales. En consecuencia, el camino natural para indexar esto es con \texttt{S1[i,j]}. Para extraer el valor del array padre \texttt{A}, el enfoque natural es reemplazar \texttt{S1[i,j]} con \texttt{A[i,5,(2:6)[j]]} y \texttt{S2[i,j]} con \texttt{A[5,i,(2:6)[j]]}.



La característica clave del diseño de SubArrays es que este reemplazo de índices puede realizarse sin ninguna sobrecarga en tiempo de ejecución.



\hypertarget{18249743152079865904}{}


\subsection{Diseño de SubArray{\textquotesingle}s}



\hypertarget{14792009757059672765}{}


\subsubsection{Parámetros de Tipo y Campos}



La estrategia adoptada está expresada en la definición del tipo:




\begin{minted}{julia}
struct SubArray{T,N,P,I,L} <: AbstractArray{T,N}
    parent::P
    indexes::I
    offset1::Int       # for linear indexing and pointer, only valid when L==true
    stride1::Int       # used only for linear indexing
    ...
end
\end{minted}



\texttt{SubArray} tiene cinco parámetros de tipo. Los dos primeros son el tipo de elemento estándar y la dimensionalidad. La siguiente es el tipo del \texttt{AbstractArray} padre. El usado más intensamente es el cuarto parámetro, una \texttt{Tuple} de los tipos de los índices para cada dimensión. El final, \texttt{L},  es sólo proporcionado como una conveniencia para el despacho; es un valor booleano que representa si los tipos del índice soportan indexacion lineal rápida. Más sobre este tema después.  



Si en nuestro ejemplo de arriba \texttt{A} es un \texttt{Array\{Float64, 3\}}, nuestro caso \texttt{S1} sería un  \texttt{SubArray\{Int64,2,Array\{Int64,3\},Tuple\{Colon,Int64,UnitRange\{Int64\}\},false\}}. Note en particular el parámetro tupla, que almacena los tipos de los índices usados para crear \texttt{S1}.  Igualmente,




\begin{minted}{jlcon}
julia> S1.indexes
(Colon(),5,2:6)
\end{minted}



Almacenar estos valores permite el reemplzao de índices, y tener los tipos codificados como parámetros permite a uno despachar a eficientes algoritmos.



\hypertarget{17922439712142437324}{}


\subsubsection{Traducción de Índices}



Realizar la traducción de índices requiere que uno haga diferentes cosas para diferentes tipos concretos de \texttt{SubArray}. Por ejemplo, para \texttt{S1} uno necesita aplicar los índices \texttt{i,j} a las dimensiones primera y tercera del array padre, mientras que para \texttt{S2} uno necesita aplicarlas a la segunda y la tercera. El enfoque más sencillo a indexar sería hacer el análisis de tipos en tiempo de ejecución:




\begin{minted}{julia}
parentindexes = Array{Any}(0)
for thisindex in S.indexes
    ...
    if isa(thisindex, Int)
        # Don't consume one of the input indexes
        push!(parentindexes, thisindex)
    elseif isa(thisindex, AbstractVector)
        # Consume an input index
        push!(parentindexes, thisindex[inputindex[j]])
        j += 1
    elseif isa(thisindex, AbstractMatrix)
        # Consume two input indices
        push!(parentindexes, thisindex[inputindex[j], inputindex[j+1]])
        j += 2
    elseif ...
end
S.parent[parentindexes...]
\end{minted}



Desgraciadamente, esto sería desastroso en términos de rendimiento: cada acceso a elemento asignaría memoria, e implicaría la ejecución de un montón de código pobremente tipado.



El mejor enfoque es despachar a métodos específicos para manejar cada tipo de índice almacenado. Esto es lo que hace \texttt{reindex}: él despacha sobre el tipo del primer índice almacenado y consume el número apropiado de índices de entrada, y entonces recurre sobre los índices restantes. En el caso de \texttt{S1}, esto expande a




\begin{minted}{julia}
Base.reindex(S1, S1.indexes, (i, j)) == (i, S1.indexes[2], S1.indexes[3][j])
\end{minted}



para cualquier par de índices \texttt{(i,j)} (excepto \texttt{CartesianIndex}s and arrays de este tipo, ver abajo).



Este es el núcleo de un \texttt{SubArray}; los métodos de indexación se basan en \texttt{reindex} para hacer esta traducción de índices. Sin embargo, algunas veces, podemos evitar la indirección y hacerlo incluso más rápido.



\hypertarget{1218543499264087968}{}


\subsubsection{Indexación Lineal}



La indexación lineal puede implementarse de forma eficiente cuando el array completo tiene un solo paso que separe elementos sucesivos, empezando desde cierto desplazamiento. Esto significa que nosotros pre-computamos estos valores y representamos la indexación lineal simplemente como una adición y multiplicación, evitando la indirección de \texttt{reindex} y (lo que es más importante) la computación lenta de las coordenadas cartesianas por completo.



Para los tipos \texttt{SubArray}, la disponibilidad de una indexación lineal eficiente está basada puramente en los tipos de los índices, y no depende de valores como el tamaño de array padre. Uno puede preguntar si un cnjunto de índices dado soporta indexación lineal rápida con la función interna \texttt{Base.viewindexing}:




\begin{minted}{jlcon}
julia> Base.viewindexing(S1.indexes)
IndexCartesian()

julia> Base.viewindexing(S2.indexes)
IndexLinear()
\end{minted}



Esto se calcula durante la construcción del \texttt{SubArray} y se almacena en el parámetro de tipo \texttt{L} como un boolean que codifica soporte de indexación lineal rápido. Aunque n oes estrictamente necesario, esto significa qeu podemos definir despacho directamente sobre \texttt{SubArray\{T,N,A,I,true\}} sin intermediarios.



Como esta computación no depende de valores en tiempo de ejecución, puede perder algunos casos en los que el paso sea uniforme:




\begin{minted}{jlcon}
julia> A = reshape(1:4*2, 4, 2)
4×2 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5
 2  6
 3  7
 4  8

julia> diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 2
 2
\end{minted}



Una vista construída como \texttt{view(A, 2:2:4, :)} tiene un paso uniforme y, por tanto la indexación lineal podría llevarse a cabo eficientemente. Sin embargo, el éxito en este caso depende del tamaño del array: Si, a diferencia del caso anterior, la primera dimensión fuera impar,




\begin{minted}{jlcon}
julia> A = reshape(1:5*2, 5, 2)
5×2 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1   6
 2   7
 3   8
 4   9
 5  10

julia> diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 3
 2
\end{minted}



entonces \texttt{A[2:2:4,:]} no tiene un paso uniforme, por lo que no podemos garantizar indexación lineal eficiente. Como tenemos que basar esta decisión puramente en los tipos codificados en los parámetros del \texttt{SubArray}, \texttt{S = view(A, 2:2:4, :)} no puede implementar una indexación lienal eficiente.



\hypertarget{17772741150475392067}{}


\subsubsection{Unos pocos detalles}



\begin{itemize}
\item Note que la función \texttt{Base.reindex} es agnóstica a los tipos de los índices de entrada; ella simplemente determina como y donde deberían reindexarse los indices almacenados. Ella no solo soporta indices enteros,

\end{itemize}


 sino que también soporta indexación no escalar. Esto significa que las vistas de vistas no necesitan dos    niveles de indirección; ellas pueden simplemente recomputar los índices en el array padre original.  



\begin{itemize}
\item Es de esperar que a estas alturas esté bastante claro que soportar rebanadas en arrays significa que la dimensionalidad, dada por el parámetro \texttt{N}, no es necesariamente igual a la dimensionalidad del array padre o la longitud de la tupla \texttt{indexes}. Tampoco los índices proporcionados por el usuario se alinean necesariamente con las entradas en la tupla \texttt{indexes} (por ejemplo, el segundo índice proporcionado por el usuario puede corresponder a la tercera dimensión de la matriz padre, y el tercer elemento en la tupla \texttt{indexes}).

Lo que podría ser menos obvio es que la dimensionalidad del array padre almacenado sea igual al número de  índices efectivos en la tupla \texttt{indexes}. Algunos ejemplos:


\begin{minted}{julia}
A = reshape(1:35, 5, 7) # A 2d parent Array
S = view(A, 2:7)         # A 1d view created by linear indexing
S = view(A, :, :, 1:1)   # Appending extra indices is supported
\end{minted}

Ingenuamente, uno pensaría que podría simplemente establecer \texttt{S.parent = A} y\texttt{S.indexes = (:,:, 1: 1)},  pero el hecho de soportar esto complica dramáticamente el proceso de reindexación, especialmente para  vistas de vistas. No solo se necesita despachar los tipos de los índices almacenados, sino que se debe  examinar si un índice dado es el último y {\textquotedbl}fusionar{\textquotedbl} los índices almacenados restantes. Esto no es una  tarea fácil, y aún peor: es lenta ya que depende implícitamente de la indexación lineal.

Afortunadamente, este es precisamente el cálculo que {\textquotesingle}ReshapedArray{\textquotesingle} realiza, y lo hace linealmente si es posible. En consecuencia, \texttt{view} asegura que el array padre es la dimensionalidad adecuada para los  índices dados mediante reformateo (\emph{reshaping}) si es necesario. El constructor interno \texttt{SubArray}  asegura que este invariante esté satisfecha.


\item \texttt{CartesianIndex} y sus matrices retuercen de una forma desagradable el esquema \texttt{reindex}. Recuerde  que \texttt{reindex} simplemente despacha sobre el tipo de índices almacenados para determinar cuántos  índices pasados deberían usarse y a dónde deberían ir. Pero con \texttt{CartesianIndex}, ya no hay una  correspondencia uno a uno entre la cantidad de argumentos pasados y la cantidad de dimensiones en  las que indexan. Si volvemos al ejemplo anterior de \texttt{Base.reindex(S1, S1.indexes, (i, j))}, puede  ver que la expansión es incorrecta para \texttt{i, j = CartesianIndex (), CartesianIndex (2,1 )}. Él  debería \emph{salta} el \texttt{CartesianIndex()} por completo y devolver:


\begin{minted}{julia}
(CartesianIndex(2,1)[1], S1.indexes[2], S1.indexes[3][CartesianIndex(2,1)[2]])
\end{minted}

Y si embargo, lo que devuelve es:


\begin{minted}{julia}
(CartesianIndex(), S1.indexes[2], S1.indexes[3][CartesianIndex(2,1)])
\end{minted}

Hacer esto correctamente requeriría el envío \emph{combinado} en los índices almacenados y pasados en  todas las combinaciones de dimensionalidades de una manera intratable. Como tal, \texttt{reindex} nunca  debe invocarse con índices \texttt{CartesianIndex}. Afortunadamente, el caso escalar se maneja fácilmente  aplanando primero los argumentos \texttt{CartesianIndex} a enteros simples. Sin embargo, las matrices de  \texttt{CartesianIndex} no se pueden dividir en piezas ortogonales tan fácilmente. Antes de intentar usar  \texttt{reindex},\texttt{view} debe garantizar que no haya matrices de \texttt{CartesianIndex} en la lista de argumentos.  Si los hay, simplemente puede {\textquotedbl}puntualizar{\textquotedbl} evitando por completo el cálculo de {\textquotesingle}reindex{\textquotesingle}, construyendo  un \texttt{SubArray} anidado con dos niveles de indirección en su lugar.

\end{itemize}


\hypertarget{4435767086673027446}{}


\section{System Image Building}



\hypertarget{13880852207471486494}{}


\subsection{Building the Julia system image}



Julia ships with a preparsed system image containing the contents of the \texttt{Base} module, named \texttt{sys.ji}.  This file is also precompiled into a shared library called \texttt{sys.\{so,dll,dylib\}} on as many platforms as possible, so as to give vastly improved startup times.  On systems that do not ship with a precompiled system image file, one can be generated from the source files shipped in Julia{\textquotesingle}s \texttt{DATAROOTDIR/julia/base} folder.



This operation is useful for multiple reasons.  A user may:



\begin{itemize}
\item Build a precompiled shared library system image on a platform that did not ship with one, thereby improving startup times.


\item Modify \texttt{Base}, rebuild the system image and use the new \texttt{Base} next time Julia is started.


\item Include a \texttt{userimg.jl} file that includes packages into the system image, thereby creating a system image that has packages embedded into the startup environment.

\end{itemize}


Julia now ships with a script that automates the tasks of building the system image, wittingly named \texttt{build\_sysimg.jl} that lives in \texttt{DATAROOTDIR/julia/}.  That is, to include it into a current Julia session, type:




\begin{minted}{julia}
include(joinpath(JULIA_HOME, Base.DATAROOTDIR, "julia", "build_sysimg.jl"))
\end{minted}



This will include a \texttt{build\_sysimg()} function:


\hypertarget{6550638812051289176}{} 
\hyperlink{6550638812051289176}{\texttt{BuildSysImg.build\_sysimg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
build_sysimg(sysimg_path=default_sysimg_path(), cpu_target="native", userimg_path=nothing; force=false)
\end{lstlisting}

Rebuild the system image. Store it in \texttt{sysimg\_path}, which defaults to a file named \texttt{sys.ji} that sits in the same folder as \texttt{libjulia.\{so,dylib\}}, except on Windows where it defaults to \texttt{JULIA\_HOME/../lib/julia/sys.ji}.  Use the cpu instruction set given by \texttt{cpu\_target}. Valid CPU targets are the same as for the \texttt{-C} option to \texttt{julia}, or the \texttt{-march} option to \texttt{gcc}.  Defaults to \texttt{native}, which means to use all CPU instructions available on the current processor. Include the user image file given by \texttt{userimg\_path}, which should contain directives such as \texttt{using MyPackage} to include that package in the new system image. New system image will not replace an older image unless \texttt{force} is set to true.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/../contrib/build_sysimg.jl#L15-L26}{\texttt{source}}


\end{adjustwidth}

Note that this file can also be run as a script itself, with command line arguments taking the place of arguments passed to the \texttt{build\_sysimg} function.  For example, to build a system image in \texttt{/tmp/sys.\{so,dll,dylib\}}, with the \texttt{core2} CPU instruction set, a user image of \texttt{{\textasciitilde}/userimg.jl} and \texttt{force} set to \texttt{true}, one would execute:




\begin{lstlisting}
julia build_sysimg.jl /tmp/sys core2 ~/userimg.jl --force
\end{lstlisting}



\hypertarget{15676237889045834434}{}


\section{Working with LLVM}



This is not a replacement for the LLVM documentation, but a collection of tips for working on LLVM for Julia.



\hypertarget{8956364453365125987}{}


\subsection{Overview of Julia to LLVM Interface}



Julia statically links in LLVM by default. Build with \texttt{USE\_LLVM\_SHLIB=1} to link dynamically.



The code for lowering Julia AST to LLVM IR or interpreting it directly is in directory \texttt{src/}.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
File & Description \\
\hline
\texttt{builtins.c} & Builtin functions \\
\hline
\texttt{ccall.cpp} & Lowering \texttt{ccall} \\
\hline
\texttt{cgutils.cpp} & Lowering utilities, notably for array and tuple accesses \\
\hline
\texttt{codegen.cpp} & Top-level of code generation, pass list, lowering builtins \\
\hline
\texttt{debuginfo.cpp} & Tracks debug information for JIT code \\
\hline
\texttt{disasm.cpp} & Handles native object file and JIT code diassembly \\
\hline
\texttt{gf.c} & Generic functions \\
\hline
\texttt{intrinsics.cpp} & Lowering intrinsics \\
\hline
\texttt{llvm-simdloop.cpp} & Custom LLVM pass for \texttt{@simd} \\
\hline
\texttt{sys.c} & I/O and operating system utility functions \\
\hline
\end{tabulary}

\end{table}



Some of the \texttt{.cpp} files form a group that compile to a single object.



The difference between an intrinsic and a builtin is that a builtin is a first class function that can be used like any other Julia function.  An intrinsic can operate only on unboxed data, and therefore its arguments must be statically typed.



\hypertarget{8366324567299313031}{}


\subsubsection{Alias Analysis}



Julia currently uses LLVM{\textquotesingle}s \href{http://llvm.org/docs/LangRef.html\#tbaa-metadata}{Type Based Alias Analysis}. To find the comments that document the inclusion relationships, look for \texttt{static MDNode*} in \texttt{src/codegen.cpp}.



The \texttt{-O} option enables LLVM{\textquotesingle}s \href{http://llvm.org/docs/AliasAnalysis.html\#the-basicaa-pass}{Basic Alias Analysis}.



\hypertarget{13120458447023898074}{}


\subsection{Building Julia with a different version of LLVM}



The default version of LLVM is specified in \texttt{deps/Versions.make}. You can override it by creating a file called \texttt{Make.user} in the top-level directory and adding a line to it such as:




\begin{lstlisting}
LLVM_VER = 3.5.0
\end{lstlisting}



Besides the LLVM release numerals, you can also use \texttt{LLVM\_VER = svn} to bulid against the latest development version of LLVM.



\hypertarget{3429896864083237221}{}


\subsection{Passing options to LLVM}



You can pass options to LLVM using \emph{debug} builds of Julia.  To create a debug build, run \texttt{make debug}.  The resulting executable is \texttt{usr/bin/julia-debug}. You can pass LLVM options to this executable via the environment variable \texttt{JULIA\_LLVM\_ARGS}. Here are example settings using \texttt{bash} syntax:



\begin{itemize}
\item \texttt{export JULIA\_LLVM\_ARGS = -print-after-all} dumps IR after each pass.


\item \texttt{export JULIA\_LLVM\_ARGS = -debug-only=loop-vectorize} dumps LLVM \texttt{DEBUG(...)} diagnostics for loop vectorizer \emph{if} you built Julia with \texttt{LLVM\_ASSERTIONS=1}. Otherwise you will get warnings about {\textquotedbl}Unknown command line argument{\textquotedbl}. Counter-intuitively, building Julia with \texttt{LLVM\_DEBUG=1} is \emph{not} enough to dump \texttt{DEBUG} diagnostics from a pass.

\end{itemize}


\hypertarget{18346154193244616171}{}


\subsection{Improving LLVM optimizations for Julia}



Improving LLVM code generation usually involves either changing Julia lowering to be more friendly to LLVM{\textquotesingle}s passes, or improving a pass.



If you are planning to improve a pass, be sure to read the \href{http://llvm.org/docs/DeveloperPolicy.html}{LLVM developer policy}. The best strategy is to create a code example in a form where you can use LLVM{\textquotesingle}s \texttt{opt} tool to study it and the pass of interest in isolation.



\begin{itemize}
\item[1. ] Create an example Julia code of interest.


\item[2. ] Use \texttt{JULIA\_LLVM\_ARGS = -print-after-all} to dump the IR.


\item[3. ] Pick out the IR at the point just before the pass of interest runs.


\item[4. ] Strip the debug metadata and fix up the TBAA metadata by hand.

\end{itemize}


The last step is labor intensive.  Suggestions on a better way would be appreciated.



\hypertarget{15255383527079538908}{}


\section{printf() and stdio in the Julia runtime}



\hypertarget{11306377068338291950}{}


\subsection{Libuv wrappers for stdio}



\texttt{julia.h} defines \href{http://docs.libuv.org}{libuv} wrappers for the \texttt{stdio.h} streams:




\begin{lstlisting}
uv_stream_t *JL_STDIN;
uv_stream_t *JL_STDOUT;
uv_stream_t *JL_STDERR;
\end{lstlisting}



... and corresponding output functions:




\begin{lstlisting}
int jl_printf(uv_stream_t *s, const char *format, ...);
int jl_vprintf(uv_stream_t *s, const char *format, va_list args);
\end{lstlisting}



These \texttt{printf} functions are used by the \texttt{.c} files in the \texttt{src/} and \texttt{ui/} directories wherever stdio is needed to ensure that output buffering is handled in a unified way.



In special cases, like signal handlers, where the full libuv infrastructure is too heavy, \texttt{jl\_safe\_printf()} can be used to \hyperlink{16947913578760238729}{\texttt{write(2)}} directly to \texttt{STDERR\_FILENO}:




\begin{lstlisting}
void jl_safe_printf(const char *str, ...);
\end{lstlisting}



\hypertarget{9919396910097555458}{}


\subsection{Interface between JL\_STD* and Julia code}



\hyperlink{13806523663202420575}{\texttt{Base.STDIN}}, \hyperlink{2784333101804678420}{\texttt{Base.STDOUT}} and \hyperlink{4481879903628924306}{\texttt{Base.STDERR}} are bound to the \texttt{JL\_STD*} libuv streams defined in the runtime.



Julia{\textquotesingle}s \texttt{\_\_init\_\_()} function (in \texttt{base/sysimg.jl}) calls \texttt{reinit\_stdio()} (in \texttt{base/stream.jl}) to create Julia objects for \hyperlink{13806523663202420575}{\texttt{Base.STDIN}}, \hyperlink{2784333101804678420}{\texttt{Base.STDOUT}} and \hyperlink{4481879903628924306}{\texttt{Base.STDERR}}.



\texttt{reinit\_stdio()} uses \hyperlink{14245046751182637566}{\texttt{ccall}} to retrieve pointers to \texttt{JL\_STD*} and calls \texttt{jl\_uv\_handle\_type()} to inspect the type of each stream.  It then creates a Julia \texttt{Base.IOStream}, \texttt{Base.TTY} or \texttt{Base.PipeEndpoint} object to represent each stream, e.g.:




\begin{lstlisting}
$ julia -e 'println(typeof((STDIN, STDOUT, STDERR)))'
Tuple{Base.TTY,Base.TTY,Base.TTY}

$ julia -e 'println(typeof((STDIN, STDOUT, STDERR)))' < /dev/null 2>/dev/null
Tuple{IOStream,Base.TTY,IOStream}

$ echo hello | julia -e 'println(typeof((STDIN, STDOUT, STDERR)))' | cat
Tuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}
\end{lstlisting}



The \hyperlink{8104134490906192097}{\texttt{Base.read()}} and \hyperlink{16947913578760238729}{\texttt{Base.write()}} methods for these streams use \hyperlink{14245046751182637566}{\texttt{ccall}} to call libuv wrappers in \texttt{src/jl\_uv.c}, e.g.:




\begin{lstlisting}
stream.jl: function write(s::IO, p::Ptr, nb::Integer)
               -> ccall(:jl_uv_write, ...)
  jl_uv.c:          -> int jl_uv_write(uv_stream_t *stream, ...)
                        -> uv_write(uvw, stream, buf, ...)
\end{lstlisting}



\hypertarget{10878739879441287330}{}


\subsection{printf() during initialization}



The libuv streams relied upon by \texttt{jl\_printf()} etc., are not available until midway through initialization of the runtime (see \texttt{init.c}, \texttt{init\_stdio()}).  Error messages or warnings that need to be printed before this are routed to the standard C library \texttt{fwrite()} function by the following mechanism:



In \texttt{sys.c}, the \texttt{JL\_STD*} stream pointers are statically initialized to integer constants: \texttt{STD*\_FILENO (0, 1 and 2)}. In \texttt{jl\_uv.c} the \texttt{jl\_uv\_puts()} function checks its \texttt{uv\_stream\_t* stream} argument and calls \texttt{fwrite()} if stream is set to \texttt{STDOUT\_FILENO} or \texttt{STDERR\_FILENO}.



This allows for uniform use of \texttt{jl\_printf()} throughout the runtime regardless of whether or not any particular piece of code is reachable before initialization is complete.



\hypertarget{15406109399506022628}{}


\subsection{Legacy \texttt{ios.c} library}



The \texttt{src/support/ios.c} library is inherited from \href{https://github.com/JeffBezanson/femtolisp}{femtolisp}. It provides cross-platform buffered file IO and in-memory temporary buffers.



\texttt{ios.c} is still used by:



\begin{itemize}
\item \texttt{src/flisp/*.c}


\item \texttt{src/dump.c} – for serialization file IO and for memory buffers.


\item \texttt{base/iostream.jl} – for file IO (see \texttt{base/fs.jl} for libuv equivalent).

\end{itemize}


Use of \texttt{ios.c} in these modules is mostly self-contained and separated from the libuv I/O system. However, there is \href{https://github.com/JuliaLang/julia/blob/master/src/flisp/print.c\#L654}{one place} where femtolisp calls through to \texttt{jl\_printf()} with a legacy \texttt{ios\_t} stream.



There is a hack in \texttt{ios.h} that makes the \texttt{ios\_t.bm} field line up with the \texttt{uv\_stream\_t.type} and ensures that the values used for \texttt{ios\_t.bm} to not overlap with valid \texttt{UV\_HANDLE\_TYPE} values.  This allows \texttt{uv\_stream\_t} pointers to point to \texttt{ios\_t} streams.



This is needed because \texttt{jl\_printf()} caller \texttt{jl\_static\_show()} is passed an \texttt{ios\_t} stream by femtolisp{\textquotesingle}s \texttt{fl\_print()} function. Julia{\textquotesingle}s \texttt{jl\_uv\_puts()} function has special handling for this:




\begin{lstlisting}
if (stream->type > UV_HANDLE_TYPE_MAX) {
    return ios_write((ios_t*)stream, str, n);
}
\end{lstlisting}



\hypertarget{15203641602433735164}{}


\section{Bounds checking}



Like many modern programming languages, Julia uses bounds checking to ensure program safety when accessing arrays. In tight inner loops or other performance critical situations, you may wish to skip these bounds checks to improve runtime performance. For instance, in order to emit vectorized (SIMD) instructions, your loop body cannot contain branches, and thus cannot contain bounds checks. Consequently, Julia includes an \texttt{@inbounds(...)} macro to tell the compiler to skip such bounds checks within the given block. For the built-in \texttt{Array} type, the magic happens inside the \texttt{arrayref} and \texttt{arrayset} intrinsics. User-defined array types instead use the \texttt{@boundscheck(...)} macro to achieve context-sensitive code selection.



\hypertarget{15977328606651213476}{}


\subsection{Eliding bounds checks}



The \texttt{@boundscheck(...)} macro marks blocks of code that perform bounds checking. When such blocks appear inside of an \texttt{@inbounds(...)} block, the compiler removes these blocks. When the \texttt{@boundscheck(...)} is nested inside of a calling function containing an \texttt{@inbounds(...)}, the compiler will remove the \texttt{@boundscheck} block \emph{only if it is inlined} into the calling function. For example, you might write the method \texttt{sum} as:




\begin{minted}{julia}
function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end
\end{minted}



With a custom array-like type \texttt{MyArray} having:




\begin{minted}{julia}
@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A,i); A.data[to_index(i)])
\end{minted}



Then when \texttt{getindex} is inlined into \texttt{sum}, the call to \texttt{checkbounds(A,i)} will be elided. If your function contains multiple layers of inlining, only \texttt{@boundscheck} blocks at most one level of inlining deeper are eliminated. The rule prevents unintended changes in program behavior from code further up the stack.



\hypertarget{10208484018202603417}{}


\subsection{Propagating inbounds}



There may be certain scenarios where for code-organization reasons you want more than one layer between the \texttt{@inbounds} and \texttt{@boundscheck} declarations. For instance, the default \texttt{getindex} methods have the chain \texttt{getindex(A::AbstractArray, i::Real)} calls \texttt{getindex(IndexStyle(A), A, i)} calls \texttt{\_getindex(::IndexLinear, A, i)}.



To override the {\textquotedbl}one layer of inlining{\textquotedbl} rule, a function may be marked with \texttt{@propagate\_inbounds} to propagate an inbounds context (or out of bounds context) through one additional layer of inlining.



\hypertarget{17261866997775737461}{}


\subsection{The bounds checking call hierarchy}



The overall hierarchy is:



\begin{itemize}
\item \texttt{checkbounds(A, I...)} which calls

\begin{itemize}
\item \texttt{checkbounds(Bool, A, I...)} which calls

\begin{itemize}
\item \texttt{checkbounds\_indices(Bool, indices(A), I)} which recursively calls

\begin{itemize}
\item \texttt{checkindex} for each dimension

\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}


Here \texttt{A} is the array, and \texttt{I} contains the {\textquotedbl}requested{\textquotedbl} indices. \texttt{indices(A)} returns a tuple of {\textquotedbl}permitted{\textquotedbl} indices of \texttt{A}.



\texttt{checkbounds(A, I...)} throws an error if the indices are invalid, whereas \texttt{checkbounds(Bool, A, I...)} returns \texttt{false} in that circumstance.  \texttt{checkbounds\_indices} discards any information about the array other than its \texttt{indices} tuple, and performs a pure indices-vs-indices comparison: this allows relatively few compiled methods to serve a huge variety of array types. Indices are specified as tuples, and are usually compared in a 1-1 fashion with individual dimensions handled by calling another important function, \texttt{checkindex}: typically,




\begin{minted}{julia}
checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &
                                                      checkbounds_indices(Bool, IA, I)
\end{minted}



so \texttt{checkindex} checks a single dimension.  All of these functions, including the unexported \texttt{checkbounds\_indices} have docstrings accessible with \texttt{?} .



If you have to customize bounds checking for a specific array type, you should specialize \texttt{checkbounds(Bool, A, I...)}. However, in most cases you should be able to rely on \texttt{checkbounds\_indices} as long as you supply useful \texttt{indices} for your array type.



If you have novel index types, first consider specializing \texttt{checkindex}, which handles a single index for a particular dimension of an array.  If you have a custom multidimensional index type (similar to \texttt{CartesianIndex}), then you may have to consider specializing \texttt{checkbounds\_indices}.



Note this hierarchy has been designed to reduce the likelihood of method ambiguities.  We try to make \texttt{checkbounds} the place to specialize on array type, and try to avoid specializations on index types; conversely, \texttt{checkindex} is intended to be specialized only on index type (especially, the last argument).



\hypertarget{16029610522337323518}{}


\section{Proper maintenance and care of multi-threading locks}



The following strategies are used to ensure that the code is dead-lock free (generally by addressing the 4th Coffman condition: circular wait).



\begin{quote}
\begin{itemize}
\item[1. ] structure code such that only one lock will need to be acquired at a time


\item[2. ] always acquire shared locks in the same order, as given by the table below


\item[3. ] avoid constructs that expect to need unrestricted recursion

\end{itemize}
\end{quote}


\hypertarget{13071695811965191352}{}


\subsection{Locks}



Below are all of the locks that exist in the system and the mechanisms for using them that avoid the potential for deadlocks (no Ostrich algorithm allowed here):



The following are definitely leaf locks (level 1), and must not try to acquire any other lock:



\begin{quote}
\begin{itemize}
\item safepoint

\begin{quote}
Note that this lock is acquired implicitly by \texttt{JL\_LOCK} and \texttt{JL\_UNLOCK}. use the \texttt{\_NOGC} variants to avoid that for level 1 locks.

While holding this lock, the code must not do any allocation or hit any safepoints. Note that there are safepoints when doing allocation, enabling / disabling GC, entering / restoring exception frames, and taking / releasing locks.

\end{quote}

\item shared\_map


\item finalizers


\item pagealloc


\item gc\_perm\_lock


\item flisp

\begin{quote}
flisp itself is already threadsafe, this lock only protects the \texttt{jl\_ast\_context\_list\_t} pool

\end{quote}
\end{itemize}
\end{quote}


The following is a leaf lock (level 2), and only acquires level 1 locks (safepoint) internally:



\begin{quote}
\begin{itemize}
\item typecache

\end{itemize}
\end{quote}


The following is a level 3 lock, which can only acquire level 1 or level 2 locks internally:



\begin{quote}
\begin{itemize}
\item Method->writelock

\end{itemize}
\end{quote}


The following is a level 4 lock, which can only recurse to acquire level 1, 2, or 3 locks:



\begin{quote}
\begin{itemize}
\item MethodTable->writelock

\end{itemize}
\end{quote}


No Julia code may be called while holding a lock above this point.



The following is a level 6 lock, which can only recurse to acquire locks at lower levels:



\begin{quote}
\begin{itemize}
\item codegen

\end{itemize}
\end{quote}


The following is an almost root lock (level end-1), meaning only the root look may be held when trying to acquire it:



\begin{quote}
\begin{itemize}
\item typeinf

\begin{quote}
this one is perhaps one of the most tricky ones, since type-inference can be invoked from many points

currently the lock is merged with the codegen lock, since they call each other recursively

\end{quote}
\end{itemize}
\end{quote}


The following is the root lock, meaning no other lock shall be held when trying to acquire it:



\begin{quote}
\begin{itemize}
\item toplevel

\begin{quote}
this should be held while attempting a top-level action (such as making a new type or defining a new method): trying to obtain this lock inside a staged function will cause a deadlock condition!

additionally, it{\textquotesingle}s unclear if \emph{any} code can safely run in parallel with an arbitrary toplevel expression, so it may require all threads to get to a safepoint first

\end{quote}
\end{itemize}
\end{quote}


\hypertarget{9065842407229995149}{}


\subsection{Broken Locks}



The following locks are broken:



\begin{itemize}
\item toplevel

\begin{quote}
doesn{\textquotesingle}t exist right now

fix: create it

\end{quote}
\end{itemize}


\hypertarget{1067922422509615580}{}


\subsection{Shared Global Data Structures}



These data structures each need locks due to being shared mutable global state. It is the inverse list for the above lock priority list. This list does not include level 1 leaf resources due to their simplicity.



MethodTable modifications (def, cache, kwsorter type) : MethodTable->writelock



Type declarations : toplevel lock



Type application : typecache lock



Module serializer : toplevel lock



JIT \& type-inference : codegen lock



MethodInstance updates : codegen lock



\begin{quote}
\begin{itemize}
\item These fields are generally lazy initialized, using the test-and-test-and-set pattern.


\item These are set at construction and immutable:

\begin{itemize}
\item specTypes


\item sparam\_vals


\item def

\end{itemize}

\item These are set by \texttt{jl\_type\_infer} (while holding codegen lock):

\begin{itemize}
\item rettype


\item inferred


\item these can also be reset, see \texttt{jl\_set\_lambda\_rettype} for that logic as it needs to keep \texttt{functionObjectsDecls} in sync

\end{itemize}

\item \texttt{inInference} flag:

\begin{itemize}
\item optimization to quickly avoid recurring into \texttt{jl\_type\_infer} while it is already running


\item actual state (of setting \texttt{inferred}, then \texttt{fptr}) is protected by codegen lock

\end{itemize}

\item Function pointers (\texttt{jlcall\_api} and \texttt{fptr}, \texttt{unspecialized\_ducttape}):

\begin{itemize}
\item these transition once, from \texttt{NULL} to a value, while the codegen lock is held

\end{itemize}

\item Code-generator cache (the contents of \texttt{functionObjectsDecls}):

\begin{itemize}
\item these can transition multiple times, but only while the codegen lock is held


\item it is valid to use old version of this, or block for new versions of this, so races are benign, as long as the code is careful not to reference other data in the method instance (such as \texttt{rettype}) and assume it is coordinated, unless also holding the codegen lock

\end{itemize}

\item \texttt{compile\_traced} flag:

\begin{itemize}
\item unknown

\end{itemize}
\end{itemize}
\end{quote}


LLVMContext : codegen lock



Method : Method->writelock



\begin{itemize}
\item roots array (serializer and codegen)


\item invoke / specializations / tfunc modifications

\end{itemize}


\hypertarget{12792533311031776054}{}


\section{Arrays with custom indices}



Julia 0.5 adds experimental support for arrays with arbitrary indices. Conventionally, Julia{\textquotesingle}s arrays are indexed starting at 1, whereas some other languages start numbering at 0, and yet others (e.g., Fortran) allow you to specify arbitrary starting indices.  While there is much merit in picking a standard (i.e., 1 for Julia), there are some algorithms which simplify considerably if you can index outside the range \texttt{1:size(A,d)} (and not just \texttt{0:size(A,d)-1}, either). Such array types are expected to be supplied through packages.



The purpose of this page is to address the question, {\textquotedbl}what do I have to do to support such arrays in my own code?{\textquotedbl}  First, let{\textquotesingle}s address the simplest case: if you know that your code will never need to handle arrays with unconventional indexing, hopefully the answer is {\textquotedbl}nothing.{\textquotedbl} Old code, on conventional arrays, should function essentially without alteration as long as it was using the exported interfaces of Julia.



\hypertarget{12133789893433293548}{}


\subsection{Generalizing existing code}



As an overview, the steps are:



\begin{itemize}
\item replace many uses of \texttt{size} with \texttt{indices}


\item replace \texttt{1:length(A)} with \texttt{linearindices(A)}, and \texttt{length(A)} with \texttt{length(linearindices(A))}


\item replace explicit allocations like \texttt{Array\{Int\}(size(B))} with \texttt{similar(Array\{Int\}, indices(B))}

\end{itemize}


These are described in more detail below.



\hypertarget{5370755282098388224}{}


\subsubsection{Background}



Because unconventional indexing breaks deeply-held assumptions throughout the Julia ecosystem, early adopters running code that has not been updated are likely to experience errors.  The most frustrating bugs would be incorrect results or segfaults (total crashes of Julia).  For example, consider the following function:




\begin{minted}{julia}
function mycopy!(dest::AbstractVector, src::AbstractVector)
    length(dest) == length(src) || throw(DimensionMismatch("vectors must match"))
    # OK, now we're safe to use @inbounds, right? (not anymore!)
    for i = 1:length(src)
        @inbounds dest[i] = src[i]
    end
    dest
end
\end{minted}



This code implicitly assumes that vectors are indexed from 1. Previously that was a safe assumption, so this code was fine, but (depending on what types the user passes to this function) it may no longer be safe.  If this code continued to work when passed a vector with non-1 indices, it would either produce an incorrect answer or it would segfault.  (If you do get segfaults, to help locate the cause try running julia with the option \texttt{--check-bounds=yes}.)



To ensure that such errors are caught, in Julia 0.5 both \texttt{length} and \texttt{size}\textbf{should} throw an error when passed an array with non-1 indexing.  This is designed to force users of such arrays to check the code, and inspect it for whether it needs to be generalized.



\hypertarget{10703643701647439456}{}


\subsubsection{Using \texttt{indices} for bounds checks and loop iteration}



\texttt{indices(A)} (reminiscent of \texttt{size(A)}) returns a tuple of \texttt{AbstractUnitRange} objects, specifying the range of valid indices along each dimension of \texttt{A}.  When \texttt{A} has unconventional indexing, the ranges may not start at 1.  If you just want the range for a particular dimension \texttt{d}, there is \texttt{indices(A, d)}.



Base implements a custom range type, \texttt{OneTo}, where \texttt{OneTo(n)} means the same thing as \texttt{1:n} but in a form that guarantees (via the type system) that the lower index is 1. For any new \hyperlink{6514416309183787338}{\texttt{AbstractArray}} type, this is the default returned by \texttt{indices}, and it indicates that this array type uses {\textquotedbl}conventional{\textquotedbl} 1-based indexing.  Note that if you don{\textquotesingle}t want to be bothered supporting arrays with non-1 indexing, you can add the following line:




\begin{minted}{julia}
@assert all(x->isa(x, Base.OneTo), indices(A))
\end{minted}



at the top of any function.



For bounds checking, note that there are dedicated functions \texttt{checkbounds} and \texttt{checkindex} which can sometimes simplify such tests.



\hypertarget{16536792033838986020}{}


\subsubsection{Linear indexing (\texttt{linearindices})}



Some algorithms are most conveniently (or efficiently) written in terms of a single linear index, \texttt{A[i]} even if \texttt{A} is multi-dimensional.  In {\textquotedbl}true{\textquotedbl} linear indexing, the indices always range from \texttt{1:length(A)}. However, this raises an ambiguity for one-dimensional arrays (a.k.a., \texttt{AbstractVector}): does \texttt{v[i]} mean linear indexing, or Cartesian indexing with the array{\textquotesingle}s native indices?



For this reason, if you want to use linear indexing in an algorithm, your best option is to get the index range by calling \texttt{linearindices(A)}.  This will return \texttt{indices(A, 1)} if \texttt{A} is an \texttt{AbstractVector}, and the equivalent of \texttt{1:length(A)} otherwise.



In a sense, one can say that 1-dimensional arrays always use Cartesian indexing. To help enforce this, it{\textquotesingle}s worth noting that \texttt{sub2ind(shape, i...)} and \texttt{ind2sub(shape, ind)} will throw an error if \texttt{shape} indicates a 1-dimensional array with unconventional indexing (i.e., is a \texttt{Tuple\{UnitRange\}} rather than a tuple of \texttt{OneTo}).  For arrays with conventional indexing, these functions continue to work the same as always.



Using \texttt{indices} and \texttt{linearindices}, here is one way you could rewrite \texttt{mycopy!}:




\begin{minted}{julia}
function mycopy!(dest::AbstractVector, src::AbstractVector)
    indices(dest) == indices(src) || throw(DimensionMismatch("vectors must match"))
    for i in linearindices(src)
        @inbounds dest[i] = src[i]
    end
    dest
end
\end{minted}



\hypertarget{8664586686165592487}{}


\subsubsection{Allocating storage using generalizations of \texttt{similar}}



Storage is often allocated with \texttt{Array\{Int\}(dims)} or \texttt{similar(A, args...)}. When the result needs to match the indices of some other array, this may not always suffice. The generic replacement for such patterns is to use \texttt{similar(storagetype, shape)}.  \texttt{storagetype} indicates the kind of underlying {\textquotedbl}conventional{\textquotedbl} behavior you{\textquotesingle}d like, e.g., \texttt{Array\{Int\}} or \texttt{BitArray} or even \texttt{dims->zeros(Float32, dims)} (which would allocate an all-zeros array). \texttt{shape} is a tuple of \hyperlink{8469131683393450448}{\texttt{Integer}} or \texttt{AbstractUnitRange} values, specifying the indices that you want the result to use.



Let{\textquotesingle}s walk through a couple of explicit examples. First, if \texttt{A} has conventional indices, then \texttt{similar(Array\{Int\}, indices(A))} would end up calling \texttt{Array\{Int\}(size(A))}, and thus return an array.  If \texttt{A} is an \texttt{AbstractArray} type with unconventional indexing, then \texttt{similar(Array\{Int\}, indices(A))} should return something that {\textquotedbl}behaves like{\textquotedbl} an \texttt{Array\{Int\}} but with a shape (including indices) that matches \texttt{A}.  (The most obvious implementation is to allocate an \texttt{Array\{Int\}(size(A))} and then {\textquotedbl}wrap{\textquotedbl} it in a type that shifts the indices.)



Note also that \texttt{similar(Array\{Int\}, (indices(A, 2),))} would allocate an \texttt{AbstractVector\{Int\}} (i.e., 1-dimensional array) that matches the indices of the columns of \texttt{A}.



\hypertarget{4653517546914986819}{}


\subsubsection{Deprecations}



In generalizing Julia{\textquotesingle}s code base, at least one deprecation was unavoidable: earlier versions of Julia defined \texttt{first(::Colon) = 1}, meaning that the first index along a dimension indexed by \texttt{:} is 1. This definition can no longer be justified, so it was deprecated. There is no provided replacement, because the proper replacement depends on what you are doing and might need to know more about the array. However, it appears that many uses of \texttt{first(::Colon)} are really about computing an index offset; when that is the case, a candidate replacement is:




\begin{minted}{julia}
indexoffset(r::AbstractVector) = first(r) - 1
indexoffset(::Colon) = 0
\end{minted}



In other words, while \texttt{first(:)} does not itself make sense, in general you can say that the offset associated with a colon-index is zero.



\hypertarget{4699181205936675892}{}


\subsection{Writing custom array types with non-1 indexing}



Most of the methods you{\textquotesingle}ll need to define are standard for any \texttt{AbstractArray} type, see \hyperlink{522338241536202486}{Abstract Arrays}. This page focuses on the steps needed to define unconventional indexing.



\hypertarget{15721468421915743828}{}


\subsubsection{Do \textbf{not} implement \texttt{size} or \texttt{length}}



Perhaps the majority of pre-existing code that uses \texttt{size} will not work properly for arrays with non-1 indices.  For that reason, it is much better to avoid implementing these methods, and use the resulting \texttt{MethodError} to identify code that needs to be audited and perhaps generalized.



\hypertarget{14591227906888876157}{}


\subsubsection{Do \textbf{not} annotate bounds checks}



Julia 0.5 includes \texttt{@boundscheck} to annotate code that can be removed for callers that exploit \texttt{@inbounds}. Initially, it seems far preferable to run with bounds checking always enabled (i.e., omit the \texttt{@boundscheck} annotation so the check always runs).



\hypertarget{5924242856598341681}{}


\subsubsection{Custom \texttt{AbstractUnitRange} types}



If you{\textquotesingle}re writing a non-1 indexed array type, you will want to specialize \texttt{indices} so it returns a \texttt{UnitRange}, or (perhaps better) a custom \texttt{AbstractUnitRange}.  The advantage of a custom type is that it {\textquotedbl}signals{\textquotedbl} the allocation type for functions like \texttt{similar}. If we{\textquotesingle}re writing an array type for which indexing will start at 0, we likely want to begin by creating a new \texttt{AbstractUnitRange}, \texttt{ZeroRange}, where \texttt{ZeroRange(n)} is equivalent to \texttt{0:n-1}.



In general, you should probably \emph{not} export \texttt{ZeroRange} from your package: there may be other packages that implement their own \texttt{ZeroRange}, and having multiple distinct \texttt{ZeroRange} types is (perhaps counterintuitively) an advantage: \texttt{ModuleA.ZeroRange} indicates that \texttt{similar} should create a \texttt{ModuleA.ZeroArray}, whereas \texttt{ModuleB.ZeroRange} indicates a \texttt{ModuleB.ZeroArray} type.  This design allows peaceful coexistence among many different custom array types.



Note that the Julia package \href{https://github.com/JuliaArrays/CustomUnitRanges.jl}{CustomUnitRanges.jl} can sometimes be used to avoid the need to write your own \texttt{ZeroRange} type.



\hypertarget{4658403811041151465}{}


\subsubsection{Specializing \texttt{indices}}



Once you have your \texttt{AbstractUnitRange} type, then specialize \texttt{indices}:




\begin{minted}{julia}
Base.indices(A::ZeroArray) = map(n->ZeroRange(n), A.size)
\end{minted}



where here we imagine that \texttt{ZeroArray} has a field called \texttt{size} (there would be other ways to implement this).



In some cases, the fallback definition for \texttt{indices(A, d)}:




\begin{minted}{julia}
indices(A::AbstractArray{T,N}, d) where {T,N} = d <= N ? indices(A)[d] : OneTo(1)
\end{minted}



may not be what you want: you may need to specialize it to return something other than \texttt{OneTo(1)} when \texttt{d > ndims(A)}.  Likewise, in \texttt{Base} there is a dedicated function \texttt{indices1} which is equivalent to \texttt{indices(A, 1)} but which avoids checking (at runtime) whether \texttt{ndims(A) > 0}. (This is purely a performance optimization.)  It is defined as:




\begin{minted}{julia}
indices1(A::AbstractArray{T,0}) where {T} = OneTo(1)
indices1(A::AbstractArray) = indices(A)[1]
\end{minted}



If the first of these (the zero-dimensional case) is problematic for your custom array type, be sure to specialize it appropriately.



\hypertarget{5556461946249659648}{}


\subsubsection{Specializing \texttt{similar}}



Given your custom \texttt{ZeroRange} type, then you should also add the following two specializations for \texttt{similar}:




\begin{minted}{julia}
function Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})
    # body
end

function Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})
    # body
end
\end{minted}



Both of these should allocate your custom array type.



\hypertarget{16440701718956142132}{}


\subsubsection{Specializing \texttt{reshape}}



Optionally, define a method




\begin{lstlisting}
Base.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...
\end{lstlisting}



and you can \texttt{reshape} an array so that the result has custom indices.



\hypertarget{18141068032187944302}{}


\subsection{Summary}



Writing code that doesn{\textquotesingle}t make assumptions about indexing requires a few extra abstractions, but hopefully the necessary changes are relatively straightforward.



As a reminder, this support is still experimental. While much of Julia{\textquotesingle}s base code has been updated to support unconventional indexing, without a doubt there are many omissions that will be discovered only through usage.  Moreover, at the time of this writing, most packages do not support unconventional indexing.  As a consequence, early adopters should be prepared to identify and/or fix bugs.  On the other hand, only through practical usage will it become clear whether this experimental feature should be retained in future versions of Julia; consequently, interested parties are encouraged to accept some ownership for putting it through its paces.



\hypertarget{8108834884169454679}{}


\section{Base.LibGit2}



The LibGit2 module provides bindings to \href{https://libgit2.github.com/}{libgit2}, a portable C library that implements core functionality for the \href{https://git-scm.com/}{Git} version control system. These bindings are currently used to power Julia{\textquotesingle}s package manager. It is expected that this module will eventually be moved into a separate package.



\hypertarget{13716495418266911399}{}


\subsubsection{Functionality}



Some of this documentation assumes some prior knowledge of the libgit2 API. For more information on some of the objects and methods referenced here, consult the upstream \href{https://libgit2.github.com/libgit2/\#v0.25.1}{libgit2 API reference}.


\hypertarget{9931686680952686942}{} 
\hyperlink{9931686680952686942}{\texttt{Base.LibGit2.AbstractCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Abstract credentials payload



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{494380605532643136}{} 
\hyperlink{494380605532643136}{\texttt{Base.LibGit2.Buffer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.Buffer
\end{lstlisting}

A data buffer for exporting data from libgit2. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_buf}{\texttt{git\_buf}} struct.

When fetching data from LibGit2, a typical usage would look like:


\begin{minted}{julia}
buf_ref = Ref(Buffer())
@check ccall(..., (Ptr{Buffer},), buf_ref)
# operation on buf_ref
free(buf_ref)
\end{minted}

In particular, note that \texttt{LibGit2.free} should be called afterward on the \texttt{Ref} object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L95-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13238011814106976912}{} 
\hyperlink{13238011814106976912}{\texttt{Base.LibGit2.CachedCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Credentials that support caching



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L719}{\texttt{source}}


\end{adjustwidth}
\hypertarget{70406186196513527}{} 
\hyperlink{70406186196513527}{\texttt{Base.LibGit2.CheckoutOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.CheckoutOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_checkout\_options}{\texttt{git\_checkout\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15962357627830986499}{} 
\hyperlink{15962357627830986499}{\texttt{Base.LibGit2.CloneOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.CloneOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_clone\_options}{\texttt{git\_clone\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14078336658014776528}{} 
\hyperlink{14078336658014776528}{\texttt{Base.LibGit2.DiffDelta}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.DiffDelta
\end{lstlisting}

Description of changes to one entry. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_diff\_delta}{\texttt{git\_diff\_delta}} struct.

The fields represent:

\begin{itemize}
\item \texttt{status}: One of \texttt{Consts.DELTA\_STATUS}, indicating whether the file has been added/modified/deleted.


\item \texttt{flags}: Flags for the delta and the objects on each side. Determines whether to treat the file(s)  as binary/text, whether they exist on each side of the diff, and whether the object ids are known  to be correct.


\item \texttt{similarity}: Used to indicate if a file has been renamed or copied.


\item \texttt{nfiles}: The number of files in the delta (for instance, if the delta  was run on a submodule commit id, it may contain more than one file).


\item \texttt{old\_file}: A \hyperlink{10853323880399933744}{\texttt{DiffFile}} containing information about the file(s) before the changes.


\item \texttt{new\_file}: A \hyperlink{10853323880399933744}{\texttt{DiffFile}} containing information about the file(s) after the changes.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L297-L313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10853323880399933744}{} 
\hyperlink{10853323880399933744}{\texttt{Base.LibGit2.DiffFile}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.DiffFile
\end{lstlisting}

Description of one side of a delta. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_diff\_file}{\texttt{git\_diff\_file}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L273-L278}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11159190153382889147}{} 
\hyperlink{11159190153382889147}{\texttt{Base.LibGit2.DiffOptionsStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.DiffOptionsStruct
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_diff\_options}{\texttt{git\_diff\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9452650946849889589}{} 
\hyperlink{9452650946849889589}{\texttt{Base.LibGit2.FetchHead}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.FetchHead
\end{lstlisting}

Contains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L468-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15843746833940127147}{} 
\hyperlink{15843746833940127147}{\texttt{Base.LibGit2.FetchOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.FetchOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_fetch\_options}{\texttt{git\_fetch\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{501958583811403153}{} 
\hyperlink{501958583811403153}{\texttt{Base.LibGit2.GitBlob}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitBlob(repo::GitRepo, hash::AbstractGitHash)
GitBlob(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return a \texttt{GitBlob} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L102-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10902694404628649896}{} 
\hyperlink{10902694404628649896}{\texttt{Base.LibGit2.GitCommit}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitCommit(repo::GitRepo, hash::AbstractGitHash)
GitCommit(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return a \texttt{GitCommit} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L102-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11729713909743491089}{} 
\hyperlink{11729713909743491089}{\texttt{Base.LibGit2.GitHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitHash
\end{lstlisting}

A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a \texttt{GitObject} in a repository.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L12-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12902667157232644392}{} 
\hyperlink{12902667157232644392}{\texttt{Base.LibGit2.GitObject}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitObject(repo::GitRepo, hash::AbstractGitHash)
GitObject(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return the specified object (\hyperlink{10902694404628649896}{\texttt{GitCommit}}, \hyperlink{501958583811403153}{\texttt{GitBlob}}, \hyperlink{15098307424713644345}{\texttt{GitTree}} or \hyperlink{16990398329245524657}{\texttt{GitTag}}) from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L91-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4330007138212949924}{} 
\hyperlink{4330007138212949924}{\texttt{Base.LibGit2.GitRemote}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString) -> GitRemote
\end{lstlisting}

Look up a remote git repository using its name and URL. Uses the default fetch refspec.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
remote = LibGit2.GitRemote(repo, "upstream", repo_url)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L3-L14}{\texttt{source}}



\begin{lstlisting}
GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString) -> GitRemote
\end{lstlisting}

Look up a remote git repository using the repository{\textquotesingle}s name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
refspec = "+refs/heads/mybranch:refs/remotes/origin/mybranch"
remote = LibGit2.GitRemote(repo, "upstream", repo_url, refspec)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L23-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5869419718818609673}{} 
\hyperlink{5869419718818609673}{\texttt{Base.LibGit2.GitRemoteAnon}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitRemoteAnon(repo::GitRepo, url::AbstractString) -> GitRemote
\end{lstlisting}

Look up a remote git repository using only its URL, not its name.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
remote = LibGit2.GitRemoteAnon(repo, repo_url)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L46-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4189069544748556340}{} 
\hyperlink{4189069544748556340}{\texttt{Base.LibGit2.GitRepo}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.GitRepo(path::AbstractString)
\end{lstlisting}

Opens a git repository at \texttt{path}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10671080275952077260}{} 
\hyperlink{10671080275952077260}{\texttt{Base.LibGit2.GitRepoExt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))
\end{lstlisting}

Opens a git repository at \texttt{path} with extended controls (for instance, if the current user must be a member of a special access group to read \texttt{path}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L15-L20}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3688304737210863680}{} 
\hyperlink{3688304737210863680}{\texttt{Base.LibGit2.GitShortHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitShortHash
\end{lstlisting}

This is a shortened form of \texttt{GitHash}, which can be used to identify a git object when it is unique.

Internally it is stored as two fields: a full-size \texttt{GitHash} (\texttt{hash}) and a length (\texttt{len}). Only the initial \texttt{len} hex digits of \texttt{hash} are used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L24-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6700778514719115049}{} 
\hyperlink{6700778514719115049}{\texttt{Base.LibGit2.GitSignature}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.GitSignature
\end{lstlisting}

This is a Julia wrapper around a pointer to a \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_signature}{\texttt{git\_signature}} object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L574-L579}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11348324466028293798}{} 
\hyperlink{11348324466028293798}{\texttt{Base.LibGit2.GitStatus}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.GitStatus(repo::GitRepo; status_opts=StatusOptions())
\end{lstlisting}

Collect information about the status of each file in the git repository \texttt{repo} (e.g. is the file modified, staged, etc.). \texttt{status\_opts} can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/status.jl#L3-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16990398329245524657}{} 
\hyperlink{16990398329245524657}{\texttt{Base.LibGit2.GitTag}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitTag(repo::GitRepo, hash::AbstractGitHash)
GitTag(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return a \texttt{GitTag} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L102-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15098307424713644345}{} 
\hyperlink{15098307424713644345}{\texttt{Base.LibGit2.GitTree}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitTree(repo::GitRepo, hash::AbstractGitHash)
GitTree(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return a \texttt{GitTree} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L102-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18198409590045889476}{} 
\hyperlink{18198409590045889476}{\texttt{Base.LibGit2.IndexEntry}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.IndexEntry
\end{lstlisting}

In-memory representation of a file entry in the index. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_index\_entry}{\texttt{git\_index\_entry}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L379-L384}{\texttt{source}}


\end{adjustwidth}
\hypertarget{296553790669644349}{} 
\hyperlink{296553790669644349}{\texttt{Base.LibGit2.IndexTime}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.IndexTime
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_index\_time}{\texttt{git\_index\_time}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L369-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2235243125158864104}{} 
\hyperlink{2235243125158864104}{\texttt{Base.LibGit2.MergeOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.MergeOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_merge\_options}{\texttt{git\_merge\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9333556612062755476}{} 
\hyperlink{9333556612062755476}{\texttt{Base.LibGit2.ProxyOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.ProxyOptions
\end{lstlisting}

Options for connecting through a proxy.

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_proxy\_options}{\texttt{git\_proxy\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L812}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17509129411927482709}{} 
\hyperlink{17509129411927482709}{\texttt{Base.LibGit2.PushOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.PushOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_push\_options}{\texttt{git\_push\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16523024686410327521}{} 
\hyperlink{16523024686410327521}{\texttt{Base.LibGit2.RebaseOperation}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.RebaseOperation
\end{lstlisting}

Describes a single instruction/operation to be performed during the rebase. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_rebase\_operation\_t}{\texttt{git\_rebase\_operation}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L423-L428}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6353749624136519808}{} 
\hyperlink{6353749624136519808}{\texttt{Base.LibGit2.RebaseOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.RebaseOptions
\end{lstlisting}

Matches the \texttt{git\_rebase\_options} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2574901316547132732}{} 
\hyperlink{2574901316547132732}{\texttt{Base.LibGit2.RemoteCallbacks}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.RemoteCallbacks
\end{lstlisting}

Callback settings. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_remote\_callbacks}{\texttt{git\_remote\_callbacks}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L811}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10720534215214670880}{} 
\hyperlink{10720534215214670880}{\texttt{Base.LibGit2.SSHCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

SSH credentials type



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L688}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2816946505163653514}{} 
\hyperlink{2816946505163653514}{\texttt{Base.LibGit2.SignatureStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.SignatureStruct
\end{lstlisting}

An action signature (e.g. for committers, taggers, etc). Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_signature}{\texttt{git\_signature}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17790110826231416677}{} 
\hyperlink{17790110826231416677}{\texttt{Base.LibGit2.StatusEntry}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.StatusEntry
\end{lstlisting}

Providing the differences between the file as it exists in HEAD and the index, and providing the differences between the index and the working directory. Matches the \texttt{git\_status\_entry} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L455-L461}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15130089426107137330}{} 
\hyperlink{15130089426107137330}{\texttt{Base.LibGit2.StatusOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.StatusOptions
\end{lstlisting}

Options to control how \texttt{git\_status\_foreach\_ext()} will issue callbacks. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_status\_opt\_t}{\texttt{git\_status\_opt\_t}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L811}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7653839277371867286}{} 
\hyperlink{7653839277371867286}{\texttt{Base.LibGit2.StrArrayStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.StrArrayStruct
\end{lstlisting}

A LibGit2 representation of an array of strings. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_strarray}{\texttt{git\_strarray}} struct.

When fetching data from LibGit2, a typical usage would look like:


\begin{minted}{julia}
sa_ref = Ref(StrArrayStruct())
@check ccall(..., (Ptr{StrArrayStruct},), sa_ref)
res = convert(Vector{String}, sa_ref[])
free(sa_ref)
\end{minted}

In particular, note that \texttt{LibGit2.free} should be called afterward on the \texttt{Ref} object.

Conversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:


\begin{minted}{julia}
strs = String[...]
@check ccall(..., (Ptr{StrArrayStruct},), strs)
\end{minted}

Note that no call to \texttt{free} is required as the data is allocated by Julia.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L62-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9560069530494563563}{} 
\hyperlink{9560069530494563563}{\texttt{Base.LibGit2.TimeStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.TimeStruct
\end{lstlisting}

Time in a signature. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_time}{\texttt{git\_time}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L39-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3851413247267063300}{} 
\hyperlink{3851413247267063300}{\texttt{Base.LibGit2.UserPasswordCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Credentials that support only \texttt{user} and \texttt{password} parameters



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L663}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13623375014723191757}{} 
\hyperlink{13623375014723191757}{\texttt{Base.LibGit2.add\_fetch!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)
\end{lstlisting}

Add a \emph{fetch} refspec for the specified \texttt{rmt}. This refspec will contain information about which branch(es) to fetch from.

\textbf{Example}


\begin{minted}{jlcon}
julia> LibGit2.add_fetch!(repo, remote, "upstream");

julia> LibGit2.fetch_refspecs(remote)
String["+refs/heads/*:refs/remotes/upstream/*"]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L165-L178}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3465864374577161747}{} 
\hyperlink{3465864374577161747}{\texttt{Base.LibGit2.add\_push!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)
\end{lstlisting}

Add a \emph{push} refspec for the specified \texttt{rmt}. This refspec will contain information about which branch(es) to push to.

\textbf{Example}


\begin{minted}{jlcon}
julia> LibGit2.add_push!(repo, remote, "refs/heads/master");

julia> remote = LibGit2.get(LibGit2.GitRemote, repo, branch);

julia> LibGit2.push_refspecs(remote)
String["refs/heads/master"]
\end{minted}

\begin{quote}
\textbf{Note}

You may need to \hyperlink{5331333469799487255}{\texttt{close}} and reopen the \texttt{GitRemote} in question after updating its push refspecs in order for the change to take effect and for calls to \hyperlink{10329292874321123591}{\texttt{push}} to work.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L185-L206}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8535948773099366335}{} 
\hyperlink{8535948773099366335}{\texttt{Base.LibGit2.addblob!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.addblob!(repo::GitRepo, path::AbstractString)
\end{lstlisting}

Reads the file at \texttt{path} and adds it to the object database of \texttt{repo} as a loose blob. Returns the \texttt{GitHash} of the resulting blob.

\textbf{Example}


\begin{minted}{julia}
hash_str = hex(commit_oid)
blob_file = joinpath(repo_path, ".git", "objects", hash_str[1:2], hash_str[3:end])
id = LibGit2.addblob!(repo, blob_file)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/blob.jl#L36-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4246691067496118320}{} 
\hyperlink{4246691067496118320}{\texttt{Base.LibGit2.authors}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
authors(repo::GitRepo) -> Vector{Signature}
\end{lstlisting}

Returns all authors of commits to the \texttt{repo} repository.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
repo_file = open(joinpath(repo_path, test_file), "a")

println(repo_file, commit_msg)
flush(repo_file)
LibGit2.add!(repo, test_file)
sig = LibGit2.Signature("TEST", "TEST@TEST.COM", round(time(), 0), 0)
commit_oid1 = LibGit2.commit(repo, "commit1"; author=sig, committer=sig)
println(repo_file, randstring(10))
flush(repo_file)
LibGit2.add!(repo, test_file)
commit_oid2 = LibGit2.commit(repo, "commit2"; author=sig, committer=sig)

# will be a Vector of [sig, sig]
auths = LibGit2.authors(repo)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L796-L820}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7529731371760227900}{} 
\hyperlink{7529731371760227900}{\texttt{Base.LibGit2.branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
branch(repo::GitRepo)
\end{lstlisting}

Equivalent to \texttt{git branch}. Create a new branch from the current HEAD.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L353-L358}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16490557174026522942}{} 
\hyperlink{16490557174026522942}{\texttt{Base.LibGit2.branch!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
branch!(repo::GitRepo, branch_name::AbstractString, commit::AbstractString=""; kwargs...)
\end{lstlisting}

Checkout a new git branch in the \texttt{repo} repository. \texttt{commit} is the \hyperlink{11729713909743491089}{\texttt{GitHash}}, in string form, which will be the start of the new branch. If \texttt{commit} is an empty string, the current HEAD will be used.

The keyword arguments are:

\begin{itemize}
\item \texttt{track::AbstractString={\textquotedbl}{\textquotedbl}}: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.


\item \texttt{force::Bool=false}: if \texttt{true}, branch creation will be forced.


\item \texttt{set\_head::Bool=true}: if \texttt{true}, after the branch creation finishes the branch head will be set as the HEAD of \texttt{repo}.

\end{itemize}
Equivalent to \texttt{git checkout [-b|-B] <branch\_name> [<commit>] [--track <track>]}.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.branch!(repo, "new_branch", set_head=false)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L368-L393}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5707429819745125730}{} 
\hyperlink{5707429819745125730}{\texttt{Base.LibGit2.checkout!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
checkout!(repo::GitRepo, commit::AbstractString=""; force::Bool=true)
\end{lstlisting}

Equivalent to \texttt{git checkout [-f] --detach <commit>}. Checkout the git commit \texttt{commit} (a \hyperlink{11729713909743491089}{\texttt{GitHash}} in string form) in \texttt{repo}. If \texttt{force} is \texttt{true}, force the checkout and discard any current changes. Note that this detaches the current HEAD.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
open(joinpath(LibGit2.path(repo), "file1"), "w") do f
    write(f, "111
")
end
LibGit2.add!(repo, "file1")
commit_oid = LibGit2.commit(repo, "add file1")
open(joinpath(LibGit2.path(repo), "file1"), "w") do f
    write(f, "112
")
end
# would fail without the force=true
# since there are modifications to the file
LibGit2.checkout!(repo, string(commit_oid), force=true)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L460-L486}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13717578412386871751}{} 
\hyperlink{13717578412386871751}{\texttt{Base.LibGit2.checkused!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Checks if credentials were used



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L124}{\texttt{source}}


Checks if credentials were used or failed authentication, see \texttt{LibGit2.credentials\_callback}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L726}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18159548566765472401}{} 
\hyperlink{18159548566765472401}{\texttt{Base.LibGit2.clone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clone(repo_url::AbstractString, repo_path::AbstractString; kwargs...)
\end{lstlisting}

Clone a remote repository located at \texttt{repo\_url} to the local filesystem location \texttt{repo\_path}.

The keyword arguments are:

\begin{itemize}
\item \texttt{branch::AbstractString={\textquotedbl}{\textquotedbl}}: which branch of the remote to clone, if not the default repository branch (usually \texttt{master}).


\item \texttt{isbare::Bool=false}: if \texttt{true}, clone the remote as a bare repository, which will make \texttt{repo\_path} itself the git directory instead of \texttt{repo\_path/.git}. This means that a working tree cannot be checked out. Plays the role of the git CLI argument \texttt{--bare}.


\item \texttt{remote\_cb::Ptr\{Void\}=C\_NULL}: a callback which will be used to create the remote before it is cloned. If \texttt{C\_NULL} (the default), no attempt will be made to create the remote - it will be assumed to already exist.


\item \texttt{payload::Nullable\{P<:AbstractCredentials\}=Nullable\{AbstractCredentials\}()}: provides credentials if necessary, for instance if the remote is a private repository.

\end{itemize}
Equivalent to \texttt{git clone [-b <branch>] [--bare] <repo\_url> <repo\_path>}.

\textbf{Examples}


\begin{minted}{julia}
repo_url = "https://github.com/JuliaLang/Example.jl"
repo1 = LibGit2.clone(repo_url, "test_path")
repo2 = LibGit2.clone(repo_url, "test_path", isbare=true)
julia_url = "https://github.com/JuliaLang/julia"
julia_repo = LibGit2.clone(julia_url, "julia_path", branch="release-0.6")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L516-L546}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8015520027139814727}{} 
\hyperlink{8015520027139814727}{\texttt{Base.LibGit2.commit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Wrapper around \texttt{git\_commit\_create} 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/commit.jl#L31}{\texttt{source}}


Commit changes to repository



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/commit.jl#L54}{\texttt{source}}



\begin{lstlisting}
LibGit2.commit(rb::GitRebase, sig::GitSignature)
\end{lstlisting}

Commits the current patch to the rebase \texttt{rb}, using \texttt{sig} as the committer. Is silent if the commit has already been applied.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/rebase.jl#L52-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{90213436121178284}{} 
\hyperlink{90213436121178284}{\texttt{Base.LibGit2.create\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.create_branch(repo::GitRepo, bname::AbstractString, commit_obj::GitCommit; force::Bool=false)
\end{lstlisting}

Create a new branch in the repository \texttt{repo} with name \texttt{bname}, which points to commit \texttt{commit\_obj} (which has to be part of \texttt{repo}). If \texttt{force} is \texttt{true}, overwrite an existing branch named \texttt{bname} if it exists. If \texttt{force} is \texttt{false} and a branch already exists named \texttt{bname}, this function will throw an error.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L196-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6849925087630414730}{} 
\hyperlink{6849925087630414730}{\texttt{Base.LibGit2.credentials\_callback}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Credentials callback function

Function provides different credential acquisition functionality w.r.t. a connection protocol. If a payload is provided then \texttt{payload\_ptr} should contain a \texttt{LibGit2.AbstractCredentials} object.

For \texttt{LibGit2.Consts.CREDTYPE\_USERPASS\_PLAINTEXT} type, if the payload contains fields: \texttt{user} \& \texttt{pass}, they are used to create authentication credentials. Empty \texttt{user} name and \texttt{pass}word trigger an authentication error.

For \texttt{LibGit2.Consts.CREDTYPE\_SSH\_KEY} type, if the payload contains fields: \texttt{user}, \texttt{prvkey}, \texttt{pubkey} \& \texttt{pass}, they are used to create authentication credentials. Empty \texttt{user} name triggers an authentication error.

Credentials are checked in the following order (if supported):

\begin{itemize}
\item ssh key pair (\texttt{ssh-agent} if specified in payload{\textquotesingle}s \texttt{usesshagent} field)


\item plain text

\end{itemize}
\textbf{Note}: Due to the specifics of the \texttt{libgit2} authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, the \texttt{checkused!} function can be called. This function returns \texttt{true} if the credentials were used. Using credentials triggers a user prompt for (re)entering required information. \texttt{UserPasswordCredentials} and \texttt{CachedCredentials} are implemented using a call counting strategy that prevents repeated usage of faulty credentials.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L174-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11853180090558191138}{} 
\hyperlink{11853180090558191138}{\texttt{Base.LibGit2.credentials\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{credentials\_callback}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L262}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18313327697666700414}{} 
\hyperlink{18313327697666700414}{\texttt{Base.LibGit2.default\_signature}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Return signature object. Free it after use.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/signature.jl#L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12407359090434445324}{} 
\hyperlink{12407359090434445324}{\texttt{Base.LibGit2.delete\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.delete_branch(branch::GitReference)
\end{lstlisting}

Delete the branch pointed to by \texttt{branch}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L216-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9650551889728428786}{} 
\hyperlink{9650551889728428786}{\texttt{Base.LibGit2.diff\_files}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diff_files(repo::GitRepo, branch1::AbstractString, branch2::AbstractString; kwarg...) -> Vector{AbstractString}
\end{lstlisting}

Show which files have changed in the git repository \texttt{repo} between branches \texttt{branch1} and \texttt{branch2}.

The keyword argument is:

\begin{itemize}
\item \texttt{filter::Set\{Consts.DELTA\_STATUS\}=Set([Consts.DELTA\_ADDED, Consts.DELTA\_MODIFIED, Consts.DELTA\_DELETED]))}, and it sets options for the diff. The default is to show files added, modified, or deleted.

\end{itemize}
Returns only the \emph{names} of the files which have changed, \emph{not} their contents.

\textbf{Example}


\begin{minted}{julia}
LibGit2.branch!(repo, "branch/a")
LibGit2.branch!(repo, "branch/b")
# add a file to repo
open(joinpath(LibGit2.path(repo),"file"),"w") do f
    write(f, "hello repo
")
end
LibGit2.add!(repo, "file")
LibGit2.commit(repo, "add file")
# returns ["file"]
filt = Set([LibGit2.Consts.DELTA_ADDED])
files = LibGit2.diff_files(repo, "branch/a", "branch/b", filter=filt)
# returns [] because existing files weren't modified
filt = Set([LibGit2.Consts.DELTA_MODIFIED])
files = LibGit2.diff_files(repo, "branch/a", "branch/b", filter=filt)
\end{minted}

Equivalent to \texttt{git diff --name-only --diff-filter=<filter> <branch1> <branch2>}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L158-L191}{\texttt{source}}


\end{adjustwidth}
\hypertarget{986549586834995629}{} 
\hyperlink{986549586834995629}{\texttt{Base.LibGit2.fetch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch(rmt::GitRemote, refspecs; options::FetchOptions=FetchOptions(), msg="")
\end{lstlisting}

Fetch from the specified \texttt{rmt} remote git repository, using \texttt{refspecs} to determine which remote branch(es) to fetch. The keyword arguments are:

\begin{itemize}
\item \texttt{options}: determines the options for the fetch, e.g. whether to prune afterwards.


\item \texttt{msg}: a message to insert into the reflogs.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L213-L221}{\texttt{source}}



\begin{lstlisting}
fetch(repo::GitRepo; kwargs...)
\end{lstlisting}

Fetches updates from an upstream of the repository \texttt{repo}.

The keyword arguments are:

\begin{itemize}
\item \texttt{remote::AbstractString={\textquotedbl}origin{\textquotedbl}}: which remote, specified by name, of \texttt{repo} to fetch from. If this is empty, the URL will be used to construct an anonymous remote.


\item \texttt{remoteurl::AbstractString={\textquotedbl}{\textquotedbl}}: the URL of \texttt{remote}. If not specified, will be assumed based on the given name of \texttt{remote}.


\item \texttt{refspecs=AbstractString[]}: determines properties of the fetch.


\item \texttt{payload=Nullable\{AbstractCredentials\}()}: provides credentials, if necessary, for instance if \texttt{remote} is a private repository.

\end{itemize}
Equivalent to \texttt{git fetch [<remoteurl>|<repo>] [<refspecs>]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L283-L299}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15757709840137244772}{} 
\hyperlink{15757709840137244772}{\texttt{Base.LibGit2.fetch\_refspecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch_refspecs(rmt::GitRemote) -> Vector{String}
\end{lstlisting}

Get the \emph{fetch} refspecs for the specified \texttt{rmt}. These refspecs contain information about which branch(es) to fetch from.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L135-L140}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14408966997565353703}{} 
\hyperlink{14408966997565353703}{\texttt{Base.LibGit2.fetchhead\_foreach\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{fetchhead\_foreach\_callback}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13775282676052107168}{} 
\hyperlink{13775282676052107168}{\texttt{Base.LibGit2.ffmerge!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Fastforward merge changes into current head 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/merge.jl#L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2101614122740166538}{} 
\hyperlink{2101614122740166538}{\texttt{Base.LibGit2.fullname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.fullname(ref::GitReference)
\end{lstlisting}

Return the name of the reference pointed to by the symbolic reference \texttt{ref}. If \texttt{ref} is not a symbolic reference, returns an empty string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L82-L88}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15231887986622283392}{} 
\hyperlink{15231887986622283392}{\texttt{Base.LibGit2.get\_creds!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Obtain the cached credentials for the given host+protocol (credid), or return and store the default if not found



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L735}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16866457035365582078}{} 
\hyperlink{16866457035365582078}{\texttt{Base.LibGit2.gitdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.gitdir(repo::GitRepo)
\end{lstlisting}

Returns the location of the {\textquotedbl}git{\textquotedbl} files of \texttt{repo}:

\begin{itemize}
\item for normal repositories, this is the location of the \texttt{.git} folder.


\item for bare repositories, this is the location of the repository itself.

\end{itemize}
See also \hyperlink{10392492346200898016}{\texttt{workdir}}, \hyperlink{13913454255383065948}{\texttt{path}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L150-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1596718389164397217}{} 
\hyperlink{1596718389164397217}{\texttt{Base.LibGit2.head}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.head(repo::GitRepo) -> GitReference
\end{lstlisting}

Returns a \texttt{GitReference} to the current HEAD of \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L33-L37}{\texttt{source}}



\begin{lstlisting}
head(pkg::AbstractString) -> String
\end{lstlisting}

Return current HEAD \hyperlink{11729713909743491089}{\texttt{GitHash}} of the \texttt{pkg} repo as a string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L45-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3725624338522540950}{} 
\hyperlink{3725624338522540950}{\texttt{Base.LibGit2.head!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.head!(repo::GitRepo, ref::GitReference) -> GitReference
\end{lstlisting}

Set the HEAD of \texttt{repo} to the object pointed to by \texttt{ref}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L225-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5805768163693010277}{} 
\hyperlink{5805768163693010277}{\texttt{Base.LibGit2.head\_oid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.head_oid(repo::GitRepo) -> GitHash
\end{lstlisting}

Lookup the object id of the current HEAD of git repository \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16596027723028346855}{} 
\hyperlink{16596027723028346855}{\texttt{Base.LibGit2.headname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.headname(repo::GitRepo)
\end{lstlisting}

Lookup the name of the current HEAD of git repository \texttt{repo}. If \texttt{repo} is currently detached, returns the name of the HEAD it{\textquotesingle}s detached from.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L65-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18237439440894670990}{} 
\hyperlink{18237439440894670990}{\texttt{Base.LibGit2.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.init(path::AbstractString, bare::Bool=false) -> GitRepo
\end{lstlisting}

Opens a new git repository at \texttt{path}. If \texttt{bare} is \texttt{false}, the working tree will be created in \texttt{path/.git}. If \texttt{bare} is \texttt{true}, no working directory will be created.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L36-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{647625840513024826}{} 
\hyperlink{647625840513024826}{\texttt{Base.LibGit2.is\_ancestor\_of}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{a}, a \hyperlink{11729713909743491089}{\texttt{GitHash}} in string form, is an ancestor of \texttt{b}, a \hyperlink{11729713909743491089}{\texttt{GitHash}} in string form.

\textbf{Example}


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file1);

julia> commit_oid1 = LibGit2.commit(repo, "commit1");

julia> LibGit2.add!(repo, test_file2);

julia> commit_oid2 = LibGit2.commit(repo, "commit2");

julia> LibGit2.is_ancestor_of(string(commit_oid1), string(commit_oid2), repo)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L215-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5620297776309259546}{} 
\hyperlink{5620297776309259546}{\texttt{Base.LibGit2.isbinary}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Use a heuristic to guess if a file is binary: searching for NULL bytes and looking for a reasonable ratio of printable to non-printable characters among the first 8000 bytes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/blob.jl#L26-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2380274570565820861}{} 
\hyperlink{2380274570565820861}{\texttt{Base.LibGit2.iscommit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iscommit(id::AbstractString, repo::GitRepo) -> Bool
\end{lstlisting}

Checks if commit \texttt{id} (which is a \hyperlink{11729713909743491089}{\texttt{GitHash}} in string form) is in the repository.

\textbf{Example}


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file);

julia> commit_oid = LibGit2.commit(repo, "add test_file");

julia> LibGit2.iscommit(string(commit_oid), repo)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L70-L88}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959496514282254576}{} 
\hyperlink{16959496514282254576}{\texttt{Base.LibGit2.isdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.isdiff(repo::GitRepo, treeish::AbstractString, pathspecs::AbstractString=""; cached::Bool=false)
\end{lstlisting}

Checks if there are any differences between the tree specified by \texttt{treeish} and the tracked files in the working tree (if \texttt{cached=false}) or the index (if \texttt{cached=true}). \texttt{pathspecs} are the specifications for options for the diff.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.isdiff(repo, "HEAD") # should be false
open(joinpath(repo_path, new_file), "a") do f
    println(f, "here's my cool new file")
end
LibGit2.isdiff(repo, "HEAD") # now true
\end{minted}

Equivalent to \texttt{git diff-index <treeish> [-- <pathspecs>]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L127-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12235718469896960833}{} 
\hyperlink{12235718469896960833}{\texttt{Base.LibGit2.isdirty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.isdirty(repo::GitRepo, pathspecs::AbstractString=""; cached::Bool=false) -> Bool
\end{lstlisting}

Checks if there have been any changes to tracked files in the working tree (if \texttt{cached=false}) or the index (if \texttt{cached=true}). \texttt{pathspecs} are the specifications for options for the diff.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.isdirty(repo) # should be false
open(joinpath(repo_path, new_file), "a") do f
    println(f, "here's my cool new file")
end
LibGit2.isdirty(repo) # now true
LibGit2.isdirty(repo, new_file) # now true
\end{minted}

Equivalent to \texttt{git diff-index HEAD [-- <pathspecs>]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L104-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9719872750978870564}{} 
\hyperlink{9719872750978870564}{\texttt{Base.LibGit2.isorphan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.isorphan(repo::GitRepo)
\end{lstlisting}

Checks if the current branch is an {\textquotedbl}orphan{\textquotedbl} branch, i.e. has no commits. The first commit to this branch will have no parents.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L21-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10123552102874129630}{} 
\hyperlink{10123552102874129630}{\texttt{Base.LibGit2.lookup\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lookup_branch(repo::GitRepo, branch_name::AbstractString, remote::Bool=false) -> Nullable{GitReference}
\end{lstlisting}

Determine if the branch specified by \texttt{branch\_name} exists in the repository \texttt{repo}. If \texttt{remote} is \texttt{true}, \texttt{repo} is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.

\texttt{lookup\_branch} returns a \hyperlink{2208920129454296646}{\texttt{Nullable}}, which will be null if the requested branch does not exist yet. If the branch does exist, the \texttt{Nullable} contains a \texttt{GitReference} to the branch.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L237-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5410497471460368983}{} 
\hyperlink{5410497471460368983}{\texttt{Base.LibGit2.mirror\_callback}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Mirror callback function

Function sets \texttt{+refs/*:refs/*} refspecs and \texttt{mirror} flag for remote reference.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11820499806800583259}{} 
\hyperlink{11820499806800583259}{\texttt{Base.LibGit2.mirror\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{mirror\_callback}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L260}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15918563895809262557}{} 
\hyperlink{15918563895809262557}{\texttt{Base.LibGit2.name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.name(ref::GitReference)
\end{lstlisting}

Return the full name of \texttt{ref}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L97-L101}{\texttt{source}}



\begin{lstlisting}
name(rmt::GitRemote)
\end{lstlisting}

Get the name of a remote repository, for instance \texttt{{\textquotedbl}origin{\textquotedbl}}. If the remote is anonymous (see \hyperlink{5869419718818609673}{\texttt{GitRemoteAnon}}) the name will be an empty string \texttt{{\textquotedbl}{\textquotedbl}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> repo_url = "https://github.com/JuliaLang/Example.jl";

julia> repo = LibGit2.clone(cache_repo, "test_directory");

julia> remote = LibGit2.GitRemote(repo, "origin", repo_url);

julia> name(remote)
"origin"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L109-L128}{\texttt{source}}



\begin{lstlisting}
LibGit2.name(tag::GitTag)
\end{lstlisting}

The name of \texttt{tag} (e.g. \texttt{{\textquotedbl}v0.5{\textquotedbl}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15134808631028226443}{} 
\hyperlink{15134808631028226443}{\texttt{Base.LibGit2.need\_update}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
need_update(repo::GitRepo)
\end{lstlisting}

Equivalent to \texttt{git update-index}. Returns \texttt{true} if \texttt{repo} needs updating.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L57-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3103116791152363577}{} 
\hyperlink{3103116791152363577}{\texttt{Base.LibGit2.objtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
objtype(obj_type::Consts.OBJECT)
\end{lstlisting}

Returns the type corresponding to the enum value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L640-L644}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13913454255383065948}{} 
\hyperlink{13913454255383065948}{\texttt{Base.LibGit2.path}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.path(repo::GitRepo)
\end{lstlisting}

The base file path of the repository \texttt{repo}.

\begin{itemize}
\item for normal repositories, this will typically be the parent directory of the {\textquotedbl}.git{\textquotedbl} directory (note: this may be different than the working directory, see \texttt{workdir} for more details).


\item for bare repositories, this is the location of the {\textquotedbl}git{\textquotedbl} files.

\end{itemize}
See also \hyperlink{16866457035365582078}{\texttt{gitdir}}, \hyperlink{10392492346200898016}{\texttt{workdir}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L186-L197}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12737959515263495066}{} 
\hyperlink{12737959515263495066}{\texttt{Base.LibGit2.peel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
peel([T,] ref::GitReference)
\end{lstlisting}

Recursively peel \texttt{ref} until an object of type \texttt{T} is obtained. If no \texttt{T} is provided, then \texttt{ref} will be peeled until an object other than a \hyperlink{16990398329245524657}{\texttt{GitTag}} is obtained.

\begin{itemize}
\item A \texttt{GitTag} will be peeled to the object it references.


\item A \hyperlink{10902694404628649896}{\texttt{GitCommit}} will be peeled to a \hyperlink{15098307424713644345}{\texttt{GitTree}}.

\end{itemize}
\begin{quote}
\textbf{Note}

Only annotated tags can be peeled to \texttt{GitTag} objects. Lightweight tags (the default) are references under \texttt{refs/tags/} which point directly to \texttt{GitCommit} objects.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L161-L173}{\texttt{source}}



\begin{lstlisting}
peel([T,] obj::GitObject)
\end{lstlisting}

Recursively peel \texttt{obj} until an object of type \texttt{T} is obtained. If no \texttt{T} is provided, then \texttt{obj} will be peeled until the type changes.

\begin{itemize}
\item A \texttt{GitTag} will be peeled to the object it references.


\item A \texttt{GitCommit} will be peeled to a \texttt{GitTree}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L211-L219}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11783394155628254030}{} 
\hyperlink{11783394155628254030}{\texttt{Base.LibGit2.posixpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.posixpath(path)
\end{lstlisting}

Standardise the path string \texttt{path} to use POSIX separators.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/utils.jl#L57-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10329292874321123591}{} 
\hyperlink{10329292874321123591}{\texttt{Base.LibGit2.push}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
push(rmt::GitRemote, refspecs; force::Bool=false, options::PushOptions=PushOptions())
\end{lstlisting}

Push to the specified \texttt{rmt} remote git repository, using \texttt{refspecs} to determine which remote branch(es) to push to. The keyword arguments are:

\begin{itemize}
\item \texttt{force}: if \texttt{true}, a force-push will occur, disregarding conflicts.


\item \texttt{options}: determines the options for the push, e.g. which proxy headers to use.

\end{itemize}
\begin{quote}
\textbf{Note}

You can add information about the push refspecs in two other ways: by setting an option in the repository{\textquotesingle}s \texttt{GitConfig} (with \texttt{push.default} as the key) or by calling \hyperlink{3465864374577161747}{\texttt{add\_push!}}. Otherwise you will need to explicitly specify a push refspec in the call to \texttt{push} for it to have any effect, like so: \texttt{LibGit2.push(repo, refspecs=[{\textquotedbl}refs/heads/master{\textquotedbl}])}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L231-L246}{\texttt{source}}



\begin{lstlisting}
push(repo::GitRepo; kwargs...)
\end{lstlisting}

Pushes updates to an upstream of \texttt{repo}.

The keyword arguments are:

\begin{itemize}
\item \texttt{remote::AbstractString={\textquotedbl}origin{\textquotedbl}}: the name of the upstream remote to push to.


\item \texttt{remoteurl::AbstractString={\textquotedbl}{\textquotedbl}}: the URL of \texttt{remote}.


\item \texttt{refspecs=AbstractString[]}: determines properties of the push.


\item \texttt{force::Bool=false}: determines if the push will be a force push,  overwriting the remote branch.


\item \texttt{payload=Nullable\{AbstractCredentials\}()}: provides credentials, if necessary, for instance if \texttt{remote} is a private repository.

\end{itemize}
Equivalent to \texttt{git push [<remoteurl>|<repo>] [<refspecs>]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L318-L333}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11244759000543317713}{} 
\hyperlink{11244759000543317713}{\texttt{Base.LibGit2.push\_refspecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
push_refspecs(rmt::GitRemote) -> Vector{String}
\end{lstlisting}

Get the \emph{push} refspecs for the specified \texttt{rmt}. These refspecs contain information about which branch(es) to push to.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L150-L155}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8999395691087615315}{} 
\hyperlink{8999395691087615315}{\texttt{Base.LibGit2.read\_tree!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.read_tree!(idx::GitIndex, tree::GitTree)
LibGit2.read_tree!(idx::GitIndex, treehash::AbstractGitHash)
\end{lstlisting}

Read the tree \texttt{tree} (or the tree pointed to by \texttt{treehash} in the repository owned by \texttt{idx}) into the index \texttt{idx}. The current index contents will be replaced.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/index.jl#L35-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15622902401322805260}{} 
\hyperlink{15622902401322805260}{\texttt{Base.LibGit2.rebase!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.rebase!(repo::GitRepo, upstream::AbstractString="", newbase::AbstractString="")
\end{lstlisting}

Attempt an automatic merge rebase of the current branch, from \texttt{upstream} if provided, or otherwise from the upstream tracking branch. \texttt{newbase} is the branch to rebase onto. By default this is \texttt{upstream}.

If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a \texttt{GitError}. This is roughly equivalent to the following command line statement:


\begin{lstlisting}
git rebase --merge [<upstream>]
if [ -d ".git/rebase-merge" ]; then
    git rebase --abort
fi
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L730-L746}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3201078861145586006}{} 
\hyperlink{3201078861145586006}{\texttt{Base.LibGit2.ref\_list}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.ref_list(repo::GitRepo) -> Vector{String}
\end{lstlisting}

Get a list of all reference names in the \texttt{repo} repository.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L182-L186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2955019549210743587}{} 
\hyperlink{2955019549210743587}{\texttt{Base.LibGit2.reftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.reftype(ref::GitReference) -> Cint
\end{lstlisting}

Returns a \texttt{Cint} corresponding to the type of \texttt{ref}:

\begin{itemize}
\item \texttt{0} if the reference is invalid


\item \texttt{1} if the reference is an object id


\item \texttt{2} if the reference is symbolic

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L70-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15080577271661897126}{} 
\hyperlink{15080577271661897126}{\texttt{Base.LibGit2.remotes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.remotes(repo::GitRepo)
\end{lstlisting}

Returns a vector of the names of the remotes of \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L291-L295}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14091044399468968783}{} 
\hyperlink{14091044399468968783}{\texttt{Base.LibGit2.reset!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Resets credentials for another use



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L127}{\texttt{source}}


Updates some entries, determined by the \texttt{pathspecs}, in the index from the target commit tree.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L253}{\texttt{source}}


Sets the current head to the specified commit oid and optionally resets the index and working tree to match.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L263}{\texttt{source}}


git reset [<committish>] [–] <pathspecs>... 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L565}{\texttt{source}}



\begin{lstlisting}
reset!(repo::GitRepo, id::GitHash, mode::Cint = Consts.RESET_MIXED)
\end{lstlisting}

Reset the repository \texttt{repo} to its state at \texttt{id}, using one of three modes set by \texttt{mode}:

\begin{itemize}
\item[1. ] \texttt{Consts.RESET\_SOFT} - move HEAD to \texttt{id}.


\item[2. ] \texttt{Consts.RESET\_MIXED} - default, move HEAD to \texttt{id} and reset the index to \texttt{id}.


\item[3. ] \texttt{Consts.RESET\_HARD} - move HEAD to \texttt{id}, reset the index to \texttt{id}, and discard all working changes.

\end{itemize}
Equivalent to \texttt{git reset [--soft | --mixed | --hard] <id>}.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
head_oid = LibGit2.head_oid(repo)
open(joinpath(repo_path, "file1"), "w") do f
    write(f, "111
")
end
LibGit2.add!(repo, "file1")
mode = LibGit2.Consts.RESET_HARD
# will discard the changes to file1
# and unstage it
new_head = LibGit2.reset!(repo, head_oid, mode)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L572-L598}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18295332994346533363}{} 
\hyperlink{18295332994346533363}{\texttt{Base.LibGit2.restore}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
restore(s::State, repo::GitRepo)
\end{lstlisting}

Return a repository \texttt{repo} to a previous \texttt{State} \texttt{s}, for example the HEAD of a branch before a merge attempt. \texttt{s} can be generated using the \hyperlink{3573482892097004589}{\texttt{snapshot}} function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L859-L865}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17483802022298804690}{} 
\hyperlink{17483802022298804690}{\texttt{Base.LibGit2.revcount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)
\end{lstlisting}

List the number of revisions between \texttt{commit1} and \texttt{commit2} (committish OIDs in string form). Since \texttt{commit1} and \texttt{commit2} may be on different branches, \texttt{revcount} performs a {\textquotedbl}left-right{\textquotedbl} revision list (and count), returning a tuple of \texttt{Int}s - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.

Equivalent to \texttt{git rev-list --left-right --count <commit1> <commit2>}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L601-L611}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6474240678825000223}{} 
\hyperlink{6474240678825000223}{\texttt{Base.LibGit2.set\_remote\_url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
set_remote_url(repo::GitRepo, url::AbstractString; remote::AbstractString="origin")
\end{lstlisting}

Set the \texttt{url} for \texttt{remote} for the git repository \texttt{repo}. The default name of the remote is \texttt{{\textquotedbl}origin{\textquotedbl}}.

\textbf{Examples}


\begin{minted}{julia}
repo_path = joinpath("test_directory", "Example")
repo = LibGit2.init(repo_path)
url1 = "https://github.com/JuliaLang/Example.jl"
LibGit2.set_remote_url(repo, url1, remote="upstream")
url2 = "https://github.com/JuliaLang/Example2.jl"
LibGit2.set_remote_url(repo_path, url2, remote="upstream2")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L243-L259}{\texttt{source}}



\begin{lstlisting}
set_remote_url(path::AbstractString, url::AbstractString; remote::AbstractString="origin")
\end{lstlisting}

Set the \texttt{url} for \texttt{remote} for the git repository located at \texttt{path}. The default name of the remote is \texttt{{\textquotedbl}origin{\textquotedbl}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L267-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1013553266138092396}{} 
\hyperlink{1013553266138092396}{\texttt{Base.LibGit2.shortname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.shortname(ref::GitReference)
\end{lstlisting}

Returns a shortened version of the name of \texttt{ref} that{\textquotesingle}s {\textquotedbl}human-readable{\textquotedbl}.


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(path_to_repo);

julia> branch_ref = LibGit2.head(repo);

julia> LibGit2.name(branch_ref)
"refs/heads/master"

julia> LibGit2.shortname(branch_ref)
"master"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L45-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3573482892097004589}{} 
\hyperlink{3573482892097004589}{\texttt{Base.LibGit2.snapshot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
snapshot(repo::GitRepo) -> State
\end{lstlisting}

Take a snapshot of the current state of the repository \texttt{repo}, storing the current HEAD, index, and any uncommitted work. The output \texttt{State} can be used later during a call to \hyperlink{18295332994346533363}{\texttt{restore}} to return the repository to the snapshotted state.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L830-L837}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7028519433729982831}{} 
\hyperlink{7028519433729982831}{\texttt{Base.LibGit2.status}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.status(repo::GitRepo, path::String)
\end{lstlisting}

Lookup the status of the file at \texttt{path} in the git repository \texttt{repo}. For instance, this can be used to check if the file at \texttt{path} has been modified and needs to be staged and committed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/status.jl#L35-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{94175727257767273}{} 
\hyperlink{94175727257767273}{\texttt{Base.LibGit2.tag\_create}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.tag_create(repo::GitRepo, tag::AbstractString, commit; kwargs...)
\end{lstlisting}

Create a new git tag \texttt{tag} (e.g. \texttt{{\textquotedbl}v0.5{\textquotedbl}}) in the repository \texttt{repo}, at the commit \texttt{commit}.

The keyword arguments are:

\begin{itemize}
\item \texttt{msg::AbstractString={\textquotedbl}{\textquotedbl}}: the message for the tag.


\item \texttt{force::Bool=false}: if \texttt{true}, existing references will be overwritten.


\item \texttt{sig::Signature=Signature(repo)}: the tagger{\textquotesingle}s signature.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L27-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14194677754403893948}{} 
\hyperlink{14194677754403893948}{\texttt{Base.LibGit2.tag\_delete}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.tag_delete(repo::GitRepo, tag::AbstractString)
\end{lstlisting}

Remove the git tag \texttt{tag} from the repository \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L17-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9177015962950322666}{} 
\hyperlink{9177015962950322666}{\texttt{Base.LibGit2.tag\_list}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.tag_list(repo::GitRepo) -> Vector{String}
\end{lstlisting}

Get a list of all tags in the git repository \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12586651171771696639}{} 
\hyperlink{12586651171771696639}{\texttt{Base.LibGit2.target}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.target(tag::GitTag)
\end{lstlisting}

The \texttt{GitHash} of the target object of \texttt{tag}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L66-L70}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13475696991682268787}{} 
\hyperlink{13475696991682268787}{\texttt{Base.LibGit2.treewalk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Traverse the entries in a tree and its subtrees in post or pre order.

Function parameter should have following signature:


\begin{lstlisting}
(Cstring, Ptr{Void}, Ptr{Void}) -> Cint
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tree.jl#L3-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11657151798206740880}{} 
\hyperlink{11657151798206740880}{\texttt{Base.LibGit2.upstream}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
upstream(ref::GitReference) -> Nullable{GitReference}
\end{lstlisting}

Determine if the branch containing \texttt{ref} has a specified upstream branch.

\texttt{upstream} returns a \hyperlink{2208920129454296646}{\texttt{Nullable}}, which will be null if the requested branch does not have an upstream counterpart. If the upstream branch does exist, the \texttt{Nullable} contains a \texttt{GitReference} to the upstream branch.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L268-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16448994131242205782}{} 
\hyperlink{16448994131242205782}{\texttt{Base.LibGit2.url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
url(rmt::GitRemote)
\end{lstlisting}

Get the fetch URL of a remote git repository.

\textbf{Example}


\begin{minted}{jlcon}
julia> repo_url = "https://github.com/JuliaLang/Example.jl";

julia> repo = LibGit2.init(mktempdir());

julia> remote = LibGit2.GitRemote(repo, "origin", repo_url);

julia> LibGit2.url(remote)
"https://github.com/JuliaLang/Example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L74-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7557388719652218483}{} 
\hyperlink{7557388719652218483}{\texttt{Base.LibGit2.with}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Resource management helper function



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L604-L606}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10392492346200898016}{} 
\hyperlink{10392492346200898016}{\texttt{Base.LibGit2.workdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.workdir(repo::GitRepo)
\end{lstlisting}

The location of the working directory of \texttt{repo}. This will throw an error for bare repositories.

\begin{quote}
\textbf{Note}

This will typically be the parent directory of \texttt{gitdir(repo)}, but can be different in some cases: e.g. if either the \texttt{core.worktree} configuration variable or the \texttt{GIT\_WORK\_TREE} environment variable is set.

\end{quote}
See also \hyperlink{16866457035365582078}{\texttt{gitdir}}, \hyperlink{13913454255383065948}{\texttt{path}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L165-L178}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4726389115529362401}{}


\section{Module loading}



\texttt{Base.require}[@ref] is responsible for loading modules and it also manages the precompilation cache. It is the implementation of the \texttt{import} statement.



\hypertarget{8895570116735182580}{}


\subsection{Experimental features}



The features below are experimental and not part of the stable Julia API. Before building upon them inform yourself about the current thinking and whether they might change soon.



\hypertarget{14149276766401458683}{}


\subsubsection{Module loading callbacks}



It is possible to listen to the modules loaded by \texttt{Base.require}, by registering a callback.




\begin{minted}{julia}
loaded_packages = Channel{Symbol}()
callback = (mod::Symbol) -> put!(loaded_packages, mod)
push!(Base.package_callbacks, callback)
\end{minted}



Please note that the symbol given to the callback is a non-unique identifier and it is the responsibility of the callback provider to walk the module chain to determine the fully qualified name of the loaded binding.



The callback below is an example of how to do that:




\begin{minted}{julia}
# Get the fully-qualified name of a module.
function module_fqn(name::Symbol)
    fqn = Symbol[name]
    mod = getfield(Main, name)
    parent = Base.module_parent(mod)
    while parent !== Main
        push!(fqn, Base.module_name(parent))
        parent = Base.module_parent(parent)
    end
    fqn = reverse!(fqn)
    return join(fqn, '.')
end
\end{minted}



\chapter{Developing/debugging Julia's C code}


\hypertarget{2099627245904836713}{}


\section{Reporting and analyzing crashes (segfaults)}



So you managed to break Julia.  Congratulations!  Collected here are some general procedures you can undergo for common symptoms encountered when something goes awry.  Including the information from these debugging steps can greatly help the maintainers when tracking down a segfault or trying to figure out why your script is running slower than expected.



If you{\textquotesingle}ve been directed to this page, find the symptom that best matches what you{\textquotesingle}re experiencing and follow the instructions to generate the debugging information requested.  Table of symptoms:



\begin{itemize}
\item \hyperlink{17793108856992155546}{Segfaults during bootstrap (\texttt{sysimg.jl})}


\item \hyperlink{12736555006642116842}{Segfaults when running a script}


\item \hyperlink{15330378602367016422}{Errors during Julia startup}

\end{itemize}


\hypertarget{13046485394122703550}{}


\subsection{Version/Environment info}



No matter the error, we will always need to know what version of Julia you are running. When Julia first starts up, a header is printed out with a version number and date.  If your version is \texttt{0.2.0} or higher, please include the output of \texttt{versioninfo()} in any report you create:




\begin{minted}{jlcon}
julia> versioninfo()
Julia Version 0.6.2
Commit d386e40* (2017-12-13 18:08 UTC)
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz
  WORD_SIZE: 64
  BLAS: libopenblas (NO_LAPACKE DYNAMIC_ARCH NO_AFFINITY Prescott)
  LAPACK: liblapack
  LIBM: libopenlibm
  LLVM: libLLVM-3.9.1 (ORCJIT, broadwell)
\end{minted}



\hypertarget{17793108856992155546}{}


\subsection{Segfaults during bootstrap (\texttt{sysimg.jl})}



Segfaults toward the end of the \texttt{make} process of building Julia are a common symptom of something going wrong while Julia is preparsing the corpus of code in the \texttt{base/} folder.  Many factors can contribute toward this process dying unexpectedly, however it is as often as not due to an error in the C-code portion of Julia, and as such must typically be debugged with a debug build inside of \texttt{gdb}.  Explicitly:



Create a debug build of Julia:




\begin{lstlisting}
$ cd <julia_root>
$ make debug
\end{lstlisting}



Note that this process will likely fail with the same error as a normal \texttt{make} incantation, however this will create a debug executable that will offer \texttt{gdb} the debugging symbols needed to get accurate backtraces.  Next, manually run the bootstrap process inside of \texttt{gdb}:




\begin{lstlisting}
$ cd base/
$ gdb -x ../contrib/debug_bootstrap.gdb
\end{lstlisting}



This will start \texttt{gdb}, attempt to run the bootstrap process using the debug build of Julia, and print out a backtrace if (when) it segfaults.  You may need to hit \texttt{<enter>} a few times to get the full backtrace.  Create a \href{https://gist.github.com}{gist} with the backtrace, the \hyperlink{13046485394122703550}{version info}, and any other pertinent information you can think of and open a new \href{https://github.com/JuliaLang/julia/issues?q=is\%3Aopen}{issue} on Github with a link to the gist.



\hypertarget{12736555006642116842}{}


\subsection{Segfaults when running a script}



The procedure is very similar to \hyperlink{17793108856992155546}{Segfaults during bootstrap (\texttt{sysimg.jl})}.  Create a debug build of Julia, and run your script inside of a debugged Julia process:




\begin{lstlisting}
$ cd <julia_root>
$ make debug
$ gdb --args usr/bin/julia-debug <path_to_your_script>
\end{lstlisting}



Note that \texttt{gdb} will sit there, waiting for instructions.  Type \texttt{r} to run the process, and \texttt{bt} to generate a backtrace once it segfaults:




\begin{lstlisting}
(gdb) r
Starting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl
...
(gdb) bt
\end{lstlisting}



Create a \href{https://gist.github.com}{gist} with the backtrace, the \hyperlink{13046485394122703550}{version info}, and any other pertinent information you can think of and open a new \href{https://github.com/JuliaLang/julia/issues?q=is\%3Aopen}{issue} on Github with a link to the gist.



\hypertarget{15330378602367016422}{}


\subsection{Errors during Julia startup}



Occasionally errors occur during Julia{\textquotesingle}s startup process (especially when using binary distributions, as opposed to compiling from source) such as the following:




\begin{minted}{julia}
$ julia
exec: error -5
\end{minted}



These errors typically indicate something is not getting loaded properly very early on in the bootup phase, and our best bet in determining what{\textquotesingle}s going wrong is to use external tools to audit the disk activity of the \texttt{julia} process:



\begin{itemize}
\item On Linux, use \texttt{strace}:


\begin{lstlisting}
$ strace julia
\end{lstlisting}


\item On OSX, use \texttt{dtruss}:


\begin{lstlisting}
$ dtruss -f julia
\end{lstlisting}

\end{itemize}


Create a \href{https://gist.github.com}{gist} with the \texttt{strace}/ \texttt{dtruss} ouput, the \hyperlink{13046485394122703550}{version info}, and any other pertinent information and open a new \href{https://github.com/JuliaLang/julia/issues?q=is\%3Aopen}{issue} on Github with a link to the gist.



\hypertarget{15861385441225766089}{}


\subsection{Glossary}



A few terms have been used as shorthand in this guide:



\begin{itemize}
\item \texttt{<julia\_root>} refers to the root directory of the Julia source tree; e.g. it should contain folders such as \texttt{base}, \texttt{deps}, \texttt{src}, \texttt{test}, etc.....

\end{itemize}


\hypertarget{10298426124440583682}{}


\section{gdb debugging tips}



\hypertarget{7470105576182008459}{}


\subsection{Displaying Julia variables}



Within \texttt{gdb}, any \texttt{jl\_value\_t*} object \texttt{obj} can be displayed using




\begin{lstlisting}
(gdb) call jl_(obj)
\end{lstlisting}



The object will be displayed in the \texttt{julia} session, not in the gdb session. This is a useful way to discover the types and values of objects being manipulated by Julia{\textquotesingle}s C code.



Similarly, if you{\textquotesingle}re debugging some of Julia{\textquotesingle}s internals (e.g., \texttt{inference.jl}), you can print \texttt{obj} using




\begin{minted}{julia}
ccall(:jl_, Void, (Any,), obj)
\end{minted}



This is a good way to circumvent problems that arise from the order in which julia{\textquotesingle}s output streams are initialized.



Julia{\textquotesingle}s flisp interpreter uses \texttt{value\_t} objects; these can be displayed with \texttt{call fl\_print(fl\_ctx, ios\_stdout, obj)}.



\hypertarget{13194055767125353293}{}


\subsection{Useful Julia variables for Inspecting}



While the addresses of many variables, like singletons, can be be useful to print for many failures, there are a number of additional variables (see \texttt{julia.h} for a complete list) that are even more useful.



\begin{itemize}
\item (when in \texttt{jl\_apply\_generic}) \texttt{mfunc} and \texttt{jl\_uncompress\_ast(mfunc->def, mfunc->code)} :: for figuring out a bit about the call-stack


\item \texttt{jl\_lineno} and \texttt{jl\_filename} :: for figuring out what line in a test to go start debugging from (or figure out how far into a file has been parsed)


\item \texttt{\$1} :: not really a variable, but still a useful shorthand for referring to the result of the last gdb command (such as \texttt{print})


\item \texttt{jl\_options} :: sometimes useful, since it lists all of the command line options that were successfully parsed


\item \texttt{jl\_uv\_stderr} :: because who doesn{\textquotesingle}t like to be able to interact with stdio

\end{itemize}


\hypertarget{7178558395386377758}{}


\subsection{Useful Julia functions for Inspecting those variables}



\begin{itemize}
\item \texttt{jl\_gdblookup(\$rip)} :: For looking up the current function and line. (use \texttt{\$eip} on i686 platforms)


\item \texttt{jlbacktrace()} :: For dumping the current Julia backtrace stack to stderr. Only usable after \texttt{record\_backtrace()} has been called.


\item \texttt{jl\_dump\_llvm\_value(Value*)} :: For invoking \texttt{Value->dump()} in gdb, where it doesn{\textquotesingle}t work natively. For example, \texttt{f->linfo->functionObject}, \texttt{f->linfo->specFunctionObject}, and \texttt{to\_function(f->linfo)}.


\item \texttt{Type->dump()} :: only works in lldb. Note: add something like \texttt{;1} to prevent lldb from printing its prompt over the output


\item \texttt{jl\_eval\_string({\textquotedbl}expr{\textquotedbl})} :: for invoking side-effects to modify the current state or to lookup symbols


\item \texttt{jl\_typeof(jl\_value\_t*)} :: for extracting the type tag of a Julia value (in gdb, call \texttt{macro define jl\_typeof jl\_typeof} first, or pick something short like \texttt{ty} for the first arg to define a shorthand)

\end{itemize}


\hypertarget{1392415358123037898}{}


\subsection{Inserting breakpoints for inspection from gdb}



In your \texttt{gdb} session, set a breakpoint in \texttt{jl\_breakpoint} like so:




\begin{lstlisting}
(gdb) break jl_breakpoint
\end{lstlisting}



Then within your Julia code, insert a call to \texttt{jl\_breakpoint} by adding




\begin{minted}{julia}
ccall(:jl_breakpoint, Void, (Any,), obj)
\end{minted}



where \texttt{obj} can be any variable or tuple you want to be accessible in the breakpoint.



It{\textquotesingle}s particularly helpful to back up to the \texttt{jl\_apply} frame, from which you can display the arguments to a function using, e.g.,




\begin{lstlisting}
(gdb) call jl_(args[0])
\end{lstlisting}



Another useful frame is \texttt{to\_function(jl\_method\_instance\_t *li, bool cstyle)}. The \texttt{jl\_method\_instance\_t*} argument is a struct with a reference to the final AST sent into the compiler. However, the AST at this point will usually be compressed; to view the AST, call \texttt{jl\_uncompress\_ast} and then pass the result to \texttt{jl\_}:




\begin{lstlisting}
#2  0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584
584          abort();
(gdb) p jl_(jl_uncompress_ast(li, li->ast))
\end{lstlisting}



\hypertarget{10952602490249170772}{}


\subsection{Inserting breakpoints upon certain conditions}



\hypertarget{796097711199942153}{}


\subsubsection{Loading a particular file}



Let{\textquotesingle}s say the file is \texttt{sysimg.jl}:




\begin{lstlisting}
(gdb) break jl_load if strcmp(fname, "sysimg.jl")==0
\end{lstlisting}



\hypertarget{11262037379695434792}{}


\subsubsection{Calling a particular method}




\begin{lstlisting}
(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), "method_to_break")==0
\end{lstlisting}



Since this function is used for every call, you will make everything 1000x slower if you do this.



\hypertarget{12553217263049394878}{}


\subsection{Dealing with signals}



Julia requires a few signal to function property. The profiler uses \texttt{SIGUSR2} for sampling and the garbage collector uses \texttt{SIGSEGV} for threads synchronization. If you are debugging some code that uses the profiler or multiple threads, you may want to let the debugger ignore these signals since they can be triggered very often during normal operations. The command to do this in GDB is (replace \texttt{SIGSEGV} with \texttt{SIGUSRS} or other signals you want to ignore):




\begin{lstlisting}
(gdb) handle SIGSEGV noprint nostop pass
\end{lstlisting}



The corresponding LLDB command is (after the process is started):




\begin{lstlisting}
(lldb) pro hand -p true -s false -n false SIGSEGV
\end{lstlisting}



If you are debugging a segfault with threaded code, you can set a breakpoint on \texttt{jl\_critical\_error} (\texttt{sigdie\_handler} should also work on Linux and BSD) in order to only catch the actual segfault rather than the GC synchronization points.



\hypertarget{8144212274800572894}{}


\subsection{Debugging during Julia{\textquotesingle}s build process (bootstrap)}



Errors that occur during \texttt{make} need special handling. Julia is built in two stages, constructing \texttt{sys0} and \texttt{sys.ji}. To see what commands are running at the time of failure, use \texttt{make VERBOSE=1}.



At the time of this writing, you can debug build errors during the \texttt{sys0} phase from the \texttt{base} directory using:




\begin{lstlisting}
julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jl
\end{lstlisting}



You might need to delete all the files in \texttt{usr/lib/julia/} to get this to work.



You can debug the \texttt{sys.ji} phase using:




\begin{lstlisting}
julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jl
\end{lstlisting}



By default, any errors will cause Julia to exit, even under gdb. To catch an error {\textquotedbl}in the act{\textquotedbl}, set a breakpoint in \texttt{jl\_error} (there are several other useful spots, for specific kinds of failures, including: \texttt{jl\_too\_few\_args}, \texttt{jl\_too\_many\_args}, and \texttt{jl\_throw}).



Once an error is caught, a useful technique is to walk up the stack and examine the function by inspecting the related call to \texttt{jl\_apply}. To take a real-world example:




\begin{lstlisting}
Breakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802
802 {
(gdb) p jl_(e)
ErrorException("auto_unbox: unable to determine argument type")
$2 = void
(gdb) bt 10
#0  jl_throw (e=0x7ffdf42de400) at task.c:802
#1  0x00007ffff65412fe in jl_error (str=0x7ffde56be000 <_j_str267> "auto_unbox:
   unable to determine argument type")
   at builtins.c:39
#2  0x00007ffde56bd01a in julia_convert_16886 ()
#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281
...
\end{lstlisting}



The most recent \texttt{jl\_apply} is at frame \#3, so we can go back there and look at the AST for the function \texttt{julia\_convert\_16886}. This is the uniqued name for some method of \texttt{convert}. \texttt{f} in this frame is a \texttt{jl\_function\_t*}, so we can look at the type signature, if any, from the \texttt{specTypes} field:




\begin{lstlisting}
(gdb) f 3
#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281
1281            return f->fptr((jl_value_t*)f, args, nargs);
(gdb) p f->linfo->specTypes
$4 = (jl_tupletype_t *) 0x7ffdf39b1030
(gdb) p jl_( f->linfo->specTypes )
Tuple{Type{Float32}, Float64}           # <-- type signature for julia_convert_16886
\end{lstlisting}



Then, we can look at the AST for this function:




\begin{lstlisting}
(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )
Expr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any, 1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,
Expr(:line, 90, :float.jl)::Any,
Expr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any)::Any
\end{lstlisting}



Finally, and perhaps most usefully, we can force the function to be recompiled in order to step through the codegen process. To do this, clear the cached \texttt{functionObject} from the \texttt{jl\_lamdbda\_info\_t*}:




\begin{lstlisting}
(gdb) p f->linfo->functionObject
$8 = (void *) 0x1289d070
(gdb) set f->linfo->functionObject = NULL
\end{lstlisting}



Then, set a breakpoint somewhere useful (e.g. \texttt{emit\_function}, \texttt{emit\_expr}, \texttt{emit\_call}, etc.), and run codegen:




\begin{lstlisting}
(gdb) p jl_compile(f)
... # your breakpoint here
\end{lstlisting}



\hypertarget{15283936980874101721}{}


\subsection{Debugging precompilation errors}



Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint or catching failures in a precompile worker requires attaching a debugger to the worker. The easiest approach is to set the debugger watch for new process launches matching a given name. For example:




\begin{lstlisting}
(gdb) attach -w -n julia-debug
\end{lstlisting}



or:




\begin{lstlisting}
(lldb) process attach -w -n julia-debug
\end{lstlisting}



Then run a script/command to start precompilation. As described earlier, use conditional breakpoints in the parent process to catch specific file-loading events and narrow the debugging window. (some operating systems may require alternative approaches, such as following each \texttt{fork} from the parent process)



\hypertarget{2874239207045478266}{}


\subsection{Mozilla{\textquotesingle}s Record and Replay Framework (rr)}



Julia now works out of the box with \href{http://rr-project.org/}{rr}, the lightweight recording and deterministic debugging framework from Mozilla. This allows you to replay the trace of an execution deterministically.  The replayed execution{\textquotesingle}s address spaces, register contents, syscall data etc are exactly the same in every run.



A recent version of rr (3.1.0 or higher) is required.



\hypertarget{13430054895263354316}{}


\section{Usando Valgrind con Julia}



\href{http://valgrind.org/}{Valgrind} es una herramienta para deputación de memoria, deteccin de fallos de página y creación de perfiles. Esta sección describe cosas a tner en cuenta cuando se usa Valgrind para depurar cuestiones de memoria con Julia.



\hypertarget{11180677432667553519}{}


\subsection{Consideraciones Generales}



Por defecto, Valgrind asume que no hay código automodificador en el programa que está ejecutando. Esta suposición trabaja bien en la mayoría de las instancias, pero falla miserablemente para un compilador JIT como \texttt{julia}. Por esta razón es crucial pasar \texttt{--smc-check=all-non-file} a \texttt{valgrind}, si no el código puede bloquearse o comportarse de forma inesperada (frecuentemente de una forma sutil).



En algunos casos, para detectar mejor errores de memoria usando Valgrind puede ayudar compilar \texttt{julia} con los \emph{pools} de memoria dehabilitados. El flag de tiempo de compilación \texttt{MEMDEBUG} desabilita los \emph{pools} de memoria en Julia y el flag \texttt{MEMDEBUG2} deshabilita los pools de memoria en FemtoLisp. Para construir \texttt{julia} con ambos flags, añada la siguiente línea a \texttt{Make.user}:




\begin{minted}{julia}
CFLAGS = -DMEMDEBUG -DMEMDEBUG2
\end{minted}



Otra cosa a notar: si nuestros programa usa múltiples procesos workers, es probable que queramos que todos esos procesos worker se ejecuten bajo Valgrind, no sólo bajo el proceso padre. Para hacer esto, pasaremos \texttt{--trace-children=yes} a \texttt{valgrind}.



\hypertarget{13140039522330031277}{}


\subsection{Supresiones}



Valgrind tipicamente mostrará avisos falsos mientras se ejecuta. Para reducir el número de tales avisos, ayuda proporcionar un \href{http://valgrind.org/docs/manual/manual-core.html\#manual-core.suppress}{fichero supresiones} a Valgrind. Un fichero supresiones de ejemplo se incluye en la distribución fuente de Julia en \texttt{contrib/valgrind-julia.supp}.



El fichero de supresiones puede ser usado desde el directorio fuente \texttt{julia/} de la siguiente manera:




\begin{lstlisting}
$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jl
\end{lstlisting}



Any memory errors that are displayed should either be reported as bugs or contributed as additional suppressions.  Note that some versions of Valgrind are \href{https://github.com/JuliaLang/julia/issues/8314\#issuecomment-55766210}{shipped with insufficient default suppressions}, so that may be one thing to consider before submitting any bugs.



\hypertarget{10173787738831416739}{}


\subsection{Running the Julia test suite under Valgrind}



It is possible to run the entire Julia test suite under Valgrind, but it does take quite some time (typically several hours).  To do so, run the following command from the \texttt{julia/test/} directory:




\begin{lstlisting}
valgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia.supp ../julia runtests.jl all
\end{lstlisting}



If you would like to see a report of {\textquotedbl}definite{\textquotedbl} memory leaks, pass the flags \texttt{--leak-check=full --show-leak-kinds=definite} to \texttt{valgrind} as well.



\hypertarget{11463604234155946056}{}


\subsection{Caveats}



Valgrind currently \href{https://bugs.kde.org/show\_bug.cgi?id=136779}{does not support multiple rounding modes}, so code that adjusts the rounding mode will behave differently when run under Valgrind.



In general, if after setting \texttt{--smc-check=all-non-file} you find that your program behaves differently when run under Valgrind, it may help to pass \texttt{--tool=none} to \texttt{valgrind} as you investigate further.  This will enable the minimal Valgrind machinery but will also run much faster than when the full memory checker is enabled.



\hypertarget{7492492303482218484}{}


\section{Sanitizer support}



\hypertarget{527857279218691176}{}


\subsection{General considerations}



Using Clang{\textquotesingle}s sanitizers obviously require you to use Clang (\texttt{USECLANG=1}), but there{\textquotesingle}s another catch: most sanitizers require a run-time library, provided by the host compiler, while the instrumented code generated by Julia{\textquotesingle}s JIT relies on functionality from that library. This implies that the LLVM version of your host compiler matches that of the LLVM library used within Julia.



An easy solution is to have an dedicated build folder for providing a matching toolchain, by building with \texttt{BUILD\_LLVM\_CLANG=1} and overriding \texttt{LLVM\_USE\_CMAKE=1} (Autotool-based builds are incompatible with ASAN). You can then refer to this toolchain from another build folder by specifying \texttt{USECLANG=1} while overriding the \texttt{CC} and \texttt{CXX} variables.



\hypertarget{1061650975116506198}{}


\subsection{Address Sanitizer (ASAN)}



For detecting or debugging memory bugs, you can use Clang{\textquotesingle}s \href{http://clang.llvm.org/docs/AddressSanitizer.html}{address sanitizer (ASAN)}. By compiling with \texttt{SANITIZE=1} you enable ASAN for the Julia compiler and its generated code. In addition, you can specify \texttt{LLVM\_SANITIZE=1} to sanitize the LLVM library as well. Note that these options incur a high performance and memory cost. For example, using ASAN for Julia and LLVM makes \texttt{testall1} takes 8-10 times as long while using 20 times as much memory (this can be reduced to respectively a factor of 3 and 4 by using the options described below).



By default, Julia sets the \texttt{allow\_user\_segv\_handler=1} ASAN flag, which is required for signal delivery to work properly. You can define other options using the \texttt{ASAN\_OPTIONS} environment flag, in which case you{\textquotesingle}ll need to repeat the default option mentioned before. For example, memory usage can be reduced by specifying \texttt{fast\_unwind\_on\_malloc=0} and \texttt{malloc\_context\_size=2}, at the cost of backtrace accuracy. For now, Julia also sets \texttt{detect\_leaks=0}, but this should be removed in the future.



\hypertarget{11752764117060042950}{}


\subsection{Memory Sanitizer (MSAN)}



For detecting use of uninitialized memory, you can use Clang{\textquotesingle}s \href{http://clang.llvm.org/docs/MemorySanitizer.html}{memory sanitizer (MSAN)} by compiling with \texttt{SANITIZE\_MEMORY=1}.



\end{document}
