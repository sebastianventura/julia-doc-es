\documentclass{memoir}

\usepackage{./documenter}
\usepackage{./custom}

\title{The Julia Language}
\author{The Julia Project}

\begin{document}

\frontmatter
\maketitle
\tableofcontents

\mainmatter



\part{Home}


\hypertarget{12349185756005454033}{}


\part{Julia Documentation}



\hypertarget{2114739140119154945}{}


\chapter{Manual}



\begin{itemize}
\item \hyperlink{3498245216777255645}{Introducción}


\item \hyperlink{15293760641260152025}{Empezando}


\item \hyperlink{15778663368769739431}{Variables}


\item \hyperlink{17453309092420764607}{Números Enteros y en Punto Flotante}


\item \hyperlink{16655087771805204817}{Operaciones Matemáticas y Funciones Elementales}


\item \hyperlink{57238021523210895}{Números Complejos y Racionales}


\item \hyperlink{3772396547767597421}{Cadenas}


\item \hyperlink{11836327794581856778}{Funciones}


\item \hyperlink{8710711813610225279}{Control de Flujo}


\item \hyperlink{14993622729045334657}{Ámbito de las Variables}


\item \hyperlink{2141690262982725665}{Tipos}


\item \hyperlink{15216268953652766477}{Métodos}


\item \hyperlink{17317810227993044854}{Constructores}


\item \hyperlink{10686378388163930476}{Conversión y Promoción}


\item \hyperlink{6589646210931807616}{Interfaces}


\item \hyperlink{10438697863683890874}{Módulos}


\item \hyperlink{12287408952024800641}{Documentación}


\item \hyperlink{15444528597476882531}{Metaprogramación}


\item \hyperlink{12380164357355707963}{Arrays Multidimensionales}


\item \hyperlink{11547352483373884762}{Álgebra Lineal}


\item \hyperlink{12120385195625176605}{Redes y Flujos}


\item \hyperlink{3649475918943763834}{Computación Paralela}


\item \hyperlink{14708268282391318496}{Date and DateTime}


\item \hyperlink{11862922961978750349}{Ejecutando Programas Externos}


\item \hyperlink{17572913146419880234}{Invocando Código C y Fortran}


\item \hyperlink{4478407192401635368}{Manejando Variaciones del Sistema Operativo}


\item \hyperlink{1581416507643810205}{Variables de Entorno}


\item \hyperlink{9220662049678686366}{Interactuando con Julia}


\item \hyperlink{7688715278401899796}{Embebiendo Julia}


\item \hyperlink{9952244917530713055}{Paquetes}


\item \hyperlink{13874102823603666739}{Creando Perfiles}


\item \hyperlink{12400320882474083416}{Tazas de Pila}


\item \hyperlink{3908315974291496321}{Consejos de Rendimiento}


\item \hyperlink{14117620934191882930}{Consejos relacionados con \emph{Workflow}}


\item \hyperlink{17403906501138262503}{Guía de Estilo}


\item \hyperlink{2735091372912754285}{\emph{Frequently Asked Questions}}


\item \hyperlink{16083606765476288441}{Diferencias Notables con Otros Lenguajes}


\item \hyperlink{7696893994298815226}{Entrada Unicode}

\end{itemize}


\hypertarget{17232060606527289141}{}


\chapter{Biblioteca Estándar}



\begin{itemize}
\item \hyperlink{4709349624826687157}{Esenciales}


\item \hyperlink{4056407506084571511}{Colecciones y Estructuras de Datos}


\item \hyperlink{8551667013795262933}{Matemáticas}


\item \hyperlink{856545484690558276}{Números}


\item \hyperlink{7104946044181754749}{Cadenas}


\item \hyperlink{14629781252390713372}{Arrays}


\item \hyperlink{10924396624761136101}{Tareas y Computación Paralela}


\item \hyperlink{2892037563719910727}{Álgebra Lineal}


\item \hyperlink{4380185033557519432}{Constantes}


\item \hyperlink{2712977310167057511}{Sistema de Ficheros}


\item \hyperlink{4334683019621329817}{E/S y Redes}


\item \hyperlink{15930311186113323480}{Puntuación}


\item \hyperlink{7484837696332142133}{Ordenación y Funciones Relacionadas}


\item \hyperlink{4492327721069002863}{Funciones del Gestor de Paquetes}


\item \hyperlink{14708268282391318496}{Fechas y Hora}


\item \hyperlink{2381796939793458375}{Utilidades de Iteración}


\item \hyperlink{6239948001455396291}{Realizando Pruebas Unitarias}


\item \hyperlink{6196042923468033404}{Interfaz C}


\item \hyperlink{346568585257401697}{Librería Estándar C}


\item \hyperlink{13427841325685013289}{Enlazador Dinámico}


\item \hyperlink{13874102823603666739}{Realización de Perfiles}


\item \hyperlink{12400320882474083416}{\emph{StackTraces}}


\item \hyperlink{13586267588072234536}{Soporte SIMD}

\end{itemize}


\hypertarget{14783992995395779345}{}


\chapter{Documentación para Desarrolladores}



\begin{itemize}
\item \hyperlink{6456620051738632536}{Reflexión e Introspección}


\item Documentación de los Interiores de Julia

\begin{itemize}
\item \hyperlink{1567551262556259173}{Initialization of the Julia runtime}


\item \hyperlink{92289363194562983}{ASTs de Julia}


\item \hyperlink{7872161424372847354}{Más sobre Tipos}


\item \hyperlink{11666441878855849549}{Memory layout of Julia Objects}


\item \hyperlink{2565512592221324751}{Evaluación de Código Julia}


\item \hyperlink{3417049897160160290}{Convenios de Llamada}


\item \hyperlink{2265182675689203812}{High-level Overview of the Native-Code Generation Process}


\item \hyperlink{10295868153719623313}{Funciones Julia}


\item \hyperlink{10117343183210038440}{Base.Cartesian}


\item \hyperlink{11367980138716686905}{Hablando al Compilador (El Mecanismo \texttt{:meta})}


\item \hyperlink{2417900207528599820}{SubArrays}


\item \hyperlink{4435767086673027446}{Construcción de Imagen del Sistema}


\item \hyperlink{15676237889045834434}{Trabajando con LLVM}


\item \hyperlink{15255383527079538908}{printf() and stdio in the Julia runtime}


\item \hyperlink{15203641602433735164}{Comprobación de Límites}


\item \hyperlink{16029610522337323518}{Proper maintenance and care of multi-threading locks}


\item \hyperlink{12792533311031776054}{Arrays with custom indices}


\item \hyperlink{8108834884169454679}{Base.LibGit2}


\item \hyperlink{4726389115529362401}{Module loading}

\end{itemize}

\item Desarrollo/Depuración de Código C de Julia

\begin{itemize}
\item \hyperlink{2099627245904836713}{Reporting and analyzing crashes (segfaults)}


\item \hyperlink{10298426124440583682}{gdb debugging tips}


\item \hyperlink{13430054895263354316}{Using Valgrind with Julia}


\item \hyperlink{7492492303482218484}{Sanitizer support}

\end{itemize}
\end{itemize}


\part{Manual}


\hypertarget{3498245216777255645}{}


\chapter{Introducción}



La computación científica ha requerido tradicionalmente el máximo rendimiento, aunque los expertos de los distintos dominios se hayan movido en gran parte a los lenguajes dinámicos, más lentos, para el trabajo diario. Creemos que hay muchas buenas razones para preferir lenguajes dinámicos para estas aplicaciones, y no esperamos que su uso disminuya. Afortunadamente, el diseño de lenguajes y las técnicas de compilación modernos permiten casi eliminar el compromiso del rendimiento y proporcionar un solo entorno suficientemente productivo para la creación de prototipos y suficientemente eficiente para implementar aplicaciones de alto rendimiento. El lenguaje de programación de Julia cumple este papel: es un lenguaje dinámico y flexible, apropiado para la computación científica y numérica, con un rendimiento comparable al de los lenguajes tradicionales de tipo estático.



Debido a que el compilador de Julia es diferente de los intérpretes utilizados para lenguajes como Python o R, podría parecer al principio que el rendimiento de Julia no es intuitivo. Si encuentra que algo es lento, le recomendamos que lea la sección \hyperlink{3908315974291496321}{Consejos de Rendimiento} antes de intentar otra cosa. Una vez que entienda cómo funciona Julia, será fácil escribir código casi tan rápido como el código C.



Julia ofrece tipado opcional, despacho múltiple, y buen desempeño, logrado usando inferencia de tipos y \href{https://en.wikipedia.org/wiki/Just-in-time\_compilation}{compilación \emph{just-in-time} (JIT)}, implementada usando \href{https://en.wikipedia.org/wiki/Low\_Level\_Virtual\_Machine}{LLVM}. Es multi-paradigma, combinando características de programación imperativa, funcional y orientada a objetos. Julia proporciona facilidad y expresividad para la computación numérica de alto nivel, de la misma manera que idiomas como R, MATLAB y Python, pero también soporta la programación general. Para conseguirlo, Julia se basa en el linaje de los lenguajes de programación matemáticos, pero también toma prestado mucho de los lenguajes dinámicos populares, incluyendo \href{https://en.wikipedia.org/wiki/Lisp\_(programming\_language)}{Lisp}, \href{https://en.wikipedia.org/wiki/Perl\_(programming\_language)}{Perl}, \href{https://en.wikipedia.org/wiki/Python\_(programming\_language)}{Python}, \href{https://en.wikipedia.org/wiki/Lua\_(programming\_language)}{Lua}, y \href{https://en.wikipedia.org/wiki/Ruby\_(programming\_language)}{Ruby}.



Las diferencias más significativas de Julia de los lenguajes dinámicos típicos son:



\begin{itemize}
\item El lenguaje básico impone muy poco; La biblioteca estándar se ha escrito en el propio Julia, incluyendo operaciones primitivas como la aritmética entera.


\item Un lenguaje enriquecido de tipos para construir y describir objetos, que también se puede utilizar opcionalmente para hacer declaraciones de tipo.


\item La capacidad de definir el comportamiento de la función a través de muchas combinaciones de tipos de argumentos mediante el \href{https://en.wikipedia.org/wiki/Multiple\_dispatch}{despacho múltiple}.


\item Generación automática de código eficiente y especializado para diferentes tipos de argumentos.


\item Buen rendimiento, aproximándose al de los lenguajes compilados estáticamente como C.

\end{itemize}


Aunque a veces se dice de los lenguajes dinámicos que son lenguajes {\textquotedbl}sin tipo{\textquotedbl}, ésto no es cierto en absoluto: cada objeto, ya sea primitivo o definido por el usuario, tiene un tipo. La falta de declaraciones de tipos en la mayoría de los lenguajes dinámicos, sin embargo, significa que uno no puede instruir al compilador acerca de los tipos de valores y, a menudo, no puede hablar explícitamente de tipos en absoluto. En lenguajes estáticos, por otro lado, aunque uno puede -y normalmente debe- anotar tipos para el compilador, los tipos sólo existen en tiempo de compilación y no pueden ser manipulados o expresados en tiempo de ejecución. En Julia, los tipos son objetos en tiempo de ejecución y también se pueden utilizar para transmitir información al compilador.



Aunque el programador casual no necesita usar explícitamente los tipos o el despacho múltiple, ellas son las características centrales unificadoras de Julia: las funciones se definen en diferentes combinaciones de tipos de argumentos y se aplican despachando a la definición concordante más específica. Este modelo se ajusta bien a la programación matemática, donde no es natural que el primer argumento {\textquotedbl}posea{\textquotedbl} una operación como en la programación orientada a objetos tradicional. Los operadores son sólo funciones con notación especial - para ampliar la adición a nuevos tipos de datos definidos por el usuario, se definen nuevos métodos para la función +. El código existente se aplica sin problemas a los nuevos tipos de datos.



En parte debido a la inferencia de tipo en tiempo de ejecución (aumentada por anotaciones de tipos opcionales), y en parte debido a enfoque muy basado en el rendimiento desde el inicio del proyecto, la eficiencia computacional de Julia supera la de otros lenguajes dinámicos e incluso rivaliza con la de lenguajes de compilación estática. Para los problemas numéricos a gran escala, la velocidad siempre ha sido, continúa siendo, y probablemente siempre será crucial: la cantidad de datos procesados se ha mantenido fácilmente al ritmo de la Ley de Moore durante las últimas décadas.



Julia tiene como objetivo crear una combinación sin precedentes de facilidad de uso, potencia y eficiencia en un solo lenguaje de programación. Además de lo anterior, algunas ventajas de Julia sobre sistemas comparables son:



\begin{itemize}
\item Libre y de código abierto (\href{https://github.com/JuliaLang/julia/blob/master/LICENSE.md}{con licencia MIT})


\item Los tipos definidos por el usuario son tan rápidos y compactos como los predefinidos.


\item No hay necesidad de vectorizar código para el rendimiento; el código devectorizado es rápido


\item Diseñado para el paralelismo y la computación distribuida.


\item Hilos {\textquotedbl}verdes{\textquotedbl} de peso ligero (\href{https://en.wikipedia.org/wiki/Coroutine}{coroutinas}).


\item Sistema de tipos discreto pero potente.


\item Conversiones y promociones elegantes y extensibles para números y otros tipos.


\item Soporte eficiente para \href{https://en.wikipedia.org/wiki/Unicode}{Unicode}, incluyendo pero no 

\end{itemize}


limitado a \href{https://en.wikipedia.org/wiki/UTF-8}{UTF-8}



\begin{itemize}
\item Llamada a las funciones C directamente (no se necesitan envolturas o API especiales).


\item Poderosas capacidades tipo shell para administrar otros procesos.


\item Macros similares a Lisp y otras instalaciones de metaprogramación.

\end{itemize}


\hypertarget{15293760641260152025}{}


\chapter{Empezando}



La instalación de Julia es sencilla, ya sea utilizando binarios precompilados o compilando desde la fuente. Descargue e instale Julia siguiendo las instrucciones disponibles en \href{https://julialang.org/downloads/}{https://julialang.org/downloads/}.



La forma más fácil de aprender y experimentar con Julia es iniciando una sesión interactiva (también conocida como \emph{read-eval-print loop} o {\textquotedbl}REPL{\textquotedbl}) haciendo doble clic en el ejecutable de Julia o ejecutando \texttt{julia} desde la línea de mandatos:




\begin{lstlisting}
$ julia
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org
   _ _   _| |_  __ _   |  Type "?help" for help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 0.5.0-dev+2440 (2016-02-01 02:22 UTC)
 _/ |\__'_|_|_|\__'_|  |  Commit 2bb94d6 (11 days old master)
|__/                   |  x86_64-apple-darwin13.1.0

julia> 1 + 2
3

julia> ans
3
\end{lstlisting}



Para salir de la sesión interactiva, escriba \texttt{{\textasciicircum}D} (la tecla de control junto con la tecla \texttt{D}) o escriba \texttt{quit()}. Cuando se ejecuta en modo interactivo, Julia muestra un banner y solicita al usuario la entrada.  Una vez que el usuario ha introducido una expresión completa, como \texttt{1 + 2}, y pulsa \emph{Enter}, la sesión  interactiva evalúa la expresión y muestra su valor. Si se introduce una expresión en una sesión interactiva  con un punto y coma al final, no se muestra su valor. La variable \texttt{ans} está enlazada al valor de la última  expresión evaluada, sea mostrada o no. La variable \texttt{ans} sólo está enlazada a las sesiones interactivas,  no cuando el código Julia se ejecuta de otras maneras.



Para evaluar expresiones escritas en un archivo de origen \texttt{file.jl}, escriba \texttt{include ({\textquotedbl}file.jl{\textquotedbl})}.



Para ejecutar código en un archivo de forma no interactiva, puede darlo como el primer argumento al mandato Julia:




\begin{lstlisting}
$ julia script.jl arg1 arg2...
\end{lstlisting}



Como indica el ejemplo, los siguientes argumentos de línea de mandatos de Julia se toman como argumentos de  línea de mandatos al programa \texttt{script.jl} del programa, pasados a través de la constante global \texttt{ARGS}. El  nombre del propio \emph{script} se pasa como la variable global \texttt{PROGRAM\_FILE}. Tenga en cuenta que \texttt{ARGS}  también se establece cuando se da el código de script usando la opción \texttt{-e} en la línea de órdenes (vea  la salida de ayuda de \texttt{julia} más abajo) pero \texttt{PROGRAM\_FILE} estará vacío. Por ejemplo, para imprimir  los argumentos que se le dan a un script, puede hacer esto:




\begin{lstlisting}
$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar

foo
bar
\end{lstlisting}



O puede poner ese código en un script y ejecutarlo:




\begin{lstlisting}
$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl
$ julia script.jl foo bar
script.jl
foo
bar
\end{lstlisting}



El delimitador \texttt{--} puede usarse para separar argumentos en línea de mandatos al fichero del  \emph{script} a los argumentos de Julia:




\begin{lstlisting}
$ julia --color=yes -O -- foo.jl arg1 arg2..
\end{lstlisting}



Julia se puede iniciar en modo paralelo con las opciones \texttt{-p} o \texttt{--machinefile}. \texttt{-p n} pondrá en marcha un \texttt{n} procesos \emph{worker} adicionales, mientras que \texttt{--machinefile archivo} iniciará un \emph{worker} para cada línea en el archivo de archivo. Las máquinas definidas en el archivo deben ser accesibles a través de un login ssh sin contraseña, con Julia instalado en la misma ubicación que el \emph{host} actual. Cada definición de máquina toma la forma \texttt{[count *] [user @] host [: port] [bind\_addr [: port]]}. El valor por defecto de \texttt{user} es el usuario actual, y el de \texttt{port} el puerto ssh estándar. Las variables opcionales \texttt{bind\_to} \texttt{bind\_addr} \texttt{[: port]} especifican la dirección IP y el puerto que otros \emph{workers} deberían usar para conectarse a este \emph{worker}.



Si tiene código que desea ejecutar cada vez que Julia se inicia, puede ponerlo en \texttt{{\textasciitilde}/.juliarc.jl}:




\begin{lstlisting}
$ echo 'println("Greetings! 你好! 안녕하세요?")' > ~/.juliarc.jl
$ julia
Greetings! 你好! 안녕하세요?

...
\end{lstlisting}



Hay varias formas de ejecutar el código Julia y proporcionar opciones, similares a las disponibles para los programas \texttt{perl} y `ruby:




\begin{lstlisting}
julia [switches] -- [programfile] [args...]
 -v, --version             Display version information
 -h, --help                Print this message

 -J, --sysimage <file>     Start up with the given system image file
 --precompiled={yes|no}    Use precompiled code from system image if available
 --compilecache={yes|no}   Enable/disable incremental precompilation of modules
 -H, --home <dir>          Set location of `julia` executable
 --startup-file={yes|no}   Load ~/.juliarc.jl
 --handle-signals={yes|no} Enable or disable Julia's default signal handlers

 -e, --eval <expr>         Evaluate <expr>
 -E, --print <expr>        Evaluate and show <expr>
 -L, --load <file>         Load <file> immediately on all processors

 -p, --procs {N|auto}      Integer value N launches N additional local worker processes
                           "auto" launches as many workers as the number of local cores
 --machinefile <file>      Run processes on hosts listed in <file>

 -i                        Interactive mode; REPL runs and isinteractive() is true
 -q, --quiet               Quiet startup (no banner)
 --color={yes|no}          Enable or disable color text
 --history-file={yes|no}   Load or save history

 --compile={yes|no|all|min}Enable or disable JIT compiler, or request exhaustive compilation
 -C, --cpu-target <target> Limit usage of cpu features up to <target>
 -O, --optimize={0,1,2,3}  Set the optimization level (default is 2 if unspecified or 3 if specified as -O)
 -g, -g <level>            Enable / Set the level of debug info generation (default is 1 if unspecified or 2 if specified as -g)
 --inline={yes|no}         Control whether inlining is permitted (overrides functions declared as @inline)
 --check-bounds={yes|no}   Emit bounds checks always or never (ignoring declarations)
 --math-mode={ieee,fast}   Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)

 --depwarn={yes|no|error}  Enable or disable syntax and method deprecation warnings ("error" turns warnings into errors)

 --output-o name           Generate an object file (including system image data)
 --output-ji name          Generate a system image data file (.ji)
 --output-bc name          Generate LLVM bitcode (.bc)
 --output-incremental=no   Generate an incremental output file (rather than complete)

 --code-coverage={none|user|all}, --code-coverage
                           Count executions of source lines (omitting setting is equivalent to "user")
 --track-allocation={none|user|all}, --track-allocation
                           Count bytes allocated by each source line
\end{lstlisting}



\hypertarget{106098538461341329}{}


\section{Resources}



Además de este manual, hay otros recursos que pueden ayudar a los usuarios nuevos cuanto empiezan con Julia:



\begin{itemize}
\item \href{http://math.mit.edu/{\textasciitilde}stevenj/Julia-cheatsheet.pdf}{Julia and IJulia cheatsheet}


\item \href{https://learnxinyminutes.com/docs/julia/}{Learn Julia in a few minutes}


\item \href{https://github.com/chrisvoncsefalvay/learn-julia-the-hard-way}{Learn Julia the Hard Way}


\item \href{http://samuelcolvin.github.io/JuliaByExample/}{Julia by Example}


\item \href{https://github.com/dpsanders/hands\_on\_julia}{Hands-on Julia}


\item \href{http://homerreid.dyndns.org/teaching/18.330/JuliaProgramming.shtml}{Tutorial for Homer Reid{\textquotesingle}s numerical analysis class}


\item \href{https://raw.githubusercontent.com/ViralBShah/julia-presentations/master/Fifth-Elephant-2013/Fifth-Elephant-2013.pdf}{An introductory presentation}


\item \href{https://julialang.org/blog/2013/03/julia-tutorial-MIT}{Videos from the Julia tutorial at MIT}


\item \href{https://www.youtube.com/user/JuliaLanguage/playlists}{YouTube videos from the JuliaCons}

\end{itemize}


\hypertarget{15778663368769739431}{}


\chapter{Variables}



Una variable en Julia es un nombre asociado a un valor. Esto es útil cuando pretendemos almacenar un valor (como el que obtenemos después de un cálculo) para un uso posterior. Por ejemplo:




\begin{minted}{jlcon}
# Assign the value 10 to the variable x
julia> x = 10
10

# Doing math with x's value
julia> x + 1
11

# Reassign x's value
julia> x = 1 + 1
2

# You can assign values of other types, like strings of text
julia> x = "Hello World!"
"Hello World!"
\end{minted}



Julia proporciona un sistema muy flexible para nombrar las variables. Los nombres de variable son sensibles a las mayúsculas, y no tienen significado semántico (es decir, que el lenguaje no trata de modo distinto  a las variables basándose en sus nombres).




\begin{minted}{jlcon}
julia> x = 1.0
1.0

julia> y = -3
-3

julia> Z = "My string"
"My string"

julia> customary_phrase = "Hello world!"
"Hello world!"

julia> UniversalDeclarationOfHumanRightsStart = "人人生而自由，在尊严和权利上一律平等。"
"人人生而自由，在尊严和权利上一律平等。"
\end{minted}



Los nombres Unicode (usando codificación UTF-8) están permitidos:




\begin{minted}{jlcon}
julia> δ = 0.00001
1.0e-5

julia> 안녕하세요 = "Hello"
"Hello"
\end{minted}



En el REPL y otros entornos de edición Julia se pueden introducir símbolos matemáticos Unicode usando la notación de \emph{Latex} precedido de backslash y seguido de un tabulador. Por ejemplo, podemos crear el nombre de variable \texttt{δ} tecleando \texttt{{\textbackslash}delta}-\emph{tab}, o incluso el nombre \texttt{α̂₂} tecleando \texttt{{\textbackslash}alpha}-\emph{tab}-\texttt{{\textbackslash}hat}- \emph{tab}-\texttt{{\textbackslash}\_2}-\emph{tab}. (Si encuentras un símbolo en algun sitio, como por ejemplo en el código de alguien, y no sabes como escribirlo, el REPL te ayudará: solamente teclea \texttt{?} y luego pega el símbolo.)



Julia también permite redefinir constantes predefinidas su fuera necesario:




\begin{minted}{jlcon}
julia> pi
π = 3.1415926535897...

julia> pi = 3
WARNING: imported binding for pi overwritten in module Main
3

julia> pi
3

julia> sqrt(100)
10.0

julia> sqrt = 4
WARNING: imported binding for sqrt overwritten in module Main
4
\end{minted}



Sin embargo, esto no se recomienta para evitar una potencial confusión.



\hypertarget{16226997356321536460}{}


\section{Nombres de Variables Permitidos}



Los nombres de variable deben comenzar con una letra (\texttt{A}-\texttt{Z} o \texttt{a}-\texttt{z}), símblo de subrayado, o un subconjunto de puntos Unicode mayores que \texttt{00A0}. En particular, se permiten las \href{http://www.fileformat.info/info/unicode/category/index.htm}{categorías de caracteres Unicode} Lu/Ll/Lt/Lm/Lo/Nl (letras), Sc/So (monedas y otros símbolos), y otros pocos caracteres (por ejemplo, un subconjunto de los símbolos matemáticos Sm). Entre los caracteres subsecuentes se pueden también incluir \texttt{!} y los dígitos (\texttt{0}-\texttt{9} y otros caracteres en las categorías Nd/No), así como otros puntos de código Unicode: diacríticas y otras marcas de modificación (categorías Mn/Mc/Me/Sk), algunos conectores de puntuación (category Pc),  primos, y otros cuantos caracteres.



Los operadores como \texttt{+} son también identificadores válidos, pero son analizados sintácticamente de un modo especial. En algunos contextos, los operadores pueden ser usados justo como variables; por ejemplo \texttt{(+)} se refiere a la función de suma, y \texttt{(+) = f} la reasignará. La mayoría de los operadores infijos Unicode (en la categoría Sm), tal como \texttt{⊕}, son analizados como operadores infijos y están disponibles para métodos definidos por el usuario (por ejemplo, podemos usar \texttt{const ⊗ = kron} para definir \texttt{⊗} como un operador infijo producto de Kronecker).



Los únicos nombres específicamente prohibidos para nombres de variables son los nombres de las instrucciones predefinidas:




\begin{minted}{jlcon}
julia> else = false
ERROR: syntax: unexpected "else"

julia> try = "No"
ERROR: syntax: unexpected "="
\end{minted}



Algunos caracteres Unicode son considerados equivalentes en identificadores. Las distintas formas de introducir caracteres que combinan en Unicode (por ejemplo, acentos) son tratadas como equivalentes (específicamente los identificadores Julia son normalizados NFC). Los caracteres Unicode \texttt{ɛ} (U+025B: Latin small letter open e) y \texttt{µ} (U+00B5: micro sign) son tratados como las letras griegas correspondientes, debido que las primeras son más fácilmente accesibles via alguos métodos de entrada.



\hypertarget{3934387976884252479}{}


\section{Convenciones de Estilo}



Aunque Julia impone pocas restricciones a los nombres válidos, se ha vuelto útil adoptar las  siguientes convenciones:



\begin{itemize}
\item Los nombres de variable van en minúsculas.


\item La separación enre palabras puede indicarse mediante el símbolo de guión bajo, aunque se desaconseja  su uso a menos que los símbolos sean difíciles de leer.


\item Los nombres de tipos y módulos comienzan con mayúscula y la separación entre palabras se representa  con el formato \emph{camel case}.


\item Los nombres de funciones y macros van en minúscula, sin símbolos de guión bajo.


\item Las funciones que escriben en sus argumentos tienen nombres que finalizan con el símbolo de admiración \texttt{!}. Estas suelen ser llamadas funciones {\textquotedbl}mutadoras{\textquotedbl} o funciones {\textquotedbl}\emph{in-place}{\textquotedbl} debido a que pretenden producir 

\end{itemize}


 cambios en sus argumentos después de que la función sea invocada, no solo devolver un valor.



Para más información sobre convenciones de estilo, ver la \hyperlink{17403906501138262503}{Guía de Estilo}.



\hypertarget{17453309092420764607}{}


\chapter{Números enteros y en punto flotante}



Los valores enteros y punto flotante son los bloques constructivos básicos de la aritmética y la computación. Las representaciones predefinidas para estos valores se denominan \emph{tipos primitivos}, mientras que las reprentaciones de números enteros y en punto flotante como valores inmediatos en código se conocen como \emph{literales numéricos}. Por ejemplo, \texttt{1} es un literal entero, mientras que \texttt{1.0} es un literal en punto flotante; sus representaciones binarias en memoria como objetos son los tipos primitivos.



Julia proporciona un amplio rango de tipos primitivos numéricos, y un complemento complemento de operadores aritméticos y de bits así como funciones matemáticas estándar definidas sobre ellos. Los operadores establecen una correspondencia enre los tipos numéricos y las operaciones que son soportadas de forma nativa sobre los ordenadores modernos, permitiendo a Julia sacar plena ventaja de los recursos computacionales. Además, Julia proporciona soporte software para \emph{aritmética de precisión arbitraria} que puede manejar operaciones sobre valores numéricos que no puede ser representada de forma efectiva en representaciones hardware nativas, pero al coste de un rendimiento relativamente menor.



Los tipos primitivos de Julia son los siguientes:



\begin{itemize}
\item \textbf{Tipos enteros:}

\end{itemize}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
Tipo             & Signo? & Número de bits & Valor más pequeño & Valor más grande \\
\hline
\hyperlink{5857518405103968275}{\texttt{Int8}} & ✓ & 8 & -2{\textasciicircum}7 & 2{\textasciicircum}7 - 1 \\
\hline
\hyperlink{6609065134969660118}{\texttt{UInt8}} &   & 8 & 0 & 2{\textasciicircum}8 - 1 \\
\hline
\hyperlink{6667287249103968645}{\texttt{Int16}} & ✓ & 16 & -2{\textasciicircum}15 & 2{\textasciicircum}15 - 1 \\
\hline
\hyperlink{7018610346698168012}{\texttt{UInt16}} &   & 16 & 0 & 2{\textasciicircum}16 - 1 \\
\hline
\hyperlink{10103694114785108551}{\texttt{Int32}} & ✓ & 32 & -2{\textasciicircum}31 & 2{\textasciicircum}31 - 1 \\
\hline
\hyperlink{8690996847580776341}{\texttt{UInt32}} &   & 32 & 0 & 2{\textasciicircum}32 - 1 \\
\hline
\hyperlink{7720564657383125058}{\texttt{Int64}} & ✓ & 64 & -2{\textasciicircum}63 & 2{\textasciicircum}63 - 1 \\
\hline
\hyperlink{5500998675195555601}{\texttt{UInt64}} &   & 64 & 0 & 2{\textasciicircum}64 - 1 \\
\hline
\hyperlink{8012327724714767060}{\texttt{Int128}} & ✓ & 128 & -2{\textasciicircum}127 & 2{\textasciicircum}127 - 1 \\
\hline
\hyperlink{14811222188335428522}{\texttt{UInt128}} &   & 128 & 0 & 2{\textasciicircum}128 - 1 \\
\hline
\hyperlink{46725311238864537}{\texttt{Bool}} & N/A & 8 & \texttt{false} (0) & \texttt{true} (1) \\
\hline
\end{tabulary}

\end{table}



\begin{itemize}
\item \textbf{Tipos en punto flotante:}

\end{itemize}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Tipo             & Precisión                                                                       & Número de bits \\
\hline
\hyperlink{2727296760866702904}{\texttt{Float16}} & \href{https://en.wikipedia.org/wiki/Half-precision\_floating-point\_format}{media} & 16 \\
\hline
\hyperlink{8101639384272933082}{\texttt{Float32}} & \href{https://en.wikipedia.org/wiki/Single\_precision\_floating-point\_format}{sencilla} & 32 \\
\hline
\hyperlink{5027751419500983000}{\texttt{Float64}} & \href{https://en.wikipedia.org/wiki/Double\_precision\_floating-point\_format}{doble} & 64 \\
\hline
\end{tabulary}

\end{table}



Adicionalmente, se ha construído un soporte completo para \hyperlink{57238021523210895}{Números Complejos y Racionales} encima de estos tipos primitivos. Todos los tipos primitivos interoperan de forma natural sin tener que realizar conversiones específicas, gracias a un \hyperlink{10686378388163930476}{sistema de promoción de tipos} flexible y extensible por el usuario.



\hypertarget{13973154041881077585}{}


\section{Enteros}



Los literales enteros se representan del modo estándar:




\begin{minted}{jlcon}
julia> 1
1

julia> 1234
1234
\end{minted}



El tipo por defecto para un literal entero depende de si el sistema de trabajo tiene una aquitectura de 32 o de 64 bits:




\begin{minted}{jlcon}
# 32-bit system:
julia> typeof(1)
Int32

# 64-bit system:
julia> typeof(1)
Int64
\end{minted}



La variable interna de Julia \hyperlink{6553323097149877235}{\texttt{Sys.WORD\_SIZE}} indica si el sistema en el que trabajamos es de 32 bits o de 64 bits:




\begin{minted}{jlcon}
# 32-bit system:
julia> Sys.WORD_SIZE
32

# 64-bit system:
julia> Sys.WORD_SIZE
64
\end{minted}



Julia también define los tipos \texttt{Int} y \texttt{UInt}, que son aliases para los tipos enteros nativos del sistema con y sin signo:




\begin{minted}{jlcon}
# 32-bit system:
julia> Int
Int32
julia> UInt
UInt32

# 64-bit system:
julia> Int
Int64
julia> UInt
UInt64
\end{minted}



Los literales enteros mayores que no pueden ser representados usando sólo 32 bits pero pueden ser representados en 64 bits se crean como enteros de 64 bits, independientemente del tipo que tenga el sistema por defecto:




\begin{minted}{jlcon}
# 32-bit or 64-bit system:
julia> typeof(3000000000)
Int64
\end{minted}



Los enteros sin signo se introducen y se muestran usando el prefijo \texttt{0x} y los dígitos hexadecimales \texttt{0-9a-f} (los dígitos capitalizados \texttt{A-F} también funcionan para la entrada). El tamaño de un valor sin signo está determinado por el número de dígitos hexadecimales usados:




\begin{minted}{jlcon}
julia> 0x1
0x01

julia> typeof(ans)
UInt8

julia> 0x123
0x0123

julia> typeof(ans)
UInt16

julia> 0x1234567
0x01234567

julia> typeof(ans)
UInt32

julia> 0x123456789abcdef
0x0123456789abcdef

julia> typeof(ans)
UInt64
\end{minted}



Este comportamiento está basado en la observación de que cuando uno usa literales hexadecimales sin signo para valores enteros, se los suele utilizar para representar una secuencia de bytes numéricos fijos en lugar de un valor entero.



Recuerde que la variable \hyperlink{11288188119698492222}{\texttt{ans}} contiene el valor de la última expresión evaluada en una sesión interactiva. Esto no ocurre cuando el código Julia se ejecuta de otra forma.



Los literales binarios y octales también están soportados:




\begin{minted}{jlcon}
julia> 0b10
0x02

julia> typeof(ans)
UInt8

julia> 0o10
0x08

julia> typeof(ans)
UInt8
\end{minted}



Los valores máximo y mínimo de tipos primitivos numéricos representables como enteros vienen dados por las funciones  \hyperlink{3613894539247233488}{\texttt{typemin()}} y \hyperlink{17760305803764597758}{\texttt{typemax()}}:




\begin{minted}{jlcon}
julia> (typemin(Int32), typemax(Int32))
(-2147483648, 2147483647)

julia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
           println("$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]")
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]
\end{minted}



Los valores devueltos por \hyperlink{3613894539247233488}{\texttt{typemin()}} y \hyperlink{17760305803764597758}{\texttt{typemax()}} siempre son del tipo de argumento dado. (La expresión anterior utiliza varias características que todavía tenemos que introducir, incluyendo \hyperlink{6800841505698205300}{bucles for}, \hyperlink{3772396547767597421}{Cadenas}, e \hyperlink{12583298261221600612}{Interpolación}, pero debería ser lo suficientemente fácil de entender para los usuarios con cierta experiencia en programación).)



\hypertarget{14418936038439856847}{}


\subsection{Comportamiento ante el Desbordamiento}



En Julia, superar el valor máximo representable de un tipo dado da como resultado un comportamiento envolvente:




\begin{minted}{jlcon}
julia> x = typemax(Int64)
9223372036854775807

julia> x + 1
-9223372036854775808

julia> x + 1 == typemin(Int64)
true
\end{minted}



Así, la aritmética con enteros de Julia es en realidad una forma de \href{https://en.wikipedia.org/wiki/Modular\_arithmetic}{aritmética modular}. Esto refleja las características de la aritmética subyacente de números enteros tal como se implementa en las computadoras modernas. En aplicaciones donde es posible el desbordamiento, es esencial comprobar explícitamente el envolvente producido por el desbordamiento. De lo contrario, se recomienda el tipo \hyperlink{423405808990690832}{\texttt{BigInt}} en \hyperlink{6835190037951372309}{Aritmética de Precisión Arbitraria}.



\hypertarget{7076833061560514546}{}


\subsection{Errores de división}



La división entera (la función \texttt{div}) tiene dos casos excepcionales: división por cero, y dividir el número  negativo más bajo  (\hyperlink{3613894539247233488}{\texttt{typemin()}}) por -1. Ambos casos lanzan un \hyperlink{4168463413201806292}{\texttt{DivideError}}. El resto y las funciones de módulo (\texttt{rem} y \texttt{mod}) lanzan un  \hyperlink{4168463413201806292}{\texttt{DivideError}} cuando su segundo argumento es cero.



\hypertarget{12894353147008502563}{}


\section{Números en Punto Flotante}



Los literales de números en punto flotante son representados en las formas estándar:




\begin{minted}{jlcon}
julia> 1.0
1.0

julia> 1.
1.0

julia> 0.5
0.5

julia> .5
0.5

julia> -1.23
-1.23

julia> 1e10
1.0e10

julia> 2.5e-4
0.00025
\end{minted}



Los resultados anteriores son todos valores \hyperlink{5027751419500983000}{\texttt{Float64}}. Los valores literales \hyperlink{8101639384272933082}{\texttt{Float32}} pueden introducirse escribiendo \texttt{f} en lugar de \texttt{e}:




\begin{minted}{jlcon}
julia> 0.5f0
0.5f0

julia> typeof(ans)
Float32

julia> 2.5f-4
0.00025f0
\end{minted}



Los valores pueden ser convertidos a \hyperlink{8101639384272933082}{\texttt{Float32}} fácilmente:




\begin{minted}{jlcon}
julia> Float32(-1.5)
-1.5f0

julia> typeof(ans)
Float32
\end{minted}



También son válidos los literales de punto flotante en formato hexadecimal, pero sólo como valores \hyperlink{5027751419500983000}{\texttt{Float64}}:




\begin{minted}{jlcon}
julia> 0x1p0
1.0

julia> 0x1.8p3
12.0

julia> 0x.4p-1
0.125

julia> typeof(ans)
Float64
\end{minted}



También esta soportados los números en punto flotante de media precisión (\hyperlink{2727296760866702904}{\texttt{Float16}}), pero ellos están implementados en software y usan \hyperlink{8101639384272933082}{\texttt{Float32}} para los cálculos.




\begin{minted}{jlcon}
julia> sizeof(Float16(4.))
2

julia> 2*Float16(4.)
Float16(8.0)
\end{minted}



El guión bajo (\emph{underscore}) puede usarse como separador de dígitos:




\begin{minted}{jlcon}
julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010
(10000, 5.0e-9, 0xdeadbeef, 0xb2)
\end{minted}



\hypertarget{4698204145764212123}{}


\subsection{Cero en punto flotante}



Los números en punto flotante tienen \href{https://en.wikipedia.org/wiki/Signed\_zero}{dos ceros}, positivo y negativo. Ellos son iguales entre sí, pero tienen distintas representaciones, como puede verse si usamos la función \texttt{bits}:




\begin{minted}{jlcon}
julia> 0.0 == -0.0
true

julia> bits(0.0)
"0000000000000000000000000000000000000000000000000000000000000000"

julia> bits(-0.0)
"1000000000000000000000000000000000000000000000000000000000000000"
\end{minted}



\hypertarget{8368313158411015136}{}


\subsection{Valores especiales en punto flotante}



Hay tres valores especificados en el estándar de punto flotante para valores que no se corresponden  con ningún punto en la línea de números reales:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\texttt{Float16} & \texttt{Float32} & \texttt{Float64} & Name & Description \\
\hline
\texttt{Inf16} & \texttt{Inf32} & \texttt{Inf} & Infinito positivo & Un valor mayor que todos los valores finitos de punto flotante \\
\hline
\texttt{-Inf16} & \texttt{-Inf32} & \texttt{-Inf} & Infinito negativo & Un valor menos que todos los valores finitos de punto flotante \\
\hline
\texttt{NaN16}   & \texttt{NaN32}   & \texttt{NaN}     & \emph{not a number}   & Un valor no \texttt{==} a otro valor en punto flotante (incluido el mismo) \\
\hline
\end{tabulary}

\end{table}



Para más información sobre cómo estos valores de punto flotante no finitos están ordenados entre sí y otros flotantes, vea \hyperlink{10761683973495993636}{Comparaciones Numéricas}. Mediante el \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{estándar IEEE 754}, estos valores de punto flotante son el resultado de ciertas operaciones aritméticas:




\begin{minted}{jlcon}
julia> 1/Inf
0.0

julia> 1/0
Inf

julia> -5/0
-Inf

julia> 0.000001/0
Inf

julia> 0/0
NaN

julia> 500 + Inf
Inf

julia> 500 - Inf
-Inf

julia> Inf + Inf
Inf

julia> Inf - Inf
NaN

julia> Inf * Inf
Inf

julia> Inf / Inf
NaN

julia> 0 * Inf
NaN
\end{minted}



Las funciones \hyperlink{3613894539247233488}{\texttt{typemin()}} y \hyperlink{17760305803764597758}{\texttt{typemax()}} también se aplican a los tipos en punto flotante:




\begin{minted}{jlcon}
julia> (typemin(Float16),typemax(Float16))
(-Inf16, Inf16)

julia> (typemin(Float32),typemax(Float32))
(-Inf32, Inf32)

julia> (typemin(Float64),typemax(Float64))
(-Inf, Inf)
\end{minted}



\hypertarget{15354049390111744640}{}


\subsection{Epsilon de máquina}



La mayoría de los números reales no pueden representarse exactamente con números de coma flotante, por lo que para muchos propósitos es importante conocer la distancia entre dos números de punto flotante representables adyacentes, lo que a menudo se conoce como \href{https://en.wikipedia.org/wiki/Machine\_epsilon}{epsilon de máquina}.



Julia proporciona \hyperlink{4594213520310841636}{\texttt{eps()}}, que da la distancia entre 1,0 y el siguiente valor de punto flotante representable más grande:




\begin{minted}{jlcon}
julia> eps(Float32)
1.1920929f-7

julia> eps(Float64)
2.220446049250313e-16

julia> eps() # same as eps(Float64)
2.220446049250313e-16
\end{minted}



Estos valores son \texttt{2.0{\textasciicircum}-23} y \texttt{2.0{\textasciicircum}-52} como valores \hyperlink{8101639384272933082}{\texttt{Float32}} y \hyperlink{5027751419500983000}{\texttt{Float64}}, respectivamente. La función \hyperlink{4594213520310841636}{\texttt{eps()}} también puede tomar un valor de punto flotante como un argumento y da la diferencia absoluta entre ese valor y el siguiente valor de punto flotante representable. Es decir, \texttt{eps(x)} produce un valor del mismo tipo que \texttt{x} tal que \texttt{x} + \texttt{eps(x)} es el siguiente valor de punto flotante representable mayor que \texttt{x}:




\begin{minted}{jlcon}
julia> eps(1.0)
2.220446049250313e-16

julia> eps(1000.)
1.1368683772161603e-13

julia> eps(1e-27)
1.793662034335766e-43

julia> eps(0.0)
5.0e-324
\end{minted}



La distancia entre dos números de punto flotante representables adyacentes no es constante, pero es menor para valores más pequeños y mayor para valores mayores. En otras palabras, los números de punto flotante representables son más densos en la línea de números reales cerca de cero, y crecen exponencialmente dispersos a medida que uno se aleja de cero. Por definición, \texttt{eps(1.0)} es el mismo que \texttt{eps(Float64)} ya que \texttt{1.0} es un valor de coma flotante de 64 bits.



Julia también proporciona las funciones \hyperlink{8339500090035450608}{\texttt{nextfloat()}} y \hyperlink{14035790731013288499}{\texttt{prevfloat()}} que devuelven el siguiente número de punto flotante representable más grande o más pequeño al argumento, respectivamente:




\begin{minted}{jlcon}
julia> x = 1.25f0
1.25f0

julia> nextfloat(x)
1.2500001f0

julia> prevfloat(x)
1.2499999f0

julia> bits(prevfloat(x))
"00111111100111111111111111111111"

julia> bits(x)
"00111111101000000000000000000000"

julia> bits(nextfloat(x))
"00111111101000000000000000000001"
\end{minted}



Este ejemplo resalta el principio general de que los números de punto flotante representables adyacentes también tienen representaciones binarias enteras adyacentes.



\hypertarget{9332804486077942939}{}


\subsection{Modos de Redondeo}



Si un número no tiene una representación de punto flotante exacta, debe redondearse a un valor representable apropiado. Sin embargo, si se desea, la forma en que se realiza este redondeo puede cambiarse de acuerdo con los modos de redondeo presentados en el \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{estándar IEEE 754}.




\begin{minted}{jlcon}
julia> x = 1.1; y = 0.1;

julia> x + y
1.2000000000000002

julia> setrounding(Float64,RoundDown) do
           x + y
       end
1.2
\end{minted}



El modo predeterminado utilizado siempre es \hyperlink{868115654703135309}{\texttt{RoundNearest}}, , que redondea al valor representable  más cercano, con arcos redondeados hacia el valor más cercano con un bit menos significativo.



\begin{quote}
\textbf{Warning}

El redondeo generalmente sólo es correcto para las funciones aritméticas básicas (\hyperlink{3677358729494553841}{\texttt{+()}},  \hyperlink{8228207173393714756}{\texttt{-()}}, \hyperlink{8486205126068439173}{\texttt{*()}}, \hyperlink{4103478871488785445}{\texttt{/()}} and \hyperlink{4178506499510800909}{\texttt{sqrt()}}) y las operaciones de conversión  de tipos. Muchas otras funciones asumen que el modo por defecto \hyperlink{868115654703135309}{\texttt{RoundNearest}} está  establecido y pueden dar resultados erróneos al operar bajo otros modos de redondeo.

\end{quote}


\hypertarget{91373173144523224}{}


\subsection{Antecedentes y referencias}



La aritmética de punto flotante supone muchas sutilezas que pueden sorprender a los usuarios que no  están familiarizados con los detalles de implementación de bajo nivel. Sin embargo, estas sutilezas  se describen en detalle en la mayoría de los libros sobre computación científica, y también en las  siguientes referencias:



\begin{itemize}
\item La guía definitiva para la aritmética de coma flotante es el estándar [IEEE 754-2008 (http://standards.ieee.org/findstds/standard/754-2008.html); Sin embargo, no está disponible 

\end{itemize}


en línea gratis.



\begin{itemize}
\item Para una presentación breve pero lúcida de cómo los números de punto flotante están 

\end{itemize}


 representados, vea el \href{https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/}{artículo de John D. Cook} sobre el tema, así como su \href{https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/}{introducción} a algunas de las cuestiones que surgen de cómo esta representación difiere en el comportamiento de la abstracción idealizada de números reales.



\begin{itemize}
\item También se recomienda la serie de \href{https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/}{publicaciones de Bruce Dawson sobre números en punto flotante}.


\item Para un excelente y profundo análisis de los números de punto flotante y los problemas de precisión numérica encontrados al calcular con ellos, vea el artículo de David Goldberg \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768\&rep=rep1\&type=pdf}{What Every Computer Scientist Should Know About Floating-Point Arithmetic}.


\item Para una documentación aún más extensa de la historia de, la razón y las cuestiones con los números de punto flotante, así como la discusión de muchos otros temas en la computación numérica, ver los \href{https://people.eecs.berkeley.edu/{\textasciitilde}wkahan/}{escritos recolectados} de \href{https://en.wikipedia.org/wiki/William\_Kahan}{William Kahan}, comúnmente conocido como el {\textquotedbl}padre de punto flotante{\textquotedbl}. De interés particular puede ser \href{https://people.eecs.berkeley.edu/{\textasciitilde}wkahan/ieee754status/754story.html}{An Interview with the Old Man of Floating-Point}.

\end{itemize}


\hypertarget{6835190037951372309}{}


\section{Aritmética de Precisión Arbitraria}



Para permitir cálculos con enteros y números de coma flotante de precisión arbitraria, Julia envuelve la \href{https://gmplib.org}{Biblioteca Aritmética de Precisión Múltiple GNU (GMP)} y la \href{http://www.mpfr.org}{biblioteca GNU MPFR}, respectivamente. Los tipos \hyperlink{423405808990690832}{\texttt{BigInt}} y \hyperlink{749816618809421837}{\texttt{BigFloat}} están disponibles en Julia para números enteros de precisión arbitraria y números de coma flotante, respectivamente.



Existen constructores para crear estos tipos de tipos numéricos primitivos, y podemos también utilizar \hyperlink{13108503824143481717}{\texttt{parse()}} para construirlos a partir de \texttt{AbstractString}s.  Una vez creados, participan en la aritmética con todos los demás tipos numéricos gracias al \hyperlink{10686378388163930476}{mecanismo de promotion y conversion de tipos} de Julia:




\begin{minted}{jlcon}
julia> BigInt(typemax(Int64)) + 1
9223372036854775808

julia> parse(BigInt, "123456789012345678901234567890") + 1
123456789012345678901234567891

julia> parse(BigFloat, "1.23456789012345678901")
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia> BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia> factorial(BigInt(40))
815915283247897734345611269596115894272000000000
\end{minted}



Sin embargo, la promoción de tipos entre los tipos primitivos ya vistos y \hyperlink{423405808990690832}{\texttt{BigInt}}/\hyperlink{749816618809421837}{\texttt{BigFloat}} no es automática y debe ser establecida explícitamente: 




\begin{minted}{jlcon}
julia> x = typemin(Int64)
-9223372036854775808

julia> x = x - 1
9223372036854775807

julia> typeof(x)
Int64

julia> y = BigInt(typemin(Int64))
-9223372036854775808

julia> y = y - 1
-9223372036854775809

julia> typeof(y)
BigInt
\end{minted}



La precisión predeterminada (en número de bits del significado) y el modo de redondeo de las operaciones de \hyperlink{749816618809421837}{\texttt{BigFloat}} pueden cambiarse globalmente llamando \hyperlink{3543074496498234209}{\texttt{setprecision()}} and \hyperlink{12025922235501343815}{\texttt{setrounding()}}, y todos los cálculos adicionales tomarán en cuenta estos cambios. Alternativamente, la precisión o el redondeo se puede cambiar dentro sólo de la ejecución de un bloque particular de código utilizando las mismas funciones dentro de un bloque \texttt{do}:




\begin{minted}{jlcon}
julia> setrounding(BigFloat, RoundUp) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia> setrounding(BigFloat, RoundDown) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia> setprecision(40) do
           BigFloat(1) + parse(BigFloat, "0.1")
       end
1.1000000000004
\end{minted}



\hypertarget{14058350023597195643}{}


\section{Coeficientes Literales Numéricos}



Para hacer más claras fórmulas numéricas y expresiones, Julia permite que las variables sean precedidas inmediatamente por un literal numérico, implicando la multiplicación. Esto hace que la escritura de las expresiones polinómicas sea mucho más limpias:




\begin{lstlisting}
julia> x = 3
3

julia> 2x^2 - 3x + 1
10

julia> 1.5x^2 - .5x + 1
13.0
\end{lstlisting}



También hace que escribir funciones exponenciales sea más elegante:




\begin{lstlisting}
julia> 2^2x
64
\end{lstlisting}



La precedencia de los coeficientes literales numéricos es la misma que la de los operadores unarios como la negación. Así que \texttt{2{\textasciicircum}3x} se analiza como \texttt{2{\textasciicircum}(3x)}, y \texttt{2x{\textasciicircum}3} se analiza como \texttt{2*(x {\textasciicircum} 3)}.



Los literales numéricos también funcionan como coeficientes de las expresiones entre paréntesis:




\begin{lstlisting}
julia> 2(x-1)^2 - 3(x-1) + 1
3
\end{lstlisting}



\begin{quote}
\textbf{Note}

\end{quote}


   La precedencia de coeficientes literales numéricos usada para multiplicación      implícita es mayor que otros operadores binarios tales como la multiplicación     (\texttt{*}), y división (\texttt{/}, \texttt{{\textbackslash}}, and \texttt{//}).  Esto significa, por ejemplo, que      \texttt{1 / 2im} es igual a \texttt{-0.5im} y \texttt{6 // 2(2 + 1)} es igual a \texttt{1 // 1}.



Además, las expresiones entre paréntesis se pueden utilizar como coeficientes a las variables, lo que implica la multiplicación de la expresión por la variable:




\begin{lstlisting}
julia> (x-1)x
6
\end{lstlisting}



Sin embargo, ni la yuxtaposición de dos expresiones entre paréntesis, ni la colocación de una variable antes de una expresión entre paréntesis puede ser usada para implicar multiplicación:




\begin{lstlisting}
julia> (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable

julia> x(x+1)
ERROR: MethodError: objects of type Int64 are not callable
\end{lstlisting}



Ambas expresiones se interpretan como la aplicación de una función: cualquier expresión que no sea un literal numérico, inmediatamente seguida de una entre paréntesis, se interpreta como una función aplicada a los valores entre paréntesis (ver \hyperlink{8538207326577378342}{Funciones} para más información sobre las funciones). Por lo tanto, en ambos casos, se produce un error, ya que el valor de la izquierda no es una función.



Las mejoras sintácticas anteriores reducen significativamente el ruido visual producido al escribir fórmulas matemáticas comunes. Obsérvese que ningún espacio en blanco puede encontrarse entre un coeficiente literal numérico y el identificador o la expresión entre paréntesis que multiplica.



\hypertarget{11622936377746394723}{}


\subsection{Conflictos de Sintaxis}



La sintaxis de los coeficientes literales yuxtapuestos puede entrar en conflicto con dos sintaxis numéricas literales: literales enteros hexadecimales y notación ingenieril para literales de punto flotante. Aquí hay algunas situaciones donde surgen conflictos sintácticos:



\begin{itemize}
\item La expresión literal de enteros hexadecimales \texttt{0xff} podría interpretarse como el literal numérico \texttt{0} multiplicado por la variable \texttt{xff}.


\item La expresión literal de punto flotante \texttt{1e10} podría interpretarse como el literal numérico \texttt{1} multiplicado por la variable \texttt{e10}, e igualmente con la forma \texttt{E} equivalente

\end{itemize}


En ambos casos, resolvemos la ambigüedad a favor de la interpretación como literales numéricos:



\begin{itemize}
\item Las expresiones que comienzan con \texttt{0x} siempre son literales hexadecimales.


\item Las expresiones que empiezan con un literal numérico seguido por e o E siempre son literales de coma flotante.

\end{itemize}


\hypertarget{13462049852775366895}{}


\section{Literales cero and uno}



Julia proporciona funciones que devuelven los literales \texttt{0} y \texttt{1} correspondientes a un tipo especificado o al tipo de una variable dada.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\hyperlink{240596739242881814}{\texttt{zero(x)}} & Literal cero del tipo \texttt{x} o del tipo de la variable \texttt{x} \\
\hline
\hyperlink{11395333326208453101}{\texttt{one(x)}} & Literal uno del tipo \texttt{x} o del tipo de la variable \texttt{x} \\
\hline
\end{tabulary}

\end{table}



Estas funciones son útiles en \hyperlink{10761683973495993636}{comparaciones numéricas} para evitar la sobrecarga de una \hyperlink{10686378388163930476}{conversión de tipo} innecesaria.



Ejemplos:




\begin{minted}{jlcon}
julia> zero(Float32)
0.0f0

julia> zero(1.0)
0.0

julia> one(Int32)
1

julia> one(BigFloat)
1.000000000000000000000000000000000000000000000000000000000000000000000000000000
\end{minted}



\hypertarget{16655087771805204817}{}


\chapter{Mathematical Operations and Elementary Functions}



Julia proporciona una colección completa de operadores aritméticos básicos y de operadores de bits para todos sus tipos numéricos primitivos, así como implementaciones portables y eficientes de una colección comprensiva de funciones matemática estándar.



\hypertarget{13157736738924759674}{}


\section{Operadores Aritméticos}



Los siguientes \href{https://en.wikipedia.org/wiki/Arithmetic\#Arithmetic\_operations}{operadores aritméticos} están soportados sobre todos los tipos primitivos:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Expression & Name & Description \\
\hline
\texttt{+x}       & más unario       & Operación identidad                    \\
\hline
\texttt{-x}       & menos unario     & Inverso matemático de un número \\
\hline
\texttt{x + y} & suma binaria & suma \\
\hline
\texttt{x - y} & menos binario & resta \\
\hline
\texttt{x * y}   & producto         & multiplicación               \\
\hline
\texttt{x / y}   & división         & división                     \\
\hline
\texttt{x {\textbackslash} y}   & división inversa & Equivalente a \texttt{y / x}                 \\
\hline
\texttt{x {\textasciicircum} y}   & potencia         & eleva \texttt{x} a la \texttt{y}-ésima potencia \\
\hline
\texttt{x \% y} & resto & Equivalente a \texttt{rem(x,y)} \\
\hline
\end{tabulary}

\end{table}



así como la negación sobre tipos \hyperlink{46725311238864537}{\texttt{Bool}}:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Expression & Name & Description \\
\hline
\texttt{!x}       & negación & Cambia \texttt{true} a \texttt{false} y viceversa \\
\hline
\end{tabulary}

\end{table}



El sistema de promoción de Julia hace que las operaciones aritméticas sobre mezclas de tipos de argumentos funcione de forma natural y automáticamente. Ver \hyperlink{10686378388163930476}{Conversión y Promoción} para los detalles del sistema de promoción.



He aquí algunos ejemplos simples de usar operadores aritméticos:




\begin{minted}{jlcon}
julia> 1 + 2 + 3
6

julia> 1 - 2
-1

julia> 3*2/12
0.5
\end{minted}



(Por convención, tendemos a separar con menos distancia los operadores cuando se aplican antes de otros operadores cercanos. Por ejemplo, generalmente escribimos \texttt{-x + 2} para reflejar que \texttt{x} primero se niega y, a continuación, \texttt{2} se agrega a ese resultado.)



\hypertarget{12563952200129302862}{}


\section{Operadores bit a bit}



Los siguientes \href{https://en.wikipedia.org/wiki/Bitwise\_operation\#Bitwise\_operators}{operadores bit a bit} son soportados sobre todos los tipos enteros primitivos:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Expression & Name \\
\hline
\texttt{{\textasciitilde}x}       & Negación bit a bit                                                     \\
\hline
\texttt{x \& y}   & Conjunción (\emph{and}) bit a bit                                           \\
\hline
\texttt{x | y}   & Disyunción (\emph{or}) bit a bit                                              \\
\hline
\texttt{x ⊻ y} & \emph{Or} exclusivo bit a bit (\emph{xor}) \\
\hline
\texttt{x >>> y} & \href{https://en.wikipedia.org/wiki/Logical\_shift}{Desplazamiento lógico} hacia la derecha       \\
\hline
\texttt{x >> y}   & \href{https://en.wikipedia.org/wiki/Arithmetic\_shift}{Desplazamiento aritmético} hacia la derecha \\
\hline
\texttt{x << y}   & Desplazamiento hacia la izquierda lógico/aritmético                                         \\
\hline
\end{tabulary}

\end{table}



He aquí algunos ejemplos de uso de operadores bit a bit:




\begin{minted}{jlcon}
julia> ~123
-124

julia> 123 & 234
106

julia> 123 | 234
251

julia> 123 ⊻ 234
145

julia> xor(123, 234)
145

julia> ~UInt32(123)
0xffffff84

julia> ~UInt8(123)
0x84
\end{minted}



\hypertarget{16299219603229115867}{}


\section{Operaciones de actualización}



Cada operador binario aritmético y bit a bit también tiene una versión de actualización que asigna el resultado de la operación de nuevo a su operando izquierdo. La versión de actualización del operador binario se forma colocando a = inmediatamente después del operador. Por ejemplo, escribir \texttt{x += 3} es equivalente a escribir \texttt{x = x + 3}:




\begin{minted}{jlcon}
julia> x = 1
1

julia> x += 3
4

julia> x
4
\end{minted}



Las versiones de actualización de todos los operadores binarios, aritméticos de bits son:




\begin{lstlisting}
+=  -=  *=  /=  \=  ÷=  %=  ^=  &=  |=  ⊻=  >>>=  >>=  <<=
\end{lstlisting}



\begin{quote}
\textbf{Note}

Un operador de actualización reasigna la variable sobre la parte izquierda de la ecuación. Como  resultado, el tipo de la variable puede cambiar:


\begin{minted}{jlcon}
julia> x = 0x01; typeof(x)
UInt8

julia> x *= 2 # Same as x = x * 2
2

julia> typeof(x)
Int64
\end{minted}

\end{quote}


\hypertarget{6173297391052343261}{}


\section{Operadores vectorizados con {\textquotedbl}punto{\textquotedbl}}



Para cada operación binaria como \texttt{{\textasciicircum}} hay su correspondiente operación {\textquotedbl}con punto{\textquotedbl} \texttt{.{\textasciicircum}} que se define \emph{automáticamente} para realizar la operación \texttt{{\textasciicircum}} elemento a elemento sobre arrays. Por ejemplo, la operación \texttt{[1, 2, 3]{\textasciicircum}3} no está definidia, porque no hay un significado matemático estándar para calcular el cubo de un array, pero \texttt{[1, 2, 3].{\textasciicircum}3} si lo está como el cálculo de la operación cubo elemento a elemento (o vectorizada) \texttt{[1{\textasciicircum}3, 2{\textasciicircum}3, 3{\textasciicircum}3]}. Lo mismo puede decirse para operadores unarios tales como \texttt{!} o \texttt{√}, que existe el correspondiente operador vectorizado \texttt{.√} que aplica el operador elemento a elemento.




\begin{minted}{jlcon}
julia> [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27
\end{minted}



Más específicamente, \texttt{a .{\textasciicircum} b} es analizado como la \hyperlink{13590013989415065742}{llamada punto} \texttt{({\textasciicircum}).(a,b)}, que realiza una operación de \hyperlink{6411237952146762090}{retransmisión (\emph{broadcast})}: ella puede combinar arrays y escalares, arrays del mismo tamaño (realizando la operación elemento a elemento), o incluso arrays de diferentes formas (por ejemplo, combinar vectores fila y columna para producir una matriz). Además, como todas las {\textquotedbl}llamadas punto{\textquotedbl}, estos {\textquotedbl}operadores punto{\textquotedbl} están \emph{fusionados}. Por ejemplo, si calculamos \texttt{2 .* A.{\textasciicircum}2 .+ sin.(A)} (o, equivalentemente \texttt{@. 2A{\textasciicircum}2 + sin(A)}, usando la macro \hyperlink{16688502228717894452}{\texttt{@.}}) para un array \texttt{A}, se realiza un \emph{único} bucle sobre \texttt{A}, computando \texttt{2a{\textasciicircum}2 + sin(a)} para cada elemento de \texttt{A}. En particular, las llamadas vectorizadas anidadas como \texttt{f.(g.(x))} están \emph{fusionadas}, y los operadores binarios adyacentes como \texttt{x .+ 3 .* x.{\textasciicircum}2} son equivalentes a llamadas vectorizadas anidadas \texttt{(+).(x, (*).(3, ({\textasciicircum}).(x, 2)))}.



Además, los operadores de actualización {\textquotedbl}vectorizados{\textquotedbl} como \texttt{a .+= b} (o \texttt{@. a += b}) son transformados en \texttt{a .= a .+ b}, donde \texttt{.=} es un operador de asignación \emph{fusionado} \emph{in-place} (ver la \hyperlink{13590013989415065742}{documentación de la sintaxis vectorizada}).



Nótese que la sintaxis de punto es también aplicable a operadores definidos por el usuario. Por ejemplo, si definimos el operador \texttt{⊗(A,B) = kron(A,B)} para dar una sintaxis infija \texttt{A ⊗ B} al producto de Kronecker (\hyperlink{14153417388267953812}{\texttt{kron}}), entonces \texttt{[A,B] .⊗ [C,D]} calculará  \texttt{[A⊗C, B⊗D]} sin ninguna codificación adicional.



\hypertarget{10761683973495993636}{}


\section{Comparaciones Numéricas}



Los operadores de comparación estándar están definidos para todos los tipos numéricos primitivos:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Operador & Nombre \\
\hline
\hyperlink{15143149452920304570}{\texttt{==}} & Igualdad \\
\hline
\hyperlink{3046079188653285114}{\texttt{!=}}, \hyperlink{3046079188653285114}{\texttt{≠}} & Desigualdad \\
\hline
\hyperlink{702782232449268329}{\texttt{<}} & Menor que \\
\hline
\hyperlink{11411050964021316526}{\texttt{<=}}, \hyperlink{11411050964021316526}{\texttt{≤}} & Menor o igual que \\
\hline
\hyperlink{8677991761303191103}{\texttt{>}} & Mayor que \\
\hline
\hyperlink{7019639580556993898}{\texttt{>=}}, \hyperlink{7019639580556993898}{\texttt{≥}} & Mayor o igual que \\
\hline
\end{tabulary}

\end{table}



He aquí algunos ejemplos:




\begin{minted}{jlcon}
julia> 1 == 1
true

julia> 1 == 2
false

julia> 1 != 2
true

julia> 1 == 1.0
true

julia> 1 < 2
true

julia> 1.0 > 3
false

julia> 1 >= 1.0
true

julia> -1 <= 1
true

julia> -1 <= -1
true

julia> -1 <= -2
false

julia> 3 < -0.5
false
\end{minted}



Los enteros se comparan de un modo estándar, mediante comparación de bits. Los números de punto flotante se comparan de acuerdo al \href{https://en.wikipedia.org/wiki/IEEE\_754-2008}{estándar IEEE 754}:



\begin{itemize}
\item Los números finitos son ordenados del modo habitual.


\item El cero positivo es igual pero no mayor que el cero negativo.


\item \texttt{Inf} es igual a si mismo y mayor que todo excepto \texttt{NaN}


\item \texttt{-Inf} es igual a si mismo y menor que todo excepto \texttt{NaN}


\item \texttt{NaN} no es igual, mayor o menor a nadie, excepto a sí mismo.

\end{itemize}


Este último punto es potencialmente sorprendente y, por tanto, vale la pena señalar que:




\begin{minted}{jlcon}
julia> NaN == NaN
false

julia> NaN != NaN
true

julia> NaN < NaN
false

julia> NaN > NaN
false
\end{minted}



y puede causar dolores de cabeza especiales con \hyperlink{15299817005323384893}{Arrays}:




\begin{minted}{jlcon}
julia> [1 NaN] == [1 NaN]
false
\end{minted}



Julia proporciona funciones adicionales para comprobar números para valores especiales, lo cuál pueden ser útil en situaciones como las comparaciones de claves hash:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Tests if \\
\hline
\hyperlink{12829995639916057841}{\texttt{isequal(x, y)}} & \texttt{x} e \texttt{y} son idénticos \\
\hline
\hyperlink{2906021895910968108}{\texttt{isfinite(x)}}   & \texttt{x} es un número finito \\
\hline
\hyperlink{4492113908831448207}{\texttt{isinf(x)}} & \texttt{x} es infinito \\
\hline
\hyperlink{6770390199496851634}{\texttt{isnan(x)}}     & \texttt{x} no es un número \\
\hline
\end{tabulary}

\end{table}



\hyperlink{12829995639916057841}{\texttt{isequal()}} considera los \texttt{NaN}s iguales entre sí:




\begin{minted}{jlcon}
julia> isequal(NaN, NaN)
true

julia> isequal([1 NaN], [1 NaN])
true

julia> isequal(NaN, NaN32)
true
\end{minted}



\texttt{isequal()} también puede usarse para distinguir los ceros con signo:




\begin{minted}{jlcon}
julia> -0.0 == 0.0
true

julia> isequal(-0.0, 0.0)
false
\end{minted}



Las comparaciones de tipos mezclados entre enteros con signo, enteros sin signo y valores en punto flotante pueden ser complicadas. Se ha tomado mucho cuidado para asegurarse de que Julia las realiza correctamente.



Para otros tipos, \texttt{isequal()} llama por defecto a \hyperlink{15143149452920304570}{\texttt{==()}}, así que si uno quiere definir la igualdad para sus propios tipos, solo tiene que agregar un método \hyperlink{15143149452920304570}{\texttt{==()}}.  Si uno define suu propia función de igualdad, probablemente deba definir un método \hyperlink{13797072367283572032}{\texttt{hash()}} correspondiente para asegurar de que \texttt{isequal(x,y)} implica \texttt{hash(x) == hash(y)}.



\hypertarget{266289900573141417}{}


\subsection{Comparaciones Encadenadas}



A diferencia de la mayoría de los idiomas, \href{https://en.wikipedia.org/wiki/Python\_syntax\_and\_semantics\#Comparison\_operators}{con la notable excepción de Python}, las comparaciones pueden encadenarse arbitrariamente:




\begin{minted}{jlcon}
julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
true
\end{minted}



El encadenamiento de comparaciones suele ser bastante conveniente en el código numérico. Las comparaciones encadenadas utilizan el operador \texttt{\&\&} para comparaciones escalares y el operador \hyperlink{1494761116451616317}{\texttt{\&}} para comparaciones elemento a elemento, lo que les permite trabajar sobre arrays. Por ejemplo, \texttt{0 .< A .< 1} da un array booleano cuyas entradas son \texttt{true} en posiciones en las que los elementos correspondientes de A están entre 0 y 1.



Nótese el comportamiento de evaluación de las comparaciones encadenadas:




\begin{minted}{jlcon}
julia> v(x) = (println(x); x)
v (generic function with 1 method)

julia> v(1) < v(2) <= v(3)
2
1
3
true

julia> v(1) > v(2) <= v(3)
2
1
false
\end{minted}



La expresión del medio sólo se evalúa una vez, en lugar de dos veces como lo sería si la expresión se escribiera como \texttt{v(1) < v(2) \&\& v(2) <= v(3)}. Sin embargo, el orden de las evaluaciones en una comparación encadenada no está definido. Se recomienda encarecidamente no utilizar expresiones que puedan tener efectos secundarios (como la impresión) en comparaciones encadenadas. Si se requieren efectos secundarios, se debe utilizar explícitamente el operador de cortocircuito \texttt{\&\&} (ver \hyperlink{10787134294480612893}{Evaluación en cortocircuito}).



\hypertarget{17395527405393843522}{}


\subsection{Funciones Elementales}



Julia proporciona una colección completa de funciones matemáticas y operadores. Estas operaciones matemáticas se definen sobre una clase de valores numéricos suficientemente amplia como para permitir definiciones apropiadas para enteros, números de punto flotante, racionales y complejos, dondequiera que tales definiciones tengan sentido.



Además, estas funciones (como cualquier función de Julia) se pueden aplicar de manera {\textquotedbl}vectorizada{\textquotedbl} a matrices y otras colecciones con la \hyperlink{13590013989415065742}{sintaxis vectorizada} \texttt{f.(A)}, por ejemplo, sin.(A) calculará el seno de cada elemento de una matriz \texttt{A}. 



\hypertarget{7500087798079418771}{}


\section{Precedencia de Operadores}



Julia applies the following order of operations, from highest precedence to lowest:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Categorí       & Operadores                                                                                        \\
\hline
Syntax & \texttt{.} seguido por \texttt{::} \\
\hline
Exponentiation & \texttt{{\textasciicircum}} \\
\hline
Fractions & \texttt{//} \\
\hline
Multiplication & \texttt{* / \% \& {\textbackslash}} \\
\hline
Bitshifts & \texttt{<< >> >>>} \\
\hline
Addition & \texttt{+ - | ⊻} \\
\hline
Syntax & \texttt{: ..} seguido por \texttt{|>} \\
\hline
Comparisons & \texttt{> < >= <= == === != !== <:} \\
\hline
Control flow & \texttt{\&\&} seguido por \texttt{||} seguido por \texttt{?} \\
\hline
Assignments & \texttt{= += -= *= /= //= {\textbackslash}= {\textasciicircum}= ÷= \%= |= \&= ⊻= <<= >>= >>>=} \\
\hline
\end{tabulary}

\end{table}



Para una lista completa de cada una de las precedencias de operadores de Julia, consultar el fichero \href{https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm}{\texttt{src/julia-parser.scm}}



También puede encontrarse la precedencia numérica pra cualquier operación dada mediante la función intrínseca \texttt{Base.operator\_precedence} donde el número mayor corresponde a la operación con mayor precedencia.




\begin{minted}{jlcon}
julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(9, 11, 15)

julia> Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(1, 1)
\end{minted}



\hypertarget{6654486840782085972}{}


\section{Conversiones Numéricas}



Julia soporta tres formas de conversión numérica, que difieren en su manejo de las conversiones inexactas.



\begin{itemize}
\item La notación \texttt{T(x)} o \texttt{convert(T,x)} convierte \texttt{x} a un valor de tipo \texttt{T}.

\begin{itemize}
\item Si \texttt{T} es un tipo en punto flotante, el resultado es el valor más cercano representable, que podría ser infinito positivo o negativo.


\item Si \texttt{T} es un tipo entero, se lanzará un \texttt{InexactError} si \texttt{x}no es representable por \texttt{T}.

\end{itemize}

\item \texttt{x \% T}convierte un entero \texttt{x} a un valor de un tipo entero \texttt{T} congruente a \texttt{x} modulo \texttt{2{\textasciicircum}n}, donde \texttt{n} es el número de bits en \texttt{T}. En otras palabras, la representación binaria es truncada para ajustarse.


\item Las \hyperlink{7716310024856559840}{Funciones de Redondeo} toman un tipo \texttt{T} como argumento opcional. Por ejemplo, \texttt{round(Int,x)} es una abreviatura de \texttt{Int(round(x))}.

\end{itemize}


Los siguientes ejemplos muestran las siguientes formas:




\begin{minted}{jlcon}
julia> Int8(127)
127

julia> Int8(128)
ERROR: InexactError()
Stacktrace:
 [1] Int8(::Int64) at ./sysimg.jl:77

julia> Int8(127.0)
127

julia> Int8(3.14)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int8}, ::Float64) at ./float.jl:658
 [2] Int8(::Float64) at ./sysimg.jl:77

julia> Int8(128.0)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int8}, ::Float64) at ./float.jl:658
 [2] Int8(::Float64) at ./sysimg.jl:77

julia> 127 % Int8
127

julia> 128 % Int8
-128

julia> round(Int8,127.4)
127

julia> round(Int8,127.6)
ERROR: InexactError()
Stacktrace:
 [1] trunc(::Type{Int8}, ::Float64) at ./float.jl:651
 [2] round(::Type{Int8}, ::Float64) at ./float.jl:337
\end{minted}



Ver \hyperlink{10686378388163930476}{Conversión y Promoción} para ver cómo definir tus propias conversiones y promociones.



\hypertarget{7716310024856559840}{}


\subsection{Funciones de Redondeo}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Función              & Descripción                       & Tipo devuelto \\
\hline
\hyperlink{7894166454005036294}{\texttt{round(x)}} & Redondea \texttt{x} al entero más cercano & \texttt{typeof(x)} \\
\hline
\hyperlink{7894166454005036294}{\texttt{round(T, x)}} & Redondea \texttt{x} al entero más cercano & \texttt{T} \\
\hline
\hyperlink{13948277906659863497}{\texttt{floor(x)}} & Redondea \texttt{x} hacia \texttt{-Inf} & \texttt{typeof(x)} \\
\hline
\hyperlink{13948277906659863497}{\texttt{floor(T, x)}} & Redondea \texttt{x} hacia \texttt{-Inf} & \texttt{T} \\
\hline
\hyperlink{11509984064218511874}{\texttt{ceil(x)}} & Redondea \texttt{x} hacia \texttt{+Inf} & \texttt{typeof(x)} \\
\hline
\hyperlink{11509984064218511874}{\texttt{ceil(T, x)}} & Redondea \texttt{x} hacia \texttt{+Inf} & \texttt{T} \\
\hline
\hyperlink{7412479111462927551}{\texttt{trunc(x)}} & Redondea \texttt{x} hacia cero & \texttt{typeof(x)} \\
\hline
\hyperlink{7412479111462927551}{\texttt{trunc(T, x)}} & Redondea \texttt{x} hacia cero & \texttt{T} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{3212114314897108312}{}


\subsection{Funciones de División}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Función              & Descripción                                                                                        \\
\hline
\hyperlink{8020976424566491334}{\texttt{div(x,y)}} & División truncada; cociente redondeado hacia cero \\
\hline
\hyperlink{15067916827074788527}{\texttt{fld(x,y)}} & División \emph{floored}; cociente redondeado hacia \texttt{-Inf} \\
\hline
\hyperlink{7922388465305816555}{\texttt{cld(x,y)}} & División \emph{ceiling}; cociente redondeado hacia \texttt{+Inf} \\
\hline
\hyperlink{3827563084771191385}{\texttt{rem(x,y)}}   & Resto; satisface \texttt{x == div(x,y)*y + rem(x,y)}; el signo se corresponde con el de \texttt{x}               \\
\hline
\hyperlink{2082041235715276573}{\texttt{mod(x,y)}} & Módulo; satisface \texttt{x == fld(x,y)*y + mod(x,y)}; el signo se corresponde con el de \texttt{y} \\
\hline
\hyperlink{13778479217547823795}{\texttt{mod1(x,y)}} & Módulo con un desplazamiento de 1; devuelve \texttt{r∈(0,y]} para \texttt{y>0} o \texttt{r∈[y,0)} para \texttt{y<0}, donde \texttt{mod(r, y) == mod(x, y)} \\
\hline
\hyperlink{15322754370885673769}{\texttt{mod2pi(x)}} & Módulo con respecto a 2pi; \texttt{0 <= mod2pi(x)  < 2pi} \\
\hline
\hyperlink{6106909621813654214}{\texttt{divrem(x,y)}} & Devuelve \texttt{(div(x,y),rem(x,y))} \\
\hline
\hyperlink{2806360720034558325}{\texttt{fldmod(x,y)}} & Devuelve \texttt{(fld(x,y),mod(x,y))} \\
\hline
\hyperlink{15906911311436241979}{\texttt{gcd(x,y...)}} & Máximo común divisor positivo de \texttt{x}, \texttt{y},... \\
\hline
\hyperlink{12975400110924105221}{\texttt{lcm(x,y...)}} & Mínimo común múltiplo positivo de \texttt{x}, \texttt{y},... \\
\hline
\end{tabulary}

\end{table}



\hypertarget{13638006402813685584}{}


\subsection{Funciones de signo y valor absoluto}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Función                & Descripción                                               \\
\hline
\hyperlink{9614495866226399167}{\texttt{abs(x)}} & Un valor positivo con la magnitud de \texttt{x} \\
\hline
\hyperlink{15686257922156163743}{\texttt{abs2(x)}} & El cuadrado de la magnitud de \texttt{x} \\
\hline
\hyperlink{14349105033929355161}{\texttt{sign(x)}} & Indica el signo de \texttt{x}, devolviendo -1, 0, o +1 \\
\hline
\hyperlink{9457038569823603490}{\texttt{signbit(x)}} & Indica que si el bit de signo está en \textbf{on} (\texttt{true}) o en \textbf{off} (\texttt{false}) \\
\hline
\hyperlink{6024566200716053110}{\texttt{copysign(x,y)}} & Indica un valor con la magnitud de \texttt{x} y el signo de \texttt{y}   \\
\hline
\hyperlink{2689022981470151558}{\texttt{flipsign(x,y)}} & Indica un valor con la magnitud de \texttt{x} y el signo de \texttt{x*y} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12769978340812816097}{}


\subsection{Potencias, logaritmos y raíces}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Función & Descripción \\
\hline
\hyperlink{4178506499510800909}{\texttt{sqrt(x)}}, \texttt{√x} & Raíz cuadrada de \texttt{x}                                                      \\
\hline
\hyperlink{15104025502404840355}{\texttt{cbrt(x)}}, \texttt{∛x} & Raíz cúbica de \texttt{x}                                                         \\
\hline
\hyperlink{18304489571285447949}{\texttt{hypot(x,y)}} & Hipotenusa del triángulo rectángulo cuyos catetos son de longitudes \texttt{x} e \texttt{y} \\
\hline
\hyperlink{5754159997488499390}{\texttt{exp(x)}}         & Función exponencial natural sobre \texttt{x}                                     \\
\hline
\hyperlink{4939309737829480377}{\texttt{expm1(x)}} & Valor exacto de \texttt{exp(x)-1} para  \texttt{x} cercano a zero \\
\hline
\hyperlink{14721177606508229464}{\texttt{ldexp(x,n)}} & \texttt{x*2{\textasciicircum}n} calculado eficientemente para valores enteros de \texttt{n} \\
\hline
\hyperlink{8009828793607756367}{\texttt{log(x)}} & Logaritmo neperiano de \texttt{x} \\
\hline
\hyperlink{8009828793607756367}{\texttt{log(b,x)}} & Logaritmo en base \texttt{b} de \texttt{x} \\
\hline
\hyperlink{18341149201477905713}{\texttt{log2(x)}} & Logaritmo en base 2 de \texttt{x} \\
\hline
\hyperlink{3481560771470480868}{\texttt{log10(x)}} & Logaritmo decimal de \texttt{x} \\
\hline
\hyperlink{5533050447473188877}{\texttt{log1p(x)}} & Valor exacto de \texttt{log(1+x)} para \texttt{x} cercano a cero \\
\hline
\hyperlink{39736318364195845}{\texttt{exponent(x)}} & Exponente binario de  \texttt{x} \\
\hline
\hyperlink{11312242195671521747}{\texttt{significand(x)}} & Significando binario (alias \emph{mantisa}) de un número en punto flotante \texttt{x} \\
\hline
\end{tabulary}

\end{table}



Para una explicación de por qué son necesarias funciones como \hyperlink{18304489571285447949}{\texttt{hypot()}}, \hyperlink{4939309737829480377}{\texttt{expm1()}}, and \hyperlink{5533050447473188877}{\texttt{log1p()}}, véase el excelente par de artículos en el blog de John D. Cook{\textquotesingle}s sobre el tema: \href{https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/}{expm1, log1p, erfc}, e \href{https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/}{hypot}.



\hypertarget{15332949081998190776}{}


\subsection{Funciones Trigonométricas e Hiperbólicas}



Todas las funciones trigonométricas e hiperbólicas estándar están también definidas:




\begin{lstlisting}
sin    cos    tan    cot    sec    csc
sinh   cosh   tanh   coth   sech   csch
asin   acos   atan   acot   asec   acsc
asinh  acosh  atanh  acoth  asech  acsch
sinc   cosc   atan2
\end{lstlisting}



Son todas funciones de un solo argumento, con la excepción de  \href{https://en.wikipedia.org/wiki/Atan2}{atan2}, que da el ángulo en \href{https://en.wikipedia.org/wiki/Radian}{radians} entre el eje \emph{x} y el punto especificado por sus argumentos, interpretado como sus coordenadas \emph{x} e \emph{y}.



Adicionalmente, se proporcionan \hyperlink{16554510911661822298}{\texttt{sinpi(x)}} e \hyperlink{2974547424856180253}{\texttt{cospi(x)}} para cálculos más exactos de \hyperlink{1413692256182243634}{\texttt{sin(pi*x)}} y \hyperlink{3839439755891439510}{\texttt{cos(pi*x)}} respectivamente.



Para computar funciones trigonométricas con grados en lugar de con rdianes, añada al nombre de la función el sufijo \texttt{d}. Por ejemplo, \hyperlink{38337471195460170}{\texttt{sind(x)}} calcula el seno de \texttt{x}, donde \texttt{x} se especifica en grados. La lista completa de funciones trigonométricas con variantes grados es:




\begin{lstlisting}
sind   cosd   tand   cotd   secd   cscd
asind  acosd  atand  acotd  asecd  acscd
\end{lstlisting}



\hypertarget{2071051749003726620}{}


\subsection{Funciones Especiales}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Función               & Descripción \\
\hline
\hyperlink{12101057483100859108}{\texttt{gamma(x)}}   & \href{https://en.wikipedia.org/wiki/Gamma\_function}{Función gamma} en \texttt{x} \\
\hline
\hyperlink{16944460120463679422}{\texttt{lgamma(x)}} & Valor exacto de \texttt{log(gamma(x))} para valores grandes de \texttt{x} \\
\hline
\hyperlink{15642673718348524569}{\texttt{lfact(x)}} & Valor exacto de  \texttt{log(factorial(x))} para valores grandes de  \texttt{x}; igual que \texttt{lgamma(x+1)} para \texttt{x > 1}, cero en otros caso \\
\hline
\hyperlink{3070115649335374621}{\texttt{beta(x,y)}}   & \href{https://en.wikipedia.org/wiki/Beta\_function}{Función beta} en \texttt{x,y} \\
\hline
\hyperlink{15599420217619146595}{\texttt{lbeta(x,y)}} & Valor exacto de  \texttt{log(beta(x,y))} para valores grandes de \texttt{x} o \texttt{y} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{57238021523210895}{}


\chapter{Números Racionales y Complejos}



Julia se distribuye con tipos predefinidos que representan números complejos y racionales, y soporta todas las \hyperlink{16655087771805204817}{Operaciones Matemáticas y Funciones Elementales} estándar sobre ellos. Se han definido \hyperlink{10686378388163930476}{conversiones y promociones} de modo que las operaciones con cualquier combinación de tipos numéricos predefinidos, primitivos o compuestos, se comporten como se esperaba.



como se esperaba.



\hypertarget{17137958748126161191}{}


\section{Números Complejos}



La constante global \hyperlink{15097910740298861288}{\texttt{im}} está ligada al número complejo \emph{i}, que representa la raíz cuadrada principal de -1. Se consideró nocivo para co-optar el nombre \texttt{i} para una constante global, ya que es un nombre de variable de índice popular. Como Julia permite que los literales numéricos se \hyperlink{14058350023597195643}{yuxtapongan con identificadores como coeficientes}, esta unión es suficiente para proporcionar sintaxis conveniente para números complejos, similar a la notación matemática tradicional:




\begin{minted}{jlcon}
julia> 1 + 2im
1 + 2im
\end{minted}



Podemos realizar todas las operaciones aritméticas estándar con los números complejos:




\begin{minted}{jlcon}
julia> (1 + 2im)*(2 - 3im)
8 + 1im

julia> (1 + 2im)/(1 - 2im)
-0.6 + 0.8im

julia> (1 + 2im) + (1 - 2im)
2 + 0im

julia> (-3 + 2im) - (5 - 1im)
-8 + 3im

julia> (-1 + 2im)^2
-3 - 4im

julia> (-1 + 2im)^2.5
2.7296244647840084 - 6.960664459571898im

julia> (-1 + 2im)^(1 + 1im)
-0.27910381075826657 + 0.08708053414102428im

julia> 3(2 - 5im)
6 - 15im

julia> 3(2 - 5im)^2
-63 - 60im

julia> 3(2 - 5im)^-1.0
0.20689655172413796 + 0.5172413793103449im
\end{minted}



El mecanismo de promoción asegura qur las combinaciones de operandos de distintos tipos funcionarán:




\begin{minted}{jlcon}
julia> 2(1 - 1im)
2 - 2im

julia> (2 + 3im) - 1
1 + 3im

julia> (1 + 2im) + 0.5
1.5 + 2.0im

julia> (2 + 3im) - 0.5im
2.0 + 2.5im

julia> 0.75(1 + 2im)
0.75 + 1.5im

julia> (2 + 3im) / 2
1.0 + 1.5im

julia> (1 - 3im) / (2 + 2im)
-0.5 - 1.0im

julia> 2im^2
-2 + 0im

julia> 1 + 3/4im
1.0 - 0.75im
\end{minted}



Nótese que \texttt{3/4im == 3/(4*im) == -(3/4*im)}, ya que un coeficiente literal se enlaza más fuerte que la división.



También se proporcionan las funciones estándar para manipular valores complejos:




\begin{minted}{jlcon}
julia> z = 1 + 2im
1 + 2im

julia> real(1 + 2im) # real part of z
1

julia> imag(1 + 2im) # imaginary part of z
2

julia> conj(1 + 2im) # complex conjugate of z
1 - 2im

julia> abs(1 + 2im) # absolute value of z
2.23606797749979

julia> abs2(1 + 2im) # squared absolute value
5

julia> angle(1 + 2im) # phase angle in radians
1.1071487177940904
\end{minted}



Como de costumbre, el valor absoluto (\hyperlink{9614495866226399167}{\texttt{abs()}}) de un número complejo es su distancia a cero. \hyperlink{15686257922156163743}{\texttt{abs2()}} da el cuadrado del valor absoluto, y es de uso particular para los números complejos donde se evita tomar una raíz cuadrada. \hyperlink{9465547375318501186}{\texttt{angle()}} devuelve el ángulo de fase en radianes (también conocido como \emph{argumento} o función \emph{arg}). La gama completa de otras \hyperlink{17395527405393843522}{funciones elementales} está también definida para los números complejos:




\begin{minted}{jlcon}
julia> sqrt(1im)
0.7071067811865476 + 0.7071067811865475im

julia> sqrt(1 + 2im)
1.272019649514069 + 0.7861513777574233im

julia> cos(1 + 2im)
2.0327230070196656 - 3.0518977991518im

julia> exp(1 + 2im)
-1.1312043837568135 + 2.4717266720048188im

julia> sinh(1 + 2im)
-0.4890562590412937 + 1.4031192506220405im
\end{minted}



Tenga en cuenta que las funciones matemáticas normalmente devuelven valores reales cuando se aplican a números reales y valores complejos cuando se aplican a números complejos. Por ejemplo, \hyperlink{4178506499510800909}{\texttt{sqrt()}} se comporta de forma diferente cuando se aplica a \texttt{-1} que cuanso se aplica sobre \texttt{-1 + 0im}, aunque \texttt{-1 == -1 + 0im}:




\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Int64) at ./math.jl:434

julia> sqrt(-1 + 0im)
0.0 + 1.0im
\end{minted}



La \hyperlink{14058350023597195643}{notación de coeficiente numérico literal} no funciona cuando se construye un número complejo a partir de variables. En su lugar, la multiplicación debe expresarse explícitamente:




\begin{minted}{jlcon}
julia> a = 1; b = 2; a + b*im
1 + 2im
\end{minted}



Sin embargo, esto no es lo recomendable; En su lugar, utilice la función \hyperlink{16014240202095271744}{\texttt{complex()}} para construir un valor complejo directamente de sus partes real e imaginaria:




\begin{minted}{jlcon}
julia> a = 1; b = 2; complex(a, b)
1 + 2im
\end{minted}



Esta construcción evita las operaciones de multiplicación y adición.



\hyperlink{1907914141659611007}{\texttt{Inf}} y \hyperlink{11449618129446476597}{\texttt{NaN}} se propagan a través de números complejos en las partes real e imaginaria de un número complejo como se describe en la sección \hyperlink{8368313158411015136}{valores especiales en punto flotante} section:




\begin{minted}{jlcon}
julia> 1 + Inf*im
1.0 + Inf*im

julia> 1 + NaN*im
1.0 + NaN*im
\end{minted}



\hypertarget{12093481009248886258}{}


\section{Números Racionales}



Julia tiene un tipo numérico racional para representar razones exactas de enteros. Los racionales se construyen usando el operador \hyperlink{17539582191808611917}{\texttt{//}}:




\begin{minted}{jlcon}
julia> 2//3
2//3
\end{minted}



Si el numerador y el denominador de un racional tienen factores comunes, ellos son reducidos a los términos mínimos tales que el denominador sea no negativo:




\begin{minted}{jlcon}
julia> 6//9
2//3

julia> -4//8
-1//2

julia> 5//-15
-1//3

julia> -4//-12
1//3
\end{minted}



Esta forma normalizada para una razón de enteros es única, por lo que la igualdad de valores racionales puede ser testada comprobando la igualdad del numerador y el denominador. El numerador estandarizado y el denominador de un valor racional pueden ser extraídos usando las funciones \hyperlink{7885506453580572157}{\texttt{numerator()}} y \hyperlink{12407209279719593434}{\texttt{denominator()}}:




\begin{minted}{jlcon}
julia> numerator(2//3)
2

julia> denominator(2//3)
3
\end{minted}



La comparación directa de numerador y denominador no suele ser necesaria, ya que la aritmetica  estándar y las operaciones de comparación están definidas para los valores racionales:




\begin{minted}{jlcon}
julia> 2//3 == 6//9
true

julia> 2//3 == 9//27
false

julia> 3//7 < 1//2
true

julia> 3//4 > 2//3
true

julia> 2//4 + 1//6
2//3

julia> 5//12 - 1//4
1//6

julia> 5//8 * 3//12
5//32

julia> 6//5 / 10//7
21//25
\end{minted}



Los racionales pueden convertirse fácilmente en número en punto flotante:




\begin{minted}{jlcon}
julia> float(3//4)
0.75
\end{minted}



La conversión de racional a punto flotante respeta la siguiente identidad para dos valores enteros cualesquiera \texttt{a} y \texttt{b}, con las excepciones de los casos \texttt{a == 0} and \texttt{b == 0}:




\begin{minted}{jlcon}
julia> a = 1; b = 2;

julia> isequal(float(a//b), a/b)
true
\end{minted}



Construir valores racionales infinitos es aceptable:




\begin{minted}{jlcon}
julia> 5//0
1//0

julia> -3//0
-1//0

julia> typeof(ans)
Rational{Int64}
\end{minted}



Sin embargo, no lo es tratar de construir un valor NaN \hyperlink{11449618129446476597}{\texttt{NaN}} racional:




\begin{minted}{jlcon}
julia> 0//0
ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)
Stacktrace:
 [1] Rational{Int64}(::Int64, ::Int64) at ./rational.jl:13
 [2] //(::Int64, ::Int64) at ./rational.jl:40
\end{minted}



Como es natural, el sistema de promoción hace que las interacciones con otros tipos numéricos se hagan sin esfuerzo alguno:




\begin{minted}{jlcon}
julia> 3//5 + 1
8//5

julia> 3//5 - 0.5
0.09999999999999998

julia> 2//7 * (1 + 2im)
2//7 + 4//7*im

julia> 2//7 * (1.5 + 2im)
0.42857142857142855 + 0.5714285714285714im

julia> 3//2 / (1 + 2im)
3//10 - 3//5*im

julia> 1//2 + 2im
1//2 + 2//1*im

julia> 1 + 2//3im
1//1 - 2//3*im

julia> 0.5 == 1//2
true

julia> 0.33 == 1//3
false

julia> 0.33 < 1//3
true

julia> 1//3 - 0.33
0.0033333333333332993
\end{minted}



\hypertarget{3772396547767597421}{}


\chapter{Strings}



Las cadenas son secuencias finitas de caracteres. Por supuesto, el verdadero problema viene cuando uno se pregunta qué es un carácter. Los caracteres con los que están familiarizados con los hablantes de inglés son las letras \texttt{A}, \texttt{B}, \texttt{C}, etc., junto con los números y los símbolos de puntuación comunes. Estos caracteres se estandarizan junto con una correspondencia a valores enteros entre 0 y 127 a través del estándar ASCII. Hay, por supuesto, muchos otros caracteres utilizados en lenguas no  inglesas, incluyendo variantes de los caracteres ASCII con acentos y otras modificaciones, escrituras relacionadas como cirílico y griego, y escrituras no relacionadas en abosluto con ASCII o inglés, entre los que se incluyen árabe, chino, Hebreo, hindi, japonés y coreano. El estándar \href{https://en.wikipedia.org/wiki/Unicode}{Unicode} aborda las complejidades de lo que es exactamente un carácter, y es generalmente aceptado como el estándar definitivo que aborda este problema. Dependiendo de tus necesidades, puedes ignorar estas complejidades por completo y fingir que sólo existen caracteres ASCII, o puedes escribir código que pueda manejar cualquiera de los caracteres o codificaciones que se pueden encontrar al manejar texto no ASCII. Julia hace que el manejo de texto ASCII sencillo sea simple y eficiente, y el manejo de Unicode tan simple y eficiente como sea posible. En particular, puedes escribir código de cadenas con estilo C para procesar cadenas ASCII y funcionarán como se esperaba, tanto en términos de rendimiento como de semántica. Si dicho código encuentra texto no ASCII, fallará  graciosamente con un mensaje de error claro, en lugar de introducir en silencio resultados corruptos. Cuando esto sucede, modificar el código para manejar datos no ASCII es sencillo.



Hay algunas características destacadas de alto nivel sobre las cadenas de caracteres en Julia:



\begin{itemize}
\item El tipo de concreto incorporado utilizado para cadenas (y literales de cadena) en Julia es \hyperlink{2825695355940841177}{\texttt{String}}. Esto soporta el rango completo de caracteres  \href{https://en.wikipedia.org/wiki/Unicode}{Unicode} a través de  la codificación \href{https://en.wikipedia.org/wiki/UTF-8}{UTF-8}. (se proporciona una función \hyperlink{11147209877072452260}{\texttt{transcode()}}   para convertir a/desde otras codificaciones Unicode).


\item Todos los tipos de cadenas son subtipos del tipo abstracto \texttt{AbstractString} y los paquetes  externos definen subtipos \texttt{AbstractString} adicionales (por ejemplo, para otras codificaciones).  Si define una función que espera un argumento de cadena, debe declarar el tipo como  \texttt{AbstractString} para aceptar cualquier tipo de cadena.


\item Como C y Java, pero a diferencia de la mayoría de los lenguajes dinámicos, Julia tiene un tipo  de primera clase que representa un solo carácter, llamado \texttt{Char}. Esto es sólo un tipo especial  de bits de 32 bits cuyo valor numérico representa un punto de código Unicode.


\item Como en Java, las cadenas son inmutables: el valor de un objeto \texttt{AbstractString} no se puede  cambiar. Para construir un valor de cadena diferente, se construye una nueva cadena de partes  de otras cadenas.


\item Conceptualmente, una cadena es una \emph{función parcial} de índices a caracteres: para algunos  valores de índice, no se devuelve ningún valor de carácter y, en su lugar, se genera una  excepción. Esto permite una indexación eficiente en cadenas por el índice de bytes de una  representación codificada en lugar de por un índice de caracteres, que no se puede implementar  de manera eficiente y sencilla para encodificaciones de anchura variable de cadenas Unicode.

\end{itemize}


\hypertarget{11743000381881707413}{}


\section{Caracteres}



Un valor \texttt{Char} representa un solo carácter: es sólo un \emph{bitstype} de 32 bits con una representación literal especial y comportamientos aritméticos apropiados, cuyo valor numérico se interpreta como un \href{https://en.wikipedia.org/wiki/Code\_point}{punto de código Unicode}. Aquí se muestra cómo se introducen y se muestran los valores \texttt{Char}:




\begin{minted}{jlcon}
julia> 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> typeof(ans)
Char
\end{minted}



Podemos convertir un \texttt{Char} a su valor entero (su punto de código) fácilmente:




\begin{minted}{jlcon}
julia> Int('x')
120

julia> typeof(ans)
Int64
\end{minted}



En arquitecturas de 32 bits,  \hyperlink{13440452181855594120}{\texttt{typeof(ans)}} será \hyperlink{10103694114785108551}{\texttt{Int32}}. Puede convertir un valor entero de nuevo a un \texttt{Char} fácilmente:




\begin{minted}{jlcon}
julia> Char(120)
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
\end{minted}



No todos los valores enteros son puntos de código Unicode válidos, pero por una cuestión de  rendimiento, la conversión \texttt{Char()} no comprueba que cada valor de carácter sea válido. Si desea comprobar que cada valor convertido es un punto de código válido, utilice la función \hyperlink{9678448882095016755}{\texttt{isvalid()}}:




\begin{minted}{jlcon}
julia> Char(0x110000)
'\U110000': Unicode U+110000 (category Cn: Other, not assigned)

julia> isvalid(Char, 0x110000)
false
\end{minted}



A partir de este momento, los puntos de código Unicode válidos son \texttt{U+00} a \texttt{U+d7ff} y \texttt{U+e000} a \texttt{U+10ffff}. A estos no se les han asignado todavía significados inteligibles, ni son necesariamente interpretables por las aplicaciones, pero todos ellos se consideran caracteres Unicode válidos.



Puede introducir cualquier carácter Unicode entre comillas simples utilizando \texttt{{\textbackslash}u} seguido de hasta cuatro dígitos hexadecimales o \texttt{{\textbackslash}U} seguido de hasta ocho dígitos hexadecimales (el valor válido más largo sólo requiere seis):




\begin{minted}{jlcon}
julia> '\u0'
'\0': ASCII/Unicode U+0000 (category Cc: Other, control)

julia> '\u78'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> '\u2200'
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia> '\U10ffff'
'\U10ffff': Unicode U+10ffff (category Cn: Other, not assigned)
\end{minted}



Julia utiliza la configuración regional y de idioma de tu sistema para determinar qué caracteres se pueden imprimir tal cual y cuáles se deben imprimir utilizando las formas de entrada genéricas, escapadas con \texttt{{\textbackslash}u} o \texttt{{\textbackslash}U}. Además de estas formas de escape de Unicode, también se pueden usar todas las \href{https://en.wikipedia.org/wiki/C\_syntax\#Backslash\_escapes}{formas de entrada de escape tradicionales de C}:




\begin{minted}{jlcon}
julia> Int('\0')
0

julia> Int('\t')
9

julia> Int('\n')
10

julia> Int('\e')
27

julia> Int('\x7f')
127

julia> Int('\177')
127

julia> Int('\xff')
255
\end{minted}



Puedes hacer comparaciones y una cantidad limitada de aritmética con los valores \texttt{Char}:




\begin{minted}{jlcon}
julia> 'A' < 'a'
true

julia> 'A' <= 'a' <= 'Z'
false

julia> 'A' <= 'X' <= 'Z'
true

julia> 'x' - 'a'
23

julia> 'A' + 1
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)
\end{minted}



\hypertarget{5982376778832702050}{}


\section{Fundamentos de Cadenas}



Los literales de cadenas están delimitados por comillas dobles o comillas dobles triples:




\begin{lstlisting}
julia> str = "Hello, world.\n"
"Hello, world.\n"

julia> """Contains "quote" characters"""
"Contains \"quote\" characters"
\end{lstlisting}



Si desea extraer un carácter de una cadena, indéxelo:




\begin{lstlisting}
julia> str[1]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia> str[6]
',': ASCII/Unicode U+002c (category Po: Punctuation, other)

julia> str[end]
'\n': ASCII/Unicode U+000a (category Cc: Other, control)
\end{lstlisting}



Toda la indexación en Julia está basada en 1: el primer elemento de cualquier objeto indexado medidante enteros se encuentra en el índice \texttt{1}, y el último elemento se encuentra en el índice \texttt{n}, cuando la cadena tiene una longitud de \texttt{n}.



En cualquier expresión de indexación, puede usarse la palabra clave \texttt{end} como una abreviatura para el último índice (calculado mediante \hyperlink{7288835006555308491}{\texttt{endof(str)}}). Puede realizar operaciones aritméticas y otras con \texttt{end}, como si de un valor normal se tratara:




\begin{lstlisting}
julia> str[end-1]
'.': ASCII/Unicode U+002e (category Po: Punctuation, other)

julia> str[end÷2]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
\end{lstlisting}



Usar un índice menor que 1 o mayor que \texttt{end} lanza un error:




\begin{lstlisting}
julia> str[0]
ERROR: BoundsError: attempt to access "Hello, world.\n"
  at index [0]
[...]

julia> str[end+1]
ERROR: BoundsError: attempt to access "Hello, world.\n"
  at index [15]
[...]
\end{lstlisting}



También puedes extraer una subcadena usando indexación mediante un rango:




\begin{lstlisting}
julia> str[4:9]
"lo, wo"
\end{lstlisting}



Nótese que las expresiones \texttt{str[k]} y \texttt{str[k:k]} no dan el mismo resultado:




\begin{lstlisting}
julia> str[6]
',': ASCII/Unicode U+002c (category Po: Punctuation, other)

julia> str[6:6]
","
\end{lstlisting}



La primera es un valor carácter de tipo \texttt{Char}, mientras que la segunda es un valor cadena que tiene un único carácter. En Julia se trata de cosas muy diferentes.



\hypertarget{535290508865367512}{}


\section{Unicode y UTF-8}



Julia soporta totalmente caracteres y cadenas Unicode. Como se ha \hyperlink{11743000381881707413}{comentado anteriormente}, en literales de caracteres, los puntos de código Unicode se pueden representar usando las secuencias de escape Unicode \texttt{{\textbackslash}u} y \texttt{{\textbackslash}U}, así como todas las secuencias de escape C estándar. Éstos también se pueden utilizar para escribir literales de cadena:




\begin{lstlisting}
julia> s = "\u2200 x \u2203 y"
"∀ x ∃ y"
\end{lstlisting}



Si estos caracteres Unicode se muestran como escapes o se muestran como caracteres especiales depende de la configuración regional de tu terminal y su compatibilidad con Unicode. Los literales de cadena se codifican utilizando la codificación UTF-8. UTF-8 es una codificación de ancho variable, lo que significa que no todos los caracteres están codificados en el mismo número de bytes. En UTF-8, los caracteres ASCII -es decir, aquellos con puntos de código inferiores a 0x80 (128) - están codificados como lo están en ASCII, usando un solo byte, mientras que los puntos de código 0x80 y superiores se codifican utilizando múltiples bytes (hasta cuatro por carácter). Esto significa que no todos los índices de bytes en una cadena UTF-8 es necesariamente un índice válido para un carácter. Si indexas una cadena en un índice de bytes no válido, se genera un error:




\begin{lstlisting}
julia> s[1]
'∀': Unicode U+2200 (category Sm: Symbol, math)

julia> s[2]
ERROR: UnicodeError: invalid character index
[...]

julia> s[3]
ERROR: UnicodeError: invalid character index
[...]

julia> s[4]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
\end{lstlisting}



En este caso, el carácter \texttt{∀} es un carácter de tres bytes, por lo que los índices 2 y 3 no son válidos y el índice del siguiente carácter es 4; este siguiente índice válido puede ser calculado con \hyperlink{7455293228649070526}{\texttt{nextind(s,1)}}, y el siguiente índice después de éste con \texttt{nextind(s,4)} y así sucesivamente.



Debido a las codificaciones de longitud variable, el número de caracteres de una cadena (dada por \hyperlink{4781133548011803693}{\texttt{length(s)}}) no siempre lo mismo que el último índice. Si se itera a través de los índices 1 hasta \hyperlink{7288835006555308491}{\texttt{endof(s)}} y se indexa en \texttt{s}, la secuencia de caracteres devueltos cuando no se lanzan errores es la secuencia de caracteres que contiene la cadena \texttt{s}. Por tanto, tenemos la identidad de que \texttt{length(s) <= endof(s)}, ya que cada carácter en una cadena debe tener su propio índice. La siguiente es una forma ineficaz y verbosa de iterar a través de los caracteres de \texttt{s}:




\begin{lstlisting}
julia> for i = 1:endof(s)
           try
               println(s[i])
           catch
               # ignore the index error
           end
       end
∀

x

∃

y
\end{lstlisting}



Las líneas en blanco en realidad tienen espacios en ellos. Afortunadamente, el idioma anterior incómodo es innecesario para iterar a través de los caracteres de una cadena, ya que se puede utilizar la cadena como un objeto iterable, sin que se requiera el manejo de excepciones:




\begin{lstlisting}
julia> for c in s
           println(c)
       end
∀

x

∃

y
\end{lstlisting}



Julia utiliza la codificación UTF-8 de forma predeterminada y el soporte para nuevas codificaciones puede agregarse mediante paquetes. Por ejemplo, el paquete \href{https://github.com/JuliaArchive/LegacyStrings.jl}{LegacyStrings.jl} implementa los tipos \texttt{UTF16String} y \texttt{UTF32String}. Una mayor discusión sobre otras codificaciones y cómo implementar el soporte para ellas está más allá del alcance de este documento por el momento. Para más información sobre los problemas de codificación UTF-8, consulte la sección siguiente sobre \hyperlink{14271532611053373881}{literales byte array}. La función \hyperlink{11147209877072452260}{\texttt{transcode()}} se proporciona para convertir datos entre las distintas codificaciones UTF-xx, principalmente para trabajar con datos y bibliotecas externas.



\hypertarget{15471840748923719409}{}


\section{Concatenación}



Una de las operaciones de cadena más comunes y útiles es la concatenación:




\begin{lstlisting}
julia> greet = "Hello"
"Hello"

julia> whom = "world"
"world"

julia> string(greet, ", ", whom, ".\n")
"Hello, world.\n"
\end{lstlisting}



Julia también proporciona el operador \texttt{*} para concatenar cadenas:




\begin{lstlisting}
julia> greet * ", " * whom * ".\n"
"Hello, world.\n"
\end{lstlisting}



Aunque \texttt{*} puede parecer una elección sorprendente a los usuarios de lenguajes que proporcionan \texttt{+} para concatenación de cadenas, este uso de \texttt{*}tiene precedentes en matemáticas, particularmente en álgebra abstracta.



En matemáticas, \texttt{+} suele denotar una operación \emph{conmutativa}, donde el orden de los operandos no importa. Un ejemplo de esto es la suma de matrices, donde \texttt{A + B == B + A} para dos matrices cualesquiera \texttt{A} y \texttt{B} que tengan la misma forma. En contraste, \texttt{*} suele denotar una operación no conmutativa, donde el orden de los operandos \emph{importa}. Un ejemplo de esto es la multiplicación de matrices donde, en general, \texttt{A * B != B * A}. Como con la multiplicación de matrices, la concatenación es no conmutativa: \texttt{greet * whom != whom * greet}. Por tanto, \texttt{*} es una elección más natural para el operador infijo de concatenación, consistente con el uso matemático común.



Más precisamente, el conjunto de todas las cadenas \emph{S} de longitud finita junto con el operador de concatenación \texttt{*} forman un \href{https://en.wikipedia.org/wiki/Free\_monoid}{monoide libre} (S, \texttt{*}). El elemento identidad de este conjunto es la cadena vacía {\textquotedbl}{\textquotedbl}. Siempre que un monoide libre es no conmutativo, la operación suele ser representada por \texttt{{\textbackslash}cdot}, \texttt{*}, o un símbolo similar, en luga de con \texttt{+} que implica conmutatividad.



\hypertarget{12583298261221600612}{}


\section{Interpolación}



Construir cadenas mediante concatenación puede llegar a ser un poco engorroso, sin embargo. Para reducir la necesidad de estas llamadas verbosas a \hyperlink{7919678712989769360}{\texttt{string()}} o multiplicaciones repetidas, Julia permite la interpolación en literales de cadena usando \texttt{\$}, como en Perl:




\begin{lstlisting}
julia> "$greet, $whom.\n"
"Hello, world.\n"
\end{lstlisting}



Esto es más legible y conveniente, y equivalente a la concatenación de cadena anterior – el sistema rescribe este aparente literal de cadena única en una concatenación de literales de cadena con variables.



La expresión completa más corta después de \texttt{\$} se toma como la expresión cuyo valor debe ser interpolado en la cadena. Por lo tanto, puede interpolar cualquier expresión en una cadena usando paréntesis:




\begin{minted}{jlcon}
julia> "1 + 2 = $(1 + 2)"
"1 + 2 = 3"
\end{minted}



Tanto la concatenación como la interpolación de cadena llaman a \hyperlink{7919678712989769360}{\texttt{string()}} para convertir objetos al formato de cadena. La mayoría de los objetos que no son \texttt{AbstractString} se convierten en cadenas que se corresponden estrechamente con la forma en que se introducen como expresiones literales:




\begin{minted}{jlcon}
julia> v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> "v: $v"
"v: [1, 2, 3]"
\end{minted}



\hyperlink{7919678712989769360}{\texttt{string()}} es la identidad para los valores \texttt{AbstractString} y \texttt{Char} values, por lo que estos se interpolan en cadenas como ellos mismos, sin entrecomillar y sin escapar:




\begin{minted}{jlcon}
julia> c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia> "hi, $c"
"hi, x"
\end{minted}



Para incluir un literal \texttt{\$} en una cadena, lo escaparemos con un backslash:




\begin{minted}{jlcon}
julia> print("I have \$100 in my account.\n")
I have $100 in my account.
\end{minted}



\hypertarget{13286845120092268894}{}


\section{Literales cadena con triples comillas}



Cuando las cadenas se crean utilizando comillas triples (\texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}...{\textquotedbl}{\textquotedbl}{\textquotedbl}}) tienen un comportamiento especial que puede ser útil para crear bloques de texto más largos. En primer lugar, si la apertura {\textquotedbl}{\textquotedbl}{\textquotedbl} es seguida por una nueva línea, la nueva línea se quita de la cadena resultante:




\begin{minted}{julia}
"""hello"""
\end{minted}



es equivalente a




\begin{minted}{julia}
"""
hello"""
\end{minted}



pero




\begin{minted}{julia}
"""

hello"""
\end{minted}



contendrá un literal \emph{new line} al principio. Los espacios en blanco no se modifican. Pueden contener símbolos \texttt{{\textquotedbl}} sin escapar. Las cadenas de triple comilla también se dedican al nivel de la línea menos indentada. Esto es útil para definir cadenas dentro del código que está sangrado Por ejemplo:




\begin{minted}{jlcon}
julia> str = """
           Hello,
           world.
         """
"  Hello,\n  world.\n"
\end{minted}



En este caso la línea final (vacía) antes del cierre \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} establece el nivel de indentación.



Tenga en cuenta que las saltos de línea en cadenas literales, sean de una sola o triple comilla, resultan en un carácter de línea nueva (LF) \texttt{{\textbackslash}n} en la cadena, incluso si su editor usa una combinación de retorno de carro (CR) o CRLF para finalizar líneas. Para incluir un CR en una cadena, utilice un escape explícito \texttt{{\textbackslash}r}; Por ejemplo, puede introducir la cadena literal \texttt{{\textquotedbl}una línea CRLF que termina {\textbackslash}r {\textbackslash}n{\textquotedbl}}.



\hypertarget{6221518812491707138}{}


\section{Operaciones Comunes}



Podemos comparar cadenas lexicográficamente usando los operadores de comparación estandard:




\begin{minted}{jlcon}
julia> "abracadabra" < "xylophone"
true

julia> "abracadabra" == "xylophone"
false

julia> "Hello, world." != "Goodbye, world."
true

julia> "1 + 2 = 3" == "1 + 2 = $(1 + 2)"
true
\end{minted}



La función \hyperlink{10006050288379145945}{\texttt{search()}} permite buscar el índice de una carácter en una cadena:




\begin{minted}{jlcon}
julia> search("xylophone", 'x')
1

julia> search("xylophone", 'p')
5

julia> search("xylophone", 'z')
0
\end{minted}



Y se puede arrancar la búsqueda de un carácter a partir de un desplazamiento proporcionado por un tercer argumento:




\begin{minted}{jlcon}
julia> search("xylophone", 'o')
4

julia> search("xylophone", 'o', 5)
7

julia> search("xylophone", 'o', 8)
0
\end{minted}



La función \hyperlink{16229508745643032859}{\texttt{contains()}} se usa para comprobar si una subcadena está contenida en una cadena:




\begin{minted}{jlcon}
julia> contains("Hello, world.", "world")
true

julia> contains("Xylophon", "o")
true

julia> contains("Xylophon", "a")
false

julia> contains("Xylophon", 'o')
ERROR: MethodError: no method matching contains(::String, ::Char)
Closest candidates are:
  contains(!Matched::Function, ::Any, !Matched::Any) at reduce.jl:664
  contains(::AbstractString, !Matched::AbstractString) at strings/search.jl:378
\end{minted}



Este último error es debido a que {\textquotesingle}o{\textquotesingle}  es un literal carácter, y \hyperlink{16229508745643032859}{\texttt{contains()}} es una función genérica que busca subsecuencias. Para buscar un elemento en una secuencia, debemos usar la función \hyperlink{17277603976666670638}{\texttt{in()}} en lugra de la anterior.



\hyperlink{15426606278434194584}{\texttt{repeat()}} y \hyperlink{18064910688022011979}{\texttt{join()}} son otras dos funciones de cadena muy útiles:




\begin{minted}{jlcon}
julia> repeat(".:Z:.", 10)
".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."

julia> join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"
\end{minted}



Algunas otras funciones útiles son:



\begin{itemize}
\item \hyperlink{7288835006555308491}{\texttt{endof(str)}} el índice máximo (byte) que se puede utilizar para indexar en \texttt{str}.


\item \hyperlink{4781133548011803693}{\texttt{length(str)}} el número de caracteres en \texttt{str}.


\item \hyperlink{1075601569170970796}{\texttt{i = start(str)}} da el primer índice válido en el que se puede encontrar un carácter en `str (típicamente 1).


\item \hyperlink{11903630693622759236}{\texttt{c, j = next(str,i)}} devuelve el carácter siguiente en o después del índice \texttt{i} y el siguiente índice de carácter válido que sigue a éste. Con \hyperlink{1075601569170970796}{\texttt{start()}} y \hyperlink{7288835006555308491}{\texttt{endof()}}, se puede utilizar para iterar a través de los caracteres en str`.


\item \hyperlink{6392662344610705448}{\texttt{ind2chr(str,i)}} da el número de caracteres en \texttt{str} hasta e incluyendo cualquiera en el índice \texttt{i}.


\item \hyperlink{3998544168504071055}{\texttt{chr2ind(str,j)}} da el índice en el cual ocurre el carácter \texttt{j}-ésimo en \texttt{str}.

\end{itemize}


\hypertarget{16709477590855265963}{}


\section{Literales cadena no estándar}



Hay situaciones en las que se desea construir una cadena o utilizar semántica de cadenas, pero el comportamiento de la construcción de cadena estándar no es lo que se necesita. Para este tipo de situaciones, Julia proporciona \hyperlink{16709477590855265963}{literales cadena no estándar}. Un literal de cadena no estándar es como una cadena literal normal de doble comilla, pero va inmediatamente precedido de un identificador y no se comporta como un literal de cadena normal. El convenio es que los literales no estándar con prefijos en mayúsculas producen objetos cadena reales, mientras que aquellos con prefijos en minúsculas producen objetos que no cadena, como arrays de bytes o expresiones regulares compiladas. Las expresiones regulares, literales arrays de bytes y literales de números de versión, como se describe a continuación, son algunos ejemplos de literales de cadena no estándar. Otros ejemplos se dan en la sección \hyperlink{15444528597476882531}{Metaprogramación}.



\hypertarget{3647388628009050906}{}


\section{Expresiones Regulares}



Julia tiene expresiones regulares compatibles con Perl (expresiones regulares), tal y como las proporciona la biblioteca \href{http://www.pcre.org/}{PCRE}. Las expresiones regulares se relacionan con las cadenas de dos maneras: la conexión obvia es que las expresiones regulares se utilizan para encontrar patrones regulares en cadenas; La otra conexión es que las expresiones regulares se introducen ellas mismas como cadenas, que se analizan en una máquina de estado que puede utilizarse para buscar patrones en cadenas de forma eficiente. En Julia, las expresiones regulares se introducen usando literales de cadena no estándar prefijados con varios identificadores comenzando por \texttt{r}. El literal de expresión regular más básico sin ninguna opción activada sólo utiliza \texttt{r{\textquotedbl}...{\textquotedbl}}:




\begin{minted}{jlcon}
julia> r"^\s*(?:#|$)"
r"^\s*(?:#|$)"

julia> typeof(ans)
Regex
\end{minted}



Para comprobar si una \emph{regex} se corresponde con una cadena, se utiliza  \hyperlink{12183734646641519159}{\texttt{ismatch()}}:




\begin{minted}{jlcon}
julia> ismatch(r"^\s*(?:#|$)", "not a comment")
false

julia> ismatch(r"^\s*(?:#|$)", "# a comment")
true
\end{minted}



Como puede verse aquí, \hyperlink{12183734646641519159}{\texttt{ismatch()}} simplemente devuelve \texttt{true} o \texttt{false}, indicando si la \emph{regex} dada coincide o no con la cadena. Es común, sin embargo, que uno quiera saber no sólo si una cadena coincide, sino también \emph{cómo} coincide. Para capturar esta información sobre una coincidencia, se utiliza la función \hyperlink{2695862412477105800}{\texttt{match()}}:




\begin{minted}{jlcon}
julia> match(r"^\s*(?:#|$)", "not a comment")

julia> match(r"^\s*(?:#|$)", "# a comment")
RegexMatch("#")
\end{minted}



Si la expresión regular no coincide con la cadena dada, \hyperlink{2695862412477105800}{\texttt{match()}} devuelve \texttt{nothing} – un valor especial que no imprime nada en el indicador interactivo. Aparte de no imprimir, es un valor completamente normal, como podemos comprobar en el siguiente código:




\begin{minted}{julia}
m = match(r"^\s*(?:#|$)", line)
if m === nothing
    println("not a comment")
else
    println("blank or comment")
end
\end{minted}



Si la expresión regular coincide, el valor devuelto por \hyperlink{2695862412477105800}{\texttt{match()}}  es un objeto \texttt{RegexMatch}. Estos objetos registran cómo coincide la expresión, incluyendo la subcadena que coincide con el patrón y cualquier subcadena capturada, si la hay. Este ejemplo sólo captura la parte de la subcadena que coincide, pero tal vez quisiéramos capturar cualquier texto no en blanco después del carácter de comentario. Podríamos hacer lo siguiente:




\begin{minted}{jlcon}
julia> m = match(r"^\s*(?:#\s*(.*?)\s*$|$)", "# a comment ")
RegexMatch("# a comment ", 1="a comment")
\end{minted}



Al invocar a \hyperlink{2695862412477105800}{\texttt{match()}}, tenemos la opción de especificar un índice en el que iniciar la búsqueda. Por ejemplo:




\begin{minted}{jlcon}
julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",1)
RegexMatch("1")

julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",6)
RegexMatch("2")

julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",11)
RegexMatch("3")
\end{minted}



Puede extraer la siguiente información de un objeto \texttt{RegexMatch}:



\begin{itemize}
\item La totalidad de la subcadena emparejada: \texttt{m.match}


\item Las subcadenas capturadas como una matriz de cadenas: \texttt{m.captures}


\item El desplazamiento en el que comienza la coincidencia del patrón: \texttt{m.offset}


\item Los desplazamientos de las subcadenas capturadas como un vector: \texttt{m.offsets}

\end{itemize}


Para cuando una captura no coincide, en lugar de una subcadena, \texttt{m.captures} no contiene nada en esa posición, y \texttt{m.offsets} tiene un desplazamiento de cero (recuerde que los índices en Julia son \emph{1-based}, por lo que un desplazamiento de cero en una cadena es inválido). Aquí hay un par de ejemplos algo artificiales:




\begin{lstlisting}
julia> m = match(r"(a|b)(c)?(d)", "acd")
RegexMatch("acd", 1="a", 2="c", 3="d")

julia> m.match
"acd"

julia> m.captures
3-element Array{Union{SubString{String}, Void},1}:
 "a"
 "c"
 "d"

julia> m.offset
1

julia> m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia> m = match(r"(a|b)(c)?(d)", "ad")
RegexMatch("ad", 1="a", 2=nothing, 3="d")

julia> m.match
"ad"

julia> m.captures
3-element Array{Union{SubString{String}, Void},1}:
 "a"
 nothing
 "d"

julia> m.offset
1

julia> m.offsets
3-element Array{Int64,1}:
 1
 0
 2
\end{lstlisting}



Es conveniente que las capturas sean retornadas como un array para que uno pueda usar la sintaxis de desestructurante para enlazarlas a variables locales: 




\begin{lstlisting}
julia> first, second, third = m.captures; first
"a"
\end{lstlisting}



Las capturas también está accesibles indexando el objeto \texttt{RegexMatch} con el número o nombre del grupo captura:




\begin{minted}{jlcon}
julia> m=match(r"(?<hour>\d+):(?<minute>\d+)","12:45")
RegexMatch("12:45", hour="12", minute="45")

julia> m[:minute]
"45"

julia> m[2]
"45"
\end{minted}



Las capturas pueden referenciarse en una cadena de sustitución cuando se utiliza \hyperlink{1718748356383062256}{\texttt{replace()}} utilizando \texttt{{\textbackslash}n} para referirse al grupo de captura \texttt{n}-ésimo y prefijando la cadena de subsitución con \texttt{s}. El grupo de captura \texttt{0} se refiere a todo el objeto de coincidencia. Los grupos de captura nombrados se pueden hacer referencia en la sustitución con g<groupname>. Por ejemplo:




\begin{minted}{jlcon}
julia> replace("first second", r"(\w+) (?<agroup>\w+)", s"\g<agroup> \1")
"second first"
\end{minted}



Los grupos de captura numerados pueden también ser referenciados como \texttt{{\textbackslash}g<n>} para evitar ambigüedad, como en:




\begin{minted}{jlcon}
julia> replace("a", r".", s"\g<0>1")
"a1"
\end{minted}



Puedes modificar el comportamiento de las expresiones regulares mediante una combinación de los flags \texttt{i}, \texttt{m}, \texttt{s} y \texttt{x} después de la marca de comillas dobles de cierre. Estas banderas tienen el mismo significado que en Perl, tal y como se describe en este fragmento de la [página de manual del referencia de Perl(http://perldoc.perl.org/perlre.html\#Modifiers):




\begin{lstlisting}
i   Do case-insensitive pattern matching.

    If locale matching rules are in effect, the case map is taken
    from the current locale for code points less than 255, and
    from Unicode rules for larger code points. However, matches
    that would cross the Unicode rules/non-Unicode rules boundary
    (ords 255/256) will not succeed.

m   Treat string as multiple lines.  That is, change "^" and "$"
    from matching the start or end of the string to matching the
    start or end of any line anywhere within the string.

s   Treat string as single line.  That is, change "." to match any
    character whatsoever, even a newline, which normally it would
    not match.

    Used together, as r""ms, they let the "." match any character
    whatsoever, while still allowing "^" and "$" to match,
    respectively, just after and just before newlines within the
    string.

x   Tells the regular expression parser to ignore most whitespace
    that is neither backslashed nor within a character class. You
    can use this to break up your regular expression into
    (slightly) more readable parts. The '#' character is also
    treated as a metacharacter introducing a comment, just as in
    ordinary code.
\end{lstlisting}



Por ejemplo, la siguiente regex tiene activados los tres \emph{flags}:




\begin{minted}{jlcon}
julia> r"a+.*b+.*?d$"ism
r"a+.*b+.*?d$"ims

julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
\end{minted}



Las cadenas \emph{regex} con triples comillas, de la forma \texttt{r{\textquotedbl}{\textquotedbl}{\textquotedbl}...{\textquotedbl}{\textquotedbl}{\textquotedbl}} están también soportadas (y puede ser conveniente para expresiones regulares que contengan comillas o caracteres de salto de línea).



\hypertarget{14271532611053373881}{}


\section{Byte Array Literals}



Otro literal de cadena no estándar útil es el literal de cadena de bytes: \texttt{b {\textquotedbl}...{\textquotedbl}}. Esta forma nos permite usar la notación de cadena para expresar arrays de bytes literales, es decir, arrays de valores \hyperlink{6609065134969660118}{\texttt{UInt8}}. Las reglas para los literales de arrays de bytes son las siguientes:



\begin{itemize}
\item Los caracteres ASCII y los escapes ASCII producen un solo byte.


\item \texttt{{\textbackslash}x} y las secuencias de escape octales producen el \emph{byte} correspondiente al valor de escape.


\item Las secuencias de escape Unicode producen una secuencia de bytes que codifican ese punto de código en UTF-8.

\end{itemize}


Hay una cierta superposición entre estas reglas ya que el comportamiento de \texttt{{\textbackslash}x} y escapes octales menores de \texttt{0x80} (128) están cubiertos por las dos primeras reglas, pero aquí estas reglas están de acuerdo. Juntas, estas reglas permiten usar fácilmente caracteres ASCII, valores arbitrarios de bytes y secuencias UTF-8 para producir matrices de bytes. Aquí hay un ejemplo usando los tres:




\begin{minted}{jlcon}
julia> b"DATA\xff\u2200"
8-element Array{UInt8,1}:
 0x44
 0x41
 0x54
 0x41
 0xff
 0xe2
 0x88
 0x80
\end{minted}



La secuencia ASCII {\textquotedbl}DATA{\textquotedbl} corresponde a los bytes 68, 65, 84, 65. \texttt{{\textbackslash}xff} produce el byte simple 255. El escape Unicode \texttt{{\textbackslash}u2200} está codificado en UTF-8 como los tres bytes 226, 136, 128. Nótese que la matriz de bytes resultante no corresponde a una cadena UTF-8 válida - si intenta utilizar esto como una cadena literal normal, obtendrá un error de sintaxis:




\begin{minted}{jlcon}
julia> "DATA\xff\u2200"
ERROR: syntax: invalid UTF-8 sequence
\end{minted}



Observe también la distinción significativa entre \texttt{{\textbackslash}xff} y \texttt{{\textbackslash}uff}: la secuencia de escape anterior codifica el \emph{byte 255}, mientras que la última secuencia de escape representa el \emph{punto de código 255}, que se codifica como dos bytes en UTF-8:




\begin{minted}{jlcon}
julia> b"\xff"
1-element Array{UInt8,1}:
 0xff

julia> b"\uff"
2-element Array{UInt8,1}:
 0xc3
 0xbf
\end{minted}



En los literales de caracteres, esta distinción se pasa por alto y \texttt{{\textbackslash}xff} está autorizado a  representar el punto de código 255, porque los caracteres \emph{siempre} representan puntos de código. En las cadenas, sin embargo, los escapes \texttt{{\textbackslash}x} siempre representan bytes, no puntos de código, mientras que los escapes \texttt{{\textbackslash}u} y \texttt{{\textbackslash}U} siempre representan puntos de código, que están codificados en uno o más bytes. Para los puntos de código inferiores a \texttt{{\textbackslash}u80}, ocurre que la codificación UTF-8 de cada punto de código es sólo el byte producido por el escape \texttt{{\textbackslash}x} correspondiente, por lo que la distinción puede ignorarse con seguridad. Sin embargo, para los escapes \texttt{{\textbackslash}x80} a \texttt{{\textbackslash}xff} en comparación con \texttt{{\textbackslash}u80} a \texttt{{\textbackslash}uff}, existe una diferencia importante: el primero escapa a todos los bytes sencillos de codificación, los cuales -a menos que sean seguidos por bytes de continuación muy específicos- no forman UTF-8 válido, mientras que los últimos escapes representan puntos de código Unicode con codificaciones de dos bytes.



Si todo esto es muy confuso, intente leer \href{https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/}{{\textquotedbl}The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets{\textquotedbl}}. Es una excelente introducción a Unicode y UTF-8, y puede ayudar a aliviar cierta confusión sobre el asunto.



\hypertarget{10038787961375920908}{}


\section{Literales Número de Versión}



Los números de versión se pueden expresar fácilmente con literales de cadena no estándar del forma \texttt{v{\textquotedbl}...{\textquotedbl}}. Los literales de número de versión crean objetos \texttt{VersionNumber} que siguen las especificaciones del \href{http://semver.org/}{control de versiones semánticas} y, por lo tanto, se componen de valores numéricos mayor, menor y de parche, seguidos de anotaciones alfanuméricas de pre-liberación y construcción. Por ejemplo, \texttt{v {\textquotedbl}0.2.1-rc1 + win64{\textquotedbl}} se divide en versión principal \texttt{0}, versión secundaria \texttt{2}, versión de revisión \texttt{1}, \texttt{rc1} de pre-lanzamiento y construcción \texttt{win64}. Al introducir una versión literal, todo excepto el número de versión principal es opcional, por ejemplo, \texttt{v{\textquotedbl}0.2{\textquotedbl}} es equivalente a \texttt{v{\textquotedbl}0.2.0{\textquotedbl}} (con anotaciones previas / de compilación vacías), \texttt{v{\textquotedbl}2{\textquotedbl}} equivale a \texttt{v{\textquotedbl}2.0.0{\textquotedbl}}, y así sucesivamente.



Los objetos \texttt{VersionNumber} son en su mayoría útiles para comparar fácilmente y correctamente dos (o más) versiones. Por ejemplo, la constante \texttt{VERSION} contiene el número de versión de Julia como un objeto \texttt{VersionNumber} y, por lo tanto, se puede definir algún comportamiento específico de la versión utilizando declaraciones simples como:




\begin{minted}{julia}
if v"0.2" <= VERSION < v"0.3-"
    # do something specific to 0.2 release series
end
\end{minted}



Obsérvese que en el ejemplo anterior se utiliza el número de versión no estándar \texttt{v{\textquotedbl}0.3-{\textquotedbl}}, con un guión \texttt{-} en cola: esta notación es una extensión Julia del estándar, y se usa para indicar una versión que es más baja que cualquier versión \texttt{0.3}, Incluyendo todas sus pre-lanzamientos. Por lo tanto, en el ejemplo anterior, el código sólo se ejecuta con versiones estable \texttt{0.2} y excluye las versiones \texttt{v{\textquotedbl}0.3.0-rc1{\textquotedbl}}. Para permitir también versiones \texttt{0.2} inestables (es decir, pre-liberación), la verificación del límite inferior debería modificarse de la siguiente manera: \texttt{v{\textquotedbl}0.2-{\textquotedbl} <= VERSION}.



Otra extensión de especificación de versión no estándar permite usar un \texttt{+} de cola para expresar un límite superior en las versiones de compilación, por ej. \texttt{VERSIÓN> v {\textquotedbl}0.2-rc1 +{\textquotedbl}} se puede utilizar para significar cualquier versión por encima de \texttt{0.2-rc1} y cualquiera de sus compilaciones: devolverá \texttt{false} para la versión \texttt{v{\textquotedbl}0.2-rc1+win64{\textquotedbl}} y \texttt{true} para \texttt{v{\textquotedbl}0.2-rc2{\textquotedbl}}.



Es una buena práctica utilizar estas versiones especiales en comparaciones (en particular, el valor \texttt{-}de cola siempre debe utilizarse en los límites superiores a menos que haya una buena razón para no hacerlo), pero no deben utilizarse como el número de versión real de nada, ya que son inválidos en el esquema de versiones semánticas.



Además de ser utilizados por la constante \hyperlink{12605722316331458198}{\texttt{VERSION}}, los objetos \texttt{VersionNumber} son ampliamente utilizados en el módulo \texttt{Pkg}, para especificar las versiones de paquetes y sus dependencias.



\hypertarget{5096496368362976040}{}


\section{Raw String Literals}



Las cadenas en bruto (\emph{raw}) sin interpolación o \emph{unescaping} pueden ser expresadas con literales cadena no estándar de la forma \texttt{raw{\textquotedbl}...{\textquotedbl}}. Los literales cadena en bruto crean objetos \texttt{String} ordinarios que contienen los contenidos encerrados exactamente como entrados sin interpolación ni separación. Esto es útil para cadenas que contiene código o marcado en otros idiomas que usan \texttt{\$} o \texttt{{\textbackslash}} como caracteres especiales. La excepción son las comillas que aún deben ser escapadas, por ejemplo,  \texttt{raw{\textquotedbl} {\textbackslash} {\textquotedbl}{\textquotedbl}}es equivalente a\texttt{{\textquotedbl}{\textbackslash}{\textquotedbl} {\textquotedbl}}.



\hypertarget{11836327794581856778}{}


\chapter{Funciones}



En Julia, una función es un objeto que hace corresponde una tupla de valores argumentos en un valor de retorno. Las funciones de Julia no son funciones matemáticas puras, en el sentido  de que pueden alterar y ser afectadas por el estado global del programa. La sintaxis básica  a definir funciones en Julia es:




\begin{minted}{jlcon}
julia> function f(x,y)
           x + y
       end
f (generic function with 1 method)
\end{minted}



Hay una segunda sintaxis, más concisa, para definir una función en Julia. La declaración de  función tradicional mostrada anteriormente es equivalente a la denominada {\textquotedbl}forma de asignación{\textquotedbl}.  Por ejemplo:




\begin{lstlisting}
julia> f(x,y) = x + y
f (generic function with 1 method)
\end{lstlisting}



En esta segunda forma, el cuerpo de la función debe ser una sola expresión, aunque puede  tratarse de una expresión compuesta (see \hyperlink{16096814372489430927}{Expresiones Compuestas}).  Estas definiciones de función cortas y simples son comunes en Julia. La sintaxis de funciones cortas es, por tanto, bastante idiomática, reduciendo considerablemente tanto la escritura como  el ruido visual.



Para invocar una función se usa la sintaxis tradicional basada en el uso del paréntesis:




\begin{lstlisting}
julia> f(2,3)
5
\end{lstlisting}



Sin usar paréntesis, la expresión \texttt{f} se refiere al objeto función, y puede ser tratada como cualquier otro valor:




\begin{lstlisting}
julia> g = f;

julia> g(2,3)
5
\end{lstlisting}



Y, como en el caso de las variables, podemos usar Unicode en el caso de los nombres de función:




\begin{minted}{jlcon}
julia> ∑(x,y) = x + y
∑ (generic function with 1 method)

julia> ∑(2, 3)
5
\end{minted}



\hypertarget{2861776483115755666}{}


\section{Comportamiento del Paso de Argumentos}



Los argumentos de función en Julia siguen un convenio denominado a veces {\textquotedbl}paso por compartición{\textquotedbl},  que significa que los valores no son copiados cuando se pasan a las funciones. Los argumentos de  las funciones actúan ellos mismos como nuevos enlaces a variable (nuevas localizaciones que pueden  referirse a valores) pero los valores a los que se refieren son idénticos a los valores pasados.  Las modificaciones a valores mutables (tales como los Arrays) hechos dentro de la función serán  visibles desde fuera de ésta. Este es el mismo comportamiento que presenta Scheme, la mayoría de  versiones de Lisp, Python, Ruby y Perl, entre otros lenguajes dinámicos.



\hypertarget{3662186082861906882}{}


\section{La palabra clave \texttt{return}}



El valor devuelto por una función es el valor de la última expresión evaluada, el cual, por  defecto, es la última expresión en el cuerpo de definición de la función. En la función \texttt{f},  mostrada en la sección anterior, el valor devuelto sería la suma \texttt{x + y}. Como en C y la mayoría  de los demás lenguajes imperativos o funcionales, la palabra clave \texttt{return} causa que la función  retorne inmediatamente, proporcionando una función cuyo valor es devuelto:




\begin{minted}{julia}
function g(x,y)
    return x * y
    x + y
end
\end{minted}



Como las definiciones a función pueden ser introducidas en una sesión interactiva, es muy sencillo comparar estas definiciones:




\begin{minted}{jlcon}
julia> f(x,y) = x + y
f (generic function with 1 method)

julia> function g(x,y)
           return x * y
           x + y
       end
g (generic function with 1 method)

julia> f(2,3)
5

julia> g(2,3)
6
\end{minted}



Por supuesto, en una función con cuerpo puramente lineal como \texttt{g}, el uso de \texttt{return} es irrelevante ya que la expresión \texttt{x+y} nunca va a ser evaluada, por lo que podríamos hacer que \texttt{x*y} fuese la última línea de la función y omitir el \texttt{return}. Sin embargo, cuando hacemos uso de esta instrucción junto con otras de control de flujo, el resultado puede ser muy interesante. Aquí, por ejemplo, hay una función que calcula la longitud de la hipotenusa de un triángulo equilátero correcto con catetos de longitudes \texttt{x} e \texttt{y}, evitando un desbordamiento:




\begin{minted}{jlcon}
julia> function hypot(x,y)
           x = abs(x)
           y = abs(y)
           if x > y
               r = y/x
               return x*sqrt(1+r*r)
           end
           if y == 0
               return zero(x)
           end
           r = x/y
           return y*sqrt(1+r*r)
       end
hypot (generic function with 1 method)

julia> hypot(3, 4)
5.0
\end{minted}



Hay tres posibles puntos de retorno en esta función, devolviendo los valores de tres expresiones diferentes, dependiendo de los valores de \texttt{x} e \texttt{y}. El \texttt{return} de la última línea podría ser omitido ya que es la última expresión.



\hypertarget{2796907390397954205}{}


\section{Operators Are Functions}



En Julia, la mayoría de los operadores son funciones con soporte para una sintaxis especial (la excepción a esta regla son las operaciones con una semática de evaluación especial, tales como \texttt{\&\&} y \texttt{||}. Estos operadores no pueden ser funciones porque la \hyperlink{10787134294480612893}{Evaluación en Cortocircuito} requiere que sus operandos no sean evaluados antes de la evaluación del operador). De acuerdo con ésto, podemos usar listas de argumentos entre paréntesis, tal como en cualquier otra función:




\begin{minted}{jlcon}
julia> 1 + 2 + 3
6

julia> +(1,2,3)
6
\end{minted}



La forma infija es equivalente a la forma de aplicación función. De hecho, la primera es transformada para producir la llamada a función internamente. Esto también significa que puedes asignar y pasar operadores tales como \hyperlink{3677358729494553841}{\texttt{+()}} y \hyperlink{8486205126068439173}{\texttt{*()}} , tal y como se hace con otros valores función:




\begin{minted}{jlcon}
julia> f = +;

julia> f(1,2,3)
6
\end{minted}



Sin embargo, cuando se usa el formato de función, como \texttt{f}, no se puede usar notación infija.



\hypertarget{10773481194654204656}{}


\section{Operadores con Nombres Especiales}



Hay unas pocas operaciones especiales que corresponden a llamadas a funciones con nombres no obvios. Estas son las siguientes:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Expresión        & Llamada               \\
\hline
\texttt{[A B C ...]} & \hyperlink{8862791894748483563}{\texttt{hcat()}} \\
\hline
\texttt{[A; B; C; ...]} & \hyperlink{14691815416955507876}{\texttt{vcat()}} \\
\hline
\texttt{[A B; C D; ...]} & \hyperlink{16279083053557795116}{\texttt{hvcat()}} \\
\hline
\texttt{A{\textquotesingle}} & \hyperlink{5848887074375173050}{\texttt{ctranspose()}} \\
\hline
\texttt{A.{\textquotesingle}} & \hyperlink{12700837529519091997}{\texttt{transpose()}} \\
\hline
\texttt{1:n} & \hyperlink{8118178594303305099}{\texttt{colon()}} \\
\hline
\texttt{A[i]} & \hyperlink{2839226020402435013}{\texttt{getindex()}} \\
\hline
\texttt{A[i]=x} & \hyperlink{17903591429492118749}{\texttt{setindex!()}} \\
\hline
\end{tabulary}

\end{table}



Estasa funciones están incluidas en el módulo \texttt{Base.Operators} incluso aunque no tengan nombres como operadores.



\hypertarget{8300730259363458305}{}


\section{Funciones Anónimas}



Las funciones en Julia son \href{https://en.wikipedia.org/wiki/First-class\_citizen}{objetos de primera clase}: ellas pueden ser asignadas a variables y ser invocadas usando la sintaxis estándar de llamadas a función desde la variable a la que han sido asignadas. Ellas pueden ser usadas como argumentos y ser devueltas como valores. Ellas pueden también ser usadas de forma anónima sin dárseles un nombre, usando alguna de estas sintaxis:




\begin{minted}{jlcon}
julia> x -> x^2 + 2x - 1
(::#1) (generic function with 1 method)

julia> function (x)
           x^2 + 2x - 1
       end
(::#3) (generic function with 1 method)
\end{minted}



Esto crea una función que toma un argumento \texttt{x} y devuelve el valor del polinomio \texttt{x{\textasciicircum}2 + 2x - 1}. Nótese que el resultado es una función genérica, pero con un nombre generado por el compilador basado en una numeración consecutiva.



El uso primario de las funciones anónimas es pasarlas a funciones que toman otras funciones como argumentos. Un ejemplo clásico es \hyperlink{11483231213869150535}{\texttt{map()}}, , que aplica una función a cada valor de un array y devuelve un nuevo array que contienen los valores resultantes:




\begin{minted}{jlcon}
julia> map(round, [1.2,3.5,1.7])
3-element Array{Float64,1}:
 1.0
 4.0
 2.0
\end{minted}



Esto está bien si ya exite una función que efectúa la transformación que uno desea para pasarla como primer argumento de \hyperlink{11483231213869150535}{\texttt{map()}}. Sin embargo, no es frecuente que exista este tipo de función. En estas situaciones, el constructor de la función anónima permite una fácil creación de un objeto función de un solo uso sin necesidad de asignarle un nombre:




\begin{minted}{jlcon}
julia> map(x -> x^2 + 2x - 1, [1,3,-1])
3-element Array{Int64,1}:
  2
 14
 -2
\end{minted}



Para escribir funciones anónimas que aceptan múltiples argumentos puede utilizarse la sintaxis \texttt{(x,y,z) -> 2x + y +z}. Una función anónima con cero argumentos se escribe como \texttt{() -> 3}.  La idea de una función sin argumentos puede parecer extraña, pero es útil para demorar un cálculo. En este uso, un bloque de código es envuelto en una función con cero argumentos, el cual es después invocado mediante una llamada como \texttt{f()}.



\hypertarget{12204150517109964952}{}


\section{Retorno de Múltiples Valores}



En Julia, uno devuelve una tupla para simular el retorno de múltiples valores. Sin embargo, como las tuplas puede salteadas y destruidas sin necesitar paréntesis, podemos proporcionar una ilusión de que se están devolviendo múltiples valores. Por ejemplo, la siguiente función devuelve un par de valores:




\begin{lstlisting}
julia> function foo(a,b)
           a+b, a*b
       end
foo (generic function with 1 method)
\end{lstlisting}



Si invocamos esta función en una sesión interactiva sin asignar los valores en ningún sitio, comprobaremos que la función devuelve una tupla:




\begin{lstlisting}
julia> foo(2,3)
(5, 6)
\end{lstlisting}



Un uso típico de tal par de valores devueltos es extraer cada valor en una variable. Julia soporta la {\textquotedbl}desestructuración{\textquotedbl} simple de una tupla que facilita esto:




\begin{lstlisting}
julia> x, y = foo(2,3)
(5, 6)

julia> x
5

julia> y
6
\end{lstlisting}



Y también podemos devolver múltiples valores mediante el uso explícito de la palabra clave \texttt{return}:




\begin{minted}{julia}
function foo(a,b)
    return a+b, a*b
end
\end{minted}



Esto tiene exactamente el mismo efecto que la definición anterior de \texttt{foo}.



\hypertarget{4426560717438156432}{}


\section{Funciones con argumentos variables (varargs)}



Suele ser muy conveniente ser capaz de escribir funciones que toman un número arbitrario de argumentos. Estas funciones se conocen como \emph{funciones vararg}. Podemos definir funciones de tal tipo poniendo puntos suspensivos \texttt{…} después del último argumento.




\begin{lstlisting}
julia> bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)
\end{lstlisting}



Las variables \texttt{a} y \texttt{b} están asociadas a los dos primeros argumentos como es natural, y la variable \texttt{x} se asocia a una colección, iterable de cero o más valores pasados a la función \texttt{bar} después de estos dos argumentos:




\begin{lstlisting}
julia> bar(1,2)
(1, 2, ())

julia> bar(1,2,3)
(1, 2, (3,))

julia> bar(1, 2, 3, 4)
(1, 2, (3, 4))

julia> bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))
\end{lstlisting}



En todos los casos, \texttt{x} es asociada a una tupla con el resto de valores pasados a la función.



Es posible restringir el número de argumentos pasados como argumento variable. Esto se discutirá más adelante en la sección \hyperlink{9272584532067475752}{métodos \emph{vararg} restringidos paramétricamente}.



Como contraposición, es frecuente manejar la división de los valores contenidos en una colección iterable en una llamada a función como argumentos individuales. Para hacer eso, se utilizará la notación de puntos suspensivos, pero esta vez en la llamada a función.




\begin{lstlisting}
julia> x = (3, 4)
(3, 4)

julia> bar(1,2,x...)
(1, 2, (3, 4))
\end{lstlisting}



En este caso hay una tupla que se divide en una llamada \emph{vararg} precisamente donde está el número de argumentos variable. Esa necesidad no tiene por qué ser el caso:




\begin{lstlisting}
julia> x = (2, 3, 4)
(2, 3, 4)

julia> bar(1,x...)
(1, 2, (3, 4))

julia> x = (1, 2, 3, 4)
(1, 2, 3, 4)

julia> bar(x...)
(1, 2, (3, 4))
\end{lstlisting}



Además, el objeto iterable dividido durante la llamada a función no tiene que ser una tupla:




\begin{lstlisting}
julia> x = [3,4]
2-element Array{Int64,1}:
 3
 4

julia> bar(1,2,x...)
(1, 2, (3, 4))

julia> x = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> bar(x...)
(1, 2, (3, 4))
\end{lstlisting}



También, la función cuyos argumentos son divididos no tiene por qué ser una función \emph{vararg} (aunque frecuentemente lo sea):




\begin{minted}{jlcon}
julia> baz(a,b) = a + b;

julia> args = [1,2]
2-element Array{Int64,1}:
 1
 2

julia> baz(args...)
3

julia> args = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
  baz(::Any, ::Any) at none:1
\end{minted}



Como puede comprobarse, si el número de elementos que se van a sacar del contenedor es inapropiado  para pasar a la función como argumentos, se generará un error, igual que si hubiéramos realizado la llamada a función con un número de argumentos inapropiado.



\hypertarget{11767106871763647644}{}


\section{Argumentos Opcionales}



En muchos casos, los argumentos de función tienen valores por defecto sensibles y, por tanto, puede no ser necesario que se pasen explícitamente en cada llamada. Por ejemplo, la función de librería \hyperlink{13108503824143481717}{\texttt{parse(T, num, base)}} interpreta una cadena como un número en cierta base. El argumento \texttt{base} tiene un valor por defecto de \texttt{10}. Este comportamiento puede expresarse de forma concisa como:




\begin{minted}{julia}
function parse(T, num, base=10)
    ###
end
\end{minted}



Con esta definición, la función puede ser llamada con dos o tres argumentos y, cuando no se pase el tercer argumento, la función asignara el valor por defecto de \texttt{10} al parámetro \texttt{base}.




\begin{minted}{jlcon}
julia> parse(Int,"12",10)
12

julia> parse(Int,"12",3)
5

julia> parse(Int,"12")
12
\end{minted}



Los argumentos opcionales son una sintaxis conveniente para escribir múltiples definiciones de métodos con diferentes números de argumentos (ver \hyperlink{3406543699482093781}{Nota sobre Argumentos opcionales y \emph{keyword}}).



\hypertarget{8972402874579430531}{}


\section{Argumentos \emph{keyword}}



Algunas funciones necesitan un número de argumentos grande o tienen un gran número de comportamientos. Recordar como llamar a tales funciones puede ser difícil. Los argumentos \emph{keyword} pueden hacer que estas interfaces complejas sean más fáciles de usar y extender permitiendo que los argumentos sean identificados por su nombre en lugar del por su posición.



Por ejemplo, considere una función \texttt{plot} que traza una línea. Esta función puede tener muchas opciones para controlar el estilo de línea, su ancho, su color, etc. Si la función  aceptara argumentos \emph{keyword}, una posible llamada al método seria \texttt{plot(x,y, width=2)}, donde hemos elegido especificar sólo el ancho de línea. Nótese que esto sirve a dos propósitos: La llamada es más sencillo leer, ya que podemos etiquetar un argumento con su significado. También se vuelve posible pasar cualquier subconjunto de un gran número de argumentos, en cualquier orden.



Las funciones con argumentos \emph{keyword} se definen usando un punto y coma en la signatura:




\begin{minted}{julia}
function plot(x, y; style="solid", width=1, color="black")
    ###
end
\end{minted}



Cuando la función es invocada, el punto y coma es opcional: uno puede hacer la llamada como \texttt{plot(x, y, width=2)}o como \texttt{plot(x, y; width=2)}, aunque el primero es más común. Se requiere un punto y coma explícito sólo en el caso de pasar \emph{vargars} o palabras clave calculadas como se describe abajo.



Los valores por defecto de los argumentos \emph{keyword} son evaluados sólo cuando sea necesario (cuando no se pasa el correspondiente argumento \emph{keyword}) y en orden izquierda a derecha. Por tanto, las expresiones por defecto pueden referirse a argumentos \emph{keyword} previos.



Los tipos de argumentos \emph{keyword}  pueden hacerse explícitos de la siguiente forma:




\begin{minted}{julia}
function f(;x::Int64=1)
    ###
end
\end{minted}



Los argumentos \emph{keyword} extra pueden ser recolectados usando \texttt{...} como en las funciones \emph{vararg}:




\begin{minted}{julia}
function f(x; y=0, kwargs...)
    ###
end
\end{minted}



Dentro de \texttt{f}, \texttt{kwargs} será una colección de tuplas \texttt{(clave,valor)}, donde cada \texttt{clave} es un símbolo. Tales colecciones pueden ser pasadas como argumentos \emph{keyword} usando un punto y coma en la llamada. Por ejemplo: \texttt{f(x, z=1; kwargs...)}. Los diccionarios pueden ser también usados para este propósito.



Uno puede también pasar tuplas \texttt{(clave, valor)} o cualquier expresión iterable (tal como un par \texttt{=>}) que puede ser asignado a una tupla, explícitamente después de un punto y coma. Por ejemplo, \texttt{plot(x, y; (:width,2))} y \texttt{plot(x, y; :width => 2)} son equivalentes a \texttt{plot(x, y, width=2)}. Esto es útil en situaciones donde el nombre de la palabra clave se calcula en tiempo de ejecución.



La naturaleza de los argumentos \emph{keyword}  le hace posible especificar el mismo argumento más de una vez. Por ejemplo, en la llamada \texttt{plot(x, y; options..., width=2)} es posible que la estructura \texttt{options} contenga también un valor para \texttt{width}. En tal caso la ocurrencia más a la derecha toma precedencia; en este ejemplo \texttt{width} tendrá el valor \texttt{2}.



\hypertarget{2989014846910448675}{}


\section{Ámbito de evaluación de Valores por defecto}



Los argumentos opcionales y \emph{keyword} difieren ligeramente en cómo sus valores son evaluados. Cuando se evalúan expresiones por defecto con valores opcionales, sólo están en el ámbito lo valores \emph{previos}. En contraste, cuando se evalúan las expresiones por defecto con argumentos \emph{keyword}, \emph{todos} los argumentos están en el ámbito. Por ejemplo, dada esta definición:




\begin{minted}{julia}
function f(x, a=b, b=1)
    ###
end
\end{minted}



la \texttt{b} en \texttt{a=b} se refiere a la \texttt{b} de un ámbito más externo, no el siguiente argumento \texttt{b}. Sin embargo, si \texttt{a} y \texttt{b} fueran argumentos \emph{keyword} en lugar de opcionales, el \texttt{b} en \texttt{a=b} se referiría al argumento posterior \texttt{b} (ocultando a cualqiuer \texttt{b} de un ámbito ms externo), lo que resultaría en un error de variable indefinida (ya que las expresiones por defecto son evaluadas de izquierda a derecha, y \texttt{b} no ha sido aún asignada).



\hypertarget{15304083161014288328}{}


\section{Sintaxis Bloque Do para Argumentos Function}



Pasar funciones como argumentos a otras funciones es una técnica muy potente, pero su sintaxis no es siempre conveniente. Estas llamadas son especialmente incómodas de escribir cuando la función argumento necesita varias líneas. Por ejemplo, consideremos llamar a  \hyperlink{11483231213869150535}{\texttt{map()}} sobre una función con varios casos:




\begin{minted}{julia}
map(x->begin
           if x < 0 && iseven(x)
               return 0
           elseif x == 0
               return 1
           else
               return x
           end
       end,
    [A, B, C])
\end{minted}



Julia proporciona la palabra reservada \texttt{do} para reescribir este código de forma más clara:




\begin{minted}{julia}
map([A, B, C]) do x
    if x < 0 && iseven(x)
        return 0
    elseif x == 0
        return 1
    else
        return x
    end
end
\end{minted}



La sintaxis \texttt{do x} crea una función anónima con argumento \texttt{x} y la pasa como primer argumento a \hyperlink{11483231213869150535}{\texttt{map()}}. Similarmente, \texttt{do a,b} crearía una función anónima de dos argumentos, y un \texttt{do} solo sería una función anónima de la forma \texttt{() -> ...}.



Cómo se inicializan estos argumentos depende de la función más externa; aquí \texttt{map()} fijará secuencialmente \texttt{x} a \texttt{A,B,C} llamando a la función anónima sobre cada uno de ellos, tal y como pasa en la sintaxis \texttt{map(func, [A,B,C])}.



Esta sintaxis hace más fácil usar funciones para extender el lenguaje de forma efectiva, ya que las llamadas tiene el aspecto de códigos de bloque normales. Hay muchos usos posibles diferentes al de \hyperlink{11483231213869150535}{\texttt{map()}}, tal como la gestión del estado del sistema. Por ejemplo, hay una versión de  \hyperlink{300818094931158296}{\texttt{open()}} que ejecuta código asegurando que el fichero abierto es cerrado eventualmente:




\begin{minted}{julia}
open("outfile", "w") do io
    write(io, data)
end
\end{minted}



Esto se consigue mediante la siguiente definición:




\begin{minted}{julia}
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
\end{minted}



Aquí, \hyperlink{300818094931158296}{\texttt{open()}} primero abre el fichero para escritura y luego pasa el flujo de salida resultante a la función anónima que se define en el bloque \texttt{do...end}.  Después de que la función exista, \hyperlink{300818094931158296}{\texttt{open()}} asegurará que el flujo ha sido cerrado apropiadamente, sin preocuparse de si la función salió normalmente o lanzó una excepción (la construcción  \texttt{try/finally} será descrita en \hyperlink{8710711813610225279}{Control de Flujo}.)



Con la sintaxis de bloque \texttt{do} se ayuda a chequear la documentación o implementaciones para saber cómo se inicializan los argumentos de la función de usuario.



\hypertarget{13590013989415065742}{}


\section{Sintaxis Punto para funciones Vectorizadas}



En los lenguajes de computación técnicos es común tener versiones {\textquotedbl}vectorizadas{\textquotedbl} de funciones, las cuales aplican una función dada \texttt{f(x)} a cada elemento de un array \texttt{A} para producir un nuevo array vía \texttt{f(A)}. Esta clase de sintaxis es conveniente para procesamiento de datos, pero en otros lenguajes la vectorización es también requerida en aras de mejorar el rendimiento:  si los bucles son lentos, la versión {\textquotedbl}vectorizada{\textquotedbl} de una función podría llamar al código de librería rápido en un lenguaje de bajo nivel. En Julia, las funciones actualizadas \emph{no son requeridas por motivos de vencimiento}; de hecho, suele ser beneficioso que el usuario escriba sus propios bucles (ver \hyperlink{3908315974291496321}{Consejos de rendimiento}), a veces incluso conveniente. Por tanto \emph{cualquier} función Julia \texttt{f} puede ser aplicada elemento a elemento a cualquier array (u otra colección) con la sintaxis \texttt{f.(A)}. Por ejemplo \texttt{sin} puede ser aplicado a todos los elementos del vector \texttt{A} de esta forma:




\begin{minted}{jlcon}
julia> A = [1.0, 2.0, 3.0]
3-element Array{Float64,1}:
 1.0
 2.0
 3.0

julia> sin.(A)
3-element Array{Float64,1}:
 0.841471
 0.909297
 0.14112
\end{minted}



Por supuesto, uno puede omitir el punto si escribe un método especial para vectores de \texttt{f} por ejemplo, vía \texttt{f(A::AbstractArray) = map(f, A)} y esto es tan eficiente como \texttt{f.(A)}. Pero este enfoque necesitaría que decidas a priori qué funciones quieres vectorizar.



Más generalmente, \texttt{f.(args...)} es de hecho equivalente a \texttt{broadcast(f, args...)}, que te permite operar sobre múltiples arrays (incluso de formas distintas) o una mezcla de arrays y escalares (ver \hyperlink{6411237952146762090}{Broadcasting}). Por ejemplo, si tenemos \texttt{f(x,y) = 3x + 4y}, entonces \texttt{f.(pi,A)} devolverá un nuevo array consistente en \texttt{f(pi,a)}para cada \texttt{a} en \texttt{A}, y \texttt{f.(vector1,vector2)} devolverá un nuevo vector que consiste en \texttt{f(vector1[i],vector2[i])} para cada índice \texttt{i} (lanzando una excepción si los vectores tienen diferente longitud).




\begin{minted}{jlcon}
julia> f(x,y) = 3x + 4y;

julia> A = [1.0, 2.0, 3.0];

julia> B = [4.0, 5.0, 6.0];

julia> f.(pi, A)
3-element Array{Float64,1}:
 13.4248
 17.4248
 21.4248

julia> f.(A, B)
3-element Array{Float64,1}:
 19.0
 26.0
 33.0
\end{minted}



Además, las llamadas anidadas \texttt{f.(args...)}se funden en un solo \texttt{broadcast}. Por ejemplo \texttt{sin.(cos.(X))} es equivalent a \texttt{broadcast(x->sin(cos(x)), X)}, lo cuál es similar a \texttt{[sin(cos(x)) for x in X]}. Hay un solo bucle sobre \texttt{X}, y se asigna un solo array para el resultado. En contraste, \texttt{sin(cos(X))} en un lenguaje vectorizado típio asignaría primero un array temporal \texttt{tmp = cos(X)} y luego calcularía \texttt{sin(tmp)} en un bucle separado, asignando un segundo array. Esta fusión de bucles no es una optimización del compilador que puede ocurrir o no, sino que es una \emph{garantía sintáctica}  cuando se encuentran llamadas \texttt{f.(array...)} anidadas. Técnicamente, la fusión se para en cuanto se encuentr una función sin punto, por ejemplo, en \texttt{sin.(srt(cos.(X)))} los bucles de \texttt{sin} y \texttt{cos} no pueden mezclarse debido a la intervención de la función \texttt{sort}.



Finalmente, la eficiencia máxima suele conseguirse cuando el array de salida de una operación vectorizada es \emph{pre-asignado}, por lo que las llamadas repetidas no asignarán nuevos arrays una y otra vez para los resultados (ver \hyperlink{3053939932383108875}{Preasignando salidas}). Una sintaxis conveniente para esto es \texttt{X .= ...} que es equivalente a \texttt{broadcast!(identity, X, ...)} excepto que, como antes, el bucle \texttt{broadcast!} es fusionado con cualquier llamada con punto anidada. Por ejemplo, \texttt{X .= sin.(Y)} es equivalente a \texttt{broadcast!(sin, X, Y)}, sobreescribiendo \texttt{X} con \texttt{sin.(Y)} en su lugar. Si el miembro izquierdo de la expresión es una expresión de indexación de un array, como \texttt{X[2:end] .= sin.(Y)} entonces ella se traduce a \texttt{broadcast!} sobre una vista, por ejemplo \texttt{broadcast!(sin, view(X, 2:endof(X)), Y)}.



Como añadir puntos a muchas operaciones y llamadas a función puede resultar tedioso y conducir a código difícil de leer, se proporciona la macro \texttt{@.} para convertir cada llamada a función, operación y asignación en una expresion en su versión {\textquotedbl}con puntos{\textquotedbl}.




\begin{minted}{jlcon}
julia> Y = [1.0, 2.0, 3.0, 4.0];

julia> X = similar(Y); # pre-allocate output array

julia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))
4-element Array{Float64,1}:
  0.514395
 -0.404239
 -0.836022
 -0.608083
\end{minted}



Los operadores binarios (o unarios) como \texttt{.+} se manejan con el mismo mecanismo: son equivalentes a llamadas retransmitidas (broadcast) y son fundidas con otras llamadas que tiene puntos. \texttt{X .+= Y etcetera} es equivalente a \texttt{X .= X .+ Y} y dan como resultado una asignación fusionada. Ver también \hyperlink{6173297391052343261}{dot operators}.



\hypertarget{4552588483164083960}{}


\section{Otras Lecturas}



Deberíamos mencionar que esto está lejos de ser una visión completa de las definiciones de función. Julia tiene un sistema de tipos sofisticado y permite despacho múltiple sobre los tipos de argumento. Ninguno de los ejemplos dados aquí proporciona anotaciones de tipo sobre sus argmentos, lo que significa que son aplicables a cualquier tipo de argumento. El sistema de tipos es descrito en \hyperlink{2141690262982725665}{Tipos} definir una función en términos de métodos elegidos mediante despacho múltiple sobre los tpos de argumento en tiempo de ejecucoión se describe en el capítulo \hyperlink{15216268953652766477}{Methods}.



\hypertarget{8710711813610225279}{}


\chapter{Control Flow}



Julia proporciona una variedad de construcciones para control de flujo:



\begin{itemize}
\item \hyperlink{16096814372489430927}{Expresiones Compuestas}: \texttt{begin} and \texttt{(;)}.


\item \hyperlink{9876835618453764646}{Evaluación Condicional}: \texttt{if}-\texttt{elseif}-\texttt{else} and \texttt{?:} (ternary operator).


\item \hyperlink{10787134294480612893}{Evaluación en Cortocircuito}: \texttt{\&\&}, \texttt{||} and chained comparisons. 


\item \hyperlink{6800841505698205300}{Evaluación Repetida: Bucles}: \texttt{while} and \texttt{for}.


\item \hyperlink{13710390273166625208}{Manejo de Excepciones}: \texttt{try}-\texttt{catch}, \hyperlink{17992125292605951734}{\texttt{error()}} and \hyperlink{16410366672587017456}{\texttt{throw()}}.


\item \hyperlink{15038256797533490288}{Tareas (también denominadas Coroutinas)}: \hyperlink{4920987536368477483}{\texttt{yieldto()}}.

\end{itemize}


Los cinco primeros mecanismos de control de flujo son estándar en los lenguajes de programación de alto nivel. Las \hyperlink{4451024474180753529}{tareas} no son un mecanismo tan estándar: ellas proporcionan control de flujo no local, haciendo posible conmutar entre cálculos suspendidos temporalmente. Esta es una construcción potente: tanto el manejo de excepciones como la multitarea cooperativa se implementan en Julia usando tareas. La programación diaria no suele requerir el uso de tareas, pero ciertos problemas se resuelve de forma mucho más sencilla usando este mecanismo.



\hypertarget{16096814372489430927}{}


\section{Expresiones Compuestas}



Algunas veces es conveniente tener una sola expresión que lleva nueve varias subexpresiones en orden, devolviendo el valor de la última subexpresión como su valor. Hay dos construcciones en Julia que llevan a cabo este trabajo: los bloques \texttt{begin} y las cadenas \texttt{;} El valor de ambas expresiones compuestas es el de la última subexpresión. He aquí un ejemplo del bloque \texttt{begin}:




\begin{minted}{jlcon}
julia> z = begin
           x = 1
           y = 2
           x + y
       end
3
\end{minted}



Como estas expresiones son bastante pequeñas, podrían ponerse con facilidad en una sola línea, que es donde la sintaxis encadenada \texttt{(;)} es más útil:




\begin{minted}{jlcon}
julia> z = (x = 1; y = 2; x + y)
3
\end{minted}



Esta sintaxis es particularmente útil con la definición de función de una línea que introdujimos en \hyperlink{8538207326577378342}{Funciones}. Aunque es típico, no hay obligación de que los bloques \texttt{begin} sean multilínea o de que las cadenas de punto y coma (\texttt{;}) tengan una única línea.




\begin{minted}{jlcon}
julia> begin x = 1; y = 2; x + y end
3

julia> (x = 1;
        y = 2;
        x + y)
3
\end{minted}



\hypertarget{9876835618453764646}{}


\section{Evaluación Condicional}



La evaluación condicional permite que porciones de código sean evaluadas o no evaluadas dependiendo del valor de una expresión booleana. Esta es la anatomía de la estructura de  \texttt{if}-\texttt{elseif}-\texttt{else}:




\begin{minted}{julia}
if x < y
    println("x is less than y")
elseif x > y
    println("x is greater than y")
else
    println("x is equal to y")
end
\end{minted}



En el ejemplo anterior, si la condición \texttt{x<y} es verdadera, entonces se evaluará el bloque correspondiente. En caso contrario se evaluará la expresión \texttt{x>y}, y si esta es verdadera, se ejecutará el bloque correspondiente. Si la expresión también es falsa, se ejecutaría el bloque correspondiente al \texttt{else}. Veámoslo en acción:




\begin{minted}{jlcon}
julia> function test(x, y)
           if x < y
               println("x is less than y")
           elseif x > y
               println("x is greater than y")
           else
               println("x is equal to y")
           end
       end
test (generic function with 1 method)

julia> test(1, 2)
x is less than y

julia> test(2, 1)
x is greater than y

julia> test(1, 1)
x is equal to y
\end{minted}



Los bloques \texttt{elsif} y \texttt{else} son opcionales, y además pueden usarse tantos \texttt{elsif} como se deseen. Las expresiones condicionales del \texttt{if-elsif-else} serán evaluadas hasta que una de ellas se evalúe a \texttt{true}, después de lo cuál se evaluará el blqoue asociado, y ya no se evaluarán más expresiones condicionales.



Los bloques \texttt{if} son {\textquotedbl}permeables{\textquotedbl}, es decir, no introducen un ámbito local. Eso significa que las variables que se definen dentro del bloque serán visibles fuera del mismo. Por tanto, podríamos haber definido la relación \texttt{test} de antes como...




\begin{minted}{jlcon}
julia> function test(x,y)
           if x < y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           else
               relation = "greater than"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia> test(2, 1)
x is greater than y.
\end{minted}



La variable \texttt{relation} se ha declarado dentro del bloque \texttt{if},  pero se usa fuera. Sin embargo, cuando se hace uso de este tipo de variables, hay que asegurarse de que todos los caminos de código definen un valor para la variable. La siguiente función no lo tiene en cuenta y genera un error en tiempo de ejecución.




\begin{minted}{jlcon}
julia> function test(x,y)
           if x < y
               relation = "less than"
           elseif x == y
               relation = "equal to"
           end
           println("x is ", relation, " y.")
       end
test (generic function with 1 method)

julia> test(1,2)
x is less than y.

julia> test(2,1)
ERROR: UndefVarError: relation not defined
Stacktrace:
 [1] test(::Int64, ::Int64) at ./none:7
\end{minted}



Los bloques \texttt{if} también devuelven un valor, lo que puede no parecer intuitivo para quienes proceden de otros lenguajes de programación no funcionales. Este valor no es más que el devuelto por la última instrucción en la rama que fue elegida. Por tanto:




\begin{minted}{jlcon}
julia> x = 3
3

julia> if x > 0
           "positive!"
       else
           "negative..."
       end
"positive!"
\end{minted}



Nótese que las instrucciones condicionales muy cortas (de una línea) se suelen expresar en Julia mediante evaluación en cortocircuito, como se verá en la siguiente sección.



A diferencia de C, MATLAB, Perl, Python y Ruby (pero como en Java y en otros lenguajes tipados, más estrictos) en Julia se produce un error si el valor de una expresión condicional es algo que no sea \texttt{true} o \texttt{false}.




\begin{minted}{jlcon}
julia> if 1
           println("true")
       end
ERROR: TypeError: non-boolean (Int64) used in boolean context
\end{minted}



Este error indica que el condicional era de un tipo incorrecto: \hyperlink{7720564657383125058}{\texttt{Int64}} en lugar del requerido \hyperlink{46725311238864537}{\texttt{Bool}}.



El llamado \emph{operador ternario} (\texttt{?}) está muy relacionado con la sintaxis de \texttt{if-elsif-else}, pero se usa donde hay que hacer una elección condicional entre expresiones sencillas, a diferencia de la ejecución condicional de grandes bloques de código. Su nombre se debe a que es el único operador que toma tres operandos en la mayoría de los lenguajes de programación:




\begin{minted}{julia}
a ? b : c
\end{minted}



La expresión \texttt{a} delante del \texttt{?} es una expresión condicional, y la operación ternaria evalúa la expresión \texttt{b} (la que está delante del símbolo \texttt{:})  si la condición \texttt{a} es \texttt{true} o la expresión \texttt{c} si la condición \texttt{a} es \texttt{false}. Nótese que los espacios alrededor de \texttt{?} y \texttt{:} son obligatorios: una expresión como \texttt{a?b:c} no es una expresin ternaria válida (aunque se pueden utilizar saltos de línea entre los símbolos \texttt{?} y \texttt{:}).



La forma más fácil de comprender este comportamiento es ver un ejemplo. En el ejemplo anterior, la llamada a \texttt{println} es compartida por las tres ramas: la única elección real es qué cadena literal imprimir. Esto podría haberse escrito de forma más concisa usando el operador ternario. En aras de la claridad, intentemos primero la versión con dos caminos:




\begin{minted}{jlcon}
julia> x = 1; y = 2;

julia> println(x < y ? "less than" : "not less than")
less than

julia> x = 1; y = 0;

julia> println(x < y ? "less than" : "not less than")
not less than
\end{minted}



En los ejemplos anteriores, si \texttt{x < y} es \texttt{true} se devolverá la cadena \texttt{{\textquotedbl}less than{\textquotedbl}} y, en caso contrario, se devolverá la cadena \texttt{{\textquotedbl}not less than{\textquotedbl}}. El ejemplo original, que tiene tres opciones, requeriría el uso encadenado del operador \texttt{?}:




\begin{minted}{jlcon}
julia> test(x, y) = println(x < y ? "x is less than y"    :
                            x > y ? "x is greater than y" : "x is equal to y")
test (generic function with 1 method)

julia> test(1, 2)
x is less than y

julia> test(2, 1)
x is greater than y

julia> test(1, 1)
x is equal to y
\end{minted}



Para facilitar el encadenamiento, el operador \texttt{?} asocia de derecha a izquierda.



Es también significativo que, como en la construcción \texttt{if-elsif-else} las expresiones anterior y posterior al símbolo \texttt{:} sólo se evalúan si la expresión condicional es evaluada a \texttt{true} o \texttt{false}, respectivamente.




\begin{minted}{jlcon}
julia> v(x) = (println(x); x)
v (generic function with 1 method)

julia> 1 < 2 ? v("yes") : v("no")
yes
"yes"

julia> 1 > 2 ? v("yes") : v("no")
no
"no"
\end{minted}



\hypertarget{10787134294480612893}{}


\section{Evaluación en Cortocircuito}



La evaluación en cortocircuito es bastante similar a la evaluación condicional. Este comportamiento aparece en la mayoría de los lenguajes de programación imperativos que tiene los operadores booleanos \texttt{\&\&} y \texttt{||}.  En una serie de expresiones booleanas conectadas por estos operadores, sólo se evalúa el número mínimo de expresiones necesarios para determinar el valor booleano final de la cadena completa. Explícitamente, esto significa que:



\begin{itemize}
\item En la expresión \texttt{a \&\& b} la subexpresión \texttt{b} sólo se evalúa si la subexpresión \texttt{a} es evaluada a \texttt{true}.


\item En la expresión \texttt{a || b} la subexpresión \texttt{b} sólo se evalúa si la subexpresión \texttt{a} es evaluada a \texttt{false}.

\end{itemize}


El razonamiento es que \texttt{a \&\& b} debe ser \texttt{false} si \texttt{a} is \texttt{false}, independientemente del valor de \texttt{b} y, análogamente, el valor de \texttt{a || b} debe ser cierto si \texttt{a} es \texttt{true}, independientemente del valor de \texttt{b}. Tanto \texttt{\&\&} como \texttt{||} asocian a la derecha, pero \texttt{\&\&} tiene mayore precedencia que \texttt{||}. Es fácil experimentar con este comportamiento:




\begin{lstlisting}
julia> t(x) = (println(x); true)
t (generic function with 1 method)

julia> f(x) = (println(x); false)
f (generic function with 1 method)

julia> t(1) && t(2)
1
2
true

julia> t(1) && f(2)
1
2
false

julia> f(1) && t(2)
1
false

julia> f(1) && f(2)
1
false

julia> t(1) || t(2)
1
true

julia> t(1) || f(2)
1
true

julia> f(1) || t(2)
1
2
true

julia> f(1) || f(2)
1
2
false
\end{lstlisting}



Se puede experimentar de forma parecida con la asociatividad y la precedencia de varias combinaciones de operadores \texttt{\&\&} y \texttt{||}.



Este comportamiento se utiliza en Julia con frecuencia para formar una alternativa a instrucciones \texttt{if} muy cortas. En lugar de usar la construcción \texttt{if <cond> \&\& <instrucción>} uno puede escribir \texttt{<cond> \&\& <instrucción>} que puede leerse como \texttt{<cond>} y entonces \texttt{<instrucción>}. de forma similar, uno puede escribir \texttt{<cond> || <instrucción>}, que se leería como \texttt{<cond>} o sino \texttt{<instrucción>} en lugar de \texttt{if !<cond> || <instrucción>}.



Por ejemplo, una rutina recursiva para obtener un factorial podría ser definida como:




\begin{minted}{jlcon}
julia> function fact(n::Int)
           n >= 0 || error("n must be non-negative")
           n == 0 && return 1
           n * fact(n-1)
       end
fact (generic function with 1 method)

julia> fact(5)
120

julia> fact(0)
1

julia> fact(-1)
ERROR: n must be non-negative
Stacktrace:
 [1] fact(::Int64) at ./none:2
\end{minted}



Las operaciones booleanas sin cortocircuito podrían llevarse a cabo con los operadores a nivel de bit introducidos en la sección \hyperlink{16655087771805204817}{Operaciones Matemáticas y Funciones Elementales}: \texttt{\&} y \texttt{|}. Estas son funciones normales, que suportan la sintaxis infija de los operadores, pero que siempre evalúan sus argumentos:




\begin{lstlisting}
julia> f(1) & t(2)
1
2
false

julia> t(1) | t(2)
1
2
true
\end{lstlisting}



Como en el caso de las expresiones condicionales usadas en \texttt{if}, \texttt{elsif} o el operador ternario \texttt{?}, los operandos de \texttt{\&\&} y de \texttt{||} deben ser valores booleanos.  Usar un valor no booleanos en cualquier lugar distinto de la última entrada en una cadena condicional producirá un error.




\begin{minted}{jlcon}
julia> 1 && true
ERROR: TypeError: non-boolean (Int64) used in boolean context
\end{minted}



Por otra parte, cualquier tipo de expresión puede ser usada al final de una cadena condicional. Ella será evaluada y devuelta dependiendo de los condicionales precedentes:




\begin{minted}{jlcon}
julia> true && (x = (1, 2, 3))
(1, 2, 3)

julia> false && (x = (1, 2, 3))
false
\end{minted}



\hypertarget{6800841505698205300}{}


\section{Evaluación Repetida: Bucles}



Hay dos construcciones que realizan la evaluación repetida de expresiones: el bucle \texttt{while} y el bucle \texttt{for}. He aquí un ejemplo del bucle \texttt{while}:




\begin{minted}{jlcon}
julia> i = 1;

julia> while i <= 5
           println(i)
           i += 1
       end
1
2
3
4
5
\end{minted}



El bucle \texttt{while} evalúa la expresión condicional (en el ejemplo \texttt{i<=5}) y, mientras que esta se evalúe a \texttt{true}, sigue evaluando el cuerpo del bucle \texttt{while}. Si la expresión se evalúa a \texttt{false} la primera vez en que se alcanza el bucle, su cuerpo nunca será evaluado.



El bucle \texttt{for} facilita la repetición. Dado que contar arriba y abajo (como en el ejemplo anterior del bucle \texttt{while}) es tan común, podemos expresar esto de una forma muy concisa con un bucle \texttt{for}:




\begin{minted}{jlcon}
julia> for i = 1:5
           println(i)
       end
1
2
3
4
5
\end{minted}



En el ejemplo anterior, \texttt{1:5} es un objeto \texttt{Range} que representa una secuencia de números. El bucle \texttt{for} itera sobre estos valores, asignando cada uno de ellos por turno a la variable \texttt{i}.  Una distinción importante ente esta construcción (\texttt{for}) y la construcción anterior (\texttt{while}) es el ámbito durante el cuál la variable es visible. Si la variable \texttt{i} no ha sido introducida en otro ámbito, el bucle \texttt{for} la verá sólo en su interior y no posteriormente. Para demostrar esto necesitaremos una nueva sesión interactiva o usar un nombre de variable distinto:




\begin{minted}{jlcon}
julia> for j = 1:5
           println(j)
       end
1
2
3
4
5

julia> j
ERROR: UndefVarError: j not defined
\end{minted}



Ver \hyperlink{14993622729045334657}{Ámbito de Variables} para una explicación detallada de los ámbitos de las variables y cómo funcionan en Julia.



En general, la construcción \texttt{for} puede iterar sobre cualquier contenedor. En estos casos, la palara clave alternativa (pero totalmente equivalente \texttt{in} o \texttt{∈} es usada en lugar de \texttt{=}, dado que hace que la lectura del código sea más clara.




\begin{minted}{jlcon}
julia> for i in [1,4,0]
           println(i)
       end
1
4
0

julia> for s ∈ ["foo","bar","baz"]
           println(s)
       end
foo
bar
baz
\end{minted}



En otras secciones del manual se introducirán y discutirán varios tipos de contenedores iterables (ver, por ejemplo, \hyperlink{12380164357355707963}{Arrays Multi-dimensionales}).



Algunas veces es conveniente terminar la repetición de un \texttt{while} antes de chequear la condición de test o partar de iterar en un bucle \texttt{for} antes de que se alcance el final del objeto iterable. Esto puede conseguirse usando la palabra clave \texttt{break}:




\begin{minted}{jlcon}
julia> i = 1;

julia> while true
           println(i)
           if i >= 5
               break
           end
           i += 1
       end
1
2
3
4
5

julia> for i = 1:1000
           println(i)
           if i >= 5
               break
           end
       end
1
2
3
4
5
\end{minted}



Si no existiera la palabra clave \texttt{break}, el bucle \texttt{while} anterior nunca finalizará por si mismo,  y el bucle \texttt{for} iteraría hasta 10000. Si hacemos uso de la instrucción \texttt{break} conseguiremos abandonar el bucle mucho antes.



En otras circunstancias es útil ser capaz de detener una iteración y moverse a la siguiente de forma inmediata. Para ello, se utiliza la palabra clave \texttt{continue}:




\begin{minted}{jlcon}
julia> for i = 1:10
           if i % 3 != 0
               continue
           end
           println(i)
       end
3
6
9
\end{minted}



Este es un ejemplo un tanto artificial, ya que podríamos obtener el mismo comportamiento de forma mucho más clara negando las condiciones y colocando la llamada a \texttt{println} dentro del bloque \texttt{if}. En usos más reales hay más código que evaluar después del \texttt{continue}, y con frecuencia hay muchos puntos desde los que uno puede llamar a esta instrucción.



Podemos anidar múltiples bucles for en un solo bucle externo, formando el producto cartesiano de sus iterables:




\begin{minted}{jlcon}
julia> for i = 1:2, j = 3:4
           println((i, j))
       end
(1, 3)
(1, 4)
(2, 3)
(2, 4)
\end{minted}



Una instrucción \texttt{break} dentro de tal bucle sale del anidamiento de bucles completo, no sólo  del más interior.



\hypertarget{13710390273166625208}{}


\section{Manejo de Excepciones}



Cuando tiene lugar una condición inesperada, una funció puede ser incapaz de devolver un valor razonable al código que la invoca. En tales casos, puede ser mejor para la condición excepcional terminar el programa, imprimiendo un mensaje de error diagnóstico, o si el programador ha proporcionado código para manejar tales circunstancias excepcionales, permitiendo que el código tome la acción apropiada.



\hypertarget{6703339244372709818}{}


\subsection{Excepciones predefinidas}



Las excepciones se lanzan cuando ocurre una condición inesperada. En la siguiente tabla se muestran todas la excepciones predefinidas, que interrumplen todas el flujo de control normal.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|}
\hline
\texttt{Exception} \\
\hline
\hyperlink{1600362634474051736}{\texttt{ArgumentError}} \\
\hline
\hyperlink{9731558909100893938}{\texttt{BoundsError}} \\
\hline
\texttt{CompositeException} \\
\hline
\hyperlink{4168463413201806292}{\texttt{DivideError}} \\
\hline
\hyperlink{14085880504701688639}{\texttt{DomainError}} \\
\hline
\hyperlink{2683611566077490148}{\texttt{EOFError}} \\
\hline
\hyperlink{12102596058483452470}{\texttt{ErrorException}} \\
\hline
\hyperlink{5399118524830636312}{\texttt{InexactError}} \\
\hline
\hyperlink{9529417803286937185}{\texttt{InitError}} \\
\hline
\hyperlink{11255134339055983338}{\texttt{InterruptException}} \\
\hline
\texttt{InvalidStateException} \\
\hline
\hyperlink{12862287453053981792}{\texttt{KeyError}} \\
\hline
\hyperlink{943337379161919670}{\texttt{LoadError}} \\
\hline
\hyperlink{9656432107553099418}{\texttt{OutOfMemoryError}} \\
\hline
\hyperlink{5617183776424836760}{\texttt{ReadOnlyMemoryError}} \\
\hline
\hyperlink{13592793980665725371}{\texttt{RemoteException}} \\
\hline
\hyperlink{14644228586476494020}{\texttt{MethodError}} \\
\hline
\hyperlink{10461069697702909970}{\texttt{OverflowError}} \\
\hline
\hyperlink{17891414672434519487}{\texttt{ParseError}} \\
\hline
\hyperlink{16303515589950241655}{\texttt{SystemError}} \\
\hline
\hyperlink{2622693721821893139}{\texttt{TypeError}} \\
\hline
\hyperlink{7764749529861419421}{\texttt{UndefRefError}} \\
\hline
\hyperlink{4452889246677411554}{\texttt{UndefVarError}} \\
\hline
\texttt{UnicodeError} \\
\hline
\end{tabulary}

\end{table}



Por ejemplo, la función \hyperlink{4178506499510800909}{\texttt{sqrt()}} lanza un \hyperlink{14085880504701688639}{\texttt{DomainError}} si se aplica sobre un valor real negativo:




\begin{minted}{jlcon}
julia> sqrt(-1)
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Int64) at ./math.jl:434
\end{minted}



Uno puede definir sus propias excepciones de la siguiente manera:




\begin{minted}{jlcon}
julia> struct MyCustomException <: Exception end
\end{minted}



\hypertarget{2341277614086993207}{}


\subsection{La función \texttt{throw()}}



Las excepciones pueden crearse explícitamente con  \hyperlink{16410366672587017456}{\texttt{throw()}}. Por ejemplo, una función definida sólo para número no negativos podría escribirse para que lanzara un \hyperlink{14085880504701688639}{\texttt{DomainError}} si el argumento es negativo:




\begin{minted}{jlcon}
julia> f(x) = x>=0 ? exp(-x) : throw(DomainError())
f (generic function with 1 method)

julia> f(1)
0.36787944117144233

julia> f(-1)
ERROR: DomainError:
Stacktrace:
 [1] f(::Int64) at ./none:1
\end{minted}



Notese que \hyperlink{14085880504701688639}{\texttt{DomainError}} sin paréntesis no es una excepción, sino un tipo de excepción. Ella necesita ser invocada para obtener un objeto \texttt{Exception}:




\begin{minted}{jlcon}
julia> typeof(DomainError()) <: Exception
true

julia> typeof(DomainError) <: Exception
false
\end{minted}



Adicionalmente, algunos tipos de excepción toman uno o más argumentos que se utilizan para reportar errores.




\begin{minted}{jlcon}
julia> throw(UndefVarError(:x))
ERROR: UndefVarError: x not defined
\end{minted}



Este mecanismo puede ser fácilmente implementado mediante los tipos de excepción personalizados que sigan la forma en que se escribe \hyperlink{4452889246677411554}{\texttt{UndefVarError}}:




\begin{minted}{jlcon}
julia> struct MyUndefVarError <: Exception
           var::Symbol
       end

julia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, " not defined")
\end{minted}



\begin{quote}
\textbf{Note}

Cuando se escribe un mensaje de error, es preferible que la primera palabra sea minúscula. Por ejemplo,    

\texttt{size(A) == size(B) || throw(DimensionMismatch({\textquotedbl}size of A not equal to size of B{\textquotedbl}))}

\end{quote}


es preferible a




\begin{lstlisting}
`size(A) == size(B) || throw(DimensionMismatch("Size of A not equal to size of B"))`.
\end{lstlisting}



Sin embargo, algunas veces tiene sentido mantener la primera letra en mayúscula, por     ejemplo, si un argumento a función es una letra mayúscula: 




\begin{lstlisting}
`size(A,1) == size(B,2) || throw(DimensionMismatch("A has first dimension..."))`.
\end{lstlisting}



\hypertarget{16959204746128130100}{}


\subsection{Errores}



La función \hyperlink{17992125292605951734}{\texttt{error()}} se usa para producir una \hyperlink{12102596058483452470}{\texttt{ErrorException}} que interrumpe el flujo de control normal.



Supóngase que deseamos detener la ejecución inmediatamente si se toma la raíz cuadrad de un número negativo. Para hacer ésto, podemos definir una versión {\textquotedbl}quisquillosa{\textquotedbl} de la función  \hyperlink{4178506499510800909}{\texttt{sqrt()}} que lanza un error si recibe un número negativo:




\begin{lstlisting}
julia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error("negative x not allowed")
fussy_sqrt (generic function with 1 method)

julia> fussy_sqrt(2)
1.4142135623730951

julia> fussy_sqrt(-1)
ERROR: negative x not allowed
Stacktrace:
 [1] fussy_sqrt(::Int64) at ./none:1
\end{lstlisting}



Si \texttt{fussy\_sqrt()} es invocada con un valor negativo desde otra función, en lugar de intentar continuar la ejecución de la función que la invocó, retorna inmediatamente, mostrando el mensaje de error en la sesión interactiva:




\begin{lstlisting}
julia> function verbose_fussy_sqrt(x)
           println("before fussy_sqrt")
           r = fussy_sqrt(x)
           println("after fussy_sqrt")
           return r
       end
verbose_fussy_sqrt (generic function with 1 method)

julia> verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951

julia> verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
Stacktrace:
 [1] fussy_sqrt at ./none:1 [inlined]
 [2] verbose_fussy_sqrt(::Int64) at ./none:3
\end{lstlisting}



\hypertarget{12422647533063242790}{}


\subsection{Mensajes de aviso y de información}



Julia también proporciona otras funciones que escriben mensajes a la salida de error estándar, pero no lanzan ninguna \texttt{Exception} y, por tanto, no interrumpen la ejecución:




\begin{minted}{jlcon}
julia> info("Hi"); 1+1
INFO: Hi
2

julia> warn("Hi"); 1+1
WARNING: Hi
2

julia> error("Hi"); 1+1
ERROR: Hi
Stacktrace:
 [1] error(::String) at ./error.jl:21
\end{minted}



\hypertarget{17859988432411679883}{}


\subsection{La instrucción \texttt{try/catch}}



La intrucción \texttt{try/ catch} permite comprobar a aparición de excepciones. Por ejemplo, puede escribirse una función personalizada para calcular la raíz cuadrada que invoque automáticamente al método de cálculo de la raíz de valores reales y/o complejos en función de la excepción:




\begin{minted}{jlcon}
julia> f(x) = try
           sqrt(x)
       catch
           sqrt(complex(x, 0))
       end
f (generic function with 1 method)

julia> f(1)
1.0

julia> f(-1)
0.0 + 1.0im
\end{minted}



Es importante notar que en el código real que computa esta función, uno podría comparar \texttt{x} con vero en lugar de atrapar la excepción. De hcho, la opción de la excepción ees mucho más lenta de comparar y ramificar.



Las instrucciones \texttt{try / catch} también permiten salvar la excepción en una variable. En este ejemplo artificial, se calcula la raíz cuadrada del segundo elemento de \texttt{x}.  Si \texttt{x} es indexable, en caso contrario asume que \texttt{x} es un número real y devuelve su raíz cuadrada:




\begin{minted}{jlcon}
julia> sqrt_second(x) = try
           sqrt(x[2])
       catch y
           if isa(y, DomainError)
               sqrt(complex(x[2], 0))
           elseif isa(y, BoundsError)
               sqrt(x)
           end
       end
sqrt_second (generic function with 1 method)

julia> sqrt_second([1 4])
2.0

julia> sqrt_second([1 -4])
0.0 + 2.0im

julia> sqrt_second(9)
3.0

julia> sqrt_second(-9)
ERROR: DomainError:
Stacktrace:
 [1] sqrt_second(::Int64) at ./none:7
\end{minted}



Note que el símbolo que sigue al \texttt{catch} siempre será interpretado como el nombre para la excepción, por lo que hay que tener cuidado cuando se escriben expresiones \texttt{try / catch} en una sola línea. El siguiente código no funcionará para devolver el valor de \texttt{x} en caso de error:




\begin{minted}{julia}
try bad() catch x end
\end{minted}



En su lugar, es mejor usar un punto u coma o insertar un salto de línea después del \texttt{catch}:




\begin{minted}{julia}
try bad() catch; x end

try bad()
catch
    x
end
\end{minted}



La cláusula \texttt{catch} no es estrictamente necesaria; cuando se omite el valor de retorno por defecto es \texttt{nothing}




\begin{minted}{jlcon}
julia> try error() end # Returns nothing
\end{minted}



La potencia de la construcción \texttt{try / catch} estriba  en la capacidad de desplegar inmediatamente un  cálculo profundamente anidado de hasta un nivel mucho más elevado en la pila de llamadas a función. Hay situacionces donde no ha ocurrido error, pero la capacidad de desplegar la pila y pasar un valor a un nivel superior es deseable. Julia proporciona las funciones   \hyperlink{2102349972401293064}{\texttt{rethrow()}}, \hyperlink{6187626674327343338}{\texttt{backtrace()}} and \hyperlink{98342946516168163}{\texttt{catch\_backtrace()}} para un manejo de errores más avanzado.



\hypertarget{10494058095197025809}{}


\subsection{Cláusulas \texttt{finally}}



En código que realiza cambios de estado o usa recursos como ficheros, hay típicamente un trabajo de limpieza (tal como cerrar ficheros) que necesita ser realizado cuando el código finaliza. Las excepciones complican potencialmente esta tarea, ya que pueden causar que un bloque de código salga antes de alcanzar su final normal. La palabra clave \texttt{finally} proporciona una forma de ejecutar código cuando existe un blqoue de código dado, sin preocuparse de cómo salga.



Por ejemplo, aquí podemos garantizar que un fichero abierto se cierra:




\begin{minted}{julia}
f = open("file")
try
    # operate on file f
finally
    close(f)
end
\end{minted}



Cuando el contro deja el bloque \texttt{try} (por ejemplo, debido a un \texttt{return}, o finalizando normalmente) se ejecutará \texttt{close()}.  Si el bloque \texttt{try} saliera debido a una excepción, la excepción continuará propagándose. Un bloque \texttt{catch} puede ser combinada con \texttt{try} y \texttt{finally} también. En este caso el bloque \texttt{finally} ejecutará después de que \texttt{catch} haya manejado el error.



\hypertarget{15038256797533490288}{}


\section{Tareas (aka Corutinas)}



Las tareas son una característica de control de flujo que permite que los cálculos sean suspendidos y continuados de una forma flexible. Esta característica es llamada algunas veces con otros nombres, tales como corrutinas simétricas, hilos de peso ligero, multitarea cooperativa o continuaciones de un disparo.



Cuando una pieza de trabajo de cómputo (en la práctica, ejecutar una función particular) es designada como tarea (\hyperlink{7131243650304654155}{\texttt{Task}}), se hace posible interrumplirla intercambiándola por otra tarea. La tarea original puede ser continuada después, en el punto en que se encontraba justo cuando fue detenida. A primera vista, esto puede parecer similar a una llamada a función. Sin embargo, hay dos diferencias clave. Primero, conmutar tareas no usa ningún espacio, por lo que puede tener lugar cualquier número de intercambios de tarea sin que se consuma la pila de llamadas. Segundo, conmutar entre tareas puede ocurrir en cualquier orden, a diferencia de lo que pasa en las llamadas a función, donde la función invocada debe terminar la ejecución antes de que el control retorne a la función que la llamó.



Esta clase de flujo de control puede hacer mucho más fácil resolver ciertos problemas. En algunos problemas, las distintas piezas de trabajo requerido no están relacionadas naturalmente mediante llamadas a función: no hay un obvio llamador o llamado entre los trabajos que necesitan ser realizados. Un ejemplo es el problema del productor-consumidor, donde un procedimiento complejo está generando valores u otro procedimiento complejo los está consumiendo. El consumidor no puede simplemente llamar a la función productora para obtener un valor, debido a que el productor puede tener más valores que generar y, por tanto, podría no estar listo todavía para retornar. Con las tareas, el productor y el consumidor pueden ambos ejecutarse mientas que lo necesiten, pasando valores adelante y detrás cuando sea necesario.



Julia proporciona un mecanismo denominado {\textquotedbl}canal{\textquotedbl} (\hyperlink{12548845729684045604}{\texttt{Channel}} para resolver este problema. Un canal es una cola FIFO (primero en entrar, primero en salir) que puede tener múltiples tareas leyendo de y escribiendo en ella. 



Definamos una tarea productor, que produce valores a través de una llamada \hyperlink{12719543094136814100}{\texttt{put!}}. Para consumir valores, necesitamos planificar un productor que ejecute una nueva tarea. Para ejecutar una tarea asociada a un canal utilizaremos un constructor especial \hyperlink{12548845729684045604}{\texttt{Channel}} que recibe como argumento una función de un argumento. Podemos entonce tomar valores repetidamente  del objeto canar mediante llamadas a \hyperlink{4360129174058888556}{\texttt{take!()}}:




\begin{lstlisting}
julia> function producer(c::Channel)
           put!(c, "start")
           for n=1:4
               put!(c, 2n)
           end
           put!(c, "stop")
       end;

julia> chnl = Channel(producer);

julia> take!(chnl)
"start"

julia> take!(chnl)
2

julia> take!(chnl)
4

julia> take!(chnl)
6

julia> take!(chnl)
8

julia> take!(chnl)
"stop"
\end{lstlisting}



Una forma de pensar en este comportamiento es que el \texttt{producer} era capaz de retornar múltiples veces. Entre las llamadas a \hyperlink{12719543094136814100}{\texttt{put!()}}, la ejecución del productor se ha suspendido y el consumidor tiene el control.



El objeto \hyperlink{12548845729684045604}{\texttt{Channel}} devuelto puede ser usado como un objeto iterable dentro de un bucle \texttt{for} loop,  en cuyo caso las variable del bucle tomará todos los objetos producidos. El bucle será terminado cuando el canal se haya cerrado.




\begin{lstlisting}
julia> for x in Channel(producer)
           println(x)
       end
start
2
4
6
8
stop
\end{lstlisting}



Note que nosotros no tuvimos que cerrar explícitamente el canal en el productor. Esto es debido a que el acto de enlazar un canal (\hyperlink{12548845729684045604}{\texttt{Channel}}) a una tarea (\hyperlink{7131243650304654155}{\texttt{Task()}}) asocia el tiempo de vida abierto de un canal con el de la tarea asociada. El objeto canal se cierra automáticamente cuando la tarea termina. Podemos enlazar múltiplos canales a una tarea, y viceversa.



Aunque el constructor de \hyperlink{7131243650304654155}{\texttt{Task()}} espere una función sin argumentos, el método \hyperlink{12548845729684045604}{\texttt{Channel()}} que crea un enlace entre un canal y una tarea espera una función que acepta un solo argumento de tipo \hyperlink{12548845729684045604}{\texttt{Channel}}. Un patrón común es que el productor esté parametrizado, en cuyo caso se neceesita una aplicación de función parcial para crear una \hyperlink{8300730259363458305}{función anónima} con 1 ó 0 argumentos..



Para objetos \hyperlink{7131243650304654155}{\texttt{Task()}} esto puede hacerse bien directamente o mediante el uso de una macro conveniente:




\begin{minted}{julia}
function mytask(myarg)
    ...
end

taskHdl = Task(() -> mytask(7))
# or, equivalently
taskHdl = @task mytask(7)
\end{minted}



Para orquestar patrones de distribucióin más avanzados, pueden usarse \hyperlink{13811388816704022260}{\texttt{bind()}} y \hyperlink{9185853093207176818}{\texttt{schedule()}} en conjunción con los constructores de \hyperlink{7131243650304654155}{\texttt{Task()}} y \hyperlink{12548845729684045604}{\texttt{Channel()}} para enlazar explícitamente un conjunto de canales con un conjunto de tareas productor/consumidor.



Note que en la actualidad las tareas Julia no son planificadas para que ejecuten sobre núcleos de CPU separados. Los verdaderos hilos del núcleo se discutirán en la sección \hyperlink{3649475918943763834}{Computación Paralela}.



\hypertarget{15214712668661423439}{}


\subsection{Operaciones Básicas de Tareas}



Exploremos la construcción de bajo nivel  \hyperlink{4920987536368477483}{\texttt{yieldto()}} para comprender cómo funciona la conmutación de tareas. \texttt{yieldto(task,value)} suspende la tarea actual, conmuta a la tarea especificada, y causa que la última llamada a  \hyperlink{4920987536368477483}{\texttt{yieldto()}} devuelva el valor especificado \texttt{value}. Nótese que \hyperlink{4920987536368477483}{\texttt{yieldto()}} para usar control de flujo estilo tarea: en lugar de llamar y retornar nos limitamos a conmutar entre las distintas tareas. Esta es la razón por la que esta característica es también llamada {\textquotedbl}corrutinas simétricas{\textquotedbl}. Cada tarea es conmutada usando el mismo mecanismo.



\hyperlink{4920987536368477483}{\texttt{yieldto()}} es potente, pero la mayoría de los usos de tareas no lo invocan directamente. Consideremos a qué se debe esto. Si tu conmutas desde la tarea actual, probablemente querrás volver a conmutar en otro puento, pero saber cuándo conmutar, y saber qué tarea tiene la responsabilidad de conmutar hacia atrás puede requerir una coordinación considerable. Por  ejemplo,  \hyperlink{12719543094136814100}{\texttt{put!()}} y \hyperlink{4360129174058888556}{\texttt{take!()}} son operaciones bloqueantes, las cuales, cuando se usan en el contexto de los canales mantienen un estado para recordar quiénes son los consumidores.  No necesitar mantener manualmente la traza de la tarea es lo que hace que \hyperlink{12719543094136814100}{\texttt{put!()}} sea más sencilla de usar que la instrucción de bajo nivel \hyperlink{4920987536368477483}{\texttt{yieldto()}}.



Ademas de \hyperlink{4920987536368477483}{\texttt{yieldto()}}, se necesitan otras funciones básicas para usar las tareas de forma efectiva:



\begin{itemize}
\item \hyperlink{12929971401717674174}{\texttt{current\_task()}} devuelve una referencia a la tarea que se está ejecutando actualmente.


\item \hyperlink{7432450399685996831}{\texttt{istaskdone()}} consulta para saber si una tarea ha salido.


\item \hyperlink{188637489024602838}{\texttt{istaskstarted()}} consulta para saber si una tarea se ha iniciado ya.


\item \hyperlink{8292907206163344794}{\texttt{task\_local\_storage()}} manipula un almacenamiento clave-valor específico a la tarea actual.

\end{itemize}


\hypertarget{5528000716193123837}{}


\subsection{Tareas y Eventos}



Muchos cambios de tarea ocurren como resultado de la espera de eventos tales como peticiones de E/S, y son realizados por un planificador incluido en la librería estándar. El planificador mantiene una cola de tareas ejecutables, y ejecuta un bucle de eventos que reinicia las tareas basándose en eventos externos tales como la llegada de un mensaje.



La función básica para esperar un evento es \hyperlink{13761789780433862250}{\texttt{wait()}}. Hay varios objetos que implementan \hyperlink{13761789780433862250}{\texttt{wait()}}; por ejemplo, dado un objeto \texttt{Process}, \hyperlink{13761789780433862250}{\texttt{wait()}}  esperará a que este salga. \hyperlink{13761789780433862250}{\texttt{wait()}} suele ser implícito; por ejemplo, una llamada a \hyperlink{13761789780433862250}{\texttt{wait()}} puede tener lugar dentro de una llamada a  \hyperlink{8104134490906192097}{\texttt{read()}} para esperar a que haya datos disponibles.



En todos estos casos,  \hyperlink{13761789780433862250}{\texttt{wait()}} opera últimamente sobre un objeto  \hyperlink{286351753995469758}{\texttt{Condition}} que es responsable de encolar y reiniciar las tareas. Cuando una tarea llama a \hyperlink{13761789780433862250}{\texttt{wait()}} sobre un objeto \hyperlink{286351753995469758}{\texttt{Condition}},la tarea es marcada como no ejecutable, añadida a la cola de esta condición y el control pasa al planificador. El planificador se ocupa entonces de preparar otra tarea para ejecución o se queda bloqueado esperando eventos externos. Si todo va bien, eventualmente un manejador de eventos llamará a  \hyperlink{2865179286002578885}{\texttt{notify()}} sobre la condición, lo que causa que las tareas que estaban esperando esa condición se vuelvan ejecutables de nuevo.



Una tarea creada explícitamente llamado a  \hyperlink{7131243650304654155}{\texttt{Task}} es inicialmente no conocida por el planificador. Esto nos permite gestionar las tareas manualmente usando  \hyperlink{4920987536368477483}{\texttt{yieldto()}} si lo deseamos. Sin embargo, cuando tal tarea espera un evento, sigue siendo reiniciada cuando el evento tiene lugar, como podría esperarse. Es también posible hacer que el planificador ejecute una tarea siempre que pueda, sin esperar ningún evento necesariamente. Esto se hace llamando a \hyperlink{9185853093207176818}{\texttt{schedule()}}, o usando las macros \hyperlink{15186286520310132839}{\texttt{@schedule}} o \hyperlink{10770947021537241619}{\texttt{@async}} macros (ver \hyperlink{3649475918943763834}{Parallel Computing} para más detalles).



\hypertarget{12490226659593495774}{}


\subsection{Estados de una Tarea}



La tareas tienen un campo \texttt{state} que describe su estado de ejecucoión. El estado de una tarea es  uno de los siguientes símbolos:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Symbol & Meaning \\
\hline
\texttt{:runnable} & Ejecutando actualmente, o disponible para ser intercambiado \\
\hline
\texttt{:waiting} & Bloqueado esperando un evento específico \\
\hline
\texttt{:queued} & En la cola de ejecución del planiticador a punto de ser reiniciado \\
\hline
\texttt{:done} & Finalizada su ejecucción con éxito \\
\hline
\texttt{:failed} & Finalizado con alguna excepción no atrapada \\
\hline
\end{tabulary}

\end{table}



\hypertarget{14993622729045334657}{}


\chapter{Ámbito de las variables}



El \emph{ámbito} de una variable es la región de código donde dicha variable es visible. El ámbito de las variables ayuda a evitar conflictos de nombrado de variables. El concepto es intuitivo: dos funciones pueden tener argumentos denominados \texttt{x} sin que las dos \texttt{x} se refieran a la misma cosa. De forma similar, hay muchos otros casos donde diferentes bloques de código pueden usar el mismo nombre sin referirse a la misma cosa. Las reglas para cuando el mismo nombre de variable se refiere o no a la  misma cosa se llaman \emph{reglas de ámbito}. Em este tema se analizan en detalle. 



Ciertas construcciones en el lenguaje introducen \emph{bloques de ámbitos}, que son regiones de código que son elegibles para estar en el ámbito de algún conjunto de variables. El ámbito de una variable no puede ser un conjunto arbitrario de líneas de código; en lugar de ello, siempre se alinea con uno de esos bloques. Hay dos tipos principales de ámbitos en Julia: \emph{globales} y \emph{locales}, pudiendo los últimos estar anidados. Las construcciones que introducen estos bloques de ámbito son:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Nombre de ámbito & Bloque/construcción que introduce este tipo de ámbito \\
\hline
Ámbito Global & \texttt{module}, \texttt{baremodule} y prompt interactivo (REPL) \\
\hline
Ámbito Local   & \hyperlink{7335782086544106228}{Ámbito local blando}: \texttt{for}, \texttt{while} comprensiones, bloques \texttt{try-catch-finally}, \texttt{let} \\
\hline
Ámbito Local   & \hyperlink{862465853020504332}{Ámbito local duro}: funciones (cualquier sintaxis, anónima y bloques do), \texttt{struct}, \texttt{macro} \\
\hline
\end{tabulary}

\end{table}



Dos notables ausencias en esta tabla son los \hyperlink{16096814372489430927}{bloques begin} y los \hyperlink{9876835618453764646}{bloques if}, que no introducen nuevos bloques de ámbito. Los tres tipos de bloques siguen reglas un poco diferentes que serán explicadas más adelante, así como algunas reglas extra para ciertos bloques.



Julia usa un \href{https://en.wikipedia.org/wiki/Scope\_\%28computer\_science\%29\#Lexical\_scoping\_vs.\_dynamic\_scoping}{ámbito léxico}, lo que significa que el ámbito de una función no hereda del ámbito que lo invocó, pero si del ámbito en que la función fue definida. Por ejemplo, en el siguiente código, \texttt{x} deontro de \texttt{foo} se refiere a la \texttt{x} que hay en el ámbito local de su módulo \texttt{Bar}:




\begin{lstlisting}
julia> module Bar
           x = 1
           foo() = x
       end;
\end{lstlisting}



y no a la \texttt{x} en el ámbito en que se ha usado \texttt{foo}:




\begin{lstlisting}
julia> import .Bar

julia> x = -1;

julia> Bar.foo()
1
\end{lstlisting}



Por tanto, \emph{ámbito léxico} significa que el ámbito de las variables puede ser inferido del código fuente sin más. 



\hypertarget{286135318489801572}{}


\section{Ámbito Global}



\emph{Cada módulo introduce un nuevo espacio global}, separado del ámbito global de todos los otros módulos; no existen ámbitos globales compartidos por todos. Los módulos pueden introducir variables de otros módulos o en su ámbito a través del uso de las instrucciones \hyperlink{10438697863683890874}{\texttt{using}} o \hyperlink{10438697863683890874}{\texttt{import}} o a través de acceso cualificado usando la notación punto. En consecuencia, cada módulo es un espacio de nombres. Notese que los enlaces de nombres pueden sólo ser cambiados  dentro de su ámbito global y no desde un módulo exterior.




\begin{minted}{jlcon}
julia> module A
           a = 1 # a global in A's scope
       end;

julia> module B
           module C
               c = 2
           end
           b = C.c    # can access the namespace of a nested global scope
                      # through a qualified access
           import ..A # makes module A available
           d = A.a
       end;

julia> module D
           b = a # errors as D's global scope is separate from A's
       end;
ERROR: UndefVarError: a not defined

julia> module E
           import ..A # make module A available
           A.a = 2    # throws below error
       end;
ERROR: cannot assign variables in other modules
\end{minted}



Nótese que el prompt interactivo (REPL) está en el ámbito global del módulo \texttt{Main}.



\hypertarget{208328426191671287}{}


\section{Ámbito Local}



La mayoría de los bloques de código introducen un nuevo ámbito local. Los ámbitos locales suelen heredar todas las variables de su ámbito padre, tanto para lectura como para escritura. Hay dos subtipos de ámbitos locales, denominados \emph{duros} y \emph{blandos}, con reglas ligeramente distintas en relación a qué variables son heredadas. A diferencia de los ámbitos globales, los ámbitos locales no son espacios de nombres, por lo que las variables de un ámbito más interno no pueden ser recuperadas de uno más externo a través de alguna clase de acceso cualificado.



Las siguientes reglas y ejemplos pertenecen tanto a los ámbitos locales como globales. Una variable introducida de nuevo en un ámbito local no se retroprogada a su ámbito padre. Por ejemplo, la \texttt{z} no se introduce en el ámbito de nivel superior:




\begin{minted}{jlcon}
julia> for i = 1:10
           z = i
       end

julia> z
ERROR: UndefVarError: z not defined
\end{minted}



(Nótese que En este ejemplo y los siguientes se supone que el ámbito de nivel superior es un ámbito global con un espacio de trabajo limpio, por ejemplo un REPL arrancado de nuevo.)



Dentro de un ámbito local una variable puede ser forzada a ser una variables local usando la palabra clave \texttt{local}.




\begin{minted}{jlcon}
julia> x = 0;

julia> for i = 1:10
           local x
           x = i + 1
       end

julia> x
0
\end{minted}



Dentro de un ámbito local puede definirse una nueva variable global usando la palabra clave \texttt{global}:




\begin{minted}{jlcon}
julia> for i = 1:10
           global z
           z = i
       end

julia> z
10
\end{minted}



La localización de las palabras clave \texttt{local} y  \texttt{global} dentro del bloque del ámbito es irrelevante. El siguiente código es totalmente equivalente al ejemplo anterior (aunque estilísticamente es peor): 




\begin{minted}{jlcon}
julia> for i = 1:10
           z = i
           global z
       end

julia> z
10
\end{minted}



\hypertarget{7335782086544106228}{}


\subsection{Ámbito local blando}



\begin{quote}
En un ámbito local blando, todas las variables son heredadas de su ámbito padre a menos que una  variable haya sido marcada específicamente con la palabra \texttt{local}.

\end{quote}


Los ámbitos locales blandos se introducen en los bucles \texttt{for}, bucles \texttt{while}, comprensiones, bloques \texttt{try-catch-finally} y bloques \texttt{let}. Hay algunas reglas extra para los \hyperlink{11032855793518532619}{bloques \texttt{let}} y para los \hyperlink{878644895699613147}{bucles \texttt{for} y comprensiones}.



En el siguiente ejemplo, \texttt{x} e \texttt{y} se refieren siempre a la misma variable dado que el ámbito local blando heredan ambas variables de lectura y escritura:




\begin{minted}{jlcon}
julia> x, y = 0, 1;

julia> for i = 1:10
           x = i + y + 1
       end

julia> x
12
\end{minted}



Dentro de los ámbitos blandos, la palabra clave \emph{global} no es nunca necesaria, aunque está permitida. El único caso donde podría cambiar la semántica es (actualmente) un error sintáctico:




\begin{minted}{jlcon}
julia> let
           local j = 2
           let
               global j = 3
           end
       end
ERROR: syntax: `global j`: j is local variable in the enclosing scope
\end{minted}



\hypertarget{862465853020504332}{}


\subsection{Ámbito local duro}



Los ámbitos locales duros se introducen mediante las definiciones de función (en todas sus formas) bloques de tipos e inmutables y definiciones de macros.



\begin{quote}
En el ámbito local duro, todas las variables son heredades de su ámbito padre a menos que:

\begin{itemize}
\item Una asignación daría como resultado una variable \texttt{global}


\item Una variable sea marcada específicamente con la palabra clave \texttt{local}.

\end{itemize}
\end{quote}


Por tanto, las variables globales son sólo heredadas para lectura pero no para escritura:




\begin{minted}{jlcon}
julia> x, y = 1, 2;

julia> function foo()
           x = 2        # assignment introduces a new local
           return x + y # y refers to the global
       end;

julia> foo()
4

julia> x
1
\end{minted}



Se necesita un \texttt{global} explícito para asignar a una variable global:




\begin{minted}{jlcon}
julia> x = 1;

julia> function foobar()
           global x = 2
       end;

julia> foobar();

julia> x
2
\end{minted}



Note que las \emph{funciones anidadas} pueden comportarse diferentemente de las funciones definidas en el ámbito global como si ellas pudieran variar las variables locales del ámbito padre.




\begin{minted}{jlcon}
julia> x, y = 1, 2;

julia> function baz()
           x = 2 # introduces a new local
           function bar()
               x = 10       # modifies the parent's x
               return x + y # y is global
           end
           return bar() + x # 12 + 10 (x is modified in call of bar())
       end;

julia> baz()
22

julia> x, y
(1, 2)
\end{minted}



La distinción entre heredar variables locales y globales para asignación puede llevar a ligeras diferencias entre funciones definidas en ámbitos locales y/o globales. Considere la modificación del último ejemplo moviendo \texttt{bar} al ámbito global:




\begin{minted}{jlcon}
julia> x, y = 1, 2;

julia> function bar()
           x = 10 # local
           return x + y
       end;

julia> function quz()
           x = 2 # local
           return bar() + x # 12 + 2 (x is not modified)
       end;

julia> quz()
14

julia> x, y
(1, 2)
\end{minted}



Notemos que lo anterior sutilmente no pertenece a las definiciones de tipo y de macro, por lo que ellas sólo pueden aparecer en el ámbito global. Hay reglas de ámbito especiales relacionadas con la evaluación de argumentos de función por defecto y palabra clave que se describen en la sección de \hyperlink{11836327794581856778}{Funciones}.



Una asignación que introduce una variable usada dentro de una definicíon de función, tipo o macro no necesita ir antes de su uso interno: 




\begin{minted}{jlcon}
julia> f = y -> y + a
(::#1) (generic function with 1 method)

julia> f(3)
ERROR: UndefVarError: a not defined
Stacktrace:
 [1] (::##1#2)(::Int64) at ./none:1

julia> a = 1
1

julia> f(3)
4
\end{minted}



Este comportamiento puede parecer un poco raro para una variable normal, pero está permitido para que las funciones nombradas sean usadas antes de ser definidas (las funciones nombradas son exactamente variables normales que almacenan objetos función). Esto permite a las funciones ser definidas en cualquier orden que sea intuitivo y conveniente en lugar de forzar un  ordenamiento de abajo a arriba o requerir declaraciones hacia delante, mientras que ellas sean definidas en el momento que sean usadas. Por ejemplo, he aquí una forma ineficiente, mutuamente recursiva de comprobar si un entero positivo es par o impar:




\begin{minted}{jlcon}
julia> even(n) = n == 0 ? true : odd(n-1);

julia> odd(n) = n == 0 ? false : even(n-1);

julia> even(3)
false

julia> odd(3)
true
\end{minted}



Julia proporciona funciones eficientes y predefinidas para comprobar la paridad o imparidad, llamadas \hyperlink{6755629456808693979}{\texttt{iseven()}} e \hyperlink{2288006657111547854}{\texttt{isodd()}}. Por tanto, las definiciones anteriores deberían ser sólo tomadas como ejemplos.



\hypertarget{15800683117927391880}{}


\subsection{Ámbitos locales duro vs. blando}



Los bloques que introducen un ámbito local blando, como los bucles, se suelen usar para manipular las variables en su ámbito padre. Por tanto, su defecto es acceder completamente a todas las variables de su ámbito padre.



A la inversa, el código dentro de los bloques que introduce un ámbito local duro (definiciones de función, tipo o macro) pueden ser ejecutados en cualquier parte del programa. Cambiar remotamente el estado de variables locales en otros módulos debería ser realizado con cuidado y por tanto esta es una característica de optimización que requiere la palabra clave \texttt{global}.



La razón para permitir \emph{modificar local} variables de ámbitos padres en funciones anidadas es permitir la construcción de \href{https://en.wikipedia.org/wiki/Closure\_\%28computer\_programming\%29}{cierres} que tienen un estado privado, por ejemplo la variable \texttt{state} del siguiente ejemplo:




\begin{minted}{jlcon}
julia> let
           state = 0
           global counter
           counter() = state += 1
       end;

julia> counter()
1

julia> counter()
2
\end{minted}



Ver también los cierres en los ejemplos de las dos siguientes secciones.



\hypertarget{11032855793518532619}{}


\subsection{Bloques Let}



A diferencia de las asignaciones a variables locales, las instrucciones \texttt{let} asignan nuevas asociaciones de variables cada vez que se ejecutan. Una asignación modifica el valor de una localización existente, y \texttt{let} crea nuevas localizaciones. Esta diferencia no suele ser importante, y es sólo detectable en el caso de variables que sobreviven a sus ámbitos vía cierres. La sintaxis de \texttt{let} acepta una serie de asignaciones y nombres de variables separados por comas:




\begin{minted}{jlcon}
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           println("x: $x, y: $y") # x is local variable, y the global
           println("z: $z") # errors as z has not been assigned yet but is local
       end
x: 1, y: -1
ERROR: UndefVarError: z not defined
\end{minted}



Las asignaciones se evalúan en orden, con cada término derecho evaluado en el ámbito antes de que se introduzca la nueva variable a través del término izquierdo. Por tanto, tiene sentido escribir algo como \texttt{let x = x} ya que las dos variables son distintas y tienen almacenamiento separado. Este es un ejemplo de dónde se necesita el comportamiento de \texttt{let}: 




\begin{minted}{jlcon}
julia> Fs = Array{Any}(2); i = 1;

julia> while i <= 2
           Fs[i] = ()->i
           i += 1
       end

julia> Fs[1]()
3

julia> Fs[2]()
3
\end{minted}



Aquí creamos y almacenamos dos cierres que devuelven la variable \texttt{i}. Sin embargo, es siempre la misma variable \texttt{i}, por lo que los dos cierres se comportan de forma idéntica. Podemos usar \texttt{let} para crear una nueva correspondencia para \texttt{i}:




\begin{minted}{jlcon}
julia> Fs = Array{Any}(2); i = 1;

julia> while i <= 2
           let i = i
               Fs[i] = ()->i
           end
           i += 1
       end

julia> Fs[1]()
1

julia> Fs[2]()
2
\end{minted}



Como la construcción \texttt{begin} no construye un nuevo ámbito, puede ser útil usar un \texttt{let} con cero argumentos para introducir un nuevo bloque de ámbito sin crear ninguna nueva correspondencia:




\begin{minted}{jlcon}
julia> let
           local x = 1
           let
               local x = 2
           end
           x
       end
1
\end{minted}



Como \texttt{let} introduce un nuevo bloque de ámbito, la variable local interna \texttt{x} es diferente de la externa local \texttt{x}.



\hypertarget{878644895699613147}{}


\subsection{Bucles for y comprensiones}



Los bucles \texttt{for} y las \hyperlink{10712284114727773149}{comprensiones} tiene el siguiente comportamiento: cualquier nueva variable introducida en sus ámbitos se reservan de nuevo para cada nueva iteración del bucle. Esto contrasta con los bucles \texttt{while} que reservan las variables para todas las iteraciones. Por tanto, estas construcciones son similares a bucles \texttt{while} con bloques \texttt{let} dentro de ellos:




\begin{minted}{jlcon}
julia> Fs = Array{Any}(2);

julia> for j = 1:2
           Fs[j] = ()->j
       end

julia> Fs[1]()
1

julia> Fs[2]()
2
\end{minted}



Los bucles \texttt{for} reusarán las variables existentes para su variable iteración:




\begin{minted}{jlcon}
julia> i = 0;

julia> for i = 1:3
       end

julia> i
3
\end{minted}



Sin embargo, las comprensiones no hacen esto, y siempre asignan de nuevo sus variables de iteración:




\begin{minted}{jlcon}
julia> x = 0;

julia> [ x for x = 1:3 ];

julia> x
0
\end{minted}



\hypertarget{9218040371144180833}{}


\section{Constantes}



Un uso común de las variables es darle nombres de valores específicos, no cambiantes. Tales variables sólo se asignan una vez. Esta intención puede ser transportada al compilador usando la palabra clave \texttt{const}:




\begin{minted}{jlcon}
julia> const e  = 2.71828182845904523536;

julia> const pi = 3.14159265358979323846;
\end{minted}



La declaración \texttt{const} es permitida sobre variables globales y locales, pero es especialmente útil para las globales. Es difícil para el compilador optimizar´código en el que están implicadas las variables globales, ya que sus valores (o incluso sus tipos) podrían cambiar en cualquier momento. Si una variable global no va a cambiar, añadir una declaración \texttt{const}  resolverá este problema de rendimiento.



Las constantes locales son bastante diferentes. El compilador es capaz de determinar cuando una variable local es constante, por lo que las declaraciones de constante local no son necesarias para mejorar el rendimiento.



Las asignaciones especiales de nivel superior, tales como las realizadas por las palabras clave \texttt{function} y \texttt{type} son constantes por defecto. 



Nótese que \texttt{const} sólo afecta a la asociación de variables:  la variable puede ser asociada a un objeto mutable (tal com un array) y el objeto puede aún ser modificado.



\hypertarget{2141690262982725665}{}


\chapter{Tipos}



Los sistemas de tipos han caído tradicionalmente en dos categorías muy diferentes: los \emph{sistemas de tipos estáticos}, donde cada expresión del programa debe tener un tipo computable antes de la ejecución del programa, y los \emph{sistemas de tipos dinámicos}, donde nada es sabido sobre los tipos hasta el momento de la ejecución, cuando los valores actuales manipulados por el programa están disponibles. La orientación a objetos permite una flexibilidad en los lenguajes tipados estáticamente dejando que el código sea escrito sin que se conozcan los tipos precisos de los valores en tiempo de compilación. La capacidad de escribir código que pueda operar sobre diferentes tipos se denomina polimorfismo. Todo el código en los lenguajes clásicos tipados dinámicamente es polimórfico: sólo mediante comprobación de equipos explícita o cuando los objetos fallan para soportar las operaciones en tiempo de ejecución, están los tipos de cualquier valor siempre restringidos.



El sistema de tipos de Julia es dinámico, pero tiene algunas de las ventajas de los sistemas de tipos estáticos haciendo posible indicar que ciertos valores son de tipos específicos. Esto puede ser de gran ayuda en la generación de código eficiente, pero incluso más significativamente, permite que el despacho de métodos sobre los tipos de los argumentos a función este profundamente integrado con el lenguaje. El despacho de métodos se explorará en detalle en la sección \hyperlink{15216268953652766477}{Methods}, pero está enraizado en el sistema de equipos presentado en este capítulo..



El comportamiento por defecto en Julia cuando se omiten los tipos es permitir que los valores sean de cualquier tipo. Por tanto, uno puede escribir muchos programa Julia útiles sin siquiera usar explícitamente los tipos. Cuando se necesita una expresividad adicional, sin embargo, es fácil introducir gradualmente anotaciones de tipo explícitas en código previamente no tipado. Hacer eso suele incrementar el rendimiento y la robustez de estos sistemas, y quizás algo contra intuitivo: simplificarlos frecuentemente.



Describir Julia en el lingo de los \href{https://en.wikipedia.org/wiki/Type\_system}{sistemas de tipos}, es decir que es: \emph{dinámico}, \emph{nominativo} y \emph{paramétrico}. Los tipos genéricos pueden ser parametrizados, y las relaciones jerárquicas entre tipos son \href{https://en.wikipedia.org/wiki/Nominal\_type\_system}{declaradas explítamente}, en lugar de ser \href{https://en.wikipedia.org/wiki/Structural\_type\_system}{implicadas mediante una estructura compatible}. Una característica particularmente distintiva del sistema de tipos de Julia es que los tipos concretos no pueden tener subtipos. Todos los tiempos completos son finales y sólo pueden tener tipos abstractos como supertipos. Aunque esto puede parecer excesivamente restrictivo al principio, tiene muchas consecuencias beneficiosas con sorprendentemente pocos inconveniente. Resulta que ser capaz de heredar comportamientos es mucho más importante que seas capaz de heredar estructura, y heredar ambas cosas causa dificultades significativas en los lenguajes orientados a objetos tradicionales. Otros aspectos de alto nivel del sistema del tipo de Julia que Debería ser mencionados son:



\begin{itemize}
\item No hay división entre los valores objetos y no objetos. Todos los valores en Julia son verdaderos objetos que tienen un tipo que pertenece a un solo grafo de tipos totalmente conectado, todos los nodos del cual son de primera clase como tipos.


\item No hay un concepto significativo de tiempo en tiempo de compilación. El único tipo que tiene un valor es su tipo actual cuando el programa está corriendo. Esto se denomina tipo en tiempo de ejecución en los lenguajes orientados a objetos, donde la combinación de complicación estática con polimorfismo hace esta distinción significativa.


\item Sólo los valores, no las variables, tienen tipos. Las variables son siempre nombres enlazados a valores.


\item Tanto los tipos abstractos como concretos pueden ser paralizados por otros tipos. Ellos pueden ser parametrizados mediante símbolos, mediante valores de cualquier tipo para los cuáles \hyperlink{12980593021531333073}{\texttt{isbits()}} devuelve \texttt{true} (esencialmente, cosas como números y booleanos que son almacenados como tipos C o estructuras sin punteros a otros objetos), y también mediante tuplas. Los parámetros de tipo pueden ser omitidos cuando no necesitan ser referenciados o restringidos.

\end{itemize}


El sistema de tipos de Julia está diseñado para ser potente y expresivo, además de claro, intuitivo y no obstructivo. Muchos programadores Julia nunca sentirán la necesidad de escribir código que use los tipos explícitamente. Algunas clases de programación, sin embargo, se vuelven más claras, rápidas y robustas usando tipos declarados.



\hypertarget{11104251578077209325}{}


\section{Declaraciones de tipo}



El operador \texttt{::} puede usarse para adjuntar declaraciones de tipo a expresiones y variables en los programas. Hay dos razones principales para esto:



\begin{itemize}
\item[1. ] Como una aserción para ayudar a confirmar que nuestro programa funciona como se esperaba.


\item[2. ] Para proporcionar al compilador información extra sobre tipos, que puede mejorar el rendimiento en algunos casos.

\end{itemize}


Cuando se añade a una expresión que calcula un valor, el operador \texttt{::}se lee como {\textquotedbl}es una instancia de{\textquotedbl}. Puede ser utilizado en cualquier parte para asertar que el valor de la expresión de la izquierda es una instancia del tipo de la derecha. Cuando el tipo de la derecha es concreto, el valor  sobre la izquierda debe tener ese tipo como su implementación (recuerde que todos los tipos concretos son finales, por lo que no hay implementaciones que sean subtipos de otros). Cuando el tipo es abstracto, basta que el valor sea implementado por un tipo concreto que sea un subtipo del tipo abstracto. Si la aserción de tipo no es \texttt{true} se lanza una excepción. En caso contrario, se devuelve el valor del lado izquierdo.




\begin{minted}{jlcon}
julia> (1+2)::AbstractFloat
ERROR: TypeError: typeassert: expected AbstractFloat, got Int64

julia> (1+2)::Int
3
\end{minted}



Esto permite que la aserción de tipo sea adjuntada a cualquier expresión \emph{in situ}.



Cuando se añade a una variable sobre el lado izquierdo de una asignación, o como parte de una declaración \texttt{local}, el operador \texttt{::} significa algo un poco diferente: declara que la variable siempre tendrá el tipo especificado, como una declaración de tipo de los lenguajes tipados estáticamente como C. Cada valor asignado a la variable será convertido al tipo declarado usando \hyperlink{1846942650946171605}{\texttt{convert()}}:




\begin{minted}{jlcon}
julia> function foo()
           x::Int8 = 100
           x
       end
foo (generic function with 1 method)

julia> foo()
100

julia> typeof(ans)
Int8
\end{minted}



Esta característica es útil para evitar las {\textquotedbl}trampas{\textquotedbl} de rendimiento que podrían tener lugar si una de las asignaciones a varible cambia su tipo inesperadamente. 



Este comportamiento {\textquotedbl}declaración{\textquotedbl} sólo ocurre en contextos específicos:




\begin{minted}{julia}
local x::Int8  # in a local declaration
x::Int8 = 10   # as the left-hand side of an assignment
\end{minted}



y se aplica al ámbito actual completo, incluso antes de la declaración. Actualmente, las declaraciones de tipo no pueden ser usadas en un espacio global, como en el REPL, ya que Julia no tiene aún globales de tipo constante.



Las declaraciones pueden también ser enlazadas a las definiciones de función:




\begin{minted}{julia}
function sinc(x)::Float64
    if x == 0
        return 1
    end
    return sin(pi*x)/(pi*x)
end
\end{minted}



Retornar de esta función se comporta justo como una asignación a una variable con un tipo declarado: el tipo será siempre convertido a \texttt{Float64}.



\hypertarget{8027802357779464383}{}


\section{Tipos Abstractos}



Los tipos abstractos no puede ser instanciados, y sólo sirven como nodos en el grafo de tipos, describiendo de este mundo conjuntos de tipos concretos relacionados: aquellos tipos concretos que son sus descendientes. Comenzamos con tipos abstractos incluso aunque no tienen instanciación debido a que ellos son la espina dorsal del sistema de tipos: ellos forman la jerarquí conceptual qu hace al sistema de tipos de Julia más que una colección de implementaciones de objetos. 



Recuerde que en \hyperlink{17453309092420764607}{Números Enteros y en Punto Flotante}, introdujimos una variedad de tipos de valores numéricos concretos: \hyperlink{5857518405103968275}{\texttt{Int8}}, \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{6667287249103968645}{\texttt{Int16}}, \hyperlink{7018610346698168012}{\texttt{UInt16}}, \hyperlink{10103694114785108551}{\texttt{Int32}}, \hyperlink{8690996847580776341}{\texttt{UInt32}}, \hyperlink{7720564657383125058}{\texttt{Int64}}, \hyperlink{5500998675195555601}{\texttt{UInt64}}, \hyperlink{8012327724714767060}{\texttt{Int128}}, \hyperlink{14811222188335428522}{\texttt{UInt128}}, \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}}. Aunque todos ellos tienen diferentes tamaños en representación,  \texttt{Int8}, \texttt{Int16}, \texttt{Int32}, \texttt{Int64} and \texttt{Int128} tienen en común que son tipos enteros con signo. Del mismo modo, \texttt{UInt8}, \texttt{UInt16}, \texttt{UInt32}, \texttt{UInt64} and \texttt{UInt128} son enteros sin signo, mientras que \texttt{Float16}, \texttt{Float32} and \texttt{Float64} son tipos en punto flotante. Es común para una pieza de código que ésta tenga sentido, por ejemplo, sólo si sus argumentos son algún tipo de entero, pero no que dependa de un tipo de entero particular. Por ejemplo, el algoritmo del máximo común denominador funciona para todas las clases de enteros, pero no funcionará para los números en punto flotante. Los tipos abstractos permiten la construcción de una jerarquía de tipos, proporcionando un contexto en el cuál los tipos concretos pueden ajustarse. Esto te permite, por ejemplo, programar fácilmente a cualquier tipo que sea un entero, sin restringir el algoritmo a un tipo de entero específico.



Los tipos abstractos se declaran usando la palabra clave \texttt{abstract}. Las sintaxis generales para declarar un tipo abstracto son:




\begin{lstlisting}
abstract type «name» end
abstract type «name» <: «supertype» end
\end{lstlisting}



La palabra clave \texttt{abstract type} introduce un nuevo tipo abstracto, cuyo nombre viene dado por \texttt{«name»}. Este nombre puede ir seguido opcionalmente de \texttt{<:} y un nombre de tipo ya existente, lo cuál indica que este tipo abstracto es un subtipo del ya existente..



Cuando no se proporciona supertipo, el supertipo por defecto es \texttt{Any} (un tipo \texttt{abstract} predefinido del que todos los objetos son instancias y todos los tipos son subtipos). En teoría de tipos, \texttt{Any} suele ser denominado \emph{top} porque es la cúspide del grafo de los tipos. Julia tiene también un tipo abstracto \emph{bottom}, en el punto más bajo del grafo de tipos, que se escribe como \texttt{Union\{\}}. Es el opuesto exacto de \texttt{Any}: ningún objeto es instancia de \texttt{Union\{\}} y todos los tipos son sus supertipos.



Consideremos algunos de los tipos abstractos que forman parte de la jerarquía numérica de Julia:




\begin{minted}{julia}
abstract type Number end
abstract type Real     <: Number end
abstract type AbstractFloat <: Real end
abstract type Integer  <: Real end
abstract type Signed   <: Integer end
abstract type Unsigned <: Integer end
\end{minted}



El tipo \hyperlink{1990584313715697055}{\texttt{Number}} es un hijo directo de \texttt{Any}, y \hyperlink{6175959395021454412}{\texttt{Real}} es su hijo. \texttt{Real} tiene dos hijos (tiene más, pero sólo mostraremos dos aquí): \hyperlink{8469131683393450448}{\texttt{Integer}} y \hyperlink{11465394427882483091}{\texttt{AbstractFloat}}, que dividen el mundo entre representaciones de números enteros y reales. Las representaciones de números reales incluyen, por supuesto, los tipos en punto flotante, pero también incluyen otros tipos como los racionales. Por tanto,  \texttt{AbstractFloat} es un subtipo apropiado de \texttt{Real} que incluye sólo representaciones en punto flotante de los números reales. Los enteros están también divididos en las variedades \hyperlink{14154866400772377486}{\texttt{Signed}} y \hyperlink{4780971278803506664}{\texttt{Unsigned}}.



El operador \texttt{<:} significa, en general, {\textquotedbl}es un subtipo de{\textquotedbl} y, usado en declaraciones como esta, declara que el tipo de la parte derecha es un supertipo inmediato de tipo que acaba de crearse. También puede usarse en expresiones como un obperador de subtipo que devuelve \texttt{true} cuando el operando de su izquierda es un subtipo del operando de su derecha:




\begin{minted}{jlcon}
julia> Integer <: Number
true

julia> Integer <: AbstractFloat
false
\end{minted}



Un uso importante de los tipos abstractos es proporcionar una implementación por defecto para los tipos concretos. Para dar un ejemplo simple, considere:




\begin{minted}{julia}
function myplus(x,y)
    x+y
end
\end{minted}



La primera cosa que hay que notar es que las declaraciones de argumento anteriores son equivalentes a \texttt{x::Any} e \texttt{y::Any}.  Cuando se invoca a estas funciones, digamos con \texttt{myplus(2,5)}, el despachador elige el método más específico cuyo nombres sea \texttt{myplus} y que se corresponda con los argumentos dados (ver \hyperlink{15216268953652766477}{Métodos} para más informacíon sobre despacho múltiple).



Asumiendo que no se encuentra método más específico que el anterior, a continuación Julia define y compila un método llamado \texttt{myplus} específicamente para dos argumentos \texttt{Int} basado en la función genérica dada anteriormente, es decir, implícitamente define y compila:




\begin{minted}{julia}
function myplus(x::Int,y::Int)
    x+y
end
\end{minted}



y, finalmente invoca a este método específico.



Por tanto, los tipos abstractos permiten a los programadores escribir funciones genéricas que puedan ser usadas después como el método por defecto mediante muchas combinaciones de tipos concretos. Gracias al despacho múltipel, el programador tiene control total sobre si se usa el método por defecto o uno más específico.



Un punto importante que notar es que no hay pérdida en el rendimiento si el programador se basa en una función cuyos argumentos sean tipos abstractos, dado que ella es recompilada para cada tupla de argumentos de tipos concretos con la cuál sea invocada (sin embargo, puede haber un problema de rendimiento en el caso de argumentos función que sean contenedores de tipos abstractos; ver \hyperlink{3908315974291496321}{Consejos de Rendimiento}.)



\hypertarget{17327063884069562276}{}


\section{Tipos Primitivos}



Un tipo primitivo es aquél un tipo concreto cuyos datos consisten en bits normales y corrientes. Ejemplos clásicos de tipos bits son los valores enteros y punto flotante. A diferencia de muchos lenguajes, Julia nos permite declarar nuestros propios tipos bits, en lugar de proporcionar un conjunto fijo de tipos bits predefinidos. De hecho, los tupos bits estándar que están definidos en el propio lenguaje son:




\begin{minted}{julia}
primitive type Float16 <: AbstractFloat 16 end
primitive type Float32 <: AbstractFloat 32 end
primitive type Float64 <: AbstractFloat 64 end

primitive type Bool <: Integer 8 end
primitive type Char 32 end

primitive type Int8    <: Signed   8 end
primitive type UInt8   <: Unsigned 8 end
primitive type Int16   <: Signed   16 end
primitive type UInt16  <: Unsigned 16 end
primitive type Int32   <: Signed   32 end
primitive type UInt32  <: Unsigned 32 end
primitive type Int64   <: Signed   64 end
primitive type UInt64  <: Unsigned 64 end
primitive type Int128  <: Signed   128 end
primitive type UInt128 <: Unsigned 128 end
\end{minted}



Las sintaxis generales para la declaración de un tipo primitivo son:




\begin{lstlisting}
primitive type «name» «bits» end
primitive type «name» <: «supertype» «bits» end
\end{lstlisting}



\texttt{«bits»} indica cuánta memoria requiere el tipo y \texttt{«name»} indica el nombre del nuevo tipo. Un tipo primitivo puede ser declarado opcionalmente como un subtipo de algún supertipo. Si se omite el supertipo, se asigna como supertipo por defecto el tipo \texttt{Any}. Por tanto, la declaración de \hyperlink{46725311238864537}{\texttt{Bool}} significa que un valor booleano consume 8 bits de almacenamiento, y que \hyperlink{8469131683393450448}{\texttt{Integer}} es su supertipo inmediato. Actualmente sólo se soportan tamaños que sea múltiplo de 8 bits. Por tanto, los valores booleanos, aunque sólo necesitan un bit, no puden ser declarados como menores de 8 bits.



Los tipos \hyperlink{46725311238864537}{\texttt{Bool}}, \hyperlink{5857518405103968275}{\texttt{Int8}} y \hyperlink{6609065134969660118}{\texttt{UInt8}} tienen representaciones idénticas: se trata de bloques de memoria de 8 bits. Como el sistema de tipos de Julia es nominativo, sin embargo, ellos no son intercambiables aunque tengan estructura idéntica. Otra diferencia fundamental entre ellos es que ellos tienen supertipos diferentes: \hyperlink{8469131683393450448}{\texttt{Integer}} es el supertipo directo de \hyperlink{46725311238864537}{\texttt{Bool}}, \hyperlink{14154866400772377486}{\texttt{Signed}} es el de \hyperlink{5857518405103968275}{\texttt{Int8}}, y \hyperlink{4780971278803506664}{\texttt{Unsigned}} es el de  \hyperlink{6609065134969660118}{\texttt{UInt8}}. Todas las demás diferencias entre  \hyperlink{46725311238864537}{\texttt{Bool}}, \hyperlink{5857518405103968275}{\texttt{Int8}}, y \hyperlink{6609065134969660118}{\texttt{UInt8}} son cuestiones de comportamiento  (la forma en la que las funciones son definidas para actuar cuando se pasan como argumentos objetos de estos tipos). Esta es la razón por la que es necesario un sistema de tipos nominativo: si la estructura determinara el tipo, que a su vez dicta el comportamiento, sería imposible hacer que los valores  \hyperlink{46725311238864537}{\texttt{Bool}} se comportaran de forma diferente a los \hyperlink{5857518405103968275}{\texttt{Int8}} o los \hyperlink{6609065134969660118}{\texttt{UInt8}}.



\hypertarget{2417174341544422883}{}


\section{Tipos Compuestos}



\href{https://en.wikipedia.org/wiki/Composite\_data\_type}{Los tipos compuestos} se llaman registros, estructuras (\emph{structs}) u objetos en distintos lenguajes. Un tipo compuesto es una colección de campos nombrados, una instancia de los cuales puede ser tratada como un único valor. En muchos lenguajes, los tiempos compuestos sos la única clase de tipos definidos por el usuario, y ellos son de lejos el tiempo definido por el usuario  que se usa mas comúnmente en el lenguaje Julia.



En el mundo de los lenguajes orientados a objetos tales como C++, Java, Python o Ruby, los tipos compuestos también tienen funciones asociadas a ellos, y esa combinación se denomina {\textquotedbl}objeto{\textquotedbl}. En los lenguajes orientados a objetos más puros, tales como Ruby o SmallTalk, todo los valores son objetos sean compuestos o no. En lenguajes orientados objetos menos puros incuyendo C++ y Java, algunos valores tales como los enteros no se consideran objetos, mientras que las instancias de los tipos compuestos definidos por el usuario son verdaderos objetos con métodos asociados. En Julia, todos los valores son objetos, pero no hay funciones a los objetos sobre los que se opera. Esto es necesario ya que Julia elige qué método de una función usar mediante despacho múltiple, lo que significa que cuando se selecciona un método se consideran los tipos de todos los argumentos de la función y no sólo el primero (ver la sección \hyperlink{15216268953652766477}{Métodos} para más información). Por tanto, sería inapropiado para las funciones {\textquotedbl}pertenecer{\textquotedbl} sólo a su primer argumento (el objeto que la posee). Organizar métodos en objetos función en lugar de tener bolsas de métodos nombrados {\textquotedbl}dentro{\textquotedbl} de cada objeto termina por ser un aspecto muy beneficioso de diseño del lenguaje.



Los tipos compuestos son introducidos por la palabra clave \texttt{struct} seguida por un bloque de nombres de campos, opcionalmente anotados con tipos usando el operador \texttt{::}




\begin{lstlisting}
julia> struct Foo
           bar
           baz::Int
           qux::Float64
       end
\end{lstlisting}



Los campos sin anotación de tipos tiene asignado \texttt{Any} como tipo por defecto, y pueden según esto almacenar cualquier tipo de valor.



Para crear nuevos objetos del tipo compuesto \texttt{Foo} se crean aplicando el tipo objeto \texttt{Foo} como una función con valores para sus campos:




\begin{lstlisting}
julia> foo = Foo("Hello, world.", 23, 1.5)
Foo("Hello, world.", 23, 1.5)

julia> typeof(foo)
Foo
\end{lstlisting}



Cuando un tipo es aplicado como una función es llamado \emph{constructor}. Hay dos constructores, denominados \emph{constructores por defecto} que se generan automáticamente al crear el tipo. Uno acepta cualquier argumento y llama a \hyperlink{1846942650946171605}{\texttt{convert()}} para convertirlos a los tipos de los campos, y el otro acepta argumentos que se corresponden exactamente a los tipos de los campos. La razón de que ambos métodos sean generados es que esto hace más sencillo añadir nuevas definiciones sin reemplazar inadvertidamente a un constructor por defecto.



Como el campo \texttt{bar} no está restringido en tipo, cualquier valor es válido. Sin embargo, el valor para \texttt{baz} debe ser convertible a \texttt{Int}:




\begin{lstlisting}
julia> Foo((), 23.5, 1)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int64}, ::Float64) at ./float.jl:679
 [2] Foo(::Tuple{}, ::Float64, ::Int64) at ./none:2
\end{lstlisting}



La función \texttt{fieldnames} devuelve una lista de los nombres de campos de un objeto:




\begin{lstlisting}
julia> fieldnames(foo)
3-element Array{Symbol,1}:
 :bar
 :baz
 :qux
\end{lstlisting}



Para acceder a los valores de los campos de un objeto compuesto puede usarse la notación tradicional \texttt{foo.bar}:




\begin{lstlisting}
julia> foo.bar
"Hello, world."

julia> foo.baz
23

julia> foo.qux
1.5
\end{lstlisting}



Los tipos compuestos declarados con \texttt{struct} son \emph{inmutables}, es decir, no pueden ser modificados después de su construcción. Esto puede parecer raro al principio, pero tiene varias ventajas:



\begin{itemize}
\item Puede ser más eficiciente. Algunos \texttt{struct} pueden ser empquetados eficientemente dentro de los arrays, y  en algunos casos el compilador es capaz de evitar asignar objetos inmutables completamente.


\item No es posible violar las invariantes proporcionadas por los contructores de tipo.


\item El código con objetos inmutables puede ser más sencillo de interpretar.

\end{itemize}


Un objeto inmutable puede contener objetos mutables, tales como arrays, como campos. Esos objetos contenidos permanecerán inmutables, sólo los cambos del objeto inmutable en sí no podrán ser cambiados para apuntar a objetos distintos. 



Cuando se requiera, los objetos compuestos mutables podrán ser declarados con la palabra clave \texttt{mutable struct}, lo que será discutido en la siguiente sección. 



Los tipos compuestos sin campos son \emph{singletons}, es decir, sólo puede haber una instancia de tales tipos:




\begin{minted}{jlcon}
julia> struct NoFields
       end

julia> NoFields() === NoFields()
true
\end{minted}



La función \texttt{===} confirma que las dos instancias construidas de \texttt{NoFields} son de hecho una y la misma. Los tipos \emph{singleton} se describirán en más detalle \hyperlink{647919389478144252}{posteriormente}.



Hay mucho más que decir sobre cómo se crean las instancias de los tipos compuestos, pero esta discusión depende de los \hyperlink{15542027490314302254}{Tipos Paramétricos} y de los \hyperlink{15216268953652766477}{Métodos}, y es suficientemente importante para ser tratada en su propia sección: \hyperlink{17317810227993044854}{Constructores}.



\hypertarget{4895133348259895821}{}


\section{Tipos Compuestos Mutables}



Si un tipo compuesto es declarado como \texttt{mutable struct} en lugar de como \texttt{struct}, sus instancias pueden ser modificadas:




\begin{lstlisting}
julia> mutable struct Bar
           baz
           qux::Float64
       end

julia> bar = Bar("Hello", 1.5);

julia> bar.qux = 2.0
2.0

julia> bar.baz = 1//2
1//2
\end{lstlisting}



Para soportar la mutación, tales objetos se alojan generalmente en el montón y tienen direcciones de memoria estables. Un objeto mutable es como un pequeño contenedor que podría almacenar distintos valores en el tiempo, y por tanto sólo puede ser identificado de forma confiable con su dirección. En contraste, una instancia de un tipo inmutable está asociada con valores de campos específicos - los valores de campos solos te dicen todo sobre el objeto. En decidir si hacer un tipo mutable, pregúntat si dos instanciasa con los mismos valores de campos tendrían que ser consideradas idénticas, o si ellas podrían necesitar cambiar independientemente con el tiempo. Si ellas fueran consideradas idénticas, el tipo probablemente debería ser inmutable. 



Para recapitular, dos propiedades esenciales definen la inmutabilidad en Julia:



\begin{itemize}
\item Un objeto con un tipo inmutable es pasado (tanto en instrucciones de asignación como en llamadas a función) mediante copia, mientras que un tipo mutable es pasado mediante referencia.


\item No está permitido modificar los campos de un tipo compuesto inmutable.

\end{itemize}


Es instructivo, particularmente para lectores cuyo background es C/C++, considerar por qué estas dos propiedades van juntas. Si fueran separadas, es decir, si los campos de los objetos pasados mediante copia pudieran ser modificados, entonces sería más difícil razonar sobre ciertas instancias de código genérico. Por ejemplo, supongamos que \texttt{x} es un argumento de función de un tipo abstracto, y supongamos que la función cambia un campo: \texttt{x.isprocessed = true}. Dependiendo de si \texttt{x}se pasa mediante copia o mediante referencia, esta instrucción puede alterar o no el argumento actual en la rutina que hace la llamada. Julia evita la posibilidad de crear funciones con efectos desconocidos en este escenario prohibiendo modificación de campos de objetos pasados mediante copia. 



\hypertarget{16169724683652759571}{}


\section{Tipos declarados}



Las tres clases de tipos discutidos en las tres secciones anteriores están muy relacionados. Ellos comparten las mismas propiedades clave:



\begin{itemize}
\item Ellos son declarados explícitamente.


\item Ellos tienen nombres.


\item Ellos tienen supertipos declarados explícitamente.


\item Ellos pueden tener parámeros.

\end{itemize}


Debido a estas propiedades compartidas, estos tipos son representados internamene  como instancias del mismo concepto, \texttt{DataType} , que es el tipo de cualquiera de estos tipos:




\begin{minted}{jlcon}
julia> typeof(Real)
DataType

julia> typeof(Int)
DataType
\end{minted}



Un \texttt{DataType} puede ser abstracto o concreto. Si es concreto, tiene un tamaño, disposición de almacenamiento y (opcionalmente) nombres de campos especificados. Por tanto, un tipo bits es un \texttt{DataType} con tamaño no nulo, pero sin nombres de campos. Un tipo compuesto es un \texttt{DataType} que tiene nombres de campos o es acío (tamaño cero).



Cada valor concreto en el sistema es una instancia de algún \texttt{DataType}.



\hypertarget{10212719512680497040}{}


\section{Uniones de Tipos}



Una unión de tipos es un tipo abstracto especial que incluye como objetos todas las instancias de alguno de sus tipos argumentos, construidos usando la función especial \texttt{Union}:




\begin{minted}{jlcon}
julia> IntOrString = Union{Int,AbstractString}
Union{AbstractString, Int64}

julia> 1 :: IntOrString
1

julia> "Hello!" :: IntOrString
"Hello!"

julia> 1.0 :: IntOrString
ERROR: TypeError: typeassert: expected Union{AbstractString, Int64}, got Float64
\end{minted}



Los compiladores de muchos lenguajes tienen una construcción unión interna para razonar sobre los tipos; Julia simplemente la pone a disposición del programador.



\hypertarget{15542027490314302254}{}


\section{Tipos Paramétricos}



Una característica importante y potente del sistema de tipos de Julia es que es paramétrico: los tipos pueden toomar parámetros, por lo que las declaraciones de tipo introducen de hecho un afamilia completa de nuevos tipos (uno por cada posible combinación de valores de parámetros). Hay muchos lenguajes que soportan alguna versión de la \href{https://en.wikipedia.org/wiki/Generic\_programming}{programación genérica}, donde las estructuras de datos y algoritmos para manipularlos pueden ser especificadas sin especificar los tipos exactos implicados. Por ejemplo, existe alguna forma de programación genérica en ML, Haskell, Ada, Eiffel, C++, Java, C\#, F\# y Scala, por nombrar unos pocos. Algunos de estos lenguajes soportan un verdadero polimorfismo paramétrico (Por ej., ML, Haskell, Scala) mientras otros soportan estilos de programación genérica \emph{ad-hoc}, basados en plantillas (Por eje., C++ y Java). Con tantas variedades diferentes de programación genérica y de tipos paramétricos en los distintos lenguajes, no queremos ni siquiera intentar comparar los tipos paramétricos de Julia a otros lenguajes, sino que nos centraremos en explicar el propio sistema de Julia. Notaremos, sin embargo, que como Julia es un lenguaje tipado dinámicamente y no necesita hacer todas las decisiones de tipos en tiempo de compilacíon, muchas dificultades tradicionales encontradas en los sistemas de tipos paramétricos estáticos pueden ser manejadas con relativa facilidad.



Todos los tipos declarados (la variedad \texttt{DataType})  pueden ser parametrizados, con la misma sintaxis en cada caso. Los discutiremos en el siguiente orden: primero tipos compuestos paramétricos, luego tipos abstractos paramétricos y por último tipos bits paramétricos.



\hypertarget{5928609471424031180}{}


\subsection{Tipos compuestos paramétricos}



Los parámetros de tipo se introducen inmediatamente después del nombre de tipo, rodeado por llaves:




\begin{lstlisting}
julia> struct Point{T}
           x::T
           y::T
       end
\end{lstlisting}



Esta declaración define un nuevo tipo paramétrico, \texttt{Point\{T\}}, que almacena dos coordenadas de tipo \texttt{T}. Uno podría preguntarse, ¿qué es \texttt{T}? Bien, este es precisamente la clave de los tipos paramétricos: puede ser cualquier tipo (o un valor de cualquier tipo bits, aunque en esta ocasión usado como un tipo, claramente). \texttt{Point\{Float64\}} es un tipo concreto equivalente al tipo definido reemplazando \texttt{T} en la definición de \texttt{Point} con \hyperlink{5027751419500983000}{\texttt{Float64}}. Por tanto, esta única  declaración declara un número de tipos ilimitado: \texttt{Point\{Float64\}}, \texttt{Point\{AbstractString\}}, \texttt{Point\{Int64\}}, etc. Cada uno de ellos es un tipo concreto usable: 




\begin{lstlisting}
julia> Point{Float64}
Point{Float64}

julia> Point{AbstractString}
Point{AbstractString}
\end{lstlisting}



El tipo \texttt{Point\{Float64\}} es un punto cuyas coordenadas son valores en punto flotante de 64-bits, mientras que el tipo \texttt{Point\{AbstractString\}} es un “punto” cuyas “coordenadas” son objetos \texttt{String} (see \hyperlink{5278796056388981234}{Strings}).



\texttt{Point} es en si mismo un tipo objeto válido también, que contiene todas las instancias \texttt{Point\{Float64\}}, \texttt{Point\{AbstractString\}}, etc. como subtipos:




\begin{lstlisting}
julia> Point{Float64} <: Point
true

julia> Point{AbstractString} <: Point
true
\end{lstlisting}



Otros tipos, por supuesto, no son subtipos de él:




\begin{lstlisting}
julia> Float64 <: Point
false

julia> AbstractString <: Point
false
\end{lstlisting}



Los tipos \texttt{Point} concretos con valores diferentes de \texttt{T} no son nunca subtipos uno de otro:




\begin{lstlisting}
julia> Point{Float64} <: Point{Int64}
false

julia> Point{Float64} <: Point{Real}
false
\end{lstlisting}



\begin{quote}
\textbf{Warning}

Este último punto es importante: \textbf{Incluso aunque \texttt{Float64 <: Real} no es cierto que \texttt{Point\{Float64\} <: Point\{Real\}}}. 

\end{quote}


En otras palabras, en términos de teoría de tipos, los parámetros de tipo de Julia son \emph{invariantes}, en lugar de ser \href{https://en.wikipedia.org/wiki/Covariance\_and\_contravariance\_\%28computer\_science\%29}{covariantes (o incluso contravariantes)}. Esto es por razones prácticas: aunque alguna instancia de \texttt{Point\{Float64\}} puede ser conceptualmente como una instancia de \texttt{Point\{Real\}}, los dos tipos tienen representaciones diferentes en memoria:



\begin{itemize}
\item Una instancia de \texttt{Point\{Float64\}} puede ser representada compactamente y eficientemente como un par   de valores de 64 bits inmediatos


\item Una instancia de \texttt{Point\{Real\}} debe ser capaz de alojar cualquier par de instancias de \hyperlink{6175959395021454412}{\texttt{Real}}. Como los  objetos son instancias de \texttt{Real} pueden ser de tamaño y estructura arbitrarios, en la práctica una instancia de \texttt{Point\{Real\}} debe ser representada como un par de punteros a objetos \texttt{Real} asignados individualmente.

\end{itemize}


La eficiencia ganada por ser capaz de almacenar objetos \texttt{Point\{Float64\}} con valores inmediatos es magnificada enormemente en el caso de arrays: un \texttt{Array\{Float64\}} puede almacenarse como un bloque contiguo de memoria de valores en punto flotante de 64 bits, mientras que un \texttt{Array\{Real\}} debe ser un array de punteros a objetos \hyperlink{6175959395021454412}{\texttt{Real}} asignados individualmente (que puede ser valores en punto flotante de 64 bits \href{https://en.wikipedia.org/wiki/Object\_type\_\%28object-oriented\_programming\%29\#Boxing}{envueltos (\emph{boxed})}, pero que también pueden ser objetos complejos, arbitrariamente grandes, que han sido declarados como implementaciones del tipo abstracto \texttt{Real}.



Como \texttt{Point\{Float64\}} no es un subtipo de \texttt{Point\{Real\}},  el siguiente método no puede ser aplicado a argumentos de tipo \texttt{Point\{Float64\}}:




\begin{minted}{julia}
function norm(p::Point{Real})
    sqrt(p.x^2 + p.y^2)
end
\end{minted}



Una forma correcta de definir un método que acepte todos los argumentos de tipo \texttt{Point\{T\}}, donde \texttt{T} es un subtipo de \hyperlink{6175959395021454412}{\texttt{Real}} es:




\begin{minted}{julia}
function norm(p::Point{<:Real})
    sqrt(p.x^2 + p.y^2)
end
\end{minted}



(Equivalentemente, uno podría definir \texttt{function norm\{T<:Real\}(p::Point\{T\})} o \texttt{function norm(p::Point\{T\} where T<:Real)}; ver \hyperlink{13494686645968204765}{tipos UnionAll}.)



Más ejemplos se discutirán después en \hyperlink{15216268953652766477}{Métodos}.



¿Cómo construye uno un objeto \texttt{Point}? Es posible definir constructores personalizados para tipos compuestos, que serán discutidos en detalle en el capítulo \hyperlink{17317810227993044854}{Constructores}, pero en ausencia de ninguna declaración especial de constructor, hay dos formas por defecto de crear nuevos objetos compuestos, uno en el que se dan explícitamente los parámetros de tipo y otro en el que ellos son implicados por los argumentos al objeto constructor.



Como el tipo \texttt{Point\{Float64\}} es un tipo concreto equivalente a \texttt{Point} declarado con \hyperlink{5027751419500983000}{\texttt{Float64}} en lugar de \texttt{T}, se puede aplicar como un constructor ede acuerdo a ésto:




\begin{lstlisting}
julia> Point{Float64}(1.0, 2.0)
Point{Float64}(1.0, 2.0)

julia> typeof(ans)
Point{Float64}
\end{lstlisting}



Para el constructor por defecto, debe proporcionarse exactamente un argumento por cada campo: 




\begin{lstlisting}
julia> Point{Float64}(1.0)
ERROR: MethodError: Cannot `convert` an object of type Float64 to an object of type Point{Float64}
This may have arisen from a call to the constructor Point{Float64}(...),
since type constructors fall back to convert methods.
Stacktrace:
 [1] Point{Float64}(::Float64) at ./sysimg.jl:77

julia> Point{Float64}(1.0,2.0,3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
\end{lstlisting}



Sólo se ha generado un constructor por defecto para tipos paramétricos, ya que sobreescribirlo no es posible. Este constructor acepta cualquier argumento y los convierte a los tipos de los campos.



En muchos casos es redundante proporcionar el tipo del objeto \texttt{Point} que uno quiere construir, ya que los tipos de los argumentos en la llamada al constructor ya proporcionan la información de tipos de forma implícita. Por esta razón, también podemos aplicar el propio \texttt{Point} como un constructor, dado que el valor implícito del parámetro de tipo \texttt{T} no es ambiguo:




\begin{lstlisting}
julia> Point(1.0,2.0)
Point{Float64}(1.0, 2.0)

julia> typeof(ans)
Point{Float64}

julia> Point(1,2)
Point{Int64}(1, 2)

julia> typeof(ans)
Point{Int64}
\end{lstlisting}



En el caso de \texttt{Point} es implicado sin ambigüedad si y sólo si los dos argumentos a \texttt{Point} tienen el mismo tipo. Cuando este no es el caso, el constructor fallará con un \hyperlink{14644228586476494020}{\texttt{MethodError}}:




\begin{lstlisting}
julia> Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T, !Matched::T) where T at none:2
\end{lstlisting}



Los método constructores para manejar apropiadamente estos casos mixtos pueden ser definidos, pero esto no será discutido hasta después en \hyperlink{17317810227993044854}{Constructores}.



\hypertarget{15009395514802137859}{}


\subsection{Tipos Abstractos Paramétricos}



Las declaraciones de tipos abstractos paramétricos declaran una colección de tipos abstractos, de la misma forma:




\begin{lstlisting}
julia> abstract type Pointy{T} end
\end{lstlisting}



Con esta declaración, \texttt{Pointy\{T\}} es un tipo abstracto distinto para cada tipo o valor entero de \texttt{T}. Como con los tipos compuestos paramétricos, cada una de tales instancias es un subtipo de \texttt{Pointy}:




\begin{lstlisting}
julia> Pointy{Int64} <: Pointy
true

julia> Pointy{1} <: Pointy
true
\end{lstlisting}



Los tipos abstractos paramétricos son invariantes, tal como los tipos compuestos paramétricos:




\begin{lstlisting}
julia> Pointy{Float64} <: Pointy{Real}
false

julia> Pointy{Real} <: Pointy{Float64}
false
\end{lstlisting}



La notación \texttt{Pointy\{<:Real\}} puede usarse para expresar el análogo Julia de un tipo \emph{covariante}, mientras que  \texttt{Pointy\{>:Int\}} es el análogo de un tipo \emph{contravariante}, pero técnicamente estos representan \emph{conjuntos} de tipos (ver \hyperlink{13494686645968204765}{tipos UnionAll}).




\begin{lstlisting}
julia> Pointy{Float64} <: Pointy{<:Real}
true

julia> Pointy{Real} <: Pointy{>:Int}
true
\end{lstlisting}



De la misma manera que los tipos abstractos antiguos sirven para crear una jerarquía útil de tipos sobre tipos concretos, los tipos abstractos paramétricos tienen el mismo propósito con respecto a los tipos compuestos paramétricos. Podríamos, por ejemplo, haber declarado \texttt{Point \{T\}} ser un subtipo de \texttt{Pointy \{T\}} de la siguiente manera:




\begin{lstlisting}
julia> struct Point{T} <: Pointy{T}
           x::T
           y::T
       end
\end{lstlisting}



Dada tal declaración, para cada elección de \texttt{T} tenemos \texttt{Point\{T\}} como un subtipo de \texttt{Pointy\{T\}}:




\begin{lstlisting}
julia> Point{Float64} <: Pointy{Float64}
true

julia> Point{Real} <: Pointy{Real}
true

julia> Point{AbstractString} <: Pointy{AbstractString}
true
\end{lstlisting}



Esta relación es también invariante:




\begin{lstlisting}
julia> Point{Float64} <: Pointy{Real}
false

julia> Point{Float64} <: Pointy{<:Real}
true
\end{lstlisting}



¿A qué propósito sirven los tipos abstractos paramétricos como \texttt{Pointy}? Considere si creamos una implementación tipo punto que sólo necesita una coordenada debido a que el punto se encuentra en la diagonal del primer cuadrante (\emph{y = x}):




\begin{lstlisting}
julia> struct DiagPoint{T} <: Pointy{T}
           x::T
       end
\end{lstlisting}



Ahora tanto \texttt{Point\{Float64\}} como \texttt{DiagPoint\{Float64\}} son implementaciones de la abstracción \texttt{Pointy\{Float64\}} y, similarmente, para cada otra posible elección del tipo \texttt{T}. Esto permite programar a un interfaz común compartido por todos los objetos \texttt{Pointy}, implementedo tanto por \texttt{Point}como por \texttt{DiagPoint}. Esto no puede ser totalmente demostrado, sin embargo, hasta que no hayamos introducidos los métodos y el despacho en la siguiente sección, \hyperlink{15216268953652766477}{Methods}.



Hay situaciones donde puede no tener sentido para los parámetros de tipo varíen libremente sobre todos los tipos posibles. En tales situaciones, uno puede restringir el rango de \texttt{T} como aquí:




\begin{lstlisting}
julia> abstract type Pointy{T<:Real} end
\end{lstlisting}



Hay situaciones donde puede no tener sentido para los parámetros de tipo varíen libremente sobre todos los tipos posibles. En tales situaciones, uno puede restringir el rango de \texttt{T} como aquí:




\begin{lstlisting}
julia> Pointy{Float64}
Pointy{Float64}

julia> Pointy{Real}
Pointy{Real}

julia> Pointy{AbstractString}
ERROR: TypeError: Pointy: in T, expected T<:Real, got Type{AbstractString}

julia> Pointy{1}
ERROR: TypeError: Pointy: in T, expected T<:Real, got Int64
\end{lstlisting}



Los parámetros de tipo para tipos compuestos paramétricos pueden ser restringidos de la misma manera:




\begin{minted}{julia}
struct Point{T<:Real} <: Pointy{T}
    x::T
    y::T
end
\end{minted}



Para dar un ejemplo del mundo real de cómo toda esta maquinaria de tipos paramétricos puede ser útil, he aquí la definición actual del tipo inmutable \texttt{Rational} \hyperlink{8304566144531167610}{\texttt{Rational}} de Julia (omitiendo el constructor por simplicidad), que representa una relacíon exacta de enteros:




\begin{minted}{julia}
struct Rational{T<:Integer} <: Real
    num::T
    den::T
end
\end{minted}



Sólo tiene sentido tomar relaciones de valores enteros, por lo que el tipo parametrizado \texttt{T} está restringido a ser un subtipo de \hyperlink{8469131683393450448}{\texttt{Integer}}, y una razón de enteros representa un valor sobre la línea de los números reales, por lo que cualquier \hyperlink{8304566144531167610}{\texttt{Rational}} es una instancia de la abstracción \hyperlink{6175959395021454412}{\texttt{Real}}.



\hypertarget{7674291003818157189}{}


\subsection{Tipos tupla}



Las tuplas son una abstracción de los argumentos de una función (sin la propia función). Los aspectos salientes de los argumentos de una funcíon son su orden y sus tipos. Por tanto, un tipo tupla es muy similar a un tipo inmutable parametrizado donde cada parámetro es el tupo de un campo. Por ejemplo, un tipo tupla de dos elementos se parece al siguiente tipo inmutable:




\begin{minted}{julia}
struct Tuple2{A,B}
    a::A
    b::B
end
\end{minted}



Sin embargo, hay tres diferencias clave:



\begin{itemize}
\item Los tipos tupla pueden tener cualquier número de parámetros.


\item Los tipos tupla son \emph{covariantes} en sus parámetros: \texttt{Tuple\{Int\}} es un subtipo of \texttt{Tuple\{Any\}}. Por tanto \texttt{Tuple\{Any\}} es considerado un tipo abstracto, y los tipos tupla son solo concretos si sus parámetros lo son.


\item Las tuplas no tienen nombres de campo; los campos son sólo accedidos mediante índices.

\end{itemize}


Los valores tupla son escritos con paréntesis y comas. Cuando se construye una tupla, se genera un tipo tupla apropiado bajo demanda:




\begin{minted}{jlcon}
julia> typeof((1,"foo",2.5))
Tuple{Int64,String,Float64}
\end{minted}



Note las implicaciones de  covarianza:




\begin{minted}{jlcon}
julia> Tuple{Int,AbstractString} <: Tuple{Real,Any}
true

julia> Tuple{Int,AbstractString} <: Tuple{Real,Real}
false

julia> Tuple{Int,AbstractString} <: Tuple{Real,}
false
\end{minted}



Intuitivamente, esto corresponde al tipo de los argumentos de una función, siendo un subtipo de la signatura de la función (cuando la signatura se corresponde).



\hypertarget{15826219568905025850}{}


\subsection{Tipos Tupla Vararg}



El último parámetro de un tipo tupla puede ser el tipo especial \texttt{Vararg}, que denota cualquier número de elementos arrastrados:




\begin{minted}{jlcon}
julia> mytupletype = Tuple{AbstractString,Vararg{Int}}
Tuple{AbstractString,Vararg{Int64,N} where N}

julia> isa(("1",), mytupletype)
true

julia> isa(("1",1), mytupletype)
true

julia> isa(("1",1,2), mytupletype)
true

julia> isa(("1",1,2,3.0), mytupletype)
false
\end{minted}



Notese que \texttt{Varags\{T\}} corresponde a cero o más elementos del tipo \texttt{T}. Los tipos tupla vararg se usan para representar los argumentos aceptados por los métodos vararg (ver \hyperlink{4426560717438156432}{Funciones Vararg}).



El tipo \texttt{Vararg\{T,N\}} se corresponde a exactamente \texttt{N} elementos de tipo \texttt{T}. \texttt{NTuple\{N,T\}} es un alias conveniente para \texttt{Tuple\{Vararg\{T,N\}\}}, es decir, un tipo tupla conteniendo exactamente \texttt{N} elementos de tipo \texttt{T}.



\hypertarget{647919389478144252}{}


\subsubsection{Tipos Singleton}



Hay una clase especial de tipo paramétrico abstracto que hay que mencionar aquí: los tipos singleton. Para cada tipo \texttt{T} el tipo singleton \texttt{Type\{T\}} es un tipo abstracto cuya única instancia es el objeto \texttt{T}.  Como la definición es un poco difícil de analizar, echemos un vistazo a los siguientes ejemplos:




\begin{minted}{jlcon}
julia> isa(Float64, Type{Float64})
true

julia> isa(Real, Type{Float64})
false

julia> isa(Real, Type{Real})
true

julia> isa(Float64, Type{Real})
false
\end{minted}



En otras palabras, \hyperlink{7066325108767373297}{\texttt{isa(A,Type\{B\})}} es \texttt{true} si y solo si \texttt{A} y \texttt{B} son el mismo objeto y este objeto es un tipo. Sin el parámetro, \texttt{Type} es simplemente un tipo abstracto que tiene como instancias todos los objetos tipo, incluyendo, por supuesto, los tipos singleton:




\begin{minted}{jlcon}
julia> isa(Type{Float64}, Type)
true

julia> isa(Float64, Type)
true

julia> isa(Real, Type)
true
\end{minted}



Cualquier objeto que no es un tipo no es una instancia de \texttt{Type}:




\begin{minted}{jlcon}
julia> isa(1, Type)
false

julia> isa("foo", Type)
false
\end{minted}



Hasta que discutamos loa \hyperlink{15542027490314302254}{métodos paramétricos} y las \hyperlink{10686378388163930476}{conversiones}, , es difícil explicar la utilidad de la construcción tipo singleton, pero abreviando, permite a uno especializar el comportamiento de una función sobre \emph{valores} de un tipo específico. Esto es útil para escribir métodos (especialmente paramétricos) cuy ocomportamiento dependa de un tipo que es dado como un argumento explícito en lugar de implicado por el tipo de un o de sus argumentos.



Unos pocos lenguajes de programación tienen tipos singleton, incluyendo Haskell, Scala y Ruby. En uso general, el término {\textquotedbl}tipo singleton{\textquotedbl} se refiere a un tipo cuya única instancia es un solo valor. Este significado se aplicaa a los tipos singleton de Julia, pero con la advertencia de que sólo los objetos tipo tienen tipos singleton.



\hypertarget{2635909473726897364}{}


\subsection{Tipos primitivos paramétricos}



Los tipos bits pueden ser declarados paramétricamente. Por ejemplo, los punteros son reprentados como tipos bits encajados que serían declarados en Julia de esta forma:




\begin{minted}{julia}
# 32-bit system:
primitive type Ptr{T} 32 end

# 64-bit system:
primitive type Ptr{T} 64 end
\end{minted}



La característica ligeramente extraña de estas declaraciones comparadas con los tipos compuestos paramétricos típicos es que el parámetro de tipo \texttt{T} no se usa en la definición del propio tipo (es justo un \emph{tag} abstracto, esencialmente definiendo una familia entera de tipos con idéntica estructura, diferenciada sólo por su parámetro de tipo. Por tanto \texttt{Ptr\{Float\}} y \texttt{Ptr\{Int64\}} son tipos distintos, incluso auntque ellos tengan representaciones idénticas. Y, por supuesto, todos los tipos puntero específicos son subtipo del tipo sombrilla \texttt{Ptr}:




\begin{minted}{jlcon}
julia> Ptr{Float64} <: Ptr
true

julia> Ptr{Int64} <: Ptr
true
\end{minted}



\hypertarget{13494686645968204765}{}


\section{Tipos UnionAll}



Hemos dicho que un tipo paramétrico como \texttt{Ptr} actúa como un supertipo de todas sus instancias (Ptr\{Int64\} etc.). ¿Cómo funciona esto? \texttt{Ptr} en si mismo no puede ser un tipo normal, ya que sin saber el tipo de los datos referenciados el tipo claramente no puede ser usado para operaciones en memoria. La respuesta es que \texttt{Ptr} (u otros tipos paramétricos como \texttt{Array}) es una clase diferente de tipo llamado \texttt{UnionAll}. Tal tipo expresa la unión iterada de tipos para todos los valores de algún parámetro.



Los tipos \texttt{UnionAll}suelen ser escritos usando la palabra clave \texttt{where}. Por ejemplo, \texttt{Ptr} podría ser escrito de forma más exacta como \texttt{Ptr\{T\} where T}, lo que significa que todos los valores cuyo tipo es \texttt{Ptr\{T\}} para algún valor de \texttt{T}. En este contexto, el parámetro \texttt{T} suele llamarse también una {\textquotedbl}variable tipo{\textquotedbl}, ya que es como una variable que se extiende sobre los tipos. Cada \texttt{where} introduce una sola variable tipo, por lo que estas expresiones están anidadas para tipos con múltiples parámetros, por ejemplo \texttt{Array\{T,N\} where N where T}.



La sintaxis de la aplicación de tipo \texttt{A\{B, C\}} requiere que \texttt{A} sea un tipo \texttt{UnionAll} y primero sustituye \texttt{B}  por la variable de tipo más externa en \texttt{A}. Se espera que el resultado sea otro tipo \texttt{UnionAll} en el cuál \texttt{C} será sustituido. Por tanto, \texttt{A\{B,C\}} es equivalente a  \texttt{A\{B\}\{C\}}. Esto explica por qué es posible instanciar parcialmente un tipo, como en \texttt{Array\{Float64\}}: El primer valor de parámetro ha sido fijado, pero el segundo aún se extiende sobre todos os posibles valores. Usando explícitamente la sintaxis \texttt{where}, cualquier subconjunto de parámetros puede ser fijado. Por ejemplo, el tipo de todos los arrays unidimensionales puede ser escrito como \texttt{Array\{T,1\} where T}.



Las variables de tipo pueden ser restringidas con relaciones de subtipos. \texttt{Array\{T\} where T<:Integer} se refiere a todos los arrays cuyo elemento de tipo es alguna clase de \hyperlink{8469131683393450448}{\texttt{Integer}}. La sintaxis \texttt{Array\{<:Integer\}} es una abreviatura conveniente para \texttt{Array\{T\} where T<:Integer}. Las variables tipo pueden tener tanto límites superiores como inferiores. \texttt{Array\{T\} where Int<:T<:Number} se refiere a todos los arrays de \hyperlink{1990584313715697055}{\texttt{Number}}s que son capaces de contener \texttt{Int}s (dado que T debe ser al menos tan grande como \texttt{Int}). La sintaxis \texttt{where T>:Int} también funciona para especificar sólo el límite inferior de una variable de tipo, y \texttt{Array\{>:Int\}} es  equivalente a \texttt{Array\{T\} where T>:Int}.



En el caso de expresiones \texttt{where} anidadas, los límites de la variable de tipo  pueden referirse a las variables de tipo más externas. Por ejemplo, \texttt{Tuple\{T,Array\{S\}\} where S<:AbstractArray\{T\} where T<:Real} se refiere a dos tuplas cuyo primer elemento es algo \hyperlink{6175959395021454412}{\texttt{Real}} y cuyo segundo elemento es un \texttt{Array} de cualquier clase cuyo tipo de elemento contenga el tipo del primero elmento de la tupla.



La palabra clave \texttt{where} en si misma puede ser anidada dentro de una declaración más compleja. Por ejemplo, considere los dos tipos creados por las siguientes declaraciones:




\begin{minted}{jlcon}
julia> const T1 = Array{Array{T,1} where T, 1}
Array{Array{T,1} where T,1}

julia> const T2 = Array{Array{T,1}, 1} where T
Array{Array{T,1},1} where T
\end{minted}



El tipo \texttt{T1} define un array unidimensional de arrays unidimensionales; cada uno de los arrays internos consta de objetos del mismo tipo, pero este tipo puede variar de un array interno al siguiente. Por otra parte, el tipo \texttt{T2} define un array unidimensional de arrays unidimensionales de manera que los arrays internos tienen todos el mismo tipo. Notese que \texttt{T2} es un tipo abstracto, es decir, \texttt{Array\{Array\{Int,1\},1\} <: T2}, mientras que \texttt{T1} es un tipo concreto. Como consecuencia, \texttt{T1} puede ser construido con un constructor de cero argumentos \texttt{a=T1()} pero \texttt{T2} no puede.



Hay una sintaxis conveniente para nombrar tales tipos, similar a la forma corta de la sintaxis de definición de función:




\begin{minted}{julia}
Vector{T} = Array{T,1}
\end{minted}



Esto es equivalente a const Vector = Array\{T,1\} where T. Escribir Vector\{Float64\} es equivalente a escribir Array\{Float64,1\}, y el tipo paraguas Vector tiene como instancias todos los objetos Array donde el segundo parámetro (el número de dimensiones del array) es uno, sin importar cuál es el tipo del elemento. En lenguajes donde los tipos paramétricos deben siempre ser especificados por completo, esto no suele ser de ayuda, pero en Julia, esto permite a uno escribir justo Vector para el tipo abstract incluyendo arrays densos unidimensionales de cualquier tipo de elementos.



\hypertarget{10156620306053906957}{}


\section{Aliases de Tipos}



Algunas veces es conveniente introducir un nuevo nombre para un tipo ya expresable. Para tales ocasiones, Julia proporciona el mecanismo \texttt{typealias}. Por ejemplo, \texttt{UInt} es un alias de \hyperlink{8690996847580776341}{\texttt{UInt32}} o \hyperlink{5500998675195555601}{\texttt{UInt64}} dependiendo de los punteros de tamaño del sistema:




\begin{minted}{jlcon}
# 32-bit system:
julia> UInt
UInt32

# 64-bit system:
julia> UInt
UInt64
\end{minted}



Esto se consigue via el siguiente código en \texttt{base/boot.jl}:




\begin{minted}{julia}
if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end
\end{minted}



Por supuesto, esto depende de a qué representa el alias \texttt{Int} si a \hyperlink{10103694114785108551}{\texttt{Int32}} o a \hyperlink{7720564657383125058}{\texttt{Int64}}.



(Note que, a diferencia de \texttt{Int}, \texttt{Float} no existe como un alias de tipo para un tamaño específico de \hyperlink{11465394427882483091}{\texttt{AbstractFloat}}. A diferencia de con los registros enteros, los tamaños de los registros en punto flotante están especificados por el estándar IEEE-754 standard. Mientras que el tamaño de \texttt{Int} refleja el tamaño de un puntero nativo de esta máquina.)



\hypertarget{6968392973243987628}{}


\section{Operaciones sobre tipos}



Como los tipos en Julia son objetos en sí mismos, las funcoines ordinarias pueden operar sobre ellos. Algunas funciones que son particularmente útiles para trabajar con o explorar tipos han sido ya introducidas. Por ejemplo, el operador \texttt{<:} que indica si el operando a su izquierda es un subtipo del operando a su derecha.



La función \hyperlink{7066325108767373297}{\texttt{isa}} comprueba si un objeto es de un tipo dado y devuelve \texttt{true} o \texttt{false}:




\begin{minted}{jlcon}
julia> isa(1, Int)
true

julia> isa(1, AbstractFloat)
false
\end{minted}



La función \hyperlink{13440452181855594120}{\texttt{typeof()}} , ya usada a través del manual en ejemplos, devuelve el tupo de su argumento. Como, con se notó anteriormente, los tipos son objetos, ellos también tienen tipos, y podemos preguntar cuáles son sus tipos:




\begin{minted}{jlcon}
julia> typeof(Rational{Int})
DataType

julia> typeof(Union{Real,Float64,Rational})
DataType

julia> typeof(Union{Real,String})
Union
\end{minted}



¿Qué pasa si repetimos el proceso? ¿Cuál es el tipo de un tipo de un tipo? Como sucede, los tipos son todos valores compuestos y por tanto todos tendrán un tipo de \texttt{DataType}:




\begin{minted}{jlcon}
julia> typeof(DataType)
DataType

julia> typeof(Union)
DataType
\end{minted}



\texttt{DataType} is its own type.



Otra operación que se aplica a algunos tipos es  \hyperlink{12192788431675298651}{\texttt{supertype()}}, que revela el supertipo de un tipo. Sólo los tipos declarados (\texttt{DataType}) tienen supertipos no ambiguos:




\begin{minted}{jlcon}
julia> supertype(Float64)
AbstractFloat

julia> supertype(Number)
Any

julia> supertype(AbstractString)
Any

julia> supertype(Any)
Any
\end{minted}



Si aplicamos \hyperlink{12192788431675298651}{\texttt{supertype()}} a otros objetos tipo (u objetos no tipo) se lanzará un \hyperlink{14644228586476494020}{\texttt{MethodError}}:




\begin{minted}{jlcon}
julia> supertype(Union{Float64,Int64})
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
Closest candidates are:
  supertype(!Matched::DataType) at operators.jl:41
  supertype(!Matched::UnionAll) at operators.jl:46
\end{minted}



\hypertarget{11661150833581032996}{}


\section{Custom pretty-printing}



Frecuentemente, uno quiere personalizar cómo se mostrarán las instancias de un tipo. Esto se consigue sobrecargando la función \hyperlink{14071376285304310153}{\texttt{show()}}. Por ejemplo, supongamos que definimos un tipo para representar número complejos en forma polar:




\begin{lstlisting}
julia> struct Polar{T<:Real} <: Number
           r::T
           Θ::T
       end

julia> Polar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)
Polar
\end{lstlisting}



Aquí, hemos añadido una función constructor personalizado para que pueda tomar argumentos de distinto tipos \hyperlink{6175959395021454412}{\texttt{Real}} y los promocione a un tipo común (ver \hyperlink{17317810227993044854}{Constructores} y \hyperlink{10686378388163930476}{Conversión y Promoción}). (Por supuesto, tendríamos que definir montones de otros métodos también, para hacer que actíe como un \hyperlink{1990584313715697055}{\texttt{Number}}, por ejemplo, \texttt{+}, \texttt{*}, \texttt{one}, \texttt{zero}, reglas de promoción y otras cosas). Por defecto, las instancias de este tipo se muestran de forma bastante simple, con información sobre el nombre del tipo y los valores de los campos, como por ejemplo en  \texttt{Polar\{Float64\}(3.0,4.0)}.



Si en lugar de usar este modo de presentacin preferimos que su presentación sea \texttt{3.0 * exp(4.0im)}, hay que definir el siguiente método para que imprima el objeto a un objeto de salida \texttt{io}dado (que representa un fichero, terminal, buffer, etc.; ver \hyperlink{12120385195625176605}{Networking and Streams}):




\begin{lstlisting}
julia> Base.show(io::IO, z::Polar) = print(io, z.r, " * exp(", z.Θ, "im)")
\end{lstlisting}



Es posible un control de grano más fino sobre la visualizacin de los objetos \texttt{Polar}. En particular, algunas veces uno desea un formato de impresión detallado multilínea, utilizado para mostrar un solo objeto en REPL y otros entornos interactivos, y también un formato de línea única más compacto utilizado para [\texttt{print ()}] @ref) o para mostrar el objeto como parte de otro objeto (por ejemplo, en una matriz). Aunque de forma predeterminada se llama a la función \texttt{show (io, z)} en ambos casos, puede definir un formato multilínea \emph{diferente} para mostrar un objeto sobrecargando una forma de tres argumentos de \texttt{show} que toma el tipo MIME \texttt{text/plain} como su segundo argumento (consulte \hyperlink{7442676307456961159}{E/S multimedia}), por ejemplo:




\begin{lstlisting}
julia> Base.show{T}(io::IO, ::MIME"text/plain", z::Polar{T}) =
           print(io, "Polar{$T} complex number:\n   ", z)
\end{lstlisting}



(Note que \texttt{print(..., z)} aquí invocará al método con dos argumentos \texttt{show(io, z)}). Esto dará como resultado:




\begin{lstlisting}
julia> Polar(3, 4.0)
Polar{Float64} complex number:
   3.0 * exp(4.0im)

julia> [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Array{Polar{Float64},1}:
 3.0 * exp(4.0im)
 4.0 * exp(5.3im)
\end{lstlisting}



donde se sigue utilizando la forma de línea \texttt{show(io, z)} para un array de valores  \texttt{Polar}. Técnicamente, el REPL llama a  \texttt{display(z)} para mostrar el resultado de ejecutar una línea que por defecto es \texttt{show (STDOUT, MIME ({\textquotedbl} text / plain {\textquotedbl}), z)},  que a su vez por defecto es \texttt{show (STDOUT, z)}, pero debe \emph{no} definir nuevos métodos \hyperlink{12073120410747960438}{\texttt{display()}} a menos que esté definiendo un nuevo controlador de pantalla multimedia (consulte \hyperlink{7442676307456961159}{E/S multimedia}).



Además, también puede definir métodos \texttt{show} para otros tipos MIME para permitir una visualización más rica (HTML, imágenes, etc.) de los objetos en entornos que lo admitan (por ejemplo, IJulia). Por ejemplo, podemos definir la visualización HTML formateada de objetos \texttt{Polar}, con superíndices y cursiva, a través de:




\begin{lstlisting}
julia> Base.show{T}(io::IO, ::MIME"text/html", z::Polar{T}) =
           println(io, "<code>Polar{$T}</code> complex number: ",
                   z.r, " <i>e</i><sup>", z.Θ, " <i>i</i></sup>")
\end{lstlisting}



Un objeto \texttt{Polar} se mostrará entonces automáticament usando HtML en un entorno que soporte pantallas HTML, pero podemos llamar a la función \texttt{show} manualmente para obtener una salida HTML si lo deseamos:




\begin{lstlisting}
julia> show(STDOUT, "text/html", Polar(3.0,4.0))
<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup>
\end{lstlisting}





\hypertarget{10522953672803278470}{}


\section{{\textquotedbl}Valores tipo{\textquotedbl}}



En Julia uno no puede despachar sobre un \emph{valor}  tal como \texttt{true} o \texttt{false}. Sin embargo, se se puede despachar sobre tipos paramétricos, y Julia  permite incluir valores {\textquotedbl}plain bits{\textquotedbl} (tipos, símbolos, enteros, números en punto flotante, tuplas, etc.) como parámetros de tipo. Un ejemplo común es el parámetro de dimensionalidad en \texttt{Array\{T,N\}}, donde \texttt{T} es un tipo (por ejemplo,  \hyperlink{5027751419500983000}{\texttt{Float64}}) pero \texttt{N} es un \texttt{Int}.



Podemos crear nuestros propio tipos personalizados que tomen valores como parámetros, y usarlos para controlar el despacho de los tipos personalizados. A modo de ilustración de esta idea, introduzcamos un tipo paramétrico, \texttt{Val\{T\}} que sirve como una forma tradicional de explotar esta técnica para casos donde tu no necesitas una jerarquía más elaborada.



\texttt{Val} es definida como:




\begin{lstlisting}
julia> struct Val{T}
       end
\end{lstlisting}



No hay más implementaciones de \texttt{Val} que esta. Algunas funciones en la librería estándar de Julia aceptan los tipos \texttt{Val} como argumentos, y uno también puede usarlos para escribir sus propias funciones. Por ejemplo:




\begin{lstlisting}
julia> firstlast(::Type{Val{true}}) = "First"
firstlast (generic function with 1 method)

julia> firstlast(::Type{Val{false}}) = "Last"
firstlast (generic function with 2 methods)

julia> firstlast(Val{true})
"First"

julia> firstlast(Val{false})
"Last"
\end{lstlisting}



Por consistencia con Julia, el sitio de llamada debería siempre pasar un tipo \texttt{Val} en lugar de crear una instancia, por ejemplo, usar \texttt{foo(Val\{:bar\})} en lugar de \texttt{foo(Val\{:bar\}())}.



Vale la pena señalar que es extremadamente sencillo usar mal los tipos {\textquotedbl}valor{\textquotedbl} paramétricos, incluyendo \texttt{Val}; en caso desfavorables, tu puedes fácilmente acabar haciendo el rendimiento de tu código mucho \emph{peor}. En particular, tu nunca tendrás que querer escribir código actual como ilustramos anteriormente. Para má información sobre el uso apropiado de \texttt{Val} consulte por fabor la discusión más extensa en los \hyperlink{3908315974291496321}{consejos de rendimiento}.



\hypertarget{6093361083853962389}{}


\section{Tipos \texttt{Nullable}: representando valores perdidos}



En muchas situaciones, uno necesita interactuar con un valor de tipo \texttt{T} que puede o no existir. Para manejar estas situaciones, Julia proporciona un tipo paramétrico denominado \hyperlink{2208920129454296646}{\texttt{Nullable\{T\}}} que puede ser pensado como un tipo contenedor especializado que puede contener cero o un valores. \texttt{Nullable\{T\}} proporciona una interfaz mínima diseñada para asegurar qué interacciones con valores perdidos son seguras. En la actualidad, la interfaz consiste en varias posibles interacciones:



\begin{itemize}
\item Construir un objeto \texttt{Nullable}.


\item Comprobar si un objeto \texttt{Nullable} tiene un valor perdido.


\item Acceder al valor de un objeto \texttt{Nullable} con la garantía de que se lanzará una \hyperlink{3710635130313494548}{\texttt{NullException}} si el valor del objeto está perdido.


\item Acceder al valor de un objeto \texttt{Nullable} con una garantía de que el valor por defecto del tipo \texttt{T} será devuelto  si el valor del objeto se pierde.


\item Realizar una operación sobre el valor (si existe) de un objeto \texttt{Nullable}, obteniendo un resultado\texttt{Nullable}.  El resultado faltará si falta el valor original.


\item Realizar una prueba sobre el valor (si existe) de un objeto \texttt{Nullable}, obteniendo un resultado que será perdido si faltaba el\texttt{Nullable} o si la prueba falla.


\item Realizar operaciones generales en objetos individuales \texttt{Nullable}, propagando los datos faltantes.

\end{itemize}


\hypertarget{11602195311361491084}{}


\subsection{Construyendo objetos \texttt{Nullable}}



Para construir un objeto representando un valor perdido de tipo \texttt{T}, use la siguiente función `Nullable\{T\}():




\begin{minted}{jlcon}
julia> x1 = Nullable{Int64}()
Nullable{Int64}()

julia> x2 = Nullable{Float64}()
Nullable{Float64}()

julia> x3 = Nullable{Vector{Int64}}()
Nullable{Array{Int64,1}}()
\end{minted}



Para construir un objeto representando un valor no perdido de tipo \texttt{T}, use la función \texttt{Nullable(x::T)}:




\begin{minted}{jlcon}
julia> x1 = Nullable(1)
Nullable{Int64}(1)

julia> x2 = Nullable(1.0)
Nullable{Float64}(1.0)

julia> x3 = Nullable([1, 2, 3])
Nullable{Array{Int64,1}}([1, 2, 3])
\end{minted}



Note que la distinción clave entre estas dos formas de construir un objeto \texttt{Nullable}: en un estilo, tu proporcionas un tipo, \texttt{T} como un parámetro a función; en el otro estilo, tu proporcionas un solo valor de tipo \texttt{T} como argumento.



\hypertarget{16356170225016189705}{}


\subsection{Comprobar si un objeto \texttt{Nullable} tiene un valor}



Puedes comprobbar si un objeto \texttt{Nullable} tiene algún valor usando \hyperlink{16547052476421706505}{\texttt{isnull()}}:




\begin{minted}{jlcon}
julia> isnull(Nullable{Float64}())
true

julia> isnull(Nullable(0.0))
false
\end{minted}



\hypertarget{13422419078415638868}{}


\subsection{Acceder de forma segura al valor de un objeto \texttt{Nullable}}



Puedes acceder al valor de un objeto \texttt{Nullable} usando  \hyperlink{1600067245044904172}{\texttt{get()}}:




\begin{minted}{jlcon}
julia> get(Nullable{Float64}())
ERROR: NullException()
Stacktrace:
 [1] get(::Nullable{Float64}) at ./nullable.jl:92

julia> get(Nullable(1.0))
1.0
\end{minted}



Si el valor no está presente, como podría ser para un \texttt{Nullable\{Float64\}} se lanzará un error  \hyperlink{3710635130313494548}{\texttt{NullException}}. La naturaleza del error lanzado de la función \texttt{get()} asegur aque cualquier intento de acceder al valor perdido falle inmediatamente.



En los casos para los cuales existe un valor por defecto razonable que podría ser usando cuando el valor de los objetos \texttt{Nullable} se volviera perdido, uno puede proporcionar este valos por defecto como un segundo argumento a \texttt{get()}:




\begin{minted}{jlcon}
julia> get(Nullable{Float64}(), 0.0)
0.0

julia> get(Nullable(1.0), 0.0)
1.0
\end{minted}



\begin{quote}
\textbf{Tip}

\end{quote}


   Asegúrese de que el tipo de valor predeterminado pasado a \texttt{get ()} y el del objeto \texttt{Nullable} coincidan para evitar      la inestabilidad de tipo, lo que podría perjudicar el rendimiento. Utilice \hyperlink{1846942650946171605}{\texttt{convert()}} manualmente si      es necesario.



\hypertarget{11340387542224707120}{}


\subsection{Realizando operaciones sobre objetos \texttt{Nullable}}



Los objetos \texttt{Nullable} representan valores que están posiblemente perdidos, y es posible escribir todo el código usando estos objetos primero comprobando para ver si el valor está perdido con \hyperlink{16547052476421706505}{\texttt{isnull()}}, y luego realizar la accin apropiada. Sin embargo, hay algunos casos de uso comunes donde el código podría ser ms conciso o claro usando una función de orden superior.



La función \hyperlink{11483231213869150535}{\texttt{map}} toma como argumentos una función \texttt{f} y un valor \texttt{x} de tipo \texttt{Nullable}. Ella produce un \texttt{Nullable}:



\begin{itemize}
\item Si \texttt{x} es un valor perdido, entonces produce un valor perdido;


\item Si \texttt{x} tiene un valor, entonces produce un objeto \texttt{Nullable} que contiene \texttt{f(get(x))} como valor.

\end{itemize}


Esto es útil para realizar operaciones simples sobre valores que podrían estar perdidos si el comportamiento deseado es simplemente propagar hacia adelante los valores perdidos.



La función \hyperlink{11445961893478569145}{\texttt{filter}} toma como argumentos una función predicado \texttt{p} (es decir, una función que devuelve un boolean) y un valor \texttt{x} de tipo \texttt{Nullable}. Ella produce un \texttt{Nullable}:



\begin{itemize}
\item Si \texttt{x} es un valor perdido, entonces produce un valor perdido;


\item Si \texttt{p(get(x))} es true, entoces produce el valor original \texttt{x};


\item Si \texttt{p(get(x))} es false, entonces produce un valor perdido.

\end{itemize}


De esta forma, \texttt{filter} puede ser considerado como seleccionar sólo valores permisibles, y convertir valores no permisibles en valores perdidos.



Mientras que \texttt{map} y \texttt{filter} son útiles para casos específicos, la función de orden superior más útil es, con diferencia, \hyperlink{1261021074485016178}{\texttt{broadcast}}, que puede manejar una amplia variedad de casos, incluyendo hacer operaciones existentes funcionen y propaguen \texttt{Nullable}s. El siguiente ejemplo motivará la necesidad de \texttt{broadcast}. Supongamos que tenemos una funcion que calcula la mayor de las dos raices reales de una ecuacion cuadratica, usando la formula cuadratica:




\begin{lstlisting}
julia> root(a::Real, b::Real, c::Real) = (-b + √(b^2 - 4a*c)) / 2a
root (generic function with 1 method)
\end{lstlisting}



Podemos verificar que el resultado de \texttt{root (1, -9, 20)} es \texttt{5.0} como esperamos, ya que \texttt{5.0} es la mayor de dos raíces reales de la ecuación cuadrática.



Supongamos ahora que queremos encontrar la mayor raíz real de una ecuación cuadrática donde los coeficientes pueden ser valores perdidos. Tener valores perdidos en los conjuntos de datos es una ocurrencia común en los datos del mundo real, por lo que es importante poder tratar con ellos. Pero no podemos encontrar las raíces de una ecuación si no conocemos todos los coeficientes. La mejor solución para esto dependerá del caso de uso particular; quizás deberíamos arrojar un error. Sin embargo, para este ejemplo, asumiremos que la mejor solución es propagar los valores perdidos; es decir, si falta alguna entrada, simplemente producimos una salida faltante.



La función \texttt{broadcast ()} facilita esta tarea; simplemente podemos pasar la función \texttt{root} que escribimos a\texttt{broadcast}:




\begin{lstlisting}
julia> broadcast(root, Nullable(1), Nullable(-9), Nullable(20))
Nullable{Float64}(5.0)

julia> broadcast(root, Nullable(1), Nullable{Int}(), Nullable{Int}())
Nullable{Float64}()

julia> broadcast(root, Nullable{Int}(), Nullable(-9), Nullable(20))
Nullable{Float64}()
\end{lstlisting}



Si faltan una o más de las entradas, faltará la salida de \texttt{broadcast ()}.



Existe un convenio sintáctico especial para la función \texttt{broadcast()} usando la notación punto:




\begin{lstlisting}
julia> root.(Nullable(1), Nullable(-9), Nullable(20))
Nullable{Float64}(5.0)
\end{lstlisting}



En particular, los operadores aritméticos regulares pueden ser \texttt{broadcast ()} convenientemente usando operadores \texttt{.}-prefijo:




\begin{minted}{jlcon}
julia> Nullable(2) ./ Nullable(3) .+ Nullable(1.0)
Nullable{Float64}(1.66667)
\end{minted}



\hypertarget{15216268953652766477}{}


\chapter{Métodos}



Recordemos de la sección \hyperlink{11836327794581856778}{Funciones} que una función es un objeto que establece una correspondencia entre una tupla de argumentos y un valor de retorno o lanza una excepción si no puede devolverse el valor apropiado. Para la misma función conceptual es común soy implementada de una forma muy diferente para tipos de argumentos diferentes: sumar dos enteros es distinto de sumar dos valores en punto flotante y ambos son distintos de sumar un entero y 1 punto flotante. A pesar de las diferencias de implementación, éstas operaciones caen todas bajo el concepto general de {\textquotedbl}suma{\textquotedbl}. En consecuencia, en Julia, estos comportamientos pertenecen todos a un solo objeto: la función \texttt{+}.



Para facilitar el uso de muchas implementaciones distintas del mismo concepto suavemente, las funciones necesitan no ser definidas de una vez, sino poder ser definidas a trozos proporcionando comportamientos distintos para ciertas combinaciones de tipos de argumentos y cuentas. Llamamos \emph{método} a la definición de un posible comportamiento para una función. Hasta ahora sólo se han presentado ejemplos de funciones definidas como sólo método, aplicables a todo tipo de argumentos. Sin embargo, las asignaturas de las definiciones de los métodos pueden anotarse para indicar los tipos de los argumentos además de su número, y puede proporcionarse más de una sola definición de método. Cuando una función se aplica a una dupla de argumentos particular, se aplica el método más específico y aplicable a esos argumentos. Por tanto, el comportamiento global de una función es un collage de los comportamientos de sus distintas definiciones de métodos. Si el collage está bien diseñado, incluso aunque las implementaciones de los métodos puedan ser bastante diferentes, el comportamiento exterior de la función pareciera contínuo y consistente.



La elección de qué método ejecutar cuando se aplica una función se llama \emph{despacho}. Julia permite al proceso de despacho elegir qué método de una función llamar basándose en el número de argumentos y en los tipos de todos los argumentos dados a la función. Este mecanismo es diferente al que ocurre en los lenguajes orientados al objeto tradicionales, donde el despacho  se basa solo en el primer argumento, que frecuentemente tiene una sintaxis especial, y que es muchas veces implicado el lugar de ser escrito explícitamente como argumento. \footnotemark[1] Usar todos los argumentos de la función para elegir qué método debería ser invocado es conocido como \href{https://en.wikipedia.org/wiki/Multiple\_dispatch}{despacho múltiple}. El despacho múltiple es  particularmente útil para código matemático, donde  tiene poco sentido considerar que las operaciones pertenecen a un argumento más que los demás. Más allá de las operaciones matemáticas, sin embargo, el despacho múltiple ha resultado ser un paradigma potente y conveniente para estructurar y organizar los programas.



\footnotetext[1]{}


   En C++ o Java, por ejemplo, en una llamada a un método como \texttt{obj.meth(arg1,arg2)}, el objeto     obj {\textquotedbl}recibe{\textquotedbl} la llamada al método y es pasado implícitamente vía la palabra clave \texttt{this},      en lugar de con un argumento de método explícito. Cuando el objeto \texttt{this} actual es el      receptor de una llamada a método él puede ser omitido, escribiendo justo \texttt{meth(arg1,arg2)},      con \texttt{this} implicito como objeto receptor.



\hypertarget{16676978681965538238}{}


\section{Definiendo Métodos}



En los ejemplos estudiados hasta ahora, sólo se han definido funciones con un único método que tienen argumentos con los tipos no restringidos. Estas funciones se comporta como las que hay en lenguajes con tipos dinámicos tradicionales. Sin embargo, también se han usado despacho múltiple y métodos sin ser consciente de ello: todas las funciones estándar y operadores de Julia, tal como función \texttt{+}, tiene muchos métodos que definen su comportamiento sobre varias combinaciones posibles número y tipo de argumentos.



Cuando se define una función, uno puede opcionalmente restringir los tipos de los parámetros sobre los que se aplica usando el operador de la selección de tipos \texttt{::}, introducido en la sección \hyperlink{2417174341544422883}{Tipos compuestos}:




\begin{lstlisting}
julia> f(x::Float64, y::Float64) = 2x + y
f (generic function with 1 method)
\end{lstlisting}



Esta definición de función se aplica sólo a llamadas en las que \texttt{x} e \texttt{y} sean ambos valores del tipo \hyperlink{5027751419500983000}{\texttt{Float64}}:




\begin{lstlisting}
julia> f(2.0, 3.0)
7.0
\end{lstlisting}



Aplicar esta definición a otros tipos de argumentos dará como resultado un \hyperlink{14644228586476494020}{\texttt{MethodError}}:




\begin{lstlisting}
julia> f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia> f(Float32(2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
Closest candidates are:
  f(!Matched::Float64, ::Float64) at none:1

julia> f(2.0, "3.0")
ERROR: MethodError: no method matching f(::Float64, ::String)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1

julia> f("2.0", "3.0")
ERROR: MethodError: no method matching f(::String, ::String)
\end{lstlisting}



Como puede comprobarse, los argumentos tienen que ser exactamente del tipo \hyperlink{5027751419500983000}{\texttt{Float64}}. Otros tipos numéricos tales como \texttt{Float32} o \texttt{Int} no serán convertidos automáticamente en \texttt{Float64}. Algo parecido sucede con los datos \texttt{String}. Como el tipo \texttt{Float64} es un tipo concreto y los tipos concretos no pueden tener subclases en Julia, esta definición sólo puede aplicarse a argumentos que sean exactamente del tipo \texttt{Float64}. Esto puede ser útil en ocasiones, sin embargo, para escribir métodos más generales se hace uso de parámetros cuyos tipos sean abstractos:




\begin{lstlisting}
julia> f(x::Number, y::Number) = 2x - y
f (generic function with 2 methods)

julia> f(2.0, 3)
1.0
\end{lstlisting}



Esta definición de método se aplica a cualquier par de argumentos que sean instancias de  \hyperlink{1990584313715697055}{\texttt{Number}}. Ellas no tienen que ser del mismo tipo, mientras que ambas sean valores numéricos. El problema de manejar tipos numéricos dispares se delega a las operaciones aritméticas en la expresión \texttt{2x - y}.



Para definir una función con múltiples métodos, uno simplemente define la función varías veces, con diferentes números de argumentos y tipos. La primera definición de método para la función crea el objeto función y las definiciones de métodos subsecuentes añaden nuevos métodos al objeto función existente. La definición de método más específica que case con el número los tipos de argumentos será la ejecutada cuando se aplique la función. Por tanto, las dos definiciones de métodos anteriores, considerados juntas, define el comportamiento de la función \texttt{f} sobre todos los padres de instancias del tipo abstracto \texttt{Number} (pero con un comportamiento específico para pares de valores \hyperlink{5027751419500983000}{\texttt{Float64}}. Si uno de los argumentos es un valor en punto flotante de 64 bits, pero el otro no lo es, entonces el método \texttt{f(Float64,Float64)} no puede ser invocado y se utilizará el método más general \texttt{f(Number,Number)}:




\begin{lstlisting}
julia> f(2.0, 3.0)
7.0

julia> f(2, 3.0)
1.0

julia> f(2.0, 3)
1.0

julia> f(2, 3)
1
\end{lstlisting}



La definición \texttt{2x+y} sólo se usa en el primer caso, mientras que la definición \texttt{2x-y} se usa en los demás. Nunca se realiza conversión automática en los otros: todas las conversiones son no mágicas y completamente exlícitas. En la sección \hyperlink{10686378388163930476}{Conversión y promoción}, sin embargo, se muestra cómo las aplicaciones inteligentes de tecnología suficientemente avanzada pueden ser indistinguibles de la magic \footnotemark[2]



Para valores no numéricos, ,y para menores de dos argumentos, la función \texttt{f} permanece indefinida, y aplicándola se obtendrá como resultado un \hyperlink{14644228586476494020}{\texttt{MethodError}}:




\begin{lstlisting}
julia> f("foo", 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
Closest candidates are:
  f(!Matched::Number, ::Number) at none:1

julia> f()
ERROR: MethodError: no method matching f()
Closest candidates are:
  f(!Matched::Float64, !Matched::Float64) at none:1
  f(!Matched::Number, !Matched::Number) at none:1
\end{lstlisting}



Puedes ver fácilmente que métodos existen para una función entrando el propio nombre del objeto en una sesión interactiva:




\begin{lstlisting}
julia> f
f (generic function with 2 methods)
\end{lstlisting}



La salida nos dice que \texttt{f} es un objeto función con dos métodos. Para encontrar cuáles son las signaturas de esos métodos, utilizaremos la función \hyperlink{3025953302266245919}{\texttt{methods()}}:




\begin{minted}{jlcon}
julia> methods(f)
# 2 methods for generic function "f":
f(x::Float64, y::Float64) in Main at none:1
f(x::Number, y::Number) in Main at none:1
\end{minted}



que muestra que \texttt{f} tiene dos métodos: uno que toma dos argumentos \texttt{Float64} y una que toma dos argumentos de tipo \texttt{Number}. También indica el fichero y el número de línea donde los métodos fueron definidos aunque, si los métodos fueron definidos en el REPL, se obtendrá \texttt{none:1}.



En ausencia de una declaración de tipo con  \texttt{::} el tipo de un parámetro de un método es \texttt{Any} por defecto, lo que significa que está sin restricciones ya que todos los valores en Julia son instancias del tipo abstracto \texttt{Any}. Por tanto, podemos definir un método atrapatodo para \texttt{f} tal como:




\begin{lstlisting}
julia> f(x,y) = println("Whoa there, Nelly.")
f (generic function with 3 methods)

julia> f("foo", 1)
Whoa there, Nelly.
\end{lstlisting}



Este atrapatodo es menos específico que cualquier otra posible definición de método para un par de valores de parámetros, por lo que sólo será llamada sobre pares de argumentos a los cuales no pueda aplicarse otra definición de método.



Aunque parece un concepto simple, el despacho múltiple sobre los tipos de valores es quizás la característica más potente y central del lenguaje Julia. Las operaciones del núcleo tienen típicamente docenas de metodos:




\begin{minted}{jlcon}
julia> methods(+)
# 180 methods for generic function "+":
+(x::Bool, z::Complex{Bool}) in Base at complex.jl:224
+(x::Bool, y::Bool) in Base at bool.jl:89
+(x::Bool) in Base at bool.jl:86
+(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96
+(x::Bool, z::Complex) in Base at complex.jl:231
+(a::Float16, b::Float16) in Base at float.jl:372
+(x::Float32, y::Float32) in Base at float.jl:374
+(x::Float64, y::Float64) in Base at float.jl:375
+(z::Complex{Bool}, x::Bool) in Base at complex.jl:225
+(z::Complex{Bool}, x::Real) in Base at complex.jl:239
+(x::Char, y::Integer) in Base at char.jl:40
+(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:303
+(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:303
+(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:296
+(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:290
+(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:258
+(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:315
...
+(a, b, c, xs...) at operators.jl:119
\end{minted}



El despacho múltiple junto con el sistema de tipos paramétrico flexible dan a Julia su capacidad para expresar de forma abstract algoritmos de alto nivel desacoplados de los detalles de implementación, generando aún código eficiente y especializado para manejar cada caso en tiempo de ejecución.



\hypertarget{8405464025999625028}{}


\section{Ambigüedades de Métodos}



Es posible definir un conjunto de métodos de función tales que no haya un método único más específico aplicable a alguna combinación de argumentos:




\begin{lstlisting}
julia> g(x::Float64, y) = 2x + y
g (generic function with 1 method)

julia> g(x, y::Float64) = x + 2y
g (generic function with 2 methods)

julia> g(2.0, 3)
7.0

julia> g(2, 3.0)
8.0

julia> g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous.
[...]
\end{lstlisting}



Aquí, la llamada \texttt{g(2.0, 3.0)} podría ser manejada por los métodos \texttt{g(Float64, Any)} o \texttt{g(Any, Float64)} y ninguno es más específico que el otro. En tales casos, Julia lanza un \hyperlink{14644228586476494020}{\texttt{MethodError}} en lugar de elegir uno de los métodos arbitrariamente. Podemos obviar las ambigüedades de los métodos especificando un método apropiado para el caso intersección:




\begin{lstlisting}
julia> g(x::Float64, y::Float64) = 2x + 2y
g (generic function with 3 methods)

julia> g(2.0, 3)
7.0

julia> g(2, 3.0)
8.0

julia> g(2.0, 3.0)
10.0
\end{lstlisting}



Se recomienda que el método que suprime la ambigüedad sea definido primero, ya que en caso contrario la ambigüedad existe, transitoriamente, hasta que el método más especifico sea definido.



En casos ms complejos, resolver ambigüedades de métodos implica un cierto elemento de diseño; este tema se explorará \hyperlink{11088607530909626670}{posteriormente}.



\hypertarget{10721236019411599281}{}


\section{Métodos paramétricos}



Las definiciones de métodos pueden tener, opcionalmente, parámetros de tipo cualificando la signatura:




\begin{lstlisting}
julia> same_type(x::T, y::T) where {T} = true
same_type (generic function with 1 method)

julia> same_type(x,y) = false
same_type (generic function with 2 methods)
\end{lstlisting}



El primer método se aplica cuando ambos argumentos son del mismo tipo concreto, independientemente del tipo que sea, mientras que el segundo actúa como un atrapatodo, cubriendo todos los demás casos. Por tanto, en conjunto, esto define una función booleana que comprueba si dos argumentos son del mismo tipo:




\begin{lstlisting}
julia> same_type(1, 2)
true

julia> same_type(1, 2.0)
false

julia> same_type(1.0, 2.0)
true

julia> same_type("foo", 2.0)
false

julia> same_type("foo", "bar")
true

julia> same_type(Int32(1), Int64(2))
false
\end{lstlisting}



Tales definiciones corresponden a métodos cuyas signaturas de tipo son tipos \texttt{UnionAll} (ver \hyperlink{13494686645968204765}{tipos UnionAll}.



Esta clase de definición del comportamiento de una función mediante despacho es bastante común (incluso idiomático) en Julia. Los métodos con parámetros de tipo no están restringidos a ser usados como los tipos de los parámetros: ellos pueden ser usados en cualquier parte donde un palo estaría en la signatura de la función o cuerpo de la función. He aquí un eemplo donde el parámetro de tipo del método \texttt{T} se sa como el parámetro de tipo al tipo paramétrico \texttt{Vector\{T\}} en la signatura del método:




\begin{minted}{jlcon}
julia> myappend(v::Vector{T}, x::T) where {T} = [v..., x]
myappend (generic function with 1 method)

julia> myappend([1,2,3],4)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1

julia> myappend([1.0,2.0,3.0],4.0)
4-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0

julia> myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)
Closest candidates are:
  myappend(::Array{T,1}, !Matched::T) where T at none:1
\end{minted}



Como puedes ver, el tipo del elemento añadido tiene que corresponderse con el tipo de elemento del vector al que se está añadiendo, o se lanzará un \hyperlink{14644228586476494020}{\texttt{MethodError}}.  En el siguiente ejemplo, el parámetro de tipo del método \texttt{T} se usa como valor de retorno:




\begin{minted}{jlcon}
julia> mytypeof(x::T) where {T} = T
mytypeof (generic function with 1 method)

julia> mytypeof(1)
Int64

julia> mytypeof(1.0)
Float64
\end{minted}



Así como puedes poner restricciones de subtipo para los parámetros de tipo en declaraciones de tipo (ver \hyperlink{15542027490314302254}{Tipos Paramétricos}) también puedes restringir los parámetros de tipo de los métodos:




\begin{minted}{jlcon}
julia> same_type_numeric(x::T, y::T) where {T<:Number} = true
same_type_numeric (generic function with 1 method)

julia> same_type_numeric(x::Number, y::Number) = false
same_type_numeric (generic function with 2 methods)

julia> same_type_numeric(1, 2)
true

julia> same_type_numeric(1, 2.0)
false

julia> same_type_numeric(1.0, 2.0)
true

julia> same_type_numeric("foo", 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
Closest candidates are:
  same_type_numeric(!Matched::T<:Number, ::T<:Number) where T<:Number at none:1
  same_type_numeric(!Matched::Number, ::Number) at none:1

julia> same_type_numeric("foo", "bar")
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)

julia> same_type_numeric(Int32(1), Int64(2))
false
\end{minted}



La función \texttt{same\_type\_numeric} se comporta como la función \texttt{same\_type} descrita antes, pero sólo está definida para pares de números.



Los métodos paramétricos permiten la misma sintaxis que las expresiones \texttt{where} usadas para escribir tipos (ver \hyperlink{13494686645968204765}{tipos UnionAll}). 



Si hay un único parámetro, las llaves que lo encierran (en \texttt{where \{T\}}) pueden ser omitidas, aunque suele ser preferible mantenerlas por claridad.



Los parámetros múltiples pueden ser separados con comas, por ejemplo \texttt{where \{T, S<:Real\}}, o escritos usando \texttt{where} anidados, por ejemplo, \texttt{where S<:Real where T}.



\hypertarget{3838308498632705310}{}


\section{Redefiniendo Métodos}



Cuando se redefine un método o se añaden nuevos métodos, es importante comprender que estos cambios no tienen efecto inmediatamente. Esto es clave para la capacidad de Julia para inferir estáticamente y compilar código para ejecutar rápido, sin los trucos de JIT y sobrecargas usuales. De hecho, cualquier nueva definición de método no será visible al entorno de ejecución actual, incluyendo tareas e hilos (y cualquier otra función definida con \texttt{@generated}). Comencemos con un ejemplo para ver qué significa esto:




\begin{minted}{jlcon}
julia> function tryeval()
           @eval newfun() = 1
           newfun()
       end
tryeval (generic function with 1 method)

julia> tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.
Closest candidates are:
  newfun() at none:1 (method too new to be called from this world context.)
 in tryeval() at none:1
 ...

julia> newfun()
1
\end{minted}



En este ejemplo, observe que la nueva definición para \texttt{newfun} ha sido creada, pero no puede ser llamada inmediatamente. El nuevo global es inmediatamente visible para la función \texttt{tryeval}, para que pueda escribir \texttt{return newfun} (sin paréntesis). ¡Pero ni usted ni ninguna de las personas que llama, ni las funciones a las que llama, etc. puede llamar a esta nueva definición de método!



Pero hay una excepción: las llamadas futuras a \texttt{newfun} \emph{del REPL} funcionan como se esperaba, pudiendo tanto ver como invocar la nueva definición de\texttt{newfun}. Sin embargo, las futuras llamadas a \texttt{tryeval} continuarán viendo la definición de\texttt{newfun} tal como era \emph{en la instrucción anterior en REPL}, y por lo tanto antes de esa llamada a \texttt{tryeval}.



Es posible que desee probar esto para ver cómo funciona.



La implementación de este comportamiento es un {\textquotedbl}contador de edad mundial{\textquotedbl}. Este valor monótonamente creciente rastrea cada operación de definición de método. Esto permite describir {\textquotedbl}el conjunto de definiciones de métodos visibles para un entorno de tiempo de ejecución dado{\textquotedbl} como un solo número, o {\textquotedbl}edad mundial{\textquotedbl}. También permite comparar los métodos disponibles en dos mundos simplemente comparando su valor ordinal. En el ejemplo anterior, vemos que el {\textquotedbl}mundo actual{\textquotedbl} (en el que existe el método \texttt{newfun ()}) es uno mayor que el {\textquotedbl}mundo de tiempo de ejecución{\textquotedbl} local de la tarea que se corrigió cuando se inició la ejecución de \texttt{tryeval}.



A veces es necesario evitar esto (por ejemplo, si está implementando el REPL anterior). Afortunadamente, hay una solución fácil: llamar a la función usando \hyperlink{15240876280767285272}{\texttt{Base.invokelatest}}:




\begin{minted}{jlcon}
julia> function tryeval2()
           @eval newfun2() = 2
           Base.invokelatest(newfun2)
       end
tryeval2 (generic function with 1 method)

julia> tryeval2()
2
\end{minted}



Por último, echemos un vistazo a algunos ejemplos más complejos donde esta regñla se pone en funcionamiento. Definamos una función \texttt{f(x)}, que inicialmente tiene un método:




\begin{lstlisting}
julia> f(x) = "original definition"
f (generic function with 1 method)
\end{lstlisting}



Iniciamos algunas operaciones que usan \texttt{f(x)}:




\begin{lstlisting}
julia> g(x) = f(x)
g (generic function with 1 method)

julia> t = @async f(wait()); yield();
\end{lstlisting}



Ahora añadimos algunos métodos nuevos a \texttt{f(x)}:




\begin{lstlisting}
julia> f(x::Int) = "definition for Int"
f (generic function with 2 methods)

julia> f(x::Type{Int}) = "definition for Type{Int}"
f (generic function with 3 methods)
\end{lstlisting}



Compare cómo difieren estos resultados:




\begin{lstlisting}
julia> f(1)
"definition for Int"

julia> g(1)
"definition for Int"

julia> wait(schedule(t, 1))
"original definition"

julia> t = @async f(wait()); yield();

julia> wait(schedule(t, 1))
"definition for Int"
\end{lstlisting}



\hypertarget{9272584532067475752}{}


\section{Parametrically-constrained Varargs methods}



Los parámetros de función pueden también ser usados para restringir el número de argumentos que pueden ser proporcionados a una función {\textquotedbl}varags{\textquotedbl} (ver \hyperlink{4426560717438156432}{Funciones Vararg}).  La notación \texttt{Vararg\{T,N\}} se usa para indicar tal restricción. Por ejemplo:




\begin{minted}{jlcon}
julia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)
bar (generic function with 1 method)

julia> bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, !Matched::Any) at none:1

julia> bar(1,2,3,4)
(1, 2, (3, 4))

julia> bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
Closest candidates are:
  bar(::Any, ::Any, ::Any, ::Any) at none:1
\end{minted}



Más útilmente, es posible restringir métodos varargs mediante un parámetro. Por ejemplo:




\begin{minted}{julia}
function getindex(A::AbstractArray{T,N}, indexes::Vararg{Number,N}) where {T,N}
\end{minted}



sería llamado sólo cuando el número de \texttt{indexes} se correspondiera con la dimensionalidad del array.



\hypertarget{3406543699482093781}{}


\section{Note on Optional and keyword Arguments}



Como se menciona brevemente en \hyperlink{11836327794581856778}{Funciones}, los argumentos opcionales se implementan como sintaxis para múltiples definiciones de métodos. Por ejemplo, esta definición:




\begin{minted}{julia}
f(a=1,b=2) = a+2b
\end{minted}



se traduce a los siguientes tres métodos:




\begin{minted}{julia}
f(a,b) = a+2b
f(a) = f(a,2)
f() = f(1,2)
\end{minted}



Esto significa que llamar a \texttt{f()} es equivalente a llamar a \texttt{f(1,2)}. En este caso, el resultado es \texttt{5}, porque\texttt{f (1,2)}invoca el primer método de \texttt{f} anterior. Sin embargo, este no siempre es el caso. Si define un cuarto método que es más especializado para enteros:




\begin{minted}{julia}
f(a::Int,b::Int) = a-2b
\end{minted}



entonces el resultado de ambos \texttt{f()} y \texttt{f(1,2)} es \texttt{-3}. En otras palabras, los argumentos opcionales están vinculados a una función, no a ningún método específico de esa función. Depende de los tipos de argumentos opcionales qué método se invoca. Cuando los argumentos opcionales se definen en términos de una variable global, el tipo de argumento opcional puede incluso cambiar en tiempo de ejecución.



Los argumentos de palabra clave se comportan de manera bastante diferente de los argumentos posicionales ordinarios. En particular, no participan en el envío del método. Los métodos se envían basados \emph{únicamente en argumentos posicionales, con argumentos de palabra clave procesados} después de que se identifica el método de coincidencia.



\hypertarget{5838617276552546951}{}


\section{Funciones como objetos}



Los métodos están asociados con tipos, por lo que es posible hacer algún objeto Julia arbitrario {\textquotedbl}invocable{\textquotedbl} añadiendo métoos a este tipo (tales objetos {\textquotedbl}invocables{\textquotedbl} son denominados en ocasiones {\textquotedbl}functores{\textquotedbl}). 



Por ejemplo, podemos definir un tipo que almacena los coeficientes de un polinomio, pero que se comporta como una función que evalúa el polinomio:




\begin{lstlisting}
julia> struct Polynomial{R}
           coeffs::Vector{R}
       end

julia> function (p::Polynomial)(x)
           v = p.coeffs[end]
           for i = (length(p.coeffs)-1):-1:1
               v = v*x + p.coeffs[i]
           end
           return v
       end
\end{lstlisting}



Note que la función es especificada por el tipo en lugar de por el nombre. En el cuerpo de la función, \texttt{p} se referira´al objeto que fue llamado. Un \texttt{Polynomial} puede ser usado como sigue:




\begin{lstlisting}
julia> p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])

julia> p(3)
931
\end{lstlisting}



Este mecanismo es también la clave de cómo los constructores de tipo y cierres (funciones internas que se refieren al entorno que las rodea) funcionan en Julia, lo cual se discute \hyperlink{9881427980873554977}{después en el manual}.



\hypertarget{4393452698373258534}{}


\section{Funciones Genéricas Vacías}



Ocasionalmente, es útil introducir una función genérica sin agregar métodos. Esto se puede usar para separar las definiciones de interfaz de las implementaciones. También se puede hacer con el fin de la documentación o la legibilidad del código. La sintaxis para esto es un bloque de \texttt{function} vacío sin una tupla de argumentos:




\begin{minted}{julia}
function emptyfunc
end
\end{minted}



\hypertarget{11088607530909626670}{}


\section{Diseño de métodos y evitación de ambigüedades}



El polimorfismo de los métodos de Julia es una de sus características más poderosas, pero explotar este poder puede plantear desafíos de diseño. En particular, en jerarquías de métodos más complejos no es raro que surjan \hyperlink{8405464025999625028}{ambigüedades}.



Arriba se indicó que uno puede resolver ambigüedades como




\begin{minted}{julia}
f(x, y::Int) = 1
f(x::Int, y) = 2
\end{minted}



definiendo un método




\begin{minted}{julia}
f(x::Int, y::Int) = 3
\end{minted}



Esta es a menudo la estrategia correcta; sin embargo, hay circunstancias en las que seguir este consejo a ciegas puede ser contraproducente. En particular, cuantos más métodos tenga una función genérica, más posibilidades habrá de ambigüedades. Cuando sus jerarquías de métodos se vuelven más complicadas que este simple ejemplo, puede valer la pena pensar cuidadosamente sobre estrategias alternativas.



A continuación, discutimos los desafíos particulares y algunas formas alternativas de resolver dichos problemas.



\hypertarget{12968608076555068412}{}


\subsection{Tuple and NTuple arguments}



Los argumentos \texttt{Tuple} (y \texttt{NTuple}) presentan retos especiales. Por ejemplo,




\begin{minted}{julia}
f(x::NTuple{N,Int}) where {N} = 1
f(x::NTuple{N,Float64}) where {N} = 2
\end{minted}



son ambiguos debido a la posibilidad de que \texttt{N == 0}: no hay elementos para determinar si se debe invocar a la variante\texttt{Int} o \texttt{Float64}. Para resolver la ambigüedad, un enfoque es definir un método para la tupla vacía:




\begin{minted}{julia}
f(x::Tuple{}) = 3
\end{minted}



Alternativamente, para todos los métodos excepto uno podemos insistir en que hay al menos un elemento en la tupla:




\begin{minted}{julia}
f(x::NTuple{N,Int}) where {N} = 1           # this is the fallback
f(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64
\end{minted}



\hypertarget{2934107525015609338}{}


\subsection{Orthogonalice su diseño}



Cuando tenga la tentación de despachar en dos o más argumentos, considere si una función de {\textquotedbl}envoltura{\textquotedbl} podría hacer un diseño más simple. Por ejemplo, en lugar de escribir múltiples variantes:




\begin{minted}{julia}
f(x::A, y::A) = ...
f(x::A, y::B) = ...
f(x::B, y::A) = ...
f(x::B, y::B) = ...
\end{minted}



podría considerar definir




\begin{minted}{julia}
f(x::A, y::A) = ...
f(x, y) = f(g(x), g(y))
\end{minted}



donde \texttt{g} convierte el argumento para escribir \texttt{A}. Esto es un ejemplo muy específico del principio más general de \href{https://en.wikipedia.org/wiki/Orthogonality\_ (programación)}{diseño ortogonal}, en el que los conceptos separados se alinean a métodos separados. Aquí, \texttt{g} muy probablemente necesitará una definición de repliegue




\begin{minted}{julia}
g(x::A) = x
\end{minted}



Una estrategia relacionada explota \texttt{promote} para llevar\texttt{x} y \texttt{y} a un tipo común:




\begin{minted}{julia}
f(x::T, y::T) where {T} = ...
f(x, y) = f(promote(x, y)...)
\end{minted}



Un riesgo de este diseño es la posibilidad de que si no hay un método de promoción adecuado para convertir \texttt{x} y\texttt{y} al mismo tipo, el segundo método se repetirá en sí mismo infinitamente y desencadenará un desbordamiento de la pila. La función no exportada \texttt{Base.promote\_noncircular} se puede usar como alternativa; cuando la promoción falla, aún arrojará un error, pero uno que falla más rápido con un mensaje de error más específico.



\hypertarget{16222736954481721742}{}


\subsection{Despacho en un argumento a la vez}



Si necesita despachar en múltiples argumentos, y hay muchos retrocesos con demasiadas combinaciones para que sea práctico definir todas las variantes posibles, entonces considere introducir una {\textquotedbl}cascada de nombres{\textquotedbl} donde (por ejemplo) despache en el primer argumento y luego llame un método interno:




\begin{minted}{julia}
f(x::A, y) = _fA(x, y)
f(x::B, y) = _fB(x, y)
\end{minted}



Entonces los métodos internos \texttt{\_fA} y\texttt{\_fB} pueden enviarse en \texttt{y} sin preocuparse por las ambigüedades entre sí con respecto a \texttt{x}.



Tenga en cuenta que esta estrategia tiene al menos una desventaja importante: en muchos casos, no es posible para los usuarios personalizar aún más el comportamiento de \texttt{f} definiendo más especializaciones de su función\texttt{f} exportada. En su lugar, tienen que definir especializaciones para sus métodos internos \texttt{\_fA} y\texttt{\_fB}, y esto borra las líneas entre los métodos exportados e internos.



\hypertarget{987501277859770915}{}


\subsection{Contenedores abstractos y tipos de elementos}



Donde sea posible, trate de evitar definir los métodos que se despachan en tipos de elementos específicos de contenedores abstractos. Por ejemplo,




\begin{minted}{julia}
-(A::AbstractArray{T}, b::Date) where {T<:Date}
\end{minted}



genera ambigüedades para cualquiera que defina un método




\begin{minted}{julia}
-(A::MyArrayType{T}, b::T) where {T}
\end{minted}



El mejor enfoque es evitar definir \emph{cualquiera} de estos métodos: en su lugar, confíe en un método genérico \texttt{-(A::AbstractArray, b)} y haga Asegúrese de que este método se implemente con llamadas genéricas (como \texttt{similar} y \texttt{-}) que hacen lo correcto para cada tipo de contenedor y tipo de elemento \emph{por separado}. Esta es solo una variante más compleja de los consejos para \hyperlink{2934107525015609338}{ortogonalize} sus métodos.



Cuando este enfoque no es posible, puede valer la pena comenzar un discusión con otros desarrolladores sobre la resolución de la ambigüedad; sólo porque un método se definió primero no necesariamente significa que no puede ser modificado o eliminado Como último recurso, un desarrollador puede definir el método {\textquotedbl}tirita{\textquotedbl}




\begin{minted}{julia}
-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...
\end{minted}



eso resuelve la ambigüedad por la fuerza bruta.



\hypertarget{14149369438271440067}{}


\subsection{Método complejo {\textquotedbl}cascadas{\textquotedbl} con argumentos predeterminados}



Si está definiendo un método {\textquotedbl}cascada{\textquotedbl} que suministra valores predeterminados, sea cuidado al eliminar cualquier argumento que corresponda al potencial por defecto. Por ejemplo, supongamos que estás escribiendo un filtro digital algoritmo y usted tiene un método que maneja los bordes de la señal mediante la aplicación de relleno:




\begin{minted}{julia}
function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel)  # now perform the "real" computation
end
\end{minted}



Esto entrará en conflicto con un método que proporciona relleno predeterminado:




\begin{minted}{julia}
myfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default
\end{minted}



Juntos, estos dos métodos generan una recursión infinita con {\textquotesingle}A{\textquotesingle} creciendo cada vez más.



El mejor diseño sería definir su jerarquía de llamadas de esta manera:




\begin{minted}{julia}
struct NoPad end  # indicate that no padding is desired, or that it's already applied

myfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions

function myfilter(A, kernel, ::Replicate)
    Apadded = replicate_edges(A, size(kernel))
    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions
end

# other padding methods go here

function myfilter(A, kernel, ::NoPad)
    # Here's the "real" implementation of the core computation
end
\end{minted}



\texttt{NoPad} se proporciona en la misma posición de argumento que cualquier otro tipo de relleno, por lo que mantiene la jerarquía de despacho bien organizada y con menor probabilidad de ambigüedades. Además, amplía lo {\textquotedbl}público{\textquotedbl}interfaz \texttt{myfilter}: un usuario que quiere controlar el relleno explícitamente puede llamar a la variante \texttt{NoPad} directamente.



\footnotetext[2]{Arthur C. Clarke, \emph{Profiles of the Future} (1961): Clarke{\textquotesingle}s Third Law.

}


\hypertarget{17317810227993044854}{}


\chapter{Constructores}



Los constructores \footnotemark[1] son funciones que crean nuevos objetos (específicamente instancias de tipos compuestos). En Julia, los objetos también sirven como funciones constructor: ellos crean instancias de sí mismos cuando se aplican a una dupla de argumentos como una función. Esto se mencionó brevemente cuando se habló de tipos compuestos. Por ejemplo:




\begin{lstlisting}
julia> struct Foo
           bar
           baz
       end

julia> foo = Foo(1, 2)
Foo(1, 2)

julia> foo.bar
1

julia> foo.baz
2
\end{lstlisting}



Para muchos tipos, formar nuevos objetos enlazando valores de campo juntos es todo se necesita para crear instancias. Hay, sin embargo, casos donde se requiere más funcionalidad cuando se crean objetos compuestos. Algunas invariantes deben ser forzadas, bien chequeando argumentos o transformándolos. Las \href{https://en.wikipedia.org/wiki/Recursion\_\%28computer\_science\%29\#Recursive\_data\_structures\_.28structural\_recursion.29}{estructuras de datos recursivas}, especialmente aquellas que pueden ser auto referenciadas frecuentemente, no pueden construirse limpiamente sin que primero sean creadas e   n un estado incompleto y después sean alteradas programáticamente para ser completadas, como un paso separado de la creación del objeto. Algunas veces, es conveniente ser capaz de construir objetos con menos o diferentes tipos de parámetros que el número de campos que tiene. El sistema Julia para construcción de objetos cubre estos casos y más.



\footnotetext[1]{Nomenclature: while the term {\textquotedbl}constructor{\textquotedbl} generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as {\textquotedbl}constructors{\textquotedbl}. In such situations, it is generally clear from context that the term is used to mean {\textquotedbl}constructor method{\textquotedbl} rather than {\textquotedbl}constructor function{\textquotedbl}, especially as it is often used in the sense of singling out a particular method of the constructor from all of the others.

}


\hypertarget{2020563352853499304}{}


\section{Métodos constructores externos}



Un constructor es como cualquier otro función en Julia en que es su comportamiento global está definido por el comportamiento combinado de sus métodos. Según esto, se puede añadir funcionalidad a ún constructor simplemente definiendo nuevos métodos. Por ejemplo, supóngase que se desea añadir un método constructor para objetos \texttt{Foo} que tomar un argumento y usa el valor dado para los dos campos que presentan \texttt{baz} y \texttt{bar}. Esto es sencillo::




\begin{lstlisting}
julia> Foo(x) = Foo(x,x)
Foo

julia> Foo(1)
Foo(1, 1)
\end{lstlisting}



Podría también añadirse un constructor \texttt{Foo} sin argumentos que proporciona valores por defecto para los campos \texttt{bar} y \texttt{baz}:




\begin{lstlisting}
julia> Foo() = Foo(0)
Foo

julia> Foo()
Foo(0, 0)
\end{lstlisting}



Aquí, el método constructor sin argumentos llama al método constructor con un argumento, que a su vez llama al método constructor de dos argumentos proporcionado automáticamente. Por razones que se aclararán pronto, los metodos constructor adicionales declarados como métodos formales como éstos se denominan \emph{métodos constructores externos}. Los métodos constructores externos sólo puede crear una nueva instancia llamando a otro método constructor, tal como los  proporcionados automáticamente por defecto.



\hypertarget{15038227707169287476}{}


\section{Métodos Constructores Internos}



Aunque los constructores externos resuelven con éxito el problema de proporcionar métodos adicionales para construir objetos, ellos fallan en los otros dos casos de uso mencionados en la introducción este capítulo: forzar invariantes y permitir la construcción de objetos autorreferenciales. Para estos problemas, se necesitan los \emph{métodos constructores internos}. Un método constructor interno es parecido a uno externo, con dos diferencias:



\begin{itemize}
\item[1. ] Se declara dentro del bloque de la declaración del tipo, el lugar donde fuera como los métodos normales.


\item[2. ] Tiene acceso a una función especial, existente totalmente, llamada \texttt{new} que crea objetos del tipo del bloque.

\end{itemize}


Poner ejemplo, supóngase que uno quiere declarar un tipo que almacene un par de elementos reales, sujetos a la restricción de que el primer número no es mayor que el segundo. Uno podría declararlo así:




\begin{lstlisting}
julia> struct OrderedPair
           x::Real
           y::Real
           OrderedPair(x,y) = x > y ? error("out of order") : new(x,y)
       end

\end{lstlisting}



Ahora sólo pueden construirse objetos \texttt{OrderedPair} tales que \texttt{x <= y}:




\begin{lstlisting}
julia> OrderedPair(1, 2)
OrderedPair(1, 2)

julia> OrderedPair(2,1)
ERROR: out of order
Stacktrace:
 [1] OrderedPair(::Int64, ::Int64) at ./none:4
\end{lstlisting}



Si el tipo se declara \texttt{mutable}, se puede acceder y cambiar directamente los valores de campo para violar esta invariante, pero se considera deficiente la interacción con las partes internas de un objeto sin invitación. Usted (u otra persona) también puede proporcionar más métodos constructores externos en cualquier momento posterior, pero una vez que se declara un tipo, no hay forma de agregar más métodos internos de construcción. Como los métodos constructores externos solo pueden crear objetos llamando a otros métodos de construcción, en última instancia, se debe llamar a algún constructor interno para crear un objeto. Esto garantiza que todos los objetos del tipo declarado deben existir mediante una llamada a uno de los métodos de constructor internos proporcionados con el tipo, dando así cierto grado de cumplimiento de las invariantes de un tipo.



Si se define cualquier método de constructor interno, no se proporciona ningún método constructor predeterminado: se supone que se ha provisto de todos los constructores internos que necesita. El constructor predeterminado es equivalente a escribir su propio método constructor interno que toma todos los campos del objeto como parámetros (restringidos para ser del tipo correcto, si el campo correspondiente tiene un tipo), y los pasa a \texttt{new}, devolviendo el objeto resultante: 




\begin{minted}{jlcon}
julia> struct Foo
           bar
           baz
           Foo(bar,baz) = new(bar,baz)
       end

\end{minted}



Esta declaración tiene el mismo efecto que la definición anterior del tipo \texttt{Foo} sin un método constructor interno específico. Los siguientes dos tipos son equivalentes (uno con un constructor por defecto y el otro con un constructor explícito):




\begin{minted}{jlcon}
julia> struct T1
           x::Int64
       end

julia> struct T2
           x::Int64
           T2(x) = new(x)
       end

julia> T1(1)
T1(1)

julia> T2(1)
T2(1)

julia> T1(1.0)
T1(1)

julia> T2(1.0)
T2(1)
\end{minted}



Se considera una buena práctica proporcionar tan pocos constructores internos como sea posible: sólo aquellos que tomen todos los argumentos explícitamente y fuercen la comprobación de errores y las transformaciones esenciales. Los demás constructores proporcionados, que proporcionan valores por defecto o transformaciones auxiliares, deberían proporcionarse como constructores externos que llaman a los internos para hacer el trabajo pesado. Esta situación suele ser bastante natural.



\hypertarget{10952678487701727595}{}


\section{Inicialización incompleta}



El problema final que aún no se ha resuelto es la construcción de objetos autorreferenciales o, más generalmente, estructuras de datos recursivas. Como la dificultad fundamental puede no ser obvia de inmediato, se explicará brevemente. Considere la siguiente declararción de tipo recursivo:




\begin{lstlisting}
julia> mutable struct SelfReferential
           obj::SelfReferential
       end

\end{lstlisting}



Este tipo puede parecer bastante inócuo a menos que uno considere cómo construir una instancia de él. Si \texttt{a} es una instancia de \texttt{SelfReferential}, entonces una segunda instancia \texttt{b} podría crearse mediante la llamada:




\begin{minted}{jlcon}
julia> b = SelfReferential(a)
\end{minted}



¿Pero cómo se construye la primera instancia cuando no existe ninguna otra instancia para propocionar un valor válido para el campo \texttt{obj}? La única solución es permitir la creación de una instancia de \texttt{SelfReferential} que no esté inicializada por completo, con el campo \texttt{obj} no asignado, y usar esta instancia incompleta como un valor válido que se podcría asignar al campo \texttt{obj} de otra instancia, o incluso al de ella misma.



Para permitir la creación de objetos inicializados de forma incompleta, Julia permite que la  función \texttt{new} sea llamada con menos argumentos del número de campos que el objeto tiene, devolviendo un objeto con los campos no especificados sin inicializar. El método constructor interno pues entonces usar el método incompleto, finalizando su inicialización antes de devolverlo. Aquí por ejemplo, se intenta definir el tipo \texttt{SelfReferental} con un constructor interno con cero argumentos que devuelve instancias con sus campos \texttt{obj} apuntando a ellos mismos:




\begin{lstlisting}
julia> mutable struct SelfReferential
           obj::SelfReferential
           SelfReferential() = (x = new(); x.obj = x)
       end

\end{lstlisting}



Podemos verificar que este constructor funciona y construye objetos que son, de hecho, autorreferenciados:




\begin{lstlisting}
julia> x = SelfReferential();

julia> x === x
true

julia> x === x.obj
true

julia> x === x.obj.obj
true
\end{lstlisting}



Aunque se permite crear objetos con campos no inicializados, cualquier objeto a una referencia no inicializada es un eror inmediato:




\begin{lstlisting}
julia> mutable struct Incomplete
           xx
           Incomplete() = new()
       end

julia> z = Incomplete();
\end{lstlisting}



Aunque se permite crear objetos con campos no inicializados, cualquier objeto a una referencia no inicializada es un eror inmediato:




\begin{lstlisting}
julia> z.xx
ERROR: UndefRefError: access to undefined reference
\end{lstlisting}



Esto evita la necesidad de estar comprobando datos \texttt{null} continuamente. Sin embargo, no todos los campos de objetos son referencias. Julia considera algunos tipos Como {\textquotedbl}datos planos{\textquotedbl}, Lo que significa que todos sus datos son auto contenidos y que no referencian otros objetos. Los tipos de datos planos son los tipos primitivos (es decir \texttt{Int}) y las estructuras inmutables de otros tipos de datos planos. Los contenidos iniciales de un tipo de datos planos son indefinidos:




\begin{minted}{jlcon}
julia> struct HasPlain
           n::Int
           HasPlain() = new()
       end

julia> HasPlain()
HasPlain(438103441441)
\end{minted}



Los arrays de tipos de datos planos exhiben el mismo comportamiento.



Uno puede pasar objetos incompletos a otras funciones desde los constructores internos para  delegar su terminación:




\begin{minted}{jlcon}
julia> mutable struct Lazy
           xx
           Lazy(v) = complete_me(new(), v)
       end
\end{minted}



Como sucede con los objetos incompletos devueltos desde los constructores, si \texttt{complete\_me} o alguno de los métodos que lo llaman intenta acceder al campo \texttt{xx} del objeto \texttt{Lazy} antes de que éste sea inicializado, se lanzará un error de inmediato.



\hypertarget{8072855221834692914}{}


\section{Constructores paramétricos}



Los tipos paramétricos añaden algunas complicaciones al tema de los constructores. Recuérdese la sección \hyperlink{15542027490314302254}{Tipos Paramétricos} que por defecto pueden construirse instancias de estos tipos dando  explícitamente los parámetros de tipo o con parámetros de tipo implicados por los tipos de los argumentos dados al constructor. He aquí algunos ejemplos:




\begin{lstlisting}
julia> struct Point{T<:Real}
           x::T
           y::T
       end

julia> Point(1,2) ## implicit T ##
Point{Int64}(1, 2)

julia> Point(1.0,2.5) ## implicit T ##
Point{Float64}(1.0, 2.5)

julia> Point(1,2.5) ## implicit T ##
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
  Point(::T<:Real, !Matched::T<:Real) where T<:Real at none:2

julia> Point{Int64}(1, 2) ## explicit T ##
Point{Int64}(1, 2)

julia> Point{Int64}(1.0,2.5) ## explicit T ##
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int64}, ::Float64) at ./float.jl:679
 [2] Point{Int64}(::Float64, ::Float64) at ./none:2

julia> Point{Float64}(1.0, 2.5) ## explicit T ##
Point{Float64}(1.0, 2.5)

julia> Point{Float64}(1,2) ## explicit T ##
Point{Float64}(1.0, 2.0)
\end{lstlisting}



Como podemos ver, para las llamadas a constructor con parámetros de tipo explícito, los argumentos se convierten a los tipos implícitos de los campos: \texttt{Point\{Int64\}(1,2)} funciona, pero \texttt{Point\{Int64\}(1.0,2.5)} lanza un \hyperlink{5399118524830636312}{\texttt{InexactError}} cuando \texttt{2.5} se convierte a \hyperlink{7720564657383125058}{\texttt{Int64}}. Cuando el tipo es implicado por los argumentos de la llamada al constructor, como en \texttt{Point(1,2)}, entonces los tipos de los argumentos deben concordar para que se pueda determinar \texttt{T}, pero da igual cuáles sean los tipos mientras ambos sean iguales y, además, subclases de \texttt{Real}.



Lo que está pasando aquí realmente es que \texttt{Point}, \texttt{Point\{Float64\}} y \texttt{Point\{Int64\}} son funcioens constructores diferentes. De hecho, \texttt{Point\{T\}} es una función constructor distinto para cada tipo \texttt{T}. Sin ningún constructor interno propocionado explícitamente, la declaración del tipo compuesto \texttt{Point\{T<:Real\}} proporciona automáticamente un constructor interno \texttt{Point\{T\}} para cada posible ipo \texttt{T<:Real} que se comporta justo como lo hacen los constructores internos no paramétricos por defecto. Ella también proporciona un solo constructor general externo que toma pares de argumentos reales, que deben ser del mismo tipo. Esta provisión automática de constructores es equivalente a la siguiente declaración explícita:




\begin{lstlisting}
julia> struct Point{T<:Real}
           x::T
           y::T
           Point{T}(x,y) where {T<:Real} = new(x,y)
       end

julia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);
\end{lstlisting}



Observe que cada definición se parece a la forma de llamada de constructor que maneja. La llamada \texttt{Point\{Int64\}(1,2)} invocará la definición \texttt{Point\{T\}(x, y)} dentro del bloque \texttt{type}.



La declaración de constructor externo, por otro lado, define un método para el constructor general de \texttt{Point} que sólo se aplica a pares de valores del mismo tipo real. Esta declaración hace que las llamadas al constructor sin parámetros de tipo explícitos, como \texttt{Punto(1,2)} y \texttt{Punto(1.0,2.5)}, funcionen. Dado que la declaración del método restringe los argumentos para que sean del mismo tipo, las llamadas como \texttt{Point(1,2.5)}, con argumentos de diferentes tipos, dan como resultado errores {\textquotedbl}no method{\textquotedbl}.



Supongamos que queremos hacer la llamada a constructor \texttt{Point(1, 2.5)} funcione promocionando el valor entero \texttt{1} a punto flotante \texttt{1.0}. La forma más sencilla de conseguir eso es definir el siguiente método constructor adicional:




\begin{lstlisting}
julia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);
\end{lstlisting}



Este método usa la función \hyperlink{1846942650946171605}{\texttt{convert()}} para convertir explícitamente \texttt{x} a \hyperlink{5027751419500983000}{\texttt{Float64}} y entonces delegar la construcción al constructor general para el caso de que ambos argumentos sean \hyperlink{5027751419500983000}{\texttt{Float64}}. Con esta definición de método, lo  que previamente producía un  \hyperlink{14644228586476494020}{\texttt{MethodError}} ahora crea con éxito un punto de tipo \texttt{Point\{Float64\}}:




\begin{lstlisting}
julia> Point(1,2.5)
Point{Float64}(1.0, 2.5)

julia> typeof(ans)
Point{Float64}
\end{lstlisting}



Sin embargo, otras llamadas similares siguen sin funcionar:




\begin{lstlisting}
julia> Point(1.5,2)
ERROR: MethodError: no method matching Point(::Float64, ::Int64)
Closest candidates are:
  Point(::T<:Real, !Matched::T<:Real) where T<:Real at none:1
\end{lstlisting}



Para una forma mucho más general de hacer que todas estas llamadas funcionen sensiblemente, ver \hyperlink{10686378388163930476}{Conversión y promoción}. A riesgo de estropear el suspense, podemos revelar aquí que todo lo toma el siguiente método externo para hacer que todas las llamadas al constructor general \texttt{Point} trabajen como uno debería esperar:




\begin{lstlisting}
julia> Point(x::Real, y::Real) = Point(promote(x,y)...);
\end{lstlisting}



La función \texttt{promote} convierte todos sus argumentos a un tipo común (en este caso, \texttt{Float64}). Con esta definición de método el constructor \texttt{Point} promociona sus argumentos de la misma forma que lo hacen los operadores aritméticos como \hyperlink{3677358729494553841}{\texttt{+}} y funciona para todos los tipos de números reales:




\begin{lstlisting}
julia> Point(1.5,2)
Point{Float64}(1.5, 2.0)

julia> Point(1,1//2)
Point{Rational{Int64}}(1//1, 1//2)

julia> Point(1.0,1//2)
Point{Float64}(1.0, 0.5)
\end{lstlisting}



Por tanto, mientras los constructores con parámetros de tipo implícitos proporcionados por defecto en Julia son muy estrictos, es posible hacer que se comporten de una forma más relajada pero sensible con bastante facilidad. Además, como los constructores pueden sacar ventaja de toda la potencia del sistema de tipos, métodos y despacho múltiple, definir comportamientos sofisticados suele ser bastante simple.



\hypertarget{13394318901311885654}{}


\section{Case Study: Rational}



Quizás la mejor forma de unir todas las piezas es presentar un ejemplo del mundo real de un tipo compuesto paramétrico y sus métodos constructores. Para este fin, he aquí una parte de  \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}}, que implementa los \hyperlink{12093481009248886258}{Números Racionales} en Julia:




\begin{lstlisting}
julia> struct OurRational{T<:Integer} <: Real
           num::T
           den::T
           function OurRational{T}(num::T, den::T) where T<:Integer
               if num == 0 && den == 0
                    error("invalid rational: 0//0")
               end
               g = gcd(den, num)
               num = div(num, g)
               den = div(den, g)
               new(num, den)
           end
       end

julia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)
OurRational

julia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)
OurRational

julia> OurRational(n::Integer) = OurRational(n,one(n))
OurRational

julia> //(n::Integer, d::Integer) = OurRational(n,d)
// (generic function with 1 method)

julia> //(x::OurRational, y::Integer) = x.num // (x.den*y)
// (generic function with 2 methods)

julia> //(x::Integer, y::OurRational) = (x*y.den) // y.num
// (generic function with 3 methods)

julia> //(x::Complex, y::Real) = complex(real(x)//y, imag(x)//y)
// (generic function with 4 methods)

julia> //(x::Real, y::Complex) = x*y'//real(y*y')
// (generic function with 5 methods)

julia> function //(x::Complex, y::Complex)
           xy = x*y'
           yy = real(y*y')
           complex(real(xy)//yy, imag(xy)//yy)
       end
// (generic function with 6 methods)
\end{lstlisting}



La primera línea – \texttt{struct OurRational\{T<:Integer\} <: Real} – declara que \texttt{OurRational} toma un parámetro de un subtipo de \texttt{Integer}, aunque él en si mismo es un tipo \texttt{Real}. Las declaraciones de campo \texttt{num::T} y \texttt{den::T} indican que los datos almacenados en un objeto \texttt{OurRational\{T\}} será un par de enteros de tipo \texttt{T}, uno que representará el numerador y otro el denominador. 



Ahora las cosas se ponen interesantes. \texttt{OurRational} tiene un solo constructor interno que comprueba que tanto \texttt{num} como \texttt{den} no son cero, y aegura que cada número racional se construye en sus términos mínimos con un denominador no negativo. Esto se consigue dividiendo los valores de numerador y denominador por su máximo común divisor, el cuál se calcula a través de la función \texttt{gcd}. Por último, y como \texttt{gcd} asigna el signo del primer argumento (en este caso \texttt{den}) se garantiza que el denominador ya no sea negativo. Como este es el único constructor interno de \texttt{Rational}, podemos estar seguros de que los objetos de este tipo siempre se construyen en forma normalizada.



\texttt{Rational} también proporciona varios métodos constructores externos por conveniencia. El primero es el constructor general {\textquotedbl}esándar{\textquotedbl}, que infiere el tupo del parámetro \texttt{T} a partir del tipo del numerado y denominador que tienen que ser del mismo tipo. El segundo se aplica cuando numerador y denominador tiene tipos distintos: los promociona a un tipo común y entonces delega la construcción al otro constructor externo con argumentos del mismo tipo. En tercer constructor externo convierte valores enteros en racionales proporcionando un denominador de valor 1.



Siguiendo las definiciones de constructores externos, tenemos una serie de métodos para el operador \hyperlink{17539582191808611917}{\texttt{//}} que proporcionan una sintaxis para escribir racionales. Antes de estas definiciones,  \hyperlink{17539582191808611917}{\texttt{//}}es un operador completamente indefinido con sólo sintaxis y sin significado. Después, se comporta tal y com se describe en \hyperlink{12093481009248886258}{Números Racionales} –  (su comportamiento completo está descrito en estas pocas líneas). La primera y más básica definición hace \texttt{a//b} construya un  \texttt{OurRational} aplicando el constructor de este tipo sobre \texttt{a} y \texttt{b} cuando ambos son enteros. Cuando uno de los operandos de  \hyperlink{17539582191808611917}{\texttt{//}} ya es un número racional se construye un nuevo número racional para la razón resultante con una leve diferencia: este comportamiento es igual a la división de un racional entre un entero. Por último, aplicar \hyperlink{17539582191808611917}{\texttt{//}} a valores complejos enteros crea una instancia de \texttt{Complex\{Rational\}}, que es un complejo cuyas partes real el imaginaria son racionales:




\begin{lstlisting}
julia> ans = (1 + 2im)//(1 - 2im);

julia> typeof(ans)
Complex{OurRational{Int64}}

julia> ans <: Complex{OurRational}
false
\end{lstlisting}



Por tanto, aunque el operador \hyperlink{17539582191808611917}{\texttt{//}} suela devolver una instancia de \texttt{OurRational}, si uno de sus rgumentos es un complejo entero, devolverá una instancia de \texttt{Complex\{OurRational\}}. El lector interesado debería considerar la lectura del resto de \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}}: es corto, autocontenido e implmeenta un tipo básico de Julia al completo.



\hypertarget{9881427980873554977}{}


\section{Constructores and Conversión}



Los constructores \texttt{T(args)} se implementan como otros objetos invocables: los métodos se añaden a sus tipos. El tipo de un tipo es \texttt{Type} por lo que los métodos constructores se almacenan en la tabla de métodos para el tipo \texttt{Type}. Esto significa que se pueden declarar constructores más flexibles, es decir, constructores para tipos abstractos, mediante la definición explícita de métodos para los tipos apropiados.



Sin embargo, en algunos casos, uno debería considerar añadir métodos a \texttt{Base.convert} en ougar de definir un constructor, dado que Julia retrocede para llamar a \hyperlink{1846942650946171605}{\texttt{convert()}} si no se encuentra un constructor que coincida. Por ejemplo, si no existe para constructor para \texttt{T(args...) =} se llamará a \texttt{Base.convert(::Type\{T\}, args...)=...}



\texttt{convert} se usa extensivamente a través de Julia cuando un tipo tenga que ser convertido en otro (por ejemplo, en asignación, \hyperlink{14245046751182637566}{\texttt{ccall}}, etcetera), y sólo debería ser definido (o exitoso) si la conversión se realiza sin pérdidas. Por ejemplo, \texttt{convert(Int, 3.0)} produce \texttt{3}, pero \texttt{convert(Int,3.2)} lanza un \texttt{InexactError}. Si desea construirse un constructor para una conversión sin pérdidas de un tipo a otro, probablemente sería mejor definir un método \texttt{convert}.



Por otra parte, si el constructro no representa una conversión sin pérdida, o no represnta ningua conversion es mejor dejarlo como constructor en lugar de como un método \texttt{convert}. Por ejemplo, el constructor \texttt{Array\{Int\}} crea un array cero-dimensional del tipo \texttt{Int} pero no es realmente una conversión de \texttt{Int} a \texttt{Array}.



\hypertarget{12408096661351866337}{}


\section{Constructores sólo exteriores}



Como se ha visto, un tipo paramétrico típico tiene constructroes internos que son invocados cuano se conocen los tupos de los parámetros, por ejemplo, se aplican a \texttt{Point\{Int\}}paro no a \texttt{Point}. Opcionalmente, los constructores externos que determinan los parámetros de tipo  pueden ser añadidos automáticamente, por ejemplo, construir un \texttt{Point\{Int\}} a partir de la llamada \texttt{Point(1,2)}. Los constructores externos llaman a los constructores internos para que hagan el trabajo básico de hacer una instancia.  Sin embargo, en algunos caos, uno podría en lugar de eso no proporcionar contructores internos para que los parámetros específicos no puedan ser solicitados manualmente. 



Por ejemplo, suponga que se define un tipo que almacena un vector con una representaciócn exacta de su suma:




\begin{minted}{jlcon}
julia> struct SummedArray{T<:Number,S<:Number}
           data::Vector{T}
           sum::S
       end

julia> SummedArray(Int32[1; 2; 3], Int32(6))
SummedArray{Int32,Int32}(Int32[1, 2, 3], 6)
\end{minted}



El problema es que nosotros queremos que \texttt{S} sea un tipo más grande que \texttt{T}, por lo que podemos sumar muchos elementos con menos pérdida de información. Por ejemplo, cuando \texttt{T} es \hyperlink{10103694114785108551}{\texttt{Int32}}, querríamos que \texttt{S} fiuera \hyperlink{7720564657383125058}{\texttt{Int64}}. Por tano queremos evitar un interfaz que permita al usuario construir instanca del tipo \texttt{SummedArray\{Int32,Int32\}}. Una forma de hacer esto es proporcionar sólo un constructor más exterior para \texttt{SummedArray}.  Esto puede hacerse usando a definicíon de métdo por tipo pero dentro del bloque de definición \texttt{type} para suprimir la generación de bucles por defecto:




\begin{minted}{jlcon}
julia> struct SummedArray{T<:Number,S<:Number}
           data::Vector{T}
           sum::S
           function SummedArray(a::Vector{T}) where T
               S = widen(T)
               new{T,S}(a, sum(S, a))
           end
       end

julia> SummedArray(Int32[1; 2; 3], Int32(6))
ERROR: MethodError: no method matching SummedArray(::Array{Int32,1}, ::Int32)
Closest candidates are:
  SummedArray(::Array{T,1}) where T at none:5
\end{minted}



El construcror será invocado por la sintaxis \texttt{SummedArray(a)}. La sintaxis \texttt{new\{T,S\}} permite especificar parámetrospara el tipo que se va a construir, es decir, esta llamada devolvera un \texttt{SummedArray\{T, s]}. \texttt{new\{T,S\}} puede usarse en cualquier definicin de constructor, pero por conveniencia los parámtros a \texttt{new\{\}} se derivan automáticamente del tipo que se está construyendo cuando sea posible.



\hypertarget{10686378388163930476}{}


\chapter{Conversión and Promoción}



Julia tiene un sistema para promocionar argumento de operaciones matemáticas a un tipo común, que ha sido mencionado en varias secciones, incluyendo \hyperlink{17453309092420764607}{números enteros y en punto flotante}, \hyperlink{16655087771805204817}{operaciones matemáticas y funciones elmentales}, \hyperlink{2141690262982725665}{Tipos}, and \hyperlink{15216268953652766477}{Métodos}.En esta sección, explicaremos cómo funciona este sistema de promociones, y también cómo extenderlo a nuevos tipos y aplicarlo a funciones junto a operadores matemáticos predefinidos. Tradicionalmente, los lenguajes de programación caen en dos categorías con respecto a la promoción de los argumentos aritméticos:



\begin{itemize}
\item \textbf{Promoción automática para operadores y tipos artiméticos predefinidos}. En la mayoría de los lenguajes, los tipos numéricos predefinidos, cuando se usan como operandos de operaciones aritméticas con una sintaxis infija, tal y  como \texttt{+}, \texttt{-}, \texttt{*}y \texttt{/}, son promocionados automáticamente a un tipo común para producir el resultado esperado. C,  Java, Perl y Pytho,, por nombrar unos pocos, calculan todos la suma \texttt{1 + 1.5} correctamente como el valor en punto flotante \texttt{2.5}, incluso aunque uno de los operandos sea un entero. Estos sistemas son convenientes y diseñados cuidadosamente de forma que generalmente realizan esta labor de forma invisible al programador: a duras penas,  alguien consciente piensa que esta promoción está teniendo lugar cuando escribe una expresión, pero los  compiladores e intérpretes deben realizar la conversión antes de la adición debido a que los valores enteros y en  punto flotante no pueden sumarse tal cual. Por tanto, reglas complejas para tales conversiones automáticas son  una parte inevitable de la especificación e implementación de estos lenguajes.


\item \textbf{No promoción automática} Este campo incluy a Ada y ML (lenguajes tipados estáticamente y muy estrictos). En  estos lenguajes, cada conversión debe ser especificada por el programador de foma explícita. Por tanto, la expresión  de ejemplo \texttt{1 + 1.5} daría un error de compilación en ambos lenguajes. En lugar de esta expresión, uno debería  escribir \texttt{real(1) + 1.5}, convirtiendo explícitamente el 1 enteror a un valores en punto flotante antes de realizar la adición. La conversión explícita en todos sitios es tan inconveniente, sin embargo, que incluso Ada tiene algún grado  de conversión automática.: los literales enteros son promocionaods al tipo entero esperado automáticamente, y los literales en punto flotante son promocionados similarmente a los tipos apropiados en punto flotante.

\end{itemize}


En cierto sentido, Julia cae en la categoría {\textquotedbl}no promoción automática{\textquotedbl}: los operadores automáticos son funciones con sintaxis especial, y los argumentos de funciones no son nunca convertidos automáticamente. Sin embargo, uno puede observar que aplicar operaciones matermáticas a una amplia variedad de tipos de argumentos mixtos es justo un caso extremo del despacho múltiple polimórfico (algo que el despacho de Julia y los sistemas de tipos manejan bastante bien. La promoción {\textquotedbl}automática{\textquotedbl} de operandos matermáticos simplemente emerge como una aplicación especial: Julia viene un reglas de despacho {\textquotedbl}atrapa-todo{\textquotedbl} predefinidas para los operadores matemáticos, invocadas cuando no existen implementaciones específicas para alguna combinación de tipos de operandos. Estas reglas {\textquotedbl}atrapa-todo{\textquotedbl} primero promocionan todos los operandos a un tipo común usando reglas de promoción definibles por el usuario, y luego invoca a una implementación especializada del operador en cuestión para los valores resultantes, ahora del mismo tipo. Los tipos definidos por el usuario pueden participar fácilmente en este sistema de promoción definiendo métodos para la conversión hacia o desde otros tipos, y proporcionar un puñado de reglas de promoción que definan a qué tipos deberían ellos promocionarse cuando se mezclan con otros tipos.



\hypertarget{14157437756365261772}{}


\section{Conversión}



La conversión de valores a varios tipos es llevada a cabo mediante la función \texttt{convert}. Esta función suele tomar dos argumentos: el primero es un objeto tipo mientras que el segundo es un valor que hay que convertir a ese tipo; el valor devuelto es el valor convertido a una instancia del tipo dado. La forma más simple de comprender esta función es verla en acción:




\begin{minted}{jlcon}
julia> x = 12
12

julia> typeof(x)
Int64

julia> convert(UInt8, x)
0x0c

julia> typeof(ans)
UInt8

julia> convert(AbstractFloat, x)
12.0

julia> typeof(ans)
Float64

julia> a = Any[1 2 3; 4 5 6]
2×3 Array{Any,2}:
 1  2  3
 4  5  6

julia> convert(Array{Float64}, a)
2×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
\end{minted}



La conversión no es siempre posible, en cuyo caso se lanza un error no método indicando que \texttt{convert} no sabe cómo realizar la conversión solicitada:




\begin{minted}{jlcon}
julia> convert(AbstractFloat, "foo")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
This may have arisen from a call to the constructor AbstractFloat(...),
since type constructors fall back to convert methods.
\end{minted}



Algunos lenguajes consideran que el análisis sintáctico de cadenas como número o el formateo de números a cadenas es una conversión (muchos lengaujes dinámicos realizarán esta conversión por ti automáticamente). Sin embargo, Julia no lo hace. Incluso aunque algunas cadenas puedan ser analizadas como números, la mayoría de las cadenas no son representaciones válidas de números, y sólo un subconjunto muy limitado de ellas lo son. Por tanto, en Julia la función  dedicada \texttt{parse()} debe ser usada para realizar esta operación, haciéndolo más explícito.



\hypertarget{7580648799228119151}{}


\subsection{Definiendo nuevas conversiones}



Para definir nuevas conversiones, simpemente propocionaremos un nuevo método para \texttt{convert()}. Esto es realmente todo lo que hay que hacer. Por ejemplo, el método para convertir un número real a boolean es:




\begin{minted}{julia}
convert(::Type{Bool}, x::Real) = x==0 ? false : x==1 ? true : throw(InexactError())
\end{minted}



El tipo del primer argumento de este método es un \hyperlink{647919389478144252}{tipo singleton}, \texttt{Type\{Bool\}}, , la única instancia del cuál es \texttt{Bool}. Por tanto, este método es sólo invocado cuando el primer argumento es el valor tipo \texttt{Bool}. Nótese la sintaxis usada pora el primer argumento: el nombre del argumento es omitido antes del símbolo \texttt{::} y sólo se da el tipo. Esta es la sintaxis de Julia para un argumento a función cuyo tipo está especificado pero su valor nunca se utilizará en el cuerpo de la función. En este ejemplo, como el tipo es un singleton, nunca habría una razón para usar su valor dentro del cuerpo. Cuando se invoca el método determina si un valor numérico es verdadero o falso como un boolean, comparándolo con uno y con cero:




\begin{minted}{jlcon}
julia> convert(Bool, 1)
true

julia> convert(Bool, 0)
false

julia> convert(Bool, 1im)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Bool}, ::Complex{Int64}) at ./complex.jl:31

julia> convert(Bool, 0im)
false
\end{minted}



Las signaturas de método para métodos de conversión están frecuentemente un poco más implicadas que este ejemplo, especialmente para tipos paramétricos. El ejemplo de antes está pensado para ser pedagógico, y no es el comportamiento actual de Julia. He aquí la implementación actual en Julia:




\begin{minted}{julia}
convert(::Type{T}, z::Complex) where {T<:Real} =
    (imag(z) == 0 ? convert(T, real(z)) : throw(InexactError()))
\end{minted}



\hypertarget{1257412251017943533}{}


\subsection{Caso de estudio: Conversiones de \texttt{Rational}}



Para continuar con nuestro caso de estudio sobre el tipo \hyperlink{8304566144531167610}{\texttt{Rational}} de Julia, he aquí las conversiones declaradas en \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}}, después de la declaración del tipo y sus constructores:




\begin{minted}{julia}
convert(::Type{Rational{T}}, x::Rational) where {T<:Integer} = Rational(convert(T,x.num),convert(T,x.den))
convert(::Type{Rational{T}}, x::Integer) where {T<:Integer} = Rational(convert(T,x), convert(T,1))

function convert(::Type{Rational{T}}, x::AbstractFloat, tol::Real) where T<:Integer
    if isnan(x); return zero(T)//zero(T); end
    if isinf(x); return sign(x)//zero(T); end
    y = x
    a = d = one(T)
    b = c = zero(T)
    while true
        f = convert(T,round(y)); y -= f
        a, b, c, d = f*a+c, f*b+d, a, b
        if y == 0 || abs(a/b-x) <= tol
            return a//b
        end
        y = 1/y
    end
end
convert(rt::Type{Rational{T}}, x::AbstractFloat) where {T<:Integer} = convert(rt,x,eps(x))

convert(::Type{T}, x::Rational) where {T<:AbstractFloat} = convert(T,x.num)/convert(T,x.den)
convert(::Type{T}, x::Rational) where {T<:Integer} = div(convert(T,x.num),convert(T,x.den))
\end{minted}



Los cuatro primeros métodos \texttt{convert} proporcionan conversión a tipos racionales. El primer método converte el tipo de reacional a otro tipo de racional convirtiendo el nomerador y el denominador al tipo de entero apropiado. El segundo método hace la misma conversión para enteros tomando el denominado para que sea 1. El tercer método implementa un aalgoritmo estándar para aproximar un número de punto flotante por una razón de enteros dentro de un a tolerancia dada, y el cuarto método lo aplica, usando el epsilo de máquina como el valor dado para elumbral. En general, uno debería tener \texttt{a//b == convert(Rational\{Int64\}, a/b)}.



Los dos últimos métodos conversores proporcionan conversiones de tipos racionales a punto flotante y entero. Para convertir a punto flotante, uno simplemente convierte tanto numerador como denominador a punto flotante y luego divide. Para convertir a entero, uno usa el operador \texttt{div} para división entera truncada (redondeo hacia cero).



\hypertarget{8431365920606292227}{}


\section{Promoción}



La promoción se refiere a convetir valores de tipos mezclados a un solo tipo común. Aunque esto no es estrictamente necesario, se supone generalmente que el tipo común al cuál los valores son convertidos puede representar de forma fidedigna todos los valores. En este sentido, el término {\textquotedbl}promoción{\textquotedbl} es apropiado ya que los valores son convertidos a un tipo {\textquotedbl}mayor{\textquotedbl} (es decir, uno que pueda reprsentar todos los valores de entrada en un solo tipo común). Es importante, sin embargo, no confundir esto con los super-tipos orientados a objetos (estructurales), o l nocíon de super-tipos abstractos de Julia: la promoción no tiene nada que ver con la jerarquía de tipos, y todo que ver con convertir entre representaciones alternas. Por ejemplo, aunque cad valor \hyperlink{10103694114785108551}{\texttt{Int32}} puede también ser representado como un valor \hyperlink{5027751419500983000}{\texttt{Float64}}, \texttt{Int32} no es un subtipo de \texttt{Float64}.



La promoción a un tipo mayor común es realizada por Julia mediante la función \texttt{promote}, que toma cualquier número de argumentos, y devuelve un atupla con el mismo número de valores, convertidos a un tipo común, o lanza una excepción si no es posible la promoción. El caso de uso más común para la promoción es convertir argumentos numéricos a un tipo común:




\begin{minted}{jlcon}
julia> promote(1, 2.5)
(1.0, 2.5)

julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)

julia> promote(2, 3//4)
(2//1, 3//4)

julia> promote(1, 2.5, 3, 3//4)
(1.0, 2.5, 3.0, 0.75)

julia> promote(1.5, im)
(1.5 + 0.0im, 0.0 + 1.0im)

julia> promote(1 + 2im, 3//4)
(1//1 + 2//1*im, 3//4 + 0//1*im)
\end{minted}



Los valores en punto flotante son promocionados al mayor de los tipos de los argumento en punto flotante. Los valores enteros son promocionados al mayor de el tamaño de palabra de máquina nativo o dl mayor tipo dde argumento entero. Las mezclas de valores enteros y en punto flotante son promocionados a tipos en punto flotante bastent grandes como para almacenar todos los valores. Los enteros mezclados con racionales promocionan a racionales. Los racionales mezclados con valores en punto flotante son promocionados a valores en punto flotante. Los valores complejos mezclados con valores relaes se promocionan al tipo apropiado de valor complejo.



Esto es realmente todo lo que es usar promociones. El resto es sólo cuestión de una aplicación inteligente, siendo la definición de métodos {\textquotedbl}atrapa-todo{\textquotedbl} para operaciones numéricas tales como las aritméticas \texttt{+}, \texttt{-}, \texttt{*} y \texttt{/} las más típicas aplicaciones inteligentes. He aquí algunas de las definiciones de métodos {\textquotedbl}atrapa-todo{\textquotedbl} dados en \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}}:




\begin{minted}{julia}
+(x::Number, y::Number) = +(promote(x,y)...)
-(x::Number, y::Number) = -(promote(x,y)...)
*(x::Number, y::Number) = *(promote(x,y)...)
/(x::Number, y::Number) = /(promote(x,y)...)
\end{minted}



Estas definiciones de métodos dicen que en la ausencia de reglas más específicas para sumar, restar, multiplicar y dividir pares de valores numéricos, promocionemos los valores a un tipo común y entonces intentemos de nuevo. Este es todo aquí: en ninguna otra parte hay que preocuparse por la promoción a un tipo numérico común para las operaciones aritméticas (ello sucede automáticamente). Hay definiciones de métodos de promoción {\textquotedbl}atrapa-todo{\textquotedbl} para un número de otras funciones arimtéticas y matemáticas en \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}}, pero más allá de eso, difícilmente encontremos ninguna llamada a \texttt{promote} necesaria en la librería estándar de Julia. Los usos más comunes de \texttt{promote} ocurren en los métodos de construcción externos, proporcionados por conveniencia, para permitir llamadas a constructor con tipos mezclados para delegar a un tipo interno con campos promocionados a un  tipo común aproximado. Por ejemplo, recordemos que \href{https://github.com/JuliaLang/julia/blob/master/base/rational.jl}{\texttt{rational.jl}} proporciona el siguiente método constructor externo:




\begin{minted}{julia}
Rational(n::Integer, d::Integer) = Rational(promote(n,d)...)
\end{minted}



This allows calls like the following to work:




\begin{minted}{jlcon}
julia> Rational(Int8(15),Int32(-5))
-3//1

julia> typeof(ans)
Rational{Int32}
\end{minted}



Para la mayoría de los tipos definidos por usuario, es mejor práctica requerir que los programadores proporcionen los tipos esperados para las funciones constructor explícitamente, pero algunas veces, especialmente para problemas numéricos, puede ser conveniente realizar la conversión de forma automática.



\hypertarget{77498233187764212}{}


\subsection{Definiendo reglas de promoción}



Aunque uno podría, en principio, definir métodos para la función \texttt{promote} directamente, esto requeriría muchas defniciones redundantes para todas las posibles permutaciones de tipos de argumentos. En lugar de ello, el comportamiento de \texttt{promote} es definido en términos de una función auxiliar denominada \texttt{promote\_rule}, para la que uno puede proporcionar métodos. La funci´no \texttt{promote\_rule} toma un par de objetos tipo y devuelve otro objeto tipo, tal que instancias de los tipos de argumentos sean promocionadas al tipo retornado. De este modo, definiendo la regla:




\begin{minted}{julia}
promote_rule(::Type{Float64}, ::Type{Float32}) = Float64
\end{minted}



uno declara que cuando se promocionan juntos valores en punto flotante de 32 y de 64 bits, ellos deberían ser promocionados a punto flotante de 64 bits. El tipo de promoción no tiene que ser uno de los tipos de los argumentos. He aquí un par de ejemplos de reglas de promoción que aparecen en la librería estándar de Julia: 




\begin{minted}{julia}
promote_rule(::Type{UInt8}, ::Type{Int8}) = Int
promote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt
\end{minted}



En el último caso, el tipo de resultado es  \hyperlink{423405808990690832}{\texttt{BigInt}} since \texttt{BigInt} ya que éste es el único tipo lo bastante grande como para alojar enteros para aritmética entera de precisión arbitraria. Nótese también que uno no necesita definir dos reglas simétricas \texttt{promote\_rule(::Type\{A\}, ::Type\{B\})} y \texttt{promote\_rule(::Type\{B\}, ::Type\{A\})} (esta simetría es supuesta por la forma en que \texttt{promote\_rule} es utilizada en el proceso de promoción.



La función \texttt{promote\_rule} se usa com un bloque constructivo para definir una segunda función llamada \texttt{promote\_type} la cuál, dado cualquier número de objetos tupo, devuelve el tipo común al cuál esos valores, como argumentos a \texttt{promote} deberían ser promocionados. Por tanto, si uno quiere saber, en ausencia de valores actuales, a qué tipo promocionaría una colección de valores de cierto tipo, uno podría usar \texttt{promote\_type}:




\begin{minted}{jlcon}
julia> promote_type(Int8, UInt16)
Int64
\end{minted}



Internamente, \texttt{promote\_type} se usa dentro de \texttt{promote} para determinar a qué valores argumento tipo deberían ser convertidos tras una promoción. Ell puede, sin embargo, ser útil en sí misma. el lector curioso puede leer el código en \href{https://github.com/JuliaLang/julia/blob/master/base/promotion.jl}{\texttt{promotion.jl}}, , que define el mecanismo de promoción completo en aproximadamente 35 líneas.



\hypertarget{14190722500597872438}{}


\subsection{Caso de estudio: promociones Rational}



Finalmente, finalizaremos nuestro caso de estudio el tipo de los números racionales en Julia, que hace un uso relativamente sofistidcado del mecanismo de promoción con las siguientes reglas de promoción:




\begin{minted}{julia}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}
promote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)
\end{minted}



La primera regla dice que promocionar un número racional con algún otro entero promociona a un tipo racional cuyo tipo numerados/denominador es el resultado de la promoción de sus tipos numerador/denoinador con el otro tipo entero. La segunda regla aplica la misma lógic a dos tipos diferentes de números racionales, dando como resultado un racional de la promoción de sus respectivos tipos numerador/denominador. Las reglas tercera y última dictan que promocionar un racional con un punto flotante da como resultado el mismo tipo que promocionar el tipo de numerador/denominador con el float.



Este pequeño puñado de reglas de promoción, junto con los \hyperlink{1257412251017943533}{métodos de conversión discutidos antes}, son suficiente para hacer que los números racionales interoperen completamente y de forma natural con todos los demás tipos numéricos de Julia (enteros, números en punto flotante y números complehjos). Proporcionando métodos de converión apropiadosy reglas de promoción en la misma manera, cualquier tipo numérico definido por el usuario puede interoperar así de naturalmente con los numéricos predefinidos en Julia.



\hypertarget{6589646210931807616}{}


\chapter{Interfaces}



Un montón de la potencia y extensibilidad de Julia viene de una colección de interfaces informales. Extendiendo unos pocos métodos específicos para que trabajen para un tipo personalizado, los objetos de este tipo no sólo reciben estas funcionalidades, sino que son también capaces de ser usados en otros métodos que han sido escritos para ser construidos genéricamente sobre esos comportamientos.



\hypertarget{5510379658285713272}{}


\section{Iteración}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Métodos requeridos               &                       & Breve descripción                                                                     \\
\hline
\texttt{start(iter)} &   & Devuelve el estado inicial de iteración \\
\hline
\texttt{next(iter, state)} &   & Devuelve el ítem actual y pone \texttt{state} en el siguiente \\
\hline
\texttt{done(iter, state)} &   & Comprueba si quedan más ítems \\
\hline
\textbf{Métodos opcionales importantes} & \textbf{Definiciones por defecto} & \textbf{Breve descripción}                                                                 \\
\hline
\texttt{iteratorsize(IterType)} & \texttt{HasLength()} & Uno de \texttt{HasLength()},\texttt{HasShape()},\texttt{IsInfinite()}, o \texttt{sizeUnknown()}, según convenga \\
\hline
\texttt{iteratoreltype(IterType)} & \texttt{HasEltype()} & Uno de \texttt{EltypeUnknown()} o \texttt{HasEltype()}, según convenga \\
\hline
\texttt{eltype(IterType)} & \texttt{Any} & El tipo de los ítems devueltos por \texttt{next()} \\
\hline
\texttt{length(iter)} & (\emph{indefinido}) & El número de ítems, si es conocido \\
\hline
\texttt{size(iter, [dim...])} & (\emph{indefinido}) & El número de ítems en cada dimensión, si es conocido \\
\hline
\end{tabulary}

\end{table}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Valor devuelto por \texttt{iteratorsize(IterType)} & Métodos requeridos \\
\hline
\texttt{HasLength()} & \texttt{length(iter)} \\
\hline
\texttt{HasShape()} & \texttt{length(iter)}  and \texttt{size(iter, [dim...])} \\
\hline
\texttt{IsInfinite()} & (\emph{ninguno}) \\
\hline
\texttt{SizeUnknown()} & (\emph{ninguno}) \\
\hline
\end{tabulary}

\end{table}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Valro devuelto por \texttt{iteratoreltype(IterType)} & Métodos requeridos \\
\hline
\texttt{HasEltype()} & \texttt{eltype(IterType)} \\
\hline
\texttt{EltypeUnknown()} & (\emph{ninguno}) \\
\hline
\end{tabulary}

\end{table}



La iteración secuencial es implementada mediante los métodos \hyperlink{1075601569170970796}{\texttt{start()}}, \hyperlink{6277510345882109527}{\texttt{done()}}, y \hyperlink{11903630693622759236}{\texttt{next()}}. En lugar de mutar objetos cuando se itera sobre ellos, Julia proporciona estos tres métodos que llevaqn la traza del estado de la iteración externamente al objeto. El método \texttt{start(iter)} devuvelve el estado inicial para un objeto iterable \texttt{iterd}. Este estado se pasa a lo largo de \texttt{done(iter, state)} que chequea si quedan más elementos, y \texttt{next(iter, state)} que devuelve una tupla que contiene el elemento y el estado actuales. El objeto \texttt{state}puede ser cualquier cosa, y suele ser considerado un detalle de implementación privado al objeto iterable.



Cualquier objeto que defina estos tres métodos es iterable y puede ser usado en las \hyperlink{405296213558195800}{muchas funciones que se basan en la iteración}. También puede ser usado directamente en un bucle for ya que la sintaxis:




\begin{minted}{julia}
for i in iter   # or  "for i = iter"
    # body
end
\end{minted}



es traducida por:




\begin{minted}{julia}
state = start(iter)
while !done(iter, state)
    (i, state) = next(iter, state)
    # body
end
\end{minted}



Un ejemplo sencillo es una secuencia iterable de cuadrados de número con una longitd definida:




\begin{lstlisting}
julia> struct Squares
           count::Int
       end

julia> Base.start(::Squares) = 1

julia> Base.next(S::Squares, state) = (state*state, state+1)

julia> Base.done(S::Squares, state) = state > S.count

julia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type

julia> Base.length(S::Squares) = S.count
\end{lstlisting}



Con sólo las definiciones de \hyperlink{1075601569170970796}{\texttt{start}}, \hyperlink{11903630693622759236}{\texttt{next}}, y \hyperlink{6277510345882109527}{\texttt{done}}, el tipo \texttt{Squares} es ya muy poderoso. Podemos iterar sobre todos los elementos:




\begin{lstlisting}
julia> for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49
\end{lstlisting}



Podemos usar muchos de los métodos predefinidos que trabajan con iterables, como \hyperlink{17277603976666670638}{\texttt{in()}}, \hyperlink{2002825322838319654}{\texttt{mean()}} y \hyperlink{8821409723106968118}{\texttt{std()}}:




\begin{lstlisting}
julia> 25 in Squares(10)
true

julia> mean(Squares(100))
3383.5

julia> std(Squares(100))
3024.355854282583
\end{lstlisting}



Hay unos pocos más métodos que se pueden extender para dar a Julia más información sobre esta colección iterable. Se sabe que todos los elementos en una secuencia \texttt{Squares} serán \texttt{Int}. Extendiendo el método  \hyperlink{6396209842929672718}{\texttt{eltype()}} method, se puede proporcionar esta información a Julia y ayudarlo a hacer código más especializado en métodos más complicados. También se sabe el número de elementos de esa secuencia, por loq ue también se pude extender \hyperlink{3699181304419743826}{\texttt{length()}}.



Ahora, cuando pedimos a Julia que \hyperlink{6278865767444641812}{\texttt{collect()}} todos los elementos en un array ella puede preasignar un \texttt{Vector\{Int\}} en la parte derecha de la expresión, en lugar de ir poniendo a ciegas mediante \hyperlink{18026893834387542681}{\texttt{push!}}ing cada elemento en un \texttt{Vector\{Any\}}.




\begin{lstlisting}
julia> collect(Squares(10))' # transposed to save space
1×10 RowVector{Int64,Array{Int64,1}}:
 1  4  9  16  25  36  49  64  81  100
\end{lstlisting}



Aunque podemos confiar en las implementaciones genéricas, podemos también extender métodos específicos donde sepamos que hay un algoritmo más simple. Por ejemplo, he aquí una fórmula para sobreescribir la versión iterativa para una solución más eficiente:




\begin{lstlisting}
julia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia> sum(Squares(1803))
1955361914
\end{lstlisting}



Este es un patrón muy común a través de la librería estándar de Julia: un pequeño conjunto de métodos requeridos definen una interfaz informal que permite muchos comportamientos muy atractivos. En algunos casos, los tipos que quieran especializar esos comportamientos extra cuando saben que existe un algoritmo más eficiente que podrán usar en su caso específico.



\hypertarget{13083166413584762822}{}


\section{Indexación}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Métodos a implementar & Breve descripción \\
\hline
\texttt{getindex(X, i)} & \texttt{X[i]}, acceso indexado a elemento \\
\hline
\texttt{setindex!(X, v, i)} & \texttt{X[i] = v}, asignación indexada \\
\hline
\texttt{endof(X)} & El último índice, usado en \texttt{X[end]} \\
\hline
\end{tabulary}

\end{table}



Para el iterable \texttt{Squares} anterior, podemos calcular fácilmente el i-ésimo elemento de la secuencia elevándolo al cuadrado. Pordemos exponer esto como una expresión de indexación \texttt{S[i]}. Para optar a ese comportamiento, \texttt{Squares} sólo tieen que definir \hyperlink{2839226020402435013}{\texttt{getindex()}}:




\begin{lstlisting}
julia> function Base.getindex(S::Squares, i::Int)
           1 <= i <= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia> Squares(100)[23]
529
\end{lstlisting}



Adicionalmente, para soportar la sintaxis \texttt{S[end]}, debemos definir \hyperlink{7288835006555308491}{\texttt{endof()}} para especificar el último índice válido:




\begin{lstlisting}
julia> Base.endof(S::Squares) = length(S)

julia> Squares(23)[end]
529
\end{lstlisting}



Tenga en cuenta, sin embargo, que lo anterior \emph{sólo} define \hyperlink{2839226020402435013}{\texttt{getindex()}} con un índice entero. Indexar con cualquier cosa que no sea un \texttt{Int} lanzará un  \hyperlink{14644228586476494020}{\texttt{MethodError}} diciendo que no había ningún método coincidente. Para soportar la indexación con intervalos o vectores de \texttt{Int}s, se deben escribir métodos separados:




\begin{lstlisting}
julia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia> Base.getindex(S::Squares, I) = [S[i] for i in I]

julia> Squares(10)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25
\end{lstlisting}



Aunque que esto está comenzando a soportar más de las \hyperlink{14469287548874312017}{operaciones de indexación soportadas por algunos de los tipos incorporados}, todavía hay un buen número de comportamientos ausentes. Esta secuencia \texttt{Squares} está empezando a parecer más y más como un vector, ya que hemos añadido comportamientos a la misma. En lugar de definir todos estos comportamientos nosotros mismos, podemos definirlos oficialmente como un subtipo de un \hyperlink{6514416309183787338}{\texttt{AbstractArray}}.



\hypertarget{522338241536202486}{}


\section{Abstract Arrays}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Metodos a implementar                           &                                         & Breve descripción                                                                  \\
\hline
\texttt{size(A)} &   & Devuelve una tupla que contiene las dimensiones de \texttt{A} \\
\hline
\texttt{getindex(A, i::Int)} &   & (if \texttt{IndexLinear}) Linear scalar indexing \\
\hline
\texttt{getindex(A, I::Vararg\{Int, N\})} &   & (if \texttt{IndexCartesian}, where \texttt{N = ndims(A)}) N-dimensional scalar indexing \\
\hline
\texttt{setindex!(A, v, i::Int)} &   & (if \texttt{IndexLinear}) Scalar indexed assignment \\
\hline
\texttt{setindex!(A, v, I::Vararg\{Int, N\})} &   & (if \texttt{IndexCartesian}, where \texttt{N = ndims(A)}) N-dimensional scalar indexed assignment \\
\hline
\textbf{Optional methods} & \textbf{Default definition} & \textbf{Brief description} \\
\hline
\texttt{IndexStyle(::Type)} & \texttt{IndexCartesian()} & Returns either \texttt{IndexLinear()} or \texttt{IndexCartesian()}. See the description below. \\
\hline
\texttt{getindex(A, I...)} & defined in terms of scalar \texttt{getindex()} & \hyperlink{14469287548874312017}{Multidimensional and nonscalar indexing} \\
\hline
\texttt{setindex!(A, I...)} & defined in terms of scalar \texttt{setindex!()} & \hyperlink{14469287548874312017}{Multidimensional and nonscalar indexed assignment} \\
\hline
\texttt{start()}/\texttt{next()}/\texttt{done()} & defined in terms of scalar \texttt{getindex()} & Iteration \\
\hline
\texttt{length(A)} & \texttt{prod(size(A))} & Number of elements \\
\hline
\texttt{similar(A)} & \texttt{similar(A, eltype(A), size(A))} & Return a mutable array with the same shape and element type \\
\hline
\texttt{similar(A, ::Type\{S\})} & \texttt{similar(A, S, size(A))} & Return a mutable array with the same shape and the specified element type \\
\hline
\texttt{similar(A, dims::NTuple\{Int\})} & \texttt{similar(A, eltype(A), dims)} & Return a mutable array with the same element type and size \emph{dims} \\
\hline
\texttt{similar(A, ::Type\{S\}, dims::NTuple\{Int\})} & \texttt{Array\{S\}(dims)} & Return a mutable array with the specified element type and size \\
\hline
\textbf{Non-traditional indices} & \textbf{Default definition} & \textbf{Brief description} \\
\hline
\texttt{indices(A)} & \texttt{map(OneTo, size(A))} & Return the \texttt{AbstractUnitRange} of valid indices \\
\hline
\texttt{Base.similar(A, ::Type\{S\}, inds::NTuple\{Ind\})} & \texttt{similar(A, S, Base.to\_shape(inds))} & Return a mutable array with the specified indices \texttt{inds} (see below) \\
\hline
\texttt{Base.similar(T::Union\{Type,Function\}, inds)} & \texttt{T(Base.to\_shape(inds))} & Return an array similar to \texttt{T} with the specified indices \texttt{inds} (see below) \\
\hline
\end{tabulary}

\end{table}



Si un tipo se define como subtipo de \texttt{AbstractArray}, hereda un conjunto muy grande de comportamientos ricos, incluyendo la iteración y la indexación multidimensional construida sobre el acceso de un solo elemento. Consulte la \hyperlink{12380164357355707963}{página de manual sobre arrays} y la \hyperlink{14629781252390713372}{sección de la biblioteca estándar} para más métodos soportados.



Una parte clave en la definición de un subtipo de \texttt{AbstractArray} es \hyperlink{7782790551324367092}{\texttt{IndexStyle}}.Dado que la indexación es una parte tan importante de una matriz y que a menudo se produce en los bucles en caliente, es importante que tanto la indexación y la asignación indexada sean lo más eficientes posible. Las estructuras de datos array se suelen definir de dos maneras: o bien accede de forma más eficaz a sus elementos utilizando sólo un índice (indexación lineal) o  accede intrínsecamente a los elementos con índices especificados para cada dimensión. Estas dos modalidades son identificadas por Julia como \texttt{IndexLinear()} e \texttt{IndexCartesian()}. La conversión de un índice lineal en subíndices de indexación múltiples suele ser muy costosa, por lo que esto proporciona un mecanismo basado en tratos para permitir un código genérico eficiente para todos los tipos de matriz.



Esta distinción determina qué métodos de indexación escalar debe definir cada tipo. Los arrays \texttt{IndexLinear()} son sencillos: sólo definen \texttt{getindex(A::ArrayType, i::Int)}. Cuando el array se indexa posteriormmente con un conjunto multidimensional de índices, el método de respaldo \texttt{getindex(A::AbstractArray, I...)()} convierte eficientemente los indices en un indice lineal y luego llama al metodo anterior. Los arrays \texttt{IndexCartesian()}, por otra parte,  requieren que se definan métodos para cada dimensionalidad soportada con \texttt{ndims(A)} índices Int. Por ejemplo, el tipo \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} incorporado sólo admite dos dimensiones, por lo que sólo define \texttt{getindex(A::SparseMatrixCSC, i::Int, j::Int)}. Lo mismo sucede para \texttt{setindex!()}.



Volviendo a la secuencia de cuadrados de arriba, podríamos definirla como un subtipo de un \texttt{AbstractArray\{Int, 1\}}:




\begin{lstlisting}
julia> struct SquaresVector <: AbstractArray{Int, 1}
           count::Int
       end

julia> Base.size(S::SquaresVector) = (S.count,)

julia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()

julia> Base.getindex(S::SquaresVector, i::Int) = i*i
\end{lstlisting}



Note que es muy importante especificar los dos parámetros del \texttt{AbstractArray}; la primera define el tipo de elemento  \hyperlink{6396209842929672718}{\texttt{eltype()}}, y la segunda el número de dimensiones \hyperlink{1688406579181746010}{\texttt{ndims()}}. Este supertipo y sus tres métodos son todo lo que hace falta para que \texttt{SquaresVector} sea un array iterable, indexable y completamente funcional:




\begin{lstlisting}
julia> s = SquaresVector(7)
7-element SquaresVector:
  1
  4
  9
 16
 25
 36
 49

julia> s[s .> 20]
3-element Array{Int64,1}:
 25
 36
 49

julia> s \ [1 2; 3 4; 5 6; 7 8; 9 10; 11 12; 13 14]
1×2 Array{Float64,2}:
 0.305389  0.335329

julia> s ⋅ s # dot(s, s)
4676
\end{lstlisting}



Un ejemplo un poco más complicado. definamos nuestro propio tipo array \emph{sparse} N-dimensional {\textquotedbl}de juguete{\textquotedbl}, construído encima de \hyperlink{3089397136845322041}{\texttt{Dict}}:




\begin{lstlisting}
julia> struct SparseArray{T,N} <: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia> SparseArray{T}(::Type{T}, dims::Int...) = SparseArray(T, dims);

julia> SparseArray{T,N}(::Type{T}, dims::NTuple{N,Int}) = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia> Base.size(A::SparseArray) = A.dims

julia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)
\end{lstlisting}



Observe que se trata de un array  \texttt{IndexCartesian} array, , por lo que debemos definir manualmente \hyperlink{2839226020402435013}{\texttt{getindex()}} y \hyperlink{17903591429492118749}{\texttt{setindex!()}} en la dimensionalidad de la matriz. En este caso, a diferencia de en \texttt{SquaresVector}, somos capaces de definir  \hyperlink{17903591429492118749}{\texttt{setindex!()}} y, en consecuencia, podemos mutar el array:




\begin{lstlisting}
julia> A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> fill!(A, 2)
3×3 SparseArray{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia> A[:] = 1:length(A); A
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0
\end{lstlisting}



El resultado de la indexación de un \texttt{AbstractArray} puede ser en sí mismo un array (por ejemplo, al indexar por un rango). Los métodos de respaldo de \texttt{AbstractArray} utilizan \hyperlink{18368531196314541873}{\texttt{similar()}} para asignar un \texttt{Array} del tamaño y tipo de elemento apropiados, que se rellena usando el método de indexación básico descrito anteriormente. Sin embargo, al implementar un \emph{wrapper} de array, a menudo deseamos que el resultado sea también un \emph{wrapper}:




\begin{lstlisting}
julia> A[1:2,:]
2×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
\end{lstlisting}



En este ejemplo esto se logra mediante la definición de \texttt{Base.similar\{T\}(A::SparseArray, :: Type\{T\}, dims::Dims)} para crear la matriz wrapped apropiada. (Tenga en cuenta que aunque \texttt{similar} soporta formas de 1 y 2 argumentos, en la mayoría de los casos sólo necesita especializar el formulario de 3 argumentos). Para que esto funcione es importante que \texttt{SparseArray} sea mutable (soporte \texttt{setindex!}). Definir \texttt{similar()}, \texttt{getindex()} y \texttt{setindex!()} para \texttt{SparseArray} también hace posible copiar el array mediante \hyperlink{15665284441316555522}{\texttt{copy()}}:




\begin{lstlisting}
julia> copy(A)
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0
\end{lstlisting}



Además de todos los métodos iterables e indexables de arriba, estos tipos también pueden interactuar entre sí y utilizar todos los métodos definidos en la biblioteca estándar para \texttt{AbstractArrays}:




\begin{lstlisting}
julia> A[SquaresVector(3)]
3-element SparseArray{Float64,1}:
 1.0
 4.0
 9.0

julia> dot(A[:,1],A[:,2])
32.0
\end{lstlisting}



Si está definiendo un tipo de array que permite la indexación no tradicional (índices que comienzan en algo distinto de 1), debe especializar \texttt{indices}. También debe especializarse \hyperlink{18368531196314541873}{\texttt{similar}} para que el argumento \texttt{dims} (normalmente una tupla de tamaños \texttt{Dims}) pueda aceptar objetos \texttt{AbstractUnitRange}, tal vez rango-tipos \texttt{Ind} de su propio diseño. Para obtener más información, vea \hyperlink{12792533311031776054}{Arrays con índices personalizados}.



\hypertarget{10438697863683890874}{}


\chapter{Módulos}



Los módulos en Julia son espacio de trabajo de variables separados, es decir, ellos introducen un nuevo ámbito global. Ellos están delimitados sintácticamente dentro de \texttt{module Nombre ... end}. Los módulos nos permiten crear definiciones de nivel superior (o  variables globales) sin preocuparnos sobre conflictos de nombres cuando estamos usando nuestro código con cualquier otro. Dentro de un módulo, podemos controlar qué nombres de otros módulos son visibles (vía importación) y especificar cúales de nuestros nombres queremos que sean públicos (vía exportación). 



El siguiente ejemplo muestra las principales características de los módulos. No está destinado para ser ejecutado, sino que se muestra para propósitos ilustrativos:




\begin{minted}{julia}
module MyModule
using Lib

using BigLib: thing1, thing2

import Base.show

importall OtherLib

export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1

show(io::IO, a::MyType) = print(io, "MyType $(a.x)")
end
\end{minted}



Notese que el estilo es no indentar el cuerpo del módulo, ya que esto llevaría a que el fichero completo estuviera indentado.



Este módulo define un tipo \texttt{MyType} y dos funciones. Las funciones \texttt{foo} y \texttt{MyType} son exportadas y, en consecuencia, estará disponibles para ser importadas en otros módulos. La función \texttt{bar} es privada a \texttt{MyModule}.



La instrucción \texttt{using Lib} significa que un módulo llamado \texttt{Lib} estará disponible para resover nombres cuando se necesite. Cuando se encuentra que una variable no tiene definición en el módulo actual, el sistema la buscará entre las variables exportadas por \texttt{Lib} y la importará si la encuentra allí. Esto significa que todos los usos de esta global dentro del módulo actual resoverá a la definición de esta variable en \texttt{Lib}.



La instrucción \texttt{using BigLib: thing1, thing2} es una abreviación sintáctica de \texttt{using BigLib.thing1, BigLib.thing2}.



La palabra clave \texttt{import} soporta la misma sintaxis que \texttt{using}, pero sólo opera sobre un solo nombre cada vez. Ella no añade módulos para ser buscados de la forma que lo hace \texttt{using}. También difiere de \texttt{using} en que las funciones deben ser importandas mediante \texttt{import} para ser extendidas con nuevos métodos.



En el jemplo anterior \texttt{MyModule} deseamos añadir un método a la función estándar \texttt{show}, por lo que tenemos que escribir \texttt{import Base.show}. Las funciones cuyos nombres son sólo visibles via \texttt{using} no pueden ser extendidas.



La palabra clave \texttt{importall} importa explícitamente todos los nombres exportados por el módulo especificado, con si se hubiera usado \texttt{import} individualmente sobre cada uno de ellos.



Una vez que una variable se ha hecho visible vía \texttt{using} o \texttt{import}, un módulo puede no crear su propia variable con el mismo nombre. Las variables importadas son de solo lectura; asignar a una variable global siempre afecta a una variable propiedad del módulo actual, o si no causar un error.



\hypertarget{10437030659535959981}{}


\section{Resumen de uso de los módulos}



Para cargar un módulo, pueden usarse dos palabras clave principales: \texttt{using} e \texttt{import}. Para comprender sus diferencias, considérese el siguiente ejemplo:




\begin{minted}{julia}
module MyModule

export x, y

x() = "x"
y() = "y"
p() = "p"

end
\end{minted}



En este módulo exportamos las funciones \texttt{x} e \texttt{y} (con la palabra clave \texttt{export}) y también tenemos la función no exportada \texttt{p}. Hay varias diferentes formas de cargar el mósulo y sus funciones internas en el espacio de trabajo actual:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Mandato de importación & Qué se introduce en el ámbito & Disponible para extensión de método \\
\hline
\texttt{using MyModule} & All \texttt{export}ed names (\texttt{x} and \texttt{y}), \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} & \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} \\
\hline
\texttt{using MyModule.x, MyModule.p} & \texttt{x} and \texttt{p} &   \\
\hline
\texttt{using MyModule: x, p} & \texttt{x} and \texttt{p} &   \\
\hline
\texttt{import MyModule} & \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} & \texttt{MyModule.x}, \texttt{MyModule.y} and \texttt{MyModule.p} \\
\hline
\texttt{import MyModule.x, MyModule.p} & \texttt{x} and \texttt{p} & \texttt{x} and \texttt{p} \\
\hline
\texttt{import MyModule: x, p} & \texttt{x} and \texttt{p} & \texttt{x} and \texttt{p} \\
\hline
\texttt{importall MyModule} & All \texttt{export}ed names (\texttt{x} and \texttt{y}) & \texttt{x} and \texttt{y} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{2756255113077741316}{}


\subsection{Módulos y ficheros}



Los ficheros y los nombres de ficheros no están relacionados con los módulos. Los módulos están asociados sólo con las expresiones \texttt{module}. Uno puede tener múltiples ficheros por módulo, y múltiples módulos por fichero:




\begin{minted}{julia}
module Foo

include("file1.jl")
include("file2.jl")

end
\end{minted}



Incluir el mismo código en módulos diferentes porporciona un comportamiento similar a la mezcla. Uno podría usar esto para ejecutar el mismo código con diferentes definiciones base, por ejemplo, código de test ejecutando una versión {\textquotedbl}segura{\textquotedbl} de algunos operadores:




\begin{minted}{julia}
module Normal
include("mycode.jl")
end

module Testing
include("safe_operators.jl")
include("mycode.jl")
end
\end{minted}



\hypertarget{11050023426399630284}{}


\subsection{Módulos estándar}



Hay tres módulos estándar importantes: Main, Core y Base.



\texttt{Main} es el módulo de nivel superior, y Julia arranca con Main fijado como módulo actual. Las variables definidas en el prompt van a Main, y \texttt{whos()} lista las variables en Main. 



\texttt{Core} contiene todos los identificadores considerados predefinidos en el lenguaje, por ejemplo, parte del lenguaje y no librerías. Cada módulo especifica implícitamente \texttt{using Core}, ya que uno no puede hacer nada sin sus definiciones.



\texttt{Base} es la librería estándar (los contenidos de \texttt{base/}). Todos los módulos contiene implícitamente \texttt{using Base}, ya que este se necesita en la gran mayoría de los casos.



\hypertarget{18386862204765796708}{}


\subsection{Definiciones de nivel superior por defecto y módulos esenciales (\emph{bare})}



Además de a \texttt{using Base}, los módulos también contiene automáticamente una definició de la función \texttt{eval}, que evalúa expresiones dentro del contexto de este módulo.



Si estas definiciones por defecto no son deseadas, los módulos pueden ser definidos usando la palabra clave \texttt{baremodule}(nota: \texttt{Core} sigue siendo importando, como antes). En términos de \texttt{baremodule} un módulo estándar tiene este aspecto.




\begin{lstlisting}
baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
eval(m,x) = Core.eval(m, x)

...

end
\end{lstlisting}



\hypertarget{5020449785991045252}{}


\subsection{Caminos absolutos y relativos de módulos}



Dada la instrucción \texttt{using Foo}, el sistema buscará \texttt{Foo} dentro de \texttt{Main}. Si el módulo no existe, el sistema interará un \texttt{require({\textquotedbl}Foo{\textquotedbl})} que típicamente da como resultado cargar código desde un paquete instalado. 



Sin embargo, algunos módulos contienen submódulos, lo que significa que tu algunas veces tienes que acceder a un módulo que no está directamente disponible en \texttt{Main}. Hay dos formas de hacer esto. La primera es usar un camino absoluto, por ejemplo \texttt{using Base.Sort}. El segundo es usar un camino relativo, que hace más fácil importar submódulos del módulo actual o alguno de sus módulos adjuntos:




\begin{lstlisting}
module Parent

module Utils
...
end

using .Utils

...
end
\end{lstlisting}



Aquí, el módulo \texttt{Parent} contiene un submódulo \texttt{Utils} y el código en \texttt{Parent} quiere que el contenido de \texttt{Utils} esté visible. Este se consigue empezando la instrucción \texttt{using} con un punto. Ada punto adicional añadido se muevo hacia arriba niveles adicionales en la jerarquía de módulos. Por ejemplo, \texttt{using ..Utils} buscaría en el módulo que contiene a \texttt{Parent}, no en el propio \texttt{Padre}.



Notese que los cualificadores de importación relativos son sólo válidos para las instrucciones \texttt{uing} e \texttt{import}.



\hypertarget{12125908108187698688}{}


\subsection{Caminos de ficheros de módulo}



La variable global \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}} contiene los directorios donde Julia busca módulos cada vez que se invoca \texttt{require}. Esto puede extenderse usandog \hyperlink{18026893834387542681}{\texttt{push!}}:




\begin{minted}{julia}
push!(LOAD_PATH, "/Path/To/My/Module/")
\end{minted}



Aquí, el módulo \texttt{Parent} contiene un submódulo \texttt{Utils} y el código en \texttt{Parent} quiere que el contenido de \texttt{Utils} esté visible. Este se consigue empezando la instrucción \texttt{using} con un punto. Ada punto adicional añadido se muevo hacia arriba niveles adicionales en la jerarquía de módulos. Por ejemplo, \texttt{using ..Utils} buscaría en el módulo que contiene a \texttt{Parent}, no en el propio \texttt{Padre}.



Notese que los cualificadores de importación relativos son sólo válidos para las instrucciones \texttt{uing} e \texttt{import}.



\hypertarget{3639122993966935000}{}


\subsection{Caminos de ficheros de módulo}



La variable global \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}} contiene los directorios donde Julia busca módulos cada vez que se invoca \texttt{require}. Esto puede extenderse usandog \hyperlink{18026893834387542681}{\texttt{push!}}:




\begin{minted}{julia}
push!(LOAD_PATH, "/Path/To/My/Module/")
\end{minted}



Poniendo esta instrucción en el ficehro \texttt{{\textasciitilde}/.juliarc.jl} extenderemos la variable \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}} on every Julia startup. en cada arranque de Julia. Alternativamente, el camino de carga de módulos puede ser extendido definiendo la variable de entorno \texttt{JULIA\_LOAD\_PATH}.



\hypertarget{8537791013955054606}{}


\subsection{Miscelánea sobre espacios de nombres}



Si un nombre está cualificado (por ejemplo \texttt{Base.sin}) entonces puede ser accedido incluso aunque no esté exportado. Esto es bastante útil de cara a depuración.



También puede haber métodos agregados al usar el nombre calificado como el nombre de la función. Sin embargo, debido a las ambigüedades sintácticas que surgen, si uno desea agregar métodos a una función en un módulo diferente cuyo nombre contiene solo símbolos, tal como un operador (por ejemplo, \texttt{Base.+}), debe usar la notación \texttt{Base.:+} para referirse a él. Si el operador tiene más de un carácter de longitud, debe rodearlo entre paréntesis, por ejemplo: \texttt{Base.:(==)}.



Los nombres de macros se escriben con \texttt{@} en las instrucciones de importación y exportación. Por ejemplo, \texttt{import Mod.@mac}. Las macros en otros módulos pueden ser invocadas como \texttt{Mod.@mac} or \texttt{@Mod.mac}.



La sintaxis \texttt{M.x=y} no funciona para asignar una variable global en otro módulo: la asignación global es siempre local a un módulo.



Una variable puede estar {\textquotedbl}reservada{\textquotedbl} por el módulo actual sin asignar a ella declarándola como \texttt{global x} en el nivel superior. Esto puede usarse para prevenir conflictos de nombreas para globales inicializadas después del tiempo de carga.



\hypertarget{16564935669398681292}{}


\subsection{Inicialización y precompilación de módulos}



Los módulos grandes puede necesitar varios segundos para cargar, debido a que ejecutar todas las instrucciones en un módulo implica compilar una gran candidad de código. Julia proporciona la capacidad de crear versiones precompiladas de los módulos para reducir este timepo.



Para crear un fichero de módulo precompilado incremental, añadimos \texttt{\_\_precompile--()} al principio de nuestro fichero de módulo (antes de que empiece la palabra \texttt{module}). Esto causará que él sea compilado automáticamente la primera vez que se importe. Alternativamete, podemos llamar a \texttt{Base.compilecache(modulename)}.  Los ficheros caché resultantes se almacenarán en \texttt{Base.LOAD\_CACHE\_PATH[1]}. Posteriormente, el módulo es recompilado automáticamente con \texttt{import} cada vez que alguna de sus dependencia cambia; las dependencias son módulos en imports, la construcción de Julia, los ficheros que incluye, o dependencias explícitas declaradas con \texttt{include\_dependency(path)} en el fichero o ficheros de módulo.



Para dependencias de fichero, un cambio se determina examinando si el momento de modificación (mtime) de cada fichero cargado por \texttt{include} o añadido explícitamente mediante \texttt{include\_dependency} está sin cambios o igual al tiempo de modificaci´no truncado al segundo más cercano (para acomodar sistemas que no pueden copiar mtime con exactitud menor que el segundo). También se tiene en cuenta si el camino al fichero elegido por la lógica de búsqueda en \texttt{require} se corresponde con el camino que había creado el fichero precompilado.



También se tiene en cuenta el conjunto de dependencias ya cargadas en el proceso actual y no recompilará esos módulos, incluso si sus ficheros cambian o desaparecen, para evitar crear incompatibilidades entre el sistema en ejecución y la caché precompilada. I queremos tener cambios en la fuente reflejados en el sistema en ejecución, deberíamos llamar a \texttt{reload({\textquotedbl}Module{\textquotedbl})} sobre el módulo que hemos cambiado, y cualquier módulo que dependa de él en el cuál quieres ver reflejado el cambio.



Precompilar un módulo también recursivamente precompila todo los módulos que son importados allí. Si sabemos que no es seguro precompilar nuestor módulo (por las razones descritas debajo) deberíamos poner \texttt{\_\_precompile\_\_(false)} en el fichero del módulo para causar que \texttt{Base.compilecache} lance un error (y por tanto evite que el módulo sea importado por cualquier otro módulo precompilado.



\texttt{\_\_precompile} \textbf{NO} debería ser usado en un módulo a menos que todas sus dependencias estén también usando \texttt{\_\_precompile\_\_()}. Un fallo en hacer esto puede dar como resultado un error en tiempo de ejecución cuando se carga el módulo.



Para hacer que nuestro módulo funcione con la precompilación, sin embargo, necesitamos cambiar nuestro módulo para separar explícitamente cualquier paso de inicialización que deba ocurrir en tiempo de ejecución de pasos que pueden ocurrir en tiempo de compilación. Para este propósito, Julia te permite definir una función \texttt{\_\_init\_\_()} en tu módulo que ejecuta cualquier paso de  inicialización que deba tener lugar en tiempo de ejecución. Esta función no será llaada durante la compilación (\texttt{--ouput-*} o \texttt{\_\_precompile\_\_()}). Podemos, por supuesto, llamarla manualmente si es necesario, pero el comportamiento por defecto es asumir que esta función trata con el estado de computación para la máquina local, que no necesita ser (o incluso no debe ser) capturada en la imagen compilada. Ella puede ser llamada después de que el módulo sea cargado en un proceso, incluyendo si el está siendo cargado en una compilación incremental (\texttt{--output-incremental=yes}), pero no si está siendo cargado en un proceso de compilación completo. 



En particular, si defines un \texttt{function \_\_init\_\_()} en un módulo, entonces Julia llamará a \texttt{\_\_init\_\_()} inmediatamente después de que el módulo se cargue (es decir, mediante \texttt{import}, \texttt{using} o \texttt{require}) en tiempo de ejecución la \emph{primera} vez (es decir, \texttt{\_\_init\_\_} sólo es llamado una vez, y sólo después de que todas las instrucciones en el módulo se hayan ejecutado). Como el es llamado después de que el módulo sea importado por completo, los submódulos u otros módulos importandos tienen sus funciones \texttt{\_\_init\_\_}llamadas antes del \texttt{\_\_init\_\_}del módulo contenedor.



Dos usos típicos de \texttt{\_\_init\_\_} son llamar a funciones de inicialización en tiempo de ejecución de librerías externas en C e inicializar constantes globales que implican punteros devueltos por las librerías externas. Por ejemplo, supongamos que estamos llamado a una librería en C \texttt{libfoo} que requiere que llamemos a la función de inicialización \texttt{foo\_init()} en tiempo de ejecución. Supongamos que también queremos definir una constante global \texttt{foo\_data\_ptr} que almacena el valor de retorno de una función \texttt{void *foo\_data()} definida por \texttt{libfoo} (esta constante tiene que se inicializada en tiempo de ejecución - no de compilación- debido a que el puntero cambiará de una ejecución a otra). Podríamos conseguir esto definiendo la siguiente función \texttt{\_\_init\_\_}en nuestro módulo:




\begin{minted}{julia}
const foo_data_ptr = Ref{Ptr{Void}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Void, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Void}, ())
end
\end{minted}



Notese que es perfectamente posible definir un global dentro de la función como \texttt{\_\_init\_\_}; esta es una de las ventajas de usar un lenguaje dinámico. Pero haciéndolo una constante en un ámbito global, podemos asegurar que el tipo es conocido al compilador y le permite generar código mejor optimizado. Obviamente, otros globales de nuestro módulo que dependan de \texttt{foo\_data\_ptr} también tendrían que ser inicializados en \texttt{\_\_init\_\_}.



Las constantes que implican a la mayoría de los objetos Julia que no son producidas por \texttt{ccall} no necesitan se colocadas en \texttt{\_\_init\_\_}: sus definiciones pueden ser precompiladas y cargadas desde la imagen cacheada del módulo. Esto incluye complicados objetos alojados en el montón (\emph{heap}) como los arrays. Sin embargo, cualquier rutina que devuelva un calor de puntero crudo debe ser llamada en tiempo de ejecución para que la precompilación funcione (los objetos Ptr se convertirán en punteros nulos a menos que sean ocultados dentro de un objeto isbits). Esto incluye los valore de retorno de las funciones Julia \texttt{cfunction} y  \texttt{pointer}.



Los tipos diccionario y conjunto, o en general cualquiera que dependa de la salida de un método \texttt{hash(key)}, son un caso más difícil. En el caso común de que las claves sean números, cadenas, símbolos, rangos, \texttt{Expr} o composiciones de estos tipos (vía arraysm, tuplas, conjuntos, pares, etc.) son seguros de precompilar. Sin embargo, para otros tipos clave, tales como \texttt{Function} o \texttt{DataType} y tipos genéricos definidos por el usuario donde no se ha definido un método \texttt{hash} el método \texttt{hash} de apoyo depende de la dirección en memoria del objeto (vía su \texttt{object\_id}) y por tanto puede cambiar de ejecución a ejecución. Si tienes uno de esos tipos como clave, o no estás seguro, puedes inicializar este diccionario desde dentro de tu función \texttt{\_\_init\_\_} para mayor seguridad. Alternativamente, puedes usar el tipo diccionario \texttt{ObjectIdDict}, que es especialmente manejado por precompilación por lo que es seguro de inicializar en tiempo de compilación.



Cuando se usa precompilación, es importante mantener un claro sentido de la distinción entre la fase de compilación y la de ejecución. En este modo, a menudo será mucho más evidente que Julia es un compilador que permite la ejecución de código arbitrario Julia, no un intérprete independiente que también genera código compilado.



Otros escenarios de fallo potencial conocidos incluyen:



\begin{itemize}
\item[1. ] Contadores globales (por ejemplo, para intentar identificar objetos únicamente). Considere el siguiente código:


\begin{minted}{julia}
mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end
\end{minted}

mientras que la intención de este código era dar a cada instancia un id único, el valor del contador es grabado al final de la compilación. Todos los usos posteriores de este módulo compilado incrementalmente empezarán desde el mismo valor de contador.

\end{itemize}


Note que \texttt{object\_if} (que trabaja haciendo \emph{hash} en el puntero a memoria) tieen problemas similares (ver las notas sobre el uso de \texttt{Dict} abajo).



One alternative is to store both \hyperlink{14046118357995428445}{\texttt{current\_module()}} and the current \texttt{counter} value, sin embargo, puede ser mejor rediseñar el código para no depender de este estado global.



\begin{itemize}
\item[2. ] Las colecciones asociativas (tales como \texttt{Dict} y \texttt{Set}) necesitan ser re-hasheadas en \texttt{\_\_init\_\_} (en el futuro,  puede proporcionarse un mecanismo para registrar un inicializador de función).


\item[3. ] Dependiendo de los efectos secundarios de tiempo de compilación que persisten a través del tiempo de carga. El  ejemplo incluye: modificar arrays u otras variables en otros módulos de Julia; mantener manejadores para abrir  archivos o dispositivos; almacenar punteros a otros recursos del sistema (incluyendo memoria);


\item[4. ] Crear {\textquotedbl}copias{\textquotedbl} accidentales de estado global desde otro módulo, haciendo referencia directamente a él en vez de  a través de su ruta de búsqueda. Por ejemplo, (en el ámbito global).


\begin{minted}{julia}
#mystdout = Base.STDOUT #= will not work correctly, since this will copy Base.STDOUT into this module =#
# instead use accessor functions:
getstdout() = Base.STDOUT #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.STDOUT #= also works =#
\end{minted}

\end{itemize}


Varias restricciones adicionales se colocan sobre las operaciones que se pueden hacer mientras se precompila el código para ayudar al usuario a evitar otras situaciones de comportamiento incorrecto:



\begin{itemize}
\item[1. ] Llamar \hyperlink{2345597220715550879}{\texttt{eval}} para provocar un efecto secundario en otro módulo. Esto también provocará que se emita una advertencia cuando se establece el indicador de precompilación incremental.


\item[2. ] Las sentencias \texttt{global consts} del ámbito local después de \texttt{\_\_init \_\_()} se han iniciado (vea el problema \#12010  para los planes de agregar un error para esto).


\item[3. ] Reemplazar un módulo (o llamar \hyperlink{7789928938295338947}{\texttt{workspace}}) es un error de tiempo de ejecución al realizar una  precompilación incremental.

\end{itemize}


Algunos otros puntos a tener en cuenta:



\begin{itemize}
\item[1. ] Ninguna recarga de código / invalidación de caché se realiza después de que se realizan cambios en los propios  archivos fuente (incluyendo \hyperlink{14197801802374863313}{\texttt{Pkg.update}}) y no se realiza ninguna limpieza después de \hyperlink{13989694063022152176}{\texttt{Pkg.rm}}.


\item[2. ] El comportamiento de compartir la memoria de una matriz reestructurada es ignorado por la precompilación (cada  vista obtiene su propia copia).


\item[3. ] Esperar que el sistema de archivos no cambie entre tiempo de compilación y tiempo de ejecución, p.ej  \hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}} / \texttt{source\_path()} para encontrar recursos en tiempo de ejecución, o la macro  BinDeps @checked\_lib. A veces esto es inevitable. Sin embargo, cuando sea posible, puede ser una buena práctica  copiar recursos en el módulo en tiempo de compilación para que no sea necesario encontrarlos en tiempo de ejecución.


\item[4. ] Los objetos \texttt{WeakRef} y los finalizadores no son manejados correctamente por el serializador (esto se arreglará  en una próxima versión).


\item[5. ] Por lo general, es mejor evitar la captura de referencias a instancias de objetos de metadatos internos como  \texttt{Method}, \texttt{MethodInstance}, \texttt{MethodTable}, \texttt{TypeMapLevel}, \texttt{TypeMapEntry} y campos de esos objetos, ya que esto  puede confundir al serializador y puede no conducir al resultado deseado. No es necesariamente un error hacer esto,  pero sólo tiene que estar preparado para que el sistema intente copiar algunos de ellos y crear una única instancia  única de otros.

\end{itemize}


A veces es útil durante el desarrollo del módulo para desactivar la precompilación incremental. El indicador de línea de comandos \texttt{--compilecache = \{yes | no\}} le permite activar y desactivar la precompilación del módulo. Cuando se inicia Julia con \texttt{--compilecache = no} se ignoran los módulos serializados en el caché de compilación al cargar módulos y dependencias de módulo. \texttt{Base.compilecache()} todavía se puede llamar manualmente y respetará las directivas \texttt{\_\_precompile\_\_()} para el módulo. El estado de este indicador de línea de comandos se pasa a \hyperlink{8295561239210722937}{\texttt{Pkg.build()}} para deshabilitar el desencadenamiento automático de precompilación al instalar, actualizar y crear explícitamente paquetes. updating, and explicitly building packages.



\hypertarget{12287408952024800641}{}


\chapter{Documentation}



Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.



The basic syntax is very simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called \emph{docstrings}). Here is a very simple example:




\begin{minted}{julia}
"Tell whether there are too foo items in the array."
foo(xs::Array) = ...
\end{minted}



Documentation is interpreted as \href{https://en.wikipedia.org/wiki/Markdown}{Markdown}, so you can use indentation and code fences to delimit code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one can construct other string macros and pass them to the \texttt{@doc} macro just as well.



Here is a more complex example, still using Markdown:




\begin{minted}{julia}
"""
    bar(x[, y])

Compute the Bar index between `x` and `y`. If `y` is missing, compute
the Bar index between all pairs of columns of `x`.

# Examples
```julia-repl
julia> bar([1, 2], [1, 2])
1
```
"""
function bar(x, y) ...
\end{minted}



As in the example above, we recommend following some simple conventions when writing documentation:



\begin{itemize}
\item[1. ] Always show the signature of a function at the top of the documentation, with a four-space indent so that it is printed as Julia code.

This can be identical to the signature present in the Julia code (like \texttt{mean(x::AbstractArray)}), or a simplified form. Optional arguments should be represented with their default values (i.e. \texttt{f(x, y=1)}) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. \texttt{f(x[, y])} and \texttt{f(x[, y[, z]])}). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a \texttt{<keyword arguments>} placeholder in the signature (i.e. \texttt{f(x; <keyword arguments>)}), and give the complete list under an \texttt{\# Arguments} section (see point 4 below).


\item[2. ] Include a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.

The one-line sentence should use the imperative form ({\textquotedbl}Do this{\textquotedbl}, {\textquotedbl}Return that{\textquotedbl}) instead of the third person (do not write {\textquotedbl}Returns the length...{\textquotedbl}) when documenting functions. It should end with a period. If the meaning of a function cannot be summarized easily, splitting it into separate composable parts could be beneficial (this should not be taken as an absolute requirement for every single case though).


\item[3. ] Do not repeat yourself.

Since the function name is given by the signature, there is no need to start the documentation with {\textquotedbl}The function \texttt{bar}...{\textquotedbl}: go straight to the point. Similarly, if the signature specifies the types of the arguments, mentioning them in the description is redundant.


\item[4. ] Only provide an argument list when really necessary.

For simple functions, it is often clearer to mention the role of the arguments directly in the description of the function{\textquotesingle}s purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an \texttt{\# Arguments} header, with one \texttt{-} bullet for each argument. The list should mention the types and default values (if any) of the arguments:


\begin{minted}{julia}
"""
...
# Arguments
- `n::Integer`: the number of elements to compute.
- `dim::Integer=1`: the dimensions along which to perform the computation.
...
"""
\end{minted}


\item[5. ] Include any code examples in an \texttt{\# Examples} section.

Examples should, whenever possible, be written as \emph{doctests}. A \emph{doctest} is a fenced code block (see \hyperlink{9246544299434150790}{Code blocks}) starting with \texttt{```jldoctest} and contains any number of \texttt{julia>} prompts together with inputs and expected outputs that mimic the Julia REPL.

For example in the following docstring a variable \texttt{a} is defined and the expected result, as printed in a Julia REPL, appears afterwards:


\begin{minted}{julia}
"""
Some nice documentation here.

# Examples

```jldoctest
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4
```
"""
\end{minted}

\begin{quote}
\textbf{Warning}

Calling \texttt{rand} and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions.

Operating system word size (\hyperlink{10103694114785108551}{\texttt{Int32}} or \hyperlink{7720564657383125058}{\texttt{Int64}}) as well as path separator differences (\texttt{/} or \texttt{{\textbackslash}}) will also affect the reproducibility of some doctests.

Note that whitespace in your doctest is significant! The doctest will fail if you misalign the output of pretty-printing an array, for example.

\end{quote}
You can then run \texttt{make -C doc doctest} to run all the doctests in the Julia Manual, which will ensure that your example works.

Examples that are untestable should be written within fenced code blocks starting with \texttt{```julia} so that they are highlighted correctly in the generated documentation.

\begin{quote}
\textbf{Tip}

Wherever possible examples should be \textbf{self-contained} and \textbf{runnable} so that readers are able to try them out without having to include any dependencies.

\end{quote}

\item[6. ] Use backticks to identify code and equations.

Julia identifiers and code excerpts should always appear between backticks \texttt{`} to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks \texttt{``}. Use Unicode characters rather than their LaTeX escape sequence, i.e. \texttt{``α = 1``} rather than \texttt{``{\textbackslash}{\textbackslash}alpha = 1``}.


\item[7. ] Place the starting and ending \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}} characters on lines by themselves.

That is, write:


\begin{minted}{julia}
"""
...

...
"""
f(x, y) = ...
\end{minted}

rather than:


\begin{minted}{julia}
"""...

..."""
f(x, y) = ...
\end{minted}

This makes it more clear where docstrings start and end.


\item[8. ] Respect the line length limit used in the surrounding code.

Docstrings are edited using the same tools as code. Therefore, the same conventions should apply. It it advised to add line breaks after 92 characters.

\end{itemize}


\hypertarget{13175452021130145252}{}


\section{Accessing Documentation}



Documentation can be accessed at the REPL or in \href{https://github.com/JuliaLang/IJulia.jl}{IJulia} by typing \texttt{?} followed by the name of a function or macro, and pressing \texttt{Enter}. For example,




\begin{minted}{julia}
?fft
?@time
?r""
\end{minted}



will bring up docs for the relevant function, macro or string macro respectively. In \href{http://junolab.org}{Juno} using \texttt{Ctrl-J, Ctrl-D} will bring up documentation for the object under the cursor.



\hypertarget{1610925430009782653}{}


\section{Functions \& Methods}



Functions in Julia may have multiple implementations, known as methods. While it{\textquotesingle}s good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by \texttt{function bar end}). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:




\begin{minted}{julia}
"""
    *(x, y, z...)

Multiplication operator. `x * y * z *...` calls this function with multiple
arguments, i.e. `*(x, y, z...)`.
"""
function *(x, y, z...)
    # ... [implementation sold separately] ...
end

"""
    *(x::AbstractString, y::AbstractString, z::AbstractString...)

When applied to strings, concatenates them.
"""
function *(x::AbstractString, y::AbstractString, z::AbstractString...)
    # ... [insert secret sauce here] ...
end

help?> *
search: * .*

  *(x, y, z...)

  Multiplication operator. x * y * z *... calls this function with multiple
  arguments, i.e. *(x,y,z...).

  *(x::AbstractString, y::AbstractString, z::AbstractString...)

  When applied to strings, concatenates them.
\end{minted}



When retrieving documentation for a generic function, the metadata for each method is concatenated with the \texttt{catdoc} function, which can of course be overridden for custom types.



\hypertarget{7493863945551919908}{}


\section{Advanced Usage}



The \texttt{@doc} macro associates its first argument with its second in a per-module dictionary called \texttt{META}. By default, documentation is expected to be written in Markdown, and the \texttt{doc{\textquotedbl}{\textquotedbl}} string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.



When used for retrieving documentation, the \texttt{@doc} macro (or equally, the \texttt{doc} function) will search all \texttt{META} dictionaries for metadata relevant to the given object and return it. The returned object (some Markdown content, for example) will by default display itself intelligently. This design also makes it easy to use the doc system in a programmatic way; for example, to re-use documentation between different versions of a function:




\begin{minted}{julia}
@doc "..." foo!
@doc (@doc foo!) foo
\end{minted}



Or for use with Julia{\textquotesingle}s metaprogramming functionality:




\begin{minted}{julia}
for (f, op) in ((:add, :+), (:subtract, :-), (:multiply, :*), (:divide, :/))
    @eval begin
        $f(a,b) = $op(a,b)
    end
end
@doc "`add(a,b)` adds `a` and `b` together" add
@doc "`subtract(a,b)` subtracts `b` from `a`" subtract
\end{minted}



Documentation written in non-toplevel blocks, such as \texttt{begin}, \texttt{if}, \texttt{for}, and \texttt{let}, is added to the documentation system as blocks are evaluated. For example:




\begin{minted}{julia}
if VERSION > v"0.5"
    "..."
    f(x) = x
end
\end{minted}



will add documentation to \texttt{f(x)} when the condition is \texttt{true}. Note that even if \texttt{f(x)} goes out of scope at the end of the block, its documentation will remain.



\hypertarget{1853789607931388452}{}


\subsection{Dynamic documentation}



Sometimes the appropriate documentation for an instance of a type depends on the field values of that instance, rather than just on the type itself. In these cases, you can add a method to \texttt{Docs.getdoc} for your custom type that returns the documentation on a per-instance basis. For instance,




\begin{minted}{julia}
struct MyType
    value::String
end

Docs.getdoc(t::MyType) = "Documentation for MyType with value $(t.value)"

x = MyType("x")
y = MyType("y")
\end{minted}



\texttt{?x} will display {\textquotedbl}Documentation for MyType with value x{\textquotedbl} while \texttt{?y} will display {\textquotedbl}Documentation for MyType with value y{\textquotedbl}.



\hypertarget{16279340761375223329}{}


\section{Syntax Guide}



A comprehensive overview of all documentable Julia syntax.



In the following examples \texttt{{\textquotedbl}...{\textquotedbl}} is used to illustrate an arbitrary docstring which may be one of the follow four variants and contain arbitrary text:




\begin{minted}{julia}
"..."

doc"..."

"""
...
"""

doc"""
...
"""
\end{minted}



\texttt{@doc\_str} should only be used when the docstring contains \texttt{\$} or \texttt{{\textbackslash}} characters that should not be parsed by Julia such as LaTeX syntax or Julia source code examples containing interpolation.



\hypertarget{8714381096633713163}{}


\subsection{Functions and Methods}




\begin{minted}{julia}
"..."
function f end

"..."
f
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to \texttt{Function}\texttt{f}. The first version is the preferred syntax, however both are equivalent.




\begin{minted}{julia}
"..."
f(x) = x

"..."
function f(x)
    x
end

"..."
f(x)
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to \texttt{Method}\texttt{f(::Any)}.




\begin{minted}{julia}
"..."
f(x, y = 1) = x + y
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to two \texttt{Method}s, namely \texttt{f(::Any)} and \texttt{f(::Any, ::Any)}.



\hypertarget{7735912728489467540}{}


\subsection{Macros}




\begin{minted}{julia}
"..."
macro m(x) end
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the \texttt{@m(::Any)} macro definition.




\begin{minted}{julia}
"..."
:(@m)
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the macro named \texttt{@m}.



\hypertarget{388524109337598454}{}


\subsection{Types}




\begin{lstlisting}
"..."
abstract type T1 end

"..."
mutable struct T2
    ...
end

"..."
struct T3
    ...
end
\end{lstlisting}



Adds the docstring \texttt{{\textquotedbl}...{\textquotedbl}} to types \texttt{T1}, \texttt{T2}, and \texttt{T3}.




\begin{minted}{julia}
"..."
struct T
    "x"
    x
    "y"
    y
end
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to type \texttt{T}, \texttt{{\textquotedbl}x{\textquotedbl}} to field \texttt{T.x} and \texttt{{\textquotedbl}y{\textquotedbl}} to field \texttt{T.y}. Also applicable to \texttt{mutable struct} types.



\hypertarget{11199822992728837276}{}


\subsection{Modules}




\begin{minted}{julia}
"..."
module M end

module M

"..."
M

end
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the \texttt{Module}\texttt{M}. Adding the docstring above the \texttt{Module} is the preferred syntax, however both are equivalent.




\begin{minted}{julia}
"..."
baremodule M
# ...
end

baremodule M

import Base: @doc

"..."
f(x) = x

end
\end{minted}



Documenting a \texttt{baremodule} by placing a docstring above the expression automatically imports \texttt{@doc} into the module. These imports must be done manually when the module expression is not documented. Empty \texttt{baremodule}s cannot be documented.



\hypertarget{1246107342185770044}{}


\subsection{Global Variables}




\begin{minted}{julia}
"..."
const a = 1

"..."
b = 2

"..."
global c = 3
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the \texttt{Binding}s \texttt{a}, \texttt{b}, and \texttt{c}.



\texttt{Binding}s are used to store a reference to a particular \texttt{Symbol} in a \texttt{Module} without storing the referenced value itself.



\begin{quote}
\textbf{Note}

When a \texttt{const} definition is only used to define an alias of another definition, such as is the case with the function \texttt{div} and its alias \texttt{÷} in \texttt{Base}, do not document the alias and instead document the actual function.

If the alias is documented and not the real definition then the docsystem (\texttt{?} mode) will not return the docstring attached to the alias when the real definition is searched for.

For example you should write


\begin{minted}{julia}
"..."
f(x) = x + 1
const alias = f
\end{minted}

rather than


\begin{minted}{julia}
f(x) = x + 1
"..."
const alias = f
\end{minted}

\end{quote}



\begin{minted}{julia}
"..."
sym
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to the value associated with \texttt{sym}. Users should prefer documenting \texttt{sym} at it{\textquotesingle}s definition.



\hypertarget{16007303151473682937}{}


\subsection{Multiple Objects}




\begin{minted}{julia}
"..."
a, b
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to \texttt{a} and \texttt{b} each of which should be a documentable expression. This syntax is equivalent to




\begin{minted}{julia}
"..."
a

"..."
b
\end{minted}



Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions \texttt{f} and \texttt{f!}.



\hypertarget{10676417314609910318}{}


\subsection{Macro-generated code}




\begin{minted}{julia}
"..."
@m expression
\end{minted}



Adds docstring \texttt{{\textquotedbl}...{\textquotedbl}} to expression generated by expanding \texttt{@m expression}. This allows for expressions decorated with \texttt{@inline}, \texttt{@noinline}, \texttt{@generated}, or any other macro to be documented in the same way as undecorated expressions.



Macro authors should take note that only macros that generate a single expression will automatically support docstrings. If a macro returns a block containing multiple subexpressions then the subexpression that should be documented must be marked using the \hyperlink{8194145670752069829}{\texttt{@\_\_doc\_\_}} macro.



The \texttt{@enum} macro makes use of \texttt{@\_\_doc\_\_} to allow for documenting \texttt{Enum}s. Examining it{\textquotesingle}s definition should serve as an example of how to use \texttt{@\_\_doc\_\_} correctly.


\hypertarget{8194145670752069829}{} 
\hyperlink{8194145670752069829}{\texttt{Core.@\_\_doc\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@__doc__(ex)
\end{lstlisting}

Low-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.


\begin{lstlisting}
macro example(f)
    quote
        $(f)() = 0
        @__doc__ $(f)(x) = 1
        $(f)(x, y) = 2
    end |> esc
end
\end{lstlisting}

\texttt{@\_\_doc\_\_} has no effect when a macro that uses it is not documented.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/Docs.jl#L570-L585}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9616939662988024327}{}


\section{Markdown syntax}



The following markdown syntax is supported in Julia.



\hypertarget{8063626144587397226}{}


\subsection{Inline elements}



Here {\textquotedbl}inline{\textquotedbl} refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.



\hypertarget{10166533682417016306}{}


\subsubsection{Bold}



Surround words with two asterisks, \texttt{**}, to display the enclosed text in boldface.




\begin{lstlisting}
A paragraph containing a **bold** word.
\end{lstlisting}



\hypertarget{4277603997710742460}{}


\subsubsection{Italics}



Surround words with one asterisk, \texttt{*}, to display the enclosed text in italics.




\begin{lstlisting}
A paragraph containing an *emphasised* word.
\end{lstlisting}



\hypertarget{6850088772867679045}{}


\subsubsection{Literals}



Surround text that should be displayed exactly as written with single backticks, \texttt{`} .




\begin{lstlisting}
A paragraph containing a `literal` word.
\end{lstlisting}



Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.



\begin{quote}
\textbf{Tip}

To include a backtick character within literal text use three backticks rather than one to enclose the text.


\begin{lstlisting}
A paragraph containing a ``` `backtick` character ```.
\end{lstlisting}

By extension any odd number of backticks may be used to enclose a lesser number of backticks.

\end{quote}


\hypertarget{6917271240677862304}{}


\subsubsection{\LaTeX}



Surround text that should be displayed as mathematics using \LaTeX syntax with double backticks, \texttt{``} .




\begin{lstlisting}
A paragraph containing some ``\LaTeX`` markup.
\end{lstlisting}



\begin{quote}
\textbf{Tip}

As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within \LaTeX markup then two enclosing backticks is sufficient.

\end{quote}


\hypertarget{10395937766942848638}{}


\subsubsection{Links}



Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, \texttt{[ ]}, is the name of the link and the text enclosed in parentheses, \texttt{( )}, is the URL.




\begin{lstlisting}
A paragraph containing a link to [Julia](http://www.julialang.org).
\end{lstlisting}



It{\textquotesingle}s also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:




\begin{minted}{julia}
"""
    eigvals!(A,[irange,][vl,][vu]) -> values

Same as [`eigvals`](@ref), but saves space by overwriting the input `A`, instead of creating a copy.
"""
\end{minted}



This will create a link in the generated docs to the \texttt{eigvals} documentation (which has more information about what this function actually does). It{\textquotesingle}s good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.



\begin{quote}
\textbf{Note}

The above cross referencing is \emph{not} a Markdown feature, and relies on \href{https://github.com/JuliaDocs/Documenter.jl}{Documenter.jl}, which is used to build base Julia{\textquotesingle}s documentation.

\end{quote}


\hypertarget{1886176754537713588}{}


\subsubsection{Footnote references}



Named and numbered footnote references can be written using the following syntax. A footnote name must be a single alphanumeric word containing no punctuation.




\begin{lstlisting}
A paragraph containing a numbered footnote [^1] and a named one [^named].
\end{lstlisting}



\begin{quote}
\textbf{Note}

The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the \hyperlink{1021238270223877775}{Footnotes} section below.

\end{quote}


\hypertarget{1299449328577314863}{}


\subsection{Toplevel elements}



The following elements can be written either at the {\textquotedbl}toplevel{\textquotedbl} of a document or within another {\textquotedbl}toplevel{\textquotedbl} element.



\hypertarget{7653906193491884111}{}


\subsubsection{Paragraphs}



A paragraph is a block of plain text, possibly containing any number of inline elements defined in the \hyperlink{8063626144587397226}{Inline elements} section above, with one or more blank lines above and below it.




\begin{lstlisting}
This is a paragraph.

And this is *another* one containing some emphasised text.
A new line, but still part of the same paragraph.
\end{lstlisting}



\hypertarget{14939650886219602329}{}


\subsubsection{Headers}



A document can be split up into different sections using headers. Headers use the following syntax:




\begin{minted}{julia}
# Level One
## Level Two
### Level Three
#### Level Four
##### Level Five
###### Level Six
\end{minted}



A header line can contain any inline syntax in the same way as a paragraph can.



\begin{quote}
\textbf{Tip}

Try to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics.

\end{quote}


\hypertarget{9246544299434150790}{}


\subsubsection{Code blocks}



Source code can be displayed as a literal block using an indent of four spaces as shown in the following example.




\begin{lstlisting}
This is a paragraph.

    function func(x)
        # ...
    end

Another paragraph.
\end{lstlisting}



Additionally, code blocks can be enclosed using triple backticks with an optional {\textquotedbl}language{\textquotedbl} to specify how a block of code should be highlighted.




\begin{lstlisting}
A code block without a "language":

```
function func(x)
    # ...
end
```

and another one with the "language" specified as `julia`:

```julia
function func(x)
    # ...
end
```
\end{lstlisting}



\begin{quote}
\textbf{Note}

{\textquotedbl}Fenced{\textquotedbl} code blocks, as shown in the last example, should be prefered over indented code blocks since there is no way to specify what language an indented code block is written in.

\end{quote}


\hypertarget{12305052721486916392}{}


\subsubsection{Block quotes}



Text from external sources, such as quotations from books or websites, can be quoted using \texttt{>} characters prepended to each line of the quote as follows.




\begin{lstlisting}
Here's a quote:

> Julia is a high-level, high-performance dynamic programming language for
> technical computing, with syntax that is familiar to users of other
> technical computing environments.
\end{lstlisting}



Note that a single space must appear after the \texttt{>} character on each line. Quoted blocks may themselves contain other toplevel or inline elements.



\hypertarget{9122787766607047979}{}


\subsubsection{Images}



The syntax for images is similar to the link syntax mentioned above. Prepending a \texttt{!} character to a link will display an image from the specified URL rather than a link to it.




\begin{minted}{julia}
![alternative text](link/to/image.png)
\end{minted}



\hypertarget{5671077042730580546}{}


\subsubsection{Lists}



Unordered lists can be written by prepending each item in a list with either \texttt{*}, \texttt{+}, or \texttt{-}.




\begin{lstlisting}
A list of items:

  * item one
  * item two
  * item three
\end{lstlisting}



Note the two spaces before each \texttt{*} and the single space after each one.



Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.




\begin{lstlisting}
Another list:

  * item one

  * item two

    ```
    f(x) = x
    ```

  * And a sublist:

      + sub-item one
      + sub-item two
\end{lstlisting}



\begin{quote}
\textbf{Note}

The contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the \texttt{i} in \texttt{item two}.

\end{quote}


Ordered lists are written by replacing the {\textquotedbl}bullet{\textquotedbl} character, either \texttt{*}, \texttt{+}, or \texttt{-}, with a positive integer followed by either \texttt{.} or \texttt{)}.




\begin{lstlisting}
Two ordered lists:

 1. item one
 2. item two
 3. item three

 5) item five
 6) item six
 7) item seven
\end{lstlisting}



An ordered list may start from a number other than one, as in the second list of the above example, where it is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.



\hypertarget{8249559303631128892}{}


\subsubsection{Display equations}



Large \LaTeX equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the {\textquotedbl}language{\textquotedbl} \texttt{math} as in the example below.




\begin{minted}{julia}
```math
f(a) = \frac{1}{2\pi}\int_{0}^{2\pi} (\alpha+R\cos(\theta))d\theta
```
\end{minted}



\hypertarget{1021238270223877775}{}


\subsubsection{Footnotes}



This syntax is paired with the inline syntax for \hyperlink{1886176754537713588}{Footnote references}. Make sure to read that section as well.



Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the \texttt{:} character that is appended to the footnote label.




\begin{lstlisting}
[^1]: Numbered footnote text.

[^note]:

    Named footnote text containing several toplevel elements.

      * item one
      * item two
      * item three

    ```julia
    function func(x)
        # ...
    end
    ```
\end{lstlisting}



\begin{quote}
\textbf{Note}

No checks are done during parsing to make sure that all footnote references have matching footnotes.

\end{quote}


\hypertarget{5663489325501471007}{}


\subsubsection{Horizontal rules}



The equivalent of an \texttt{<hr>} HTML tag can be written using the following syntax:




\begin{lstlisting}
Text above the line.

---

And text below the line.
\end{lstlisting}



\hypertarget{13092196581825070152}{}


\subsubsection{Tables}



Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above – only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.




\begin{lstlisting}
| Column One | Column Two | Column Three |
|:---------- | ---------- |:------------:|
| Row `1`    | Column `2` |              |
| *Row* 2    | **Row** 2  | Column ``3`` |
\end{lstlisting}



\begin{quote}
\textbf{Note}

As illustrated in the above example each column of \texttt{|} characters must be aligned vertically.

A \texttt{:} character on either end of a column{\textquotesingle}s header separator (the row containing \texttt{-} characters) specifies whether the row is left-aligned, right-aligned, or (when \texttt{:} appears on both ends) center-aligned. Providing no \texttt{:} characters will default to right-aligning the column.

\end{quote}


\hypertarget{7215905182614360565}{}


\subsubsection{Admonitions}



Specially formatted blocks with titles such as {\textquotedbl}Notes{\textquotedbl}, {\textquotedbl}Warning{\textquotedbl}, or {\textquotedbl}Tips{\textquotedbl} are known as admonitions and are used when some part of a document needs special attention. They can be defined using the following \texttt{!!!} syntax:




\begin{lstlisting}
!!! note

    This is the content of the note.

!!! warning "Beware!"

    And this is another one.

    This warning admonition has a custom title: `"Beware!"`.
\end{lstlisting}



Admonitions, like most other toplevel elements, can contain other toplevel elements. When no title text, specified after the admonition type in double quotes, is included then the title used will be the type of the block, i.e. \texttt{{\textquotedbl}Note{\textquotedbl}} in the case of the \texttt{note} admonition.



\hypertarget{10627994621615977524}{}


\section{Markdown Syntax Extensions}



Julia{\textquotesingle}s markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual \texttt{show} methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.



In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.



\hypertarget{15444528597476882531}{}


\chapter{Metaprogramación}



El legado más fuerte de Lisp en el lenguaje Julia es su soporte a la metaprogramación. Al igual que Lisp, Julia representa su propio código como una estructura de datos del propio lenguaje. Dado que el código está representado por objetos que pueden ser creados y manipulados desde dentro del lenguaje, es posible que un programa pueda transformar y generar su propio código. Esto permite una sofisticada generación de código sin pasos de construcción adicionales, y también permite las verdaderas macros de estilo Lisp que operan a nivel de los \href{https://en.wikipedia.org/wiki/Abstract\_syntax\_tree}{árboles sintácticos abstractos}. En contraste, los sistemas de preprocesador {\textquotedbl}macro{\textquotedbl} como el de C y C++, realizan la manipulación y sustitución textual antes de que se realice cualquier análisis o interpretación real. Debido a que todos los tipos de datos y código en Julia están representados por las estructuras de datos Julia, hay disponibles poderosas capacidades de \href{https://en.wikipedia.org/wiki/Reflection\_\%28computer\_programming\%29}{reflexión} están disponibles para explorar las características internas de un programa y sus tipos al igual que cualquier otro dato.



\hypertarget{2983319663567725723}{}


\section{Representación de programas}



Cada programa en Julia comienza su vida como una cadena:




\begin{lstlisting}
julia> prog = "1 + 1"
"1 + 1"
\end{lstlisting}



\textbf{¿Qué sucede después?}



El siguiente paso es \href{https://en.wikipedia.org/wiki/Parsing\#Computer\_languages}{analizar sintácticamente} cada cadena en un objeto denominado una expresión, representado por el tipo \texttt{Expr} de Julia:




\begin{lstlisting}
julia> ex1 = parse(prog)
:(1 + 1)

julia> typeof(ex1)
Expr
\end{lstlisting}



Los objetos \texttt{Expr} contienen trdoses partes:



\begin{itemize}
\item Un \texttt{Symbol} identificando la clase de expresión. Un símbolo es un \href{https://en.wikipedia.org/wiki/String\_interning}{identificador de cadena internado} (más información a continuación).

\end{itemize}



\begin{lstlisting}
julia> ex1.head
:call
\end{lstlisting}



\begin{itemize}
\item Los argumentos de expresión, que pueden ser símbolos, otras expresiones o valores literales:

\end{itemize}



\begin{lstlisting}
julia> ex1.args
3-element Array{Any,1}:
  :+
 1
 1
\end{lstlisting}



Las expresiones pueden también ser construidas directamente en \href{https://en.wikipedia.org/wiki/Polish\_notation}{notación prefija}:




\begin{lstlisting}
julia> ex2 = Expr(:call, :+, 1, 1)
:(1 + 1)
\end{lstlisting}



Las dos expresiones construidas antes (mediante análisis sintáctico y mediante construcción directa) son equivalentes:




\begin{lstlisting}
julia> ex1 == ex2
true
\end{lstlisting}



\textbf{El punto clave aquí es que el código Julia se representa internamente como una estructura de datos que es accesible desde el propio lenguaje.}



La función \hyperlink{15981569052160951906}{\texttt{dump()}} proporciona una visualización indentada y anotada de objetos \texttt{Expr}:




\begin{lstlisting}
julia> dump(ex2)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1
  typ: Any
\end{lstlisting}



Los objetos \texttt{Expr} puede ser también anidados:




\begin{lstlisting}
julia> ex3 = parse("(4 + 4) / 2")
:((4 + 4) / 2)
\end{lstlisting}



Otra forma de ver expresiones es con Meta.show\_sexpr, que muestra la \href{https://en.wikipedia.org/wiki/S-expression}{expresión-S} de una \texttt{Expr} dada, que puede resultar muy familiar a los usuarios de Lisp. He aquí un ejemplo que visualiza una expresión (\texttt{Expr}) anidada:




\begin{lstlisting}
julia> Meta.show_sexpr(ex3)
(:call, :/, (:call, :+, 4, 4), 2)
\end{lstlisting}



\hypertarget{10111749228506104555}{}


\subsection{Simbolos}



El carácter \texttt{:} tiene dos propósitos sintácticos en Julia. La primera forma crea un símbolo (\texttt{Symbol}), una \href{https://en.wikipedia.org/wiki/String\_interning}{cadena internada} usada como un bloque constructivo de expresiones:




\begin{minted}{jlcon}
julia> :foo
:foo

julia> typeof(ans)
Symbol
\end{minted}



El constructor \hyperlink{18332791376992528422}{\texttt{Symbol}} toma cualquier número de argumentos y crea un símbolo concatenando sus representaciones de cadena juntas:




\begin{minted}{jlcon}
julia> :foo == Symbol("foo")
true

julia> Symbol("func",10)
:func10

julia> Symbol(:var,'_',"sym")
:var_sym
\end{minted}



En el contexto de una expresión, los símbolos se utilizan para indicar el acceso a variables; Cuando se evalúa una expresión, se sustituye un símbolo por el valor asociado a ese símbolo en el \hyperlink{14993622729045334657}{ámbito} apropiado.



A veces son necesarios paréntesis adicionales alrededor del argumento a: para evitar la ambigüedad en el análisis:




\begin{minted}{jlcon}
julia> :(:)
:(:)

julia> :(::)
:(::)
\end{minted}



\hypertarget{17122171325869777470}{}


\section{Expresiones y evaluación}



\hypertarget{11914177268708629376}{}


\subsection{Citación}



El segundo propósito sintáctico del carácter \texttt{:} es crear objetos expresión sin utilizar el constructor \texttt{Expr} explícito. Esto se conoce como \emph{citación}. El carácter \texttt{:}, seguido de pares de paréntesis alrededor de una sola declaración de código Julia, produce un objeto \texttt{Expr} basado en el código incluido. He aquí un ejemplo de la forma corta utilizada para citar una expresión aritmética:




\begin{minted}{jlcon}
julia> ex = :(a+b*c+1)
:(a + b * c + 1)

julia> typeof(ex)
Expr
\end{minted}



(para ver la estructura de esta expresión, podemos usar \texttt{ex.head} y \texttt{ex.args} o \texttt{dump()}como antes)



Nótese que pueden construirse expresiones equivalentes usando \hyperlink{13108503824143481717}{\texttt{parse()}} o la forma directa \texttt{Expr}:




\begin{minted}{jlcon}
julia>      :(a + b*c + 1)  ==
       parse("a + b*c + 1") ==
       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)
true
\end{minted}



Las expresiones proporcionadas por el analizador sólo suelen tener símbolos, otras expresiones y valores literales como sus args, mientras que las expresiones construidas por el código Julia pueden tener valores de ejecución arbitrarios sin formas literales como args. En este ejemplo específico, \texttt{+} y \texttt{a} son símbolos, \texttt{*(b,c)} es una subexpresión, y \texttt{1} un entero literal de 64 bits.



Hay una segunda forma sintáctica de citar para expresiones múltiples: bloques de código encerrados en \texttt{quote ... end}. Note que esta forma introduce elementos \texttt{QuoteNode} al árbol de expresión que deben considerarse cuando se manipule directamente un árbol de expresiones generado a partir de bloques \texttt{quote}. Para otros propósitos, los bloques \texttt{:(...)} y \texttt{quote...end} se tratan de forma idéntica.




\begin{minted}{jlcon}
julia> ex = quote
           x = 1
           y = 2
           x + y
       end
quote
    #= none:2 =#
    x = 1
    #= none:3 =#
    y = 2
    #= none:4 =#
    x + y
end

julia> typeof(ex)
Expr
\end{minted}



\hypertarget{2204956672833253673}{}


\subsection{Interpolación}



La construcción directa de objetos \texttt{Expr} con valores como argumentos es potente, pero los constructores objetos \texttt{Expr} pueden ser tediosos comparados con la sintaxis {\textquotedbl}normal{\textquotedbl} de Julia. Como alternativa, Julia permite {\textquotedbl}empalme{\textquotedbl} o interpolación de literales o expresiones en expresiones citadas. La interpolación se indica con el prefijo \texttt{\$}.



En este ejemplo el valor literal de \texttt{a} es interpolado:




\begin{lstlisting}
julia> a = 1;

julia> ex = :($a + b)
:(1 + b)
\end{lstlisting}



Interpolar en una expresión no citada (\emph{quoted}) no se admite y causará un error en tiempo de compilación: 




\begin{lstlisting}
julia> $a + b
ERROR: unsupported or misplaced expression $
 ...
\end{lstlisting}



En este ejemplo, la tupla \texttt{(1,2,3)} es interpolada como una expresión en un test condicional:




\begin{lstlisting}
julia> ex = :(a in $:((1,2,3)) )
:(a in (1, 2, 3))
\end{lstlisting}



Interpolar símbolos en una expresión anidada requiere encerrar cada símbolo en un bloque de cita que lo encierre:




\begin{minted}{jlcon}
julia> :( :a in $( :(:a + :b) ) )
                   ^^^^^^^^^^
                   quoted inner expression
\end{minted}



El uso de \texttt{\$} para la interpolación de la expresión recuerda intencionalmente a la \hyperlink{12583298261221600612}{interpolación de cadenas} y a la \hyperlink{6373319844820183024}{interpolación de mandatos}. La interpolación de expresiones permite la construcción programática conveniente y legible de expresiones Julia complejas.



\hypertarget{303473621980441805}{}


\subsection{\texttt{eval()} and efectos}



Dado un objeto expresión, uno puede causar que Julia lo evalúe (ejecute) en un ámbito global usando \hyperlink{2345597220715550879}{\texttt{eval()}}:




\begin{lstlisting}
julia> :(1 + 2)
:(1 + 2)

julia> eval(ans)
3

julia> ex = :(a + b)
:(a + b)

julia> eval(ex)
ERROR: UndefVarError: b not defined
[...]

julia> a = 1; b = 2;

julia> eval(ex)
3
\end{lstlisting}



Cada \hyperlink{10438697863683890874}{módulo} tiene su propia función \hyperlink{2345597220715550879}{\texttt{eval()}} que evalúa expresiones en su ámbito global. Las expresiones pasadas a \hyperlink{2345597220715550879}{\texttt{eval()}} no están limitadas a valores de retorno (ellas también pueden tener efetos colaterales que alteren el estado del entorno del módulo que las encierra:




\begin{minted}{jlcon}
julia> ex = :(x = 1)
:(x = 1)

julia> x
ERROR: UndefVarError: x not defined

julia> eval(ex)
1

julia> x
1
\end{minted}



Aquí, la evaluación de un objeto expresión causa que se asigne un valor a la variable global \texttt{x}.



Como las expresiones no son más que objetos \texttt{Expr} que pueden ser construidos programáticamente y después evaluados, es posible generar dinámicamente código arbitrario que pueda ser ejecutado luego mediante \hyperlink{2345597220715550879}{\texttt{eval()}}. He aquí Since expressions are just \texttt{Expr} objects which can be constructed programmatically and then evaluated, un ejemplo sencillo:




\begin{minted}{jlcon}
julia> a = 1;

julia> ex = Expr(:call, :+, a, :b)
:(1 + b)

julia> a = 0; b = 2;

julia> eval(ex)
3
\end{minted}



El valor de \texttt{a} se ha usado para construir la expresión \texttt{ex} que aplica la función \texttt{+} al valor \texttt{1} y a la variable \texttt{b}. Note la distinción importante entre la forma en que se usan las variables \texttt{a} y \texttt{b}:



\begin{itemize}
\item El valor de la \emph{variable} \texttt{a} se utiliza como valor inmediato en la expresión en el tiempo de construcción de la  expresión. Por lo tanto, una vez que la expresión es evaluada, el valor de a ya no importa: el valor en la expresión  ya es 1, independientemente de lo que pueda ser ahora  el valor de \texttt{a}.


\item Por otro lado, el símbolo \texttt{:b} se utiliza en la construcción de la expresión, por lo que el valor de la variable \texttt{b}  en ese momento es irrelevante - :b es sólo un símbolo y la variable b ni siquiera necesita ser definida. En el  momento de la evaluación de la expresión, sin embargo, el valor del símbolo \texttt{:b} se resuelve buscando el valor de  la variable \texttt{b}.

\end{itemize}


\hypertarget{14612651381079997690}{}


\subsection{Funcciones sobre \texttt{Expr}esiones}



Como se ha sugerido anteriormente, una característica muy útil de Julia es la capacidad de generar y manipular código Julia dentro del propio Julia. Ya hemos visto un ejemplo de una función que devuelve objetos \texttt{Expr}: la función \hyperlink{13108503824143481717}{\texttt{parse()}}, que toma una cadena de código Julia y devuelve la \texttt{Expr} correspondiente. Una función también puede tomar uno o más objetos \texttt{Expr} como argumentos, y devolver otro \texttt{Expr}. Aquí hay un ejemplo simple y motivador:




\begin{minted}{jlcon}
julia> function math_expr(op, op1, op2)
           expr = Expr(:call, op, op1, op2)
           return expr
       end
math_expr (generic function with 1 method)

julia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))
:(1 + 4 * 5)

julia> eval(ex)
21
\end{minted}



Otro ejemplo puede ser esta función que dobla cualquier argumento numérico, pero deja las expresiones solas:




\begin{minted}{jlcon}
julia> function make_expr2(op, opr1, opr2)
           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))
           retexpr = Expr(:call, op, opr1f, opr2f)
           return retexpr
       end
make_expr2 (generic function with 1 method)

julia> make_expr2(:+, 1, 2)
:(2 + 4)

julia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))
:(2 + 5 * 8)

julia> eval(ex)
42
\end{minted}



\hypertarget{11146454106624591870}{}


\section{Macros}



Las macros proporcionan un método para incluir el código generado en el cuerpo final de un programa. Una macro asigna una tupla de argumentos a una expresión devuelta, y la expresión resultante se compila directamente en lugar de requerir una llamada \hyperlink{2345597220715550879}{\texttt{eval()}} de ejecución. Los argumentos de macro pueden incluir expresiones, valores literales y símbolos.



\hypertarget{6301913939237280186}{}


\subsection{Básico}



He aquí una macro extraordinariamente simple:




\begin{lstlisting}
julia> macro sayhello()
           return :( println("Hello, world!") )
       end
@sayhello (macro with 1 method)
\end{lstlisting}



Las macros tienen un carácter dedicado en la sintaxis de Julia: el \texttt{@} (at-sign), seguido por el nombre único declarado en un bloque \texttt{macro NAME ... end}. En este ejemplo, el compilador reemplazará todas las instancias de \texttt{@sayhello} con:




\begin{minted}{julia}
:( println("Hello, world!") )
\end{minted}



Cuando \texttt{@sayhello} se llama en el REPL, la expresión se ejecuta inmediatamente, por lo tanto solo vemos el resultado de la evaluación:   




\begin{lstlisting}
julia> @sayhello()
Hello, world!
\end{lstlisting}



Ahora, considere una macro un poco más compleja:




\begin{lstlisting}
julia> macro sayhello(name)
           return :( println("Hello, ", $name) )
       end
@sayhello (macro with 1 method)
\end{lstlisting}



Esta macro toma un argumento: \texttt{name}. Cuando se encuentra \texttt{@sayhello}, la expresión citada se \emph{expande} para interpolar el valor del argumento en la expresión final:




\begin{lstlisting}
julia> @sayhello("human")
Hello, human
\end{lstlisting}



Podemos ver la expresión de retorno entre comillas usando la función \hyperlink{8018172489611994488}{\texttt{macroexpand()}} (\textbf{nota importante:} esta es una herramienta extremadamente útil para depurar macros):




\begin{lstlisting}
julia> ex = macroexpand( :(@sayhello("human")) )
:((println)("Hello, ", "human"))

julia> typeof(ex)
Expr
\end{lstlisting}



We can see that the \texttt{{\textquotedbl}human{\textquotedbl}} literal has been interpolated into the expression.



También existe una macro \hyperlink{14913190777653949565}{\texttt{@macroexpand}} que quizás sea un poco más conveniente que la función \texttt{macroexpand}:




\begin{lstlisting}
julia> @macroexpand @sayhello "human"
:((println)("Hello, ", "human"))
\end{lstlisting}



\hypertarget{4602919026196282781}{}


\subsection{Un momento. ¿Por qué las macros?}



Ya hemos visto una función \texttt{f(:: Expr ...) -> Expr} en una sección anterior. De hecho, \hyperlink{8018172489611994488}{\texttt{macroexpand()}} es también una función. Entonces, ¿por qué existen macros?



Las macros son necesarias porque se ejecutan cuando se analiza el código, por lo tanto, las macros permiten al programador generar e incluir fragmentos de código personalizado antes de ejecutar el programa completo. Para ilustrar la diferencia, considere el siguiente ejemplo:




\begin{lstlisting}
julia> macro twostep(arg)
           println("I execute at parse time. The argument is: ", arg)
           return :(println("I execute at runtime. The argument is: ", $arg))
       end
@twostep (macro with 1 method)

julia> ex = macroexpand( :(@twostep :(1, 2, 3)) );
I execute at parse time. The argument is: $(Expr(:quote, :((1, 2, 3))))
\end{lstlisting}



La primera llamada a \hyperlink{783803254548423222}{\texttt{println()}} se ejecuta cuando se invoca \hyperlink{8018172489611994488}{\texttt{macroexpand()}}. La expresión resultante contiene \emph{sólo} el segundo \texttt{println}:




\begin{lstlisting}
julia> typeof(ex)
Expr

julia> ex
:((println)("I execute at runtime. The argument is: ", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))

julia> eval(ex)
I execute at runtime. The argument is: (1, 2, 3)
\end{lstlisting}



\hypertarget{7791071585667838537}{}


\subsection{Invocación de macros}



Las macros son invocadas con la siguiente sintaxis general:



``julia @name expr1 expr2 ... @name(expr1, expr2, ...)




\begin{lstlisting}

Note la `@` antes del nombre de macro y la falta de domas entre las expresiones de los argumentos en la primera forma, y la falta de espacios en balnco después de `@name` en la segunda forma. Los dos estilos no deberían mezclarse. Por ejemplo, la siguiente sintaxis es diferente que la de los ejemplos anteriores; ella pasa la tupla `(expr1, expr2, ...)` como argumento a la macro:

\end{lstlisting}



julia @name (expr1, expr2, ...)




\begin{lstlisting}

Es importante enfatizar que las macros reciben sus argumentos como expresiones, literales o símbolos. Una forma de explorar los argumentos de las macros es llamar a la función `show()` dentro del cuerpo de la macro:

\end{lstlisting}



jldoctest julia> macro showarg(x)            show(x)            \# ... remainder of macro, returning an expression        end @showarg (macro with 1 method)



julia> @showarg(a) :a



julia> @showarg(1+1) :(1 + 1)



julia> @showarg(println({\textquotedbl}Yo!{\textquotedbl})) :(println({\textquotedbl}Yo!{\textquotedbl}))




\begin{lstlisting}

### Construir una macro avanzada

He aquí una versión simplificada de la macro `@assert` de Julia:

\end{lstlisting}



jldoctest building julia> macro assert(ex)            return :( \(ex ? nothing : throw(AssertionError(\)(string(ex)))) )        end @assert (macro with 1 method)




\begin{lstlisting}

La macro puede ser usada de esta forma:

\end{lstlisting}



jldoctest building julia> @assert 1 == 1.0



julia> @assert 1 == 0 ERROR: AssertionError: 1 == 0




\begin{lstlisting}

En lugar de la sintaxis escrita, la llamada a macro es expandida en tiempo de análisis para que devuelva un resutlado. Esto es equivalente a escribir:

\end{lstlisting}



julia 1 == 1.0 ? nothing : throw(AssertionError({\textquotedbl}1 == 1.0{\textquotedbl})) 1 == 0 ? nothing : throw(AssertionError({\textquotedbl}1 == 0{\textquotedbl}))




\begin{lstlisting}

Es decir, en la primera llamada, la expresión `:(1 == 1.0)` se empalma en la ranura de condición de prueba, mientras que el valor de `string(:( 1 == 1.0))` se empalma en la ranura de mensaje de aserción. Toda la expresión, así construida, se coloca en el árbol de sintaxis donde se produce la llamada de macro `@assert`. Entonces, en el tiempo de ejecución, si la expresión de prueba se evalúa como verdadera, entonces se devuelve `nothing`, mientras que si la prueba es falsa, se genera un error indicando la expresión afirmada que es falsa. Observe que no sería posible escribir esto como una función, ya que sólo está disponible el valor de la condición y sería imposible mostrar la expresión que lo calculó en el mensaje de error.

La definición real de `@assert` en la biblioteca estándar es más complicada. Permite al usuario especificar opcionalmente su propio mensaje de error, en lugar de simplemente imprimir la expresión fallida. Al igual que en las funciones con un número variable de argumentos, esto se especifica con elipses después del último argumento:

\end{lstlisting}



jldoctest assert2 julia> macro assert(ex, msgs...)            msg\_body = isempty(msgs) ? ex : msgs[1]            msg = string(msg\_body)            return :(\(ex ? nothing : throw(AssertionError(\)msg)))        end @assert (macro with 1 method)




\begin{lstlisting}

Ahora `@assert` tiene dos modos de operación, dependiendo del número de argumentos que recibe! Si sólo hay un argumento, la tupla de expresiones capturadas por `msgs` estará vacía y se comportará igual que la definición más simple anterior. Ahora bien, si el usuario especifica un segundo argumento, se imprime en el cuerpo del mensaje en lugar de la expresión que falla. Puede examinar el resultado de una expansión de macro con la función [`macroexpand()`](@ref) correctamente denominada:

\end{lstlisting}



jldoctest assert2 julia> macroexpand(:(@assert a == b)) :(if a == b         nothing     else         (throw)((AssertionError)({\textquotedbl}a == b{\textquotedbl}))     end)



julia> macroexpand(:(@assert a==b {\textquotedbl}a should equal b!{\textquotedbl})) :(if a == b         nothing     else         (throw)((AssertionError)({\textquotedbl}a should equal b!{\textquotedbl}))     end)




\begin{lstlisting}

Hay otro caso que la versión real de `@assert` maneja: ¿qué pasa si, además de imprimir "a should be equal b", queremos imprimir sus valores? Uno podría ingenuamente intentar usar interpolación de cadena en el mensaje personalizado, por ejemplo, ` @assert a==b "a ($a) should equal b ($b)!"`, pero esto no funcionará como se esperaba con la macro anterior. ¿Puedes ver por qué? Recuerda de [string interpolation](@ref string-interpolation) que una cadena interpolada se reescribe a una llamada a [`string()`](@ref). Compare:

\end{lstlisting}



jldoctest julia> typeof(:({\textquotedbl}a should equal b{\textquotedbl})) String



julia> typeof(:({\textquotedbl}a (\(a) should equal b (\)b)!{\textquotedbl})) Expr



julia> dump(:({\textquotedbl}a (\(a) should equal b (\)b)!{\textquotedbl})) Expr   head: Symbol string   args: Array\{Any\}((5,))     1: String {\textquotedbl}a ({\textquotedbl}     2: Symbol a     3: String {\textquotedbl}) should equal b ({\textquotedbl}     4: Symbol b     5: String {\textquotedbl})!{\textquotedbl}   typ: Any




\begin{lstlisting}

Así que ahora en lugar de obtener una cadena sencilla en `msg_body`, la macro está recibiendo una expresión completa que necesitará ser evaluada para mostrarse como se esperaba. Esto puede ser empalmado directamente en la expresión devuelta como un argumento a la llamada [`string()`](@ref); Vea [`error.jl`](https://github.com/JuliaLang/julia/blob/master/base/error.jl) para la implementación completa.

La macro `@assert` hace un gran uso del empalme en expresiones entre comillas para simplificar la manipulación de expresiones dentro del cuerpo de la macro.

### Higiene

Un problema que surge en las macros más complejas es el de la [higiene](https://en.wikipedia.org/wiki/Hygienic_macro).En resumen, las macros deben asegurarse de que las variables que introducen en sus expresiones devueltas no chocan accidentalmente con las variables existentes en el código circundante en el que se expanden. A la inversa, a menudo se espera que las expresiones que se pasan a una macro como argumentos evalúen en el contexto del código circundante, interactuando con y modificando las variables existentes. Otra preocupación surge del hecho de que una macro puede ser llamada en un módulo diferente desde donde se definió. En este caso, debemos asegurarnos de que todas las variables globales se resuelvan en el módulo correcto. Julia ya tiene una gran ventaja sobre los lenguajes con expansión de macro textual (como C) en que sólo necesita considerar la expresión devuelta. Todas las demás variables (como `msg` en `@assert` arriba) siguen el [comportamiento normal del bloque de ámbito](@ref scope-of-variables).

Para demostrar estos problemas, consideremos la posibilidad de escribir una macro `@time` que toma una expresión como su argumento, registra el tiempo, evalúa la expresión, registra el tiempo de nuevo, imprime la diferencia entre los tiempos antes y después y luego tiene el valor de La expresión como su valor final. La macro podría tener este aspecto:

\end{lstlisting}



julia macro time(ex)     return quote         local t0 = time()         local val = ex         local t1 = time()         println({\textquotedbl}elapsed time: {\textquotedbl}, t1-t0, {\textquotedbl} seconds{\textquotedbl})         val     end end




\begin{lstlisting}

Aquí, queremos que `t0`, `t1` y `val` sean variables temporales privadas, y queremos que `time` se refiera a la función [`time()`](@ref) de la biblioteca estándar, no a cualquier variable de tiempo que el usuario pueda tener (lo mismo se aplica a `println`). Imagine los problemas que podrían ocurrir si la expresión de usuario `ex` también contuviera asignaciones a una variable denominada `t0`, o definiese su propia variable `time`. Podríamos obtener errores o comportamiento misteriosamente incorrecto.


El expansor de macro de Julia resuelve estos problemas de la siguiente manera. En primer lugar, las variables dentro de un resultado de macro se clasifican como locales o globales. Una variable se considera local si es asignada (y no se declara global), se declara local o se utiliza como un nombre de argumento de función. De lo contrario, se considera global. Las variables locales son renombradas como únicas (utilizando la función [`gensym()`](@ref), que genera nuevos símbolos), y las variables globales se resuelven dentro del entorno de definición de macro. Por lo tanto, ambas preocupaciones se manejan; Los locales de la macro no entrarán en conflicto con ninguna variable de usuario, y `time` y `println` se referirán a las definiciones de la biblioteca estándar.

Sin embargo, queda un problema. Considere el siguiente uso de esta macro:

\end{lstlisting}



julia module MyModule import Base.@time



time() = ... \# compute something



@time time() end




\begin{lstlisting}

Aquí la expresión de usuario `ex` es una llamada a `time`, pero no a la misma función `time` que usa la macro, sino que se refiere claramente a `MyModule.time`. Por tanto, debemos arreglar pora que el código en `ex` sea resuelto en el entorno de llamada de la macro. Esto se hace usando [`esc()`](@ref) para "escapar" la expresión:

\end{lstlisting}



julia macro time(ex)     ...     local val = esc(ex)     ... end




\begin{lstlisting}

Una expresión envuelta de esta manera es dejada sola por el expansor de macros y simplemente pegada en la salida. Por tanto, será resuelta en el entorno de llamada de la macro.

El mecanismo de "escapar" puede ser usado para "violar" la higiene cuando sea necesario, para introducir o manipular variables de usuario. Por ejemplo, la siguiente macro fija `x` a cero en el entorno de llamada:

\end{lstlisting}



jldoctest julia> macro zerox()            return esc(:(x = 0))        end @zerox (macro with 1 method)



julia> function foo()            x = 1            @zerox            return x \# is zero        end foo (generic function with 1 method)



julia> foo() 0




\begin{lstlisting}

Esta clase de manipulación de variables debería ser usada juiciosamente, pero es ocasionalmente bastante útil.

Obtener las normas de higiene correctas puede ser un desafío formidable. Antes de usar una macro, es posible que desee considerar si un cierre de función sería suficiente. Otra estrategia útil es diferir tanto trabajo como sea posible para el tiempo de ejecución. Por ejemplo, muchas macros simplemente envuelven sus argumentos en un QuoteNode u otro Expr similar. Algunos ejemplos de esto incluyen `@task body` que simplemente devuelve `schedule (Task(() -> $ body))`, y `@eval expr`, que simplemente devuelve `eval (QuoteNode (expr))`.

Obtener las normas de higiene correctas puede ser un desafío formidable. Antes de usar una macro, es posible que desee considerar si un cierre de función sería suficiente. Otra estrategia útil es diferir tanto trabajo como sea posible para el tiempo de ejecución. Por ejemplo, muchas macros simplemente envuelven sus argumentos en un QuoteNode u otro Expr similar. Algunos ejemplos de esto incluyen `@task body` que simplemente devuelve` schedule (Task (() -> $ body)) `, y` @eval expr`, que simplemente devuelve `eval (QuoteNode (expr))`.

Para demostrarlo, podríamos reescribir el ejemplo `@time` anterior como:

\end{lstlisting}



julia macro time(expr)     return :(timeit(() -> esc(expr))) end function timeit(f)     t0 = time()     val = f()     t1 = time()     println({\textquotedbl}elapsed time: {\textquotedbl}, t1-t0, {\textquotedbl} seconds{\textquotedbl})     return val end




\begin{lstlisting}

Sin embargo, no hacemos esto por una buena razón: al envolver el `expr` en un nuevo bloque de alcance (la función anónima) también cambia ligeramente el significado de la expresión (el alcance de cualquier variable en él), mientras que queremos` @ time` para ser utilizable con un impacto mínimo en el código ajustado.

## Generación de Código

Cuando se requiere una cantidad significativa de código repetitivo, es común generarlo programáticamente para evitar la redundancia. En la mayoría de los lenguajes, esto requiere un paso de construcción adicional y un programa separado para generar el código repetitivo. En Julia, la interpolación de expresión y [`eval()`](@ref) permiten que dicha generación de código tenga lugar en el curso normal de la ejecución del programa. Por ejemplo, el siguiente código define una serie de operadores en tres argumentos en términos de sus formas de 2 argumentos:

\end{lstlisting}



julia for op = (:+, :*, :\&, :|, :\()     eval(quote         (\)op)(a,b,c) = (\(op)((\)op)(a,b),c)     end) end




\begin{lstlisting}

De este modo, Julia actúa como su propio [preprocesador](https://en.wikipedia.org/wiki/Preprocessor), y permite la generación de código desde dentro del lenguaje. El código anterior debería ser escrito ligeramente más secamente usando la forma prefija de citación `:`

\end{lstlisting}



julia for op = (:+, :*, :\&, :|, :\()     eval(:((\)op)(a,b,c) = (\(op)((\)op)(a,b),c))) end




\begin{lstlisting}

En este tipo de generación de código dentro del lenguaje utilizando el patrón `eval(quote(...))` es bastante común, sin embargo, que Julia venga con una macro para abreviar este patrón:

\end{lstlisting}



julia for op = (:+, :*, :\&, :|, :\()     @eval (\)op)(a,b,c) = (\(op)((\)op)(a,b),c) end




\begin{lstlisting}

La macro [`@eval`](@ref) reescribe esta llamada para ser precisamente equivalente a las versiones largas anteriores. Para bloques de código generado más grandes, el argumento expresión dado a [`@eval`](@ref) puede ser un bloque:

\end{lstlisting}



julia @eval begin     \# multiple lines end




\begin{lstlisting}

## Literales de cadena no estándar

Recuerde de [Strings](@ref non-standard-string-literals) que los literales de cadena prefijados por un identificador se llaman literales de cadena no estándar y pueden tener semántica distinta que los literales de cadena no prefijados. Por ejemplo:

* `r"^\s*(?:#|$)"` produces un objeto expresión regular en lugar de una cadena.
* `b"DATA\xff\u2200"` es un literal array bytepara `[68,65,84,65,255,226,136,128]`.

Tal vez sorprendentemente, estos comportamientos no están codificados en el analizador de Julia o en el compilador. En su lugar, son comportamientos personalizados proporcionados por un mecanismo general que cualquiera puede utilizar: los literales de cadenas prefijados se analizan como llamadas a macros de nombre especial. Por ejemplo, la macro de expresiones regulares es sólo la siguiente:

\end{lstlisting}



julia macro r\_str(p)     Regex(p) end




\begin{lstlisting}

Eso es todo. Esta macro dice que el contenido literal de la cadena literal `r"^\s*(?:#|$)"` debe ser pasado a la macro `@r_str` y que el resultado de esa expansión debe colocarse en el árbol de sintaxis donde tiene lugar la cadena literal. En otras palabras, la expresión `r"^\s*(?:#|$)"` equivale a colocar el siguiente objeto directamente en el árbol de sintaxis:

\end{lstlisting}



julia Regex({\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl})




\begin{lstlisting}

No sólo la forma literal de la cadena es más corta y mucho más conveniente, sino que también es más eficiente: puesto que la expresión regular se compila y el objeto Regex se crea realmente *cuando el código es compilado*, la compilación se produce sólo una vez, Se ejecuta el código. Considere si la expresión regular se produce en un bucle:


\end{lstlisting}



julia for line = lines     m = match(r{\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}, line)     if m === nothing         \# non-comment     else         \# comment     end end




\begin{lstlisting}

Como la expresión regular `r"^\s*(?:#|$)"` Se compila e inserta en el árbol de sintaxis cuando se analiza este código, la expresión sólo se compila una vez en lugar de cada vez que se ejecuta el bucle. Para lograr esto sin macros, uno tendría que escribir este bucle así:

\end{lstlisting}



julia re = Regex({\textquotedbl}{\textasciicircum}{\textbackslash}s*(?:\#|\$){\textquotedbl}) for line = lines     m = match(re, line)     if m === nothing         \# non-comment     else         \# comment     end end




\begin{lstlisting}

Por otra parte, si el compilador no pudiera determinar que el objeto regex era constante en todos los bucles, ciertas optimizaciones podrían no ser posibles, haciendo esta versión aún menos eficiente que la forma literal más conveniente de arriba. Por supuesto, todavía hay situaciones en las que la forma no literal es más conveniente: si se necesita interpolar una variable en la expresión regular, se debe tomar este enfoque más detallado; En los casos en que el patrón de expresión regular mismo es dinámico, cambiando potencialmente en cada iteración del bucle, un nuevo objeto expresión regular debe ser construido en cada iteración. Sin embargo, en la gran mayoría de los casos de uso, las expresiones regulares no se construyen sobre la base de datos de tiempo de ejecución. En esta mayoría de casos, la capacidad de escribir expresiones regulares como valores en tiempo de compilación es valiosísima.

Al igual que los literales de cadena no estándar, existen literales de comandos no estándar que usan una variante prefijada de la sintaxis literal del comando. El comando literal ```custom `literal` ``` se analiza como `@custom_cmd "literal"`. Julia por sí misma no contiene ningún literal de comando no estándar, pero los paquetes pueden hacer uso de esta sintaxis. Aparte de la sintaxis diferente y el sufijo `_cmd` en lugar del sufijo` _str`, los literales de comandos no estándar se comportan exactamente como los literales de cadena no estándar.

En el caso de que dos módulos proporcionen cadenas o literales de comando con el mismo nombre, es posible calificar la cadena o literal de comando con un nombre de módulo. Por ejemplo, si tanto `Foo` como` Bar` proporcionan literal de cadena no estándar `@x_str`, entonces uno puede escribir `Foo.x "literal"` o `Bar.x "literal" `para desambiguar entre los dos.

El mecanismo para literales de cadena definidos por el usuario es profundo, profundamente poderoso. No sólo son literales no estándar de Julia implementados usándolos, sino que también se implementa la sintaxis literal de comandos (``` `echo "Hello, $person"` ```) se implementa con la siguiente macro de aspecto inofensivo:

\end{lstlisting}



julia macro cmd(str)     :(cmd\_gen((shell\_parse(str))[1])) end




\begin{lstlisting}

Por supuesto, una gran cantidad de complejidad se oculta en las funciones utilizadas en esta definición de macro, pero son sólo funciones, escritas íntegramente en Julia. Usted puede leer su fuente y ver exactamente lo que hacen -y todo lo que hacen es construir objetos de expresión para ser insertados en el árbol de sintaxis de su programa.

## Funciones Generadas

Una macro muy especial es `@generated`, que permite definir las llamadas *funciones generadas*. Éstas tienen la capacidad de generar código especializado dependiendo de los tipos de sus argumentos con más flexibilidad y/o menos código que lo que se puede lograr con el despacho múltiple. Mientras las macros trabajan con expresiones al momento de analizar y no pueden acceder a los tipos de sus entradas, una función generada se amplía en un momento en que se conocen los tipos de los argumentos, pero la función aún no se ha compilado.

En lugar de realizar algún cálculo o acción, una declaración de función generada devuelve una expresión entre comillas que luego forma el cuerpo para el método correspondiente a los tipos de los argumentos. Cuando se llama, la expresión del cuerpo se compila (o se extrae de una caché, en las llamadas posteriores) y sólo se evalúa la expresión devuelta, y no el código que lo generó. Así, las funciones generadas proporcionan un marco flexible para mover el trabajo desde el tiempo de ejecución hasta el tiempo de compilación.

Cuando se definen las funciones generadas, hay tres diferencias principales con las funciones ordinarias:

1. Uno anota la declaración de función con la macro `@generated`. Esto agrega cierta información a la AST que permite al
   compilador saber que se trata de una función generada.
2. En el cuerpo de la función generada sólo tiene acceso a los *tipos* de los argumentos, no a sus valores – y cualquier
   función que fuera definida *antes* de la definición de la función generada.
3. En lugar de calcular algo o realizar alguna acción, devuelve una *expresión citada* que, cuando se evalúa, hace lo
   que uno quiere.
4. Las funciones generadas no deben *mutar* ni *observar* ningún estado global no constante (incluidos, por ejemplo, 
   IO, bloqueos, diccionarios no locales o que usen `method_exists`). Esto significa que solo pueden leer constantes 
   globales y no pueden tener ningún efecto secundario. En otras palabras, deben ser completamente puros. Debido a 
   una limitación de implementación, esto también significa que actualmente no pueden definir un cierre o un generador 
   sin tipo.

Es más fácil ilustrar esto con un ejemplo. Podemos declarar una función generada `foo` como:

\end{lstlisting}



jldoctest generated julia> @generated function foo(x)            Core.println(x)            return :(x * x)        end foo (generic function with 1 method)




\begin{lstlisting}

Tenga en cuenta que el cuerpo devuelve una expresión entre comillas, a saber `:(x * x)`, en lugar de sólo el valor de `x * x`.

Desde la perspectiva del llamador, son muy similares a las funciones regulares; de hecho, no tienes que saber si estás llamando a una función regular o generada  -la sintaxis y el resultado de la llamada son iguales. Veamos cómo se comporta `foo`:

\end{lstlisting}



jldoctest generated julia> x = foo(2); \# note: output is from println() statement in the body Int64



julia> x           \# now we print x 4



julia> y = foo({\textquotedbl}bar{\textquotedbl}); String



julia> y {\textquotedbl}barbar{\textquotedbl}




\begin{lstlisting}

Así, vemos que en el cuerpo de la función generada, `x` es el tipo del argumento pasado, y el valor devuelto por la función generada es el resultado de la evaluación de la expresión citada que devolvimos de la definición, ahora con el *valor* de `x`.

¿Qué pasa si evaluamos foo de nuevo con un tipo que ya hemos utilizado?

\end{lstlisting}



jldoctest generated julia> foo(4) 16




\begin{lstlisting}

Tenga en cuenta que no hay ninguna impresión de [`Int64`](@ref). El cuerpo de la función generada sólo se ejecuta una vez (no es enteramente cierto, véase la nota a continuación) cuando se compila el método para ese conjunto específico de tipos de argumentos. Después de eso, la expresión devuelta de la función generada en la primera invocación se vuelve a utilizar como el cuerpo del método.

La cantidad de veces que se genera una función generada *podría* ser solo una vez, pero *podría* también ser más frecuente o no aparecer en absoluto. Como consecuencia, *nunca* debe escribir una función generada con efectos secundarios: cuándo y con qué frecuencia ocurren los efectos secundarios no está definida. (Esto también es válido para las macros, y al igual que para las macros, el uso de [`eval()`](@ref) en una función generada es una señal de que estás haciendo algo incorrecto.) Sin embargo, a diferencia de las macros , el sistema de tiempo de ejecución no puede manejar correctamente una llamada a [`eval()`](@ref), por lo que no se permite.

También es importante ver cómo las funciones `@generated` interactúan con la redefinición del método. Siguiendo el principio de que una función correcta `@ generated` no debe observar ningún estado mutable ni causar ninguna mutación del estado global, vemos el siguiente comportamiento. Observe que la función generada *no puede* llamar a ningún método que no se haya definido antes de la * definición * de la función generada en sí.

Inicialmente `f (x)` tiene una definición:

\end{lstlisting}



jldoctest redefinition julia> f(x) = {\textquotedbl}original definition{\textquotedbl};




\begin{lstlisting}

Define otras operaciones que usan `f(x)`:

\end{lstlisting}



jldoctest redefinition julia> g(x) = f(x);



julia> @generated gen1(x) = f(x);



julia> @generated gen2(x) = :(f(x));




\begin{lstlisting}

Ahora añadimos algunas definiciones nuevas para `f(x)`:

\end{lstlisting}



jldoctest redefinition julia> f(x::Int) = {\textquotedbl}definition for Int{\textquotedbl};



julia> f(x::Type\{Int\}) = {\textquotedbl}definition for Type\{Int\}{\textquotedbl};




\begin{lstlisting}

y comparamos cómo difieren estos resultados:

\end{lstlisting}



jldoctest redefinition julia> f(1) {\textquotedbl}definition for Int{\textquotedbl}



julia> g(1) {\textquotedbl}definition for Int{\textquotedbl}



julia> gen1(1) {\textquotedbl}original definition{\textquotedbl}



julia> gen2(1) {\textquotedbl}definition for Int{\textquotedbl}




\begin{lstlisting}

Cada método de una función generada tiene su propia visión de funciones definidas:

\end{lstlisting}



jldoctest redefinition julia> @generated gen1(x::Real) = f(x);



julia> gen1(1) {\textquotedbl}definition for Type\{Int\}{\textquotedbl}




\begin{lstlisting}
La función de ejemplo `foo` anterior no hizo nada de lo que una función normal` foo(x) = x*x` no pudo hacer (excepto imprimir el tipo en la primera invocación y incurrir en una sobrecarga más alta). Sin embargo, el poder de una función generada radica en su capacidad para calcular diferentes expresiones entrecomilladas según los tipos que se le pasen:

\end{lstlisting}



jldoctest julia> @generated function bar(x)            if x <: Integer                return :(x {\textasciicircum} 2)            else                return :(x)            end        end bar (generic function with 1 method)



julia> bar(4) 16



julia> bar({\textquotedbl}baz{\textquotedbl}) {\textquotedbl}baz{\textquotedbl}




\begin{lstlisting}

(although por supuesto este ejemplo artificial se implementa facilmente usando despacho múltiple...

Podemos, por supuesto, abusar de esto para producir algún comportamiento interesante:

\end{lstlisting}



jldoctest julia> @generated function baz(x)            if rand() < .9                return :(x{\textasciicircum}2)            else                return :({\textquotedbl}boo!{\textquotedbl})            end        end baz (generic function with 1 method)




\begin{lstlisting}

ado que el cuerpo de la función generada es no determinista, su comportamiento es indefinido.

*¡No copie estos ejemplos!*

Estos ejemplos sirven para ilustrar cómo funcionan las funciones generadas, tanto en el extremo de la definición como en el sitio de llamada; Sin embargo, no los copie, por las siguientes razones:

  * La función `foo` tiene efectos secundarios (la llamada a `Core.println`) y no está definida exactamente cuándo, 
    con qué frecuencia o cuántas veces se producirán estos efectos secundarios
  * La función `bar` resuelve un problema que se resuelve mejor con el despacho múltiple - definiendo `bar(x) = x` 
    y `bar(x :: Integer) = x ^ 2` hará la misma cosa, pero es más simple y más rápido.
  * La función `baz` es patológicamente insana

Tenga en cuenta que el conjunto de operaciones que no se deben intentar en una función generada no tiene límites, y el sistema de tiempo de ejecución solo puede detectar actualmente un subconjunto de las operaciones no válidas. Hay muchas otras operaciones que simplemente corromperán el sistema de tiempo de ejecución sin notificación, por lo general de maneras sutiles que obviamente no están conectadas a la mala definición. Debido a que el generador de funciones se ejecuta durante la inferencia, debe respetar todas las limitaciones de ese código.

Algunas operaciones que no deberían intentarse incluyen:

1. Almacenamiento en caché de punteros nativos.
2. Interactuar de cualquier manera con los contenidos o métodos de Core.Inference.
3. Observar cualquier estado mutable.

     * La inferencia sobre la función generada se puede ejecutar en *cualquier* momento, incluso cuando el código intenta
       observar o modificar este estado.

4. Tomar cualquier bloqueo: código C que llame a puede utilizar bloqueos internos, (por ejemplo, no es problemático 
   para llamar `malloc`, a pesar de que la mayoría de las implementaciones requieren bloqueos internos), pero no 
   pretenden mantener o adquirir cualquier tiempo ejecutando el código de Julia.
5. Llamar a cualquier función que esté definida después del cuerpo de la función generada. Esta condición se relaja 
   para los módulos precompilados de carga incremental para permitir llamar a cualquier función en el módulo.

De acuerdo, ahora que tenemos una mejor comprensión de cómo funcionan las funciones generadas, utilicémoslas para construir algunas funcionalidades más avanzadas (y válidas) ...

### An advanced example

La biblioteca base de Julia tiene una función  [`sub2ind()`](@ref) para calcular un índice lineal en una matriz n-dimensional, basada en un conjunto de n índices multilineales - en otras palabras, para calcular el índice `i` que se puede usar para indexar en una matriz `A` usando `A[i]`, en lugar de `A[x, y, z, ...]`. Una posible implementación es la siguiente:

\end{lstlisting}



jldoctest sub2ind julia> function sub2ind\_loop(dims::NTuple\{N\}, I::Integer...) where N            ind = I[N] - 1            for i = N-1:-1:1                ind = I[i]-1 + dims[i]*ind            end            return ind + 1        end sub2ind\_loop (generic function with 1 method)



julia> sub2ind\_loop((3, 5), 1, 2) 4




\begin{lstlisting}

Lo mismo puede hacerse usando recursión:

\end{lstlisting}



jldoctest julia> sub2ind\_rec(dims::Tuple\{\}) = 1;



julia> sub2ind\_rec(dims::Tuple\{\}, i1::Integer, I::Integer...) =            i1 == 1 ? sub2ind\_rec(dims, I...) : throw(BoundsError());



julia> sub2ind\_rec(dims::Tuple\{Integer, Vararg\{Integer\}\}, i1::Integer) = i1;



julia> sub2ind\_rec(dims::Tuple\{Integer, Vararg\{Integer\}\}, i1::Integer, I::Integer...) =            i1 + dims[1] * (sub2ind\_rec(Base.tail(dims), I...) - 1);



julia> sub2ind\_rec((3, 5), 1, 2) 4




\begin{lstlisting}

Ambas implementaciones, aunque diferentes, hacen esencialmente lo mismo: un bucle de tiempo de ejecución sobre las dimensiones de la matriz, recogiendo el desplazamiento en cada dimensión en el índice final.

Sin embargo, toda la información que necesitamos para el bucle está incrustada en la información de tipo de los argumentos. Por lo tanto, podemos utilizar las funciones generadas para mover la iteración a tiempo de compilación; en la jerga del compilador, usamos las funciones generadas para desenrollar manualmente el bucle. El cuerpo se vuelve casi idéntico, pero en vez de calcular el índice lineal, construimos una *expresión* que calcula el índice:

\end{lstlisting}



jldoctest sub2ind\_gen julia> @generated function sub2ind\_gen(dims::NTuple\{N\}, I::Integer...) where N            ex = :(I[\(N] - 1)            for i = (N - 1):-1:1                ex = :(I[\)i] - 1 + dims[\(i] * $ex)            end            return :(\)ex + 1)        end sub2ind\_gen (generic function with 1 method)



julia> sub2ind\_gen((3, 5), 1, 2) 4




\begin{lstlisting}

**¿Qué código generará esto?**

Una forma sencilla de averiguarlo es extraer el cuerpo en otra función (regular):

\end{lstlisting}



jldoctest sub2ind\_gen2 julia> @generated function sub2ind\_gen(dims::NTuple\{N\}, I::Integer...) where N            return sub2ind\_gen\_impl(dims, I...)        end sub2ind\_gen (generic function with 1 method)



julia> function sub2ind\_gen\_impl(dims::Type\{T\}, I...) where T <: NTuple\{N,Any\} where N            length(I) == N || return :(error({\textquotedbl}partial indexing is unsupported{\textquotedbl}))            ex = :(I[\(N] - 1)            for i = (N - 1):-1:1                ex = :(I[\)i] - 1 + dims[\(i] * $ex)            end            return :(\)ex + 1)        end sub2ind\_gen\_impl (generic function with 1 method)




\begin{lstlisting}

Ahora podemos ejecutar `sub2ind_gen_impl` y examinar la expresión que devuelve

\end{lstlisting}



jldoctest sub2ind\_gen2 julia> sub2ind\_gen\_impl(Tuple\{Int,Int\}, Int, Int) :(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1) ```



Por lo tanto, el cuerpo de método que se utilizará aquí no incluye un bucle en absoluto - sólo indexación en las dos tuplas, multiplicación y suma/resta. Todo el bucle se realiza en tiempo de compilación, y evitamos el bucle durante la ejecución por completo. Por lo tanto, sólo se realiza el bucle una vez por tipo, en este caso una vez por \texttt{N} (excepto en casos de borde donde la función se genera más de una vez - véase la exención de responsabilidad anterior).



\hypertarget{12380164357355707963}{}


\chapter{Arrays Multi-dimensionales}



Julia, como la mayoría de los lenguajes informáticos técnicos, proporciona una implementación de los arrays de primera clase. La mayoría de los lenguajes informáticos técnicos prestan mucha atención a su implementación de arrays a expensas de otros contenedores. Julia no trata los arrays de manera especial. La biblioteca de arrays se ha implementado casi completamente en el propio lenguaje Julia, y deriva su rendimiento del compilador, al igual que cualquier otro código escrito en Julia. Como tal, es también posible definir tipos de arrays personalizados heredando de AbstractArray. Consulte la \hyperlink{522338241536202486}{sección de manual en la interfaz AbstractArray} para ms detalles sobre implementar un tipo array personalizado.



Un array es una colección de objetos almacenados en una cuadrícula multidimensional. En el caso más general, un array puede contener objetos de tipo \texttt{Any}. Para la mayoría de los propósitos computacionales, los arrays deben contener objetos de un tipo más específico, como  \hyperlink{5027751419500983000}{\texttt{Float64}} o \hyperlink{10103694114785108551}{\texttt{Int32}}.



En general, a diferencia de muchos otros lenguajes informáticos técnicos, Julia no espera que los programas se escriban en un estilo vectorizado para el rendimiento. El compilador de Julia utiliza la inferencia de tipos y genera código optimizado para la indexación escalar de arrays, permitiendo que los programas se escriban en un estilo que sea conveniente y legible, sin sacrificar el rendimiento y utilizando menos memoria a veces.



En Julia, todos los argumentos a las funciones se pasan por referencia. Algunos lenguajes informáticos técnicos pasan los arrays por valor, y esto es conveniente en muchos casos. En Julia, las modificaciones hechas a los arrays de entrada dentro de una función serán visibles en la función principal. Toda la biblioteca de arrays de Julia garantiza que las entradas no sean modificadas por las funciones de biblioteca. El código de usuario, si necesita mostrar un comportamiento similar, debe tener cuidado de crear una copia de las entradas que puede modificar.



\hypertarget{15299817005323384893}{}


\section{Arrays}



\hypertarget{3742150230926700713}{}


\subsection{Funciones Básicas}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\hyperlink{6396209842929672718}{\texttt{eltype(A)}} & Tipo de los elementos contenidos en \texttt{A} \\
\hline
\hyperlink{4781133548011803693}{\texttt{length(A)}} & Número de elementos en \texttt{A} \\
\hline
\hyperlink{1688406579181746010}{\texttt{ndims(A)}} & Número de dimensiones de \texttt{A} \\
\hline
\hyperlink{17888996102305087038}{\texttt{size(A)}} & Una tupla que contien las dimensiones de \texttt{A} \\
\hline
\hyperlink{17888996102305087038}{\texttt{size(A,n)}} & El tamaño de \texttt{A} a lo largo de una dimensión particular \texttt{n} \\
\hline
\hyperlink{16112307926804387301}{\texttt{indices(A)}} & Una tupla que contiene los índices válidos de \texttt{A} \\
\hline
\hyperlink{16112307926804387301}{\texttt{indices(A,n)}} & Un rango expresando los úndices válidos a lo largo de la dimensión \texttt{n}           \\
\hline
\hyperlink{4701773772897287974}{\texttt{eachindex(A)}} & Un iterador eficiente para visitar cada posición en \texttt{A} \\
\hline
\hyperlink{97811245619734938}{\texttt{stride(A,k)}} & La zancada (\emph{stride}, distancia de índice lineal entre elementos adyacentes) a lo largo de la dimensión \texttt{k}. \\
\hline
\hyperlink{13576557637670855932}{\texttt{strides(A)}} & Una tupla de las zancadas en cada dimensión \\
\hline
\end{tabulary}

\end{table}



\hypertarget{2718974068386098500}{}


\subsection{Construcción e Inicialización}



Existen muchas funciones para construir e inicializar matrices. En la siguiente lista de tales funciones, las llamadas con un argumento \texttt{dims...} pueden tomar una sola tupla de tamaños de dimensión o una serie de tamaños de dimensión pasados como un número variable de argumentos. Muchas de estas funciones también aceptan un primea entrada \texttt{T}, que es el tipo de los elementos del array. Si este tipo es omitido se asumirá como tipo por defecto por defecto \hyperlink{5027751419500983000}{\texttt{Float64}}.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\hyperlink{15492651498431872487}{\texttt{Array\{T\}(dims...)}} & an uninitialized dense \hyperlink{15492651498431872487}{\texttt{Array}} \\
\hline
\hyperlink{13837674686090348619}{\texttt{zeros(T, dims...)}} & an \texttt{Array} of all zeros \\
\hline
\hyperlink{13837674686090348619}{\texttt{zeros(A)}} & an array of all zeros with the same type, element type and shape as \texttt{A} \\
\hline
\hyperlink{5858390260510292771}{\texttt{ones(T, dims...)}} & an \texttt{Array} of all ones \\
\hline
\hyperlink{5858390260510292771}{\texttt{ones(A)}} & an array of all ones with the same type, element type and shape as \texttt{A} \\
\hline
\hyperlink{12844393578243965152}{\texttt{trues(dims...)}} & a \hyperlink{18015155802543401629}{\texttt{BitArray}} with all values \texttt{true} \\
\hline
\hyperlink{12844393578243965152}{\texttt{trues(A)}} & a \texttt{BitArray} with all values \texttt{true} and the same shape as \texttt{A} \\
\hline
\hyperlink{12518029339635756199}{\texttt{falses(dims...)}} & a \texttt{BitArray} with all values \texttt{false} \\
\hline
\hyperlink{12518029339635756199}{\texttt{falses(A)}} & a \texttt{BitArray} with all values \texttt{false} and the same shape as \texttt{A} \\
\hline
\hyperlink{3388738163419525310}{\texttt{reshape(A, dims...)}} & an array containing the same data as \texttt{A}, but with different dimensions \\
\hline
\hyperlink{15665284441316555522}{\texttt{copy(A)}} & copy \texttt{A} \\
\hline
\hyperlink{3259459540194502889}{\texttt{deepcopy(A)}} & copy \texttt{A}, recursively copying its elements \\
\hline
\hyperlink{18368531196314541873}{\texttt{similar(A, T, dims...)}} & an uninitialized array of the same type as \texttt{A} (dense, sparse, etc.), but with the specified element type and dimensions. The second and third arguments are both optional, defaulting to the element type and dimensions of \texttt{A} if omitted. \\
\hline
\hyperlink{293815781001952115}{\texttt{reinterpret(T, A)}} & an array with the same binary data as \texttt{A}, but with element type \texttt{T} \\
\hline
\hyperlink{791894090820620170}{\texttt{rand(T, dims...)}} & an \texttt{Array} with random, iid \footnotemark[1] and uniformly distributed values in the half-open interval \([0, 1)\) \\
\hline
\hyperlink{8153706463199753760}{\texttt{randn(T, dims...)}} & an \texttt{Array} with random, iid and standard normally distributed values \\
\hline
\hyperlink{245874853049830800}{\texttt{eye(T, n)}} & \texttt{n}-by-\texttt{n} identity matrix \\
\hline
\hyperlink{245874853049830800}{\texttt{eye(T, m, n)}} & \texttt{m}-by-\texttt{n} identity matrix \\
\hline
\hyperlink{11519832570242386196}{\texttt{linspace(start, stop, n)}} & range of \texttt{n} linearly spaced elements from \texttt{start} to \texttt{stop} \\
\hline
\hyperlink{5162290739791026948}{\texttt{fill!(A, x)}} & fill the array \texttt{A} with the value \texttt{x} \\
\hline
\hyperlink{2836152204730819918}{\texttt{fill(x, dims...)}} & an \texttt{Array} filled with the value \texttt{x} \\
\hline
\end{tabulary}

\end{table}



\footnotetext[1]{\emph{iid}, independently and identically distributed.

}


La sintaxis \texttt{[A, B, C, ...]} construye un array 1-dimensional (vector) a partir de sus argumentos. Si todos los argumentos tienen un \hyperlink{10686378388163930476}{tipo de promocion} comun entonces ellos son convertidos a este tipo usando \texttt{convert()}.



\hypertarget{10393014471752931909}{}


\subsection{Concatenación}



Los arrays pueden ser construídos y también concatenados usando las siguientes funciones:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\hyperlink{9868138443525443234}{\texttt{cat(k, A...)}} & concatena n-d arrays a lo largo de la dimensión \texttt{k} \\
\hline
\hyperlink{14691815416955507876}{\texttt{vcat(A...)}} & abreviatura para \texttt{cat(1, A...)} \\
\hline
\hyperlink{8862791894748483563}{\texttt{hcat(A...)}} & abreviatura para \texttt{cat(2, A...)} \\
\hline
\end{tabulary}

\end{table}



Los valores escalares pasados a estas funciones son tratados como arrays de 1 elemento.



Las funciones de concatenación se usan tan frecuentemente que tiene una sintaxis especial:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Expression & Calls \\
\hline
\texttt{[A; B; C; ...]} & \hyperlink{14691815416955507876}{\texttt{vcat()}} \\
\hline
\texttt{[A B C ...]} & \hyperlink{8862791894748483563}{\texttt{hcat()}} \\
\hline
\texttt{[A B; C D; ...]} & \hyperlink{16279083053557795116}{\texttt{hvcat()}} \\
\hline
\end{tabulary}

\end{table}



\hyperlink{16279083053557795116}{\texttt{hvcat()}} concatena tanto en la dimensión 1 (con puntos y coma) como en la dos (con espacios).



\hypertarget{40378116110818994}{}


\subsection{Inicializadores de Array Tipados}



Se puede construir una matriz con un tipo de elemento específico utilizando la sintaxis \texttt{T[A, B, C, ...]}. Esto construirá un array 1-d con el tipo de elemento \texttt{T}, inicializado para contener los elementos \texttt{A}, \texttt{B}, \texttt{C}, etc. Por ejemplo, \texttt{Any [x, y, z]} construye un array heterogéneo que puede contener cualquier valor.



La sintaxis de concatenación puede ser prefijada de forma similar con un tipo para especificar el tipo de elemento del resultado.




\begin{minted}{jlcon}
julia> [[1 2] [3 4]]
1×4 Array{Int64,2}:
 1  2  3  4

julia> Int8[[1 2] [3 4]]
1×4 Array{Int8,2}:
 1  2  3  4
\end{minted}



\hypertarget{10712284114727773149}{}


\subsection{Comprensiones}



Las comprensiones proporcionan una forma general y potente de construir arrays. Su sintaxis es similar a la notación de construcción de conjuntos en matemáticas:




\begin{lstlisting}
A = [ F(x,y,...) for x=rx, y=ry, ... ]
\end{lstlisting}



El significado de esta forma es que \texttt{F(x, y, ...)} es evaluado para las variables x, y, etc. tomando cada valor de la lista de valores proporcionada. Los valores se pueden especificar mediante cualquier objeto iterable, pero comúnmente serán rangos como \texttt{1:n} o \texttt{2:(n-1)}, o arrays de valores explícitos como \texttt{[1.2, 3.4, 5.7]}. El resultado es una matriz N-d densa con dimensiones que son la concatenación de las dimensiones de los rangos de las variables \texttt{rx}, \texttt{ry}, etc. y donde cada evaluación \texttt{F(x, y, ...)} devuelve un escalar.



El siguiente ejemplo calcula la media ponderada del elemento actual y su vecino izquierdo y derecho a lo largo de una rejilla unidimensional:




\begin{minted}{jlcon}
julia> x = rand(8)
8-element Array{Float64,1}:
 0.843025
 0.869052
 0.365105
 0.699456
 0.977653
 0.994953
 0.41084
 0.809411

julia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
6-element Array{Float64,1}:
 0.736559
 0.57468
 0.685417
 0.912429
 0.8446
 0.656511
\end{minted}



El tipo del array resultante depende de los tipos de los elementos calculados. Para controlar el tipo explícitamente, un tipo puede ser precedido a la comprensión. Por ejemplo, podríamos haber solicitado el resultado en precisión simple escribiendo:




\begin{minted}{julia}
Float32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]
\end{minted}



\hypertarget{5932317856076876818}{}


\subsection{Expresiones Generador}



Las comprensiones también se pueden escribir sin los corchetes que las encierran, produciendo un objeto conocido como \textbf{generador}. Este objeto puede ser iterado para producir valores bajo demanda, en lugar de reservar espacio para un array y almacenarlos en él de antemano (véase \hyperlink{5510379658285713272}{Iteración}). Por ejemplo, la siguiente expresión suma una serie sin asignar memoria:




\begin{minted}{jlcon}
julia> sum(1/n^2 for n=1:1000)
1.6439345666815615
\end{minted}



Cuando se escribe una expresión generador con múltiples dimensiones dentro de una lista de argumentos, se necesitan paréntesis para separar el generador de argumentos posteriores:




\begin{minted}{jlcon}
julia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])
ERROR: syntax: invalid iteration specification
\end{minted}



Todas las expresiones separadas por comas después del \texttt{for} se interpretan como rangos. Añadir paréntesis permite añadir un tercer argumento a \texttt{map}:




\begin{minted}{jlcon}
julia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])
2×2 Array{Tuple{Float64,Int64},2}:
 (0.5, 1)       (0.333333, 3)
 (0.333333, 2)  (0.25, 4)
\end{minted}



Los rangos en generadores y comprensiones pueden depender de rangos anteriores escribiendo varias palabras clave \texttt{for}:




\begin{minted}{jlcon}
julia> [(i,j) for i=1:3 for j=1:i]
6-element Array{Tuple{Int64,Int64},1}:
 (1, 1)
 (2, 1)
 (2, 2)
 (3, 1)
 (3, 2)
 (3, 3)
\end{minted}



En tales casos, el resultado es siempre unidimensional.



Los valores generados se pueden filtrar usando la palabra clave \texttt{if}:




\begin{minted}{jlcon}
julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]
2-element Array{Tuple{Int64,Int64},1}:
 (2, 2)
 (3, 1)
\end{minted}



\hypertarget{14469287548874312017}{}


\subsection{Indexación}



La sintaxis general para indexar en un array n-dimensional \texttt{A} es:




\begin{lstlisting}
X = A[I_1, I_2, ..., I_n]
\end{lstlisting}



donde cada \texttt{I\_k} puede ser un entero escalar, un array de enteros o cualquier otro \hyperlink{982887983034702059}{índice soportado}. Esto incluye \hyperlink{13649361117037263099}{\texttt{Colon}} (\texttt{:}) para seleccionar todos los índices dentro de la dimensión completa, rangos de la forma \texttt{a:c} o \texttt{a:b:c} para seleccionar subsecciones contiguas o con salto, y arrays de booleans para seleccionar elementos en sus índices \texttt{true}.



Si todos los índices son escalares, entonces el resultado \texttt{X} es un solo elemento del array \texttt{A}. De lo contrario, \texttt{X} es un array con el mismo número de dimensiones que la suma de las dimensionalidades de todos los índices.



Si todos los índices son vectores, por ejemplo, entonces la forma de \texttt{X} sería \texttt{(length(I\_1), length(I\_2), ..., length(I\_n))}, donde las ubicaciones \texttt{(i\_1, i\_2, ..., i\_n)} de \texttt{X} contienen el valor \texttt{A[I\_1[i\_1], I\_2[i\_2], ..., I\_n[i\_n]]}. Si \texttt{I\_1} se cambia por un array bidimensional, entonces \texttt{X} se vuelve un \texttt{n+1}-dimensional array de forma \texttt{(size(I\_1, 1), size(I\_1, 2), length(I\_2), ..., length(I\_n))}. La matriz añade una dimensión. La ubicación \texttt{(i\_1, i\_2, i\_3, ..., i\_\{n+1\})} contiene el valor en \texttt{A[I\_1[i\_1, i\_2], I\_2[i\_3], ..., I\_n[i\_\{n+1\}]]}. Todas las dimensiones indexadas con escalares se eliminan. Por ejemplo, el resultado de \texttt{A[2, I, 3]} es un array de tamaño \texttt{size(I)}. Su i-ésimo elemento es poblado por \texttt{A[2, I[i], 3]}.



Como parte especial de esta sintaxis, se puede usar la palabra clave \texttt{end} para representar el último índice de cada dimensión dentro de los corchetes de indexación, según lo determinado por el tamaño del array más interno indexado. La sintaxis de indexación sin la palabra \texttt{end} es equivalente a una llamada a \texttt{getindex}:




\begin{lstlisting}
X = getindex(A, I_1, I_2, ..., I_n)
\end{lstlisting}



Example:




\begin{minted}{jlcon}
julia> x = reshape(1:16, 4, 4)
4×4 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[2:3, 2:end-1]
2×2 Array{Int64,2}:
 6  10
 7  11

julia> x[1, [2 3; 4 1]]
2×2 Array{Int64,2}:
  5  9
 13  1
\end{minted}



Los rangos vacío de la forma \texttt{n:n-1} se suelen usar para indicar la localización inter-index entre \texttt{n-1} y \texttt{n}. Por ejemplo, la función \hyperlink{17287969759719368562}{\texttt{searchsorted()}} usa esta convención para indicar el punto de inserción de un valor no encontrados en un array ordenado:




\begin{minted}{jlcon}
julia> a = [1,2,5,6,7];

julia> searchsorted(a, 3)
3:2
\end{minted}



\hypertarget{5433025065156514046}{}


\subsection{Asignación}



La sintaxis general para asignar valores en un array n-dimensional \texttt{A} es:




\begin{lstlisting}
A[I_1, I_2, ..., I_n] = X
\end{lstlisting}



donde cada \texttt{I\_k} puede ser un índice escalar, un array de enteros o cualquier otro \hyperlink{982887983034702059}{índice soportado}. Esto incluye \hyperlink{13649361117037263099}{\texttt{Colon}} (\texttt{:}) para seleccionar todos los índices dentro de la dimensión completa, rangos de la forma \texttt{a:c} o \texttt{a:b:c} para seleccionar subsecciones contiguas o con salto, y arrays de booleans para seleccionar elementos en sus índices \texttt{true}.



Si \texttt{X} es un array, debe tener el mismo número de elementos que el producto de las longitudes de los índices \texttt{prod(length(I\_1), length(I\_2), ..., length(I\_n))}. El valor en la localización \texttt{I\_1[i\_1], I\_2[i\_2], ..., I\_n[i\_n]}de \texttt{A} es sobreescrito con el valor \texttt{X[i\_1, i\_2, ..., i\_n]}. Si \texttt{X} no es un array, su valor es escrito a todas las localizaciones referenciadas de \texttt{A}.



Justo como en \hyperlink{14469287548874312017}{Indexación}, la palabra clave \texttt{end} puede utilizarse para representar el último índice de cada dimensión dentro de los corchetes de los índices, como queda determinado por el tamaño del array en el que se está siendo asignado. La sintaxis de la asignación indexada sin la palabra clave \texttt{end} es equivalente a llamar a la función \hyperlink{17903591429492118749}{\texttt{setindex!()}}:




\begin{lstlisting}
setindex!(A, X, I_1, I_2, ..., I_n)
\end{lstlisting}



Ejemplo:




\begin{minted}{jlcon}
julia> x = collect(reshape(1:9, 3, 3))
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9

julia> x[1:2, 2:3] = -1
-1

julia> x
3×3 Array{Int64,2}:
 1  -1  -1
 2  -1  -1
 3   6   9
\end{minted}



\hypertarget{982887983034702059}{}


\subsection{Tipos de Índices Soportados}



En la expresión \texttt{A[I\_1, I\_2, ..., I\_n]}, cada \texttt{I\_k} puede ser un índice escalar, un array de índices escalares o un objeto que repreenta un array de índices escalares y puede ser convertido a tal mediante \hyperlink{10027537986402266830}{\texttt{to\_indices}}:



\begin{itemize}
\item[1. ] Un índice escalar. Por defecto esto incluye:

\begin{itemize}
\item Enteros no booleanos


\item \texttt{CartesianIndex\{N\}}s, que se comportan como una \texttt{N}-tupla de enteros abarcando múltiples dimensiones (ver abajo para ms detalles)

\end{itemize}

\item[2. ] Un array de índices escalares. Esto incluye:

\begin{itemize}
\item Vectores y arrays multidimensionales de enteros


\item Arrays vacíos como \texttt{[]}, que no selecciona elementos


\item \texttt{Range}s de la forma \texttt{a:c} o \texttt{a:b:c}, que seleccionan subsecciones contiguas o con salto desde \texttt{a} hasta \texttt{c} (inclusive)


\item Cualquier array de índices escalares que sea un subtipo de \texttt{AbstractArray}


\item Arrays de \texttt{CartesianIndex\{N\}} (ver abajo para ms detalles)

\end{itemize}

\item[3. ] Un objeto que representa un array de índice escalares y puede ser convertido a tal mediante \hyperlink{10027537986402266830}{\texttt{to\_indices}}. Por defecto esto incluye:

\begin{itemize}
\item \hyperlink{13649361117037263099}{\texttt{Colon()}} (\texttt{:}), que representa todos los índices dentro de una dimensión entera o a través del array completo


\item Arrays de booleans, que seleccionan los elementos en los que sus índices son \texttt{true} indices (ver abajo para más detalles)

\end{itemize}
\end{itemize}


\hypertarget{4655120660876939995}{}


\subsubsection{Índices Cartesianos}



El objeto especial \texttt{CartesianIndex\{N\}} representa un índice escalar que se comporta como una \texttt{N}-tupla de enteros que abarcan multiples dimensioneas. Por ejemplo:




\begin{lstlisting}
julia> A = reshape(1:32, 4, 4, 2);

julia> A[3, 2, 1]
7

julia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7
true
\end{lstlisting}



Considerado solo, esto puede parecer relativamente trivial; \texttt{CartesianIndex} simplemente reúne múltiples enteros juntos en un objeto que representa un único índice multidimensional. Sin embargo, cuando se combina con otras formas de indexación e iteradores que producen \texttt{CartesianIndex}es, esto puede conducir directamente a un código muy elegante y eficiente. Ver \hyperlink{5510379658285713272}{Iteración} a continuación, y para algunos ejemplos más avanzados, ver \href{https://julialang.org/blog/2016/02/iteration}{esta publicación en el blog sobre algoritmos multidimensionales e iteración}.



Los \emph{arrays} de \texttt{CartesianIndex\{N\}} también sestán soportados. Representan una colección de índices escalares que abarcan   \texttt{N} dimensiones cada uno, lo que permite una forma de indexación que a veces se denomina \emph{indexación puntual}. Por ejemplo, permite acceder a los elementos diagonales desde la primera {\textquotedbl}página{\textquotedbl} de {\textquotesingle}A{\textquotesingle} desde arriba:




\begin{lstlisting}
julia> page = A[:,:,1]
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> page[[CartesianIndex(1,1),
             CartesianIndex(2,2),
             CartesianIndex(3,3),
             CartesianIndex(4,4)]]
4-element Array{Int64,1}:
  1
  6
 11
 16
\end{lstlisting}



Esto se puede expresar mucho más simplemente con \hyperlink{13590013989415065742}{\emph{dot broadcasting}} y combinándolo con un índice entero normal (en lugar de extraer la primera página de\texttt{A} como un paso separado). Incluso se puede combinar con \texttt{:} para extraer ambas diagonales de las dos páginas al mismo tiempo:




\begin{lstlisting}
julia> A[CartesianIndex.(indices(A, 1), indices(A, 2)), 1]
4-element Array{Int64,1}:
  1
  6
 11
 16

julia> A[CartesianIndex.(indices(A, 1), indices(A, 2)), :]
4×2 Array{Int64,2}:
  1  17
  6  22
 11  27
 16  32
\end{lstlisting}



\begin{quote}
\textbf{Warning}

\texttt{CartesianIndex} y los arrays de \texttt{CartesianIndex} no son compatibles con la palabra

\end{quote}


   clave \texttt{end} que representa el último índice de una dimensión. No usaremos \texttt{end}     cuando se indexen expresiones que puedan contener \texttt{CartesianIndex} or arrays de ellos.



\hypertarget{15088539231972097937}{}


\subsubsection{Indexación Lógica}



A menudo denominada indexación lógica o indexación con una máscara lógica, la indexación mediante  una matriz booleana selecciona elementos en los índices cuyos valores son \texttt{verdaderos}. La indexación por un vector booleano \texttt{B} es efectivamente igual a la indexación por el vector de enteros que es devuelto por \texttt{find (B)}. De forma similar, la indexación por una matriz booleana \texttt{N}-dimensional es efectivamente igual a la indexación por el vector de \texttt{CartesianIndex\{N\}}s donde sus valores son \texttt{true}. Un índice lógico debe ser un vector de la misma longitud que la dimensión en la que indexa, o debe ser el único índice proporcionado y debe coincidir con el tamaño y la dimensionalidad de la matriz en la que se indexa. En general, es más eficiente usar matrices booleanas como índices directamente en lugar de llamar primero a \hyperlink{13973031941728195278}{\texttt{find()}}.




\begin{minted}{jlcon}
julia> x = reshape(1:16, 4, 4)
4×4 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> x[[false, true, true, false], :]
2×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15

julia> mask = map(ispow2, x)
4×4 Array{Bool,2}:
  true  false  false  false
  true  false  false  false
 false  false  false  false
  true   true  false   true

julia> x[mask]
5-element Array{Int64,1}:
  1
  2
  4
  8
 16
\end{minted}



\hypertarget{14266659218850988151}{}


\subsection{Iteración}



Las formas recomendadas de iterar sobre un array completo son:




\begin{minted}{julia}
for a in A
    # Do something with the element a
end

for i in eachindex(A)
    # Do something with i and/or A[i]
end
\end{minted}



La primera construcción se usa cuando necesitamos el valor, pero no los índices, de cada elemento. En la segunda construcción, \texttt{i} será un \texttt{Int} si \texttt{A} es un tipo array con indexación lineal rápida; en caso contrario será un \texttt{CartesianIndex}:




\begin{minted}{jlcon}
julia> A = rand(4,3);

julia> B = view(A, 1:3, 2:3);

julia> for i in eachindex(B)
           @show i
       end
i = CartesianIndex{2}((1, 1))
i = CartesianIndex{2}((2, 1))
i = CartesianIndex{2}((3, 1))
i = CartesianIndex{2}((1, 2))
i = CartesianIndex{2}((2, 2))
i = CartesianIndex{2}((3, 2))
\end{minted}



En contraste con \texttt{for i = 1:length(A)}, iterar con \texttt{eachindex} proporciona una forma eficiente de iterar sobre cualquier tipo de array.



\hypertarget{2985383153793243157}{}


\subsection{Rasgos de  Array}



Si uno escribe un tipo \hyperlink{6514416309183787338}{\texttt{AbstractArray}} personalizado, uno puede especificar que el tipo tiene indexación lineal rápida usando:




\begin{minted}{julia}
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()
\end{minted}



Esta configuración hará que la iteración \texttt{eachindex} sobre un objeto \texttt{MyArray} use enteros. Si no especifica este rasgo, se usa el valor predeterminado \texttt{IndexCartesian()}.



\hypertarget{3377433517916213965}{}


\subsection{Arrays, Funciones y Operadores Vectorizados}



Los siguientes operadores están soportados para arrays:



\begin{itemize}
\item[1. ] Aritmética unaria – \texttt{-}, \texttt{+}


\item[2. ] Aritmética binaria – \texttt{-}, \texttt{+}, \texttt{*}, \texttt{/}, \texttt{{\textbackslash}}, \texttt{{\textasciicircum}}


\item[3. ] Comparación – \texttt{==}, \texttt{!=}, \texttt{≈} (\hyperlink{12499503887608197213}{\texttt{isapprox}}), \texttt{≉}

\end{itemize}


La mayoría de los operadores aritméticos binarios enumerados anteriormente también funcionan elemento a elemento cuando un argumento es escalar: \texttt{-}, \texttt{+}, y \texttt{*}cuando cualquiera de los argumentos es escalar, y \texttt{/} y \texttt{{\textbackslash}} cuando el denominador es escalar. Por ejemplo, \texttt{[1, 2] + 3 == [4, 5]} y \texttt{[6, 4] / 2 == [3, 2]}.



Además, para permitir una conveniente vectorización de operaciones matemáticas y de otro tipo, Julia \hyperlink{13590013989415065742}{proporciona la sintaxis punto} \texttt{f.(args ...)}, por ejemplo, \texttt{sin.(x)} o \texttt{min.(x, y)}, para operaciones con elementos sobre arrays o mezclas de matrices y escalares (una \hyperlink{6411237952146762090}{Retransmisión (\emph{broadcasting})}); estos tienen la ventaja adicional de {\textquotedbl}fusión{\textquotedbl} en un solo bucle cuando se combina con otras llamadas de puntos, por ejemplo, \texttt{sin.(cos.(x))}



También, \emph{cada} operador binario admite una \hyperlink{6173297391052343261}{versión de punto} que se puede aplicar a matrices (y combinaciones de matrices y escalares) en tales \hyperlink{13590013989415065742}{operaciones de retransmisión fusionadas}, por ejemplo, \texttt{z .== sin.(x. * y)}.



Tenga en cuenta que las comparaciones como \texttt{==} operan en arrays completos, dando un solo booleano como respuesta. Use operadores de punto como \texttt{.==} para comparaciones elemento a elemento. (Para operaciones de comparación como \texttt{<}, \emph{solo} la versión de elementos \texttt{.<} es aplicable a las matrices).



También note la diferencia entre \texttt{max.(a, b)}, que retransmitir \hyperlink{7839419811914289844}{\texttt{max()}} elemento a elemento sobre \texttt{a} y\texttt{b}, y \texttt{maximum(a)}, que encuentra el mayor valor dentro de \texttt{a}. La misma relación se cumple para \texttt{min.(A, b)} y \texttt{minimum(a)}.



\hypertarget{6411237952146762090}{}


\subsection{Retransmisión}



A veces es útil realizar operaciones binarias elemento por elemento en matrices de diferentes tamaños, como agregar un vector a cada columna de una matriz. Una forma ineficiente de hacer esto sería replicar el vector al tamaño de la matriz:




\begin{minted}{jlcon}
julia> a = rand(2,1); A = rand(2,3);

julia> repmat(a,1,3)+A
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846
\end{minted}



Esto es un desperdicio cuando las dimensiones son grandes, por lo que Julia ofrece \texttt{broadcast()}, que expande las dimensiones \emph{singleton} en los argumentos array para hacer coincidir la dimensión correspondiente en el otro array sin usar memoria extra, y aplicar la función dada elemento a elemento:




\begin{minted}{jlcon}
julia> broadcast(+, a, A)
2×3 Array{Float64,2}:
 1.20813  1.82068  1.25387
 1.56851  1.86401  1.67846

julia> b = rand(1,2)
1×2 Array{Float64,2}:
 0.867535  0.00457906

julia> broadcast(+, a, b)
2×2 Array{Float64,2}:
 1.71056  0.847604
 1.73659  0.873631
\end{minted}



\hyperlink{6173297391052343261}{Los operadores con punto} tales como \texttt{.+} y \texttt{.*} son equivalentes a llamadas a \texttt{broadcast} (excepto que se funden, como se describe a continuación). También hay una función \texttt{broadcast!()} para especificar un destino explícito (al que también se puede acceder por fusión mediante asignación \texttt{.=}), y funciones \hyperlink{5896180186078332739}{\texttt{broadcast\_getindex()}} y \texttt{broadcast\_setindex! ()} que retransmiten los índices antes de indexar. Además, \texttt{f. (Args ...)} es equivalente a \texttt{broadcast(f, args ...)}, proporcionando una sintaxis conveniente para retransmitir cualquier función (\hyperlink{13590013989415065742}{sintaxis punto}). {\textquotedbl}Llamadas punto{\textquotedbl} anidadas \texttt{f.(...)} (incluidas las llamadas a \texttt{.+} Etcétera) \hyperlink{6173297391052343261}{fusibles automáticamente} en una sola llamada \texttt{broadcast}.



Además, \texttt{broadcast ()} no está limitado a los array (ver la documentación de la función), también maneja tuplas y trata cualquier argumento que no sea un array, tupla o \texttt{Ref} (excepto para\texttt{Ptr} ) como un {\textquotedbl}escalar{\textquotedbl}.




\begin{minted}{jlcon}
julia> convert.(Float32, [1, 2])
2-element Array{Float32,1}:
 1.0
 2.0

julia> ceil.((UInt8,), [1.2 3.4; 5.6 6.7])
2×2 Array{UInt8,2}:
 0x02  0x04
 0x06  0x07

julia> string.(1:3, ". ", ["First", "Second", "Third"])
3-element Array{String,1}:
 "1. First"
 "2. Second"
 "3. Third"
\end{minted}



\hypertarget{612241206445696325}{}


\subsection{Implementation}



El tipo de matriz base en Julia es el tipo abstracto \texttt{AbstractArray \{T, N\}}. Este tipo está parametrizado por el número de dimensiones \texttt{N} y el tipo de elementos \texttt{T}. \texttt{AbstractVector} y \texttt{AbstractMatrix} son aliases para los casos 1-d y 2-d. Las operaciones en los objetos \texttt{AbstractArray} se definen usando operadores y funciones de alto nivel, de  manera que es independiente del almacenamiento subyacente. Estas operaciones generalmente funcionan correctamente como una alternativa para cualquier implementación de matriz específica.



El tipo \texttt{AbstractArray} incluye algo vagamente parecido a un array, y las implementaciones de este podrían ser bastante diferentes de los arrays convencionales. Por ejemplo, los elementos se pueden calcular a petición en lugar de ser almacenados. Sin embargo, cualquier tipo concreto de \texttt{AbstractArray\{T, N\}} debería implementar al menos \hyperlink{17888996102305087038}{\texttt{size(A)}} (que devolvería una tupla \texttt{Int}), \hyperlink{2839226020402435013}{\texttt{getindex(A,i)}} y \hyperlink{2839226020402435013}{\texttt{getindex(A, i1, ..., iN)}}; Los arrays mutables también deberían implementar \hyperlink{17903591429492118749}{\texttt{setindex!()}}. Se recomienda que estas operaciones tengan complejidad temporal casi constante, o técnicamente complejidad de orden 1 (Õ(1)), ya que de lo contrario algunas funciones podrían ser inesperadamente lentas. Los tipos concretos también deberían proporcionar un método \hyperlink{18368531196314541873}{\texttt{similar(A,T=eltype(A),dims=size(A))}}, que se utiliza para asignar un conjunto similar para \hyperlink{15665284441316555522}{\texttt{copy()}} y otras operaciones de actualización. No importa cómo se represente internamente un \texttt{AbstractArray \{T, N\}}, \texttt{T} es el tipo de objeto devuelto por la indización entera (\texttt{A [1, ..., 1]}, cuando \texttt{A} no está vacío) y\texttt{N} debe ser la longitud de la tupla devuelta por \hyperlink{17888996102305087038}{\texttt{size()}}.



\texttt{DenseArray} es un subtipo abstracto de\texttt{AbstractArray} que pretende incluir todos los arrays que están establecidos en bloques regulares de memoria y que, por tanto, se puede pasar a funciones externas C y Fortran que esperan este diseño de memoria. Los subtipos deberían proporcionar un método \hyperlink{97811245619734938}{\texttt{stride(A,k)}} que devuelve el {\textquotedbl}paso{\textquotedbl} de la dimensión \texttt{k}; incrementar el índice de dimensión \texttt{k} en \texttt{1} debería incremental el índice \texttt{i} de \hyperlink{2839226020402435013}{\texttt{getindex(A,i)}} en \hyperlink{97811245619734938}{\texttt{stride(A,k)}}. Si se proporciona un método de conversión de puntero \hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert(Ptr\{T\}, A)}}, el diseño de la memoria debe corresponder de la misma manera a estos pasos.



El tipo \hyperlink{15492651498431872487}{\texttt{Array}} es una instancia específica de \texttt{DenseArray} donde los elementos se almacenan en orden de columnas principales (consulte notas adicionales en \hyperlink{3908315974291496321}{Sugerencias de rendimiento}). \texttt{Vector} y \texttt{Matrix} son alias para los casos 1-d y 2-d. Las operaciones específicas como la indexación escalar, la asignación y algunas otras operaciones básicas específicas del almacenamiento son todas las que tienen que estar implementadas en  \hyperlink{15492651498431872487}{\texttt{Array}}, de modo que el resto de la biblioteca de arrays puede implementarse de forma genérica.



\texttt{SubArray} es una especialización de \texttt{AbstractArray} que realiza indexación por referencia en lugar de por copia. Un \texttt{SubArray} se crea con la función \hyperlink{4861450464669906845}{\texttt{view()}}, que es llamada de la misma manera que \hyperlink{2839226020402435013}{\texttt{getindex()}} (con una matriz y una serie de argumentos de índice) . El resultado de \hyperlink{4861450464669906845}{\texttt{view()}} se ve igual que el resultado de \hyperlink{2839226020402435013}{\texttt{getindex()}}, excepto que los datos se dejan en su lugar. \hyperlink{4861450464669906845}{\texttt{view()}} almacena los vectores de índice de entrada en un objeto \texttt{SubArray}, que luego puede usarse para indexar la matriz original de forma indirecta. Al colocar la macro \hyperlink{4544474300423667148}{\texttt{@views}} delante de una expresión o bloque de código, cualquier segmento \texttt{array[...]} en esa expresión se convertirá para crear una vista \texttt{SubArray} en su lugar.



\texttt{StridedVector} y\texttt{StridedMatrix} son alias convenientes definidos para que Julia pueda llamar a un rango más amplio de funciones BLAS y LAPACK pasándoles objetos \hyperlink{15492651498431872487}{\texttt{Array}} o \texttt{SubArray}, y ahorrando así ineficiencias de asignación de memoria y copia.



El siguiente ejemplo calcula la descomposición QR de una pequeña sección de una matriz más grande, sin crear ningún array temporal, y llamando a la función LAPACK apropiada con los parámetros de tamaño de dimensión y salto correctos.




\begin{minted}{jlcon}
julia> a = rand(10,10)
10×10 Array{Float64,2}:
 0.561255   0.226678   0.203391  0.308912   …  0.750307  0.235023   0.217964
 0.718915   0.537192   0.556946  0.996234      0.666232  0.509423   0.660788
 0.493501   0.0565622  0.118392  0.493498      0.262048  0.940693   0.252965
 0.0470779  0.736979   0.264822  0.228787      0.161441  0.897023   0.567641
 0.343935   0.32327    0.795673  0.452242      0.468819  0.628507   0.511528
 0.935597   0.991511   0.571297  0.74485    …  0.84589   0.178834   0.284413
 0.160706   0.672252   0.133158  0.65554       0.371826  0.770628   0.0531208
 0.306617   0.836126   0.301198  0.0224702     0.39344   0.0370205  0.536062
 0.890947   0.168877   0.32002   0.486136      0.096078  0.172048   0.77672
 0.507762   0.573567   0.220124  0.165816      0.211049  0.433277   0.539476

julia> b = view(a, 2:2:8,2:2:4)
4×2 SubArray{Float64,2,Array{Float64,2},Tuple{StepRange{Int64,Int64},StepRange{Int64,Int64}},false}:
 0.537192  0.996234
 0.736979  0.228787
 0.991511  0.74485
 0.836126  0.0224702

julia> (q,r) = qr(b);

julia> q
4×2 Array{Float64,2}:
 -0.338809   0.78934
 -0.464815  -0.230274
 -0.625349   0.194538
 -0.527347  -0.534856

julia> r
2×2 Array{Float64,2}:
 -1.58553  -0.921517
  0.0       0.866567
\end{minted}



\hypertarget{15616629732727427304}{}


\section{Vectores y Matrices \emph{Sparse}}



Julia tiene soporte integrado para vectores y \href{https://en.wikipedia.org/wiki/Sparse\_matrix}{matrices dispersas (\emph{sparse})}. Las matrices \emph{sparse} son matrices que contienen suficientes ceros para almacenarlos en una estructura de datos especial que ahorra espacio y tiempo de ejecución, en comparación con las matrices densas.



\hypertarget{4438718230137239554}{}


\subsection{Columna Comprimida \emph{Sparse} (CSC) Para Almacenamiento de Matrices \emph{Sparse}}



En Julia, las matrices dispersas se almacenan en el formato \href{https://en.wikipedia.org/wiki/Sparse\_matrix\#Compressed\_sparse\_column\_.28CSC\_or\_CCS.29}{Compressed Sparse Column (CSC)}. Las matrices \emph{sparse} de Julia tienen el tipo \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC\{Tv,Ti\}}}, donde \texttt{Tv} es el tipo de los valores almacenados, y\texttt{Ti} es el tipo entero para almacenar punteros de columnas e índices de filas. La representación interna de \texttt{SparseMatrixCSC} es la siguiente:




\begin{minted}{julia}
struct SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}
    m::Int                  # Number of rows
    n::Int                  # Number of columns
    colptr::Vector{Ti}      # Column i is in colptr[i]:(colptr[i+1]-1)
    rowval::Vector{Ti}      # Row indices of stored values
    nzval::Vector{Tv}       # Stored values, typically nonzeros
end
\end{minted}



El almacenamiento de columnas dispersas y comprimidas (CSC) facilita y agiliza el acceso a los elementos en la columna de una matriz \emph{sparse}, mientras que el acceso a la matriz \emph{sparse} por filas es considerablemente más lento. Las operaciones como la inserción de entradas previamente no almacenadas de una en una en la estructura de CSC tienden a ser lentas. Esto se debe a que todos los elementos de la matriz \emph{sparse} que están más allá del punto de inserción deben moverse un lugar más.



Todas las operaciones en matrices \emph{sparse} se implementan cuidadosamente para aprovechar la estructura de datos CSC para el rendimiento y para evitar operaciones costosas.



Si tiene datos en formato CSC desde una aplicación o biblioteca diferente, y desea importarlos a Julia, asegúrese de utilizar la indexación basada en 1. Los índices de fila en cada columna deben estar ordenados. Si su objeto \texttt{SparseMatrixCSC} contiene índices de filas sin ordenar, una forma rápida de ordenarlos es hacer una doble transposición.



En algunas aplicaciones, es conveniente almacenar valores cero explícitos en una \texttt{SparseMatrixCSC}. Estas \emph{son} aceptadas por funciones en \texttt{Base} (pero no hay garantía de que se conservarán en las operaciones de mutación). Tales ceros explícitamente almacenados son tratados como no estructurales por muchas rutinas. La función \hyperlink{6318543341724753931}{\texttt{nnz()}} devuelve la cantidad de elementos almacenados explícitamente en la estructura de datos dispersos, incluidos los no-ceros estructurales. Para contar el número exacto de nozeros numéricos, use \hyperlink{14756260737478660234}{\texttt{countnz()}}, que inspecciona todos los elementos almacenados en un a matriz \emph{sparse}. \hyperlink{16980472205632865276}{\texttt{dropzeros()}}, y \hyperlink{4343590179532251994}{\texttt{dropzeros!()}}, se puede usar para eliminar ceros almacenados de la matriz dispersa.




\begin{minted}{jlcon}
julia> A = sparse([1, 2, 3], [1, 2, 3], [0, 2, 0])
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  0
  [2, 2]  =  2
  [3, 3]  =  0

julia> dropzeros(A)
3×3 SparseMatrixCSC{Int64,Int64} with 1 stored entry:
  [2, 2]  =  2
\end{minted}



\hypertarget{11978256442297483077}{}


\subsection{Almacenamiento de Vectores \emph{Sparse}}



Los vectores \emph{sparse} se almacenan en un formato de columna análogo al que se usa en las matrices \emph{sparse}. En Julia, los vectores \emph{sparse} tienen el tipo \hyperlink{17278185509996384677}{\texttt{SparseVector\{Tv,Ti\}}} donde \texttt{Tv} es el tipo de los valores almacenados y\texttt{Ti} el tipo entero para los índices. La representación interna es la siguiente:




\begin{minted}{julia}
struct SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}
    n::Int              # Length of the sparse vector
    nzind::Vector{Ti}   # Indices of stored values
    nzval::Vector{Tv}   # Stored values, typically nonzeros
end
\end{minted}



En cuanto a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}}, el tipo \texttt{SparseVector} también puede contener ceros almacenados explícitamente. (Consulte \hyperlink{4438718230137239554}{Almacenamiento de matriz \emph{sparse}}.).



\hypertarget{14573726910211075461}{}


\subsection{Constructores de Vectores y Matrices \emph{Sparse}}



La forma más sencilla de crear matrices \emph{sparse} es usar funciones equivalentes a las funciones \hyperlink{13837674686090348619}{\texttt{zeros()}} y \hyperlink{245874853049830800}{\texttt{eye()}} que proporciona Julia para trabajar con matrices densas. Para producir matrices \emph{sparse} en su lugar, puede usar los mismos nombres con el prefijo \texttt{sp}:




\begin{minted}{jlcon}
julia> spzeros(3)
3-element SparseVector{Float64,Int64} with 0 stored entries

julia> speye(3,5)
3×5 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
\end{minted}



La función \hyperlink{6442735913986985800}{\texttt{sparse()}} suele ser una forma útil de construir arrays \emph{sparse}. Por ejemplo, para construir una matriz \emph{sparse}, podemos ingresar un vector \texttt{I} de índices de fila, un vector\texttt{J} de índices de columna, y un vector \texttt{V} de valores almacenados (esto también se conoce como \href{https://en.wikipedia.org/wiki/Sparse\_matrix\#Coordinate\_list\_.28COO.29}{formato COO (coordenada)}). \texttt{sparse (I,J,V)} construye una matriz \emph{sparse} tal que \texttt{S[I[k], J[k]] = V[k]}. El constructor de vector \emph{sparse} equivalente es \hyperlink{18161940743946340171}{\texttt{sparsevec}}, que toma el vector de índices (fila) \texttt{I} y el vector \texttt{V} con los valores almacenados y construye un vector \emph{sparse} \texttt{R} tal que \texttt{R[I[k]] = V[k]}.




\begin{lstlisting}
julia> I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia> S = sparse(I,J,V)
5×18 SparseMatrixCSC{Int64,Int64} with 4 stored entries:
  [1 ,  4]  =  1
  [4 ,  7]  =  2
  [5 ,  9]  =  3
  [3 , 18]  =  -5

julia> R = sparsevec(I,V)
5-element SparseVector{Int64,Int64} with 4 stored entries:
  [1]  =  1
  [3]  =  -5
  [4]  =  2
  [5]  =  3
\end{lstlisting}



La inversa de las funciones \hyperlink{6442735913986985800}{\texttt{sparse()}} y \hyperlink{18161940743946340171}{\texttt{sparsevec}} es \hyperlink{10811968090686169507}{\texttt{findnz()}}, que recupera las entradas utilizadas para crear el array \emph{sparse}. También hay una función \hyperlink{7762671957301951450}{\texttt{findn}} que solo devuelve los vectores índice.




\begin{lstlisting}
julia> findnz(S)
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia> findn(S)
([1, 4, 5, 3], [4, 7, 9, 18])

julia> findnz(R)
([1, 3, 4, 5], [1, -5, 2, 3])

julia> findn(R)
4-element Array{Int64,1}:
 1
 3
 4
 5
\end{lstlisting}



Otra forma de crear un array \emph{sparse} es convertir un array denso en un array \emph{sparse} usando la función \hyperlink{6442735913986985800}{\texttt{sparse()}}:




\begin{minted}{jlcon}
julia> sparse(eye(5))
5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  1.0
  [5, 5]  =  1.0

julia> sparse([1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0
\end{minted}



Puede ir en la otra dirección usando el constructor \hyperlink{15492651498431872487}{\texttt{Array}}. La función \hyperlink{4718940244439103334}{\texttt{issparse()}} se puede usar para consultar si una matriz es o no \emph{sparse}.




\begin{minted}{jlcon}
julia> issparse(speye(5))
true
\end{minted}



\hypertarget{17281408938920196874}{}


\subsection{Operaciones con matrices \emph{sparse}}



Las operaciones aritméticas en matrices \emph{sparse} también funcionan como lo hacen en matrices densas. La indexación de, la asignación en y la concatenación de matrices \emph{sparse} funcionan de la misma manera que las matrices densas. Las operaciones de indexación, especialmente la asignación, son costosas, cuando se llevan a cabo un elemento cada vez. En muchos casos, puede ser mejor convertir la matriz dispersa en formato \texttt{(I,J,V)} usando \hyperlink{10811968090686169507}{\texttt{findnz()}}, manipular los valores o la estructura en los vectores densos \texttt{(I,J,V)}, y luego reconstruir la matriz \emph{sparse}.



\hypertarget{3328350436064607795}{}


\subsection{Correspondence of dense and sparse methods}



La siguiente tabla proporciona una correspondencia entre los métodos incorporados en matrices \emph{sparse} y sus métodos correspondientes en tipos de matrices densas. En general, los métodos que generan matrices \emph{sparse} difieren de sus contrapartes densas en que la matriz resultante sigue el mismo patrón de dispersión que una matriz \emph{sparse} dada \texttt{S}, o que la matriz \emph{sparse} resultante tiene densidad \texttt{d}, es decir, cada elemento de matriz tiene una probabilidad \texttt{d} de ser diferente de cero.



Los detalles se pueden encontrar en la sección \hyperlink{2402954669804328212}{Vectores y Matrices \emph{Sparse}} de la referencia de biblioteca estándar.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Sparse & Dense & Description \\
\hline
\hyperlink{7195216781795987163}{\texttt{spzeros(m,n)}} & \hyperlink{13837674686090348619}{\texttt{zeros(m,n)}} & Creates a \emph{m}-by-\emph{n} matrix of zeros. (\hyperlink{7195216781795987163}{\texttt{spzeros(m,n)}} is empty.) \\
\hline
\hyperlink{8792030753977135320}{\texttt{spones(S)}} & \hyperlink{5858390260510292771}{\texttt{ones(m,n)}} & Creates a matrix filled with ones. Unlike the dense version, \hyperlink{8792030753977135320}{\texttt{spones()}} has the same sparsity pattern as \emph{S}. \\
\hline
\hyperlink{15336931858862742282}{\texttt{speye(n)}} & \hyperlink{245874853049830800}{\texttt{eye(n)}} & Creates a \emph{n}-by-\emph{n} identity matrix. \\
\hline
\hyperlink{6442668105237896007}{\texttt{full(S)}} & \hyperlink{6442735913986985800}{\texttt{sparse(A)}} & Interconverts between dense and sparse formats. \\
\hline
\hyperlink{7938626005548874744}{\texttt{sprand(m,n,d)}} & \hyperlink{791894090820620170}{\texttt{rand(m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed uniformly on the half-open interval \([0, 1)\). \\
\hline
\hyperlink{641245889672681934}{\texttt{sprandn(m,n,d)}} & \hyperlink{8153706463199753760}{\texttt{randn(m,n)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution. \\
\hline
\hyperlink{641245889672681934}{\texttt{sprandn(m,n,d,X)}} & \hyperlink{8153706463199753760}{\texttt{randn(m,n,X)}} & Creates a \emph{m}-by-\emph{n} random matrix (of density \emph{d}) with iid non-zero elements distributed according to the \emph{X} distribution. (Requires the \texttt{Distributions} package.) \\
\hline
\end{tabulary}

\end{table}



\hypertarget{11547352483373884762}{}


\chapter{Álgebra Lineal}



Además de (y como parte de) su soporte a los arrays multidimensionales, Julia proporciona implementaciones nativas de muchas operaciones de álgebra lineal comunes y útiles. Las operaciones básicas tales como la traza (\hyperlink{4723994450949629907}{\texttt{trace}}), el determinante (\hyperlink{1300265042345987014}{\texttt{det}}) y la inversa (\hyperlink{9013378623280719296}{\texttt{inv}}) están todas soportadas:




\begin{minted}{jlcon}
julia> A = [1 2 3; 4 1 6; 7 8 1]
3×3 Array{Int64,2}:
 1  2  3
 4  1  6
 7  8  1

julia> trace(A)
3

julia> det(A)
104.0

julia> inv(A)
3×3 Array{Float64,2}:
 -0.451923   0.211538    0.0865385
  0.365385  -0.192308    0.0576923
  0.240385   0.0576923  -0.0673077
\end{minted}



Así como otras operaciones útiles, como buscar autovalores o autovectores:




\begin{minted}{jlcon}
julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia> eigvals(A)
3-element Array{Complex{Float64},1}:
  9.31908+0.0im
 -2.40954+2.72095im
 -2.40954-2.72095im

julia> eigvecs(A)
3×3 Array{Complex{Float64},2}:
 -0.488645+0.0im  0.182546-0.39813im   0.182546+0.39813im
 -0.540358+0.0im  0.692926+0.0im       0.692926-0.0im
   0.68501+0.0im  0.254058-0.513301im  0.254058+0.513301im
\end{minted}



Además, Julia proporciona muchas \hyperlink{12615392115882150758}{factorizaciones} que pueden usarse para acelerar problemas como la resolución lineal o la exponenciación de matrices mediante la pre-factorización de una matriz en una forma más adecuada (por razones de rendimiento o memoria) ) al problema. Consulte la documentación en \hyperlink{10363263068585650380}{\texttt{factorize}} para obtener más información. Como ejemplo:




\begin{minted}{jlcon}
julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Array{Float64,2}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia> factorize(A)
Base.LinAlg.LU{Float64,Array{Float64,2}} with factors L and U:
[1.0 0.0 0.0; -0.15 1.0 0.0; -0.3 -0.132196 1.0]
[-10.0 2.3 4.0; 0.0 2.345 -3.4; 0.0 0.0 -5.24947]
\end{minted}



Como \texttt{A} no es hermítica, simétrica, triangular o bidiagonal, una factorización LU puede ser lo mejor que podemos hacer. Compara con:




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> factorize(B)
Base.LinAlg.BunchKaufman{Float64,Array{Float64,2}}([-1.64286 0.142857 -0.8; 2.0 -2.8 -0.6; -4.0 -3.0 5.0], [1, 2, 3], 'U', true, false, 0)
\end{minted}



Aquí, Julia fue capaz de detectar que \texttt{B} es de hecho simetrica, y usa una factorizacíon más apropiada. Frecuentemente es posible escribir código ms eficiente para una matriz de la que se conocen ciertas propiedades como que sea simétrica o diagonal. Julia proporciona algunos tipos especiales para que uno pueda {\textquotedbl}etiquetar{\textquotedbl} las matrices que tengan estas propiedades. Por ejemplo:




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0
\end{minted}



\texttt{sB} ha sido etiquetada como una matriz que es simétrica (real) por lo que para algunas operacioneas que podríamos hacer sobre ella, tal como la autofactorización o calbular productos matriz-vector, pueden encontrarse eficiencias sólo referenciando la mitad de ella. Por ejemplo:




\begin{minted}{jlcon}
julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Array{Float64,2}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> sB = Symmetric(B)
3×3 Symmetric{Float64,Array{Float64,2}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia> x = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> sB\x
3-element Array{Float64,1}:
 -1.73913
 -1.1087
 -1.45652
\end{minted}



La operación \texttt{{\textbackslash}} realiza aquí la resolución de la ecuación lineal. El analizador sintáctico de Julia proporciona un despacho conveniente para métodos especializados para la \emph{transpuesta} de una matriz o una matriz dividida por la izquierda por un vector, o para las distintas combinaciones u operacioneas de transposición en soluciones matriz-matriz. Muchas de ellas son incluso más especializadas para ciertos tipos especiales de matrices. Por ejemplo, \texttt{A{\textbackslash}B} acabará llamando a \hyperlink{16784809286794154433}{\texttt{Base.LinAlg.A\_ldiv\_B!}} mientras que \texttt{A{\textquotesingle}{\textbackslash}B} acabará llamando a \hyperlink{9966202373988898888}{\texttt{Base.LinAlg.Ac\_ldiv\_B}}, incluso aunque usáramos el mismo operador de división por la izquierda. Esto funcionea también para matrices: \texttt{A.{\textquotesingle}{\textbackslash}B.{\textquotesingle}} invocará a \hyperlink{13563153742436501281}{\texttt{Base.LinAlg.At\_ldiv\_Bt}}. El operador de división por la izquierda es muy potente y es fácil escribir código compacto y bastante legible para resolver todo tipo de sistemas de ecuaciones lineales.



\hypertarget{8410174550859365496}{}


\section{Matrices Especiales}



\href{http://www2.imm.dtu.dk/pubdb/views/publication\_details.php?id=3274}{Las matrices con simetrías y estructuras especiales} surgen a menudo en el álgebra lineal y frecuentemente se asocian con varias factorizaciones matriciales. Julia presenta una rica colección de tipos de matrices especiales, que permiten un cálculo rápido con rutinas especializadas que están especialmente desarrolladas para estos tipos particuales de matrices.



Las siguientes tablas resumen los tipos de matrices especiales que se han implementado en Julia, así como si están disponibles ganchos para varios métodos optimizados para ellos en LAPACK.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Type & Description \\
\hline
\hyperlink{11943711269274284831}{\texttt{Hermitian}}       & \href{https://en.wikipedia.org/wiki/Hermitian\_matrix}{Matriz hermítica}               \\
\hline
\hyperlink{1757421215459158076}{\texttt{UpperTriangular}} & \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{Matriz triangular} superior \\
\hline
\hyperlink{17017578003271911360}{\texttt{LowerTriangular}} & \href{https://en.wikipedia.org/wiki/Triangular\_matrix}{Matriz triangular} inferior \\
\hline
\hyperlink{10627817666628508033}{\texttt{Tridiagonal}} & \href{https://en.wikipedia.org/wiki/Tridiagonal\_matrix}{Matriz tridiagonal} \\
\hline
\hyperlink{14121197223449931750}{\texttt{SymTridiagonal}} & Matriz tridiagonal simétrica                                                     \\
\hline
\hyperlink{3712437588055447942}{\texttt{Bidiagonal}} & \href{https://en.wikipedia.org/wiki/Bidiagonal\_matrix}{Matriz bidiagonal} superior/inferior \\
\hline
\hyperlink{14932727513503167130}{\texttt{Diagonal}} & \href{https://en.wikipedia.org/wiki/Diagonal\_matrix}{Matriz diagonal} \\
\hline
\texttt{UniformScaling} & \href{https://en.wikipedia.org/wiki/Uniform\_scaling}{Operador escalado uniforme} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{1835715041462291876}{}


\subsection{Operaciones elementales}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
Tipo de matriz           & \texttt{+} & \texttt{-} & \texttt{*} & \texttt{{\textbackslash}} & Otras funciones con métodos optimizados                             \\
\hline
\hyperlink{11943711269274284831}{\texttt{Hermitian}} &   &   &   & MV & \hyperlink{9013378623280719296}{\texttt{inv()}}, \hyperlink{16982789562347489346}{\texttt{sqrtm()}}, \hyperlink{13066189226307440587}{\texttt{expm()}} \\
\hline
\hyperlink{1757421215459158076}{\texttt{UpperTriangular}} &   &   & MV & MV & \hyperlink{9013378623280719296}{\texttt{inv()}}, \hyperlink{1300265042345987014}{\texttt{det()}} \\
\hline
\hyperlink{17017578003271911360}{\texttt{LowerTriangular}} &   &   & MV & MV & \hyperlink{9013378623280719296}{\texttt{inv()}}, \hyperlink{1300265042345987014}{\texttt{det()}} \\
\hline
\hyperlink{14121197223449931750}{\texttt{SymTridiagonal}} & M & M & MS & MV & \hyperlink{2002481541828933425}{\texttt{eigmax()}}, \hyperlink{3000514364430926525}{\texttt{eigmin()}} \\
\hline
\hyperlink{10627817666628508033}{\texttt{Tridiagonal}} & M & M & MS & MV &   \\
\hline
\hyperlink{3712437588055447942}{\texttt{Bidiagonal}} & M & M & MS & MV &   \\
\hline
\hyperlink{14932727513503167130}{\texttt{Diagonal}} & M & M & MV & MV & \hyperlink{9013378623280719296}{\texttt{inv()}}, \hyperlink{1300265042345987014}{\texttt{det()}}, \hyperlink{6649271058375699908}{\texttt{logdet()}}, \hyperlink{4103478871488785445}{\texttt{/()}} \\
\hline
\texttt{UniformScaling} & M & M & MVS & MVS & \hyperlink{4103478871488785445}{\texttt{/()}} \\
\hline
\end{tabulary}

\end{table}



Legend:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Clave     & Descripción                                                   \\
\hline
M (matrix) & An optimized method for matrix-matrix operations is available \\
\hline
V (vector) & An optimized method for matrix-vector operations is available \\
\hline
S (scalar) & An optimized method for matrix-scalar operations is available \\
\hline
\end{tabulary}

\end{table}



\hypertarget{1715764056844303476}{}


\subsection{Factorizaciones de matrices}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|}
\hline
Matrix type & LAPACK & \hyperlink{14864609220164435086}{\texttt{eig()}} & \hyperlink{3176364577236723896}{\texttt{eigvals()}} & \hyperlink{13341009863130381110}{\texttt{eigvecs()}} & \hyperlink{14775973623414930183}{\texttt{svd()}} & \hyperlink{15097149969632009300}{\texttt{svdvals()}} \\
\hline
\hyperlink{11943711269274284831}{\texttt{Hermitian}} & HE &   & ARI &   &   &   \\
\hline
\hyperlink{1757421215459158076}{\texttt{UpperTriangular}} & TR & A & A & A &   &   \\
\hline
\hyperlink{17017578003271911360}{\texttt{LowerTriangular}} & TR & A & A & A &   &   \\
\hline
\hyperlink{14121197223449931750}{\texttt{SymTridiagonal}} & ST & A & ARI & AV &   &   \\
\hline
\hyperlink{10627817666628508033}{\texttt{Tridiagonal}} & GT &   &   &   &   &   \\
\hline
\hyperlink{3712437588055447942}{\texttt{Bidiagonal}} & BD &   &   &   & A & A \\
\hline
\hyperlink{14932727513503167130}{\texttt{Diagonal}} & DI &   & A &   &   &   \\
\hline
\end{tabulary}

\end{table}



Legend:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Key & Description & Example \\
\hline
A (all) & An optimized method to find all the characteristic values and/or vectors is available & e.g. \texttt{eigvals(M)} \\
\hline
R (range) & An optimized method to find the \texttt{il}th through the \texttt{ih}th characteristic values are available & \texttt{eigvals(M, il, ih)} \\
\hline
I (interval) & An optimized method to find the characteristic values in the interval [\texttt{vl}, \texttt{vh}] is available & \texttt{eigvals(M, vl, vh)} \\
\hline
V (vectors) & An optimized method to find the characteristic vectors corresponding to the characteristic values \texttt{x=[x1, x2,...]} is available & \texttt{eigvecs(M, x)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{9047300032434660219}{}


\subsection{El operador de escalado uniforme}



Un operador \texttt{UniformScaling} representa un escalar multiplicado por el operador de identidad, \texttt{λ*I}. El operador de identidad \texttt{I} se define como una constante y es una instancia de \texttt{UniformScaling}. El tamaño de estos operadores es genérico y coincide con la otra matriz en las operaciones binarias \hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{8486205126068439173}{\texttt{*}} y \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}. Para \texttt{A+I} y\texttt{A-I} esto significa que \texttt{A} debe ser cuadrado. La multiplicación con el operador de identidad \texttt{I} es un \emph{noop} (excepto para comprobar que el factor de escala es uno) y, por lo tanto, casi sin sobrecarga.



\hypertarget{12615392115882150758}{}


\section{Factorizaciones de matrices}



\href{https://en.wikipedia.org/wiki/Matrix\_decomposition}{las factorizaciones de matrices (a.k.a. descomposiciones de matrices)} calculan la factorizacin de una matriz en un producto de matrices, y son uno de los conceptos centrales del álgebra lineal.



La siguiente tabla resume los tipos de factorizaciones de matrices que han sido implementados en Julia. En la sección \hyperlink{2892037563719910727}{Linear Algebra} de la documentación de la librería estándar pueden encontrarse más detalles de los métodos asociados.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Type & Description \\
\hline
\texttt{Cholesky} & \href{https://en.wikipedia.org/wiki/Cholesky\_decomposition}{Cholesky factorization} \\
\hline
\texttt{CholeskyPivoted} & \href{https://en.wikipedia.org/wiki/Pivot\_element}{Pivoted} Cholesky factorization \\
\hline
\texttt{LU} & \href{https://en.wikipedia.org/wiki/LU\_decomposition}{LU factorization} \\
\hline
\texttt{LUTridiagonal} & LU factorization for \hyperlink{10627817666628508033}{\texttt{Tridiagonal}} matrices \\
\hline
\texttt{UmfpackLU} & LU factorization for sparse matrices (computed by UMFPack) \\
\hline
\texttt{QR} & \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} \\
\hline
\texttt{QRCompactWY} & Compact WY form of the QR factorization \\
\hline
\texttt{QRPivoted} & Pivoted \href{https://en.wikipedia.org/wiki/QR\_decomposition}{QR factorization} \\
\hline
\texttt{Hessenberg} & \href{http://mathworld.wolfram.com/HessenbergDecomposition.html}{Hessenberg decomposition} \\
\hline
\texttt{Eigen} & \href{https://en.wikipedia.org/wiki/Eigendecomposition\_(matrix)}{Spectral decomposition} \\
\hline
\texttt{SVD} & \href{https://en.wikipedia.org/wiki/Singular\_value\_decomposition}{Singular value decomposition} \\
\hline
\texttt{GeneralizedSVD} & \href{https://en.wikipedia.org/wiki/Generalized\_singular\_value\_decomposition\#Higher\_order\_version}{Generalized SVD} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12120385195625176605}{}


\chapter{Redes y Flujos}



Julia proporciona una interfaz rica para tratar objetos que representen un flujo contínuo de E/S como terminales, tuberías y sockets TCP. Esta interfaz, aunque asíncrona a nivel del sistema, se presenta de forma síncrona al programador y normalmente no es necesario pensar en la operación asincrónica subyacente. Esto se logra haciendo un uso intensivo de la funcionalidad de los hilos cooperativos en Julia (o \hyperlink{15038256797533490288}{corrutinas}).



\hypertarget{11716149801780664581}{}


\section{Flujos de E/S básico}



Todos los flujos en Julia exponen al menos un método \hyperlink{8104134490906192097}{\texttt{read()}} y un \hyperlink{16947913578760238729}{\texttt{write()}}, tomando el flujo como su primer argumento, por ejemplo:




\begin{minted}{jlcon}
julia> write(STDOUT,"Hello World");  # suppress return value 11 with ;
Hello World
julia> read(STDIN,Char)

'\n': ASCII/Unicode U+000a (category Cc: Other, control)
\end{minted}



Tenga en cuenta que \hyperlink{16947913578760238729}{\texttt{write()}} devuelve 11, el número de bytes (en \texttt{{\textquotedbl}Hello World{\textquotedbl}}) escrito en \hyperlink{2784333101804678420}{\texttt{STDOUT}}, pero este valor de retorno se suprime con \texttt{;}.



Aquí Enter fue presionado nuevamente para que Julia leyera la nueva línea. Ahora, como puede ver en este ejemplo, \hyperlink{16947913578760238729}{\texttt{write()}} toma los datos para escribir como su segundo argumento, mientras que \hyperlink{8104134490906192097}{\texttt{read()}} toma el tipo de datos para ser leído como el segundo argumento.



Por ejemplo, para leer una matriz de bytes simple, podríamos hacer:




\begin{minted}{jlcon}
julia> x = zeros(UInt8, 4)
4-element Array{UInt8,1}:
 0x00
 0x00
 0x00
 0x00

julia> read!(STDIN, x)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64
\end{minted}



Sin embargo, dado que esto es un poco engorroso, se proporcionan varios métodos de conveniencia. Por ejemplo, podríamos haber escrito lo anterior como:




\begin{minted}{jlcon}
julia> read(STDIN,4)
abcd
4-element Array{UInt8,1}:
 0x61
 0x62
 0x63
 0x64
\end{minted}



o si hubiéramos querido leer toda la línea en su lugar:




\begin{minted}{jlcon}
julia> readline(STDIN)
abcd
"abcd"
\end{minted}



Tenga en cuenta que, dependiendo de la configuración de su terminal, su TTY puede estar almacenado en línea y, por lo tanto, podría requerir una entrada adicional antes de enviar los datos a Julia.



Para leer cada línea desde \hyperlink{13806523663202420575}{\texttt{STDIN}}, puede usar \hyperlink{3474649815265066504}{\texttt{eachline()}}:




\begin{minted}{julia}
for line in eachline(STDIN)
    print("Found $line")
end
\end{minted}



o \hyperlink{8104134490906192097}{\texttt{read()}} si deseamos leer carácter a carácter en lugar de lo anterior:




\begin{minted}{julia}
while !eof(STDIN)
    x = read(STDIN, Char)
    println("Found: $x")
end
\end{minted}



\hypertarget{3938862926454188721}{}


\section{E/S Texto}



Note que el método \hyperlink{16947913578760238729}{\texttt{write()}} mencionado arriba opera sobre flujos binarios. En particular, los valores no son convertidos a ninguna representación de texto canónica sino que son escritas tal cual:




\begin{minted}{jlcon}
julia> write(STDOUT,0x61);  # suppress return value 1 with ;
a
\end{minted}



Note que \texttt{a} es escrito a \hyperlink{2784333101804678420}{\texttt{STDOUT}} por la función \hyperlink{16947913578760238729}{\texttt{write()}} y que el valor devuelto es \texttt{1} (ya que \texttt{0x61} es un byte).



Para E/S texto, use los métodos \hyperlink{8248717042415202230}{\texttt{print()}} o \hyperlink{14071376285304310153}{\texttt{show()}} methods, dependiendo de sus necesidades (ver la referencia de la librería estándar para una discusin detallada de la diferencia entre las dos):




\begin{minted}{jlcon}
julia> print(STDOUT, 0x61)
97
\end{minted}



\hypertarget{407533094941619161}{}


\section{Propiedades contextuales de salida IO}



En ocasiones, la salida de IO puede beneficiarse de la capacidad de pasar información contextual a los métodos de muestra. El objeto \hyperlink{13454403377667762339}{\texttt{IOContext}} proporciona este marco para asociar metadatos arbitrarios con un objeto IO. Por ejemplo, \hyperlink{5384438952883464143}{\texttt{showcompact}} agrega un parámetro de alusión al objeto IO para que el método del espectáculo invocado imprima un resultado más corto (si corresponde).



\hypertarget{13857077857222739634}{}


\section{Trabajando con Ficheros}



Al igual que muchos otros entornos, Julia tiene una función \hyperlink{300818094931158296}{\texttt{open()}}, que toma un nombre de archivo y devuelve un objeto \texttt{IOStream} que puede usar para leer y escribir cosas del archivo. Por ejemplo, si tenemos un archivo, \texttt{hello.txt}, cuyo contenido es \texttt{Hello, World!}:




\begin{minted}{jlcon}
julia> f = open("hello.txt")
IOStream(<file hello.txt>)

julia> readlines(f)
1-element Array{String,1}:
 "Hello, World!"
\end{minted}



Si desea escribir a un fichero, puede abrirlo con el flag de escritura (\texttt{{\textquotedbl}w{\textquotedbl}}):




\begin{minted}{jlcon}
julia> f = open("hello.txt","w")
IOStream(<file hello.txt>)

julia> write(f,"Hello again.")
12
\end{minted}



Si examina el contenido de \texttt{hello.txt} en este punto, notará que está vacío; no se ha escrito nada en el disco todavía. Esto se debe a que el \texttt{IOStream} debe cerrarse antes de que la escritura realmente se vacíe en el disco:




\begin{minted}{jlcon}
julia> close(f)
\end{minted}



Examinando \texttt{hello.txt} nuevamente mostrará que su contenido ha sido cambiado.



Abrir un archivo, hacer algo con su contenido y volver a cerrarlo es un patrón muy común. Para hacerlo más fácil, existe otra invocación de \hyperlink{300818094931158296}{\texttt{open()}} que toma una función como su primer argumento y nombre de archivo como su segundo, abre el archivo, llama a la función con el archivo como argumento, y luego lo cierra de nuevo. Por ejemplo, dada una función:




\begin{minted}{julia}
function read_and_capitalize(f::IOStream)
    return uppercase(readstring(f))
end
\end{minted}



Uno puede llamar a:




\begin{minted}{jlcon}
julia> open(read_and_capitalize, "hello.txt")
"HELLO AGAIN."
\end{minted}



para abrir \texttt{hello.txt}, llamar \texttt{read\_and\_capitalize on it}, cerrar \texttt{hello.txt} y devolver los contenidos capitalizados.



Para incluso evitar tener que definir una función nombrada, puede usarse la sintaxis \texttt{do}, que crea una función anónima sobre la marcha:




\begin{minted}{jlcon}
julia> open("hello.txt") do f
           uppercase(readstring(f))
       end
"HELLO AGAIN."
\end{minted}



\hypertarget{9437920954475149393}{}


\section{Un ejemplo TCP simple}



Saltemos directamente con un ejemplo simple que involucra sockets TCP. Primero creemos un servidor simple:




\begin{minted}{jlcon}
julia> @async begin
           server = listen(2000)
           while true
               sock = accept(server)
               println("Hello World\n")
           end
       end
Task (runnable) @0x00007fd31dc11ae0
\end{minted}



Para quienes estén familiarizados con la API de socket de Unix, los nombres de los métodos se sentirán familiares, aunque su uso es algo más simple que la API de socket Raw de Unix. La primera llamada a \hyperlink{10380677384505520251}{\texttt{listen()}} creará un servidor en espera de conexiones entrantes en el puerto especificado (2000) en este caso. La misma función también se puede usar para crear otros tipos de servidores:




\begin{minted}{jlcon}
julia> listen(2000) # Listens on localhost:2000 (IPv4)
TCPServer(active)

julia> listen(ip"127.0.0.1",2000) # Equivalent to the first
TCPServer(active)

julia> listen(ip"::1",2000) # Listens on localhost:2000 (IPv6)
TCPServer(active)

julia> listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces
TCPServer(active)

julia> listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces
TCPServer(active)

julia> listen("testsocket") # Listens on a UNIX domain socket/named pipe
PipeServer(active)
\end{minted}



Tengase en cuenta que el tipo de retorno de la última invocación es diferente. Esto se debe a que este servidor no escucha en TCP, sino sobre una tubería nombrada (Windows) o socket de dominio UNIX. La diferencia es sutil y tiene que ver con los métodos \hyperlink{7162820662735004343}{\texttt{accept()}} y \hyperlink{9152037818560122293}{\texttt{connect()}}. El método \hyperlink{7162820662735004343}{\texttt{accept()}} recupera una conexión con el cliente que se está conectando en el servidor que acabamos de crear, mientras que la función \hyperlink{9152037818560122293}{\texttt{connect()}} se conecta a un servidor usando el método especificado. La función \hyperlink{9152037818560122293}{\texttt{connect()}} toma los mismos argumentos que \hyperlink{10380677384505520251}{\texttt{listen()}}, por lo tanto, suponiendo que el entorno (es decir, host, cwd, etc.) es el mismo uno debería capaz de pasar los mismos argumentos a \hyperlink{9152037818560122293}{\texttt{connect()}} como lo se hizo para escuchar en el establecimiento de la conexión. Así que vamos a intentarlo (después de haber creado el servidor anterior):




\begin{minted}{jlcon}
julia> connect(2000)
TCPSocket(open, 0 bytes waiting)

julia> Hello World
\end{minted}



Como era de esperar, vimos {\textquotedbl}Hello World{\textquotedbl} impreso. Entonces, analicemos realmente lo que sucedió detrás de escena. Cuando llamamos a \hyperlink{9152037818560122293}{\texttt{connect()}}, nos conectamos al servidor que acabamos de crear. Mientras tanto, la función \texttt{accept} devuelve una conexión del lado del servidor al socket recién creado e imprime {\textquotedbl}Hello World{\textquotedbl} para indicar que la conexión fue exitosa.



Una gran fortaleza de Julia es que, dado que la API se expone sincrónicamente a pesar de que la E/S realmente está sucediendo de forma asíncrona, no tuvimos que preocuparnos de las devoluciones de llamadas ni siquiera de asegurarnos de que el servidor se ejecute. Cuando llamamos a \hyperlink{9152037818560122293}{\texttt{connect()}} la tarea actual esperó a que se estableciera la conexión y solo continuó ejecutándose después de que se hizo. En esta pausa, la tarea del servidor reanudó la ejecución (porque una solicitud de conexión ya estaba disponible), aceptó la conexión, imprimió el mensaje y esperó al próximo cliente. Leer y escribir funciona de la misma manera. Para ver esto, considere el siguiente servidor de eco simple:




\begin{minted}{jlcon}
julia> @async begin
           server = listen(2001)
           while true
               sock = accept(server)
               @async while isopen(sock)
                   write(sock,readline(sock))
               end
           end
       end
Task (runnable) @0x00007fd31dc12e60

julia> clientside = connect(2001)
TCPSocket(RawFD(28) open, 0 bytes waiting)

julia> @async while true
           write(STDOUT,readline(clientside))
       end
Task (runnable) @0x00007fd31dc11870

julia> println(clientside,"Hello World from the Echo Server")
Hello World from the Echo Server
\end{minted}



Como con otros flujos, use \hyperlink{5331333469799487255}{\texttt{close()}} para desconectar el socket:




\begin{minted}{jlcon}
julia> close(clientside)
\end{minted}



\hypertarget{4586704640754855388}{}


\section{Resolviendo Direcciones IP}



Uno de los métodos \hyperlink{9152037818560122293}{\texttt{connect()}} que no sigue los métodos \hyperlink{10380677384505520251}{\texttt{listen()}} es \texttt{connect(host::String, port)}, que intentará conectarse al host dado por el parámetro \texttt{host} en el puerto dado por el parámetro port. Te permite hacer cosas como:




\begin{minted}{jlcon}
julia> connect("google.com",80)
TCPSocket(RawFD(30) open, 0 bytes waiting)
\end{minted}



En la base de esta funcionalidad está \hyperlink{8137893525760517927}{\texttt{getaddrinfo()}}, que hará la resolución de dirección apropiada:




\begin{minted}{jlcon}
julia> getaddrinfo("google.com")
ip"74.125.226.225"
\end{minted}



\hypertarget{3649475918943763834}{}


\chapter{Computación Paralela}



La mayoría de las computadoras modernas poseen más de una CPU, y varias computadoras pueden combinarse en un cluster. Aprovechar la potencia de estas múltiples CPU permite que muchos cálculos se completen más rápidamente. Hay dos factores principales que influyen en el rendimiento: la velocidad de las propias CPUs y la velocidad de su acceso a la memoria. En un clúster, es bastante obvio que una CPU dada tendrá acceso más rápido a la RAM dentro de la misma computadora (nodo). Quizás más sorprendentemente, problemas similares son relevantes en un portátil multicore típico, debido a las diferencias en la velocidad de la memoria principal y la \href{https://www.akkadia.org/drepper/cpumemory.pdf}{caché}. En consecuencia, un buen entorno de multiprocesamiento debe permitir el control sobre la {\textquotedbl}propiedad{\textquotedbl} de un trozo de memoria por una CPU particular. Julia proporciona un entorno de multiprocesamiento basado en el paso de mensajes para permitir que los programas se ejecuten en múltiples procesos en distintos dominios de memoria a la vez.



La implementación de Julia del paso del mensajes es diferente de otros entornos tales como MPI \footnotemark[1]. Comunicación en Julia es generalmente {\textquotedbl}unilateral{\textquotedbl}, lo que significa que el programador necesita explícitamente administrar sólo un proceso en una operación de dos procesos. Además, estas operaciones típicamente no se parecen a {\textquotedbl}envío de mensajes{\textquotedbl} y {\textquotedbl}recepción de mensajes{\textquotedbl}, sino más bien se asemejan a operaciones de nivel superior como llamadas a funciones de usuario.



La programación paralela en Julia se basa en dos primitivas: \emph{referencias remotas} y \emph{llamadas remotas}. Una referencia remota es un objeto que puede utilizarse desde cualquier proceso para referirse a un objeto almacenado en un proceso determinado. Una llamada remota es una petición de un proceso para llamar a una determinada función en ciertos argumentos en otro proceso (posiblemente el mismo).



Las referencias remotas vienen en dos variedades: \hyperlink{11214097672600393233}{\texttt{Future}} y \hyperlink{18168838922212360925}{\texttt{RemoteChannel}}.



Una llamada remota devuelve un \hyperlink{11214097672600393233}{\texttt{Future}} a su resultado. Las llamadas remotas retornan inmediatamente; el proceso que hizo que la llamada procede a su siguiente operación mientras la llamada remota sucede en otro lugar. Podemos esperar a que una llamada remota termine llamando a \hyperlink{13761789780433862250}{\texttt{wait()}} en el \hyperlink{11214097672600393233}{\texttt{Future}} devuelto, y puede obtener el valor completo del resultado usando \hyperlink{7098010828229464277}{\texttt{fetch()}}.



Por otro lado, los objetos \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} son reescribibles. Por ejemplo, varios procesos pueden coordinar su procesamiento haciendo referencia al mismo canal (\texttt{Channel}) remoto.



Cada proceso tiene un identificador asociado. El proceso que proporciona el \emph{prompt} interactivo de Julia siempre tiene un \texttt{id} igual a 1. Los procesos utilizados por defecto para operaciones paralelas se conocen como {\textquotedbl}workers{\textquotedbl}. Cuando solo hay un proceso, el proceso 1 se considera trabajador. De lo contrario, se considera que los trabajadores son todos procesos distintos del proceso 1.



Vamos a probar esto. Comenzar con \texttt{julia -p n} proporciona \texttt{n} procesos \emph{workers} en la máquina local. Generalmente tiene sentido igualar \texttt{n} al número de núcleos de la CPU en la máquina.




\begin{minted}{julia}
$ ./julia -p 2

julia> r = remotecall(rand, 2, 2, 2)
Future(2, 1, 4, Nullable{Any}())

julia> s = @spawnat 2 1 .+ fetch(r)
Future(2, 1, 5, Nullable{Any}())

julia> fetch(s)
2×2 Array{Float64,2}:
 1.18526  1.50912
 1.16296  1.60607
\end{minted}



El primer argumento para \hyperlink{1245601033905961947}{\texttt{remotecall()}} es la función para llamar. La mayoría de la programación paralela en Julia no hace referencia a procesos específicos ni a la cantidad de procesos disponibles, pero \hyperlink{1245601033905961947}{\texttt{remotecall()}} se considera una interfaz de bajo nivel que proporciona un control más preciso. El segundo argumento para \hyperlink{1245601033905961947}{\texttt{remotecall()}} es el \texttt{id} del proceso que hará el trabajo, y los argumentos restantes se pasarán a la función a la que se llama.



Como puede ver, en la primera línea le pedimos al proceso 2 que construyera una matriz aleatoria de 2 por 2, y en la segunda línea le pedimos que agregara 1 a ella. El resultado de ambos cálculos está disponible en los dos futuros, \texttt{r} y\texttt{s}. La macro \hyperlink{13196020699522784599}{\texttt{@ spawnat}} evalúa la expresión en el segundo argumento sobre el proceso especificado por el primer argumento.



Ocasionalmente, es posible que desee un valor calculado de forma remota de inmediato. Esto suele ocurrir cuando lee desde un objeto remoto para obtener los datos que necesita la próxima operación local. La función \hyperlink{16429337757386989414}{\texttt{remotecall\_fetch()}} existe para este propósito. Es equivalente a \texttt{fetch (remotecall(...))} pero es más eficiente




\begin{minted}{jlcon}
julia> remotecall_fetch(getindex, 2, r, 1, 1)
0.18526337335308085
\end{minted}



Recuerde que \hyperlink{2839226020402435013}{\texttt{getindex(r,1,1)}} es \hyperlink{14469287548874312017}{equivalente} a \texttt{r[1,1]}, por lo que esta llamada capta el primer elemento del futuro \texttt{r}.



La sintaxis de \hyperlink{1245601033905961947}{\texttt{remotecall()}} no es especialmente conveniente. La macro \hyperlink{2703776722227867458}{\texttt{@spawn}} hace las cosas más fáciles. Ella opera sobre una expresión en lugar de sobre una función, y elige dónde hacer la operación por ti:




\begin{minted}{jlcon}
julia> r = @spawn rand(2,2)
Future(2, 1, 4, Nullable{Any}())

julia> s = @spawn 1 .+ fetch(r)
Future(3, 1, 5, Nullable{Any}())

julia> fetch(s)
2×2 Array{Float64,2}:
 1.38854  1.9098
 1.20939  1.57158
\end{minted}



Note que usamos \texttt{1 .+ fetch(r)} en lugar de \texttt{1 .+ r}. Esto es debido a que no sabemos dónde se ejecutará el código, por lo que en general puede que se requiera un\hyperlink{7098010828229464277}{\texttt{fetch()}} para mover \texttt{r} al proceso que esta realizando la suma. En este caso, \hyperlink{2703776722227867458}{\texttt{@spawn}} es bastante inteligente como para realizar el computo sobre el proceso que posee \texttt{r}, por lo que la llamada \hyperlink{7098010828229464277}{\texttt{fetch()}} será una no-op (no se realiza trabajo).



(Hay que notar que \hyperlink{2703776722227867458}{\texttt{@spawn}} no es una función predefinida sino que está definida en Julia como una \hyperlink{11146454106624591870}{macro}. Es posible definir nuestras propias construcciones de ese tipo).



Una importante cosa a recordar es que, una vez traída, un \hyperlink{11214097672600393233}{\texttt{Future}} cacheará su valor localmente. Las llamadas adicionales a \hyperlink{7098010828229464277}{\texttt{fetch()}} calls no implican un salto de red. Una vez que todos los \hyperlink{11214097672600393233}{\texttt{Future}}s que referencian ha sido recuperados, el valor remoto almacenado es borrado.



\hypertarget{10930251041671662785}{}


\section{Disponibiliad de Código y Carga de Paquetes}



Nuestro código debe estar disponible sobre cualquir proceso que lo ejecuta. Por ejemplo, escriba esto en el \emph{prompt} de Julia:




\begin{minted}{jlcon}
julia> function rand2(dims...)
           return 2*rand(dims...)
       end

julia> rand2(2,2)
2×2 Array{Float64,2}:
 0.153756  0.368514
 1.15119   0.918912

julia> fetch(@spawn rand2(2,2))
ERROR: RemoteException(2, CapturedException(UndefVarError(Symbol("#rand2"))
[...]
\end{minted}



El proceso 1 sabe dónde se encuentra la función \texttt{rand2}, pero el proceso 2 no.



Ms comunmente uno estará cargando código desde ficheros o paquetes, y tendrá una considerable flexibilidad para controlar qué procesos cargan código. Considere un fichero \texttt{DummyModule.jl}, que contenga el siguiente código:




\begin{minted}{julia}
module DummyModule

export MyType, f

mutable struct MyType
    a::Int
end

f(x) = x^2+1

println("loaded")

end
\end{minted}



Si se arranca Julia con \texttt{julia -p 2}, se puede usar esto para verificar lo siguiente:



\begin{itemize}
\item \hyperlink{438355891087818425}{\texttt{include({\textquotedbl}DummyModule.jl{\textquotedbl})}} carga elfichero sólo sobre un proceso (el que ejecuta la instrucción).


\item \texttt{using DummyModule} causa que el módulo sea cargado sobre todos los procesos; sin embargo, el módulo es llevado al ámbito sólo por el que ejecuta la instrucción.


\item En cuanto \texttt{DummyModule} sea cargado sobre el proceso 2, mandatos como


\begin{minted}{julia}
rr = RemoteChannel(2)
put!(rr, MyType(7))
\end{minted}

permiten almacenar un objeto de tipo \texttt{MyType} sobre el proceso 2 incluso aunque \texttt{DummyModule} no esté en  el ámbito del proceso 2.

\end{itemize}


Uno puede forzar que un mandato se ejecute sobre todos los procesos usando la macro \hyperlink{12473779098025967223}{\texttt{@everywhere}}. Por ejemplo, \texttt{@everywhere} puede también ser usado para definir directamente una función sobre todos los procesos:




\begin{minted}{jlcon}
julia> @everywhere id = myid()

julia> remotecall_fetch(()->id, 2)
2
\end{minted}



Un fichero puede también ser precargado sobre múltiples procesos al inicio, y puede usarse un \emph{driver} para llevar a cabo ese cómputo:




\begin{lstlisting}
julia -p <n> -L file1.jl -L file2.jl driver.jl
\end{lstlisting}



El proceso Julia que corre el programa \emph{driver} del ejemplo anterior tiene un \texttt{id} igual a 1, justo como un proceso que proporciona un prompt interactivo.



La instalación base de Julia tiene soporte intríseco para dos tipos de clusters:



\begin{itemize}
\item Un clúster local especificado con la opción \texttt{-p}, como se mostró anteriormente.


\item Un clúster que abarca máquinas utilizando la opción \texttt{--machinefile}. Esto utiliza un inicio de  sesión \texttt{ssh} sin contraseña para iniciar los procesos de trabajo de Julia (desde la misma ruta  que el servidor actual) en las máquinas especificadas.

\end{itemize}


Las funciones \hyperlink{1448678099847390}{\texttt{addprocs()}}, \hyperlink{10441166839192005456}{\texttt{rmprocs()}}, \hyperlink{13629390137500792933}{\texttt{workers()}}, y otras están disponibles como una forma programática de añadir, borrar y consultar los procesos en un cluster.



Note que los \emph{workers} no ejecutan un script \texttt{.juliarc.jl} de inicio, ni sincronizan su estado global (tal como variables globales, nuevas definiciones de métodos y módulos cargados) con cualquiera de los procesos que están ejecutando.



Pueden soportarse otros tipos de clústers escribiendo nuestro propio \texttt{ClusterManager}, como se describe después en la sección ClusterManagers section.



\hypertarget{8031321852813948159}{}


\section{Movimiento de Datos}



Enviar mensaje y mover datos constituye la mayor parte de la sobrecarga de un programa paralelo. Reducir el número de mensajes y la cantidad de datos enviados es crítico para conseguir rendimiento y escalabilidad. Para este fin, es importante comprender el movimiento de datos realizado por varias construcciones de programación paralela de Julia.



\hyperlink{7098010828229464277}{\texttt{fetch()}} puede considerarse una operación explícita de movimiento de datos, ya que directamente pide que un objeto sea movido a la máquina local. \hyperlink{2703776722227867458}{\texttt{@spawn}} (y unas pocas construcciones relacionadas) también mueve datos, pero esto no es tan obvio, por lo tanto, puede denominarse una operación implícita de movimiento de datos. Considere estos dos enfoques para construir y cuadrar una matriz aleatoria:



Method 1:




\begin{minted}{jlcon}
julia> A = rand(1000,1000);

julia> Bref = @spawn A^2;

[...]

julia> fetch(Bref);
\end{minted}



Method 2:




\begin{minted}{jlcon}
julia> Bref = @spawn rand(1000,1000)^2;

[...]

julia> fetch(Bref);
\end{minted}



La diferencia parece trivial, pero de hecho es bastante significativa debido al comportamiento de \hyperlink{2703776722227867458}{\texttt{@spawn}}. En el primer método, se construye localmente una matriz aleatoria, y después se manda a otro proceso que la eleva al cuadrado. En el segundo método, una matriz aleatoria es construida y elevada al cuadrado (ambas operaciones) sobre otro proceso. Por tanto, el segundo método envía muchos menos datos que el primero. 



En este ejemplo de juquete, los dos métodos son fáciles de distinguir y elegir. Sin embargo, en un programa real dieseñar movimiento de datos puede requerir ms reflexin y, probablemente, alguna medida. Por ejemplo, si el primero proceso necesita la matriz \texttt{A}, entonces el primer método sera mejor. O, si calcular \texttt{A} es costoso y sólo el proceso actual tiene que hacerlo, entonces mover la matriz al otro proceso puede ser inevitable. o, si el proceso actual tiene muy poco que hacer entre las instrucciones \hyperlink{2703776722227867458}{\texttt{@spawn}} y \texttt{fetch(Bref)}, podría ser mejor eliminar el paralelismo por completo. O imagine que \texttt{rand(1000,1000)} es reemplazado con un a operación más costosa. Entonces podría tener sentido añadir ora instrucción  \hyperlink{2703776722227867458}{\texttt{@spawn}} sólo para este paso.



\hypertarget{5313424777478067659}{}


\chapter{Variables Globales}



Las expresiones ejecutadas remotamente vía \texttt{@spawn}, o los cierres especificados para ejecucin remota usando \texttt{remotecall} pueden referirse a variables globales. Las vinculaciones globales en el módulo \texttt{Main} son tratadas de un modo un poco diferente comparados a las vinculaciones globales en otros módulos. Considere el siguiente trozo de código:




\begin{minted}{jlcon}
A = rand(10,10)
remotecall_fetch(()->foo(A), 2)
\end{minted}



Tenga en cuenta que \texttt{A} es una variable global definida en el espacio de trabajo local. El \emph{worker} 2 no tiene una variable llamada \texttt{A} dentro de \texttt{Main}. Por tantom el acto de enviar el cierre \texttt{() -> foo(A)} al \emph{worker} 2 da como resultado que \texttt{Main.A} se defina en 2. \texttt{Main.A} sigue existiendo en el worker 2 incluso después de que la llamada \texttt{remotecall\_fetch} retorne. Las llamadas remotas con referencias globales integradas (solo bajo el módulo \texttt{Main}) administran los datos globales de la siguiente manera:



\begin{itemize}
\item Se crean nuevos enlaces globales en los trabajadores de destino si se hace referencia a ellos como parte de una llamada remota.


\item Las constantes globales se declaran también como constantes en los nodos remotos.


\item Globales se reenvían a un \emph{worker} de destino solo en el contexto de una llamada remota, y solo si su valor ha cambiado. Además, el clúster no sincroniza las asignaciones globales entre nodos. Por ejemplo:


\begin{minted}{julia}
A = rand(10,10)
remotecall_fetch(()->foo(A), 2) # worker 2
A = rand(10,10)
remotecall_fetch(()->foo(A), 3) # worker 3
A = nothing
\end{minted}

Ejecutar este trozo de código da como resultado que \texttt{Main.A} del \emph{worker} 2 tenga un valor diferente del que tiene en  \texttt{Main.A} del \emph{worker} 3, mientras que el valor de \texttt{Main.A} en el nodo 1 se fija a \texttt{nothing}.

\end{itemize}


Como se habrá dado cuenta, aunque la memoria asociada con los globales se puede recopilar cuando se reasignan en el maestro, dicha acción no se toma en los \emph{workers} ya que los enlaces siguen siendo válidos. \hyperlink{16259780224935483802}{\texttt{clear!}} se puede usar para reasignar manualmente globales específicos en nodos remotos a \texttt{nothing} una vez que ya no sean necesarios. Esto liberará cualquier memoria asociada con ellos como parte de un ciclo de recolección de basura regular.



Por lo tanto, los programas deben ser cuidadosos al hacer referencia a los globales en las llamadas remotas. De hecho, es preferible evitarlos por completo si es posible. Si hay que hacer referencia a globales, considere usar bloques \texttt{let} para localizar variables globales.



For example:




\begin{minted}{jlcon}
julia> A = rand(10,10);

julia> remotecall_fetch(()->A, 2);

julia> B = rand(10,10);

julia> let B = B
           remotecall_fetch(()->B, 2)
       end;

julia> @spawnat 2 whos();

julia>  From worker 2:                               A    800 bytes  10×10 Array{Float64,2}
        From worker 2:                            Base               Module
        From worker 2:                            Core               Module
        From worker 2:                            Main               Module
\end{minted}



Como puede verse, la variable global \texttt{A} es definidia en el \emph{worker} 2, pero \texttt{B} es capturada como una variable local y por tanto no existe una asignacin para \texttt{B} en \emph{worker} 2.



\hypertarget{13617358862583386109}{}


\section{Map y Bucles Paralelos}



Afortunadamente, muchos cálculos paralelos no requieren movimiento de datos. Un ejemplo común es las simulaciones Monte Carlo, donde muchos procesos pueden manejar simultáneamente pruebas de simulación independientes. Podemos usar \hyperlink{2703776722227867458}{\texttt{@spawn}} para lanzar monedas sobre dos procesos. Primero, se escribiría la siguiente función en \texttt{count\_heads.jl}:




\begin{minted}{julia}
function count_heads(n)
    c::Int = 0
    for i = 1:n
        c += rand(Bool)
    end
    c
end
\end{minted}



La función \texttt{count\_heads} simplemente añade juntos \texttt{n} bits aleatorios. He aqui cónmo pueden realizarse algunas pruebas sobre dos máquinas, y añadir juntos los resultados:




\begin{minted}{jlcon}
julia> @everywhere include("count_heads.jl")

julia> a = @spawn count_heads(100000000)
Future(2, 1, 6, Nullable{Any}())

julia> b = @spawn count_heads(100000000)
Future(3, 1, 7, Nullable{Any}())

julia> fetch(a)+fetch(b)
100001564
\end{minted}



Este ejemplo demuestra un patrón de programación paralela potente y frecuentemente usado. Muchas iteraciones se ejecutan independientemente sobre varios porocesos, y entonces sus resultados se combinan usando alguna función. El proceso de combinación se denomina \emph{reducción} ya que suele ser la reduccin de rango de un tensor: un vector de números es reducido a un solo número o una matriz es reducida a una sola fila o columna, etc. En código esto suele tener el aspecto del patrón \texttt{x = f(x,v[i])}, donde \texttt{x} es el acumulador, \texttt{f} es la funcin de reducción, y los \texttt{v[i]} son los elementos que se reducirán. Es deseable que \texttt{f} sea asociativa, para que no importe el orden en el que se realizan las operaciones.



Notese que nuestro uso de este patrón con \texttt{count\_heads} puede ser generalizado. Se utilizaron dos instrucciones \hyperlink{2703776722227867458}{\texttt{@spawn}} explícitas, que limitan el paralelismo a dos procesos. Para ejecutar sobre cualquier número de procesos, se puede usar el \emph{bucle for paralelo} que puede escribirse en Julia usando la macro \hyperlink{11870389661093259741}{\texttt{@parallel}} como en este ejemplo:




\begin{minted}{julia}
nheads = @parallel (+) for i = 1:200000000
    Int(rand(Bool))
end
\end{minted}



Esta construcción implementa el patrón de asignar iteraciones a múltiples procesos, y combinarlos con una reducción especificada (en este caso \texttt{(+)}). El resultado de cada iteración es tomado como el valor de la última expresión dentro del bucle. La expresión total del bucle paralelo en sí misma se evalúa a la respuesta final.



Debe notar que, aunque los bucles for paralelos tienen un aspecto muy parecido al de los bucles for seriales, su comportamiento es dramaticamente diferente. En particular, las iteraciones no tiene lugar en un orden especificado, y l escritura a variables o arrays no será globalmente visible ya que las iteraciones se ejecutan sobre procesos distintos. Cualquier variable usada dentro del bucle paralelo será copiada y retransmitida a cada proceso.



Por ejemplo, el siguiente código no trabajará como se esperaba:




\begin{minted}{julia}
a = zeros(100000)
@parallel for i = 1:100000
    a[i] = i
end
\end{minted}



Este código no inicializará todo \texttt{a}, ya que cada proceso tendrá una copia separada de él. Los bucles for paralelos como éste deben ser evitados. Afortunadamente, podemos usar los arrays compartidos para sortear esta limitación:




\begin{minted}{julia}
a = SharedArray{Float64}(10)
@parallel for i = 1:10
    a[i] = i
end
\end{minted}



Usar variables {\textquotedbl}forasteras{\textquotedbl} en los bucles paralelos es perfectamente razonable si las variables son de sólo lectura:




\begin{minted}{julia}
a = randn(1000)
@parallel (+) for i = 1:100000
    f(a[rand(1:end)])
end
\end{minted}



En este ejemplo, cada iteración aplica \texttt{f} a una muestra elegida aleatoriamente de un vector \texttt{a} compartido por todos los procesos.



Como podía ver, el operador de reducción puede ser omitido si no se necesita En este caso, el bucle se ejecuta de forma asíncrona, es decir, engendra tareas independientes sobre todos los \emph{workers} disponibles y devuelve un array de objetos \hyperlink{11214097672600393233}{\texttt{Future}} inmediatamente sin esperar a su terminación. El código invocador puede esperar a la terminación de los \hyperlink{11214097672600393233}{\texttt{Future}} en un punto posterior mediante una llamada a \hyperlink{7098010828229464277}{\texttt{fetch()}} sobre ellos, o esperar la terminancin al final del bucle prefijándolo con \hyperlink{7188613740509403855}{\texttt{@sync}}, como \texttt{@sync @parallel for}.



En algunos casos no se necesita un operador de reducción, y simplemente deseamos aplicar una funcin a todos los enteros en algún rango (o, de forma más general, a todos los elementos de una colección). Esta es otra operación útil llamada \emph{parallel map}, implementada en con la función \hyperlink{3190941263759446411}{\texttt{pmap()}}. Por ejemplo, podríamos computar los valores singularees de varias matrices aleatorias en paralelo de la siguiente forma:




\begin{minted}{jlcon}
julia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];

julia> pmap(svd, M);
\end{minted}



La función \hyperlink{3190941263759446411}{\texttt{pmap()}} de Julia está diseñada para el caso de que cada llamada a función realice una gran cantidad de trabajo. En contraste \texttt{@parallel for} puede manejar situaciones donde cada iteración es pequeña, quizás incluso sumar dos números. Tanto las funciones \hyperlink{3190941263759446411}{\texttt{pmap()}} como \texttt{@parallel for} usan exclusivamente procesos \emph{worker} para la computación paralela. En el caso de \texttt{@parallel for}, la reducción final se realiza sobre el proceso principal.



\hypertarget{6433297939763556168}{}


\section{Sincronización con Referencias Remotas}



\hypertarget{17938708047980043710}{}


\section{Planificación}



La plataforma de programación paralela de Julia usa \hyperlink{15038256797533490288}{Tareas (también conocidas como Coroutinas)} para alternar entre múltiples cálculos. Cada vez que el código realiza una operación de comunicación como \hyperlink{7098010828229464277}{\texttt{fetch()}} o \hyperlink{13761789780433862250}{\texttt{wait()}}, la tarea actual se suspende y un planificador elige otra tarea para ejecutar. Una tarea se reinicia cuando finaliza el evento que está esperando.



Para muchos problemas, no es necesario pensar en las tareas directamente. Sin embargo, pueden usarse para esperar múltiples eventos al mismo tiempo, lo que proporciona una \emph{planificación dinámica}. En la planificación dinámica, un programa decide qué calcular o dónde calcularlo en función de cuándo finalizan otros trabajos. Esto es necesario para cargas de trabajo impredecibles o desequilibradas, donde queremos asignar más trabajo a los procesos solo cuando finalizan sus tareas actuales.



Como ejemplo, considere calcular los valores singulares de matrices de diferentes tamaños:




\begin{minted}{jlcon}
julia> M = Matrix{Float64}[rand(800,800), rand(600,600), rand(800,800), rand(600,600)];

julia> pmap(svd, M);
\end{minted}



Si un proceso maneja la dos matrices de 800 × 800 y otro maneja las dos matrices de 600 × 600, no obtendremos la mayor escalabilidad posible. La solución es hacer una tarea local para {\textquotedbl}alimentar{\textquotedbl} el trabajo a cada proceso cuando completa su tarea actual. Por ejemplo, considere una implementación simple \hyperlink{3190941263759446411}{\texttt{pmap()}}:




\begin{minted}{julia}
function pmap(f, lst)
    np = nprocs()  # determine the number of processes available
    n = length(lst)
    results = Vector{Any}(n)
    i = 1
    # function to produce the next work item from the queue.
    # in this case it's just an index.
    nextidx() = (idx=i; i+=1; idx)
    @sync begin
        for p=1:np
            if p != myid() || np == 1
                @async begin
                    while true
                        idx = nextidx()
                        if idx > n
                            break
                        end
                        results[idx] = remotecall_fetch(f, p, lst[idx])
                    end
                end
            end
        end
    end
    results
end
\end{minted}



\hyperlink{10770947021537241619}{\texttt{@async}} es similar a \hyperlink{2703776722227867458}{\texttt{@spawn}}, pero solo ejecuta tareas en el proceso local. Lo usamos para crear una tarea   {\textquotedbl}alimentador{\textquotedbl} para cada proceso. Cada tarea selecciona el siguiente índice que debe calcularse, luego espera a que termine su proceso, y luego se repite hasta que nos quedemos sin índices. Tenga en cuenta que las tareas {\textquotedbl}alimentadoras no{\textquotedbl} comienzan a ejecutarse hasta que la tarea principal llega al final del bloque \hyperlink{7188613740509403855}{\texttt{@sync}}, momento en el cual se somete al control y espera a que se completen todas las tareas locales antes de regresar de la función. Las tareas del {\textquotedbl}alimentador{\textquotedbl} pueden compartir el estado a través de \texttt{nextidx()} porque todas se ejecutan en el mismo proceso. No se requiere bloqueo, ya que los hilos están programados de forma cooperativa y no apropiativa. Esto significa que los cambios de contexto solo ocurren en puntos bien definidos: en este caso, cuando se llama a \hyperlink{16429337757386989414}{\texttt{remotecall\_fetch()}}.



\hypertarget{1667100093623018762}{}


\section{Canales}



La sección sobre tareas (\hyperlink{7131243650304654155}{\texttt{Task}}) en \hyperlink{8710711813610225279}{Control de flujo} discutió la ejecución de múltiples funciones de forma cooperativa. Los canales (\hyperlink{12548845729684045604}{\texttt{Channel}}) pueden ser bastante útiles para pasar datos entre tareas en ejecución, particularmente aquellas que involucran operaciones de E/S.



Ejemplos de operaciones que implican E/S incluyen la lectura/escritura en archivos, acceso a servicios web, ejecución de programas externos, etc. En todos estos casos, el tiempo de ejecución general puede mejorarse si se pueden ejecutar otras tareas mientras se lee un archivo, o mientras se espera a que se complete un servicio o programa externo.



Un canal se puede visualizar como un conducto, es decir, tiene un extremo de escritura y un extremo de lectura.



\begin{itemize}
\item Varios escritores en diferentes tareas pueden escribir en el mismo canal concurrentemente a través de llamadas \hyperlink{12719543094136814100}{\texttt{put!()}}.


\item Varios lectores en diferentes tareas pueden leer datos simultáneamente a través de llamadas \hyperlink{4360129174058888556}{\texttt{take!()}}.


\item Como ejemplo:

\end{itemize}



\begin{minted}{julia}
    # Given Channels c1 and c2,
    c1 = Channel(32)
    c2 = Channel(32)

    # and a function `foo()` which reads items from from c1, processes the item read
    # and writes a result to c2,
    function foo()
        while true
            data = take!(c1)
            [...]               # process data
            put!(c2, result)    # write out result
        end
    end

    # we can schedule `n` instances of `foo()` to be active concurrently.
    for _ in 1:n
        @schedule foo()
    end
    ```
 
   * Los canales se crean a través del constructor `Channel{T}(sz)`. El canal solo tendrá objetos de tipo `T`. Si no se especifica el tipo, el canal puede contener objetos de cualquier tipo. `sz` se refiere a la cantidad máxima de elementos que pueden mantenerse en el canal en cualquier momento. Por ejemplo, `Channel(32)` crea un canal que puede contener un máximo de 32 objetos de cualquier tipo. Un `Channel{MyType}(64)` puede contener hasta 64 objetos de `MyType` en cualquier momento.
   * Si un [`Channel`](@ref) está vacío, los lectores (en una llamada [`take!()`](@ref)) se bloquearán hasta que los datos estén disponibles.
   * Si un [`Channel`](@ref) está lleno, los escritores (en una llamada [`put!()`](@ref)) se bloquearán hasta que haya espacio disponible.
   * [`isready()`](@ref) comprueba la presencia de cualquier objeto en el canal, mientras que [`wait()`](@ref) espera a que un objeto esté disponible.
   * Un [`Channel`](@ref) está inicialmente en un estado abierto. Esto significa que puede leerse y escribirse libremente a través de llamadas [`take!()`](@ref) y [`put!()`](@ref). [`close()`](@ref) cierra un [`Channel`](@ref). En un [`Channel`](@ref) cerrado, la función [`put!()`](@ref) fallará. Por ejemplo:
  
\end{minted}



julia-repl julia> c = Channel(2);



julia> put!(c, 1) \# \texttt{put!} on an open channel succeeds 1



julia> close(c);



julia> put!(c, 2) \# \texttt{put!} on a closed channel throws an exception. ERROR: InvalidStateException({\textquotedbl}Channel is closed.{\textquotedbl},:closed) [...]




\begin{lstlisting}

* [`take!()`](@ref) y [`fetch()`](@ref) (que recupera pero no elimina el valor) en un canal cerrado devuelve con éxito cualquier valor existente hasta que se vacíe. Continuando con el ejemplo anterior:

\end{lstlisting}



julia-repl julia> fetch(c) \# Any number of \texttt{fetch} calls succeed. 1



julia> fetch(c) 1



julia> take!(c) \# The first \texttt{take!} removes the value. 1



julia> take!(c) \# No more data available on a closed channel. ERROR: InvalidStateException({\textquotedbl}Channel is closed.{\textquotedbl},:closed) [...]




\begin{lstlisting}

Un canal se puede usar como un objeto iterable en un bucle `for`, en cuyo caso el bucle se ejecuta mientras el canal tenga datos o esté abierto. La variable del bucle toma todos los valores agregados al canal. El bucle `for` finaliza una vez que el canal se cierra y se vacía.

Por ejemplo, lo siguiente haría que el bucle `for` esperara más datos:

\end{lstlisting}



julia-repl julia> c = Channel\{Int\}(10);



julia> foreach(i->put!(c, i), 1:3) \# add a few entries



julia> data = [i for i in c]




\begin{lstlisting}

mientras que esto retornará después de leer todos los datos:

\end{lstlisting}



julia-repl julia> c = Channel\{Int\}(10);



julia> foreach(i->put!(c, i), 1:3); \# add a few entries



julia> close(c);                    \# \texttt{for} loops can exit



julia> data = [i for i in c] 3-element Array\{Int64,1\}:  1  2  3




\begin{lstlisting}

Consideremos un ejemplo simple utilizando canales para la comunicación entre tareas. Comenzamos 4 tareas para procesar los datos de un solo canal `jobs`. Los trabajos, identificados por un identificador (`job_id`), se escriben en el canal. Cada tarea en esta simulación lee un `job_id`, espera una cantidad aleatoria de tiempo y escribe una tupla de `job_id` y el tiempo simulado en el canal de resultados. Finalmente todos los `resultados` se imprimen.

\end{lstlisting}



julia-repl julia> const jobs = Channel\{Int\}(32);



julia> const results = Channel\{Tuple\}(32);



julia> function do\_work()            for job\_id in jobs                exec\_time = rand()                sleep(exec\_time)                \# simulates elapsed time doing actual work                                                \# typically performed externally.                put!(results, (job\_id, exec\_time))            end        end;



julia> function make\_jobs(n)            for i in 1:n                put!(jobs, i)            end        end;



julia> n = 12;



julia> @schedule make\_jobs(n); \# feed the jobs channel with {\textquotedbl}n{\textquotedbl} jobs



julia> for i in 1:4 \# start 4 tasks to process requests in parallel            @schedule do\_work()        end



julia> @elapsed while n > 0 \# print out results            job\_id, exec\_time = take!(results)            println({\textquotedbl}job\_id finished in round(exec\_time, 2) seconds{\textquotedbl})            n = n - 1        end 4 finished in 0.22 seconds 3 finished in 0.45 seconds 1 finished in 0.5 seconds 7 finished in 0.14 seconds 2 finished in 0.78 seconds 5 finished in 0.9 seconds 9 finished in 0.36 seconds 6 finished in 0.87 seconds 8 finished in 0.79 seconds 10 finished in 0.64 seconds 12 finished in 0.5 seconds 11 finished in 0.97 seconds 0.029772311




\begin{lstlisting}

La versión actual de Julia multiplexa todas las tareas en un solo hilo del sistema operativo. Por lo tanto, aunque las tareas que implican operaciones de E/S se benefician de la ejecución en paralelo, las tareas vinculadas a la computación se ejecutan efectivamente de forma secuencial en un solo hilo del sistema operativo. Las versiones futuras de Julia pueden soportar la planificación de tareas en múltiples subprocesos, en cuyo caso las tareas vínculadas al cálculo  también verán los beneficios de la ejecución en paralelo.

## Referencias remotas y AbstractChannels

Las referencias remotas siempre se refieren a una implementación de un `AbstractChannel`.

Se requiere una implementación concreta de un `AbstractChannel` (como `Channel`) para implementar [`put!()`](@ref), [`take!()`](@ref), [`fetch()`](@ref), [`isready()`](@ref) y [`wait()`](@ref). El objeto remoto al que se hace referencia con un [`Future`](@ref) se almacena en `Channel{Any}(1) `, es decir, un` Channel` de tamaño 1 capaz de contener objetos del tipo `Any`.

[`RemoteChannel`](@ref), que es reescribible, puede señalar cualquier tipo y tamaño de canales, o cualquier otra implementación de `AbstractChannel`.

El constructor `RemoteChannel(f::Function, pid)()` permite construir referencias a canales que contienen más de un valor de un tipo específico. `f()` es una función ejecutada en un `pid` y debe devolver un `AbstractChannel`.

Por ejemplo, `RemoteChannel(()->Channel{Int}(10), pid)`, devolverá una referencia a un canal de tipo `Int` y tamaño 10. El canal existe sobre el *worker* `pid`.

Los métodos [`put!()`](@ref), [`take!()`](@ref), [`fetch()`](@ref), [`isready()`](@ref) y [`wait()`](@ref) de un [`RemoteChannel`](@ref) son proxys en el backing store en el proceso remoto.

[`RemoteChannel`](@ref) se puede usar para referirse a los objetos `AbstractChannel` implementados por el usuario. Un ejemplo simple de esto se proporciona en `examples/dictchannel.jl` que usa un diccionario como su almacén remoto.

## `Channel`s y `RemoteChannel`s

* Un objeto [`Channel`](@ref) es local a un proceso. El *worker* 2 no puede referirse directamente a un `Channel` sobre el *worker* 3 y viceversa. Un [`RemoteChannel`](@ref), sin embargo, puedo poner y tomar valores entre *worker*s.
* Un [`RemoteChannel`](@ref) se puede considerar como un *manejador* para un `Channel`.
* La identificación del proceso, `pid`, asociada con un [`RemoteChannel`](@ref) identifica el proceso donde el almacén de respaldo, es decir, el `Channel`  de respaldo existe.
* Cualquier proceso con una referencia a [`RemoteChannel`](@ref) puede poner y tomar elementos del canal. Los datos se envían automáticamente a (o se recuperan de) el proceso al que está asociado [`RemoteChannel`](@ref).
* Serializar un `Channel` también serializa cualquier dato presente en el canal. Deserializarlo, por lo tanto, efectivamente hace una copia del objeto original.
* Por otro lado, serializar un [`RemoteChannel`](@ref) solo implica la serialización de un identificador que identifica la ubicación y la instancia del `Channel` al que hace referencia el manejador. Un objeto [`RemoteChannel`](@ref) deserializado  (en cualquier *worker*), por lo tanto, también apunta al mismo almacén de respaldo que el original.

El ejemplo de canales anterior puede modificarse para la comunicación entre procesos, como se muestra a continuación.

Comenzamos 4 trabajadores para procesar un solo canal remoto `jobs`. Los trabajos, identificados por una identificación (`job_id`), se escriben en el canal. Cada tarea de ejecución remota en esta simulación lee un `job_id`, espera una cantidad aleatoria de tiempo y escribe una tupla de` job_id`, tiempo tomado y su propio `pid` en el canal de resultados. Finalmente todos los `resultados` se imprimen en el proceso maestro.

\end{lstlisting}



julia-repl julia> addprocs(4); \# add worker processes



julia> const jobs = RemoteChannel(()->Channel\{Int\}(32));



julia> const results = RemoteChannel(()->Channel\{Tuple\}(32));



julia> @everywhere function do\_work(jobs, results) \# define work function everywhere            while true                job\_id = take!(jobs)                exec\_time = rand()                sleep(exec\_time) \# simulates elapsed time doing actual work                put!(results, (job\_id, exec\_time, myid()))            end        end



julia> function make\_jobs(n)            for i in 1:n                put!(jobs, i)            end        end;



julia> n = 12;



julia> @schedule make\_jobs(n); \# feed the jobs channel with {\textquotedbl}n{\textquotedbl} jobs



julia> for p in workers() \# start tasks on the workers to process requests in parallel            @async remote\_do(do\_work, p, jobs, results)        end



julia> @elapsed while n > 0 \# print out results            job\_id, exec\_time, where = take!(results)            println({\textquotedbl}job\_id finished in round(exec\_time, 2) seconds on worker where{\textquotedbl})            n = n - 1        end 1 finished in 0.18 seconds on worker 4 2 finished in 0.26 seconds on worker 5 6 finished in 0.12 seconds on worker 4 7 finished in 0.18 seconds on worker 4 5 finished in 0.35 seconds on worker 5 4 finished in 0.68 seconds on worker 2 3 finished in 0.73 seconds on worker 3 11 finished in 0.01 seconds on worker 3 12 finished in 0.02 seconds on worker 3 9 finished in 0.26 seconds on worker 5 8 finished in 0.57 seconds on worker 4 10 finished in 0.58 seconds on worker 2 0.055971741




\begin{lstlisting}

## Referencias Remotas y Recolección de Basura Distribuida

Los objetos a los que se refieren las referencias remotas se pueden liberar solo cuando se eliminan *todas* las referencias retenidas en el clúster.

El nodo donde se almacena el valor realiza un seguimiento de cuáles de los trabajadores tienen una referencia. Cada vez que un [`RemoteChannel`](@ref) o un (unfetched) [`Future`](@ref) se serializa a un *worker*, se notifica el nodo al que apunta la referencia. Y cada vez que un [`RemoteChannel`](@ref) o un (unfetched) [`Future`](@ref) es sometido a recolección de basura localmente, el nodo que posee el valor es nuevamente notificado.

Las notificaciones se realizan a través del envío de mensajes de "seguimiento": un mensaje de "agregar referencia" cuando una referencia se serializa a un proceso diferente y un mensaje de "eliminación de referencia" cuando una referencia se recolecta localmente.

Como los [`Future`](@ref)s son de escritura única y se almacenan en caché localmete, el acto de [`fetch()`](@ref)ing un [`Future`](@ref) también actualiza la información de seguimiento de referencia en el nodo que posee el valor.

El nodo que posee el valor lo libera una vez que se borran todas las referencias a él.

Con [`Future`](@ref)s, la serialización de un [`Future`](@ref) ya obtenido  a un nodo diferente también envía el valor ya que el almacén remoto original puede haber recolectado el valor en ese momento.

Es importante tener en cuenta que *cuando* un objeto se recolecta basura localmente depende del tamaño del objeto y la presión de la memoria actual en el sistema.

En el caso de referencias remotas, el tamaño del objeto de referencia local es bastante pequeño, mientras que el valor almacenado en el nodo remoto puede ser bastante grande. Dado que el objeto local puede no receolectarse inmediatamente, es una buena práctica llamar explícitamente a [`finalize()`](@ref) en instancias locales de un [`RemoteChannel`](@ref), o en unfetched [`Future`](@ref)s. Como llamar a [`fetch()`](@ref) sobre un [`Future`](@ref) también elimina su referencia del almacén remoto, esto no es necesario en fetched [`Future`](@ref)s. Llamar explícitamente a [`finalize()`](@ref) da como resultado un mensaje inmediato enviado al nodo remoto para continuar y eliminar su referencia al valor.

Una vez finalizado, una referencia deja de ser válida y no se puede usar en ninguna otra llamada.

## [Arrays Compartidos](@id man-shared-arrays)

Los arrays compartidos usan memoria compartida del sistema para hacer corresponder el mismo array a través de muchos procesos. Aunque hay algunas similaridades a un [`DArray`](https://github.com/JuliaParallel/DistributedArrays.jl), el comportamiento de un [`SharedArray`](@ref) es bastante diferente. En un [`SharedArray`](@ref), cada proceso tiene acceso local justo a un trozo de los datos, y do hay dos procesos que compartan el mismo trozo; en contraste, en un [`SharedArray`](@ref) cada proceso "participante" tiene acceso al array completo. Un [`SharedArray`](@ref) es una buena elección cuando uno quiere tener una gran cantidad de datos conjuntamente accesibles a dos o más procesos sobre la misma máquina.

La indexación de los [`SharedArray`](@ref)s funciona justo como con los arrays regulares, y es eficiente debido a que la memoria subyacente está disponible al proceso local. Por tanto, la mayoría de los algoritmos trabajan de forma natural sobre los [`SharedArray`](@ref)s, aunque en modo uniproceso. En casos donde un algoritmo insiste sobre una entrada [`Array`](@ref), el array subyacente se puede recuperar desde un [`SharedArray`](@ref) llamando a [`sdata()`](@ref). Para otros tipos de `AbstractArray`, [`sdata()`](@ref) simplemente devuelve el objeto, por lo que es seguro usar [`sdata()`](@ref) en cualquier objeto de tipo` Array`.

El constructor par aun array compartido es de la forma:

\end{lstlisting}



julia SharedArray\{T,N\}(dims::NTuple; init=false, pids=Int[])




\begin{lstlisting}

que crea un array compartido `N`-dimensional de un tipo de bits `T` y `dims` de tamaño en los procesos especificados por `pids`. A diferencia de los arrays distribuidos, a un array compartido solo se puede acceder desde los *workers* participantes especificados por el argumento denominado `pids` (y el proceso de creación también, si está en el mismo host).

Si se especifica una función `init`, con signatura `initfn(S::SharedArray)`, se llama a todos los trabajadores participantes. Puede especificar que cada trabajador ejecute la función `init` en una parte distinta de la matriz, paralelizando así la inicialización.

He aquí un breve ejemplo:

\end{lstlisting}



julia-repl julia> addprocs(3) 3-element Array\{Int64,1\}:  2  3  4



julia> S = SharedArray\{Int,2\}((3,4), init = S -> S[Base.localindexes(S)] = myid()) 3×4 SharedArray\{Int64,2\}:  2  2  3  4  2  3  3  4  2  3  4  4



julia> S[3,2] = 7 7



julia> S 3×4 SharedArray\{Int64,2\}:  2  2  3  4  2  3  3  4  2  7  4  4




\begin{lstlisting}

[`Base.localindexes()`](@ref) proporciona rangos unidimensionales disjuntos de índices, y a veces es conveniente para dividir tareas entre procesos. Uno puede, por supuesto, dividir el trabajo de la manera que desee:

\end{lstlisting}



julia-repl julia> S = SharedArray\{Int,2\}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = myid()) 3×4 SharedArray\{Int64,2\}:  2  2  2  2  3  3  3  3  4  4  4  4




\begin{lstlisting}

Como todos los procesos tienen acceso a los datos subyacentes, uno tiene que tener cuidado de no generar conflictos. Por ejemplo:

\end{lstlisting}



julia @sync begin     for p in procs(S)         @async begin             remotecall\_wait(fill!, p, S, p)         end     end end




\begin{lstlisting}

daría como resultado un comportamiento indefinido. Debido a que cada proceso llena la matriz *entera* con su propio `pid`, el proceso que sea el último en ejecutarse (para cualquier elemento en particular de` S`) tendrá su `pid` retenido.

Como un ejemplo más extenso y complejo, considere ejecutar el siguiente "kernel" en paralelo:

\end{lstlisting}



julia q[i,j,t+1] = q[i,j,t] + u[i,j,t]




\begin{lstlisting}

En este caso, si tratamos de dividir el trabajo utilizando un índice unidimensional, es probable que tengamos problemas: si `q[i,j,t]` está cerca del final del bloque asignado a un *worker* y `q [i,j,t+1]` está cerca del comienzo del bloque asignado a otro, es muy probable que `q[i,j,t]` no esté listo en el momento en que se necesita para computar `q [i,j,t+1] `. En tales casos, es mejor dividir manualmente la matriz. Vamos a dividirnos a lo largo de la segunda dimensión. Defina una función que devuelve los índices `(irange, jrange)` asignados a este *worker*:

\end{lstlisting}



julia-repl julia> @everywhere function myrange(q::SharedArray)            idx = indexpids(q)            if idx == 0 \# This worker is not assigned a piece                return 1:0, 1:0            end            nchunks = length(procs(q))            splits = [round(Int, s) for s in linspace(0,size(q,2),nchunks+1)]            1:size(q,1), splits[idx]+1:splits[idx+1]        end




\begin{lstlisting}

A continuación, se define el kernel:

\end{lstlisting}



julia-repl julia> @everywhere function advection\_chunk!(q, u, irange, jrange, trange)            @show (irange, jrange, trange)  \# display so we can see what{\textquotesingle}s happening            for t in trange, j in jrange, i in irange                q[i,j,t+1] = q[i,j,t] + u[i,j,t]            end            q        end




\begin{lstlisting}

Podemos también definir un *wrapper* de conveniencia para una implementación de `SharedArray` 

\end{lstlisting}



julia-repl julia> @everywhere advection\_shared\_chunk!(q, u) =            advection\_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)




\begin{lstlisting}

Ahora comparemos las tres versiones diferentes, una que ejecuta en un solo proceso:

\end{lstlisting}



julia-repl julia> advection\_serial!(q, u) = advection\_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);




\begin{lstlisting}

una que usa [`@parallel`](@ref):

\end{lstlisting}



julia-repl julia> function advection\_parallel!(q, u)            for t = 1:size(q,3)-1                @sync @parallel for j = 1:size(q,2)                    for i = 1:size(q,1)                        q[i,j,t+1]= q[i,j,t] + u[i,j,t]                    end                end            end            q        end;




\begin{lstlisting}

y una que delega en trozos:

\end{lstlisting}



julia-repl julia> function advection\_shared!(q, u)            @sync begin                for p in procs(q)                    @async remotecall\_wait(advection\_shared\_chunk!, p, q, u)                end            end            q        end;




\begin{lstlisting}

Si creamos un `SharedArray`s y controlamos el tiempo de estas funciones, obtendremos sl siguiente resultado (con `julia -p 4`):

\end{lstlisting}



julia-repl julia> q = SharedArray\{Float64,3\}((500,500,500));



julia> u = SharedArray\{Float64,3\}((500,500,500));




\begin{lstlisting}

Ejecutemos las funciones una vez para tenga lugar la compilación JIT y [`@time`](@ref), y pasemos después a una segunda ejecución:

\end{lstlisting}



julia-repl julia> @time advection\_serial!(q, u); (irange,jrange,trange) = (1:500,1:500,1:499)  830.220 milliseconds (216 allocations: 13820 bytes)



julia> @time advection\_parallel!(q, u);    2.495 seconds      (3999 k allocations: 289 MB, 2.09\% gc time)



julia> @time advection\_shared!(q,u);         From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)         From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)         From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)         From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)  238.119 milliseconds (2264 allocations: 169 KB)




\begin{lstlisting}

La mayor ventaja de `advection_shared!` es que minimiza el tráfico entre los *workers* permitiendo que cada uno compute para un tiempo extendido sobre la pieiza asignada.

## Arrays Compartidos y Recolección de Basura Distribuida

Al igual que las referencias remotas, las matrices compartidas también dependen de la recolección de basura en el nodo de creación para liberar referencias de todos los *workers* participantes. El código que crea muchos arrays compartidas de vida corta se beneficiaría de finalizar explícitamente estos objetos tan pronto como sea posible. Esto da como resultado que tanto la memoria como los manejadores de archivos mapeen el segmento compartido que se libera antes.

## [ClusterManagers](@id clustermanagers)

El lanzamiento, la administración y la comunicación en red de los procesos de Julia en un clúster lógico se realiza a través de los administradores del clúster. Un `ClusterManager` es responsable de

  * Lanzar procesos *worker* en un entorno clúster
  * gestión de eventos durante la vida de cada *worker*
  * opcionalmente, proporcionar transporte de datos
  
Un clúster Julia tiene las siguientes características:

  * El proceso inicial de Julia, también llamado `master`, es especial y tiene un` id` de 1.
  * Solo el proceso `master` puede agregar o eliminar procesos de trabajo.
  * Todos los procesos pueden comunicarse directamente entre ellos.

Las conexiones entre los *workers* (utilizando el transporte integrado de TCP/IP) se establecen de la siguiente manera:

  * [`addprocs()`](@ref) se invoca en el proceso maestro con un objeto `ClusterManager`.
  * [`addprocs()`](@ref) llama al método apropiado [`launch()`](@ref) que engendra el número requerido de procesos de trabajo en las máquinas apropiadas.
  * Cada *worker* comienza a escuchar en un puerto libre y escribe su información de host y puerto en [`STDOUT`](@ref).
  * El administrador del clúster captura el [`STDOUT`](@ref) de cada *worker* y lo pone a disposición del proceso maestro.
  * El proceso maestro analiza esta información y configura conexiones TCP/IP para cada *worker*.
  * Todos los *workers* también reciben notificaciones de otros trabajadores en el clúster.
  * Cada *worker* se conecta con todos los *worker* cuyo `id` es menor que su propio` id`.
  * De esta forma se establece una red de malla, en la que cada *worker* está directamente conectado con cada
    otro *worker*.
    
Aunque la capa de transporte predeterminada usa el `TCPSocket` simple, es posible que un clúster Julia proporcione su propio transporte.

Julia proporciona dos administradores de clúster integrados:

  * `LocalManager`, usado cuando se llama a [`addprocs()`](@ref) o a [`addprocs(np::Integer)`](@ref)
  * `SSHManager`, utilizado cuando se llama a [`addprocs(hostnames::Array)`](@ref con una lista de nombres de host
  
`LocalManager` se utiliza para iniciar *workers* adicionales en el mismo host, aprovechando de ese modo los núcleos múltiples
y el hardware multiprocesador.

Por lo tanto, un administrador de clúster mínimo necesitaría:

  * ser un subtipo del resumen `ClusterManager`
  * implementar [`launch()`](@ref), un método responsable del lanzamiento de nuevos *workers*
  * implementar [`manage()`](@ref), que se invoca en varios eventos durante la vida de un *worker* (por ejemplo, enviando una señal de interrupción)

[`addprocs(manager::FooManager)`](@ref addprocs) requiere `FooManager` para implementar:

\end{lstlisting}



julia function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)     [...] end



function manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)     [...] end




\begin{lstlisting}

Como ejemplo, veamos cómo se implementa el `LocalManager`, el administrador responsable de iniciar los *workers* en el mismo host:

\end{lstlisting}



julia struct LocalManager <: ClusterManager     np::Integer end



function launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)     [...] end



function manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)     [...] end




\begin{lstlisting}

El método [`launch()`](@ref) toma los siguientes argumentos:

  * `manager::ClusterManager`: el administrador de clúster al que se llama con [`addprocs()`](@ref)
  * `params::Dict`: todos los argumentos palabra clave pasados ​​a [`addprocs()`](@ref)
  * `launched::Array`: el array al que agregar uno o más objetos `WorkerConfig`
  * `c::Condition`:la variable de condición que se notificará cuando se inicien los trabajadores

El método [`launch()`](@ref) se llama asincrónicamente en una tarea separada. La finalización de esta tarea indica que se han lanzado todos los *workers* solicitados. Por lo tanto, la función [`launch()`](@ref) DEBE salir tan pronto como se hayan lanzado todos los *workers* solicitados.

Los trabajadores recién lanzados están conectados entre sí y el proceso maestro de una manera integral. Al especificar el argumento de la línea de comando `--worker <cookie>` los procesos iniciados se inicializan a sí mismos como trabajadores y las conexiones se configuran a través de sockets TCP / IP. Optionally, `--bind-to bind_addr[:port]` may also be specified to enable other workers to connect to it at the specified `bind_addr` and `port`. Esto es útil para hosts multi-homed.

Como ejemplo de transporte no TCP / IP, una implementación puede optar por utilizar MPI, en cuyo caso `-worker` NO se debe especificar. En cambio, los trabajadores recién lanzados deberían llamar `init_worker (cookie)` antes de usar cualquiera de las construcciones paralelas.

Para cada trabajador puesto en marcha, el método [`launch ()`] (@ref) debe agregar un objeto `WorkerConfig` (con los campos apropiados inicializados) al `launched`

\end{lstlisting}



julia mutable struct WorkerConfig     \# Common fields relevant to all cluster managers     io::Nullable\{IO\}     host::Nullable\{AbstractString\}     port::Nullable\{Integer\}




\begin{lstlisting}
# Used when launching additional workers at a host
count::Nullable{Union{Int, Symbol}}
exename::Nullable{AbstractString}
exeflags::Nullable{Cmd}

# External cluster managers can use this to store information at a per-worker level
# Can be a dict if multiple fields need to be stored.
userdata::Nullable{Any}

# SSHManager / SSH tunnel connections to workers
tunnel::Nullable{Bool}
bind_addr::Nullable{AbstractString}
sshflags::Nullable{Cmd}
max_parallel::Nullable{Integer}

connect_at::Nullable{Any}

[...]
\end{lstlisting}



end




\begin{lstlisting}

La mayoría de los campos en `WorkerConfig` son utilizados por los administradores incorporados. Gestores de cluster personalizados normalmente especificarían solo `io` o` host` / `port`:

   * Si se especifica `io`, se usa para leer información de host / puerto. Un *worker* Julia imprime su dirección y puerto de enlace al inicio. Esto permite a los *workers* Julia escuchar en cualquier puerto libre disponible en lugar de requerir que los puertos de los trabajadores se configuren manualmente.
   * Si `io` no está especificado,` host` y `port` se utilizan para conectarse.
   * `count`,` exename` y `exeflags` son relevantes para el lanzamiento de trabajadores adicionales de un trabajador. Por ejemplo, un administrador de clúster puede iniciar un solo trabajador por nodo y usarlo para iniciar trabajadores adicionales.

      * `count` con un valor entero` n` lanzará un total de `n` *workers*.
      * `count` con un valor de`: auto` lanzará tantos trabajadores como la cantidad de núcleos en esa máquina.
      * `exename` es el nombre del ejecutable` julia` que incluye la ruta completa.
      * `exeflags` debe establecerse en los argumentos de línea de comando necesarios para los nuevos *workers*.
   * `tunnel`,` bind_addr`, `sshflags` y` max_parallel` se usan cuando se requiere un túnel ssh para conectarse con los *workers* del proceso maestro.
   * `userdata` se proporciona para que los administradores de clúster personalizados almacenen su propia información específica del *worker*.

`manage (manager :: FooManager, id :: Integer, config :: WorkerConfig, op :: Symbol)` se llama en diferentes momentos durante la vida del trabajador con valores `op` apropiados:

   * con `: register` /`: deregister` cuando un trabajador se agrega / elimina del grupo de *workers* de Julia.
   * con `: interrupt` cuando se invoca `interrupt(workers)`. El `ClusterManager` debe señalar al *worker* apropiado con una señal de interrupción.
   * con `: finalize` para fines de limpieza.

## Administradores de Clúster con Transportes Personalizados

Reemplazar las conexiones por defecto de socket TCP/IP con una capa de transporte personalizada es un poco más complicado. Cada proceso de Julia tiene tantas tareas de comunicación como los *workers* a los que está conectado. Por ejemplo, considere un clúster de Julia de 32 procesos en una red de malla todos contra todos:

  * Cada proceso de Julia tiene 31 tareas de comunicación.
  * Cada tarea maneja todos los mensajes entrantes desde un solo *worker* remoto en un bucle de procesamiento de mensajes.
  * El bucle de procesamiento de mensajes espera en un objeto `IO` (por ejemplo, un` TCPSocket` en la implementación predeterminada), lee un mensaje completo, lo procesa y espera el siguiente.
  * El envío de mensajes a un proceso se realiza directamente desde cualquier tarea Julia, no solo tareas de comunicación, nuevamente, a través del objeto `IO` apropiado.

Reemplazar el transporte predeterminado requiere que la nueva implementación establezca conexiones con *workers* remotos y que proporcione los objetos `IO` apropiados para que los lazos de procesamiento de mensajes puedan esperar. Las devoluciones de llamada específicas del administrador que se implementarán son:

\end{lstlisting}



julia connect(manager::FooManager, pid::Integer, config::WorkerConfig) kill(manager::FooManager, pid::Int, config::WorkerConfig)




\begin{lstlisting}

La implementación por defecto (que usa sockets TCP/IP) se implementa como `connect (manager::ClusterManager, pid::Integer, config::WorkerConfig)`.

`connect` debería devolver un par de objetos` IO`, uno para leer los datos enviados por el `pid` del *worker*, y el otro para escribir datos que deben ser enviados al `pid` del *worker*. Los administradores de clústeres personalizados pueden usar un `BufferStream` en memoria como la conexión de datos proxy entre el *worker* personalizado, posiblemente transporte no-`IO`y la infraestructura paralela incorporada de Julia.

Un `BufferStream` es un `IOBuffer` en memoria que se comporta como un `IO` - es un flujo que puede manejarse de forma asíncrona.

La carpeta `examples/clustermanager/0MQ` contiene un ejemplo del uso de ZeroMQ para conectar *workers* Julia en una topología en estrella con un intermediario 0MQ en el medio. Nota: Los procesos de Julia todavía están todos *lógicamente* conectados entre sí: cualquier trabajador puede enviar mensajes a cualquier otro trabajador directamente sin que se tenga conocimiento de que se está usando 0MQ como capa de transporte.

Al usar transportes personalizados:

   * Los *workers* de Julia NO deben comenzar con `-worker`. Comenzar con `--worker` dará como resultado que los trabajadores recién lanzados adopten de forma predeterminada la implementación de transporte de socket TCP/IP.
  * Para cada conexión lógica entrante con un *worker*, se deben llamar `Base.process_messages(rd::IO, wr::IO)()`. Esto inicia una nueva tarea que maneja la lectura y escritura de mensajes desde / hacia el trabajador representado por los objetos `IO`.
  * `init_worker(cookie, manager::FooManager)` DEBE invocarse como parte de la inicialización del proceso de trabajo.
  * El campo `connect_at::Any` en `WorkerConfig` puede ser configurado por el administrador del clúster cuando se invoca [`launch()`](@ref). El valor de este campo se transfiere en todas las devoluciones de llamada [`connect()`](@ref). Por lo general, transmite información sobre *cómo conectarse* a un *worker*. Por ejemplo, el transporte de socket TCP/IP utiliza este campo para especificar la tupla `(host, port)` en la que se conecta a un *worker*.

`kill (manager, pid, config)` se llama para eliminar un *worker* del clúster. En el proceso maestro, los objetos `IO` correspondientes deben ser cerrados por la implementación para garantizar una limpieza adecuada. La implementación predeterminada simplemente ejecuta una llamada `exit()` en el *worker* remoto especificado.

`examples/clustermanager/simple` es un ejemplo que muestra una implementación simple usando el dominio UNIX
enchufes para la configuración del clúster.

## Requisitos de Red para LocalManager y SSHManager

Los clústeres de Julia están diseñados para ejecutarse en entornos ya protegidos en infraestructura, como laptops locales, clusters departamentales o incluso en la nube. Esta sección cubre los requisitos de seguridad de red para los `LocalManager` y `SSHManager` incorporados:

  * El proceso maestro no escucha en ningún puerto. Solo se conecta con los *workers*.
  * Each worker binds to only one of the local interfaces and listens on the first free port starting from `9009`.
  * `LocalManager`, usado por `addprocs(N)`, por defecto se une solo a la interfaz *loopback*. Esto significa que los trabajadores que comenzaron más adelante en los hosts remotos (o por cualquier persona con intenciones maliciosas) no pueden conectarse al clúster. Un `addprocs(4)` seguido de un `addprocs(["remote_host"])` fallará. Algunos usuarios pueden necesitar crear un clúster que comprenda su sistema local y algunos sistemas remotos.     Esto se puede hacer solicitando explícitamente que `LocalManager` se vincule a una interfaz de red externa mediante el argumento de la palabra clave` restrict`: `addprocs (4; restrict = false)`.
  * `SSHManager`, utilizado por` addprocs (list_of_remote_hosts) `, inicia trabajadores en hosts remotos a través de SSH.
    Por defecto, SSH solo se usa para iniciar los trabajadores de Julia. Las conexiones subsiguientes de maestro-trabajador y trabajador-trabajador usan conectores TCP / IP sin cifrar. Los hosts remotos deben tener habilitado el inicio de sesión sin contraseña. Se pueden especificar indicadores o credenciales SSH adicionales a través del argumento de palabra clave `sshflags`.
  * `addprocs (list_of_remote_hosts; tunnel = true, sshflags = <ssh keys y otros flags>)` es útil cuando deseamos usar conexiones SSH para el maestro trabajador también. Un escenario típico para esto es una computadora portátil local que ejecuta el REPL de Julia (es decir, el maestro) con el resto del clúster en la nube, por ejemplo en Amazon EC2. En este caso, solo se debe abrir el puerto 22 en el clúster remoto junto con el cliente SSH autenticado a través de la infraestructura de clave pública (PKI). Las credenciales de autenticación se pueden suministrar a través de `sshflags`, por ejemplo ```sshflags =`-e <keyfile>` ```.

Note that worker-worker connections are still plain TCP and the local security policy on the remote cluster must allow for free connections between worker nodes, at least for ports 9009 and above.

    Asegurar y encriptar todo el tráfico de trabajador-trabajador (a través de SSH) o encriptar mensajes individuales se puede hacer a través de un ClusterManager personalizado.
    
## Cluster Cookie

Todos los procesos en un clúster comparten la misma cookie que, de forma predeterminada, es una cadena generada aleatoriamente en el proceso maestro:

  * [`Base.cluster_cookie()`](@ref) devuelve la cookie, mientras `Base.cluster_cookie(cookie)()` lo configura y devuelve la nueva cookie.
  * Todas las conexiones están autenticadas en ambos lados para garantizar que solo los *workers* iniciados por el maestro puedan conectarse entre sí.
  * The cookie must be passed to the workers at startup via argument `--worker <cookie>`. Custom ClusterManagers can retrieve the cookie on the master by calling [`Base.cluster_cookie()`](@ref). Cluster managers not using the default TCP/IP transport (and hence not specifying `--worker`) must call `init_worker(cookie, manager)` with the same cookie as on the master.

Tenga en cuenta que los entornos que requieren mayores niveles de seguridad pueden implementar esto a través de un `ClusterManager` personalizado. Por ejemplo, las cookies se pueden compartir previamente y, por lo tanto, no se especifican como un argumento de inicio.

## Specifying Network Topology (Experimental)

El argumento de palabra clave `topología` pasado a `addprocs` se usa para especificar cómo los trabajadores deben estar conectados entre sí:

  * `: all_to_all`, el valor predeterminado: todos los trabajadores están conectados entre sí.
  * `: master_slave`: solo el proceso del controlador, es decir,` pid` 1, tiene conexiones con los trabajadores.
  * `: custom`: el método` launch` del administrador del clúster especifica la topología de conexión a través del
    campos `ident` y` connect_idents` en `WorkerConfig`. Un trabajador con un cluster-manager-provided
    identidad `ident` se conectará a todos los trabajadores especificados en `connect_idents`.

Actualmente, enviar un mensaje entre *workers* desconectados genera un error. Este comportamiento, al igual que la funcionalidad y la interfaz, debe considerarse de naturaleza experimental y puede cambiar en versiones futuras.


## Multi-Threading (Experimental)

Además de las tareas, llamadas remotas y referencias remotas, Julia desde la `v0.5` hacia delante admitirá de forma nativa soporte para multi-hilo. Tenga en cuenta que esta sección es experimental y las interfaces pueden cambiar en el futuro.

### Setup

Por defecto, Julia se inicia con un único hilo de ejecución. Esto se puede verificar utilizando el mandato [`Threads.nthreads ()`](@ref):

\end{lstlisting}



julia-repl julia> Threads.nthreads() 1




\begin{lstlisting}

El número de hilos con los que arranca Julia está controlado por una variable de entorno llamada `JULIA_NUM_THREADS`. Ahora, comencemos Julia con 4 hilos:

\end{lstlisting}



bash export JULIA\_NUM\_THREADS=4




\begin{lstlisting}

(El mandato anterior funciona en shells de Bourne shells de Linux y OSX. Tenga en cuenta que si usa un C shell en estas plataformas, debe usar la palabra clave `set` en lugar de` export`. Si está en Windows, inicie la línea de órdenes en la ubicación de `julia.exe` y use `set` en lugar de `export`.)

Verifiquemos que hay 4 hilos a nuestra disposición.

\end{lstlisting}



julia-repl julia> Threads.nthreads() 4




\begin{lstlisting}

Pero actualmente estamos en el hilo maestro. Para verificar, usamos el mandato [`Threads.threadid()`](@ref)

\end{lstlisting}



julia-repl julia> Threads.threadid() 1




\begin{lstlisting}

### La Macro `@threads` 

Vamos a trabajar un ejemplo simple usando nuestros hilos nativos. Creemos un array de ceros:

\end{lstlisting}



jldoctest julia> a = zeros(10) 10-element Array\{Float64,1\}:  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0




\begin{lstlisting}

Operemos sobre este array de forma simultánea utilizando 4 hilos. Haremos que cada hilo escriba su ID de hilo en cada ubicación.

Julia soporta bucles paralelos utilizando la macro [`Threads.@Threads`](@ref). Esta macro está fijada delante de un bucle `for` para indicar a Julia que el bucle es una región con múltiples subprocesos:

\end{lstlisting}



julia-repl julia> Threads.@threads for i = 1:10            a[i] = Threads.threadid()        end




\begin{lstlisting}

El espacio de iteración se divide entre los hilos, después de lo cual cada hilo escribe su ID de hilo a sus ubicaciones asignadas:

\end{lstlisting}



julia-repl julia> a 10-element Array\{Float64,1\}:  1.0  1.0  1.0  2.0  2.0  2.0  3.0  3.0  4.0  4.0 ```



Tenga en cuenta que \hyperlink{15582842999596899869}{\texttt{Threads.@threads}} no tiene un parámetro de reducción opcional como \hyperlink{11870389661093259741}{\texttt{@parallel}}.



\hypertarget{4888104675376389648}{}


\section{@threadcall (Experimental)}



Todas las tareas de E/S, temporizadores, comandos REPL, etc. se multiplexan en una sola cadena del sistema operativo mediante un bucle de eventos. Una versión parcheada de libuv (\href{http://docs.libuv.org/en/v1.x/}{http://docs.libuv.org/en/v1.x/}] proporciona esta funcionalidad. Los puntos de rendimiento proporcionan la planificación cooperativa de tareas múltiples en el mismo hilo del sistema operativo. Las tareas de E/S y los temporizadores se producen implícitamente mientras se espera que ocurra el evento. Llamar a \hyperlink{13455314829114364187}{\texttt{yield()}} explícitamente permite planificar otras tareas.



Por lo tanto, una tarea que ejecuta un \hyperlink{14245046751182637566}{\texttt{ccall}} evita efectivamente que el planificador Julia ejecute otras tareas hasta que la llamada regrese. Esto es cierto para todas las llamadas a bibliotecas externas. Las excepciones son llamadas al código C personalizado que devuelve la llamada a Julia (que luego puede ceder) o al código C que llama a \texttt{jl\_yield()} (C equivalente a \hyperlink{13455314829114364187}{\texttt{yield()}}).



Note that while Julia code runs on a single thread (by default), libraries used by Julia may launch their own internal threads. For example, the BLAS library may start as many threads as there are cores on a machine.



La macro \texttt{@ threadcall} trata los escenarios donde no queremos que un \texttt{ccall} bloquee el ciclo principal de eventos de Julia. Planifica una función C para su ejecución en un hilo separado. Para esto, se usa un pool de hilos con un tamaño predeterminado de 4. El tamaño del pool de hilos se controla mediante la variable de entorno \texttt{UV\_THREADPOOL\_SIZE}. Mientras espera un hilo libre, y durante la ejecución de la función una vez que un hilo está disponible, la tarea solicitante (en el ciclo de eventos principal de Julia) cede a otras tareas. Tenga en cuenta que \texttt{@threadcall} no regresa hasta que se completa la ejecución. Desde el punto de vista del usuario, es por lo tanto una llamada de bloqueo como otras API de Julia.



Es muy importante que la función llamada no vuelva a llamar a Julia.



\texttt{@threadcall} puede ser eliminada / cambiada en futuras versiones de Julia.



\footnotetext[1]{In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding RMA to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see \href{http://mpi-forum.org/docs/}{http://mpi-forum.org/docs}.

}


\hypertarget{14708268282391318496}{}


\chapter{Date and DateTime}





The \texttt{Dates} module provides two types for working with dates: \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}}, representing day and millisecond precision, respectively; both are subtypes of the abstract \hyperlink{10402032810188745271}{\texttt{TimeType}}. The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don{\textquotesingle}t have to be dealt with. For example, since the \hyperlink{5911165232663997394}{\texttt{Date}} type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.



Both \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} are basically immutable \hyperlink{7720564657383125058}{\texttt{Int64}} wrappers. The single \texttt{instant} field of either type is actually a \texttt{UTInstant\{P\}} type, which represents a continuously increasing machine timeline based on the UT second \footnotemark[1]. The \hyperlink{8865912400344885633}{\texttt{DateTime}} type is not aware of time zones (\emph{naive}, in Python parlance), analogous to a \emph{LocalDateTime} in Java 8. Additional time zone functionality can be added through the \href{https://github.com/JuliaTime/TimeZones.jl/}{TimeZones.jl package}, which compiles the \href{http://www.iana.org/time-zones}{IANA time zone database}. Both \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} are based on the \href{https://en.wikipedia.org/wiki/ISO\_8601}{ISO 8601} standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so \texttt{0000-12-31} is the day before \texttt{0001-01-01}, and year \texttt{-0001} (yes, negative one for the year) is 2 BC/BCE, year \texttt{-0002} is 3 BC/BCE, etc.



\footnotetext[1]{The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a {\textquotedbl}UT second{\textquotedbl}, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called \href{https://en.wikipedia.org/wiki/Universal\_Time}{UT} or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.

}


\hypertarget{3597362352537600414}{}


\section{Constructors}



\hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} types can be constructed by integer or \hyperlink{14377501606406826094}{\texttt{Period}} types, by parsing, or through adjusters (more on those later):




\begin{minted}{jlcon}
julia> DateTime(2013)
2013-01-01T00:00:00

julia> DateTime(2013,7)
2013-07-01T00:00:00

julia> DateTime(2013,7,1)
2013-07-01T00:00:00

julia> DateTime(2013,7,1,12)
2013-07-01T12:00:00

julia> DateTime(2013,7,1,12,30)
2013-07-01T12:30:00

julia> DateTime(2013,7,1,12,30,59)
2013-07-01T12:30:59

julia> DateTime(2013,7,1,12,30,59,1)
2013-07-01T12:30:59.001

julia> Date(2013)
2013-01-01

julia> Date(2013,7)
2013-07-01

julia> Date(2013,7,1)
2013-07-01

julia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))
2013-07-01

julia> Date(Dates.Month(7),Dates.Year(2013))
2013-07-01
\end{minted}



\hyperlink{5911165232663997394}{\texttt{Date}} or \hyperlink{8865912400344885633}{\texttt{DateTime}} parsing is accomplished by the use of format strings. Format strings work by the notion of defining \emph{delimited} or \emph{fixed-width} {\textquotedbl}slots{\textquotedbl} that contain a period to parse and passing the text to parse and format string to a \hyperlink{5911165232663997394}{\texttt{Date}} or \hyperlink{8865912400344885633}{\texttt{DateTime}} constructor, of the form \texttt{Date({\textquotedbl}2015-01-01{\textquotedbl},{\textquotedbl}y-m-d{\textquotedbl})} or \texttt{DateTime({\textquotedbl}20150101{\textquotedbl},{\textquotedbl}yyyymmdd{\textquotedbl})}.



Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so \texttt{{\textquotedbl}y-m-d{\textquotedbl}} lets the parser know that between the first and second slots in a date string like \texttt{{\textquotedbl}2014-07-16{\textquotedbl}}, it should find the \texttt{-} character. The \texttt{y}, \texttt{m}, and \texttt{d} characters let the parser know which periods to parse in each slot.



Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So \texttt{{\textquotedbl}yyyymmdd{\textquotedbl}} would correspond to a date string like \texttt{{\textquotedbl}20140716{\textquotedbl}}. The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition \texttt{{\textquotedbl}yyyymm{\textquotedbl}} from one period character to the next.



Support for text-form month parsing is also supported through the \texttt{u} and \texttt{U} characters, for abbreviated and full-length month names, respectively. By default, only English month names are supported, so \texttt{u} corresponds to {\textquotedbl}Jan{\textquotedbl}, {\textquotedbl}Feb{\textquotedbl}, {\textquotedbl}Mar{\textquotedbl}, etc. And \texttt{U} corresponds to {\textquotedbl}January{\textquotedbl}, {\textquotedbl}February{\textquotedbl}, {\textquotedbl}March{\textquotedbl}, etc. Similar to other name=>value mapping functions \hyperlink{3340143850480916413}{\texttt{dayname()}} and \hyperlink{12803026364514696452}{\texttt{monthname()}}, custom locales can be loaded by passing in the \texttt{locale=>Dict\{String,Int\}} mapping to the \texttt{MONTHTOVALUEABBR} and \texttt{MONTHTOVALUE} dicts for abbreviated and full-name month names, respectively.



One note on parsing performance: using the \texttt{Date(date\_string,format\_string)} function is fine if only called a few times. If there are many similarly formatted date strings to parse however, it is much more efficient to first create a \hyperlink{18366440545577280750}{\texttt{Dates.DateFormat}}, and pass it instead of a raw format string.




\begin{minted}{jlcon}
julia> df = DateFormat("y-m-d");

julia> dt = Date("2015-01-01",df)
2015-01-01

julia> dt2 = Date("2015-01-02",df)
2015-01-02
\end{minted}



You can also use the \texttt{dateformat{\textquotedbl}{\textquotedbl}} string macro. This macro creates the \texttt{DateFormat} object once when the macro is expanded and uses the same \texttt{DateFormat} object even if a code snippet is run multiple times.




\begin{minted}{jlcon}
julia> for i = 1:10^5
           Date("2015-01-01", dateformat"y-m-d")
       end
\end{minted}



A full suite of parsing and formatting tests and examples is available in \href{https://github.com/JuliaLang/julia/blob/release-0.6/test/dates/io.jl}{\texttt{tests/dates/io.jl}}.



\hypertarget{9675062304126123157}{}


\section{Durations/Comparisons}



Finding the length of time between two \hyperlink{5911165232663997394}{\texttt{Date}} or \hyperlink{8865912400344885633}{\texttt{DateTime}} is straightforward given their underlying representation as \texttt{UTInstant\{Day\}} and \texttt{UTInstant\{Millisecond\}}, respectively. The difference between \hyperlink{5911165232663997394}{\texttt{Date}} is returned in the number of \hyperlink{5199769942291019025}{\texttt{Day}}, and \hyperlink{8865912400344885633}{\texttt{DateTime}} in the number of \hyperlink{2512115765177421351}{\texttt{Millisecond}}. Similarly, comparing \hyperlink{10402032810188745271}{\texttt{TimeType}} is a simple matter of comparing the underlying machine instants (which in turn compares the internal \hyperlink{7720564657383125058}{\texttt{Int64}} values).




\begin{minted}{jlcon}
julia> dt = Date(2012,2,29)
2012-02-29

julia> dt2 = Date(2000,2,1)
2000-02-01

julia> dump(dt)
Date
  instant: Base.Dates.UTInstant{Base.Dates.Day}
    periods: Base.Dates.Day
      value: Int64 734562

julia> dump(dt2)
Date
  instant: Base.Dates.UTInstant{Base.Dates.Day}
    periods: Base.Dates.Day
      value: Int64 730151

julia> dt > dt2
true

julia> dt != dt2
true

julia> dt + dt2
ERROR: MethodError: no method matching +(::Date, ::Date)
[...]

julia> dt * dt2
ERROR: MethodError: no method matching *(::Date, ::Date)
[...]

julia> dt / dt2
ERROR: MethodError: no method matching /(::Date, ::Date)
[...]

julia> dt - dt2
4411 days

julia> dt2 - dt
-4411 days

julia> dt = DateTime(2012,2,29)
2012-02-29T00:00:00

julia> dt2 = DateTime(2000,2,1)
2000-02-01T00:00:00

julia> dt - dt2
381110400000 milliseconds
\end{minted}



\hypertarget{15274886386548419130}{}


\section{Accessor Functions}



Because the \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} types are stored as single \hyperlink{7720564657383125058}{\texttt{Int64}} values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:




\begin{lstlisting}
julia> t = Date(2014, 1, 31)
2014-01-31

julia> Dates.year(t)
2014

julia> Dates.month(t)
1

julia> Dates.week(t)
5

julia> Dates.day(t)
31
\end{lstlisting}



While propercase return the same value in the corresponding \hyperlink{14377501606406826094}{\texttt{Period}} type:




\begin{lstlisting}
julia> Dates.Year(t)
2014 years

julia> Dates.Day(t)
31 days
\end{lstlisting}



Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:




\begin{lstlisting}
julia> Dates.yearmonth(t)
(2014, 1)

julia> Dates.monthday(t)
(1, 31)

julia> Dates.yearmonthday(t)
(2014, 1, 31)
\end{lstlisting}



One may also access the underlying \texttt{UTInstant} or integer value:




\begin{lstlisting}
julia> dump(t)
Date
  instant: Base.Dates.UTInstant{Base.Dates.Day}
    periods: Base.Dates.Day
      value: Int64 735264

julia> t.instant
Base.Dates.UTInstant{Base.Dates.Day}(735264 days)

julia> Dates.value(t)
735264
\end{lstlisting}



\hypertarget{16158364891045757229}{}


\section{Query Functions}



Query functions provide calendrical information about a \hyperlink{10402032810188745271}{\texttt{TimeType}}. They include information about the day of the week:




\begin{lstlisting}
julia> t = Date(2014, 1, 31)
2014-01-31

julia> Dates.dayofweek(t)
5

julia> Dates.dayname(t)
"Friday"

julia> Dates.dayofweekofmonth(t) # 5th Friday of January
5
\end{lstlisting}



Month of the year:




\begin{lstlisting}
julia> Dates.monthname(t)
"January"

julia> Dates.daysinmonth(t)
31
\end{lstlisting}



As well as information about the \hyperlink{10402032810188745271}{\texttt{TimeType}}{\textquotesingle}s year and quarter:




\begin{lstlisting}
julia> Dates.isleapyear(t)
false

julia> Dates.dayofyear(t)
31

julia> Dates.quarterofyear(t)
1

julia> Dates.dayofquarter(t)
31
\end{lstlisting}



The \hyperlink{3340143850480916413}{\texttt{dayname()}} and \hyperlink{12803026364514696452}{\texttt{monthname()}} methods can also take an optional \texttt{locale} keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely \hyperlink{2563884892429498349}{\texttt{dayabbr()}} and \hyperlink{1979988737860589713}{\texttt{monthabbr()}}. First the mapping is loaded into the \texttt{LOCALES} variable:




\begin{lstlisting}
julia> french_months = ["janvier", "février", "mars", "avril", "mai", "juin",
                        "juillet", "août", "septembre", "octobre", "novembre", "décembre"];

julia> french_monts_abbrev = ["janv","févr","mars","avril","mai","juin",
                              "juil","août","sept","oct","nov","déc"];

julia> french_days = ["lundi","mardi","mercredi","jeudi","vendredi","samedi","dimanche"];

julia> Dates.LOCALES["french"] = Dates.DateLocale(french_months, french_monts_abbrev, french_days, [""]);
\end{lstlisting}



The above mentioned functions can then be used to perform the queries:




\begin{lstlisting}
julia> Dates.dayname(t;locale="french")
"vendredi"

julia> Dates.monthname(t;locale="french")
"janvier"

julia> Dates.monthabbr(t;locale="french")
"janv"
\end{lstlisting}



Since the abbreviated versions of the days are not loaded, trying to use the function \texttt{dayabbr()} will error.




\begin{lstlisting}
julia> Dates.dayabbr(t;locale="french")
ERROR: BoundsError: attempt to access 1-element Array{String,1} at index [5]
Stacktrace:
 [1] #dayabbr#6(::String, ::Function, ::Int64) at ./dates/query.jl:114
 [2] (::Base.Dates.#kw##dayabbr)(::Array{Any,1}, ::Base.Dates.#dayabbr, ::Int64) at ./<missing>:0 (repeats 2 times)
\end{lstlisting}



\hypertarget{10010400361329749456}{}


\section{TimeType-Period Arithmetic}



It{\textquotesingle}s good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some \href{https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/}{tricky issues} to deal with (though much less so for day-precision types).



The \texttt{Dates} module approach tries to follow the simple principle of trying to change as little as possible when doing \hyperlink{14377501606406826094}{\texttt{Period}} arithmetic. This approach is also often known as \emph{calendrical} arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let{\textquotesingle}s take a classic example: add 1 month to January 31st, 2014. What{\textquotesingle}s the answer? Javascript will say \href{http://www.markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/}{March 3} (assumes 31 days). PHP says \href{http://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month}{March 2} (assumes 30 days). The fact is, there is no right answer. In the \texttt{Dates} module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.



Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead and add another month to our date, \texttt{2014-02-28 + Month(1) == 2014-03-28}. What? Were you expecting the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so we first increment the month slot by 1, 2014-03-28, and boom, we{\textquotesingle}re done because that{\textquotesingle}s a valid date. On the other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced (i.e. adding things in different orders results in different outcomes). For example:




\begin{minted}{jlcon}
julia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)
2014-02-28

julia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)
2014-03-01
\end{minted}



What{\textquotesingle}s going on there? In the first line, we{\textquotesingle}re adding 1 day to January 29th, which results in 2014-01-30; then we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28. In the second example, we add 1 month \emph{first}, where we get 2014-02-29, which adjusts down to 2014-02-28, and \emph{then} add 1 day, which results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods, the operations will be ordered by the Periods{\textquotesingle} \emph{types}, not their value or positional order; this means \texttt{Year} will always be added first, then \texttt{Month}, then \texttt{Week}, etc. Hence the following \emph{does} result in associativity and Just Works:




\begin{minted}{jlcon}
julia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)
2014-03-01

julia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)
2014-03-01
\end{minted}



Tricky? Perhaps. What is an innocent \texttt{Dates} user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that{\textquotesingle}s pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the {\textquotedbl}joys{\textquotedbl} of dealing with daylight savings, leap seconds, etc.).



As a bonus, all period arithmetic objects work directly with ranges:




\begin{minted}{jlcon}
julia> dr = Date(2014,1,29):Date(2014,2,3)
2014-01-29:1 day:2014-02-03

julia> collect(dr)
6-element Array{Date,1}:
 2014-01-29
 2014-01-30
 2014-01-31
 2014-02-01
 2014-02-02
 2014-02-03

julia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)
2014-01-29:1 month:2014-07-29

julia> collect(dr)
7-element Array{Date,1}:
 2014-01-29
 2014-02-28
 2014-03-29
 2014-04-29
 2014-05-29
 2014-06-29
 2014-07-29
\end{minted}



\hypertarget{13551592780469201884}{}


\section{Adjuster Functions}



As convenient as date-period arithmetics are, often the kinds of calculations needed on dates take on a \emph{calendrical} or \emph{temporal} nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as {\textquotedbl}Memorial Day = Last Monday of May{\textquotedbl}, or {\textquotedbl}Thanksgiving = 4th Thursday of November{\textquotedbl}. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.



The \texttt{Dates} module provides the \emph{adjuster} API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single \hyperlink{10402032810188745271}{\texttt{TimeType}} as input and return or \emph{adjust to} the first or last of the desired period relative to the input.




\begin{minted}{jlcon}
julia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input's week
2014-07-14

julia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input's month
2014-07-31

julia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input's quarter
2014-09-30
\end{minted}



The next two higher-order methods, \hyperlink{17409471999654347609}{\texttt{tonext()}}, and \hyperlink{7599972091906648015}{\texttt{toprev()}}, generalize working with temporal expressions by taking a \texttt{DateFunction} as first argument, along with a starting \hyperlink{10402032810188745271}{\texttt{TimeType}}. A \texttt{DateFunction} is just a function, usually anonymous, that takes a single \hyperlink{10402032810188745271}{\texttt{TimeType}} as input and returns a \hyperlink{46725311238864537}{\texttt{Bool}}, \texttt{true} indicating a satisfied adjustment criterion. For example:




\begin{minted}{jlcon}
julia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday # Returns true if the day of the week of x is Tuesday
(::#1) (generic function with 1 method)

julia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 is a Sunday
2014-07-15

julia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # Convenience method provided for day of the week adjustments
2014-07-15
\end{minted}



This is useful with the do-block syntax for more complex temporal expressions:




\begin{minted}{jlcon}
julia> Dates.tonext(Date(2014,7,13)) do x
           # Return true on the 4th Thursday of November (Thanksgiving)
           Dates.dayofweek(x) == Dates.Thursday &&
           Dates.dayofweekofmonth(x) == 4 &&
           Dates.month(x) == Dates.November
       end
2014-11-27
\end{minted}



The \hyperlink{11445961893478569145}{\texttt{Base.filter()}} method can be used to obtain all valid dates/moments in a specified range:




\begin{minted}{jlcon}
# Pittsburgh street cleaning; Every 2nd Tuesday from April to November
# Date range from January 1st, 2014 to January 1st, 2015
julia> dr = Dates.Date(2014):Dates.Date(2015);

julia> filter(dr) do x
           Dates.dayofweek(x) == Dates.Tue &&
           Dates.April <= Dates.month(x) <= Dates.Nov &&
           Dates.dayofweekofmonth(x) == 2
       end
8-element Array{Date,1}:
 2014-04-08
 2014-05-13
 2014-06-10
 2014-07-08
 2014-08-12
 2014-09-09
 2014-10-14
 2014-11-11
\end{minted}



Additional examples and tests are available in \href{https://github.com/JuliaLang/julia/blob/release-0.6/test/dates/adjusters.jl}{\texttt{test/dates/adjusters.jl}}.



\hypertarget{6665623146623573170}{}


\section{Period Types}



Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context. Or a year could represent 365 or 366 days in the case of a leap year. \hyperlink{14377501606406826094}{\texttt{Period}} types are simple \hyperlink{7720564657383125058}{\texttt{Int64}} wrappers and are constructed by wrapping any \texttt{Int64} convertible type, i.e. \texttt{Year(1)} or \texttt{Month(3.0)}. Arithmetic between \hyperlink{14377501606406826094}{\texttt{Period}} of the same type behave like integers, and limited \texttt{Period-Real} arithmetic is available.




\begin{minted}{jlcon}
julia> y1 = Dates.Year(1)
1 year

julia> y2 = Dates.Year(2)
2 years

julia> y3 = Dates.Year(10)
10 years

julia> y1 + y2
3 years

julia> div(y3,y2)
5

julia> y3 - y2
8 years

julia> y3 % y2
0 years

julia> div(y3,3) # mirrors integer division
3 years
\end{minted}



\hypertarget{12464510960418657842}{}


\section{Rounding}



\hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} values can be rounded to a specified resolution (e.g., 1 month or 15 minutes) with \hyperlink{13948277906659863497}{\texttt{floor()}}, \hyperlink{11509984064218511874}{\texttt{ceil()}}, or \hyperlink{7894166454005036294}{\texttt{round()}}:




\begin{minted}{jlcon}
julia> floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia> round(DateTime(2016, 8, 6, 20, 15), Dates.Day)
2016-08-07T00:00:00
\end{minted}



Unlike the numeric \hyperlink{7894166454005036294}{\texttt{round()}} method, which breaks ties toward the even number by default, the \hyperlink{10402032810188745271}{\texttt{TimeType}}\hyperlink{7894166454005036294}{\texttt{round()}} method uses the \texttt{RoundNearestTiesUp} rounding mode. (It{\textquotesingle}s difficult to guess what breaking ties to nearest {\textquotedbl}even{\textquotedbl} \hyperlink{10402032810188745271}{\texttt{TimeType}} would entail.) Further details on the available \texttt{RoundingMode} s can be found in the \hyperlink{11995623453970199783}{API reference}.



Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is not obvious.



\hypertarget{18235125897086797691}{}


\subsection{Rounding Epoch}



In many cases, the resolution specified for rounding (e.g., \texttt{Dates.Second(30)}) divides evenly into the next largest period (in this case, \texttt{Dates.Minute(1)}). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a \hyperlink{8865912400344885633}{\texttt{DateTime}} to the nearest 10 hours?




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 11, 55), Dates.Hour(10))
2016-07-17T12:00:00
\end{minted}



That may seem confusing, given that the hour (12) is not divisible by 10. The reason that \texttt{2016-07-17T12:00:00} was chosen is that it is 17,676,660 hours after \texttt{0000-01-01T00:00:00}, and 17,676,660 is divisible by 10.



As Julia \hyperlink{5911165232663997394}{\texttt{Date}} and \hyperlink{8865912400344885633}{\texttt{DateTime}} values are represented according to the ISO 8601 standard, \texttt{0000-01-01T00:00:00} was chosen as base (or {\textquotedbl}rounding epoch{\textquotedbl}) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia{\textquotesingle}s internal representation of \hyperlink{5911165232663997394}{\texttt{Date}} s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, \texttt{0000-01-01T00:00:00} was chosen as the rounding epoch instead of the \texttt{0000-12-31T00:00:00} used internally to minimize confusion.)



The only exception to the use of \texttt{0000-01-01T00:00:00} as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use \texttt{0000-01-03T00:00:00} (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.



Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest \texttt{P(2)}, where \texttt{P} is a \hyperlink{14377501606406826094}{\texttt{Period}} type? In some cases (specifically, when \texttt{P <: Dates.TimePeriod}) the answer is clear:




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Hour(2))
2016-07-17T08:00:00

julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Minute(2))
2016-07-17T08:56:00
\end{minted}



This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:




\begin{minted}{jlcon}
julia> round(DateTime(2016, 7, 17, 8, 55, 30), Dates.Month(2))
2016-07-01T00:00:00
\end{minted}



Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are 1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which are assigned 0).



This means that rounding a \hyperlink{8865912400344885633}{\texttt{DateTime}} to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a \hyperlink{8865912400344885633}{\texttt{DateTime}} with an even value in that field, while rounding a \hyperlink{8865912400344885633}{\texttt{DateTime}} to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.



See the \hyperlink{11995623453970199783}{API reference} for additional information on methods exported from the \texttt{Dates} module.



\hypertarget{9220662049678686366}{}


\chapter{Interactuando con Julia}



Julia viene con un REPL (read-eval-print loop) interactivo de línea de comando  integrado en el ejecutable \texttt{julia}. Además de permitir una evaluación rápida y fácil de las declaraciones de Julia, tiene un historial de búsqueda, finalización de pestañas, muchas combinaciones útiles de teclas, ayuda dedicada y modos de shell. El REPL se puede iniciar simplemente llamando a \texttt{julia} sin argumentos o haciendo doble clic en el ejecutable:




\begin{lstlisting}
$ julia
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org
   _ _   _| |_  __ _   |  Type "?help" for help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 0.6.0-dev.2493 (2017-01-31 18:53 UTC)
 _/ |\__'_|_|_|\__'_|  |  Commit c99e12c* (0 days old master)
|__/                   |  x86_64-linux-gnu

julia>
\end{lstlisting}



Para salir de la sesión interactiva, escriba \texttt{{\textasciicircum}D} - la tecla de control junto con la tecla \texttt{d} en una línea en blanco - o escriba \texttt{quit()} seguido de la tecla return o enter. El REPL te saluda con un banner y un prompt \texttt{julia>}.



\hypertarget{13014889144002412056}{}


\section{Los distintos modos de prompt}



\hypertarget{16284424912761293699}{}


\subsection{El modo Juliano}



El REPL tiene cuatro modos principales de operación. El primero y más común es el prompt Juliano. Es el modo de operación predeterminado; cada nueva línea inicialmente comienza con \texttt{julia>}. Es aquí donde puede ingresar las expresiones de Julia. Pulsando \emph{return} o \emph{enter} después de haber ingresado una expresión completa, se evaluará la entrada y se mostrará el resultado de la última expresión.




\begin{minted}{jlcon}
julia> string(1 + 2)
"3"
\end{minted}



Hay varias funciones útiles únicas para el trabajo interactivo. Además de mostrar el resultado, el REPL también vincula el resultado a la variable \texttt{ans}. Un punto y coma final en la línea se puede utilizar como un indicador para suprimir mostrar el resultado.




\begin{minted}{jlcon}
julia> string(3 * 4);

julia> ans
"12"
\end{minted}



En el modo Julia, el REPL es compatible con algo llamado \emph{pegado rápido}. Esto se activa al pegar texto que comienza con \texttt{julia>} en REPL. En ese caso, solo las expresiones que comienzan con \texttt{julia>} se analizan, otras se eliminan. Esto hace que sea posible pegar un trozo de código que ha sido copiado de una sesión REPL sin tener que eliminar los prompts y las salidas. Esta característica está habilitada de forma predeterminada, pero se puede desactivar o habilitar a voluntad con \texttt{Base.REPL.enable\_promptpaste(:: Bool)}. Si está habilitado, puedes probar pegando el bloque de código arriba de este párrafo directamente en REPL. Esta función no funciona en el símbolo del sistema estándar de Windows debido a su limitación para detectar cuándo se produce un pegado.



\hypertarget{18241426316285689604}{}


\subsection{Modo Ayuda}



Cuando el cursor está al principio de la línea, el aviso se puede cambiar a un modo de ayuda escribiendo \texttt{?}. Julia intentará imprimir ayuda o documentación para todo lo ingresado en modo de ayuda:




\begin{minted}{jlcon}
julia> ? # upon typing ?, the prompt changes (in place) to: help?>

help?> string
search: string String stringmime Cstring Cwstring RevString readstring randstring bytestring SubString

  string(xs...)

  Create a string from any values using the print function.
\end{minted}



Las macros, los tipos y las variables también se pueden consultar:




\begin{lstlisting}
help?> @time
  @time

  A macro to execute an expression, printing the time it took to execute, the number of allocations,
  and the total number of bytes its execution caused to be allocated, before returning the value of the
  expression.

  See also @timev, @timed, @elapsed, and @allocated.

help?> AbstractString
search: AbstractString AbstractSparseMatrix AbstractSparseVector AbstractSet

  No documentation found.

  Summary:

  abstract AbstractString <: Any

  Subtypes:

  Base.Test.GenericString
  DirectIndexString
  String
\end{lstlisting}



El modo de ayuda puede salir presionando la tecla de retroceso al comienzo de la línea.



\hypertarget{17654100848947676892}{}


\subsection{Modo Shell}



Del mismo modo que el modo de ayuda es útil para acceder rápidamente a la documentación, otra tarea común es utilizar el shell del sistema para ejecutar los comandos del sistema. Así como \texttt{?} Ingresó al modo de ayuda cuando está al principio de la línea, un punto y coma (\texttt{;}) ingresará al modo shell. Y puede salir presionando el retroceso al comienzo de la línea.




\begin{minted}{jlcon}
julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> echo hello
hello
\end{minted}



\hypertarget{16358259555391284736}{}


\subsection{Modos de búsqueda}



En todos los modos anteriores, las líneas ejecutadas se guardan en un archivo de historial, que se puede buscar. Para iniciar una búsqueda incremental a través del historial anterior, escriba \texttt{{\textasciicircum}R} - la tecla de control junto con la tecla \texttt{r}. El aviso cambiará a \texttt{(reverse-i-search)` {\textquotesingle}:}, y al escribir, la consulta de búsqueda aparecerá en las comillas. El resultado más reciente que coincida con la consulta se actualizará dinámicamente a la derecha de los dos puntos a medida que se escriba más. Para encontrar un resultado anterior usando la misma consulta, simplemente escriba \texttt{{\textasciicircum}R} de nuevo.



Del mismo modo que \texttt{{\textasciicircum} R} es una búsqueda inversa,\texttt{{\textasciicircum} S} es una búsqueda directa, con el indicador \texttt{(i-search)` {\textquotesingle}:}. Los dos pueden usarse conjuntamente para avanzar entre los resultados de coincidencia anterior o siguiente, respectivamente.



\hypertarget{18365686885517381407}{}


\section{Asociaciones de teclas}



El REPL de Julia hace un gran uso de las asociaciones de teclas. Varias combinaciones de teclas de control ya se han introducido anteriormente (\texttt{{\textasciicircum}D} para salir,\texttt{{\textasciicircum}R} y \texttt{{\textasciicircum}S} para buscar), pero hay muchas más. Además de la tecla de control, también hay enlaces de meta-clave. Estos varían según la plataforma, pero la mayoría de los terminales utilizan de forma predeterminada alt- u opción-, mantenida presionada con una tecla para enviar la meta-clave (o puede configurarse para hacerlo).




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Keybinding & Description \\
\hline
\textbf{Program control} &   \\
\hline
\texttt{{\textasciicircum}D} & Exit (when buffer is empty) \\
\hline
\texttt{{\textasciicircum}C} & Interrupt or cancel \\
\hline
\texttt{{\textasciicircum}L} & Clear console screen \\
\hline
Return/Enter, \texttt{{\textasciicircum}J} & New line, executing if it is complete \\
\hline
meta-Return/Enter & Insert new line without executing it \\
\hline
\texttt{?} or \texttt{;} & Enter help or shell mode (when at start of a line) \\
\hline
\texttt{{\textasciicircum}R}, \texttt{{\textasciicircum}S} & Incremental history search, described above \\
\hline
\textbf{Cursor movement} &   \\
\hline
Right arrow, \texttt{{\textasciicircum}F} & Move right one character \\
\hline
Left arrow, \texttt{{\textasciicircum}B} & Move left one character \\
\hline
Home, \texttt{{\textasciicircum}A} & Move to beginning of line \\
\hline
End, \texttt{{\textasciicircum}E} & Move to end of line \\
\hline
\texttt{{\textasciicircum}P} & Change to the previous or next history entry \\
\hline
\texttt{{\textasciicircum}N} & Change to the next history entry \\
\hline
Up arrow & Move up one line (or to the previous history entry) \\
\hline
Down arrow & Move down one line (or to the next history entry) \\
\hline
Page-up & Change to the previous history entry that matches the text before the cursor \\
\hline
Page-down & Change to the next history entry that matches the text before the cursor \\
\hline
\texttt{meta-F} & Move right one word \\
\hline
\texttt{meta-B} & Move left one word \\
\hline
\textbf{Editing} &   \\
\hline
Backspace, \texttt{{\textasciicircum}H} & Delete the previous character \\
\hline
Delete, \texttt{{\textasciicircum}D} & Forward delete one character (when buffer has text) \\
\hline
meta-Backspace & Delete the previous word \\
\hline
\texttt{meta-D} & Forward delete the next word \\
\hline
\texttt{{\textasciicircum}W} & Delete previous text up to the nearest whitespace \\
\hline
\texttt{{\textasciicircum}K} & {\textquotedbl}Kill{\textquotedbl} to end of line, placing the text in a buffer \\
\hline
\texttt{{\textasciicircum}Y} & {\textquotedbl}Yank{\textquotedbl} insert the text from the kill buffer \\
\hline
\texttt{{\textasciicircum}T} & Transpose the characters about the cursor \\
\hline
\texttt{{\textasciicircum}Q} & Write a number in REPL and press \texttt{{\textasciicircum}Q} to open editor at corresponding stackframe \\
\hline
\end{tabulary}

\end{table}



\hypertarget{14697017135338015656}{}


\subsection{Personalizando asociaciones de teclas}



Las combinaciones de teclas en el REPL de Julia pueden personalizarse completamente según las preferencias de un usuario pasando un diccionario a \texttt{REPL.setup\_interface()}. Las claves de este diccionario pueden ser caracteres o cadenas. La tecla \texttt{{\textquotesingle}*{\textquotesingle}} se refiere a la acción predeterminada. Las asociaciones de control y carácter \texttt{x} se indican con\texttt{{\textquotedbl}{\textasciicircum}x{\textquotedbl}}. Meta plus \texttt{x} se puede escribir\texttt{{\textquotedbl}{\textbackslash}{\textbackslash} Mx{\textquotedbl}}. Los valores del mapa de teclas personalizado deben ser \(nothing\) (lo que indica que la entrada debe ignorarse) o las funciones que aceptan la firma \texttt{(PromptState, AbstractREPL, Char)}. La función \texttt{REPL.setup\_interface()} debe invocarse antes de que se inicialice REPL, registrando la operación con \texttt{atreplinit()}. Por ejemplo, para enlazar las teclas de flecha hacia arriba y hacia abajo para moverse a través del historial sin búsqueda de prefijos, uno podría poner el siguiente código en \texttt{.juliarc.jl}:




\begin{minted}{julia}
import Base: LineEdit, REPL

const mykeys = Dict{Any,Any}(
    # Up Arrow
    "\e[A" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),
    # Down Arrow
    "\e[B" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))
)

function customize_keys(repl)
    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)
end

atreplinit(customize_keys)
\end{minted}



Los usuarios deberían consultar \texttt{base/LineEdit.jl} para descubrir las acciones disponibles sobre la entrada clave.



\hypertarget{11261862479923251512}{}


\section{Uso de Tab para completar expresiones}



Tanto en los moddos Juliano como de ayuda del REPL, uno puede entrar los primeros caracteres de una función o tipo y luego pulsar la tecla del tabulador para obtener una lista de posibles coincidencias:




\begin{minted}{jlcon}
julia> stri[TAB]
stride     strides     string      stringmime  strip

julia> Stri[TAB]
StridedArray    StridedMatrix    StridedVecOrMat  StridedVector    String
\end{minted}



La tecla tabulador puede también usarse para sustituir los símbolos matemáticos de LaTeX con sus equivalentes Unicode, y obtener también una lista de coincidencias LaTeX:




\begin{minted}{jlcon}
julia> \pi[TAB]
julia> π
π = 3.1415926535897...

julia> e\_1[TAB] = [1,0]
julia> e₁ = [1,0]
2-element Array{Int64,1}:
 1
 0

julia> e\^1[TAB] = [1 0]
julia> e¹ = [1 0]
1×2 Array{Int64,2}:
 1  0

julia> \sqrt[TAB]2     # √ is equivalent to the sqrt() function
julia> √2
1.4142135623730951

julia> \hbar[TAB](h) = h / 2\pi[TAB]
julia> ħ(h) = h / 2π
ħ (generic function with 1 method)

julia> \h[TAB]
\hat              \hermitconjmatrix  \hkswarow          \hrectangle
\hatapprox        \hexagon           \hookleftarrow     \hrectangleblack
\hbar             \hexagonblack      \hookrightarrow    \hslash
\heartsuit        \hksearow          \house             \hspace

julia> α="\alpha[TAB]"   # LaTeX completion also works in strings
julia> α="α"
\end{minted}



En la sección \hyperlink{7696893994298815226}{Entrada Unicode} del manual puede encontrarse una lista completa de finalizaciones usando tabulador.



En modo shell también puede usarse el tabulador para completar cadenas relativas a caminos de fichero:




\begin{minted}{jlcon}
julia> path="/[TAB]"
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
shell> /[TAB]
.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/
.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/
\end{minted}



Esta funcionalidad puede ayudar con la investigación de los métodos disponibles que coinciden con los argumentos de entrada:




\begin{minted}{jlcon}
julia> max([TAB] # All methods are displayed, not shown here due to size of the list

julia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument
max(x, y) in Base at operators.jl:215
max(a, b, c, xs...) in Base at operators.jl:281

julia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.
max(x, y) in Base at operators.jl:215
max(a, b, c, xs...) in Base at operators.jl:281
\end{minted}



Las palabras clave (\emph{keywords}) son también mostradas en los métodos sugeridos, ver la segunda línea después de \texttt{;} donde \texttt{limit} y \texttt{keep} son argumentos palabras clave:




\begin{minted}{jlcon}
julia> split("1 1 1", [TAB]
split(str::AbstractString) in Base at strings/util.jl:278
split{T<:AbstractString}(str::T, splitter; limit, keep) in Base at strings/util.jl:254
\end{minted}



La acción de completar los métodos usa inferencia de tipos y puede por tanto ver si los argumentos coinciden incluso si los argumentos son la salida de funcionees La función necesita se estable de tipos para que la acción de completar sea capaz de borrar los métodos no coincidentes.



La acción de completar puede también ayudar a completar campos:




\begin{minted}{jlcon}
julia> Pkg.a[TAB]
add       available
\end{minted}



También pueden completarse los campos para la salida de funciones:




\begin{minted}{jlcon}
julia> split("","")[1].[TAB]
endof  offset  string
\end{minted}



La acción de completar campos para la salida de funciones usa inferencia de tipos, y sólo puede sugerir campos si la función es estable en los tipos.



\hypertarget{6894944232879088790}{}


\section{Personalizando Colores}



Los colores utilizados por Julia y REPL se pueden personalizar también. Para cambiar el color del \emph{prompt} de Julia, puede agregar algo como lo siguiente a su \texttt{.juliarc.jl}, que se debe colocar dentro del directorio de inicio:




\begin{minted}{julia}
function customize_colors(repl)
    repl.prompt_color = Base.text_colors[:cyan]
end

atreplinit(customize_colors)
\end{minted}



Las teclas de color disponibles se pueden ver escribiendo \texttt{Base.text\_colors} en el modo de ayuda de REPL. Además, los números enteros 0 a 255 se pueden usar como teclas de color para terminales con soporte de 256 colores.



También puede cambiar los colores para la ayuda y las instrucciones del shell e ingresar y contestar el texto configurando el campo apropiado de \texttt{repl} en la función \texttt{customize\_colors} arriba (respectivamente, \texttt{help\_color}, \texttt{shell\_color}, \texttt{input\_color}, y \texttt{answer\_color}). Para los dos últimos, asegúrese de que el campo \texttt{envcolors} también esté configurado a false.



También es posible aplicar el formato en negrita mediante el uso de \texttt{Base.text\_colors[: bold]} como color. Por ejemplo, para imprimir las respuestas en letra negrita, se puede usar lo siguiente como \texttt{.juliarc.jl}:




\begin{minted}{julia}
function customize_colors(repl)
    repl.envcolors = false
    repl.answer_color = Base.text_colors[:bold]
end

atreplinit(customize_colors)
\end{minted}



También puede personalizarse el color utilizado para presentar mensajes de advertencia e información estableciendo las variables de entorno apropiadas. Por ejemplo, para generar mensajes de error, de advertencia y de información respectivamente en magenta, amarillo y cian, puede agregar lo siguiente a su archivo \texttt{.juliarc.jl}:




\begin{minted}{julia}
ENV["JULIA_ERROR_COLOR"] = :magenta
ENV["JULIA_WARN_COLOR"] = :yellow
ENV["JULIA_INFO_COLOR"] = :cyan
\end{minted}



\hypertarget{11862922961978750349}{}


\chapter{Ejecutando programas externos}



Julia toma prestada la notación de tilde inversa para ejecutar mandatos de la shell y programas en Perl y en Ruby.  Sin embargo, en Julia, escribir




\begin{minted}{jlcon}
julia> `echo hello`
`echo hello`
\end{minted}



difiere en algunos aspectos del comportamiento en varios shells, Perl y Ruby:



\begin{itemize}
\item En lugar de ejecutar el mandato inmediatamente, las tildes invertidas crean un objeto \texttt{Cmd} para representar el  mandato. Uno puede usar este objeto para conectar los mandatos a otros vía tuberías (\emph{pipes}), ejecutarlo y leer  o escribir en él.


\item Cuando el mandato se está ejecutando, Julia no captura su salida a menos que uno lo organice específicamente. En  lugar de ello, la salida del mandato va por defecto a \hyperlink{2784333101804678420}{\texttt{STDOUT}} como si se estuviera realizando una llamada  al sistema con la \texttt{libc}.


\item El mandato nunca es ejecutado con un shell. En su lugar, Julia analiza directamente la sintaxis del mandato,  interpola variables adecuadametne y dividiendo en palabras como el shell lo haría, respetando su sintaxis.  El mandato se ejecuta como un proceso hijo inmediato de Julia, usando las llamadas \texttt{fork} y \texttt{exec}.

\end{itemize}


He aquí un ejemplo sencillo de ejecución de un programa externo:




\begin{minted}{jlcon}
julia> mycommand = `echo hello`
`echo hello`

julia> typeof(mycommand)
Cmd

julia> run(mycommand)
hello
\end{minted}



El mensaje \texttt{hello} es la salida de este mandato \texttt{echo}, enviado a \hyperlink{2784333101804678420}{\texttt{STDOUT}}. El mensaje \texttt{hello} es la salida de este mandato \texttt{echo}, enviado a \texttt{STDOUT}. El método ejecutado devuelve en si mismo \texttt{nothing}, y lanza una \hyperlink{12102596058483452470}{\texttt{ErrorException}} si el mandato externo falla en ejecutarse con éxito.



Si se desea leer la salida de un mandato externo puede usarse \texttt{readstring()}:  




\begin{minted}{jlcon}
julia> a = readstring(`echo hello`)
"hello\n"

julia> chomp(a) == "hello"
true
\end{minted}



Más generalmente, puedes usar \hyperlink{300818094931158296}{\texttt{open()}} para leer desde o escribir hacia un mandato externo.




\begin{minted}{jlcon}
julia> open(`less`, "w", STDOUT) do io
           for i = 1:3
               println(io, i)
           end
       end
1
2
3
\end{minted}



\hypertarget{6373319844820183024}{}


\section{Interpolación}



Supongamos que uno quiere algo un poco más complicado y usa el nombre de un fichero en la variable \texttt{file} como argumento a un mandato. Se puede usar \texttt{\$} para interpolar tal como lo haríamos con un literal cadena (ver la sección \hyperlink{5278796056388981234}{Strings}):




\begin{minted}{jlcon}
julia> file = "/etc/passwd"
"/etc/passwd"

julia> `sort $file`
`sort /etc/passwd`
\end{minted}



Un error común es que cuando se ejecutan programas externos a través de un shell es que si el nombre del fichero contiene caracteres que son especiales para el shell, ellos pueden causar un comportamiento indeseaddo. Por ejemplo, en lugar de \texttt{/etc/passwd} se desea ordenar los contenidos del fichero \texttt{/volumes/External HD/data.csv}. Intentémoslo:




\begin{minted}{jlcon}
julia> file = "/Volumes/External HD/data.csv"
"/Volumes/External HD/data.csv"

julia> `sort $file`
`sort '/Volumes/External HD/data.csv'`
\end{minted}



¿Cómo se entrecomilla el nombre de fichero? Julia sabe que \texttt{file} va a ser interpolado por un solo argumento, por lo que él entrecomilla la cadena. De hecho, esto no es bastante exacto: el valor de \texttt{file} no va a ser interpretado por el shell nunca, por lo que no hay necesidad de entrecomillar. Las comillas se insertan sólo para presentar al usuario. Eso funcionará incluso si uno interpola un valor como parte de una palabra del shell:




\begin{minted}{jlcon}
julia> path = "/Volumes/External HD"
"/Volumes/External HD"

julia> name = "data"
"data"

julia> ext = "csv"
"csv"

julia> `sort $path/$name.$ext`
`sort '/Volumes/External HD/data.csv'`
\end{minted}



Como puedes ver, el espacio en la variable \texttt{path} es apropiadamente {\textquotedbl}escapado{\textquotedbl}. Pero, ¿qué pasa si lo que uno desea es interpolar múltiples palabras? En este caso, se utilizará un array (u otro contenedor iterable):




\begin{minted}{jlcon}
julia> files = ["/etc/passwd","/Volumes/External HD/data.csv"]
2-element Array{String,1}:
 "/etc/passwd"
 "/Volumes/External HD/data.csv"

julia> `grep foo $files`
`grep foo /etc/passwd '/Volumes/External HD/data.csv'`
\end{minted}



Si interpolas un array como parte de una palabra de la shell, Julia emula la generación de argumentos de la shell \texttt{\{a, b, c\}}:




\begin{minted}{jlcon}
julia> names = ["foo","bar","baz"]
3-element Array{String,1}:
 "foo"
 "bar"
 "baz"

julia> `grep xylophone $names.txt`
`grep xylophone foo.txt bar.txt baz.txt`
\end{minted}



Además, si interpolas múltiples arrays en la misma palabra, se emula el comportamiento de generación del shell haciendo el producto cartesiano: 




\begin{minted}{jlcon}
julia> names = ["foo","bar","baz"]
3-element Array{String,1}:
 "foo"
 "bar"
 "baz"

julia> exts = ["aux","log"]
2-element Array{String,1}:
 "aux"
 "log"

julia> `rm -f $names.$exts`
`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`
\end{minted}



Como pudes interpolar arrays de literales, puedes usar esta funcionalidad generativa sin necesidad de crer objetos array temporales primero: 




\begin{minted}{jlcon}
julia> `rm -rf $["foo","bar","baz","qux"].$["aux","log","pdf"]`
`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`
\end{minted}



\hypertarget{7834136129176976876}{}


\section{Entrecomillado}



Inevitablemente, uno quiere escribir mandatos que no sean tan simples, y se vueve necesario usar comillas. He aquí un ejemplo simple de un script Perl de una línea en el prompt del shell:




\begin{lstlisting}
sh$ perl -le '$|=1; for (0..3) { print }'
0
1
2
3
\end{lstlisting}



La expresión Perl necesita estar entre comillas sencillas por dos razones: para que los espacios no rompan la expresión en múltiples palabras en el shell, y para que el uso de variables de Perl, como \texttt{\$|} no cause interpolación. En otras instancias, puedes querer usar dobles comillas para que la interpolación SI tenga lugar:




\begin{lstlisting}
sh$ first="A"
sh$ second="B"
sh$ perl -le '$|=1; print for @ARGV' "1: $first" "2: $second"
1: A
2: B
\end{lstlisting}



En general, la sintaxis de comillas invertidas de Julia está diseñada cuidadosamente para que puedas cortar y pegar comendos del shell, los pongas entre comillas y funcionen: los comportamientos del escape, las comillas y las interpolaciones son los mismos que los del shell. La única diferencia es que la interpolación está integrada y consciente de la noción de Julia de que es un valor de cadena simple, y qué es un contenedor para valores múltiples. Intentemos los dos ejemplos anteriores en Julia:




\begin{minted}{jlcon}
julia> A = `perl -le '$|=1; for (0..3) { print }'`
`perl -le '$|=1; for (0..3) { print }'`

julia> run(A)
0
1
2
3

julia> first = "A"; second = "B";

julia> B = `perl -le 'print for @ARGV' "1: $first" "2: $second"`
`perl -le 'print for @ARGV' '1: A' '2: B'`

julia> run(B)
1: A
2: B
\end{minted}



Los resultados son idénticos, y el comportamiento de interpolación de Julia imita el shell con algunas mejoras debido a que Julia soporta objetos iterables de primera clase mientras la mayoría de los shells usan división de cadenas mediante espacios para ésto, lo cuál introduce ambigüedades. Cuando intentamos portar mandatos del shell a Julia, intentemos cortar y pegar primero. Como Julia te muestra los mandatos antes de que los ejecutes, puedes examinar fácilmente y de forma segura su interpretación sin hacer ningún daño.



\hypertarget{11841742305199605860}{}


\section{Tuberías}



Los metacaracteres del shell tales como \texttt{|}, \texttt{\&}, and \texttt{>}, necesitan ser acotados o escapados dentro de las comillas invertidas de Julia:




\begin{minted}{jlcon}
julia> run(`echo hello '|' sort`)
hello | sort

julia> run(`echo hello \| sort`)
hello | sort
\end{minted}



Esta expresión invoca el mandato \texttt{echo} con tres palabras como argumentos, {\textquotedbl}hello{\textquotedbl}, {\textquotedbl}|{\textquotedbl} y {\textquotedbl}sort{\textquotedbl}. El resultados es que se imprime una sola línea {\textquotedbl}hello | sort{\textquotedbl}. Dentro de las comillas traseras, el símbolo {\textquotedbl}|{\textquotedbl} no tiene un significado especial. ¿Cómo entonces, podemos construir una tubería? En lugar de usar el símbolo {\textquotedbl}|{\textquotedbl} dentro de la tubería, utilizaremos la función \hyperlink{17710887576380723118}{\texttt{pipeline()}}:




\begin{minted}{jlcon}
julia> run(pipeline(`echo hello`, `sort`))
hello
\end{minted}



Esto entuba la salida del mandato \texttt{echo} al mandato \texttt{sort}. Por supuesto, esto no es terriblemente interesante ya que sólo hay una línea que ordenar, pero podemos cosas mucho más interesantes:




\begin{minted}{jlcon}
julia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))
210
211
212
213
214
\end{minted}



Esto imprime los cinco identificadores de usuario mayores dentro de un sistema UNIX. Los mandatos \texttt{cut}, \texttt{sort} y \texttt{tail} son {\textquotedbl}criados{\textquotedbl} como hijos inmediatos del proceso \texttt{julia} actual, sin que intervenga el proceso shell. Julia en sí mismo hace el trabajo (normalmente hecho por el shell) de inicializar las tuberías y conectar los descriptores de fichero.  Como Julia hace este trabajo, retiene un mejor control y puede hacer algunas cosas que el shell no puede.



Julia puede ejecutar múltiples órdenes en paralelo:




\begin{minted}{jlcon}
julia> run(`echo hello` & `echo world`)
world
hello
\end{minted}



El orden de esta salida es no determinista debido a que los dos procesos \texttt{echo} se lanzan casi simultáneamente, y compiten para hacer la primera escritura al descriptor \hyperlink{2784333101804678420}{\texttt{STDOUT}} que ambas comparten con el proceso padre \texttt{julia}.  Julia te premite entubar la salida desde estos procesos a otro programa:




\begin{minted}{jlcon}
julia> run(pipeline(`echo world` & `echo hello`, `sort`))
hello
world
\end{minted}



En términos de fontanería UNIX, lo que está pasando aquí es que un único objeto tubería de UNIX se ha creado y es escrito por dos procesos \texttt{echo} y el otro extremo al final de la tubería es leído por la orden \texttt{sort}.



La redirección de la E/S puede conseguirse pasando los argumentos clave stdin, stdout y stderr a la función \texttt{pipeline}:




\begin{minted}{julia}
pipeline(`do_work`, stdout=pipeline(`sort`, "out.txt"), stderr="errs.txt")
\end{minted}



\hypertarget{13016989177198809745}{}


\subsection{Evitar interbloqueos en tuberías}



Cuando leemos y escribirmos en los dos extremos de una tubería desde un solo proceso, es importante evitar forzar el núcleo a almacenar todos los datos en el buffer.



Por ejemplo, cuando leemos toda la salida de un mandato, llamamos a \texttt{readstring(out)}, no \texttt{wait(process)}, ya que el primero consumirá activamente todos los datos exritos por el proceso, mientras que el último interntará almacenar los datos en los búferes del kernel mientras espera a que un lector esté conectado. 



Otra solución común es separar el lector y el escritor de la tuberían en tareas separadas:




\begin{minted}{julia}
writer = @async writeall(process, "data")
reader = @async do_compute(readstring(process))
wait(process)
fetch(reader)
\end{minted}



\hypertarget{853872503613643322}{}


\subsection{Ejemplo complicado}



La combinación de un lenguaje de programación de alto nivel, una abstracción de mandatos de primera clase y la inicialización automática de tuberías entre procesos es muy poderos. Para dar algun sentido a las tuberías complejas que pueden ser creadas facilmente, he aquí algunos ejemplos más sofisticado, con nuestras disculpas por el excesito uso de scripts Perl con una sola línea:




\begin{minted}{jlcon}
julia> prefixer(prefix, sleep) = `perl -nle '$|=1; print "'$prefix' ", $_; sleep '$sleep';'`;

julia> run(pipeline(`perl -le '$|=1; for(0..9){ print; sleep 1 }'`, prefixer("A",2) & prefixer("B",2)))
A 0
B 1
A 2
B 3
A 4
B 5
A 6
B 7
A 8
B 9
\end{minted}



Este es el ejemplo típico de un solo productor que alimenta dos consumidores concurrentes: un proceso \texttt{perl} genera líneas con los número 0 a 9, el otro con la letra {\textquotedbl}B{\textquotedbl}. Qué consumidor llega el primero es no determinista, pero una vez que se ha ganado la carrera, las líneas son consumidas alternativamente primero por un proceso y después por el otro. (Fijas \texttt{\$|=1} en Perl causa que cada instrucción de impresión vuelque al flujo \hyperlink{2784333101804678420}{\texttt{STDOUT}}, lo cuál es necesario para que este ejemplo funcione. En caso contrario toda la salida va a un buffer y sería impresa en la tubería de una vez, para ser leída por un solo proceso consumidor).



He aquí un ejemplo incluso más complicado de productor consumidor multi-etapa:




\begin{minted}{jlcon}
julia> run(pipeline(`perl -le '$|=1; for(0..9){ print; sleep 1 }'`,
           prefixer("X",3) & prefixer("Y",3) & prefixer("Z",3),
           prefixer("A",2) & prefixer("B",2)))
A X 0
B Y 1
A Z 2
B X 3
A Y 4
B Z 5
A X 6
B Y 7
A Z 8
B X 9
\end{minted}



Este ejemplo es similar al anterior, excepto en que hay dos etapas de consumidores y las estapas tiene diferente latencia por lo que usan un número de workers paralelos diferrentes, para mantener saturado el throughput .



Se recomienda intentar todos estos ejemplos y ver cómo funcionan.



\hypertarget{17572913146419880234}{}


\chapter{Llamando a código C y Fortran}



Aunque la mayoría del código se puede escribir en Julia, hay muchas bibliotecas maduras de alta calidad para computación numérica ya escritas en C y Fortran. Para permitir el uso fácil de este código existente, Julia hace que sea sencillo y eficiente llamar a las funciones C y Fortran. Julia tiene una filosofía de {\textquotedbl}no repetitivo{\textquotedbl}: las funciones se pueden llamar directamente desde Julia sin ningún código de {\textquotedbl}pegamento{\textquotedbl}, generación de código o compilación, incluso desde el aviso interactivo. Esto se logra haciendo una llamada apropiada con la sintaxis \hyperlink{14245046751182637566}{\texttt{ccall}}, que se parece a una llamada de función ordinaria.



El código que se debe llamar debe estar disponible como una biblioteca compartida. La mayoría de las bibliotecas C y Fortran ya se han compilado como bibliotecas compartidas, pero si está compilando el código usted mismo usando GCC (o Clang), necesitará usar las opciones \texttt{-shared} y\texttt{-fPIC}. Las instrucciones de la máquina generadas por el JIT de Julia son las mismas que una llamada C nativa, por lo que la sobrecarga resultante es lo mismo que llamar a una función de biblioteca desde el código C. (Las llamadas a funciones que no son de la biblioteca en C y Julia pueden estar incluidas y, por lo tanto, pueden tener incluso menos gastos generales que las llamadas a funciones de biblioteca compartidas. Cuando LLVM genera bibliotecas y ejecutables, es posible realizar optimizaciones de todo el programa que incluso optimizar a través de este límite, pero Julia aún no lo admite. Sin embargo, en el futuro, puede hacerlo, produciendo ganancias de rendimiento incluso mayores).



Las bibliotecas y funciones compartidas están referenciadas por una tupla de la forma \texttt{(:función,{\textquotedbl}biblioteca{\textquotedbl})} o \texttt{({\textquotedbl}función{\textquotedbl}, {\textquotedbl}biblioteca{\textquotedbl})} donde \texttt{función} es el nombre de función exportado por C. \texttt{library} se refiere al nombre de la biblioteca compartida: las bibliotecas compartidas disponibles en la ruta de carga (específica de la plataforma) se resolverán por nombre y, si es necesario, se puede especificar una ruta directa.



El nombre de una función se puede usar solo en lugar de la tupla (solo \texttt{:función} o\texttt{{\textquotedbl}función{\textquotedbl}}). En este caso, el nombre se resuelve dentro del proceso actual. Este formulario se puede usar para llamar funciones de biblioteca C, funciones en el tiempo de ejecución de Julia o funciones en una aplicación vinculada a Julia.



Por defecto, los compiladores Fortran \href{https://en.wikipedia.org/wiki/Name\_mangling\#Fortran}{generan nombres destrozados} (por ejemplo, convirtiendo nombres de funciones a minúsculas o mayúsculas, a menudo añadiendo un guión bajo), y para llamar a una función Fortran a través de \hyperlink{14245046751182637566}{\texttt{ccall}} debe pasar el identificador mutilado correspondiente a la regla seguida por su compilador Fortran . Además, cuando se llama a una función Fortran, todas las entradas se deben pasar por referencia.



Por último, se puede usar \hyperlink{14245046751182637566}{\texttt{ccall}} para generar de hecho una llamada a la función de librería. Los argumentos a  \hyperlink{14245046751182637566}{\texttt{ccall}} son los siguientes:



\begin{itemize}
\item[1. ] Una pareja \texttt{(:función, {\textquotedbl}librería{\textquotedbl})}, que debe ser escrita como una constante literal,

O

\end{itemize}


  un puntero a función (por ejemplo, de \texttt{dlsym}).



\begin{itemize}
\item[2. ] Tipo de retorno (ver abajo para la correspondencia entre el tipo declarado en C y Julia)

\begin{itemize}
\item Este argumento será evaluado en tiempo de compilación, cuando se defina el método que lo contiene.

\end{itemize}

\item[3. ] Una tupla de tipos de entrada. Los tipos de entrada deben ser escritos como un literal tupla, no como una variable o expresión de valor tupla.

\begin{itemize}
\item Este argumento será evaluado en tiempo de compilación, cuando se defina el método que lo contiene.

\end{itemize}

\item[4. ] Los siguientes argumentos, si los hay, son los valores de los argumentos actuales pasados a la función.

\end{itemize}


Como un ejemplo completo pero simple, el siguiente código llama a la función \texttt{clock} de la librería estándar C:




\begin{minted}{jlcon}
julia> t = ccall((:clock, "libc"), Int32, ())
2292761

julia> t
2292761

julia> typeof(ans)
Int32
\end{minted}



\texttt{clock} no toma argumentos y devuelve un \hyperlink{10103694114785108551}{\texttt{Int32}}. Un problema común es que una 1-tupla debe escribirse con una coma al final. Por ejemplo, para llamar a la función \texttt{getenv} para obtener un puntero al valor de una variable de entorno, se realiza una llamada como esta:




\begin{minted}{jlcon}
julia> path = ccall((:getenv, "libc"), Cstring, (Cstring,), "SHELL")
Cstring(@0x00007fff5fbffc45)

julia> unsafe_string(path)
"/bin/bash"
\end{minted}



Note que la tupla del tipo de argumento debe ser escrita como \texttt{(Cstring,)}, en lugar de como \texttt{(Cstring)}. Esto es debido a que \texttt{(Cstring)} es justo la expresión \texttt{Cstring} rodeada entre paréntesis, en lugar de una tupla que contiene a \texttt{Cstring}:




\begin{minted}{jlcon}
julia> (Cstring)
Cstring

julia> (Cstring,)
(Cstring,)
\end{minted}



En la práctica, especialmente cuando se proporciona funcionalidad reutilizable, generalmente se envuelve el usp de  \hyperlink{14245046751182637566}{\texttt{ccall}} en funciones de Julia que configuran argumentos y luego se comprueban los errores de cualquier forma que la función C o Fortran los indique, propagándose al código que llama desde Julia como excepciones. Esto es especialmente importante ya que las API de C y Fortran son notoriamente inconsistentes sobre cómo indican las condiciones de error. Por ejemplo, la función de biblioteca C \texttt{getenv} está envuelta en la siguiente función Julia, que es una versión simplificada de la definición real de \href{https://github.com/JuliaLang/julia/blob/master/base/env.jl}{\texttt{env.jl}}:




\begin{minted}{julia}
function getenv(var::AbstractString)
    val = ccall((:getenv, "libc"),
                Cstring, (Cstring,), var)
    if val == C_NULL
        error("getenv: undefined variable: ", var)
    end
    unsafe_string(val)
end
\end{minted}



La función C \texttt{getenv} indica un error al devolver\texttt{NULL}, pero otras funciones C estándar indican errores de varias maneras diferentes, incluyendo al devolver -1, 0, 1 y otros valores especiales. Este contenedor arroja una excepción que indica claramente el problema si la persona que llama intenta obtener una variable de entorno inexistente:




\begin{minted}{jlcon}
julia> getenv("SHELL")
"/bin/bash"

julia> getenv("FOOBAR")
getenv: undefined variable: FOOBAR
\end{minted}



Aquí hay un ejemplo ligeramente ms complejo que descubre el nombre de host de la máquina local:




\begin{minted}{julia}
function gethostname()
    hostname = Vector{UInt8}(128)
    ccall((:gethostname, "libc"), Int32,
          (Ptr{UInt8}, Csize_t),
          hostname, sizeof(hostname))
    hostname[end] = 0; # ensure null-termination
    return unsafe_string(pointer(hostname))
end
\end{minted}



Este ejemplo primero asigna un array de bytes, luego llama a la función de biblioteca C \texttt{gethostname} para llenar el array con el nombre de host, toma un puntero al buffer de nombre de host, y convierte el puntero a una cadena Julia, asumiendo que es una cadena C terminada en NUL. Es común que las bibliotecas C usen este patrón de requerir al llamador que asigne memoria para que la pase al llamado y la complete. La asignación de la memoria de Julia se logra generalmente creando un array no inicializada y pasando un puntero a sus datos a la función C. Es por eso que no usamos el tipo \texttt{Cstring} aquí: como la matriz no está inicializada, podría contener bytes NUL. Convertir a \texttt{Cstring} como parte de \hyperlink{14245046751182637566}{\texttt{ccall}} comprueba si hay bytes NUL contenidos y, por lo tanto, puede arrojar un error de conversión.



\hypertarget{13510626999326813290}{}


\section{Creando Punteros a Función Julia Compatibles con C}



Es posible pasar funciones Julia a funciones C nativas que aceptan argumentos punteros a función. Por ejemplo, para emparejar prototipos C de la forma:




\begin{lstlisting}
typedef returntype (*functiontype)(argumenttype,...)
\end{lstlisting}



La función \hyperlink{13392697678913949769}{\texttt{cfunction()}} genera el puntero a función compatible con C para una llamadan a una función de biblioteca de Julia. Los argumentos a \hyperlink{13392697678913949769}{\texttt{cfunction()}} son los siguientes:



\begin{itemize}
\item[1. ] Una función Julia


\item[2. ] Tipo de retorno


\item[3. ] Una tupla de tipos de entrada

\end{itemize}


Un ejemplo clásico es la función estándar de biblioteca C \texttt{qsort} declarada como:




\begin{lstlisting}
void qsort(void *base, size_t nmemb, size_t size,
           int(*compare)(const void *a, const void *b));
\end{lstlisting}



The \texttt{base} argument is a pointer to an array of length \texttt{nmemb}, with elements of \texttt{size} bytes each. \texttt{compare} is a callback function which takes pointers to two elements \texttt{a} and \texttt{b} and returns an integer less/greater than zero if \texttt{a} should appear before/after \texttt{b} (or zero if any order is permitted). Now, suppose that we have a 1d array \texttt{A} of values in Julia that we want to sort using the \texttt{qsort} function (rather than Julia{\textquotesingle}s built-in \texttt{sort} function). Before we worry about calling \texttt{qsort} and passing arguments, we need to write a comparison function that works for some arbitrary type T:




\begin{lstlisting}
julia> function mycompare(a::T, b::T) where T
           return convert(Cint, a < b ? -1 : a > b ? +1 : 0)::Cint
       end
mycompare (generic function with 1 method)
\end{lstlisting}



Notice that we have to be careful about the return type: \texttt{qsort} expects a function returning a C \texttt{int}, so we must be sure to return \texttt{Cint} via a call to \texttt{convert} and a \texttt{typeassert}.



In order to pass this function to C, we obtain its address using the function \texttt{cfunction}:




\begin{lstlisting}
julia> const mycompare_c = cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));
\end{lstlisting}



\hyperlink{13392697678913949769}{\texttt{cfunction()}} accepts three arguments: the Julia function (\texttt{mycompare}), the return type (\texttt{Cint}), and a tuple of the argument types, in this case to sort an array of \texttt{Cdouble} (\hyperlink{5027751419500983000}{\texttt{Float64}}) elements.



The final call to \texttt{qsort} looks like this:




\begin{lstlisting}
julia> A = [1.3, -2.7, 4.4, 3.1]
4-element Array{Float64,1}:
  1.3
 -2.7
  4.4
  3.1

julia> ccall(:qsort, Void, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{Void}),
             A, length(A), sizeof(eltype(A)), mycompare_c)

julia> A
4-element Array{Float64,1}:
 -2.7
  1.3
  3.1
  4.4
\end{lstlisting}



As can be seen, \texttt{A} is changed to the sorted array \texttt{[-2.7, 1.3, 3.1, 4.4]}. Note that Julia knows how to convert an array into a \texttt{Ptr\{Cdouble\}}, how to compute the size of a type in bytes (identical to C{\textquotesingle}s \texttt{sizeof} operator), and so on. For fun, try inserting a \texttt{println({\textquotedbl}mycompare(\$a,\$b){\textquotedbl})} line into \texttt{mycompare}, which will allow you to see the comparisons that \texttt{qsort} is performing (and to verify that it is really calling the Julia function that you passed to it).



\hypertarget{7299460396633422544}{}


\section{Mapping C Types to Julia}



It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.



Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The \href{https://github.com/ihnorton/Clang.jl}{Clang package} can be used to auto-generate Julia code from a C header file.)



\hypertarget{12226435363744783027}{}


\subsection{Auto-conversion:}



Julia automatically inserts calls to the \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} function to convert each argument to the specified type. For example, the following call:




\begin{minted}{julia}
ccall((:foo, "libfoo"), Void, (Int32, Float64), x, y)
\end{minted}



will behave as if the following were written:




\begin{minted}{julia}
ccall((:foo, "libfoo"), Void, (Int32, Float64),
      Base.unsafe_convert(Int32, Base.cconvert(Int32, x)),
      Base.unsafe_convert(Float64, Base.cconvert(Float64, y)))
\end{minted}



\hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} normally just calls \hyperlink{1846942650946171605}{\texttt{convert()}}, but can be defined to return an arbitrary new object more appropriate for passing to C. For example, this is used to convert an \texttt{Array} of objects (e.g. strings) to an array of pointers.



\hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert()}} handles conversion to \texttt{Ptr} types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.



\hypertarget{8963563453975340082}{}


\subsection{Type Correspondences:}



First, a review of some relevant Julia type terminology:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Syntax / Keyword & Example & Description \\
\hline
\texttt{mutable struct} & \texttt{String} & {\textquotedbl}Leaf Type{\textquotedbl} :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no \texttt{TypeVars} are allowed) in order for the instance to be constructed. \\
\hline
\texttt{abstract type} & \texttt{Any}, \texttt{AbstractArray\{T, N\}}, \texttt{Complex\{T\}} & {\textquotedbl}Super Type{\textquotedbl} :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types. \\
\hline
\texttt{T\{A\}} & \texttt{Vector\{Int\}} & {\textquotedbl}Type Parameter{\textquotedbl} :: A specialization of a type (typically used for dispatch or storage optimization). \\
\hline
 &  & {\textquotedbl}TypeVar{\textquotedbl} :: The \texttt{T} in the type parameter declaration is referred to as a TypeVar (short for type variable). \\
\hline
\texttt{primitive type} & \texttt{Int}, \texttt{Float64} & {\textquotedbl}Primitive Type{\textquotedbl} :: A type with no fields, but a size. It is stored and defined by-value. \\
\hline
\texttt{struct} & \texttt{Pair\{Int, Int\}} & {\textquotedbl}Struct{\textquotedbl} :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag. \\
\hline
 & \texttt{Complex128} (\texttt{isbits}) & {\textquotedbl}Is-Bits{\textquotedbl}   :: A \texttt{primitive type}, or a \texttt{struct} type where all fields are other \texttt{isbits} types. It is defined by-value, and is stored without a type-tag. \\
\hline
\texttt{struct ...; end} & \texttt{nothing} & {\textquotedbl}Singleton{\textquotedbl} :: a Leaf Type or Struct with no fields. \\
\hline
\texttt{(...)} or \texttt{tuple(...)} & \texttt{(1, 2, 3)} & {\textquotedbl}Tuple{\textquotedbl} :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{15482144590484122804}{}


\subsection{Bits Types:}



There are several special types to be aware of, as no other type can be defined to behave the same:



\begin{itemize}
\item \texttt{Float32}

Exactly corresponds to the \texttt{float} type in C (or \texttt{REAL*4} in Fortran).


\item \texttt{Float64}

Exactly corresponds to the \texttt{double} type in C (or \texttt{REAL*8} in Fortran).


\item \texttt{Complex64}

Exactly corresponds to the \texttt{complex float} type in C (or \texttt{COMPLEX*8} in Fortran).


\item \texttt{Complex128}

Exactly corresponds to the \texttt{complex double} type in C (or \texttt{COMPLEX*16} in Fortran).


\item \texttt{Signed}

Exactly corresponds to the \texttt{signed} type annotation in C (or any \texttt{INTEGER} type in Fortran). Any Julia type that is not a subtype of \hyperlink{14154866400772377486}{\texttt{Signed}} is assumed to be unsigned.

\end{itemize}


\begin{itemize}
\item \texttt{Ref\{T\}}

Behaves like a \texttt{Ptr\{T\}} that can manage its memory via the Julia GC.

\end{itemize}


\begin{itemize}
\item \texttt{Array\{T,N\}}

When an array is passed to C as a \texttt{Ptr\{T\}} argument, it is not reinterpret-cast: Julia requires that the element type of the array matches \texttt{T}, and the address of the first element is passed.

Therefore, if an \texttt{Array} contains data in the wrong format, it will have to be explicitly converted using a call such as \texttt{trunc(Int32, a)}.

To pass an array \texttt{A} as a pointer of a different type \emph{without} converting the data beforehand (for example, to pass a \texttt{Float64} array to a function that operates on uninterpreted bytes), you can declare the argument as \texttt{Ptr\{Void\}}.

If an array of eltype \texttt{Ptr\{T\}} is passed as a \texttt{Ptr\{Ptr\{T\}\}} argument, \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} will attempt to first make a null-terminated copy of the array with each element replaced by its \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} version. This allows, for example, passing an \texttt{argv} pointer array of type \texttt{Vector\{String\}} to an argument of type \texttt{Ptr\{Ptr\{Cchar\}\}}.

\end{itemize}


On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an \texttt{int} in C is not the same as an \texttt{Int} in Julia).



\textbf{System Independent:}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
C name & Fortran name & Standard Julia Alias & Julia Base Type \\
\hline
\texttt{unsigned char} & \texttt{CHARACTER} & \texttt{Cuchar} & \texttt{UInt8} \\
\hline
\texttt{bool} (only in C++) &  & \texttt{Cuchar} & \texttt{UInt8} \\
\hline
\texttt{short} & \texttt{INTEGER*2}, \texttt{LOGICAL*2} & \texttt{Cshort} & \texttt{Int16} \\
\hline
\texttt{unsigned short} &   & \texttt{Cushort} & \texttt{UInt16} \\
\hline
\texttt{int}, \texttt{BOOL} (C, typical) & \texttt{INTEGER*4}, \texttt{LOGICAL*4} & \texttt{Cint} & \texttt{Int32} \\
\hline
\texttt{unsigned int} &   & \texttt{Cuint} & \texttt{UInt32} \\
\hline
\texttt{long long} & \texttt{INTEGER*8}, \texttt{LOGICAL*8} & \texttt{Clonglong} & \texttt{Int64} \\
\hline
\texttt{unsigned long long} &   & \texttt{Culonglong} & \texttt{UInt64} \\
\hline
\texttt{intmax\_t} &   & \texttt{Cintmax\_t} & \texttt{Int64} \\
\hline
\texttt{uintmax\_t} &   & \texttt{Cuintmax\_t} & \texttt{UInt64} \\
\hline
\texttt{float} & \texttt{REAL*4i} & \texttt{Cfloat} & \texttt{Float32} \\
\hline
\texttt{double} & \texttt{REAL*8} & \texttt{Cdouble} & \texttt{Float64} \\
\hline
\texttt{complex float} & \texttt{COMPLEX*8} & \texttt{Complex64} & \texttt{Complex\{Float32\}} \\
\hline
\texttt{complex double} & \texttt{COMPLEX*16} & \texttt{Complex128} & \texttt{Complex\{Float64\}} \\
\hline
\texttt{ptrdiff\_t} &   & \texttt{Cptrdiff\_t} & \texttt{Int} \\
\hline
\texttt{ssize\_t} &   & \texttt{Cssize\_t} & \texttt{Int} \\
\hline
\texttt{size\_t} &   & \texttt{Csize\_t} & \texttt{UInt} \\
\hline
\texttt{void} &   &   & \texttt{Void} \\
\hline
\texttt{void} and \texttt{[[noreturn]]} or \texttt{\_Noreturn} &   &   & \texttt{Union\{\}} \\
\hline
\texttt{void*} &   &   & \texttt{Ptr\{Void\}} \\
\hline
\texttt{T*} (where T represents an appropriately defined type) &   &   & \texttt{Ref\{T\}} \\
\hline
\texttt{char*} (or \texttt{char[]}, e.g. a string) & \texttt{CHARACTER*N} &   & \texttt{Cstring} if NUL-terminated, or \texttt{Ptr\{UInt8\}} if not \\
\hline
\texttt{char**} (or \texttt{*char[]}) &   &   & \texttt{Ptr\{Ptr\{UInt8\}\}} \\
\hline
\texttt{jl\_value\_t*} (any Julia Type) &   &   & \texttt{Any} \\
\hline
\texttt{jl\_value\_t**} (a reference to a Julia Type) &   &   & \texttt{Ref\{Any\}} \\
\hline
\texttt{va\_arg} &   &   & Not supported \\
\hline
\texttt{...} (variadic function specification) &   &   & \texttt{T...} (where \texttt{T} is one of the above types, variadic functions of different argument types are not supported) \\
\hline
\end{tabulary}

\end{table}



The \texttt{Cstring} type is essentially a synonym for \texttt{Ptr\{UInt8\}}, except the conversion to \texttt{Cstring} throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a \texttt{char*} to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use \texttt{Ptr\{UInt8\}} as the argument type. \texttt{Cstring} can also be used as the \hyperlink{14245046751182637566}{\texttt{ccall}} return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.



\textbf{System-dependent:}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
C name & Standard Julia Alias & Julia Base Type \\
\hline
\texttt{char} & \texttt{Cchar} & \texttt{Int8} (x86, x86\_64), \texttt{UInt8} (powerpc, arm) \\
\hline
\texttt{long} & \texttt{Clong} & \texttt{Int} (UNIX), \texttt{Int32} (Windows) \\
\hline
\texttt{unsigned long} & \texttt{Culong} & \texttt{UInt} (UNIX), \texttt{UInt32} (Windows) \\
\hline
\texttt{wchar\_t} & \texttt{Cwchar\_t} & \texttt{Int32} (UNIX), \texttt{UInt16} (Windows) \\
\hline
\end{tabulary}

\end{table}



\begin{quote}
\textbf{Note}

When calling a Fortran function, all inputs must be passed by reference, so all type correspondences above should contain an additional \texttt{Ptr\{..\}} or \texttt{Ref\{..\}} wrapper around their type specification.

\end{quote}


\begin{quote}
\textbf{Warning}

For string arguments (\texttt{char*}) the Julia type should be \texttt{Cstring} (if NUL- terminated data is expected) or either \texttt{Ptr\{Cchar\}} or \texttt{Ptr\{UInt8\}} otherwise (these two pointer types have the same effect), as described above, not \texttt{String}. Similarly, for array arguments (\texttt{T[]} or \texttt{T*}), the Julia type should again be \texttt{Ptr\{T\}}, not \texttt{Vector\{T\}}.

\end{quote}


\begin{quote}
\textbf{Warning}

Julia{\textquotesingle}s \texttt{Char} type is 32 bits, which is not the same as the wide character type (\texttt{wchar\_t} or \texttt{wint\_t}) on all platforms.

\end{quote}


\begin{quote}
\textbf{Warning}

A return type of \texttt{Union\{\}} means the function will not return i.e. C++11 \texttt{[[noreturn]]} or C11 \texttt{\_Noreturn} (e.g. \texttt{jl\_throw} or \texttt{longjmp}). Do not use this for functions that return no value (\texttt{void}) but do return, use \texttt{Void} instead.

\end{quote}


\begin{quote}
\textbf{Note}

For \texttt{wchar\_t*} arguments, the Julia type should be \texttt{Cwstring} (if the C routine expects a NUL-terminated string) or \texttt{Ptr\{Cwchar\_t\}} otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the \texttt{Cwstring} type will cause an error to be thrown if the string itself contains NUL characters).

\end{quote}


\begin{quote}
\textbf{Note}

C functions that take an argument of the type \texttt{char**} can be called by using a \texttt{Ptr\{Ptr\{UInt8\}\}} type within Julia. For example, C functions of the form:


\begin{lstlisting}
int main(int argc, char **argv);
\end{lstlisting}

can be called via the following Julia code:


\begin{minted}{julia}
argv = [ "a.out", "arg1", "arg2" ]
ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)
\end{minted}

\end{quote}


\begin{quote}
\textbf{Note}

A C function declared to return \texttt{Void} will return the value \texttt{nothing} in Julia.

\end{quote}


\hypertarget{13731679927184956787}{}


\subsection{Struct Type correspondences}



Composite types, aka \texttt{struct} in C or \texttt{TYPE} in Fortran90 (or \texttt{STRUCTURE} / \texttt{RECORD} in some variants of F77), can be mirrored in Julia by creating a \texttt{struct} definition with the same field layout.



When used recursively, \texttt{isbits} types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an \texttt{isbits} struct type and use that instead. Unnamed structs are not possible in the translation to Julia.



Packed structs and union declarations are not supported by Julia.



You can get a near approximation of a \texttt{union} if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.



Arrays of parameters can be expressed with \texttt{NTuple}:




\begin{lstlisting}
in C:
struct B {
    int A[3];
};
b_a_2 = B.A[2];

in Julia:
struct B
    A::NTuple{3, CInt}
end
b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)
\end{lstlisting}



Arrays of unknown size (C99-compliant variable length structs specified by \texttt{[]} or \texttt{[0]}) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:




\begin{lstlisting}
struct String {
    int strlen;
    char data[];
};
\end{lstlisting}



In Julia, we can access the parts independently to make a copy of that string:




\begin{minted}{julia}
str = from_c::Ptr{Void}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)
\end{minted}



\hypertarget{7624173302473303801}{}


\subsection{Type Parameters}



The type arguments to \texttt{ccall} are evaluated statically, when the method containing the ccall is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.



This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.



However, while the type layout must be known statically to compute the \texttt{ccall} ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the \texttt{ccall} signature, as long as they don{\textquotesingle}t affect the layout of the type. For example, \texttt{f(x::T) where \{T\} = ccall(:valid, Ptr\{T\}, (Ptr\{T\},), x)} is valid, since \texttt{Ptr} is always a word-size primitive type. But, \texttt{g(x::T) where \{T\} = ccall(:notvalid, T, (T,), x)} is not valid, since the type layout of \texttt{T} is not known statically.



\hypertarget{17832703301283919502}{}


\subsection{SIMD Values}



Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.



If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of \texttt{VecElement} that naturally maps to the SIMD type.  Specifically:



\begin{quote}
\begin{itemize}
\item The tuple must be the same size as the SIMD type. For example, a tuple representing an \texttt{\_\_m128} on x86 must have a size of 16 bytes.


\item The element type of the tuple must be an instance of \texttt{VecElement\{T\}} where \texttt{T} is a primitive type that is 1, 2, 4 or 8 bytes.

\end{itemize}
\end{quote}


For instance, consider this C routine that uses AVX intrinsics:




\begin{lstlisting}
#include <immintrin.h>

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}
\end{lstlisting}



The following Julia code calls \texttt{dist} using \texttt{ccall}:




\begin{minted}{julia}
const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    ccall((:dist, "libdist"), m256, (m256, m256), a, b)
end

println(call_dist(a,b))
\end{minted}



The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support.



\hypertarget{6052846273119995959}{}


\subsection{Memory Ownership}



\textbf{malloc/free}



Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with \texttt{Libc.free} in Julia, as this may result in the \texttt{free} function being called via the wrong \texttt{libc} library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.



\hypertarget{15982365234273661730}{}


\subsection{When to use T, Ptr\{T\} and Ref\{T\}}



In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type \texttt{T} inside the \hyperlink{14245046751182637566}{\texttt{ccall}}, as they are passed by value.  For C code accepting pointers, \texttt{Ref\{T\}} should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}}.  In contrast, pointers returned by the C function called should be declared to be of output type \texttt{Ptr\{T\}}, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type \texttt{Ptr\{T\}} within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.



In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type \texttt{Ref\{T\}}, as Fortran passes all variables by reference. The return type should either be \texttt{Void} for Fortran subroutines, or a \texttt{T} for Fortran functions returning the type \texttt{T}.



\hypertarget{6114319820079574946}{}


\section{Mapping C Functions to Julia}



\hypertarget{9085571853862897545}{}


\subsection{\texttt{ccall}/\texttt{cfunction} argument translation guide}



For translating a C argument list to Julia:



\begin{itemize}
\item \texttt{T}, where \texttt{T} is one of the primitive types: \texttt{char}, \texttt{int}, \texttt{long}, \texttt{short}, \texttt{float}, \texttt{double}, \texttt{complex}, \texttt{enum} or any of their \texttt{typedef} equivalents

\begin{itemize}
\item \texttt{T}, where \texttt{T} is an equivalent Julia Bits Type (per the table above)


\item if \texttt{T} is an \texttt{enum}, the argument type should be equivalent to \texttt{Cint} or \texttt{Cuint}


\item argument value will be copied (passed by value)

\end{itemize}

\item \texttt{struct T} (including typedef to a struct)

\begin{itemize}
\item \texttt{T}, where \texttt{T} is a Julia leaf type


\item argument value will be copied (passed by value)

\end{itemize}

\item \texttt{void*}

\begin{itemize}
\item depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list


\item this argument may be declared as \texttt{Ptr\{Void\}}, if it really is just an unknown pointer

\end{itemize}

\item \texttt{jl\_value\_t*}

\begin{itemize}
\item \texttt{Any}


\item argument value must be a valid Julia object


\item currently unsupported by \hyperlink{13392697678913949769}{\texttt{cfunction()}}

\end{itemize}

\item \texttt{jl\_value\_t**}

\begin{itemize}
\item \texttt{Ref\{Any\}}


\item argument value must be a valid Julia object (or \texttt{C\_NULL})


\item currently unsupported by \hyperlink{13392697678913949769}{\texttt{cfunction()}}

\end{itemize}

\item \texttt{T*}

\begin{itemize}
\item \texttt{Ref\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}


\item argument value will be copied if it is an \texttt{isbits} type otherwise, the value must be a valid Julia object

\end{itemize}

\item \texttt{(T*)(...)} (e.g. a pointer to a function)

\begin{itemize}
\item \texttt{Ptr\{Void\}} (you may need to use \hyperlink{13392697678913949769}{\texttt{cfunction()}} explicitly to create this pointer)

\end{itemize}

\item \texttt{...} (e.g. a vararg)

\begin{itemize}
\item \texttt{T...}, where \texttt{T} is the Julia type

\end{itemize}

\item \texttt{va\_arg}

\begin{itemize}
\item not supported

\end{itemize}
\end{itemize}


\hypertarget{4058583142675680098}{}


\subsection{\texttt{ccall}/\texttt{cfunction} return type translation guide}



For translating a C return type to Julia:



\begin{itemize}
\item \texttt{void}

\begin{itemize}
\item \texttt{Void} (this will return the singleton instance \texttt{nothing::Void})

\end{itemize}

\item \texttt{T}, where \texttt{T} is one of the primitive types: \texttt{char}, \texttt{int}, \texttt{long}, \texttt{short}, \texttt{float}, \texttt{double}, \texttt{complex}, \texttt{enum} or any of their \texttt{typedef} equivalents

\begin{itemize}
\item \texttt{T}, where \texttt{T} is an equivalent Julia Bits Type (per the table above)


\item if \texttt{T} is an \texttt{enum}, the argument type should be equivalent to \texttt{Cint} or \texttt{Cuint}


\item argument value will be copied (returned by-value)

\end{itemize}

\item \texttt{struct T} (including typedef to a struct)

\begin{itemize}
\item \texttt{T}, where \texttt{T} is a Julia Leaf Type


\item argument value will be copied (returned by-value)

\end{itemize}

\item \texttt{void*}

\begin{itemize}
\item depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list


\item this argument may be declared as \texttt{Ptr\{Void\}}, if it really is just an unknown pointer

\end{itemize}

\item \texttt{jl\_value\_t*}

\begin{itemize}
\item \texttt{Any}


\item argument value must be a valid Julia object

\end{itemize}

\item \texttt{jl\_value\_t**}

\begin{itemize}
\item \texttt{Ref\{Any\}}


\item argument value must be a valid Julia object (or \texttt{C\_NULL})

\end{itemize}

\item \texttt{T*}

\begin{itemize}
\item If the memory is already owned by Julia, or is an \texttt{isbits} type, and is known to be non-null:

\begin{itemize}
\item \texttt{Ref\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}


\item a return type of \texttt{Ref\{Any\}} is invalid, it should either be \texttt{Any} (corresponding to \texttt{jl\_value\_t*}) or \texttt{Ptr\{Any\}} (corresponding to \texttt{Ptr\{Any\}})


\item C \textbf{MUST NOT} modify the memory returned via \texttt{Ref\{T\}} if \texttt{T} is an \texttt{isbits} type

\end{itemize}

\item If the memory is owned by C:

\begin{itemize}
\item \texttt{Ptr\{T\}}, where \texttt{T} is the Julia type corresponding to \texttt{T}

\end{itemize}
\end{itemize}

\item \texttt{(T*)(...)} (e.g. a pointer to a function)

\begin{itemize}
\item \texttt{Ptr\{Void\}} (you may need to use \hyperlink{13392697678913949769}{\texttt{cfunction()}} explicitly to create this pointer)

\end{itemize}
\end{itemize}


\hypertarget{12317000517353378133}{}


\subsection{Passing Pointers for Modifying Inputs}



Because C doesn{\textquotesingle}t support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a \hyperlink{14245046751182637566}{\texttt{ccall}}, you need to first encapsulate the value inside an \texttt{Ref\{T\}} of the appropriate type. When you pass this \texttt{Ref} object as an argument, Julia will automatically pass a C pointer to the encapsulated data:




\begin{minted}{julia}
width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
ccall(:foo, Void, (Ref{Cint}, Ref{Cfloat}), width, range)
\end{minted}



Upon return, the contents of \texttt{width} and \texttt{range} can be retrieved (if they were changed by \texttt{foo}) by \texttt{width[]} and \texttt{range[]}; that is, they act like zero-dimensional arrays.



\hypertarget{13468242842430921722}{}


\subsection{Special Reference Syntax for ccall (deprecated):}



The \texttt{\&} syntax is deprecated, use the \texttt{Ref\{T\}} argument type instead.



A prefix \texttt{\&} is used on an argument to \hyperlink{14245046751182637566}{\texttt{ccall}} to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.




\begin{minted}{julia}
function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = ccall((:ddot_, "libLAPACK"),
                    Float64,
                    (Ptr{Int32}, Ptr{Float64}, Ptr{Int32}, Ptr{Float64}, Ptr{Int32}),
                    &n, DX, &incx, DY, &incy)
    return product
end
\end{minted}



The meaning of prefix \texttt{\&} is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via \texttt{type}). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, \texttt{\&} may be used with any expression, such as \texttt{\&0} or \texttt{\&f(x)}.



When a scalar value is passed with \texttt{\&} as an argument of type \texttt{Ptr\{T\}}, the value will first be converted to type \texttt{T}.



\hypertarget{3327404933822645337}{}


\section{Some Examples of C Wrappers}



Here is a simple example of a C wrapper that returns a \texttt{Ptr} type:




\begin{minted}{julia}
mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = ccall(
        (:gsl_permutation_alloc, :libgsl), # name of C function and library
        Ptr{gsl_permutation},              # output type
        (Csize_t,),                        # tuple of input types
        n                                  # name of Julia variable to pass in
    )
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end
\end{minted}



The \href{https://www.gnu.org/software/gsl/}{GNU Scientific Library} (here assumed to be accessible through \texttt{:libgsl}) defines an opaque pointer, \texttt{gsl\_permutation *}, as the return type of the C function \texttt{gsl\_permutation\_alloc()}. As user code never has to look inside the \texttt{gsl\_permutation} struct, the corresponding Julia wrapper simply needs a new type declaration, \texttt{gsl\_permutation}, that has no internal fields and whose sole purpose is to be placed in the type parameter of a \texttt{Ptr} type.  The return type of the \hyperlink{14245046751182637566}{\texttt{ccall}} is declared as \texttt{Ptr\{gsl\_permutation\}}, since the memory allocated and pointed to by \texttt{output\_ptr} is controlled by C (and not Julia).



The input \texttt{n} is passed by value, and so the function{\textquotesingle}s input signature is simply declared as \texttt{(Csize\_t,)} without any \texttt{Ref} or \texttt{Ptr} necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be \texttt{(Ref\{Csize\_t\},)}, since Fortran variables are passed by reference.) Furthermore, \texttt{n} can be any type that is convertable to a \texttt{Csize\_t} integer; the \hyperlink{14245046751182637566}{\texttt{ccall}} implicitly calls \hyperlink{16487788729383051927}{\texttt{Base.cconvert(Csize\_t, n)}}.



Here is a second example wrapping the corresponding destructor:




\begin{minted}{julia}
# The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ref{gsl_permutation})
    ccall(
        (:gsl_permutation_free, :libgsl), # name of C function and library
        Void,                             # output type
        (Ref{gsl_permutation},),          # tuple of input types
        p                                 # name of Julia variable to pass in
    )
end
\end{minted}



Here, the input \texttt{p} is declared to be of type \texttt{Ref\{gsl\_permutation\}}, meaning that the memory that \texttt{p} points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type \texttt{Ptr\{gsl\_permutation\}}, but it is convertable using \hyperlink{16487788729383051927}{\texttt{Base.cconvert()}} and therefore can be used in the same (covariant) context of the input argument to a \hyperlink{14245046751182637566}{\texttt{ccall}}. A pointer to memory allocated by Julia must be of type \texttt{Ref\{gsl\_permutation\}}, to ensure that the memory address pointed to is valid and that Julia{\textquotesingle}s garbage collector manages the chunk of memory pointed to correctly. Therefore, the \texttt{Ref\{gsl\_permutation\}} declaration allows pointers managed by C or Julia to be used.



If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using \texttt{p::Ptr\{gsl\_permutation\}} for the method signature of the wrapper and similarly in the \hyperlink{14245046751182637566}{\texttt{ccall}} is also acceptable.



Here is a third example passing Julia arrays:




\begin{minted}{julia}
# The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax < nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(nmax - nmin + 1)
    errorcode = ccall(
        (:gsl_sf_bessel_Jn_array, :libgsl), # name of C function and library
        Cint,                               # output type
        (Cint, Cint, Cdouble, Ref{Cdouble}),# tuple of input types
        nmin, nmax, x, result_array         # names of Julia variables to pass in
    )
    if errorcode != 0
        error("GSL error code $errorcode")
    end
    return result_array
end
\end{minted}



The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array \texttt{result\_array}. This variable can only be used with corresponding input type declaration \texttt{Ref\{Cdouble\}}, since its memory is allocated and managed by Julia, not C. The implicit call to \hyperlink{16487788729383051927}{\texttt{Base.cconvert(Ref\{Cdouble\}, result\_array)}} unpacks the Julia pointer to a Julia array data structure into a form understandable by C.



Note that for this code to work correctly, \texttt{result\_array} must be declared to be of type \texttt{Ref\{Cdouble\}} and not \texttt{Ptr\{Cdouble\}}. The memory is managed by Julia and the \texttt{Ref} signature alerts Julia{\textquotesingle}s garbage collector to keep managing the memory for \texttt{result\_array} while the \hyperlink{14245046751182637566}{\texttt{ccall}} executes. If \texttt{Ptr\{Cdouble\}} were used instead, the \hyperlink{14245046751182637566}{\texttt{ccall}} may still work, but Julia{\textquotesingle}s garbage collector would not be aware that the memory declared for \texttt{result\_array} is being used by the external C function. As a result, the code may produce a memory leak if \texttt{result\_array} never gets freed by the garbage collector, or if the garbage collector prematurely frees \texttt{result\_array}, the C function may end up throwing an invalid memory access exception.



\hypertarget{6663973011603779975}{}


\section{Garbage Collection Safety}



When passing data to a \hyperlink{14245046751182637566}{\texttt{ccall}}, it is best to avoid using the \hyperlink{8901246211940014300}{\texttt{pointer()}} function. Instead define a convert method and pass the variables directly to the \hyperlink{14245046751182637566}{\texttt{ccall}}. \hyperlink{14245046751182637566}{\texttt{ccall}} automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the \hyperlink{14245046751182637566}{\texttt{ccall}} returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global variable of type \texttt{Array\{Ref,1\}} to hold these values, until the C library notifies you that it is finished with them.



Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many methods in Julia such as \hyperlink{13744149973765810952}{\texttt{unsafe\_load()}} and \hyperlink{2825695355940841177}{\texttt{String()}} make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is \hyperlink{14566494858943689253}{\texttt{unsafe\_wrap()}} which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.



The garbage collector does not guarantee any order of finalization. That is, if \texttt{a} contained a reference to \texttt{b} and both \texttt{a} and \texttt{b} are due for garbage collection, there is no guarantee that \texttt{b} would be finalized after \texttt{a}. If proper finalization of \texttt{a} depends on \texttt{b} being valid, it must be handled in other ways.



\hypertarget{14397309909238125480}{}


\section{Non-constant Function Specifications}



A \texttt{(name, library)} function specification must be a constant expression. However, it is possible to use computed values as function names by staging through \texttt{eval} as follows:




\begin{lstlisting}
@eval ccall(($(string("a", "b")), "lib"), ...
\end{lstlisting}



This expression constructs a name using \texttt{string}, then substitutes this name into a new \hyperlink{14245046751182637566}{\texttt{ccall}} expression, which is then evaluated. Keep in mind that \texttt{eval} only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with \texttt{\$}). For this reason, \texttt{eval} is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions.



If your usage is more dynamic, use indirect calls as described in the next section.



\hypertarget{14195829583958657383}{}


\section{Indirect Calls}



The first argument to \hyperlink{14245046751182637566}{\texttt{ccall}} can also be an expression evaluated at run time. In this case, the expression must evaluate to a \texttt{Ptr}, which will be used as the address of the native function to call. This behavior occurs when the first \hyperlink{14245046751182637566}{\texttt{ccall}} argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.



For example, you might look up the function via \texttt{dlsym}, then cache it in a global variable for that session. For example:




\begin{minted}{julia}
macro dlsym(func, lib)
    z, zlocal = gensym(string(func)), gensym()
    eval(current_module(), :(global $z = C_NULL))
    z = esc(z)
    quote
        let $zlocal::Ptr{Void} = $z::Ptr{Void}
            if $zlocal == C_NULL
                $zlocal = dlsym($(esc(lib))::Ptr{Void}, $(esc(func)))
                global $z = $zlocal
            end
            $zlocal
        end
    end
end

mylibvar = Libdl.dlopen("mylib")
ccall(@dlsym("myfunc", mylibvar), Void, ())
\end{minted}



\hypertarget{8984473107328045984}{}


\section{Calling Convention}



The second argument to \hyperlink{14245046751182637566}{\texttt{ccall}} can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: \texttt{stdcall}, \texttt{cdecl}, \texttt{fastcall}, and \texttt{thiscall}. For example (from \texttt{base/libc.jl}) we see the same \texttt{gethostname}\hyperlink{14245046751182637566}{\texttt{ccall}} as above, but with the correct signature for Windows:




\begin{minted}{julia}
hn = Vector{UInt8}(256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))
\end{minted}



For more information, please see the \href{http://llvm.org/docs/LangRef.html\#calling-conventions}{LLVM Language Reference}.



There is one additional special calling convention \texttt{llvmcall}, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for \href{http://llvm.org/docs/NVPTXUsage.html}{CUDA}, we need to be able to read the thread index:




\begin{minted}{julia}
ccall("llvm.nvvm.read.ptx.sreg.tid.x", llvmcall, Int32, ())
\end{minted}



As with any \texttt{ccall}, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by \texttt{Core.Intrinsics}.



\hypertarget{2707067892080774554}{}


\section{Accessing Global Variables}



Global variables exported by native libraries can be accessed by name using the \hyperlink{2746947069730856184}{\texttt{cglobal()}} function. The arguments to \hyperlink{2746947069730856184}{\texttt{cglobal()}} are a symbol specification identical to that used by \hyperlink{14245046751182637566}{\texttt{ccall}}, and a type describing the value stored in the variable:




\begin{minted}{jlcon}
julia> cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8
\end{minted}



The result is a pointer giving the address of the value. The value can be manipulated through this pointer using \hyperlink{13744149973765810952}{\texttt{unsafe\_load()}} and \hyperlink{4579672834750013041}{\texttt{unsafe\_store!()}}.



\hypertarget{14428977823562595292}{}


\section{Accessing Data through a Pointer}



The following methods are described as {\textquotedbl}unsafe{\textquotedbl} because a bad pointer or type declaration can cause Julia to terminate abruptly.



Given a \texttt{Ptr\{T\}}, the contents of type \texttt{T} can generally be copied from the referenced memory into a Julia object using \texttt{unsafe\_load(ptr, [index])}. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of \hyperlink{2839226020402435013}{\texttt{getindex()}} and \hyperlink{17903591429492118749}{\texttt{setindex!()}} (e.g. \texttt{[]} access syntax).



The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.



If \texttt{T} is \texttt{Any}, then the memory is assumed to contain a reference to a Julia object (a \texttt{jl\_value\_t*}), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia{\textquotesingle}s garbage collector.  If the \texttt{Ptr} itself is actually a \texttt{jl\_value\_t*}, it can be converted back to a Julia object reference by \hyperlink{10812596548944930674}{\texttt{unsafe\_pointer\_to\_objref(ptr)}}. (Julia values \texttt{v} can be converted to \texttt{jl\_value\_t*} pointers, as \texttt{Ptr\{Void\}}, by calling \hyperlink{9366554937543398846}{\texttt{pointer\_from\_objref(v)}}.)



The reverse operation (writing data to a \texttt{Ptr\{T\}}), can be performed using \hyperlink{4579672834750013041}{\texttt{unsafe\_store!(ptr, value, [index])}}. Currently, this is only supported for primitive types or other pointer-free (\texttt{isbits}) immutable struct types.



Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.



If the pointer of interest is a plain-data array (primitive type or immutable struct), the function \hyperlink{14566494858943689253}{\texttt{unsafe\_wrap(Array, ptr,dims,[own])}} may be more useful. The final parameter should be true if Julia should {\textquotedbl}take ownership{\textquotedbl} of the underlying buffer and call \texttt{free(ptr)} when the returned \texttt{Array} object is finalized.  If the \texttt{own} parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.



Arithmetic on the \texttt{Ptr} type in Julia (e.g. using \texttt{+}) does not behave the same as C{\textquotesingle}s pointer arithmetic. Adding an integer to a \texttt{Ptr} in Julia always moves the pointer by some number of \emph{bytes}, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.



\hypertarget{13563408698628305845}{}


\section{Thread-safety}



Some C libraries execute their callbacks from a different thread, and since Julia isn{\textquotesingle}t thread-safe you{\textquotesingle}ll need to take some extra precautions. In particular, you{\textquotesingle}ll need to set up a two-layered system: the C callback should only \emph{schedule} (via Julia{\textquotesingle}s event loop) the execution of your {\textquotedbl}real{\textquotedbl} callback. To do this, create a \texttt{AsyncCondition} object and wait on it:




\begin{minted}{julia}
cond = Base.AsyncCondition()
wait(cond)
\end{minted}



The callback you pass to C should only execute a \hyperlink{14245046751182637566}{\texttt{ccall}} to \texttt{:uv\_async\_send}, passing \texttt{cond.handle} as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.



Note that events may be coalesced, so multiple calls to \texttt{uv\_async\_send} may result in a single wakeup notification to the condition.



\hypertarget{144011036836523845}{}


\section{More About Callbacks}



For more details on how to pass callbacks to C libraries, see this \href{https://julialang.org/blog/2013/05/callback}{blog post}.



\hypertarget{4039606750368114245}{}


\section{C++}



For direct C++ interfacing, see the \href{https://github.com/Keno/Cxx.jl}{Cxx} package. For tools to create C++ bindings, see the \href{https://github.com/JuliaInterop/CxxWrap.jl}{CxxWrap} package.



\hypertarget{4478407192401635368}{}


\chapter{Manejando variaciones en el Sistema Operativo}



Cuando se trata con librerías de plataforma, es frecuentemente necesario proporcionar casos especiales para distintas plataformas. La variable \texttt{Sys.KERNEL} puede utilizarse para escribir estos casos especiales. Hay varias funciones con intención de hacer esto más sencillo: \texttt{is\_unix}, \texttt{is\_linux}, \texttt{is\_apple}, \texttt{is\_bsd} e \texttt{is\_windows}. Ellas pueden usarse de la siguiente forma:




\begin{minted}{julia}
if is_windows()
    some_complicated_thing(a)
end
\end{minted}



Note que \texttt{is\_linux}e \texttt{is\_apple} son subconjuntos mutuamente exclusivos de \texttt{is\_unix}. Adicionalmente, existe una macro \texttt{@static} que hace posible usar estas funciones para ocultar código inválido condicionalmente, como demuestran los siguientes ejemplos:



Bloques simples:




\begin{lstlisting}
ccall( (@static is_windows() ? :_fopen : :fopen), ...)
\end{lstlisting}



Bloques complejos:




\begin{minted}{julia}
@static if is_linux()
    some_complicated_thing(a)
else
    some_different_thing(a)
end
\end{minted}



Cuando se encadenan condicionales (incluyendo if/elsif/end) \texttt{@static} debe ser repetido por cada nivel (paréntesis opcional, pero recomendado por legibilidad):




\begin{minted}{julia}
@static is_windows() ? :a : (@static is_apple() ? :b : :c)
\end{minted}



\hypertarget{1581416507643810205}{}


\chapter{Variables de Entorno}



Julia se puede configurar con varias variables de entorno, ya sea de la manera habitual del sistema operativo o de manera portátil desde Julia. Supongamos que quiere establecer la variable de entorno \texttt{JULIA\_EDITOR} como \texttt{vim}, para ello escribirá \texttt{ENV[{\textquotedbl}JULIA\_EDITOR{\textquotedbl}] = {\textquotedbl}vim{\textquotedbl}} en el REPL para llevar a cabo este cambio en la sesión actual, o agregará lo mismo en el archivo de configuración \texttt{.juliarc.jl} en el directorio de inicio del usuario para tener un efecto permanente. El valor actual de la misma variable de entorno se determina evaluando \texttt{ENV [{\textquotedbl}JULIA\_EDITOR{\textquotedbl}]}.



Las variables de entorno que usa Julia generalmente comienzan con \texttt{JULIA}. Si \hyperlink{4959604240462971450}{\texttt{Base.versioninfo}} se llama con \texttt{verbose} igual a \texttt{true}, la salida mostrará una lista de variables de entorno definidas relevantes para Julia, incluidas aquellas para las cuales\texttt{JULIA} aparece en el nombre.



\hypertarget{7694248346443891377}{}


\section{Localizaciones de fichero}



\hypertarget{16977344973946922110}{}


\subsection{\texttt{JULIA\_HOME}}



La ruta absoluta del directorio que contiene el ejecutable de Julia, que establece la variable global \hyperlink{15863123579738922895}{\texttt{Base.JULIA\_HOME}}. Si \texttt{\$JULIA\_HOME} no está configurado, entonces Julia determina el valor\texttt{Base.JULIA\_HOME} en el tiempo de ejecución.



El ejecutable en sí es uno de




\begin{lstlisting}
$ JULIA_HOME/julia
$ JULIA_HOME/julia-debug
\end{lstlisting}



por defecto.



La variable global \texttt{Base.DATAROOTDIR} determina una ruta relativa de \texttt{Base.JULIA\_HOME} al directorio de datos asociado con Julia. Entonces el camino




\begin{lstlisting}
$ JULIA_HOME / $ DATAROOTDIR / julia / base
\end{lstlisting}



determina el directorio en el que Julia inicialmente busca los archivos fuente (a través de \texttt{Base.find\_source\_file()}).



Del mismo modo, la variable global \texttt{Base.SYSCONFDIR} determina una ruta relativa al directorio del archivo de configuración. Entonces Julia busca un archivo \texttt{juliarc.jl} en



\(` $JULIA_HOME/$SYSCONFDIR/julia/juliarc.jl $JULIA_HOME/../etc/julia/juliarc.jl\) `



por defecto (a través de \texttt{Base.load\_juliarc()}).



Por ejemplo, una instalación de Linux con un ejecutable de Julia ubicado en \texttt{/bin/julia}, un\texttt{DATAROOTDIR} de \texttt{../ share}, y un\texttt{SYSCONFDIR} de \texttt{../ etc} tendrá \texttt{JULIA\_HOME} establecido en \texttt{/bin}, una ruta de búsqueda de archivo fuente de




\begin{lstlisting}
/share/julia/base
\end{lstlisting}



y una ruta de búsqueda de configuración global de




\begin{lstlisting}
/etc/julia/juliarc.jl
\end{lstlisting}



\hypertarget{1363234541366705734}{}


\subsection{\texttt{JULIA\_LOAD\_PATH}}



Una lista separada de rutas absolutas que se anexarán a la variable \hyperlink{17914149694871263675}{\texttt{LOAD\_PATH}}. (En sistemas tipo Unix, el separador de ruta es \texttt{:}; en sistemas Windows, el separador de ruta es \texttt{;}.) La variable \texttt{LOAD\_PATH} es donde \hyperlink{16690217505788642360}{\texttt{Base.require}} y \texttt{Base.load\_in\_path()} busca el código; se predetermina a las rutas absolutas




\begin{lstlisting}
$JULIA_HOME/../local/share/julia/site/v$(VERSION.major).$(VERSION.minor)
$JULIA_HOME/../share/julia/site/v$(VERSION.major).$(VERSION.minor)
\end{lstlisting}



de modo que, por ejemplo, la versión 0.6 de Julia en un sistema Linux con un ejecutable de Julia en \texttt{/bin/julia} tendrá un\texttt{LOAD\_PATH} predeterminado de




\begin{lstlisting}
/local/share/julia/site/v0.6
/share/julia/site/v0.6
\end{lstlisting}



\hypertarget{10906004900633915980}{}


\subsection{\texttt{JULIA\_PKGDIR}}



La ruta del directorio principal \texttt{Pkg.Dir.\_pkgroot()} para los repositorios de paquetes Julia específicos de la versión. Si la ruta es relativa, entonces se toma con respecto al directorio de trabajo. Si \texttt{\$JULIA\_PKGDIR} no está configurado, entonces\texttt{Pkg.Dir.\_pkgroot()}se establece por defecto en




\begin{lstlisting}
$HOME/.julia
\end{lstlisting}



Entonces la localizacíon del repositorio \hyperlink{4800223299836980046}{\texttt{Pkg.dir}} para una versin dada de Julia es




\begin{lstlisting}
$JULIA_PKGDIR/v$(VERSION.major).$(VERSION.minor)
\end{lstlisting}



Por ejemplo, para un usuario Linux cuyo directorio home ea \texttt{/home/alice}, el directorio que contiene los repositorios de paquetes por defecto sería




\begin{lstlisting}
/home/alice/.julia
\end{lstlisting}



y el repositorio de paquetes paa la versión 0.6 de Julia sería




\begin{lstlisting}
/home/alice/.julia/v0.6
\end{lstlisting}



\hypertarget{7464422147684280847}{}


\subsection{\texttt{JULIA\_HISTORY}}



El camino absoluto \texttt{Base.REPL.find\_hist\_file()} del fichero de historia del REPL. Si \texttt{\$JULIA\_HISTORY} no está fijado, encontces \texttt{Base.REPL.find\_hist\_file()} tiene como valor por defecto




\begin{lstlisting}
$HOME/.julia_history
\end{lstlisting}



\hypertarget{12321769564794734949}{}


\subsection{\texttt{JULIA\_PKGRESOLVE\_ACCURACY}}



Un \texttt{Int} positivo que determina cuánto tiempo la subrutina de suma máxima\texttt{MaxSum.maxsum ()}del resolvedor de dependencia de paquetes \hyperlink{246440786291582695}{\texttt{Base.Pkg.resolve}} dedicará a intentar las restricciones satisfactorias antes de abandonar: este valor es por defecto \texttt{1}, y los valores más grandes corresponden a mayores cantidades de tiempo.



Supongamos que el valor de \texttt{\$ JULIA\_PKGRESOLVE\_ACCURACY} es \texttt{n}. Entonces



\begin{itemize}
\item el número de iteraciones de pre-decimación es \texttt{20*n},


\item el número de iteraciones entre los pasos de aniquilación es \texttt{10*n}, y


\item en los pasos de aniquilación, como máximo se destruye uno de cada paquetes \texttt{20*n}.

\end{itemize}


\hypertarget{1317804132185511834}{}


\section{Aplicaciones externas}



\hypertarget{12177211249965413749}{}


\subsection{\texttt{JULIA\_SHELL}}



La ruta absoluta del shell con el que Julia debe ejecutar comandos externos (a través de \texttt{Base.repl\_cmd ()}). Se predetermina a la variable de entorno \texttt{\$SHELL}, y vuelve a \texttt{/bin/sh} si \texttt{\$SHELL} está desactivado.



\begin{quote}
\textbf{Note}

En Windows, esta variable de entorno se ignora y los comandos externos se ejecutan directamente.

\end{quote}


\hypertarget{327473439132778011}{}


\subsection{\texttt{JULIA\_EDITOR}}



El editor devuelto por \texttt{Base.editor()} y utilizado en, por ejemplo, \hyperlink{7044880690333675643}{\texttt{Base.edit}}, refiriéndose al comando del editor preferido, por ejemplo\texttt{vim}.



\texttt{\$JULIA\_EDITOR} tiene prioridad sobre\texttt{\$VISUAL}, que a su vez tiene prioridad sobre \texttt{\$EDITOR}. Si no se establece ninguna de estas variables de entorno, entonces el editor se considera \texttt{abierto} en Windows y OS X, o\texttt{/etc/alternatives/editor} si existe, o \texttt{emacs} de lo contrario.



\begin{quote}
\textbf{Note}

\texttt{\$JULIA\_EDITOR} \emph{no se usa} en la determinación del editor para \hyperlink{3124493295760422384}{\texttt{Base.Pkg.edit}}: esta función verifica \texttt{\$VISUAL} y\texttt{\$EDITOR} solo.

\end{quote}


\hypertarget{7333313418671737474}{}


\section{Paralelización}



\hypertarget{12080077898249568422}{}


\subsection{\texttt{JULIA\_CPU\_CORES}}



Sobreescribe la variable global \hyperlink{8935415573697237606}{\texttt{Base.Sys.CPU\_CORES}}, el número de núcleos de CPU lógicos disponible.



\hypertarget{17625390316676574932}{}


\subsection{\texttt{JULIA\_WORKER\_TIMEOUT}}



Un \hyperlink{5027751419500983000}{\texttt{Float64}} que establece el valor de\texttt{Base.worker\_timeout()} (predeterminado:\texttt{60.0}). Esta función proporciona la cantidad de segundos que un proceso de trabajo esperará un proceso maestro para establecer una conexión antes de morir.



\hypertarget{7328254851646027731}{}


\subsection{\texttt{JULIA\_NUM\_THREADS}}



Un entero sin signo de 64 bits (\texttt{uint64\_t}) que establece el número máximo de subprocesos disponiblew para Julia. Si \texttt{\$JULIA\_NUM\_THREADS} excede la cantidad disponiblede núcleos de CPU físicos, el número de subprocesos se establece en la cantidad de núcleos. Si \texttt{\$JULIA\_NUM\_THREADS} no es positivo o no está configurado, o si el número de núcleos de CPU no se puede determinar a través de llamadas al sistema, entonces la cantidad de hilos es establecida en \texttt{1}.



\hypertarget{10532418503410947704}{}


\subsection{\texttt{JULIA\_THREAD\_SLEEP\_THRESHOLD}}



Si se fija a una cadena que comienza con la subcadena insensible a mayúsculas y minúsculas \texttt{{\textquotedbl}infinite{\textquotedbl}}, entonces los hilos vivos nunva duermen. En caso contrario, \texttt{\$JULIA\_THREAD\_SLEEP\_THRESHOLD} es interpretado como un entero sin signo de 64 bits (\texttt{uint64\_t}) y da, en nanosegundos, la cantidad de tiempo después del cual los hilos deben dormir.



\hypertarget{12794875033848178110}{}


\subsection{\texttt{JULIA\_EXCLUSIVE}}



Si se establece en algo además de \texttt{0}, entonces la política de hilos de Julia es consistente con la ejecución en una máquina dedicada: el hilo maestro está en proc 0, y los hilos están affinitizados. De lo contrario, Julia deja que el sistema operativo maneje la política de hilos.



\hypertarget{8168014885470512347}{}


\section{Formateo del REPL}



Variables de entorno que determinan cómo debe formatearse la salida REPL en el terminal. En general, estas variables deben establecerse en \href{http://ascii-table.com/ansi-escape-sequences.php}{seciencias de scape de terminal ANSI}. Julia proporciona una interfaz de alto nivel con gran parte de la misma funcionalidad: ver la sección sobre \hyperlink{9220662049678686366}{Interacción con Julia}.



\hypertarget{13891100922495428417}{}


\subsection{\texttt{JULIA\_ERROR\_COLOR}}



El formato \texttt{Base.error\_color()} (predeterminado: rojo claro, \texttt{{\textquotedbl}{\textbackslash}033[91m {\textquotedbl}}) que los errores deberían tener en la terminal.



\hypertarget{17711733982596187514}{}


\subsection{\texttt{JULIA\_WARN\_COLOR}}



El formato \texttt{Base.warn\_color()} (preeterminado: amarillo, \texttt{{\textquotedbl}{\textbackslash}033[93m{\textquotedbl}}) que deberían tener las advertencias en el terminal.



\hypertarget{10994657891761481518}{}


\subsection{\texttt{JULIA\_INFO\_COLOR}}



El formato \texttt{Base.info\_color()} (predeterminado: cyan, \texttt{{\textquotedbl}{\textbackslash}033[36m{\textquotedbl}}) que debería tener la info en el terminal. 



\hypertarget{7277467062996316804}{}


\subsection{\texttt{JULIA\_INPUT\_COLOR}}



El formato \texttt{Base.input\_color()} (predeterminado: normal, \texttt{{\textquotedbl}{\textbackslash}033[0m{\textquotedbl}}) que debería haber en el terminal.



\hypertarget{11974933399373427924}{}


\subsection{\texttt{JULIA\_ANSWER\_COLOR}}



El formato \texttt{Base.answer\_color()} (predeterminado:  normal, \texttt{{\textquotedbl}{\textbackslash}033[0m{\textquotedbl}}) que debería haber en el terminal..



\hypertarget{1071250415559095053}{}


\subsection{\texttt{JULIA\_STACKFRAME\_LINEINFO\_COLOR}}



El formato \texttt{Base.stackframe\_lineinfo\_color()} (predeterminado:  bold, \texttt{{\textquotedbl}{\textbackslash}033[1m{\textquotedbl}}) que la línea info debería tener durante una traza de la pila en el terminal.



\hypertarget{15357004504591912181}{}


\subsection{\texttt{JULIA\_STACKFRAME\_FUNCTION\_COLOR}}



El formato \texttt{Base.stackframe\_function\_color()} (predeterminado:  bold, \texttt{{\textquotedbl}{\textbackslash}033[1m{\textquotedbl}}) que las llamadas a funcin deberían tener durante una traza de la pila en el terminal.



\hypertarget{7937407667990775768}{}


\section{Depuración y profiling}



\hypertarget{17935900017233878037}{}


\subsection{\texttt{JULIA\_GC\_ALLOC\_POOL}, \texttt{JULIA\_GC\_ALLOC\_OTHER}, \texttt{JULIA\_GC\_ALLOC\_PRINT}}



Si se establecen, estas variables de entorno toman cadenas que opcionalmente comienzan con el carácter \texttt{{\textquotesingle}r{\textquotesingle}}, seguido por una interpolación de cadenas de una lista separada por dos puntos de tres enteros de 64 bits (\texttt{int64\_t}). Este triplete de enteros \texttt{a:b:c} representa la secuencia aritmética \texttt{a}, \texttt{a + b},\texttt{a + 2*b}, ... \texttt{c}.



\begin{itemize}
\item Si es la {\textquotedbl}n{\textquotedbl} vez que se ha llamado a \texttt{jl\_gc\_pool\_alloc ()}, y \texttt{n} pertenece a la secuencia aritmética  representada por\texttt{\$ JULIA\_GC\_ALLOC\_POOL}, entonces se forzará la recolección de elementos no utilizados.


\item Si es la \texttt{n}th vez que\texttt{maybe\_collect ()}ha sido llamado, y \texttt{n} pertenece a la secuencia aritmética  representada por \texttt{\$JULIA\_GC\_ALLOC\_OTHER}, entonces se forzará la recolección de elementos no utilizados.


\item Si es la \texttt{n} th vez que\texttt{jl\_gc\_collect()} ha sido llamado, y \texttt{n} pertenece a la secuencia aritmética  representada por \texttt{\$JULIA\_GC\_ALLOC\_PRINT}, entonces cuenta para el número de llamadas a \texttt{jl\_gc\_pool\_alloc()} y \texttt{maybe\_collect()} están impresos.

\end{itemize}


Si el valor de la variable de entorno comienza con el carácter \texttt{{\textquotesingle}r{\textquotesingle}}, entonces el intervalo entre los eventos de recolección de basura es aleatorio.



\begin{quote}
\textbf{Note}

Estas variables de entorno solo tienen un efecto si Julia se compiló con la  depuración de la recolección de basura (es decir, si \texttt{WITH\_GC\_DEBUG\_ENV}  se fija a \texttt{1} en la configuración de compilación).

\end{quote}


\hypertarget{15291982466110123243}{}


\subsection{\texttt{JULIA\_GC\_NO\_GENERATIONAL}}



Si se fija a algo por encima de \texttt{0}, entonces el recolector de basura de Julia nunca realizará barridos rápidos de memoria.



\begin{quote}
\textbf{Note}

Esta variable de entorno solo tiene un efecto si Julia se compiló con depuración de recolección de elementos  no utilizados (es decir, si \texttt{WITH\_GC\_DEBUG\_ENV} está establecido en\texttt{1} en la configuración de compilación).

\end{quote}


\hypertarget{4439082668862420182}{}


\subsection{\texttt{JULIA\_GC\_WAIT\_FOR\_DEBUGGER}}



Si se fija a algo por encima de \texttt{0}, entonces el recolector de basura esperará a que un depurador la enlace en lugar de abortar cuando haya un error crítico.



\begin{quote}
\textbf{Note}

Esta variable de entorno solo tiene un efecto si Julia se compiló con depuración de recolección de elementos  no utilizados (es decir, si \texttt{WITH\_GC\_DEBUG\_ENV} está establecido en\texttt{1} en la configuración de compilación).

\end{quote}


\hypertarget{1100661411174026998}{}


\subsection{\texttt{ENABLE\_JITPROFILING}}



Si se fija a un valor por encima de \texttt{0}, entonces el compilador creará y registrará un detector de evaentos (\emph{event listener})  para \emph{for just-in-time (JIT) profiling}.



\begin{quote}
\textbf{Note}

Esta variable de entorno sólo tiene efecto su Julia se compiló con soporte de JIT profiling usando 

\end{quote}


\begin{itemize}
\item \href{https://software.intel.com/en-us/intel-vtune-amplifier-xe}{VTune™ Amplifier} de Intel   (\texttt{USE\_INTEL\_JITEVENTS} set to \texttt{1} in the build configuration), o bien


\item \href{http://oprofile.sourceforge.net/news/}{OProfile} (\texttt{USE\_OPROFILE\_JITEVENTS} set to \texttt{1}   in the build configuration).

\end{itemize}


\hypertarget{12744946110825549407}{}


\subsection{\texttt{JULIA\_LLVM\_ARGS}}



Arguments para pasar al backend de LLVM.



\begin{quote}
\textbf{Note}

Esta variable de entorno sólo tiene efecto su Julia se compiló con \texttt{JL\_DEBUG\_BUILD} fijado — en particular, el ejecutable \texttt{julia-debug} siempre es compilado con esta variable.

\end{quote}


\hypertarget{2233455458339293271}{}


\subsection{\texttt{JULIA\_DEBUG\_LOADING}}



Si se establece, entonces Julia imprime información detallada sobre la caché en el proceso de carga de \hyperlink{16690217505788642360}{\texttt{Base.require}}.



\hypertarget{7688715278401899796}{}


\chapter{Embedding Julia}



As we have seen in \hyperlink{17572913146419880234}{Calling C and Fortran Code}, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C\#).



\hypertarget{2692186280181047639}{}


\section{High-Level Embedding}



We start with a simple C program that initializes Julia and calls some Julia code:




\begin{lstlisting}
#include <julia.h>

int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string("print(sqrt(2.0))");

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



In order to build this program you have to put the path to the Julia header into the include path and link against \texttt{libjulia}. For instance, when Julia is installed to \texttt{\$JULIA\_DIR}, one can compile the above test program \texttt{test.c} with \texttt{gcc} using:




\begin{lstlisting}
gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib test.c -ljulia $JULIA_DIR/lib/julia/libstdc++.so.6
\end{lstlisting}



Then if the environment variable \texttt{JULIA\_HOME} is set to \texttt{\$JULIA\_DIR/bin}, the output \texttt{test} program can be executed.



Alternatively, look at the \texttt{embedding.c} program in the Julia source tree in the \texttt{examples/} folder. The file \texttt{ui/repl.c} program is another simple example of how to set \texttt{jl\_options} options while linking against \texttt{libjulia}.



The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling \texttt{jl\_init}, which tries to automatically determine Julia{\textquotesingle}s install location. If you need to specify a custom location, or specify which system image to load, use \texttt{jl\_init\_with\_image} instead.



The second statement in the test program evaluates a Julia statement using a call to \texttt{jl\_eval\_string}.



Before the program terminates, it is strongly recommended to call \texttt{jl\_atexit\_hook}.  The above example program calls this before returning from \texttt{main}.



\begin{quote}
\textbf{Note}

Currently, dynamically linking with the \texttt{libjulia} shared library requires passing the \texttt{RTLD\_GLOBAL} option. In Python, this looks like:


\begin{lstlisting}
>>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)
>>> julia.jl_init.argtypes = []
>>> julia.jl_init()
250593296
\end{lstlisting}

\end{quote}


\begin{quote}
\textbf{Note}

If the julia program needs to access symbols from the main executable, it may be necessary to add \texttt{-Wl,--export-dynamic} linker flag at compile time on Linux in addition to the ones generated by \texttt{julia-config.jl} described below. This is not necessary when compiling a shared library.

\end{quote}


\hypertarget{7452394744805348324}{}


\subsection{Using julia-config to automatically determine build parameters}



The script \texttt{julia-config.jl} was created to aid in determining what build parameters are required by a program that uses embedded Julia.  This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution.  This script is located in the Julia shared data directory.



\hypertarget{3004524604150878810}{}


\subsubsection{Example}




\begin{lstlisting}
#include <julia.h>

int main(int argc, char *argv[])
{
    jl_init();
    (void)jl_eval_string("println(sqrt(2.0))");
    jl_atexit_hook(0);
    return 0;
}
\end{lstlisting}



\hypertarget{3428797394902131495}{}


\subsubsection{On the command line}



A simple use of this script is from the command line.  Assuming that \texttt{julia-config.jl} is located in \texttt{/usr/local/julia/share/julia}, it can be invoked on the command line directly and takes any combination of 3 flags:




\begin{lstlisting}
/usr/local/julia/share/julia/julia-config.jl
Usage: julia-config [--cflags|--ldflags|--ldlibs]
\end{lstlisting}



If the above example source is saved in the file \texttt{embed\_example.c}, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute \texttt{clang} for \texttt{gcc}.:




\begin{lstlisting}
/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c
\end{lstlisting}



\hypertarget{4427716365208739491}{}


\subsubsection{Use in Makefiles}



But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well – assuming GNU make because of the use of the \textbf{shell} macro expansions.  Additionally, though many times \texttt{julia-config.jl} may be found in the directory \texttt{/usr/local}, this is not necessarily the case, but Julia can be used to locate \texttt{julia-config.jl} too, and the makefile can be used to take advantage of that.  The above example is extended to use a Makefile:




\begin{lstlisting}
JL_SHARE = $(shell julia -e 'print(joinpath(JULIA_HOME,Base.DATAROOTDIR,"julia"))')
CFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
LDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example
\end{lstlisting}



Now the build command is simply \texttt{make}.



\hypertarget{15196043106042315499}{}


\section{Converting Types}



Real applications will not just need to execute expressions, but also return their values to the host program. \texttt{jl\_eval\_string} returns a \texttt{jl\_value\_t*}, which is a pointer to a heap-allocated Julia object. Storing simple data types like \hyperlink{5027751419500983000}{\texttt{Float64}} in this way is called \texttt{boxing}, and extracting the stored primitive data is called \texttt{unboxing}. Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C looks as follows:




\begin{lstlisting}
jl_value_t *ret = jl_eval_string("sqrt(2.0)");

if (jl_typeis(ret, jl_float64_type)) {
    double ret_unboxed = jl_unbox_float64(ret);
    printf("sqrt(2.0) in C: %e \n", ret_unboxed);
}
else {
    printf("ERROR: unexpected return type from sqrt(::Float64)\n");
}
\end{lstlisting}



In order to check whether \texttt{ret} is of a specific Julia type, we can use the \texttt{jl\_isa}, \texttt{jl\_typeis}, or \texttt{jl\_is\_...} functions. By typing \texttt{typeof(sqrt(2.0))} into the Julia shell we can see that the return type is \hyperlink{5027751419500983000}{\texttt{Float64}} (\texttt{double} in C). To convert the boxed Julia value into a C double the \texttt{jl\_unbox\_float64} function is used in the above code snippet.



Corresponding \texttt{jl\_box\_...} functions are used to convert the other way:




\begin{lstlisting}
jl_value_t *a = jl_box_float64(3.0);
jl_value_t *b = jl_box_float32(3.0f);
jl_value_t *c = jl_box_int32(3);
\end{lstlisting}



As we will see next, boxing is required to call Julia functions with specific arguments.



\hypertarget{12323658234921669115}{}


\section{Calling Julia Functions}



While \texttt{jl\_eval\_string} allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using \texttt{jl\_call}:




\begin{lstlisting}
jl_function_t *func = jl_get_function(jl_base_module, "sqrt");
jl_value_t *argument = jl_box_float64(2.0);
jl_value_t *ret = jl_call1(func, argument);
\end{lstlisting}



In the first step, a handle to the Julia function \texttt{sqrt} is retrieved by calling \texttt{jl\_get\_function}. The first argument passed to \texttt{jl\_get\_function} is a pointer to the \texttt{Base} module in which \texttt{sqrt} is defined. Then, the double value is boxed using \texttt{jl\_box\_float64}. Finally, in the last step, the function is called using \texttt{jl\_call1}. \texttt{jl\_call0}, \texttt{jl\_call2}, and \texttt{jl\_call3} functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use \texttt{jl\_call}:




\begin{lstlisting}
jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)
\end{lstlisting}



Its second argument \texttt{args} is an array of \texttt{jl\_value\_t*} arguments and \texttt{nargs} is the number of arguments.



\hypertarget{8210663840912105043}{}


\section{Memory Management}



As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.



Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.



The GC can only run when Julia objects are allocated. Calls like \texttt{jl\_box\_float64} perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between \texttt{jl\_...} calls. But in order to make sure that values can survive \texttt{jl\_...} calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the \texttt{JL\_GC\_PUSH} macros:




\begin{lstlisting}
jl_value_t *ret = jl_eval_string("sqrt(2.0)");
JL_GC_PUSH1(&ret);
// Do something with ret
JL_GC_POP();
\end{lstlisting}



The \texttt{JL\_GC\_POP} call releases the references established by the previous \texttt{JL\_GC\_PUSH}. Note that \texttt{JL\_GC\_PUSH}  is working on the stack, so it must be exactly paired with a \texttt{JL\_GC\_POP} before the stack frame is destroyed.



Several Julia values can be pushed at once using the \texttt{JL\_GC\_PUSH2} , \texttt{JL\_GC\_PUSH3} , and \texttt{JL\_GC\_PUSH4} macros. To push an array of Julia values one can use the  \texttt{JL\_GC\_PUSHARGS} macro, which can be used as follows:




\begin{lstlisting}
jl_value_t **args;
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects
args[0] = some_value;
args[1] = some_other_value;
// Do something with args (e.g. call jl_... functions)
JL_GC_POP();
\end{lstlisting}



The garbage collector also operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the \texttt{jl\_gc\_wb} (write barrier) function like so:




\begin{lstlisting}
jl_value_t *parent = some_old_value, *child = some_young_value;
((some_specific_type*)parent)->field = child;
jl_gc_wb(parent, child);
\end{lstlisting}



It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the \texttt{parent} object was just allocated and garbage collection was not run since then. Remember that most \texttt{jl\_...} functions can sometimes invoke garbage collection.



The write barrier is also necessary for arrays of pointers when updating their data directly. For example:




\begin{lstlisting}
jl_array_t *some_array = ...; // e.g. a Vector{Any}
void **data = (void**)jl_array_data(some_array);
jl_value_t *some_value = ...;
data[0] = some_value;
jl_gc_wb(some_array, some_value);
\end{lstlisting}



\hypertarget{10013959686315797399}{}


\subsection{Manipulating the Garbage Collector}



There are some functions to control the GC. In normal use cases, these should not be necessary.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Function & Description \\
\hline
\texttt{jl\_gc\_collect()} & Force a GC run \\
\hline
\texttt{jl\_gc\_enable(0)} & Disable the GC, return previous state as int \\
\hline
\texttt{jl\_gc\_enable(1)} & Enable the GC,  return previous state as int \\
\hline
\texttt{jl\_gc\_is\_enabled()} & Return current state as int \\
\hline
\end{tabulary}

\end{table}



\hypertarget{11331212931537392185}{}


\section{Working with Arrays}



Julia and C can share array data without copying. The next example will show how this works.



Julia arrays are represented in C by the datatype \texttt{jl\_array\_t*}. Basically, \texttt{jl\_array\_t} is a struct that contains:



\begin{itemize}
\item Information about the datatype


\item A pointer to the data block


\item Information about the sizes of the array

\end{itemize}


To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:




\begin{lstlisting}
jl_value_t* array_type = jl_apply_array_type(jl_float64_type, 1);
jl_array_t* x          = jl_alloc_array_1d(array_type, 10);
\end{lstlisting}



Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:




\begin{lstlisting}
double *existingArray = (double*)malloc(sizeof(double)*10);
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);
\end{lstlisting}



The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call \texttt{free} on the data pointer when the array is no longer referenced.



In order to access the data of x, we can use \texttt{jl\_array\_data}:




\begin{lstlisting}
double *xData = (double*)jl_array_data(x);
\end{lstlisting}



Now we can fill the array:




\begin{lstlisting}
for(size_t i=0; i<jl_array_len(x); i++)
    xData[i] = i;
\end{lstlisting}



Now let us call a Julia function that performs an in-place operation on \texttt{x}:




\begin{lstlisting}
jl_function_t *func = jl_get_function(jl_base_module, "reverse!");
jl_call1(func, (jl_value_t*)x);
\end{lstlisting}



By printing the array, one can verify that the elements of \texttt{x} are now reversed.



\hypertarget{7420178557371558504}{}


\subsection{Accessing Returned Arrays}



If a Julia function returns an array, the return value of \texttt{jl\_eval\_string} and \texttt{jl\_call} can be cast to a \texttt{jl\_array\_t*}:




\begin{lstlisting}
jl_function_t *func  = jl_get_function(jl_base_module, "reverse");
jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);
\end{lstlisting}



Now the content of \texttt{y} can be accessed as before using \texttt{jl\_array\_data}. As always, be sure to keep a reference to the array while it is in use.



\hypertarget{14696119346407960155}{}


\subsection{Multidimensional Arrays}



Julia{\textquotesingle}s multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:




\begin{lstlisting}
// Create 2D array of float64 type
jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);
jl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);

// Get array pointer
double *p = (double*)jl_array_data(x);
// Get number of dimensions
int ndims = jl_array_ndims(x);
// Get the size of the i-th dim
size_t size0 = jl_array_dim(x,0);
size_t size1 = jl_array_dim(x,1);

// Fill array with data
for(size_t i=0; i<size1; i++)
    for(size_t j=0; j<size0; j++)
        p[j + size0*i] = i + j;
\end{lstlisting}



Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling \texttt{jl\_array\_dim}) in order to read as idiomatic C code.



\hypertarget{15281182540313819412}{}


\section{Exceptions}



Julia code can throw exceptions. For example, consider:




\begin{lstlisting}
jl_eval_string("this_function_does_not_exist()");
\end{lstlisting}



This call will appear to do nothing. However, it is possible to check whether an exception was thrown:




\begin{lstlisting}
if (jl_exception_occurred())
    printf("%s \n", jl_typeof_str(jl_exception_occurred()));
\end{lstlisting}



If you are using the Julia C API from a language that supports exceptions (e.g. Python, C\#, C++), it makes sense to wrap each call into \texttt{libjulia} with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.



\hypertarget{6187003825237320013}{}


\subsection{Throwing Julia Exceptions}



When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:




\begin{lstlisting}
if (!jl_typeis(val, jl_float64_type)) {
    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);
}
\end{lstlisting}



General exceptions can be raised using the functions:




\begin{lstlisting}
void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);
\end{lstlisting}



\texttt{jl\_error} takes a C string, and \texttt{jl\_errorf} is called like \texttt{printf}:




\begin{lstlisting}
jl_errorf("argument x = %d is too large", x);
\end{lstlisting}



where in this example \texttt{x} is assumed to be an integer.



\hypertarget{9952244917530713055}{}


\chapter{Paquetes}



Julia tiene un administrador de paquetes incorporado para instalar la funcionalidad añadida y escrita en Julia. También puede instalar bibliotecas externas utilizando el sistema estándar de su sistema operativo para hacerlo, o compilando desde los fuentes. La lista de paquetes Julia registrados se puede encontrar en \href{http://pkg.julialang.org}{http://pkg.julialang.org}. Todos los mandatos del gestor de paquetes se encuentran en el módulo \texttt{Pkg}, incluido en la instalación \texttt{Base} de Julia.



Primero revisaremos los mecanismos de la familia de mandatos de \texttt{Pkg} y luego brindaremos algunas pautas sobre cómo registrar sus paquetes. Asegúrese de leer la siguiente sección sobre las convenciones de nombres de paquetes, las versiones de etiquetado y la importancia de un archivo \texttt{REQUIRE} para cuando esté listo para agregar su código al repositorio de METADATA seleccionado.



\hypertarget{16395747802237759798}{}


\section{Estado de un paquete}



La función \hyperlink{7389584356782450249}{\texttt{Pkg.status()}} imprime un resumen del estado de los paquetes que uno ha instalado. Inicialmente uno no tendrá paquetes instalados:




\begin{minted}{jlcon}
julia> Pkg.status()
INFO: Initializing package repository /Users/stefan/.julia/v0.6
INFO: Cloning METADATA from git://github.com/JuliaLang/METADATA.jl
No packages installed.
\end{minted}



El directorio de paquetes es inicializado automáticamente la primera vez que una ejecute un mandato \texttt{Pkg} que asume su existencia – que incluya \hyperlink{7389584356782450249}{\texttt{Pkg.status()}}. He aquí un conjunto de ejemplo no trivial de paquetes requeridos y adicionales:




\begin{minted}{jlcon}
julia> Pkg.status()
Required packages:
 - Distributions                 0.2.8
 - SHA                           0.3.2
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.6
\end{minted}



Estos paquetes están todos en versiones registradas, administradas por \texttt{Pkg}. Los paquetes pueden estar en estados más complicados, indicados por anotaciones a la derecha de la versión del paquete instalado; estos estados y anotaciones serán explicados a medida que los encontremos. Para el uso programático, \hyperlink{10971725533820181631}{\texttt{Pkg.installed()}} devuelve un diccionario, donde se hacen corresponder los nombres de paquetes instalados con la versión instalada de ese paquete:




\begin{minted}{jlcon}
julia> Pkg.installed()
Dict{String,VersionNumber} with 4 entries:
"Distributions"     => v"0.2.8"
"Stats"             => v"0.2.6"
"SHA"               => v"0.3.2"
"NumericExtensions" => v"0.2.17"
\end{minted}



\hypertarget{13216306495685544934}{}


\section{Añadir y eliminar paquetes}



El administrador de paquetes de Julia es un poco inusual ya que es declarativo en lugar de imperativo. Esto significa que uno le dice lo que quiere y el gestor descubre qué versiones instalar (o eliminar) para satisfacer esos requisitos de manera óptima, - y mínimamente. Por tanto, en lugar de instalar un paquete, simplemente lo agrega a la lista de requisitos y luego {\textquotedbl}resuelve{\textquotedbl} lo que necesita instalar. En particular, esto significa que si algún paquete se ha instalado porque lo necesitaba una versión anterior de algo que usted quería, y una versión más nueva ya no tiene ese requisito, la actualización realmente eliminará ese paquete.



Los requisitos de paquetes están en el archivo \texttt{{\textasciitilde} /.julia/v0.6/REQUIRE}. Este archivo puede ser editado a mano y luego llamarse a \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} para instalar, actualizar o eliminar paquetes para satisfacer de manera óptima los requisitos, o puede hacer \hyperlink{3124493295760422384}{\texttt{Pkg.edit()}}, que abrirá {\textquotesingle}REQUIRE{\textquotesingle} en su editor (configurado a través de las variables de entorno \texttt{EDITOR} o\texttt{VISUAL}), y luego llamará automáticamente a \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} después si es necesario. Si solo desea agregar o eliminar el requisito para un solo paquete, también puede usar los mandatos no interactivos \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} y \hyperlink{13989694063022152176}{\texttt{Pkg.rm()}}, que agregan o eliminan un solo requisito a \texttt{REQUIRE} y luego llaman a \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}}.



Puede agregarse un paquete a la lista de requisitos con la función \hyperlink{10284711283997279340}{\texttt{Pkg.add()}}, y se instalará el paquete y todos los paquetes de los que depende.




\begin{minted}{jlcon}
julia> Pkg.status()
No packages installed.

julia> Pkg.add("Distributions")
INFO: Cloning cache of Distributions from git://github.com/JuliaStats/Distributions.jl.git
INFO: Cloning cache of NumericExtensions from git://github.com/lindahua/NumericExtensions.jl.git
INFO: Cloning cache of Stats from git://github.com/JuliaStats/Stats.jl.git
INFO: Installing Distributions v0.2.7
INFO: Installing NumericExtensions v0.2.17
INFO: Installing Stats v0.2.6
INFO: REQUIRE updated.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.7
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.6
\end{minted}



Lo que está haciendo es primero agregar \texttt{Distribuciones} a su archivo \texttt{{\textasciitilde}/.julia/v0.6/REQUIRE}:




\begin{lstlisting}
$ cat ~/.julia/v0.6/REQUIRE
Distributions
\end{lstlisting}



A continuación, ejecuta \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} utilizando estos nuevos requisitos, lo que lleva a la conclusión de que el paquete \texttt{Distributions} debe instalarse ya que es obligatorio pero no está instalado. Como se dijo anteriormente, puede lograr lo mismo editando su archivo \texttt{{\textasciitilde} /.julia/v0.6/REQUIRE} a mano y luego ejecutando \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} usted mismo:




\begin{minted}{jlcon}
$ echo SHA >> ~/.julia/v0.6/REQUIRE

julia> Pkg.resolve()
INFO: Cloning cache of SHA from git://github.com/staticfloat/SHA.jl.git
INFO: Installing SHA v0.3.2

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.7
 - SHA                           0.3.2
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.6
\end{minted}



Esto es funcionalmente equivalente a llamar a \hyperlink{10284711283997279340}{\texttt{Pkg.add({\textquotedbl}SHA{\textquotedbl})}}, excepto que \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} no cambia \texttt{REQUIRE} hasta \emph{después} de que la instalación haya finalizado, por lo que si hay problemas, \texttt{REQUIRE} quedará como estaba antes de llamar a \hyperlink{10284711283997279340}{\texttt{Pkg.add()}}. El formato del archivo \texttt{REQUIRE} se describe en \hyperlink{5869679324207541494}{Especificación de requisitos}; permite, entre otras cosas, requerir rangos específicos de versiones de paquetes.



Cuando decida que no quiere tener un paquete más, puede usar \hyperlink{13989694063022152176}{\texttt{Pkg.rm()}} para eliminar el requisito del archivo \texttt{REQUIRE}:




\begin{minted}{jlcon}
julia> Pkg.rm("Distributions")
INFO: Removing Distributions v0.2.7
INFO: Removing Stats v0.2.6
INFO: Removing NumericExtensions v0.2.17
INFO: REQUIRE updated.

julia> Pkg.status()
Required packages:
 - SHA                           0.3.2

julia> Pkg.rm("SHA")
INFO: Removing SHA v0.3.2
INFO: REQUIRE updated.

julia> Pkg.status()
No packages installed.
\end{minted}



Una vez más, esto es equivalente a editar el archivo \texttt{REQUIRE} para eliminar la línea con cada nombre de paquete y ejecutar \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} para actualizar el conjunto de paquetes instalados para que coincidan. Mientras que \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} y \hyperlink{13989694063022152176}{\texttt{Pkg.rm()}} son convenientes para agregar y eliminar requisitos para un solo paquete, cuando desea agregar o eliminar paquetes múltiples, puede llamar a \hyperlink{3124493295760422384}{\texttt{Pkg.edit()}} para cambiar manualmente el contenido de \texttt{REQUIRE} y luego actualizar sus paquetes en consecuencia. \hyperlink{3124493295760422384}{\texttt{Pkg.edit()}} no retrotrae el contenido de \texttt{REQUIRE} si \hyperlink{246440786291582695}{\texttt{Pkg.resolve()}} falla, sino que debe ejecutar \hyperlink{3124493295760422384}{\texttt{Pkg.edit()}} otra vez para corregir el contenido de los archivos uno mismo.



Debido a que el administrador de paquetes usa libgit2 internamente para administrar los repositorios git del paquete, los usuarios pueden encontrarse con problemas de protocolo (por ejemplo, si están detrás de un \emph{firewall}) al ejecutar \hyperlink{10284711283997279340}{\texttt{Pkg.add()}}. Por defecto, se accederá a todos los paquetes alojados por GitHub a través de {\textquotesingle}https{\textquotesingle}; este valor predeterminado se puede modificar llamando a \hyperlink{16637824229915276013}{\texttt{Pkg.setprotocol!()}}. El siguiente comando se puede ejecutar desde la línea de comando para decirle a git que use {\textquotesingle}https{\textquotesingle} en lugar del protocolo {\textquotesingle}git{\textquotesingle} cuando clona todos los repositorios, dondequiera que estén alojados:




\begin{lstlisting}
git config --global url."https://".insteadOf git://
\end{lstlisting}



Sin embargo, este cambio será en todo el sistema y, por lo tanto, es preferible utilizar \hyperlink{16637824229915276013}{\texttt{Pkg.setprotocol!()}}.



\begin{quote}
\textbf{Note}

Las funciones del administrador de paquetes también aceptan el sufijo \texttt{.jl} sobre los nombres de paquetes, aunque el sufijo sea eliminado internamente. Por ejemplo:


\begin{minted}{julia}
Pkg.add("Distributions.jl")
Pkg.rm("Distributions.jl")
\end{minted}

\end{quote}


\hypertarget{14335377459201516768}{}


\section{Instalación de paquetes fuera de línea}



Para las máquinas sin conexión a Internet, los paquetes se pueden instalar copiando el directorio raíz del paquete (proporcionado por \hyperlink{4800223299836980046}{\texttt{Pkg.dir()}}) desde una máquina con el mismo sistema operativo y entorno.



\hyperlink{10284711283997279340}{\texttt{Pkg.add()}} hace lo siguiente dentro del directorio raíz del paquete:



\begin{itemize}
\item[1. ] Agrega el nombre del paquete a \texttt{REQUIRE}.


\item[2. ] Descarga el paquete en \texttt{.cache}, luego copia el paquete en el directorio raíz del paquete.


\item[3. ] Realiza recursivamente el paso 2 contra todos los paquetes enumerados en el archivo \texttt{REQUIRE} del paquete.


\item[4. ] Ejecuta \hyperlink{8295561239210722937}{\texttt{Pkg.build()}}

\end{itemize}


\begin{quote}
\textbf{Warning}

Copiar paquetes instalados desde una máquina diferente es frágil para paquetes que requieren dependencias  externas binarias. Dichos paquetes pueden romperse debido a diferencias en las versiones del sistema  operativo, entornos de compilación y / o dependencias absolutas de rutas.

\end{quote}


\hypertarget{9054555393221352388}{}


\section{Instalar paquetes no registrados}



Los paquetes de Julia son simplemente repositorios git, clonables a través de cualquiera de los \href{https://www.kernel.org/pub/software/scm/git/docs/git-clone.html\#URLS}{protocolos} que admite git, y que contienen código Julia que sigue ciertas convenciones de diseño. Los paquetes oficiales de Julia están registrados en el repositorio \href{https://github.com/JuliaLang/METADATA.jl}{METADATA.jl}, disponible en una ubicación conocida \footnotemark[1]. Los mandatos \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} y \hyperlink{13989694063022152176}{\texttt{Pkg.rm()}} de la sección anterior interactúan con los paquetes registrados, pero el administrador de paquetes también puede instalar y trabajar con paquetes no registrados. Para instalar un paquete no registrado, usaremos \hyperlink{12404258328199389568}{\texttt{Pkg.clone(url)}}, donde \texttt{url} es una URL de git desde la cual se puede clonar el paquete:




\begin{minted}{jlcon}
julia> Pkg.clone("git://example.com/path/to/Package.jl.git")
INFO: Cloning Package from git://example.com/path/to/Package.jl.git
Cloning into 'Package'...
remote: Counting objects: 22, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 22 (delta 8), reused 22 (delta 8)
Receiving objects: 100% (22/22), 2.64 KiB, done.
Resolving deltas: 100% (8/8), done.
\end{minted}



Por convención, los nombres de los repositorios de Julia terminan con \texttt{.jl} (el \texttt{.git} adicional indica un repositorio {\textquotedbl}vacío{\textquotedbl} de git), lo que evita que colisionen con los repositorios de otros lenguajes, y también hace que los paquetes de Julia sean fáciles de encontrar en los motores de búsqueda. Sin embargo, cuando los paquetes están instalados en su directorio \texttt{.julia/v0.6}, la extensión es redundante, por lo que la dejamos fuera.



Si los paquetes no registrados contienen un archivo \texttt{REQUIRE} en la parte superior de su árbol fuente, ese archivo se usará para determinar de qué paquetes registrados depende el paquete no registrado, y se instalarán automáticamente. Los paquetes no registrados participan en la misma lógica de resolución de versiones que los paquetes registrados, por lo que las versiones de paquetes instalados se ajustarán según sea necesario para satisfacer los requisitos de los paquetes registrados y no registrados.



\footnotetext[1]{El conjunto oficial de paquetes está en  [https://github.com/JuliaLang/METADATA.jl(https://github.com/JuliaLang/METADATA.jl),  pero los individuos y las organizaciones pueden usar fácilmente un repositorio de  metadatos diferente. Esto permite controlar qué paquetes están disponibles para la i nstalación automática. Solo se pueden permitir versiones de paquete auditadas y aprobadas,  y hacer paquetes privados u horquillas disponibles. Ver \hyperlink{5259816761388614368}{Repositorio METADATA personalizado} para más detalles.

}


\hypertarget{1162022872513249443}{}


\section{Actualizando Paquetes}



Cuando los desarrolladores de paquetes publican nuevas versiones registradas de los paquetes que está utilizando, por supuesto, querrá las nuevas versiones brillantes. Para obtener las últimas y mejores versiones de todos sus paquetes, simplemente haga \hyperlink{14197801802374863313}{\texttt{Pkg.update()}}:



When package developers publish new registered versions of packages that you{\textquotesingle}re using, you will, of course, want the new shiny versions. To get the latest and greatest versions of all your packages, just do \hyperlink{14197801802374863313}{\texttt{Pkg.update()}}:




\begin{minted}{jlcon}
julia> Pkg.update()
INFO: Updating METADATA...
INFO: Computing changes...
INFO: Upgrading Distributions: v0.2.8 => v0.2.10
INFO: Upgrading Stats: v0.2.7 => v0.2.8
\end{minted}



El primer paso para actualizar paquetes es generar nuevos cambios en \texttt{{\textasciitilde}/.julia/v0.6/ METADATA} y ver si se ha publicado alguna nueva versión del paquete registrado. Después de esto, \hyperlink{14197801802374863313}{\texttt{Pkg.update()}} intenta actualizar paquetes que están desprotegidos en una rama y no están sucios (es decir, no se han realizado cambios a los archivos rastreados por git) al extraer los cambios del repositorio en sentido ascendente del paquete. Los cambios en sentido ascendente solo se aplicarán si no es necesaria la fusión o rebase, es decir, si la rama puede ser \href{https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging}{{\textquotedbl}fast-forwarded{\textquotedbl}}. Si la rama no se puede reenviar rápidamente, se supone que está trabajando en ella y actualizará el repositorio usted mismo.



Finalmente, el proceso de actualización vuelve a calcular un conjunto óptimo de versiones de paquetes a tener instalado para satisfacer sus requisitos de nivel superior y los requisitos de paquetes {\textquotedbl}fijos{\textquotedbl}. Un paquete es considerado corregido si es uno de los siguientes:



\begin{itemize}
\item[1. ] \textbf{No registrado:} el paquete no está en \texttt{METADATA} - uno lo instaló con \hyperlink{12404258328199389568}{\texttt{Pkg.clone()}}.


\item[2. ] \textbf{Retirado:} el repositorio del paquete está en una rama de desarrollo.


\item[3. ] \textbf{Sucio:} se han realizado cambios a los archivos en el repositorio.

\end{itemize}


Si cualquiera de estos es el caso, el administrador del paquete no puede cambiar libremente la versión instalada de el paquete, por lo que sus requisitos deben ser satisfechos por cualquier otra versión del paquete que elija. La combinación de requisitos de nivel superior en \texttt{{\textasciitilde}/.julia/v0.6/REQUIRE} y el requisito de requisitos fijos los paquetes se usan para determinar qué se debe instalar.



También puede actualizar solo un subconjunto de los paquetes instalados, proporcionando argumentos a la función \hyperlink{14197801802374863313}{\texttt{Pkg.update}}. En ese caso, solo los paquetes proporcionados como argumentos y sus dependencias serán actualizados:




\begin{minted}{jlcon}
julia> Pkg.update("Example")
INFO: Updating METADATA...
INFO: Computing changes...
INFO: Upgrading Example: v0.4.0 => 0.4.1
\end{minted}



Este proceso de actualización parcial todavía calcula el nuevo conjunto de versiones de paquetes de acuerdo con los requisitos de nivel superior y los paquetes {\textquotedbl}fijos{\textquotedbl}, pero considera además todos los demás paquetes, excepto los explícitamente proporcionados, y sus dependencias, como corregidas.



\hypertarget{7300017143347297563}{}


\section{Pago, Pin y Gratis}



Puede querer usar la versión \texttt{maestra} de un paquete en lugar de una de sus versiones registradas. Es posible que haya correcciones o funcionalidades que necesite y que aún no se hayan publicado en ninguna versión registrada, o puede que sea un desarrollador del paquetes y necesite realizar cambios en \texttt{master} o en alguna otra rama de desarrollo. En tales casos, puede hacer \hyperlink{13289698592044275412}{\texttt{Pkg.checkout(pkg)}} para verificar la rama \texttt{master} de\texttt{pkg} o \hyperlink{13289698592044275412}{\texttt{Pkg.checkout(pkg, branch)}} para verificar alguna otra rama:




\begin{minted}{jlcon}
julia> Pkg.add("Distributions")
INFO: Installing Distributions v0.2.9
INFO: Installing NumericExtensions v0.2.17
INFO: Installing Stats v0.2.7
INFO: REQUIRE updated.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7

julia> Pkg.checkout("Distributions")
INFO: Checking out Distributions master...
INFO: No packages to install, update or remove.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9+             master
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7
\end{minted}



Inmediatamente después de instalar \texttt{Distributions} con \hyperlink{10284711283997279340}{\texttt{Pkg.add()}} está en la versión registrada más reciente actual - \texttt{0.2.9} en el momento de escribir esto. Luego, después de ejecutar \hyperlink{13289698592044275412}{\texttt{Pkg.checkout({\textquotedbl}Distributions{\textquotedbl})}}, puede ver en la salida de \hyperlink{7389584356782450249}{\texttt{Pkg.status()}} que \texttt{Distributions} está en una versión no registrada mayor que \texttt{0.2.9}, indicado por el número de {\textquotedbl}pseudo-versión{\textquotedbl} \texttt{0.2.9+}.



Cuando compra una versión no registrada de un paquete, la copia del archivo \texttt{REQUIRE} en el repositorio del paquete tiene prioridad sobre cualquier requisito registrado en \texttt{METADATA}, por lo que es importante que los desarrolladores mantengan este archivo exacto y actualizado, lo que refleja los requisitos reales de la versión actual del paquete. Si el archivo \texttt{REQUIRE} en el repositorio del paquete es incorrecto o falta, las dependencias se pueden eliminar cuando se desprotege el paquete. Este archivo también se usa para completar las versiones del paquete publicadas recientemente si utiliza la API que \texttt{Pkg} proporciona para esto (que se describe a continuación).



Cuando decide que ya no desea tener un paquete desprotegido en una rama, puede {\textquotedbl}liberarlo{\textquotedbl} de nuevo al control del administrador de paquetes con \hyperlink{17638373134027476185}{\texttt{Pkg.free(pkg)}}:




\begin{minted}{jlcon}
julia> Pkg.free("Distributions")
INFO: Freeing Distributions...
INFO: No packages to install, update or remove.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7
\end{minted}



Después de esto, dado que el paquete está en una versión registrada y no en una sucursal, su versión se actualizará a medida que se publiquen nuevas versiones registradas del paquete.



Si desea fijar un paquete en una versión específica para que llamar \hyperlink{14197801802374863313}{\texttt{Pkg.update()}} no cambie la versión en la que está el paquete, puede usar \hyperlink{5411776221154476292}{\texttt{Pkg.pin()}} función:




\begin{minted}{jlcon}
julia> Pkg.pin("Stats")
INFO: Creating Stats branch pinned.47c198b1.tmp

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7              pinned.47c198b1.tmp
\end{minted}



Después de esto, el paquete \texttt{Stats} permanecerá anclado en la versión\texttt{0.2.7} - o más específicamente, en el \texttt{commit  47c198b1}, pero como las versiones están asociadas permanentemente a un hash git dado, esto es lo mismo. \hyperlink{5411776221154476292}{\texttt{Pkg.pin()}} funciona creando una rama descartable para la confirmación a la que desea fijar el paquete y luego verificando esa ramificación. De forma predeterminada, fija un paquete en la confirmación actual, pero puede elegir una versión diferente pasando un segundo argumento:




\begin{minted}{jlcon}
julia> Pkg.pin("Stats",v"0.2.5")
INFO: Creating Stats branch pinned.1fd0983b.tmp
INFO: No packages to install, update or remove.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.5              pinned.1fd0983b.tmp
\end{minted}



Ahora el paquete \texttt{Stats} está anclado en \texttt{commit 1fd0983b}, que corresponde a la versión \texttt{0.2.5}. Cuando decides {\textquotedbl}desanclar{\textquotedbl} un paquete y dejar que el administrador de paquetes lo actualice nuevamente, puedes usar \hyperlink{17638373134027476185}{\texttt{Pkg.free()}} como lo harías para deshacerte de cualquier rama:




\begin{minted}{jlcon}
julia> Pkg.free("Stats")
INFO: Freeing Stats...
INFO: No packages to install, update or remove.

julia> Pkg.status()
Required packages:
 - Distributions                 0.2.9
Additional packages:
 - NumericExtensions             0.2.17
 - Stats                         0.2.7
\end{minted}



Después de esto, el paquete \texttt{Stats} es gestionado nuevamente por el administrador del paquete, y las futuras llamadas a \hyperlink{14197801802374863313}{\texttt{Pkg.update()}} lo actualizarán a versiones más nuevas cuando se publiquen. La rama descartable \texttt{pinned.1fd0983b.tmp} permanece en el repositorio local de\texttt{Stats}, pero como las ramas de git son extremadamente livianas, esto realmente no importa; si desea limpiarlos, puede acceder al repositorio y eliminar esas ramas \footnotemark[2].



\footnotetext[2]{Los paquetes que no están en las ramas también se marcarán como sucios si realiza cambios en el repositorio,  pero eso es menos común.

}


\hypertarget{5259816761388614368}{}


\section{Repositorio METADATA Personalizado}



Por defecto, Julia supone que utilizará el \href{https://github.com/JuliaLang/METADATA.jl}{repositorio oficial METADATA.jl} para descargar e instalar paquetes. También podemos proporcionar una ubicación de repositorio de metadatos diferente. Un enfoque común es mantener nuestra rama \texttt{metadata-v2} actualizada con la rama oficial de Julia y agregar otra rama con sus paquetes personalizados. Puede inicializar su repositorio de metadatos local utilizando esa ubicación y rama personalizadas y luego volver a establecer la base de nuestra rama personalizada con la rama oficial \texttt{metadata-v2}. Para utilizar un repositorio y una sucursal personalizados, utilice el siguiente mandato:




\begin{minted}{jlcon}
julia> Pkg.init("https://me.example.com/METADATA.jl.git", "branch")
\end{minted}



El argumento de la rama es opcional y se predetermina a \texttt{metadata-v2}. Una vez inicializado, un archivo llamado \texttt{META\_BRANCH} en su ruta \texttt{{\textasciitilde}/.julia/vX.Y/} hará un seguimiento de la rama con la que se inicializó su repositorio METADATA. Si desea cambiar de rama, necesitará modificar el archivo \texttt{META\_BRANCH} directamente (¡tenga cuidado!) O elimine el directorio\texttt{vX.Y} y reinicie su repositorio METADATA utilizando el mandato \texttt{Pkg.init}.



\hypertarget{1291144519806895574}{}


\chapter{Desarrollo de Paquetes}



El administrador de paquetes de Julia está diseñado para que cuando tenga un paquete instalado, ya pueda ver su código fuente y el historial completo de desarrollo. También puede realizar cambios en los paquetes, enviarlos por git y contribuir fácilmente a las correcciones y mejoras en el flujo ascendente. Del mismo modo, el sistema está diseñado para que, si desea crear un nuevo paquete, la forma más sencilla de hacerlo sea dentro de la infraestructura proporcionada por el administrador de paquetes.



\hypertarget{10119090900086482810}{}


\section{Initial Setup}



Dado que los paquetes son repositorios de git, antes de realizar cualquier desarrollo de paquete, tenemos que fijar los siguientes ajustes de configuración de git global estándar:




\begin{lstlisting}
$ git config --global user.name "FULL NAME"
$ git config --global user.email "EMAIL"
\end{lstlisting}



donde \texttt{FULL NAME} es su nombre completo actual (se permiten espacios entre las comillas dobles) y\texttt{EMAIL} es su dirección de correo electrónico real. Aunque no es necesario usar \href{https://github.com/}{GitHub} para crear o publicar paquetes de Julia, la mayoría de los paquetes de Julia al momento de escribir esto están alojados en GitHub y el administrador de paquetes sabe cómo formatear correctamente las URL de origen. y de lo contrario trabajar con el servicio sin problemas. Le recomendamos que cree una \href{https://github.com/join}{cuenta gratuita} en GitHub y luego haga lo siguiente:




\begin{lstlisting}
$ git config --global github.user "USERNAME"
\end{lstlisting}



donde \texttt{USERNAME} es nuestro nombre real de usuario en GitHub. Una vez que hace esto, el administrador de paquetes reconoce el nombre de usuario GitHub y puede configurar las cosas en consecuencia. También debemos \href{https://github.com/login?return\_to=https\%3A\%2F\%2Fgithub.com\%2Fsettings\%2Fssh}{cargar} nuestra clave pública SSH a GitHub y configurar un \href{https://linux.die.net/man/1/ssh-agent}{agente SSH} en nuestra máquina de desarrollo para que pueda realizar cambios con una molestia mínima. En el futuro, haremos que este sistema sea extensible y admitiremos otras opciones comunes de alojamiento git como \href{https://bitbucket.org}{BitBucket} y permitiremos a los desarrolladores elegir su favorito. Como las funciones de desarrollo del paquete se han movido al paquete \href{https://github.com/JuliaLang/PkgDev.jl}{PkgDev}, debe ejecutar \texttt{Pkg.add ({\textquotedbl}PkgDev{\textquotedbl}); import PkgDev} para acceder a las funciones que comienzan con \texttt{PkgDev} en el documento siguiente.



\hypertarget{2564140551144534965}{}


\section{Hacer cambios a un paquete existente}



\hypertarget{13670362755681341276}{}


\subsection{Cambios en la Documentación}



Si desea mejorar la documentación en línea de un paquete, el enfoque más fácil (al menos para pequeños cambios) es utilizar la funcionalidad de edición en línea de GitHub. Primero, vaya a la {\textquotedbl}página de inicio{\textquotedbl} de GitHub del repositorio, busque el archivo (por ejemplo, \texttt{README.md}) dentro de la estructura de carpetas del repositorio y haga clic en él. Verá el contenido que se muestra, junto con un pequeño icono de {\textquotedbl}lápiz{\textquotedbl} en la esquina superior derecha. Al hacer clic en ese icono, se abre el archivo en modo de edición. Realice los cambios, escriba un breve resumen que describa los cambios que desea realizar (este es su \emph{mensaje de confirmación}), y luego presione {\textquotedbl}Proponer cambio de archivo{\textquotedbl}. Sus cambios serán enviados para su consideración por el propietario (s) del paquete y sus colaboradores.



Para cambios de documentación más grandes, y especialmente aquellos que espera tener que actualizar en respuesta a los comentarios, puede que le resulte más fácil utilizar el procedimiento para los cambios de código que se describe a continuación.



\hypertarget{6602410166309909939}{}


\subsection{Caambios en el Código}



\hypertarget{2777112252278821454}{}


\subsubsection{Resumen Ejecutivo}



Aquí suponemos que ya ha configurado git en su máquina local y tiene una cuenta de GitHub (consulte más arriba). Imaginemos que está solucionando un error en el paquete \texttt{Images}:




\begin{lstlisting}
Pkg.checkout("Images")           # check out the master branch
<here, make sure your bug is still a bug and hasn't been fixed already>
cd(Pkg.dir("Images"))
;git checkout -b myfixes         # create a branch for your changes
<edit code>                      # be sure to add a test for your bug
Pkg.test("Images")               # make sure everything works now
;git commit -a -m "Fix foo by calling bar"   # write a descriptive message
using PkgDev
PkgDev.submit("Images")
\end{lstlisting}



La última línea le presentará un enlace para enviar una solicitud de extracción para incorporar sus cambios.



\hypertarget{9311192580718322072}{}


\subsubsection{Descripción Detallada}



Si desea corregir un error o agregar una nueva funcionalidad, desea poder probar los cambios antes de enviarlos para su consideración. También debe tener una manera fácil de actualizar su propuesta en respuesta a los comentarios del propietario del paquete. En consecuencia, en este caso, la estrategia es trabajar localmente en su propia máquina; una vez que esté satisfecho con sus cambios, los envía para su consideración. Este proceso se llama \emph{solicitud de extracción} porque usted está solicitando {\textquotedbl}extraer{\textquotedbl} sus cambios en el repositorio principal del proyecto. Debido a que el repositorio en línea no puede ver el código en su máquina privada, primero * envía * sus cambios a una ubicación visible públicamente, su propio * fork * en línea del paquete (alojado en su propia cuenta personal de GitHub).



Supongamos que ya tiene instalado el paquete \texttt{Foo}. En la siguiente descripción, todo lo que comience con \texttt{Pkg} o\texttt{PkgDev} debe escribirse en el prompt de Julia; cualquier cosa que comience con \texttt{git} debe escribirse en \hyperlink{17654100848947676892}{modo de shell de julia} (o usando el shell que viene con su sistema operativo). Dentro de Julia, puedes combinar estos dos modos:




\begin{minted}{jlcon}
julia> cd(Pkg.dir("Foo"))          # go to Foo's folder

shell> git command arguments...    # command will apply to Foo
\end{minted}



Ahora supongamos que está listo para hacer algunos cambios en \texttt{Foo}. Si bien hay varios enfoques posibles, aquí hay uno que se utiliza ampliamente:



\begin{itemize}
\item Desde el prompt de Julia, escriba \hyperlink{13289698592044275412}{\texttt{Pkg.checkout({\textquotedbl}Foo{\textquotedbl})}}. Esto garantiza que está ejecutando  el último código (la rama \texttt{master}), en lugar de cualquier copia de la {\textquotedbl}versión oficial{\textquotedbl} que haya instalado.  (Si planea corregir un error, en este punto es una buena idea verificar nuevamente si el error ya ha sido  corregido por otra persona. Si lo ha hecho, puede solicitar que se etiquete un nuevo lanzamiento oficial  para que la corrección se distribuya al resto de la comunidad). Si recibe un error \texttt{Foo is dirty, bailing},  consulte \hyperlink{1603073439226781612}{Paquetes sucios} a continuación.


\item Crea una rama para tus cambios: navega a la carpeta del paquete (la que Julia informa desde  \hyperlink{4800223299836980046}{\texttt{Pkg.dir({\textquotedbl}Foo{\textquotedbl})}}) y (en modo shell) crea una nueva rama usando \texttt{git checkout -b <newbranch>},  donde \texttt{<newbranch>} podría ser un nombre descriptivo (por ejemplo,\texttt{fixbar}). Al crear una rama, se  asegura de que pueda moverse fácilmente entre su nuevo trabajo y la rama actual {\textquotesingle}principal{\textquotesingle} (consulte  \href{https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell}{https://git-scm.com/book/es/v2/Git-Branching-Branches-in-a-Nutshell}).

\end{itemize}


Si olvida hacer este paso hasta que haya realizado algunos cambios, no se preocupe: consulte \hyperlink{1840922819273614147}{más detalles sobre la bifurcación} a continuación.



\begin{itemize}
\item Haz tus cambios. Ya sea para corregir un error o agregar una nueva funcionalidad, en la mayoría de los casos tu  cambio debería incluir actualizaciones para las carpetas \texttt{src/} y \texttt{test/}. Si estás solucionando un error, agrega  un ejemplo mínimo que demuestre el error (en el código actual) al conjunto de pruebas; al contribuir con una  prueba para el error, te aseguras de que el error no vuelva a aparecer accidentalmente en algún momento posterior  debido a otros cambios. Si agregas una nueva funcionalidad, la creación de pruebas le demuestra al propietario  del paquete que te has asegurado de que el código funcione según lo previsto.


\item Ejecuta las pruebas del paquete y asegúrate de que pasen. Hay varias formas de ejecutar las pruebas:

\begin{itemize}
\item Desde Julia, ejecuta \hyperlink{9222688485458908711}{\texttt{Pkg.test({\textquotedbl}Foo{\textquotedbl})}}: esto ejecutará tus pruebas en un proceso  separado (nuevo) \texttt{julia}.


\item Desde Julia, \texttt{include({\textquotedbl}runtests.jl{\textquotedbl})} desde la carpeta \texttt{test/} del paquete (es posible que el  archivo tenga un nombre diferente, busque uno que ejecute todas las pruebas): esto te permite  ejecutar las pruebas repetidamente en la misma sesión sin volver a cargar todo el código del  paquete; para paquetes que tardan un poco en cargarse, esto puede ser mucho más rápido. Con  este enfoque, debes hacer un trabajo adicional para realizar  \hyperlink{14117620934191882930}{cambios en el código del paquete}.


\item Desde el shell, ejecute \texttt{julia ../test / runtests.jl} desde dentro de la carpeta\texttt{src /}del  paquete.

\end{itemize}

\item Confirma tus cambios: consulte \href{https://git-scm.com/book/es/v2/Git-Basics-Recording-Changes-to-the-Repository}{https://git-scm.com/book/es/v2/Git-Basics-Recording-Changes-to-the-Repository}.


\item Envía tus cambios: desde el prompt de Julia, escribe \texttt{PkgDev.submit({\textquotedbl}Foo{\textquotedbl})}. Esto impulsará los  cambios a la bifurcacion de GitHub y la creará si aún no existe. (Si encuentras un error,  \hyperlink{10119090900086482810}{asegúrate de haber configurado tus claves SSH}.) Julia le dará un  hipervínculo; abra ese enlace, edite el mensaje y luego haga clic en {\textquotedbl}enviar{\textquotedbl}. En ese momento,  se notificará al propietario del paquete de sus cambios y podrá iniciar el debate.  (Si te sientes cómodo con git, también puedes hacer estos pasos manualmente desde el shell).


\item El propietario del paquete puede sugerir mejoras adicionales. Para responder a esas sugerencias,  puede actualizar fácilmente la solicitud de extracción (esto solo funciona para cambios que aún  no se han fusionado, para solicitudes de extracción fusionadas, realice nuevos cambios iniciando  una nueva rama):

\begin{itemize}
\item Si ha cambiado ramas mientras tanto, asegúrese de volver a la misma rama con \texttt{git checkout fixbar} 

\end{itemize}
(del modo shell) o \hyperlink{13289698592044275412}{\texttt{Pkg.checkout({\textquotedbl}Foo{\textquotedbl}, {\textquotedbl}fixbar{\textquotedbl})}} (del prompt de Julia).

\begin{itemize}
\item Como arriba, haga sus cambios, ejecute las pruebas y comprometa sus cambios.


\item Desde el shell, escribe \texttt{git push}. Esto agregará sus nuevas confirmaciones a la misma solicitud  de extracción; debería verlos aparecer automáticamente en la página que contiene la discusión de  su solicitud de extracción.

\end{itemize}
\end{itemize}


Un posible tipo de cambio que el propietario puede solicitar es que elimine sus compromisos. Ver \hyperlink{7222706544523187857}{Squashing} a continuación.



\hypertarget{1603073439226781612}{}


\subsection{Paquetes Sucios}



Si no se pueden cambiar las ramas porque el administrador del paquete se queja de que su paquete está sucio, significa que tiene algunos cambios que no se han confirmado (enviado). Desde el shell, use \texttt{git diff} para ver cuáles son estos cambios; puede descartarlos (\texttt{git checkout changedfile.jl}) o confirmarlos antes de cambiar de rama. Si no puede resolver los problemas manualmente, como último recurso, puede eliminar toda la carpeta \texttt{{\textquotedbl}Foo{\textquotedbl}} y reinstalar una nueva copia con \hyperlink{10284711283997279340}{\texttt{Pkg.add({\textquotedbl}Foo{\textquotedbl})}}. Naturalmente, esto borra cualquier cambio que haya realizado.



\hypertarget{1840922819273614147}{}


\subsection{Haciendo una Rama \emph{post hoc}}



Especialmente para los recién llegados a git, uno a menudo se olvida de crear una nueva rama hasta después de que ya se hayan hecho algunos cambios. Si todavía no has organizado ni comprometido tus cambios, puedes crear una nueva rama con \texttt{git checkout -b <newbranch>} como siempre - git te mostrará amablemente que algunos archivos han sido modificados y creará la nueva rama para ti. \emph{Sus cambios aún no se han comprometido a esta nueva rama}, por lo que las reglas de trabajo normales aún se aplican.



Sin embargo, si ya has hecho un commit a \texttt{master} pero deseas volver al\texttt{master} oficial (llamado \texttt{origin/master}), utiliza el siguiente procedimiento:



\begin{itemize}
\item Crea una nueva rama. Esta rama mantendrá tus cambios.


\item Asegúrate de que todo esté comprometido con esta rama.


\item \texttt{git checkout master}. Si esto no funciona, \emph{no} continúes hasta que hayas resuelto los problemas, o puedes perder los cambios.


\item \emph{Restablece} \texttt{master} (tu rama actual) a un estado anterior con \texttt{git reset --hard origin/master} (ver \href{https://git-scm.com/blog/2011/07/11/reset.html}{https://git-scm.com/blog/2011/07/11/reset.html}).

\end{itemize}


Esto requiere un poco más de familiaridad con git, por lo que es mucho mejor tener el hábito de crear una rama desde el principio.



\hypertarget{7222706544523187857}{}


\subsection{Squashing and rebasing}



Dependiendo de los gustos del propietario(s) del paquete, él podrá pedirte que {\textquotedbl}squash{\textquotedbl} tus compromisos. Esto es especialmente probable si el cambio es bastante simple, pero su historial de compromiso se ve así:




\begin{lstlisting}
WIP: add new 1-line whizbang function (currently breaks package)
Finish whizbang function
Fix typo in variable name
Oops, don't forget to supply default argument
Split into two 1-line functions
Rats, forgot to export the second function
...
\end{lstlisting}



Esto entra en el territorio del uso de git más avanzado, y se te anima a leer un poco ([https://git-scm.com/book/en/v2/Git-Branching-Rebasing]]https://git -scm.com/book/en/v2/Git-Branching-Rebasing)). Sin embargo, un breve resumen del procedimiento es el siguiente:



\begin{itemize}
\item Para protegerse del error, comienza desde tu rama \texttt{fixbar} y crea una nueva rama con\texttt{git checkout -b fixbar\_backup}. Como has comenzado desde \texttt{fixbar}, esta será una copia. Ahora vuelve a la que intentas modificar con \texttt{git checkout fixbar}.


\item Desde el shell, escribe \texttt{git rebase -i origin/master}.


\item Para combinar confirmaciones, cambia \texttt{pick} por \texttt{squash} (para opciones adicionales, consulta otras fuentes). Guarda el archivo y cierre la ventana del editor.


\item Edita el mensaje de confirmación combinado.

\end{itemize}


Si la operación de rebase funciona mal, puedes volver al principio para intentarlo de nuevo de esta manera:




\begin{lstlisting}
git checkout fixbar
git reset --hard fixbar_backup
\end{lstlisting}



Ahora supongamos que has realizado la operación de rebase con éxito. Como el repositorio \texttt{fixbar} ahora se ha separado del que está en tu fork GitHub, vas a tener que hacer un \emph{force push}:



\begin{itemize}
\item Para que sea fácil referirse a tu rama GitHub, cree un {\textquotedbl}manejador{\textquotedbl} para ella con \texttt{git remote add myfork https://github.com/myaccount/Foo.jl.git}, donde la URL proviene de la {\textquotedbl}URL de clonación{\textquotedbl} en la página de tu bifurcación de GitHub.


\item Para que sea fácil referirse a tu rama GitHub, cree un {\textquotedbl}manejador{\textquotedbl} para ella con \texttt{git remote add myfork https://github.com/myaccount/Foo.jl.git},


\item Fuerza el push a tu bifurcación con \texttt{git push myfork+fixbar}. El \texttt{+} indica que esto debería reemplazar la rama \texttt{fixbar} encontrada en\texttt{myfork}.

\end{itemize}


\hypertarget{15783462829957256990}{}


\section{Creando un nuevo Paquete}



\hypertarget{7503244006975768273}{}


\subsection{REQUIRE habla por sí mismo}



Deberías tener un archivo \texttt{REQUIRE} en tu repositorio de paquetes, con una directiva mínima de la versión de Julia que esperas que los usuarios ejecuten para que el paquete funcione. Poniendo un piso en qué versión de Julia apoya tu paquete se hace simplemente agregando \texttt{julia 0.x} en este archivo. Si bien esta línea es parcialmente informativa, también tiene la consecuencia de si \texttt{Pkg.update()} actualizará el código que se encuentra en los directorios de versiones \texttt{.julia}. No actualizará el código encontrado en los directorios de versiones debajo del piso de lo que se especifica en su {\textquotesingle}REQUIRE{\textquotesingle}.



A medida que la versión de desarrollo {\textquotesingle}0.y{\textquotesingle} madura, es posible que la utilices con más frecuencia y desees que su paquete la admita. Ten cuidado, la rama de desarrollo de Julia es {\textquotedbl}tierra de la rotura{\textquotedbl}, y puede esperar que haya cosas que se rompan. Cuando vayas a arreglar lo que rompió tu paquete en la rama de desarrollo \texttt{0.y}, probablemente encontrarás que acaba de romper tu paquete en la versión estable.



Hay un mecanismo que se encuentra en el paquete \href{https://github.com/JuliaLang/Compat.jl}{Compat} que le permitirá admitir tanto la versión estable como los cambios de última hora que se encuentran en la versión de desarrollo. Si decide utilizar esta solución, deberá agregar \texttt{Compat} a su archivo\texttt{REQUIRE}. En este caso, todavía tendrá \texttt{julia 0.x} en su\texttt{REQUIRE}. La \texttt{x} es la versión de piso de lo que su paquete admite.



Es posible que tampoco tengas interés en apoyar la versión de desarrollo de Julia. Del mismo modo que puede agregar un piso a la versión que espera que tengan los usuarios, puede establecer un límite superior. En este caso, pondría \texttt{julia 0.x 0.y-} en su archivo \texttt{REQUIRE}. El \texttt{-} al final del número de versión se refiere a las versiones preliminares de esa versión específica desde el primer compromiso. Al establecerlo como techo, quiere decir que el código es compatible con todo pero no incluye la versión de techo.



Otra situación es que está escribiendo la mayor parte del código para su paquete con Julia \texttt{0.y} y no desea admitir la versión estable actual de Julia. Si elige hacer esto, simplemente agregue \texttt{julia 0.y-} a su \texttt{REQUIRE}. Solo recuerda cambiar \texttt{julia 0.y-} a \texttt{julia 0.y} en tu archivo\texttt{REQUIRE} una vez que \texttt{0.y} sea lanzado oficialmente. Si no edita el dash cruft, estás sugiriendo que admita tanto el desarrollo como las versiones estables del mismo número de versión. Eso sería una locura. Consulte la \hyperlink{5869679324207541494}{Especificación de requisitos} para obtener el formato completo de \texttt{REQUIRE}.



Por último, en muchos casos puede necesitar paquetes adicionales para las pruebas. Paquetes adicionales que solo son necesarios para las pruebas deben especificarse en el archivo \texttt{test/REQUIRE}. Este archivo \texttt{REQUIRE} tiene la misma especificación que el archivo \texttt{REQUIRE} estándar.



\hypertarget{9557716147004241553}{}


\subsection{Líneas Guía para Nombrar un Paquete}



Los nombres de los paquetes deben ser sensatos para la mayoría de los usuarios de Julia, \emph{incluso para aquellos que no son expertos en el dominio}. Cuando envíes tu paquete a METADATA, puedes esperar un poco de ida y vuelta sobre el nombre del paquete con tus colaboradores, especialmente si es ambiguo o puede confundirse con algo diferente de lo que es. Durante este intervalo de tiempo, no es raro obtener una variedad de \emph{diferentes} sugerencias de nombres. Sin embargo, estas son solo sugerencias, con la intención de mantener un espacio de nombres ordenado en el repositorio de METADATA seleccionado. Como este repositorio pertenece a toda la comunidad, es probable que haya algunos colaboradores a los que les importe el nombre de su paquete. Aquí hay algunas pautas a seguir para nombrar su paquete:



\begin{itemize}
\item[1. ] Evita la jerga. En particular, evita los acrónimos a menos que haya una mínima posibilidad de confusión.

\begin{itemize}
\item Está bien decir \texttt{USA} si estás hablando de USA.


\item No está bien decir \texttt{PMA}, incluso si estás hablando de una actitud mental positiva.

\end{itemize}

\item[2. ] Evite usar \texttt{Julia} en el nombre de su paquete.

\begin{itemize}
\item Por lo general, es claro, por contexto y para sus usuarios, que el paquete es un paquete Julia.


\item Tener a Julia en el nombre puede implicar que el paquete está conectado a, o avalado por, colaboradores del propio lenguaje Julia.

\end{itemize}

\item[3. ] Los paquetes que proporcionan la mayor parte de su funcionalidad en asociación con un nuevo tipo deberían tener nombres pluralizados.

\begin{itemize}
\item \texttt{DataFrames} proporciona el tipo\texttt{DataFrame}.


\item \texttt{BloomFilters} proporciona el tipo\texttt{BloomFilter}.


\item Por el contrario, \texttt{JuliaParser} no proporciona ningún tipo nuevo, sino una nueva funcionalidad en la función \texttt{JuliaParser.parse()}.

\end{itemize}

\item[4. ] Err del lado de la claridad, incluso si la claridad te parece larga.

\begin{itemize}
\item \texttt{RandomMatrices} es un nombre menos ambiguo que\texttt{RndMat} o \texttt{RMT}, aunque estos últimos sean más cortos.

\end{itemize}

\item[5. ] Un nombre menos sistemático puede adaptarse a un paquete que implemente uno de varios enfoques posibles para su dominio.

\begin{itemize}
\item Julia no tiene un solo paquete completo de graficación. En cambio, \texttt{Gadfly},\texttt{PyPlot}, \texttt{Winston} y otros paquetes implementan cada uno un enfoque único basado en una filosofía de diseño particular.


\item Por el contrario, \texttt{SortingAlgorithms} proporciona una interfaz coherente para usar muchos sistemas bien establecidos de algoritmos de clasificación.

\end{itemize}

\item[6. ] Los paquetes que envuelven bibliotecas externas o programas deben tener el nombre de esas bibliotecas o programas.

\begin{itemize}
\item \texttt{CPLEX.jl} envuelve la biblioteca\texttt{CPLEX}, -que se puede identificar fácilmente en una búsqueda web.


\item \texttt{MATLAB.jl} proporciona una interfaz para llamar al motor de MATLAB desde dentro de Julia.

\end{itemize}
\end{itemize}


\hypertarget{8394064991138809779}{}


\subsection{Generando el paquete}



Supongamos que quiere crear un nuevo paquete de Julia llamado \texttt{FooBar}. Para comenzar, haga \texttt{PkgDev.generate(pkg,license)} donde \texttt{pkg} es el nuevo nombre del paquete y\texttt{license} es el nombre de una licencia que el generador de paquetes conoce:




\begin{minted}{jlcon}
julia> PkgDev.generate("FooBar","MIT")
INFO: Initializing FooBar repo: /Users/stefan/.julia/v0.6/FooBar
INFO: Origin: git://github.com/StefanKarpinski/FooBar.jl.git
INFO: Generating LICENSE.md
INFO: Generating README.md
INFO: Generating src/FooBar.jl
INFO: Generating test/runtests.jl
INFO: Generating REQUIRE
INFO: Generating .travis.yml
INFO: Generating appveyor.yml
INFO: Generating .gitignore
INFO: Committing FooBar generated files
\end{minted}



Esto crea el directorio \texttt{{\textasciitilde}/.julia/v0.6/FooBar}, lo inicializa como un repositorio de git, genera un grupo de archivos que todos los paquetes deben tener y los envía al repositorio:




\begin{lstlisting}
$ cd ~/.julia/v0.6/FooBar && git show --stat

commit 84b8e266dae6de30ab9703150b3bf771ec7b6285
Author: Stefan Karpinski <stefan@karpinski.org>
Date:   Wed Oct 16 17:57:58 2013 -0400

    FooBar.jl generated files.

        license: MIT
        authors: Stefan Karpinski
        years:   2013
        user:    StefanKarpinski

    Julia Version 0.3.0-prerelease+3217 [5fcfb13*]

 .gitignore       |  2 ++
 .travis.yml      | 13 +++++++++++++
 LICENSE.md       | 22 +++++++++++++++++++++++
 README.md        |  3 +++
 REQUIRE          |  1 +
 appveyor.yml     | 34 ++++++++++++++++++++++++++++++++++
 src/FooBar.jl    |  5 +++++
 test/runtests.jl |  5 +++++
 8 files changed, 85 insertions(+)
\end{lstlisting}



Por el momento, el administrador del paquete conoce la licencia {\textquotedbl}Expat{\textquotedbl} del MIT, indicada por \texttt{{\textquotedbl}MIT{\textquotedbl}}, la licencia simplificada BSD, indicada por \texttt{{\textquotedbl}BSD{\textquotedbl}}, y la versión 2.0 de la licencia del software Apache, indicada por \texttt{{\textquotedbl}ASL{\textquotedbl}}. Si desea utilizar una licencia diferente, puede solicitarnos que la agreguemos al generador de paquetes, o simplemente seleccione una de estas tres y luego modifique el archivo \texttt{{\textasciitilde}/.julia/v0.6/PACKAGE/LICENSE.md} después de haberlo generado.



Si creó una cuenta de GitHub y configuró git para saber sobre ello, \texttt{PkgDev.generate()} establecerá una URL de origen adecuada para usted. También generará automáticamente un archivo \texttt{.travis.yml} para usar el servicio de prueba automatizado \href{https://travis-ci.org}{Travis}, y un archivo \texttt{appveyor.yml} para usar \href{https://www.appveyor.com}{AppVeyor}. Deberá habilitar las pruebas en los sitios web de Travis y AppVeyor para su repositorio de paquetes, pero una vez que lo haya hecho, ya tendrá pruebas de funcionamiento. Por supuesto, todas las pruebas predeterminadas hacen es verificar que \texttt{usando FooBar} en Julia funciona.



\hypertarget{13401942842773502143}{}


\subsection{Cargando ficheros estáticos No-Julia}



Si su código de paquete necesita cargar archivos estáticos que no son código Julia, p. una biblioteca externa o archivos de datos, y se encuentran dentro del directorio del paquete, use la macro \texttt{@\_\_DIR\_\_} para determinar el directorio del archivo fuente actual. Por ejemplo, si \texttt{FooBar/src/FooBar.jl} necesita cargar  \texttt{FooBar/data/foo.csv}, use el siguiente código:




\begin{minted}{julia}
datapath = joinpath(@__DIR__, "..", "data")
foo = readcsv(joinpath(datapath, "foo.csv"))
\end{minted}



\hypertarget{4719966161636558896}{}


\subsection{Haciendo Disponible tu Paquete}



Una vez que haya realizado algunos commits y esté satisfecho con el funcionamiento de \texttt{FooBar}, es posible que desee conseguir que otras personas lo prueben. Primero tendrá que crear el repositorio remoto e insertar su código; todavía no hacemos esto automáticamente por usted, pero lo haremos en el futuro y no es demasiado difícil de entender \footnotemark[3]. Una vez que haya hecho esto, dejar que la gente pruebe su código es tan simple como enviarles la URL del repositorio publicado, en este caso:




\begin{lstlisting}
git://github.com/StefanKarpinski/FooBar.jl.git
\end{lstlisting}



Para su paquete, será su nombre de usuario GitHub y el nombre de su paquete, pero se entiende la idea. Las personas a las que envíes esta URL pueden usar \hyperlink{12404258328199389568}{\texttt{Pkg.clone()}} para instalar el paquete y probarlo:




\begin{minted}{jlcon}
julia> Pkg.clone("git://github.com/StefanKarpinski/FooBar.jl.git")
INFO: Cloning FooBar from git@github.com:StefanKarpinski/FooBar.jl.git
\end{minted}



\footnotetext[3]{Se recomienda encarecidamente instalar y usar la \href{https://github.com/github/hub}{herramienta {\textquotedbl}hub{\textquotedbl} de GitHub}.  Esta herramienta permite hacer cosas como ejecutar \texttt{hub create} en el repositorio del paquete y hacer que se  cree automáticamente a través de la API de GitHub.

}


\hypertarget{15434198254171333487}{}


\subsection{Tagging and Publishing Your Package}



\begin{quote}
\textbf{Tip}

Si aloja su paquete en GitHub, puede usar la \href{https://github.com/attobot/attobot}{integración attobot}  para gestionar el registro, etiquetado y publicación de paquetes.

\end{quote}


Una vez que haya decidido que \texttt{FooBar} está listo para registrarse como paquete oficial, puede agregarlo a su copia local de\texttt{METADATA} usando \texttt{PkgDev.register()}:




\begin{minted}{jlcon}
julia> PkgDev.register("FooBar")
INFO: Registering FooBar at git://github.com/StefanKarpinski/FooBar.jl.git
INFO: Committing METADATA for FooBar
\end{minted}



Esto crea un commit en el repositorio \texttt{{\textasciitilde}/.julia/v0.6/METADATA}:




\begin{lstlisting}
$ cd ~/.julia/v0.6/METADATA && git show

commit 9f71f4becb05cadacb983c54a72eed744e5c019d
Author: Stefan Karpinski <stefan@karpinski.org>
Date:   Wed Oct 16 18:46:02 2013 -0400

    Register FooBar

diff --git a/FooBar/url b/FooBar/url
new file mode 100644
index 0000000..30e525e
--- /dev/null
+++ b/FooBar/url
@@ -0,0 +1 @@
+git://github.com/StefanKarpinski/FooBar.jl.git
\end{lstlisting}



Sin embargo, este compromiso sólo es visible localmente. Para que sea visible para la comunidad Julia, debe fusionar su \texttt{METADATA} local en el repositorio oficial. El comando \texttt{PkgDev.publish()} bifurca el repositorio \texttt{METADATA} en GitHub, inserta los cambios en su bifurcación, y abre una solicitud de extracción:




\begin{minted}{jlcon}
julia> PkgDev.publish()
INFO: Validating METADATA
INFO: No new package versions to publish
INFO: Submitting METADATA changes
INFO: Forking JuliaLang/METADATA.jl to StefanKarpinski
INFO: Pushing changes as branch pull-request/ef45f54b
INFO: To create a pull-request open:

  https://github.com/StefanKarpinski/METADATA.jl/compare/pull-request/ef45f54b
\end{minted}



\begin{quote}
\textbf{Tip}

Si \texttt{PkgDev.publish()} falla con error:


\begin{lstlisting}
ERROR: key not found: "token"
\end{lstlisting}

\end{quote}


entonces puede que hayas encontrado un problema al usar la API de GitHub en múltiples sistemas. La solución es eliminar el token de acceso personal {\textquotedbl}\emph{Julia Package Manager}{\textquotedbl} \href{https://github.com/login?return\_to=https\%3A\%2F\%2Fgithub.com\%2Fsettings\%2Ftokens}{de tu cuenta Github} e intentarlo de nuevo.



Otros fallos pueden requerir que evites \texttt{PkgDev.publish()} al \href{https://help.github.com/articles/creating-a-pull-request/}{crear una solicitud de extracción en GitHub}. Ver: \hyperlink{17750985984600933817}{Publicación de METADATA manualmente} a continuación.



Una vez que la URL del paquete para \texttt{FooBar} se registra en el repositorio oficial de\texttt{METADATA}, las personas saben de dónde clonar el paquete, pero todavía no hay ninguna versión registrada disponible. Puede etiquetarlo y registrarlo con el comando \texttt{PkgDev.tag()}:




\begin{minted}{jlcon}
julia> PkgDev.tag("FooBar")
INFO: Tagging FooBar v0.0.1
INFO: Committing METADATA for FooBar
\end{minted}



Esto etiqueta el reppositorio en \texttt{FooBar} con \texttt{v0.0.1}:




\begin{lstlisting}
$ cd ~/.julia/v0.6/FooBar && git tag
v0.0.1
\end{lstlisting}



También crea una nueva entrada de versión en su repositorio \texttt{METADATA} local para\texttt{FooBar}:




\begin{lstlisting}
$ cd ~/.julia/v0.6/FooBar && git show
commit de77ee4dc0689b12c5e8b574aef7f70e8b311b0e
Author: Stefan Karpinski <stefan@karpinski.org>
Date:   Wed Oct 16 23:06:18 2013 -0400

    Tag FooBar v0.0.1

diff --git a/FooBar/versions/0.0.1/sha1 b/FooBar/versions/0.0.1/sha1
new file mode 100644
index 0000000..c1cb1c1
--- /dev/null
+++ b/FooBar/versions/0.0.1/sha1
@@ -0,0 +1 @@
+84b8e266dae6de30ab9703150b3bf771ec7b6285
\end{lstlisting}



El mandato \texttt{PkgDev.tag()} toma un segundo argumento opcional que es un objeto de número de versión explícito como \texttt{v{\textquotedbl}0.0.1{\textquotedbl}} o uno de los símbolos \texttt{:patch},\texttt{:minor} o \texttt{:major} . Estos incrementan el parche, el número de versión menor o mayor de su paquete de forma inteligente.



Agregar una versión etiquetada de su paquete agilizará el registro oficial en METADATA.jl por parte de los colaboradores. Se recomienda enfáticamente que complete este proceso, independientemente de si su paquete está completamente listo para una versión oficial.



Como regla general, los paquetes deben etiquetarse como \texttt{0.0.1} primero. Como Julia no ha alcanzado el estado {\textquotesingle}1.0{\textquotesingle}, es mejor ser conservador en las versiones etiquetadas de su paquete.



Al igual que con \texttt{PkgDev.register()}, estos cambios en \texttt{METADATA} no están disponibles para nadie más hasta que se hayan incluido en la versión anterior. De nuevo, use el comando \texttt{PkgDev.publish()}, que primero se asegura de que los repos individuales de paquetes hayan sido etiquetados, los empuja si no han sido ya, y luego abre una solicitud de extracción a \texttt{METADATA}:




\begin{minted}{jlcon}
julia> PkgDev.publish()
INFO: Validating METADATA
INFO: Pushing FooBar permanent tags: v0.0.1
INFO: Submitting METADATA changes
INFO: Forking JuliaLang/METADATA.jl to StefanKarpinski
INFO: Pushing changes as branch pull-request/3ef4f5c4
INFO: To create a pull-request open:

  https://github.com/StefanKarpinski/METADATA.jl/compare/pull-request/3ef4f5c4
\end{minted}



\hypertarget{17750985984600933817}{}


\subsubsection{Publishing METADATA manually}



Si \texttt{PkgDev.publish()} falla, puede seguir estas instrucciones para publicar su paquete manualmente.



Al {\textquotedbl}bifurcar{\textquotedbl} el repositorio principal de METADATA, puede crear una copia personal (de METADATA.jl) en su cuenta de GitHub. Una vez que existe esa copia, puede enviar sus cambios locales a su copia (al igual que cualquier otro proyecto de GitHub).



\begin{itemize}
\item[1. ] Vaya a \href{https://github.com/login?return\_to=https\%3A\%2F\%2Fgithub.com\%2FJuliaLang\%2FMETADATA.jl\%2Ffork}{https://github.com/login?return\_to=https\%3A\%2F\%2Fgithub.com\%2FJuliaLang\%2FMETADATA.jl\%2Ffork}

\end{itemize}


y cree su propia bifurcación.



\begin{itemize}
\item[2. ] Agregue su bifurcación como un repositorio remoto para el repositorio METADATA en su computadora local (en la terminal donde USERNAME es su nombre de usuario github)::

\end{itemize}



\begin{lstlisting}
cd ~/.julia/v0.6/METADATA
git remote add USERNAME https://github.com/USERNAME/METADATA.jl.git
\end{lstlisting}



\begin{itemize}
\item[1. ] empuja tus cambios a tu bifurcación:


\begin{lstlisting}
git push USERNAME metadata-v2
\end{lstlisting}


\item[2. ] Si todo eso funciona, regrese a la página de GitHub para su tenedor y haga clic en el enlace {\textquotedbl}solicitar solicitud{\textquotedbl}.

\end{itemize}


\hypertarget{4361188995750101402}{}


\section{Fixing Package Requirements}



Si necesita corregir los requisitos registrados de una versión de paquete ya publicada, puede hacerlo simplemente editando los metadatos de esa versión, que seguirá teniendo el mismo hash de confirmación: el hash asociado a una versión es permanente:




\begin{lstlisting}
$ cd ~/.julia/v0.6/METADATA/FooBar/versions/0.0.1 && cat requires
julia 0.3-
$ vi requires
\end{lstlisting}



Como el hash de confirmación (\emph{commit}) permanece igual, el contenido del archivo \texttt{REQUIRE} que se retirará en el repositorio \textbf{no} coincidirá con los requisitos en \texttt{METADATA} después de dicho cambio; esto es inevitable. Sin embargo, cuando se fijan los requisitos en \texttt{METADATA} para una versión anterior de un paquete, también se debe corregir el archivo\texttt{REQUIRE} en la versión actual del paquete.



\hypertarget{5869679324207541494}{}


\section{Especificación de Requisitos}



El archivo \texttt{{\textasciitilde}/.julia/v0.6/REQUIRE}, el archivo\texttt{REQUIRE} dentro de los paquetes y los archivos \texttt{require} del paquete \texttt{METADATA} utilizan un formato simple basado en línea para expresar los rangos de las versiones del paquete que necesitan estar instalados. Los archivos \texttt{REQUIRE} y \texttt{METADATA requires} también deben incluir el rango de versiones de \texttt{julia} con las que se espera que funcione el paquete. Además, los paquetes pueden incluir un archivo \texttt{test/REQUIRE} para especificar paquetes adicionales que solo son necesarios para la prueba.



Así es cómo se analizan e interpretan estos archivos.



\begin{itemize}
\item Todo lo que haya después de que una marca \texttt{\#} se elimina de cada línea como un comentario.


\item Si solo queda espacio en blanco, la línea se ignorará.


\item Si quedan caracteres que no sean espacios en blanco, la línea es un requisito y el espacio en blanco se  divide en palabras.

\end{itemize}


El requisito más simple posible es simplemente el nombre del nombre de un paquete en una línea por sí mismo:




\begin{minted}{julia}
Distributions
\end{minted}



Este requisito se satisface con cualquier versión del paquete \texttt{Distributions}. El nombre del paquete puede ir seguido de cero o más números de versión en orden ascendente, lo que indica intervalos aceptables de versiones de ese paquete. Una versión abre un intervalo, la siguiente la cierra y la siguiente abre un nuevo intervalo, y así sucesivamente; si se da un número impar de números de versión, las versiones arbitrariamente grandes satisfarán; si se proporciona un número par de números de versión, el último es un límite superior para los números de versión aceptables. Por ejemplo, la línea:




\begin{lstlisting}
Distributions 0.1
\end{lstlisting}



se satisface con cualquier versión de \texttt{Distribuciones} superior o igual a\texttt{0.1.0}. El sufijo de una versión con \texttt{-} también permite versiones preliminares. Por ejemplo:




\begin{lstlisting}
Distributions 0.1-
\end{lstlisting}



se satisface con las versiones preliminares tales como \texttt{0.1-dev} o\texttt{0.1-rc1}, o con cualquier versión mayor o igual a \texttt{0.1.0}.



Esta entrada de requisito:




\begin{lstlisting}
Distributions 0.1 0.2.5
\end{lstlisting}



se satisface con versiones desde {\textquotesingle}0.1.0{\textquotesingle} hasta, pero sin incluir, {\textquotesingle}0.2.5{\textquotesingle}. Si quiere indicar que cualquier versión de \texttt{0.1.x} va a funcionar, querrá escribir:




\begin{lstlisting}
Distributions 0.1 0.2-
\end{lstlisting}



If you want to start accepting versions after \texttt{0.2.7}, you can write:




\begin{lstlisting}
Distributions 0.1 0.2- 0.2.7
\end{lstlisting}



Si una línea de requisitos tiene palabras iniciales que comienzan con \texttt{@}, es un requisito dependiente del sistema. Si su sistema coincide con estos condicionales del sistema, se incluye el requisito, de lo contrario, se ignora el requisito. Por ejemplo:




\begin{lstlisting}
@osx Homebrew
\end{lstlisting}



requerirá el paquete \texttt{Homebrew} solo en los sistemas donde el sistema operativo es OS X. Las condiciones del sistema que actualmente son compatibles son (jerárquicamente):



\begin{itemize}
\item \texttt{@unix}

\begin{itemize}
\item \texttt{@linux}


\item \texttt{@bsd}

\begin{itemize}
\item \texttt{@osx}

\end{itemize}
\end{itemize}

\item \texttt{@windows}

\end{itemize}


La condición \texttt{@unix} se cumple en todos los sistemas UNIX, incluidos Linux y BSD. Los condicionales de sistema negados también son compatibles al agregar un \texttt{!} Después del \texttt{@} inicial. Ejemplos:




\begin{lstlisting}
@!windows
@unix @!osx
\end{lstlisting}



La primera condición se aplica a cualquier sistema excepto Windows y la segunda condición se aplica a cualquier sistema UNIX además de OS X.



Los controles de tiempo de ejecución para la versión actual de Julia se pueden realizar utilizando la variable incorporada \texttt{VERSION}, que es de tipo \texttt{VersionNumber}. Dicho código ocasionalmente es necesario para realizar un seguimiento de la funcionalidad nueva o obsoleta entre varias versiones de Julia. Ejemplos de controles de tiempo de ejecución:




\begin{minted}{julia}
VERSION < v"0.3-" #exclude all pre-release versions of 0.3

v"0.2-" <= VERSION < v"0.3-" #get all 0.2 versions, including pre-releases, up to the above

v"0.2" <= VERSION < v"0.3-" #To get only stable 0.2 versions (Note v"0.2" == v"0.2.0")

VERSION >= v"0.2.1" #get at least version 0.2.1
\end{minted}



See the section on \hyperlink{10038787961375920908}{version number literals} for a more complete description.



\hypertarget{13874102823603666739}{}


\chapter{Elaboración de Perfiles (\emph{Profiling})}



El módulo \texttt{Profile} proporciona herramientas para ayudar a los desarrolladores a mejorar el rendimiento de su código. Cuando se usa, toma medidas de código en ejecución y produce resultados que lo ayudan a comprender cuánto tiempo se gasta en línea(s) individual(es). El uso más común es identificar {\textquotedbl}cuellos de botella{\textquotedbl} como objetivos para la optimización.



\texttt{Profile} implementa lo que se conoce como {\textquotedbl}sampling{\textquotedbl} o \href{https://en.wikipedia.org/wiki/Profiling\_ (computer\_programming)}{\emph{profiler} estadístico}. Funciona periódicamente tomando una traza inversa durante la ejecución de cualquier tarea. Cada traz inversa captura la función que se está ejecutando actualmente y el número de línea, más la cadena completa de llamadas a función que llevó a esta línea, y por lo tanto es una {\textquotedbl}instantánea{\textquotedbl} del estado actual de ejecución.



Si se gasta una gran parte de su tiempo de ejecución al ejecutar una línea particular de código, esta línea aparecerá con frecuencia en el conjunto de todas las trazas inversas. En otras palabras, el {\textquotedbl}costo{\textquotedbl} de una línea determinada -o, en realidad, el costo de la secuencia de llamadas de función hasta e incluyendo esta línea- es proporcional a la frecuencia con que aparece en el conjunto de todas las trazas inversas.



Un generador de perfiles de muestreo (\emph{sampling profiler}) no proporciona una cobertura completa línea por línea, porque las trazas inversas se producen a intervalos (por defecto, 1 ms en sistemas Unix y 10 ms en Windows, aunque la programación real está sujeta a la carga del sistema operativo). Además, como se analiza más adelante, como las muestras se recogen en un subconjunto disperso de todos los puntos de ejecución, los datos recopilados por un generador de perfiles de muestreo están sujetos a ruido estadístico.



A pesar de estas limitaciones, los perfiles de muestreo tienen fortalezas sustanciales:



\begin{itemize}
\item No tiene que hacer ninguna modificación en su código para tomar medidas de temporización (en c

\end{itemize}


ontraste con la alternativa \href{https://github.com/timholy/IProfile.jl}{instrumenting profiler}).  



\begin{itemize}
\item Puede perfilarse en el código central de Julia e incluso (opcionalmente) en las bibliotecas C y Fortran.


\item Al ejecutarse {\textquotedbl}con poca frecuencia{\textquotedbl}, hay muy poca sobrecarga de rendimiento; durante el perfilado,  su código puede ejecutarse a una velocidad casi nativa.

\end{itemize}


Por estas razones, se recomienda que intente utilizar el generador de perfiles de muestreo incorporado antes de considerar cualquier alternativa.



\hypertarget{15136625242009699742}{}


\section{Uso básico}



Trabajemos con un simple caso de test:




\begin{minted}{jlcon}
julia> function myfunc()
           A = rand(200, 200, 400)
           maximum(A)
       end
\end{minted}



Es buena idea ejecutar primero el código que se intenta analizar al menos una vez (a menos que uno quiera analizar el compilador JIT de Julia):




\begin{minted}{jlcon}
julia> myfunc() # run once to force compilation
\end{minted}



Ahora estamos listos para analizar esta función:




\begin{minted}{jlcon}
julia> @profile myfunc()
\end{minted}



Para ver los resultados del \emph{profiler} hay disponible un \href{https://github.com/timholy/ProfileView.jl}{navegador gráfico}, pero aquí usaremos la pantalla basada en texto que viene con la librería estándar:




\begin{minted}{jlcon}
julia> Profile.print()
80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
 80 ./REPL.jl:97; macro expansion
  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)
   80 ./boot.jl:235; eval(::Module, ::Any)
    80 ./<missing>:?; anonymous
     80 ./profile.jl:23; macro expansion
      52 ./REPL[1]:2; myfunc()
       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...
        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...
       14 ./random.jl:278; rand
        14 ./random.jl:277; rand
         14 ./random.jl:366; rand
          14 ./random.jl:369; rand
      28 ./REPL[1]:3; myfunc()
       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...
        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...
\end{minted}



Cada línea de esta pantalla representa un punto particular (número de línea) en el código. La sangría se usa para indicar la secuencia anidada de llamadas a funciones, con líneas más sangradas que son más profundas en la secuencia de llamadas. En cada línea, el primer {\textquotedbl}campo{\textquotedbl} es el número de trazas inversas (muestras) tomadas \emph{en esta línea o en cualquier función ejecutada por esta línea}. El segundo campo es el nombre del archivo y el número de línea, y el tercer campo es el nombre de la función. Tenga en cuenta que los números de línea específicos pueden cambiar como los cambios de código de Julia; si quieres seguir, es mejor que ejecutes este ejemplo tú mismo.



En este ejemplo, podemos ver que la función de nivel superior llamada está en el archivo \texttt{event.jl}. Esta es la función que ejecuta REPL cuando se lanza Julia. Si se examina la línea 97 de \texttt{REPL.jl}, verá que aquí es donde se llama a la función \texttt{eval\_user\_input()}. Esta es la función que evalúa lo que escribes en el REPL, y dado que estamos trabajando de forma interactiva estas funciones se invocaron cuando ingresamos \texttt{@profile myfunc()}. La siguiente línea refleja las acciones tomadas en la macro \hyperlink{2219312293287618200}{\texttt{@ profile}}.



La primera línea muestra que se tomaron 80 trazas inversas en la línea 73 de \texttt{event.jl}, pero no es que esta línea fuera {\textquotedbl}costosa{\textquotedbl} por sí misma: la tercera línea revela que las 80 trazas inversas se desencadenaron dentro de su llamada a \texttt{eval\_user\_input}, y así sucesivamente. Para averiguar qué operaciones se están tomando realmente el tiempo, necesitamos buscar más profundamente en la cadena de llamadas.



La primera línea {\textquotedbl}importante{\textquotedbl} en esta salida es esta:




\begin{lstlisting}
52 ./REPL[1]:2; myfunc()
\end{lstlisting}



\texttt{REPL} se refiere al hecho de que definimos\texttt{myfunc} en REPL, en lugar de ponerlo en un archivo; si hubiéramos usado un archivo, esto mostraría el nombre del archivo. El \texttt{[1]} muestra que la función \texttt{myfunc} fue la primera expresión evaluada en esta sesión REPL. La línea 2 de \texttt{myfunc()} contiene la llamada a \texttt{rand}, y hubo 52 (de 80) trazas inversas que ocurrieron en esta línea. Debajo de eso, puede ver una llamada a \texttt{dsfmt\_fill\_array\_close\_open!} Dentro de \texttt{dSFMT.jl}.



Un poco más abajo, ves:




\begin{lstlisting}
28 ./REPL[1]:3; myfunc()
\end{lstlisting}



La línea 3 de \texttt{myfunc} contiene la llamada a\texttt{maximum}, y hubo 28 (de 80) trazas inversas tomadas aquí. Debajo de eso, puede ver los lugares específicos en \texttt{base/reduce.jl} que llevan a cabo las operaciones que consumen mucho tiempo en la función\texttt{maximum} para este tipo de datos de entrada.



En general, podemos concluir tentativamente que generar los números aleatorios es aproximadamente el doble de costoso que encontrar el elemento máximo. Podríamos aumentar nuestra confianza en este resultado recopilando más muestras:




\begin{minted}{jlcon}
julia> @profile (for i = 1:100; myfunc(); end)

julia> Profile.print()
[....]
 3821 ./REPL[1]:2; myfunc()
  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...
   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...
  310  ./random.jl:278; rand
   [....]
 2893 ./REPL[1]:3; myfunc()
  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...
   [....]
\end{minted}



En general, si tiene \texttt{N} muestras recopiladas en una línea, puede esperar una incertidumbre en el orden de \texttt{sqrt(N)} (excluyendo otras fuentes de ruido, como cuán ocupada está la computadora con otras tareas). La principal excepción a esta regla es la recolección de basura, que se ejecuta con poca frecuencia pero tiende a ser bastante costosa. (Dado que el recolector de basura de Julia está escrito en C, tales eventos pueden ser detectados usando el modo de salida \texttt{C = true} descrito a continuación, o usando \href{https://github.com/timholy/ProfileView.jl}{ProfileView.jl}.)



Esto ilustra el volcado de {\textquotedbl}árbol{\textquotedbl} predeterminado; una alternativa es el volcado {\textquotedbl}plano{\textquotedbl}, que acumula conteos independientemente de su anidación:




\begin{minted}{jlcon}
julia> Profile.print(format=:flat)
 Count File          Line Function
  6714 ./<missing>     -1 anonymous
  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)
  6714 ./REPL.jl       97 macro expansion
  3821 ./REPL[1]        2 myfunc()
  2893 ./REPL[1]        3 myfunc()
  6714 ./REPL[7]        1 macro expansion
  6714 ./boot.jl      235 eval(::Module, ::Any)
  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...
  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()
  6714 ./profile.jl    23 macro expansion
  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...
   310 ./random.jl    277 rand
   310 ./random.jl    278 rand
   310 ./random.jl    366 rand
   310 ./random.jl    369 rand
  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...
     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...
\end{minted}



Si nuestro código tiene recursión, un punto potencialmente confso es que una línea en una función {\textquotedbl}hija{\textquotedbl} puede acumular ms cuentas que hay de trazas inversas en total.Considere las siguientes definiciones de función:




\begin{minted}{julia}
dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)
dumbsum3() = dumbsum(3)
\end{minted}



Si tuviéramos que analizar  \texttt{dumbsum3}, y una traza inversa fuera tomada mientras estaba ejecutándose \texttt{dumbsum(1)}, la traza inversa tendría este aspecto:




\begin{minted}{julia}
dumbsum3
    dumbsum(3)
        dumbsum(2)
            dumbsum(1)
\end{minted}



En consecuencia, esta función hija realiza tres cuentas incluso aunque la padre sólo realiza una. La representación en {\textquotedbl}árbol{\textquotedbl} hace esto mucho ms claro, y por esta razón (entre otras) es probablemente la forma más útil de ver los resultados.



\hypertarget{8198701969315815437}{}


\section{Acumulación y Limpieza}



Los resultados de \hyperlink{2219312293287618200}{\texttt{@profile}} se acumulan en un buffer; si ejecuta varios fragmentos de código en \hyperlink{2219312293287618200}{\texttt{@profile}}, entonces \hyperlink{15011226253236705098}{\texttt{Profile.print()}} le mostrará los resultados combinados. Esto puede ser muy útil, pero a veces desea comenzar de nuevo; puede hacerlo con \hyperlink{11632425935156818951}{\texttt{Profile.clear()}}.



\hypertarget{10095580200006276095}{}


\section{Opciones para controlar la visión de los resultados del análisis}



\hyperlink{15011226253236705098}{\texttt{Profile.print()}} tienes más opciones de las que se han descrito hasta ahora. Veamos la declaración completa:




\begin{minted}{julia}
function print(io::IO = STDOUT, data = fetch(); kwargs...)
\end{minted}



Primero discutamos los dos argumentos posicionales, y luego los argumentos \emph{keyword}:



\begin{itemize}
\item \texttt{io} – Le permite guardar los resultados en un búfer, por ejemplo, un archivo, pero el predeterminado es  imprimir en \texttt{STDOUT} (la consola)..


\item \texttt{data} – Contiene los datos que desea analizar; de forma predeterminada, se obtiene de \hyperlink{9770463724510220682}{\texttt{Profile.fetch()}},  que extrae trazas inversas de un búfer preasignado. Por ejemplo, si desea perfilar el generador de perfiles,  podría decir:


\begin{minted}{julia}
data = copy(Profile.fetch())
Profile.clear()
@profile Profile.print(STDOUT, data) # Prints the previous results
Profile.print()                      # Prints results from Profile.print()
\end{minted}

\end{itemize}


The argumentos \emph{keyword} pueden ser cualquier combinación de:



\begin{itemize}
\item \texttt{format} – Introducido anteriormente, determina si se imprimen trazas inversas con (por defecto, \texttt{: árbol}) 

\end{itemize}


   o sin (\texttt{: plano}) indentación que indica la estructura en árbol.



\begin{itemize}
\item \texttt{C} – Si\texttt{true}, se muestran trazas inversas de C y Fortran (normalmente están excluidas). Intente ejecutar  el ejemplo introductorio con \texttt{Profile.print(C = true)}. Esto puede ser extremadamente útil para decidir si  es el código Julia o el código C lo que está causando un cuello de botella; establecer \texttt{C = true} también 

\end{itemize}


   mejora la interpretabilidad del anidamiento, a coste de unos listados de perfil más largos. 



\begin{itemize}
\item \texttt{combine} – Algunas líneas de código contienen múltiples operaciones; por ejemplo, \texttt{s + = A [i]} contiene  una referencia de matriz (\texttt{A[i]}) y una operación de suma. Estos corresponden a diferentes líneas en el  código máquina generado, y por lo tanto puede haber dos o más direcciones diferentes capturadas durante  las trazas inversas en esta línea. \texttt{combine = true} los agrupa, y es probablemente lo que generalmente  desea, pero puede generar un resultado por separado para cada puntero de instrucción con\texttt{combine = false}.


\item \texttt{maxdepth} – Limita los marcos a una profundidad mayor que\texttt{maxdepth} en el formato \texttt{:tree}.


\item \texttt{sortedby} – Controla el orden en formato \texttt{:flat}. \texttt{:filefuncline} (predeterminado) ordena por la línea  de origen, mientras que \texttt{:count} se ordena según el número de muestras recolectadas.


\item \texttt{noisefloor} – Límita los marcos que están debajo del umbral de ruido heurístico de la muestra (solo se aplica al formato\texttt{: tree}). Un valor sugerido para intentar esto es 2.0 (el valor predeterminado es 0). Este parámetro  oculta muestras para las cuales \texttt{n <= noisefloor * √N}, donde\texttt{n} es el número de muestras en esta línea, y 

\end{itemize}


   \texttt{N} es el número de muestras para el método invocado.



\begin{itemize}
\item \texttt{mincount} – Limita marcos con menos de \texttt{mincount} ocurrencias.

\end{itemize}


Los nombres de archivo/función a veces se truncan (con \texttt{...}), y la sangría se trunca con un \texttt{+n} al principio, donde \texttt{n} es el número de espacios adicionales que se habrían insertado, si hubiera habido espacio . Si desea un perfil completo de código profundamente anidado, a menudo una buena idea es guardar en un archivo usando un ancho {\textquotedbl}tamaño de pantalla{\textquotedbl} en un \hyperlink{13454403377667762339}{\texttt{IOContext}}:




\begin{minted}{julia}
open("/tmp/prof.txt", "w") do s
    Profile.print(IOContext(s, :displaysize => (24, 500)))
end
\end{minted}



\hypertarget{10900168837796521972}{}


\section{Configuración}



\hyperlink{2219312293287618200}{\texttt{@ profile}} solo acumula \emph{backtraces}, y el análisis ocurre cuando usted llama a \hyperlink{15011226253236705098}{\texttt{Profile.print()}}. Para un cálculo de larga ejecución, es muy posible que se llene el búfer preasignado para almacenar \emph{backtraces}. Si eso sucede, las trazas inversas se detienen pero su cálculo continúa. Como consecuencia, es posible que omitan algunos datos importantes de generación de perfiles (recibirá una advertencia cuando eso suceda).



Puede obtener y configurar los parámetros relevantes de esta manera:




\begin{minted}{julia}
Profile.init() # returns the current settings
Profile.init(n = 10^7, delay = 0.01)
\end{minted}



\texttt{n} es la cantidad total de punteros de instrucción que puede almacenar, con un valor predeterminado de \texttt{10 {\textasciicircum} 6}. Si su traza inversa típica es de 20 punteros de instrucción, puede recopilar 50000 trazas inversas, lo que sugiere una incertidumbre estadística de menos del 1\%. Esto puede ser lo suficientemente bueno para la mayoría de las aplicaciones.



En consecuencia, es más probable que necesite modificar el \texttt{retraso}, expresado en segundos, que establece la cantidad de tiempo que Julia obtiene entre las instantáneas para realizar los cálculos solicitados. Un trabajo de larga duración puede no necesitar trazas frecuentes. La configuración predeterminada es \texttt{delay = 0.001}. Por supuesto, puede disminuir la demora y aumentarla; sin embargo, la sobrecarga de los perfiles crece una vez que la demora se vuelve similar a la cantidad de tiempo necesaria para tomar una traza inversa ({\textasciitilde} 30 microsegundos en la computadora portátil del autor).



\hypertarget{10992983602239333354}{}


\chapter{Análisis de la asignación de memoria}



Una de las técnicas más comunes para mejorar el rendimiento es reducir la asignación de memoria. La cantidad total de  asignación se puede medir con \hyperlink{8029752041511656628}{\texttt{@time}} y \hyperlink{5377755456008435782}{\texttt{@allocated}}, y las líneas específicas que desencadenan la asignación a  pueden a menudo inferirse a partir del perfil a través del costo de la recolección de basura en la que incurren estas líneas. Sin embargo, a veces es más eficiente medir directamente la cantidad de memoria asignada por cada línea de código.



Para medir la asignación línea por línea, inicie Julia con la opción de línea de comando \texttt{--track-allocation = <setting>}, para la cual puede elegir \texttt{none} (el predeterminado, no medir la asignación), \texttt{user} (mida la asignación de memoria en todas partes excepto el código central de Julia), o \texttt{todo} (mida la asignación de memoria en cada línea del código Julia). La asignación se mide para cada línea de código compilado. Cuando sale de Julia, los resultados acumulativos se escriben en archivos de texto con \texttt{.mem} adjunto después del nombre del archivo, que residen en el mismo directorio que el archivo de origen. Cada línea enumera la cantidad total de bytes asignados. El \href{https://github.com/JuliaCI/Coverage.jl}{paquete \texttt{Coverage}} contiene algunas herramientas de análisis elementales, por ejemplo, para ordenar las líneas en orden de cantidad de bytes asignados.



Al interpretar los resultados, hay algunos detalles importantes. Bajo la configuración \texttt{user}, la primera línea de cualquier función directamente llamada desde REPL exhibirá asignación debido a eventos que ocurren en el código REPL. Más significativamente, la compilación de JIT también se suma a los recuentos de asignación, porque gran parte del compilador de Julia está escrito en Julia (y la compilación generalmente requiere asignación de memoria). El procedimiento recomendado es forzar la compilación ejecutando todos los comandos que desea analizar, luego llame a \hyperlink{12267785385121896224}{\texttt{Profile.clear\_malloc\_data()}} para restablecer todos los contadores de asignación. Finalmente, ejecute los comandos deseados y salga de Julia para activar la generación de los archivos \texttt{.mem}.



\hypertarget{12400320882474083416}{}


\chapter{Trazas de Pila}



El módulo \texttt{StackTraces} proporciona simples seguimientos de pila que son legibles para los humanos y fáciles de usar mediante programación.



\hypertarget{10829023227365826514}{}


\section{Viendo un rastro de pila}



La función principal utilizada para obtener un seguimiento de pila es \hyperlink{11964270650763140298}{\texttt{stacktrace()}}:




\begin{minted}{jlcon}
julia> stacktrace()
4-element Array{StackFrame,1}:
 eval(::Module, ::Any) at boot.jl:236
 eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66
 macro expansion at REPL.jl:97 [inlined]
 (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73
\end{minted}



Llamar a \hyperlink{11964270650763140298}{\texttt{stacktrace()}} devuelve un vector de \hyperlink{16824886840215699957}{\texttt{StackFrame}}s. Para facilitar el uso, el alias \hyperlink{12289172590874430030}{\texttt{StackTrace}} se puede usar en lugar de \texttt{Vector\{StackFrame\}}. (Los ejemplos con \texttt{[...]} indican que la salida puede variar dependiendo de cómo se ejecuta el código).




\begin{minted}{jlcon}
julia> example() = stacktrace()
example (generic function with 1 method)

julia> example()
5-element Array{StackFrame,1}:
 example() at REPL[1]:1
 eval(::Module, ::Any) at boot.jl:236
[...]

julia> @noinline child() = stacktrace()
child (generic function with 1 method)

julia> @noinline parent() = child()
parent (generic function with 1 method)

julia> grandparent() = parent()
grandparent (generic function with 1 method)

julia> grandparent()
7-element Array{StackFrame,1}:
 child() at REPL[3]:1
 parent() at REPL[4]:1
 grandparent() at REPL[5]:1
[...]
\end{minted}



Tenga en cuenta que cuando llama a \hyperlink{11964270650763140298}{\texttt{stacktrace()}} normalmente verá un marco con \texttt{eval (...) en boot.jl}. Al invocar \hyperlink{11964270650763140298}{\texttt{stacktrace()}} desde el REPL, también tendrá algunos fotogramas adicionales en la pila de \texttt{REPL.jl}, que generalmente se ve así:




\begin{minted}{jlcon}
julia> example() = stacktrace()
example (generic function with 1 method)

julia> example()
5-element Array{StackFrame,1}:
 example() at REPL[1]:1
 eval(::Module, ::Any) at boot.jl:236
 eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66
 macro expansion at REPL.jl:97 [inlined]
 (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73
\end{minted}



\hypertarget{18214495163799289313}{}


\section{Extracting useful information}



Cada \hyperlink{16824886840215699957}{\texttt{StackFrame}} contiene el nombre de la función, el nombre del archivo, el número de línea, la información lambda, un indicador que indica si el marco ha sido insertado, un indicador que indica si es una función C (por defecto las funciones C no aparecen en el seguimiento de la pila) y una representación entera del puntero devuelto por \hyperlink{6187626674327343338}{\texttt{backtrace()}}:




\begin{minted}{jlcon}
julia> top_frame = stacktrace()[1]
eval(::Module, ::Any) at boot.jl:236

julia> top_frame.func
:eval

julia> top_frame.file
Symbol("./boot.jl")

julia> top_frame.line
236

julia> top_frame.linfo
Nullable{Core.MethodInstance}(MethodInstance for eval(::Module, ::Any))

julia> top_frame.inlined
false

julia> top_frame.from_c
false
\end{minted}




\begin{minted}{jlcon}
julia> top_frame.pointer
0x00007f390d152a59
\end{minted}



Esto hace que la información de seguimiento de pila esté disponible programáticamente para el registro, el manejo de errores y más.



\hypertarget{3561929707903882086}{}


\section{Manejo de Errores}



Si bien tener acceso fácil a la información sobre el estado actual de la pila de llamadas puede ser útil en muchos lugares, la aplicación más obvia es la gestión de errores y la depuración.




\begin{minted}{jlcon}
julia> @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia> @noinline example() = try
           bad_function()
       catch
           stacktrace()
       end
example (generic function with 1 method)

julia> example()
5-element Array{StackFrame,1}:
 example() at REPL[2]:4
 eval(::Module, ::Any) at boot.jl:236
[...]
\end{minted}



Puede observar que en el ejemplo anterior, el primer marco apila puntos en la línea 4, donde se llama a \hyperlink{11964270650763140298}{\texttt{stacktrace()}}, en lugar de a la línea 2, donde se llama \emph{bad\_function} y el marco de \texttt{bad\_function} falta por completo. Esto es comprensible, dado que \hyperlink{11964270650763140298}{\texttt{stacktrace()}} se llama desde el contexto de \emph{catch}. Si bien en este ejemplo es bastante fácil encontrar el origen real del error, en casos complejos, rastrear el origen del error no es trivial.



Esto se puede remediar llamando a \hyperlink{16506728660892665673}{\texttt{catch\_stacktrace()}} en lugar de \hyperlink{11964270650763140298}{\texttt{stacktrace()}}. En lugar de devolver la información de la pila de llamadas para el contexto actual, \hyperlink{16506728660892665673}{\texttt{catch\_stacktrace()}} devuelve la información de la pila para el contexto de la excepción más reciente:




\begin{minted}{jlcon}
julia> @noinline bad_function() = undeclared_variable
bad_function (generic function with 1 method)

julia> @noinline example() = try
           bad_function()
       catch
           catch_stacktrace()
       end
example (generic function with 1 method)

julia> example()
6-element Array{StackFrame,1}:
 bad_function() at REPL[1]:1
 example() at REPL[2]:2
[...]
\end{minted}



Nótese que la traza de la pila indica ahora el número de línea apropiado y el marco perdido.




\begin{minted}{jlcon}
julia> @noinline child() = error("Whoops!")
child (generic function with 1 method)

julia> @noinline parent() = child()
parent (generic function with 1 method)

julia> @noinline function grandparent()
           try
               parent()
           catch err
               println("ERROR: ", err.msg)
               catch_stacktrace()
           end
       end
grandparent (generic function with 1 method)

julia> grandparent()
ERROR: Whoops!
7-element Array{StackFrame,1}:
 child() at REPL[1]:1
 parent() at REPL[2]:1
 grandparent() at REPL[3]:3
[...]
\end{minted}



\hypertarget{10595232015135904423}{}


\section{Comparación con \texttt{backtrace()}}



Una llamada a \hyperlink{6187626674327343338}{\texttt{backtrace()}} devuelve un vector de \texttt{Ptr\{Void\}}, que puede pasarse luego a \hyperlink{11964270650763140298}{\texttt{stacktrace()}} para la traducción:




\begin{minted}{jlcon}
julia> trace = backtrace()
21-element Array{Ptr{Void},1}:
 Ptr{Void} @0x00007f10049d5b2f
 Ptr{Void} @0x00007f0ffeb4d29c
 Ptr{Void} @0x00007f0ffeb4d2a9
 Ptr{Void} @0x00007f1004993fe7
 Ptr{Void} @0x00007f10049a92be
 Ptr{Void} @0x00007f10049a823a
 Ptr{Void} @0x00007f10049a9fb0
 Ptr{Void} @0x00007f10049aa718
 Ptr{Void} @0x00007f10049c0d5e
 Ptr{Void} @0x00007f10049a3286
 Ptr{Void} @0x00007f0ffe9ba3ba
 Ptr{Void} @0x00007f0ffe9ba3d0
 Ptr{Void} @0x00007f1004993fe7
 Ptr{Void} @0x00007f0ded34583d
 Ptr{Void} @0x00007f0ded345a87
 Ptr{Void} @0x00007f1004993fe7
 Ptr{Void} @0x00007f0ded34308f
 Ptr{Void} @0x00007f0ded343320
 Ptr{Void} @0x00007f1004993fe7
 Ptr{Void} @0x00007f10049aeb67
 Ptr{Void} @0x0000000000000000

julia> stacktrace(trace)
5-element Array{StackFrame,1}:
 backtrace() at error.jl:46
 eval(::Module, ::Any) at boot.jl:236
 eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66
 macro expansion at REPL.jl:97 [inlined]
 (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73
\end{minted}



Observe que el vector devuelto por \hyperlink{6187626674327343338}{\texttt{backtrace()}} tenía 21 punteros, mientras que el vector devuelto por \hyperlink{11964270650763140298}{\texttt{stacktrace()}} solo tiene 5. Esto es porque, de forma predeterminada, \hyperlink{11964270650763140298}{\texttt{stacktrace()}} elimina cualquier función C de nivel inferior de la pila. Si desea incluir cuadros de pila de llamadas C, puede hacerlo así:




\begin{minted}{jlcon}
julia> stacktrace(trace, true)
27-element Array{StackFrame,1}:
 jl_backtrace_from_here at stackwalk.c:103
 backtrace() at error.jl:46
 backtrace() at sys.so:?
 jl_call_method_internal at julia_internal.h:248 [inlined]
 jl_apply_generic at gf.c:2215
 do_call at interpreter.c:75
 eval at interpreter.c:215
 eval_body at interpreter.c:519
 jl_interpret_toplevel_thunk at interpreter.c:664
 jl_toplevel_eval_flex at toplevel.c:592
 jl_toplevel_eval_in at builtins.c:614
 eval(::Module, ::Any) at boot.jl:236
 eval(::Module, ::Any) at sys.so:?
 jl_call_method_internal at julia_internal.h:248 [inlined]
 jl_apply_generic at gf.c:2215
 eval_user_input(::Any, ::Base.REPL.REPLBackend) at REPL.jl:66
 ip:0x7f1c707f1846
 jl_call_method_internal at julia_internal.h:248 [inlined]
 jl_apply_generic at gf.c:2215
 macro expansion at REPL.jl:97 [inlined]
 (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at event.jl:73
 ip:0x7f1c707ea1ef
 jl_call_method_internal at julia_internal.h:248 [inlined]
 jl_apply_generic at gf.c:2215
 jl_apply at julia.h:1411 [inlined]
 start_task at task.c:261
 ip:0xffffffffffffffff
\end{minted}



Los punteros individuales devueltos por \hyperlink{6187626674327343338}{\texttt{backtrace()}} se pueden traducir a \hyperlink{16824886840215699957}{\texttt{StackFrame}} s pasándolos a \hyperlink{1451426077045795515}{\texttt{StackTraces.lookup()}}:




\begin{minted}{jlcon}
julia> pointer = backtrace()[1];

julia> frame = StackTraces.lookup(pointer)
1-element Array{StackFrame,1}:
 jl_backtrace_from_here at stackwalk.c:103

julia> println("The top frame is from $(frame[1].func)!")
The top frame is from jl_backtrace_from_here!
\end{minted}



\hypertarget{3908315974291496321}{}


\chapter{Performance Tips}



In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.



\hypertarget{8908549671364476026}{}


\section{Avoid global variables}



A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.



Any code that is performance critical or being benchmarked should be inside a function.



We find that global names are frequently constants, and declaring them as such greatly improves performance:




\begin{minted}{julia}
const DEFAULT_VAL = 0
\end{minted}



Uses of non-constant globals can be optimized by annotating their types at the point of use:




\begin{minted}{julia}
global x
y = f(x::Int + 1)
\end{minted}



Writing functions is better style. It leads to more reusable code and clarifies what steps are being done, and what their inputs and outputs are.



\begin{quote}
\textbf{Note}

All code in the REPL is evaluated in global scope, so a variable defined and assigned at toplevel will be a \textbf{global} variable.

\end{quote}


In the following REPL session:




\begin{minted}{jlcon}
julia> x = 1.0
\end{minted}



is equivalent to:




\begin{minted}{jlcon}
julia> global x = 1.0
\end{minted}



so all the performance issues discussed previously apply.



\hypertarget{1385939278590919882}{}


\section{Measure performance with \texttt{@time} and pay attention to memory allocation}



A useful tool for measuring performance is the \hyperlink{8029752041511656628}{\texttt{@time}} macro. The following example illustrates good working style:




\begin{minted}{jlcon}
julia> function f(n)
           s = 0
           for i = 1:n
               s += i/2
           end
           s
       end
f (generic function with 1 method)

julia> @time f(1)
  0.012686 seconds (2.09 k allocations: 103.421 KiB)
0.5

julia> @time f(10^6)
  0.021061 seconds (3.00 M allocations: 45.777 MiB, 11.69% gc time)
2.5000025e11
\end{minted}



On the first call (\texttt{@time f(1)}), \texttt{f} gets compiled.  (If you{\textquotesingle}ve not yet used \hyperlink{8029752041511656628}{\texttt{@time}} in this session, it will also compile functions needed for timing.)  You should not take the results of this run seriously. For the second run, note that in addition to reporting the time, it also indicated that a large amount of memory was allocated. This is the single biggest advantage of \hyperlink{8029752041511656628}{\texttt{@time}} vs. functions like \hyperlink{15143202356224875278}{\texttt{tic()}} and \hyperlink{16488371574475401451}{\texttt{toc()}}, which only report time.



Unexpected memory allocation is almost always a sign of some problem with your code, usually a problem with type-stability. Consequently, in addition to the allocation itself, it{\textquotesingle}s very likely that the code generated for your function is far from optimal. Take such indications seriously and follow the advice below.



For more serious benchmarking, consider the \href{https://github.com/JuliaCI/BenchmarkTools.jl}{BenchmarkTools.jl} package which evaluates the function multiple times in order to reduce noise.



As a teaser, an improved version of this function allocates no memory (the allocation reported below is due to running the \texttt{@time} macro in global scope) and has an order of magnitude faster execution after the first call:




\begin{minted}{jlcon}
julia> @time f_improved(1)
  0.007008 seconds (1.32 k allocations: 63.640 KiB)
0.5

julia> @time f_improved(10^6)
  0.002997 seconds (6 allocations: 192 bytes)
2.5000025e11
\end{minted}



Below you{\textquotesingle}ll learn how to spot the problem with \texttt{f} and how to fix it.



In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the \hyperlink{14350444000650775715}{tools} below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see \hyperlink{3053939932383108875}{Pre-allocating outputs}).



\hypertarget{14350444000650775715}{}


\section{Tools}



Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:



\begin{itemize}
\item \hyperlink{13874102823603666739}{Profiling} allows you to measure the performance of your running code and identify lines that serve as bottlenecks.  For complex projects, the \href{https://github.com/timholy/ProfileView.jl}{ProfileView} package can help you visualize your profiling results.


\item Unexpectedly-large memory allocations–as reported by \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{5377755456008435782}{\texttt{@allocated}}, or the profiler (through calls to the garbage-collection routines)–hint that there might be issues with your code.  If you don{\textquotesingle}t see another reason for the allocations, suspect a type problem.  You can also start Julia with the \texttt{--track-allocation=user} option and examine the resulting \texttt{*.mem} files to see information about where those allocations occur.  See \hyperlink{10992983602239333354}{Memory allocation analysis}.


\item \texttt{@code\_warntype} generates a representation of your code that can be helpful in finding expressions that result in type uncertainty. See \hyperlink{7509450972834198661}{\texttt{@code\_warntype}} below.


\item The \href{https://github.com/tonyhffong/Lint.jl}{Lint} package can also warn you of certain types of programming errors.

\end{itemize}


\hypertarget{10897967302437980226}{}


\section{Avoid containers with abstract type parameters}



When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible.



Consider the following:




\begin{minted}{julia}
a = Real[]    # typeof(a) = Array{Real,1}
if (f = rand()) < .8
    push!(a, f)
end
\end{minted}



Because \texttt{a} is a an array of abstract type \hyperlink{6175959395021454412}{\texttt{Real}}, it must be able to hold any \texttt{Real} value.  Since \texttt{Real} objects can be of arbitrary size and structure, \texttt{a} must be represented as an array of pointers to individually allocated \texttt{Real} objects. Because \texttt{f} will always be a \hyperlink{5027751419500983000}{\texttt{Float64}}, we should instead, use:




\begin{minted}{julia}
a = Float64[] # typeof(a) = Array{Float64,1}
\end{minted}



which will create a contiguous block of 64-bit floating-point values that can be manipulated efficiently.



See also the discussion under \hyperlink{15542027490314302254}{Parametric Types}.



\hypertarget{14626636305597624304}{}


\section{Type declarations}



In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is \emph{not} the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.



\hypertarget{1456452126529302259}{}


\subsection{Avoid fields with abstract type}



Types can be declared without specifying the types of their fields:




\begin{lstlisting}
julia> struct MyAmbiguousType
           a
       end
\end{lstlisting}



This allows \texttt{a} to be of any type. This can often be useful, but it does have a downside: for objects of type \texttt{MyAmbiguousType}, the compiler will not be able to generate high-performance code.  The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type \texttt{MyAmbiguousType}:




\begin{lstlisting}
julia> b = MyAmbiguousType("Hello")
MyAmbiguousType("Hello")

julia> c = MyAmbiguousType(17)
MyAmbiguousType(17)

julia> typeof(b)
MyAmbiguousType

julia> typeof(c)
MyAmbiguousType
\end{lstlisting}



\texttt{b} and \texttt{c} have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field \texttt{a}, the fact that the memory representation of a \hyperlink{6609065134969660118}{\texttt{UInt8}} differs from a \hyperlink{5027751419500983000}{\texttt{Float64}} also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.



You can do better by declaring the type of \texttt{a}. Here, we are focused on the case where \texttt{a} might be any one of several types, in which case the natural solution is to use parameters. For example:




\begin{lstlisting}
julia> mutable struct MyType{T<:AbstractFloat}
           a::T
       end
\end{lstlisting}



This is a better choice than




\begin{lstlisting}
julia> mutable struct MyStillAmbiguousType
           a::AbstractFloat
       end
\end{lstlisting}



because the first version specifies the type of \texttt{a} from the type of the wrapper object.  For example:




\begin{lstlisting}
julia> m = MyType(3.2)
MyType{Float64}(3.2)

julia> t = MyStillAmbiguousType(3.2)
MyStillAmbiguousType(3.2)

julia> typeof(m)
MyType{Float64}

julia> typeof(t)
MyStillAmbiguousType
\end{lstlisting}



The type of field \texttt{a} can be readily determined from the type of \texttt{m}, but not from the type of \texttt{t}.  Indeed, in \texttt{t} it{\textquotesingle}s possible to change the type of field \texttt{a}:




\begin{lstlisting}
julia> typeof(t.a)
Float64

julia> t.a = 4.5f0
4.5f0

julia> typeof(t.a)
Float32
\end{lstlisting}



In contrast, once \texttt{m} is constructed, the type of \texttt{m.a} cannot change:




\begin{lstlisting}
julia> m.a = 4.5f0
4.5f0

julia> typeof(m.a)
Float64
\end{lstlisting}



The fact that the type of \texttt{m.a} is known from \texttt{m}{\textquotesingle}s type–coupled with the fact that its type cannot change mid-function–allows the compiler to generate highly-optimized code for objects like \texttt{m} but not for objects like \texttt{t}.



Of course, all of this is true only if we construct \texttt{m} with a concrete type.  We can break this by explicitly constructing it with an abstract type:




\begin{lstlisting}
julia> m = MyType{AbstractFloat}(3.2)
MyType{AbstractFloat}(3.2)

julia> typeof(m.a)
Float64

julia> m.a = 4.5f0
4.5f0

julia> typeof(m.a)
Float32
\end{lstlisting}



For all practical purposes, such objects behave identically to those of \texttt{MyStillAmbiguousType}.



It{\textquotesingle}s quite instructive to compare the sheer amount code generated for a simple function




\begin{minted}{julia}
func(m::MyType) = m.a+1
\end{minted}



using




\begin{minted}{julia}
code_llvm(func,Tuple{MyType{Float64}})
code_llvm(func,Tuple{MyType{AbstractFloat}})
code_llvm(func,Tuple{MyType})
\end{minted}



For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn{\textquotesingle}t need to generate any code to resolve the type at run-time. This results in shorter and faster code.



\hypertarget{14656612614164373357}{}


\subsection{Avoid fields with abstract containers}



The same best practices also work for container types:




\begin{lstlisting}
julia> mutable struct MySimpleContainer{A<:AbstractVector}
           a::A
       end

julia> mutable struct MyAmbiguousContainer{T}
           a::AbstractVector{T}
       end
\end{lstlisting}



For example:




\begin{lstlisting}
julia> c = MySimpleContainer(1:3);

julia> typeof(c)
MySimpleContainer{UnitRange{Int64}}

julia> c = MySimpleContainer([1:3;]);

julia> typeof(c)
MySimpleContainer{Array{Int64,1}}

julia> b = MyAmbiguousContainer(1:3);

julia> typeof(b)
MyAmbiguousContainer{Int64}

julia> b = MyAmbiguousContainer([1:3;]);

julia> typeof(b)
MyAmbiguousContainer{Int64}
\end{lstlisting}



For \texttt{MySimpleContainer}, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.



While the compiler can now do its job perfectly well, there are cases where \emph{you} might wish that your code could do different things depending on the \emph{element type} of \texttt{a}.  Usually the best way to achieve this is to wrap your specific operation (here, \texttt{foo}) in a separate function:




\begin{lstlisting}
julia> function sumfoo(c::MySimpleContainer)
           s = 0
           for x in c.a
               s += foo(x)
           end
           s
       end
sumfoo (generic function with 1 method)

julia> foo(x::Integer) = x
foo (generic function with 1 method)

julia> foo(x::AbstractFloat) = round(x)
foo (generic function with 2 methods)
\end{lstlisting}



This keeps things simple, while allowing the compiler to generate optimized code in all cases.



However, there are cases where you may need to declare different versions of the outer function for different element types of \texttt{a}. You could do it like this:




\begin{lstlisting}
function myfun(c::MySimpleContainer{Vector{T}}) where T<:AbstractFloat
    ...
end
function myfun(c::MySimpleContainer{Vector{T}}) where T<:Integer
    ...
end
\end{lstlisting}



This works fine for \texttt{Vector\{T\}}, but we{\textquotesingle}d also have to write explicit versions for \texttt{UnitRange\{T\}} or other abstract types. To prevent such tedium, you can use two parameters in the declaration of \texttt{MyContainer}:




\begin{lstlisting}
julia> mutable struct MyContainer{T, A<:AbstractVector}
           a::A
       end

julia> MyContainer(v::AbstractVector) = MyContainer{eltype(v), typeof(v)}(v)
MyContainer

julia> b = MyContainer(1:5);

julia> typeof(b)
MyContainer{Int64,UnitRange{Int64}}
\end{lstlisting}



Note the somewhat surprising fact that \texttt{T} doesn{\textquotesingle}t appear in the declaration of field \texttt{a}, a point that we{\textquotesingle}ll return to in a moment. With this approach, one can write functions such as:




\begin{lstlisting}
julia> function myfunc(c::MyContainer{<:Integer, <:AbstractArray})
           return c.a[1]+1
       end
myfunc (generic function with 1 method)

julia> function myfunc(c::MyContainer{<:AbstractFloat})
           return c.a[1]+2
       end
myfunc (generic function with 2 methods)

julia> function myfunc(c::MyContainer{T,Vector{T}}) where T<:Integer
           return c.a[1]+3
       end
myfunc (generic function with 3 methods)
\end{lstlisting}



\begin{quote}
\textbf{Note}

Because we can only define \texttt{MyContainer} for \texttt{A<:AbstractArray}, and any unspecified parameters are arbitrary, the first function above could have been written more succinctly as \texttt{function myfunc\{T<:Integer\}(c::MyContainer\{T\})}

\end{quote}



\begin{lstlisting}
julia> myfunc(MyContainer(1:3))
2

julia> myfunc(MyContainer(1.0:3))
3.0

julia> myfunc(MyContainer([1:3;]))
4
\end{lstlisting}



As you can see, with this approach it{\textquotesingle}s possible to specialize on both the element type \texttt{T} and the array type \texttt{A}.



However, there{\textquotesingle}s one remaining hole: we haven{\textquotesingle}t enforced that \texttt{A} has element type \texttt{T}, so it{\textquotesingle}s perfectly possible to construct an object like this:




\begin{lstlisting}
julia> b = MyContainer{Int64, UnitRange{Float64}}(UnitRange(1.3, 5.0));

julia> typeof(b)
MyContainer{Int64,UnitRange{Float64}}
\end{lstlisting}



To prevent this, we can add an inner constructor:




\begin{lstlisting}
julia> mutable struct MyBetterContainer{T<:Real, A<:AbstractVector}
           a::A
           MyBetterContainer{T,A}(v::AbstractVector{T}) where {T,A} = new(v)
       end

julia> MyBetterContainer(v::AbstractVector) = MyBetterContainer{eltype(v),typeof(v)}(v)
MyBetterContainer

julia> b = MyBetterContainer(UnitRange(1.3, 5.0));

julia> typeof(b)
MyBetterContainer{Float64,UnitRange{Float64}}

julia> b = MyBetterContainer{Int64, UnitRange{Float64}}(UnitRange(1.3, 5.0));
ERROR: MethodError: Cannot `convert` an object of type UnitRange{Float64} to an object of type MyBetterContainer{Int64,UnitRange{Float64}}
[...]
\end{lstlisting}



The inner constructor requires that the element type of \texttt{A} be \texttt{T}.



\hypertarget{8349945497889639186}{}


\subsection{Annotate values taken from untyped locations}



It is often convenient to work with data structures that may contain values of any type (arrays of type \texttt{Array\{Any\}}). But, if you{\textquotesingle}re using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:




\begin{minted}{julia}
function foo(a::Array{Any,1})
    x = a[1]::Int32
    b = x+1
    ...
end
\end{minted}



Here, we happened to know that the first element of \texttt{a} would be an \hyperlink{10103694114785108551}{\texttt{Int32}}. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.



\hypertarget{3940644267230903518}{}


\subsection{Declare types of keyword arguments}



Keyword arguments can have declared types:




\begin{minted}{julia}
function with_keyword(x; name::Int = 1)
    ...
end
\end{minted}



Functions are specialized on the types of keyword arguments, so these declarations will not affect performance of code inside the function. However, they will reduce the overhead of calls to the function that include keyword arguments.



Functions with keyword arguments have near-zero overhead for call sites that pass only positional arguments.



Passing dynamic lists of keyword arguments, as in \texttt{f(x; keywords...)}, can be slow and should be avoided in performance-sensitive code.



\hypertarget{46524760051978294}{}


\section{Break functions into multiple definitions}



Writing a function as many small definitions allows the compiler to directly call the most applicable code, or even inline it.



Here is an example of a {\textquotedbl}compound function{\textquotedbl} that should really be written as multiple definitions:




\begin{minted}{julia}
function norm(A)
    if isa(A, Vector)
        return sqrt(real(dot(A,A)))
    elseif isa(A, Matrix)
        return maximum(svd(A)[2])
    else
        error("norm: invalid argument")
    end
end
\end{minted}



This can be written more concisely and efficiently as:




\begin{minted}{julia}
norm(x::Vector) = sqrt(real(dot(x,x)))
norm(A::Matrix) = maximum(svd(A)[2])
\end{minted}



\hypertarget{11858157923263469229}{}


\section{Write {\textquotedbl}type-stable{\textquotedbl} functions}



When possible, it helps to ensure that a function always returns a value of the same type. Consider the following definition:




\begin{minted}{julia}
pos(x) = x < 0 ? 0 : x
\end{minted}



Although this seems innocent enough, the problem is that \texttt{0} is an integer (of type \texttt{Int}) and \texttt{x} might be of any type. Thus, depending on the value of \texttt{x}, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:




\begin{minted}{julia}
pos(x) = x < 0 ? zero(x) : x
\end{minted}



There is also a \hyperlink{11395333326208453101}{\texttt{one()}} function, and a more general \hyperlink{374166931194490566}{\texttt{oftype(x, y)}} function, which returns \texttt{y} converted to the type of \texttt{x}.



\hypertarget{8500497942804690009}{}


\section{Avoid changing the type of a variable}



An analogous {\textquotedbl}type-stability{\textquotedbl} problem exists for variables used repeatedly within a function:




\begin{minted}{julia}
function foo()
    x = 1
    for i = 1:10
        x = x/bar()
    end
    return x
end
\end{minted}



Local variable \texttt{x} starts as an integer, and after one loop iteration becomes a floating-point number (the result of \hyperlink{4103478871488785445}{\texttt{/}} operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:



\begin{itemize}
\item Initialize \texttt{x} with \texttt{x = 1.0}


\item Declare the type of \texttt{x}: \texttt{x::Float64 = 1}


\item Use an explicit conversion: \texttt{x = oneunit(T)}


\item Initialize with the first loop iteration, to \texttt{x = 1/bar()}, then loop \texttt{for i = 2:10}

\end{itemize}


\hypertarget{13103982983044032238}{}


\section{Separate kernel functions (aka, function barriers)}



Many functions follow a pattern of performing some set-up work, and then running many iterations to perform a core computation. Where possible, it is a good idea to put these core computations in separate functions. For example, the following contrived function returns an array of a randomly-chosen type:






\begin{minted}{jlcon}
julia> function strange_twos(n)
           a = Vector{rand(Bool) ? Int64 : Float64}(n)
           for i = 1:n
               a[i] = 2
           end
           return a
       end
strange_twos (generic function with 1 method)

julia> strange_twos(3)
3-element Array{Float64,1}:
 2.0
 2.0
 2.0
\end{minted}



This should be written as:




\begin{minted}{jlcon}
julia> function fill_twos!(a)
           for i=1:length(a)
               a[i] = 2
           end
       end
fill_twos! (generic function with 1 method)

julia> function strange_twos(n)
           a = Array{rand(Bool) ? Int64 : Float64}(n)
           fill_twos!(a)
           return a
       end
strange_twos (generic function with 1 method)

julia> strange_twos(3)
3-element Array{Float64,1}:
 2.0
 2.0
 2.0
\end{minted}



Julia{\textquotesingle}s compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of \texttt{a} during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of \texttt{fill\_twos!} for different types of \texttt{a}.



The second form is also often better style and can lead to more code reuse.



This pattern is used in several places in the standard library. For example, see \texttt{hvcat\_fill} in \href{https://github.com/JuliaLang/julia/blob/master/base/abstractarray.jl}{\texttt{abstractarray.jl}}, or the \hyperlink{5162290739791026948}{\texttt{fill!}} function, which we could have used instead of writing our own \texttt{fill\_twos!}.



Functions like \texttt{strange\_twos} occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.



\hypertarget{14283833063419818391}{}


\section{Types with values-as-parameters}



Let{\textquotesingle}s say you want to create an \texttt{N}-dimensional array that has size 3 along each axis.  Such arrays can be created like this:




\begin{minted}{jlcon}
julia> A = fill(5.0, (3, 3))
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



This approach works very well: the compiler can figure out that \texttt{A} is an \texttt{Array\{Float64,2\}} because it knows the type of the fill value (\texttt{5.0::Float64}) and the dimensionality (\texttt{(3, 3)::NTuple\{2,Int\}}). This implies that the compiler can generate very efficient code for any future usage of \texttt{A} in the same function.



But now let{\textquotesingle}s say you want to write a function that creates a 3×3×... array in arbitrary dimensions; you might be tempted to write a function




\begin{minted}{jlcon}
julia> function array3(fillval, N)
           fill(fillval, ntuple(d->3, N))
       end
array3 (generic function with 1 method)

julia> array3(5.0, 2)
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



This works, but (as you can verify for yourself using \texttt{@code\_warntype array3(5.0, 2)}) the problem is that the output type cannot be inferred: the argument \texttt{N} is a \emph{value} of type \texttt{Int}, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of \texttt{A}; such code will be very slow.



Now, one very good way to solve such problems is by using the \hyperlink{13103982983044032238}{function-barrier technique}. However, in some cases you might want to eliminate the type-instability altogether.  In such cases, one approach is to pass the dimensionality as a parameter, for example through \texttt{Val\{T\}} (see \hyperlink{10522953672803278470}{{\textquotedbl}Value types{\textquotedbl}}):




\begin{minted}{jlcon}
julia> function array3(fillval, ::Type{Val{N}}) where N
           fill(fillval, ntuple(d->3, Val{N}))
       end
array3 (generic function with 1 method)

julia> array3(5.0, Val{2})
3×3 Array{Float64,2}:
 5.0  5.0  5.0
 5.0  5.0  5.0
 5.0  5.0  5.0
\end{minted}



Julia has a specialized version of \texttt{ntuple} that accepts a \texttt{Val\{::Int\}} as the second parameter; by passing \texttt{N} as a type-parameter, you make its {\textquotedbl}value{\textquotedbl} known to the compiler. Consequently, this version of \texttt{array3} allows the compiler to predict the return type.



However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called \texttt{array3} from a function like this:




\begin{minted}{julia}
function call_array3(fillval, n)
    A = array3(fillval, Val{n})
end
\end{minted}



Here, you{\textquotesingle}ve created the same problem all over again: the compiler can{\textquotesingle}t guess the type of \texttt{n}, so it doesn{\textquotesingle}t know the type of \texttt{Val\{n\}}.  Attempting to use \texttt{Val}, but doing so incorrectly, can easily make performance \emph{worse} in many situations.  (Only in situations where you{\textquotesingle}re effectively combining \texttt{Val} with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)



An example of correct usage of \texttt{Val} would be:




\begin{minted}{julia}
function filter3(A::AbstractArray{T,N}) where {T,N}
    kernel = array3(1, Val{N})
    filter(A, kernel)
end
\end{minted}



In this example, \texttt{N} is passed as a parameter, so its {\textquotedbl}value{\textquotedbl} is known to the compiler.  Essentially, \texttt{Val\{T\}} works only when \texttt{T} is either hard-coded (\texttt{Val\{3\}}) or already specified in the type-domain.



\hypertarget{5410118045861360063}{}


\section{The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)}



Once one learns to appreciate multiple dispatch, there{\textquotesingle}s an understandable tendency to go crazy and try to use it for everything. For example, you might imagine using it to store information, e.g.




\begin{lstlisting}
struct Car{Make,Model}
    year::Int
    ...more fields...
end
\end{lstlisting}



and then dispatch on objects like \texttt{Car\{:Honda,:Accord\}(year, args...)}.



This might be worthwhile when the following are true:



\begin{itemize}
\item You require CPU-intensive processing on each \texttt{Car}, and it becomes vastly more efficient if you know the \texttt{Make} and \texttt{Model} at compile time.


\item You have homogenous lists of the same type of \texttt{Car} to process, so that you can store them all in an \texttt{Array\{Car\{:Honda,:Accord\},N\}}.

\end{itemize}


When the latter holds, a function processing such a homogenous array can be productively specialized: Julia knows the type of each element in advance (all objects in the container have the same concrete type), so Julia can {\textquotedbl}look up{\textquotedbl} the correct method calls when the function is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list.



When these do not hold, then it{\textquotesingle}s likely that you{\textquotesingle}ll get no benefit; worse, the resulting {\textquotedbl}combinatorial explosion of types{\textquotedbl} will be counterproductive.  If \texttt{items[i+1]} has a different type than \texttt{item[i]}, Julia has to look up the type at run-time, search for the appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In essence, you{\textquotesingle}re asking the full type- system and JIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary lookup in your own code.



Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a {\textquotedbl}switch{\textquotedbl} statement can be found \href{https://groups.google.com/forum/\#!msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ}{on the mailing list}.



Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized functions for each different \texttt{Car\{Make, Model\}}; if you have hundreds or thousands of such types, then every function that accepts such an object as a parameter (from a custom \texttt{get\_year} function you might write yourself, to the generic \texttt{push!} function in the standard library) will have hundreds or thousands of variants compiled for it.  Each of these increases the size of the cache of compiled code, the length of internal lists of methods, etc.  Excess enthusiasm for values-as-parameters can easily waste enormous resources.



\hypertarget{18377588874636550850}{}


\section{Access arrays in memory order, along columns}



Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be verified using the \texttt{vec} function or the syntax \texttt{[:]} as shown below (notice that the array is ordered \texttt{[1 3 2 4]}, not \texttt{[1 2 3 4]}):




\begin{minted}{jlcon}
julia> x = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> x[:]
4-element Array{Int64,1}:
 1
 3
 2
 4
\end{minted}



This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (\texttt{numpy}) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.



Consider the following contrived example. Imagine we wanted to write a function that accepts a \texttt{Vector} and returns a square \texttt{Matrix} with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in \hyperlink{7643954538117657889}{\texttt{repmat()}}):




\begin{minted}{julia}
function copy_cols(x::Vector{T}) where T
    n = size(x, 1)
    out = Array{T}(n, n)
    for i = 1:n
        out[:, i] = x
    end
    out
end

function copy_rows(x::Vector{T}) where T
    n = size(x, 1)
    out = Array{T}(n, n)
    for i = 1:n
        out[i, :] = x
    end
    out
end

function copy_col_row(x::Vector{T}) where T
    n = size(x, 1)
    out = Array{T}(n, n)
    for col = 1:n, row = 1:n
        out[row, col] = x[row]
    end
    out
end

function copy_row_col(x::Vector{T}) where T
    n = size(x, 1)
    out = Array{T}(n, n)
    for row = 1:n, col = 1:n
        out[row, col] = x[col]
    end
    out
end
\end{minted}



Now we will time each of these functions using the same random \texttt{10000} by \texttt{1} input vector:




\begin{minted}{jlcon}
julia> x = randn(10000);

julia> fmt(f) = println(rpad(string(f)*": ", 14, ' '), @elapsed f(x))

julia> map(fmt, Any[copy_cols, copy_rows, copy_col_row, copy_row_col]);
copy_cols:    0.331706323
copy_rows:    1.799009911
copy_col_row: 0.415630047
copy_row_col: 1.721531501
\end{minted}



Notice that \texttt{copy\_cols} is much faster than \texttt{copy\_rows}. This is expected because \texttt{copy\_cols} respects the column-based memory layout of the \texttt{Matrix} and fills it one column at a time. Additionally, \texttt{copy\_col\_row} is much faster than \texttt{copy\_row\_col} because it follows our rule of thumb that the first element to appear in a slice expression should be coupled with the inner-most loop.



\hypertarget{3053939932383108875}{}


\section{Pre-allocating outputs}



If your function returns an \texttt{Array} or some other complex type, it may have to allocate memory.  Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.



Sometimes you can circumvent the need to allocate memory on each function call by preallocating the output.  As a trivial example, compare




\begin{minted}{julia}
function xinc(x)
    return [x, x+1, x+2]
end

function loopinc()
    y = 0
    for i = 1:10^7
        ret = xinc(i)
        y += ret[2]
    end
    y
end
\end{minted}



with




\begin{minted}{julia}
function xinc!(ret::AbstractVector{T}, x::T) where T
    ret[1] = x
    ret[2] = x+1
    ret[3] = x+2
    nothing
end

function loopinc_prealloc()
    ret = Array{Int}(3)
    y = 0
    for i = 1:10^7
        xinc!(ret, i)
        y += ret[2]
    end
    y
end
\end{minted}



Timing results:




\begin{minted}{jlcon}
julia> @time loopinc()
  0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)
50000015000000

julia> @time loopinc_prealloc()
  0.030850 seconds (6 allocations: 288 bytes)
50000015000000
\end{minted}



Preallocation has other advantages, for example by allowing the caller to control the {\textquotedbl}output{\textquotedbl} type from an algorithm.  In the example above, we could have passed a \texttt{SubArray} rather than an \hyperlink{15492651498431872487}{\texttt{Array}}, had we so desired.



Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for {\textquotedbl}vectorized{\textquotedbl} (element-wise) functions, the convenient syntax \texttt{x .= f.(y)} can be used for in-place operations with fused loops and no temporary arrays (see the \hyperlink{13590013989415065742}{dot syntax for vectorizing functions}).



\hypertarget{17646926318481901948}{}


\section{More dots: Fuse vectorized operations}



Julia has a special \hyperlink{13590013989415065742}{dot syntax} that converts any scalar function into a {\textquotedbl}vectorized{\textquotedbl} function call, and any operator into a {\textquotedbl}vectorized{\textquotedbl} operator, with the special property that nested {\textquotedbl}dot calls{\textquotedbl} are \emph{fusing}: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use \texttt{.=} and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).



In a linear-algebra context, this means that even though operations like \texttt{vector + vector} and \texttt{vector * scalar} are defined, it can be advantageous to instead use \texttt{vector .+ vector} and \texttt{vector .* scalar} because the resulting loops can be fused with surrounding computations. For example, consider the two functions:




\begin{minted}{julia}
f(x) = 3x.^2 + 4x + 7x.^3

fdot(x) = @. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3
\end{minted}



Both \texttt{f} and \texttt{fdot} compute the same thing.  However, \texttt{fdot} (defined with the help of the \hyperlink{16688502228717894452}{\texttt{@.}} macro) is significantly faster when applied to an array:




\begin{minted}{jlcon}
julia> x = rand(10^6);

julia> @time f(x);
  0.010986 seconds (18 allocations: 53.406 MiB, 11.45% gc time)

julia> @time fdot(x);
  0.003470 seconds (6 allocations: 7.630 MiB)

julia> @time f.(x);
  0.003297 seconds (30 allocations: 7.631 MiB)
\end{minted}



That is, \texttt{fdot(x)} is three times faster and allocates 1/7 the memory of \texttt{f(x)}, because each \texttt{*} and \texttt{+} operation in \texttt{f(x)} allocates a new temporary array and executes in a separate loop. (Of course, if you just do \texttt{f.(x)} then it is as fast as \texttt{fdot(x)} in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)



\hypertarget{10279107342440166344}{}


\section{Consider using views for slices}



In Julia, an array {\textquotedbl}slice{\textquotedbl} expression like \texttt{array[1:5, :]} creates a copy of that data (except on the left-hand side of an assignment, where \texttt{array[1:5, :] = ...} assigns in-place to that portion of \texttt{array}). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.



An alternative is to create a {\textquotedbl}view{\textquotedbl} of the array, which is an array object (a \texttt{SubArray}) that actually references the data of the original array in-place, without making a copy.  (If you write to a view, it modifies the original array{\textquotesingle}s data as well.) This can be done for individual slices by calling \hyperlink{4861450464669906845}{\texttt{view()}}, or more simply for a whole expression or block of code by putting \hyperlink{4544474300423667148}{\texttt{@views}} in front of that expression.  For example:




\begin{minted}{jlcon}
julia> fcopy(x) = sum(x[2:end-1])

julia> @views fview(x) = sum(x[2:end-1])

julia> x = rand(10^6);

julia> @time fcopy(x);
  0.003051 seconds (7 allocations: 7.630 MB)

julia> @time fview(x);
  0.001020 seconds (6 allocations: 224 bytes)
\end{minted}



Notice both the 3× speedup and the decreased memory allocation of the \texttt{fview} version of the function.



\hypertarget{17505542591786045379}{}


\section{Avoid string interpolation for I/O}



When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of:




\begin{minted}{julia}
println(file, "$a $b")
\end{minted}



use:




\begin{minted}{julia}
println(file, a, " ", b)
\end{minted}



The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:




\begin{minted}{julia}
println(file, "$(f(a))$(f(b))")
\end{minted}



versus:




\begin{minted}{julia}
println(file, f(a), f(b))
\end{minted}



\hypertarget{4757281004083031972}{}


\section{Optimize network I/O during parallel execution}



When executing a remote function in parallel:




\begin{minted}{julia}
responses = Vector{Any}(nworkers())
@sync begin
    for (idx, pid) in enumerate(workers())
        @async responses[idx] = remotecall_fetch(pid, foo, args...)
    end
end
\end{minted}



is faster than:




\begin{minted}{julia}
refs = Vector{Any}(nworkers())
for (idx, pid) in enumerate(workers())
    refs[idx] = @spawnat pid foo(args...)
end
responses = [fetch(r) for r in refs]
\end{minted}



The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the \hyperlink{13196020699522784599}{\texttt{@spawnat}} and the second due to the \hyperlink{7098010828229464277}{\texttt{fetch}} (or even a \hyperlink{13761789780433862250}{\texttt{wait}}). The \hyperlink{7098010828229464277}{\texttt{fetch}}/\hyperlink{13761789780433862250}{\texttt{wait}} is also being executed serially resulting in an overall poorer performance.



\hypertarget{15573873242571976679}{}


\section{Fix deprecation warnings}



A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.



\hypertarget{12747370404536591663}{}


\section{Tweaks}



These are some minor points that might help in tight inner loops.



\begin{itemize}
\item Avoid unnecessary arrays. For example, instead of \hyperlink{8666686648688281595}{\texttt{sum([x,y,z])}} use \texttt{x+y+z}.


\item Use \hyperlink{15686257922156163743}{\texttt{abs2(z)}} instead of \hyperlink{5729367935110528960}{\texttt{abs(z){\textasciicircum}2}} for complex \texttt{z}. In general, try to rewrite code to use \hyperlink{15686257922156163743}{\texttt{abs2()}} instead of \hyperlink{9614495866226399167}{\texttt{abs()}} for complex arguments.


\item Use \hyperlink{8020976424566491334}{\texttt{div(x,y)}} for truncating division of integers instead of \hyperlink{7412479111462927551}{\texttt{trunc(x/y)}}, \hyperlink{15067916827074788527}{\texttt{fld(x,y)}} instead of \hyperlink{13948277906659863497}{\texttt{floor(x/y)}}, and \hyperlink{7922388465305816555}{\texttt{cld(x,y)}} instead of \hyperlink{11509984064218511874}{\texttt{ceil(x/y)}}.

\end{itemize}


\hypertarget{10607053427200951903}{}


\section{Performance Annotations}



Sometimes you can enable better optimization by promising certain program properties.



\begin{itemize}
\item Use \texttt{@inbounds} to eliminate array bounds checking within expressions. Be certain before doing this. If the subscripts are ever out of bounds, you may suffer crashes or silent corruption.


\item Use \texttt{@fastmath} to allow floating point optimizations that are correct for real numbers, but lead to differences for IEEE numbers. Be careful when doing this, as this may change numerical results. This corresponds to the \texttt{-ffast-math} option of clang.


\item Write \texttt{@simd} in front of \texttt{for} loops that are amenable to vectorization. \textbf{This feature is experimental} and could change or disappear in future versions of Julia.

\end{itemize}


Note: While \texttt{@simd} needs to be placed directly in front of a loop, both \texttt{@inbounds} and \texttt{@fastmath} can be applied to several statements at once, e.g. using \texttt{begin} ... \texttt{end}, or even to a whole function.



Here is an example with both \texttt{@inbounds} and \texttt{@simd} markup:




\begin{minted}{julia}
function inner(x, y)
    s = zero(eltype(x))
    for i=1:length(x)
        @inbounds s += x[i]*y[i]
    end
    s
end

function innersimd(x, y)
    s = zero(eltype(x))
    @simd for i=1:length(x)
        @inbounds s += x[i]*y[i]
    end
    s
end

function timeit(n, reps)
    x = rand(Float32,n)
    y = rand(Float32,n)
    s = zero(Float64)
    time = @elapsed for j in 1:reps
        s+=inner(x,y)
    end
    println("GFlop/sec        = ",2.0*n*reps/time*1E-9)
    time = @elapsed for j in 1:reps
        s+=innersimd(x,y)
    end
    println("GFlop/sec (SIMD) = ",2.0*n*reps/time*1E-9)
end

timeit(1000,1000)
\end{minted}



On a computer with a 2.4GHz Intel Core i5 processor, this produces:




\begin{lstlisting}
GFlop/sec        = 1.9467069505224963
GFlop/sec (SIMD) = 17.578554163920018
\end{lstlisting}



(\texttt{GFlop/sec} measures the performance, and larger numbers are better.) The range for a \texttt{@simd for} loop should be a one-dimensional range. A variable used for accumulating, such as \texttt{s} in the example, is called a \emph{reduction variable}. By using \texttt{@simd}, you are asserting several properties of the loop:



\begin{itemize}
\item It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.


\item Floating-point operations on reduction variables can be reordered, possibly causing different results than without \texttt{@simd}.


\item No iteration ever waits on another iteration to make forward progress.

\end{itemize}


A loop containing \texttt{break}, \texttt{continue}, or \texttt{@goto} will cause a compile-time error.



Using \texttt{@simd} merely gives the compiler license to vectorize. Whether it actually does so depends on the compiler. To actually benefit from the current implementation, your loop should have the following additional properties:



\begin{itemize}
\item The loop must be an innermost loop.


\item The loop body must be straight-line code. This is why \texttt{@inbounds} is currently needed for all array accesses. The compiler can sometimes turn short \texttt{\&\&}, \texttt{||}, and \texttt{?:} expressions into straight-line code, if it is safe to evaluate all operands unconditionally. Consider using \hyperlink{9861487635347877687}{\texttt{ifelse()}} instead of \texttt{?:} in the loop if it is safe to do so.


\item Accesses must have a stride pattern and cannot be {\textquotedbl}gathers{\textquotedbl} (random-index reads) or {\textquotedbl}scatters{\textquotedbl} (random-index writes).


\item The stride should be unit stride.


\item In some simple cases, for example with 2-3 arrays accessed in a loop, the LLVM auto-vectorization may kick in automatically, leading to no further speedup with \texttt{@simd}.

\end{itemize}


Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:




\begin{minted}{julia}
function init!(u)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds @simd for i in 1:n
        u[i] = sin(2pi*dx*i)
    end
end

function deriv!(u, du)
    n = length(u)
    dx = 1.0 / (n-1)
    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx
    @fastmath @inbounds @simd for i in 2:n-1
        du[i] = (u[i+1] - u[i-1]) / (2*dx)
    end
    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx
end

function norm(u)
    n = length(u)
    T = eltype(u)
    s = zero(T)
    @fastmath @inbounds @simd for i in 1:n
        s += u[i]^2
    end
    @fastmath @inbounds return sqrt(s/n)
end

function main()
    n = 2000
    u = Array{Float64}(n)
    init!(u)
    du = similar(u)

    deriv!(u, du)
    nu = norm(du)

    @time for i in 1:10^6
        deriv!(u, du)
        nu = norm(du)
    end

    println(nu)
end

main()
\end{minted}



On a computer with a 2.7 GHz Intel Core i7 processor, this produces:




\begin{lstlisting}
$ julia wave.jl;
elapsed time: 1.207814709 seconds (0 bytes allocated)

$ julia --math-mode=ieee wave.jl;
elapsed time: 4.487083643 seconds (0 bytes allocated)
\end{lstlisting}



Here, the option \texttt{--math-mode=ieee} disables the \texttt{@fastmath} macro, so that we can compare results.



In this case, the speedup due to \texttt{@fastmath} is a factor of about 3.7. This is unusually large – in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result – in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.



The annotation \texttt{@fastmath} re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression \texttt{1 / (2*dx)} in the function \texttt{deriv} is hoisted out of the loop (i.e. calculated outside the loop), as if one had written \texttt{idx = 1 / (2*dx)}. In the loop, the expression \texttt{... / (2*dx)} then becomes \texttt{... * idx}, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia{\textquotesingle}s \hyperlink{1731537926898979255}{\texttt{code\_native()}} function.



\hypertarget{12370344689233780157}{}


\section{Treat Subnormal Numbers as Zeros}



Subnormal numbers, formerly called \href{https://en.wikipedia.org/wiki/Denormal\_number}{denormal numbers}, are useful in many contexts, but incur a performance penalty on some hardware. A call \hyperlink{2845950135157372113}{\texttt{set\_zero\_subnormals(true)}} grants permission for floating-point operations to treat subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call \hyperlink{2845950135157372113}{\texttt{set\_zero\_subnormals(false)}} enforces strict IEEE behavior for subnormal numbers.



Below is an example where subnormals noticeably impact performance on some hardware:




\begin{minted}{julia}
function timestep(b::Vector{T}, a::Vector{T}, Δt::T) where T
    @assert length(a)==length(b)
    n = length(b)
    b[1] = 1                            # Boundary condition
    for i=2:n-1
        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * Δt
    end
    b[n] = 0                            # Boundary condition
end

function heatflow(a::Vector{T}, nstep::Integer) where T
    b = similar(a)
    for t=1:div(nstep,2)                # Assume nstep is even
        timestep(b,a,T(0.1))
        timestep(a,b,T(0.1))
    end
end

heatflow(zeros(Float32,10),2)           # Force compilation
for trial=1:6
    a = zeros(Float32,1000)
    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic
    @time heatflow(a,1000)
end
\end{minted}



This example generates many subnormal numbers because the values in \texttt{a} become an exponentially decreasing curve, which slowly flattens out over time.



Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as \texttt{x-y == 0} implies \texttt{x == y}:




\begin{minted}{jlcon}
julia> x = 3f-38; y = 2f-38;

julia> set_zero_subnormals(true); (x - y, x == y)
(0.0f0, false)

julia> set_zero_subnormals(false); (x - y, x == y)
(1.0000001f-38, false)
\end{minted}



In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.  For example, instead of initializing \texttt{a} with zeros, initialize it with:




\begin{minted}{julia}
a = rand(Float32,1000) * 1.f-9
\end{minted}



\hypertarget{7082991166860772411}{}


\section{\texttt{@code\_warntype}}



The macro \hyperlink{7509450972834198661}{\texttt{@code\_warntype}} (or its function variant \hyperlink{16883039507765569860}{\texttt{code\_warntype()}}) can sometimes be helpful in diagnosing type-related problems. Here{\textquotesingle}s an example:




\begin{minted}{julia}
pos(x) = x < 0 ? 0 : x

function f(x)
    y = pos(x)
    sin(y*x+1)
end

julia> @code_warntype f(3.2)
Variables:
  #self#::#f
  x::Float64
  y::UNION{FLOAT64,INT64}
  fy::Float64
  #temp#@_5::UNION{FLOAT64,INT64}
  #temp#@_6::Core.MethodInstance
  #temp#@_7::Float64

Body:
  begin
      $(Expr(:inbounds, false))
      # meta: location REPL[1] pos 1
      # meta: location float.jl < 487
      fy::Float64 = (Core.typeassert)((Base.sitofp)(Float64,0)::Float64,Float64)::Float64
      # meta: pop location
      unless (Base.or_int)((Base.lt_float)(x::Float64,fy::Float64)::Bool,(Base.and_int)((Base.and_int)((Base.eq_float)(x::Float64,fy::Float64)::Bool,(Base.lt_float)(fy::Float64,9.223372036854776e18)::Bool)::Bool,(Base.slt_int)((Base.fptosi)(Int64,fy::Float64)::Int64,0)::Bool)::Bool)::Bool goto 9
      #temp#@_5::UNION{FLOAT64,INT64} = 0
      goto 11
      9:
      #temp#@_5::UNION{FLOAT64,INT64} = x::Float64
      11:
      # meta: pop location
      $(Expr(:inbounds, :pop))
      y::UNION{FLOAT64,INT64} = #temp#@_5::UNION{FLOAT64,INT64} # line 3:
      unless (y::UNION{FLOAT64,INT64} isa Int64)::ANY goto 19
      #temp#@_6::Core.MethodInstance = MethodInstance for *(::Int64, ::Float64)
      goto 28
      19:
      unless (y::UNION{FLOAT64,INT64} isa Float64)::ANY goto 23
      #temp#@_6::Core.MethodInstance = MethodInstance for *(::Float64, ::Float64)
      goto 28
      23:
      goto 25
      25:
      #temp#@_7::Float64 = (y::UNION{FLOAT64,INT64} * x::Float64)::Float64
      goto 30
      28:
      #temp#@_7::Float64 = $(Expr(:invoke, :(#temp#@_6), :(Main.*), :(y), :(x)))
      30:
      return $(Expr(:invoke, MethodInstance for sin(::Float64), :(Main.sin), :((Base.add_float)(#temp#@_7,(Base.sitofp)(Float64,1)::Float64)::Float64)))
  end::Float64
\end{minted}



Interpreting the output of \hyperlink{7509450972834198661}{\texttt{@code\_warntype}}, like that of its cousins \hyperlink{10170271820987078660}{\texttt{@code\_lowered}}, \hyperlink{12279119633919839581}{\texttt{@code\_typed}}, \hyperlink{4715999780877895760}{\texttt{@code\_llvm}}, and \hyperlink{2366615256687729425}{\texttt{@code\_native}}, takes a little practice. Your code is being presented in form that has been partially digested on its way to generating compiled machine code.  Most of the expressions are annotated by a type, indicated by the \texttt{::T} (where \texttt{T} might be \hyperlink{5027751419500983000}{\texttt{Float64}}, for example). The most important characteristic of \hyperlink{7509450972834198661}{\texttt{@code\_warntype}} is that non-concrete types are displayed in red; in the above example, such output is shown in all-caps.



The top part of the output summarizes the type information for the different variables internal to the function. You can see that \texttt{y}, one of the variables you created, is a \texttt{Union\{Int64,Float64\}}, due to the type-instability of \texttt{pos}.  There is another variable, \texttt{\_var4}, which you can see also has the same type.



The next lines represent the body of \texttt{f}. The lines starting with a number followed by a colon (\texttt{1:}, \texttt{2:}) are labels, and represent targets for jumps (via \texttt{goto}) in your code.  Looking at the body, you can see that \texttt{pos} has been \emph{inlined} into \texttt{f}–everything before \texttt{2:} comes from code defined in \texttt{pos}.



Starting at \texttt{2:}, the variable \texttt{y} is defined, and again annotated as a \texttt{Union} type.  Next, we see that the compiler created the temporary variable \texttt{\_var1} to hold the result of \texttt{y*x}. Because a \hyperlink{5027751419500983000}{\texttt{Float64}} times \emph{either} an \hyperlink{7720564657383125058}{\texttt{Int64}} or \texttt{Float64} yields a \texttt{Float64}, all type-instability ends here. The net result is that \texttt{f(x::Float64)} will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.



How you use this information is up to you. Obviously, it would be far and away best to fix \texttt{pos} to be type-stable: if you did so, all of the variables in \texttt{f} would be concrete, and its performance would be optimal.  However, there are circumstances where this kind of \emph{ephemeral} type instability might not matter too much: for example, if \texttt{pos} is never used in isolation, the fact that \texttt{f}{\textquotesingle}s output is type-stable (for \hyperlink{5027751419500983000}{\texttt{Float64}} inputs) will shield later code from the propagating effects of type instability.  This is particularly relevant in cases where fixing the type instability is difficult or impossible: for example, currently it{\textquotesingle}s not possible to infer the return type of an anonymous function.  In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the {\textquotedbl}damage{\textquotedbl} from type instability.



The following examples may help you interpret expressions marked as containing non-leaf types:



\begin{itemize}
\item Function body ending in \texttt{end::Union\{T1,T2\})}

\begin{itemize}
\item Interpretation: function with unstable return type


\item Suggestion: make the return value type-stable, even if you have to annotate it

\end{itemize}

\item \texttt{f(x::T)::Union\{T1,T2\}}

\begin{itemize}
\item Interpretation: call to a type-unstable function


\item Suggestion: fix the function, or if necessary annotate the return value

\end{itemize}

\item \texttt{(top(arrayref))(A::Array\{Any,1\},1)::Any}

\begin{itemize}
\item Interpretation: accessing elements of poorly-typed arrays


\item Suggestion: use arrays with better-defined types, or if necessary annotate the type of individual element accesses

\end{itemize}

\item \texttt{(top(getfield))(A::ArrayContainer\{Float64\},:data)::Array\{Float64,N\}}

\begin{itemize}
\item Interpretation: getting a field that is of non-leaf type. In this case, \texttt{ArrayContainer} had a field \texttt{data::Array\{T\}}. But \texttt{Array} needs the dimension \texttt{N}, too, to be a concrete type.


\item Suggestion: use concrete types like \texttt{Array\{T,3\}} or \texttt{Array\{T,N\}}, where \texttt{N} is now a parameter of \texttt{ArrayContainer}

\end{itemize}
\end{itemize}


\hypertarget{14117620934191882930}{}


\chapter{Workflow Tips}



Here are some tips for working with Julia efficiently.



\hypertarget{9117157922141826251}{}


\section{REPL-based workflow}



As already elaborated in \hyperlink{9220662049678686366}{Interacting With Julia}, Julia{\textquotesingle}s REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.



\hypertarget{126896972279328152}{}


\subsection{A basic editor/REPL workflow}



The most basic Julia workflows involve using a text editor in conjunction with the \texttt{julia} command line. A common pattern includes the following elements:



\begin{itemize}
\item \textbf{Put code under development in a temporary module.} Create a file, say \texttt{Tmp.jl}, and include within it


\begin{lstlisting}
module Tmp

<your definitions here>

end
\end{lstlisting}


\item \textbf{Put your test code in another file.} Create another file, say \texttt{tst.jl}, which begins with


\begin{minted}{julia}
import Tmp
\end{minted}

and includes tests for the contents of \texttt{Tmp}. The value of using \texttt{import} versus \texttt{using} is that you can call \texttt{reload({\textquotedbl}Tmp{\textquotedbl})} instead of having to restart the REPL when your definitions change. Of course, the cost is the need to prepend \texttt{Tmp.} to uses of names defined in your module. (You can lower that cost by keeping your module name short.)

Alternatively, you can wrap the contents of your test file in a module, as


\begin{lstlisting}
module Tst
    using Tmp

    <scratch work>

end
\end{lstlisting}

The advantage is that you can now do \texttt{using Tmp} in your test code and can therefore avoid prepending \texttt{Tmp.} everywhere. The disadvantage is that code can no longer be selectively copied to the REPL without some tweaking.


\item \textbf{Lather. Rinse. Repeat.} Explore ideas at the \texttt{julia} command prompt. Save good ideas in \texttt{tst.jl}. Occasionally restart the REPL, issuing


\begin{minted}{julia}
reload("Tmp")
include("tst.jl")
\end{minted}

\end{itemize}


\hypertarget{16277073820866957327}{}


\subsection{Simplify initialization}



To simplify restarting the REPL, put project-specific initialization code in a file, say \texttt{\_init.jl}, which you can run on startup by issuing the command:




\begin{lstlisting}
julia -L _init.jl
\end{lstlisting}



If you further add the following to your \texttt{.juliarc.jl} file




\begin{minted}{julia}
isfile("_init.jl") && include(joinpath(pwd(), "_init.jl"))
\end{minted}



then calling \texttt{julia} from that directory will run the initialization code without the additional command line argument.



\hypertarget{3725235168071892595}{}


\section{Browser-based workflow}



It is also possible to interact with a Julia REPL in the browser via \href{https://github.com/JuliaLang/IJulia.jl}{IJulia}. See the package home for details.



\hypertarget{17403906501138262503}{}


\chapter{Guía de Estilo}



Las siguientes secciones explican unos cuantos aspectos del estilo de codificación idiomático de Julia. Ninguna de estas reglas son absolutas; sólo son sugerencias para ayudar a familiarizarte con el lenguaje y ayudarte a elegir entre diseños alternativos.



\hypertarget{409542941476972201}{}


\section{Escribe funciones, no sólo \emph{scripts}}



Escribir código como una serie de pasos a nivel superior Es una forma rápida de empezar a  resolver un problema, pero uno debería intentar dividir un programa en funciones tan pronto como  sea posible. La función son más reusabes y testables, y clarifican qué pasos se están dando y  cuáles son sus entradas y sus salidas. Además, el código dentro de las funciones tiende a ejecutar  mucho más rápido que el código de nivel superior debido a cómo funciona el compilador de Julia.



También merece la pena señalar que las funciones deberían tomar argumentos, en lugar de operar directamente sobre las variables globales (aparte de constantes como \hyperlink{13833999108924821801}{\texttt{pi}}).



\hypertarget{9296013559083340261}{}


\section{Evita escribir tipos demasiado específicos}



El código debería ser tan genérico como sea posible. En lugar de escribir:




\begin{minted}{julia}
convert(Complex{Float64}, x)
\end{minted}



es mejor usar funciones genéricas disponibles:




\begin{minted}{julia}
complex(float(x))
\end{minted}



La segunda versión convertirá \texttt{x} a un tipo apropiado, en lugrar de siempre al mismo tipo. 



Este punto de estilo es especialmente relevante para los argumentos de función. Por ejemplo, no declare que un argumento sea de tipo \texttt{Int} o \hyperlink{10103694114785108551}{\texttt{Int32}} si realmente pudiera ser cualquier número entero, expresado con el tipo abstracto \hyperlink{8469131683393450448}{\texttt{Integer}}. De hecho, en muchos casos puede omitir el tipo de argumento por completo, a menos que sea necesario para eliminar la ambigüedad de otras definiciones de método, ya que se lanzará \hyperlink{14644228586476494020}{\texttt{MethodError}} de todos modos si se pasa un tipo que no admite ninguna de las operaciones requeridas. (Esto se conoce como \href{https://en.wikipedia.org/wiki/Duck\_typing}{\emph{duck typing}}.)



Por ejemplo, considere las siguientes definiciones de una función \texttt{addone} que devuelve uno más su argumento:




\begin{minted}{julia}
addone(x::Int) = x + 1                 # works only for Int
addone(x::Integer) = x + oneunit(x)    # any integer type
addone(x::Number) = x + oneunit(x)     # any numeric type
addone(x) = x + oneunit(x)             # any type supporting + and oneunit
\end{minted}



La última definición de \texttt{addone} maneja cualquier tipo que soporte \hyperlink{2310843180104103470}{\texttt{oneunit}} (que devuelve 1 en el mismo tipo que \texttt{x}, lo que evita la promoción de tipos no deseados) y  la función \hyperlink{3677358729494553841}{\texttt{+}} con esos argumentos. La clave para darse cuenta es que no hay \emph{ninguna penalización de rendimiento} para definir \emph{solo} el general \texttt{addone (x) = x + oneunit (x)}, porque Julia compilará automáticamente versiones especializadas según sea necesario. Por ejemplo, la primera vez que llame a \texttt{addone(12)}, Julia compilará automáticamente una función especializada \texttt{addone} para argumentos \texttt{x :: Int}, reemplazando la llamada a \texttt{oneunit} por su valor\texttt{1}. Por lo tanto, las primeras tres definiciones de {\textquotesingle}addone{\textquotesingle} anteriores son completamente redundantes con la cuarta definición.



\hypertarget{740116931890747988}{}


\section{Manejar el exceso de diversidad de argumentos en el {\textquotedbl}código llamador{\textquotedbl}}



En lugar de:




\begin{minted}{julia}
function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)
\end{minted}



use:




\begin{minted}{julia}
function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))
\end{minted}



Este es mucho mejor estilo debido a que \texttt{foo} no acepta realmente números de todos los tipos, sino que necesita \texttt{Int} s.



Un problema aquí es que si una función requiere números enteros intrínsecamente, podría ser mejor forzar al autor de la llamada a decidir cómo deberían convertirse los no enteros (por ejemplo, redondeando por abajo o por arriba). Otro problema es que la declaración de tipos más específicos deja más {\textquotedbl}espacio{\textquotedbl} para las futuras definiciones de métodos.



\hypertarget{8474674807000700396}{}


\section{Añadir \texttt{!} para los nombres de funciones que modifican sus argumentos}



En lugar de:




\begin{minted}{julia}
function double(a::AbstractArray{<:Number})
    for i = 1:endof(a)
        a[i] *= 2
    end
    return a
end
\end{minted}



use:




\begin{minted}{julia}
function double!(a::AbstractArray{<:Number})
    for i = 1:endof(a)
        a[i] *= 2
    end
    return a
end
\end{minted}



La biblioteca estándar de Julia usa esta convención y contiene ejemplos de funciones con formas tanto de copiado como de modificación (por ejemplo, \hyperlink{8473525809131227606}{\texttt{sort()}} y \hyperlink{12296873681374954808}{\texttt{sort!()}}), y otras que simplemente están modificando (por ejemplo, \hyperlink{18026893834387542681}{\texttt{push!()}}, \hyperlink{8214834680518266248}{\texttt{pop!()}}, \hyperlink{13785507599688955371}{\texttt{splice!()}}). Es típico para tales funciones devolver también la matriz modificada por conveniencia.



\hypertarget{4946523623897939404}{}


\section{Evitar tipos \texttt{Union} extraños}



Tipos tales como \texttt{Union\{Function,AbstractString\}} son frecuentemente un signo de que hay que limpiar algo en el diseño.



\hypertarget{1097030513054318581}{}


\section{Evitar las Uniones de tipos en campos}



Cuando se crea un tipo tal como :




\begin{minted}{julia}
mutable struct MyType
    ...
    x::Union{Void,T}
end
\end{minted}



pregunte si la opción de \texttt{x} para ser \texttt{nada} (de tipo \texttt{Void}) es realmente necesaria. Aquí hay algunas alternativas a considerar:



\begin{itemize}
\item Encuentre un valor predeterminado seguro con el que inicializar \texttt{x}


\item Introduce otro tipo del que carece \texttt{x}


\item Si hay muchos campos como \texttt{x}, guárdelos en un diccionario


\item Determine si hay una regla simple para cuando \texttt{x} es\texttt{nada}. Por ejemplo, a menudo el campo comenzará  como \texttt{nada} pero se inicializará en algún punto bien definido. En ese caso, considere dejarlo indefinido  al principio.


\item Si \texttt{x} realmente no necesita contener ningún valor en algún momento, defínalo como \texttt{::Nullable\{T\}} en  su lugar, ya que esto garantiza estabilidad de tipo en el código que accede a este campo  (ver \hyperlink{6093361083853962389}{TiposNullable}).

\end{itemize}


\hypertarget{4374450765972738010}{}


\section{Evitar elaborar tipos contenedor}



Usualmente no es de mucha ayuda construir arrays como los siguientes:




\begin{minted}{julia}
a = Array{Union{Int,AbstractString,Tuple,Array}}(n)
\end{minted}



En este caso \texttt{Array\{Any\}(n)} es mejor. Es también de más ayuda para el compilador anotar usos específicos (por ejemplo  \texttt{a[i]::Int}) que intentar empaquetar muchas alternativas en un tipo.



\hypertarget{17316563762918598460}{}


\section{Usar convenciones de nombrado consistentes con el paquete \texttt{base/} de Julia}



\begin{itemize}
\item Los nombres de los módulos y tipos usan mayúsculas y \emph{came case}: \texttt{module SparseArrays}, \texttt{struct UnitRange}.


\item Las funciones van en minúscula (\hyperlink{10566500735406837086}{\texttt{maximum()}}, \hyperlink{1846942650946171605}{\texttt{convert()}}) y, cuando es legible, con múltiples palabras pegadas juntas (\hyperlink{12829995639916057841}{\texttt{isequal()}}, \hyperlink{16178429961779994033}{\texttt{haskey()}}). Cuando sea necesario, use guiones bajos como separadores de palabra. Los guiones bajos también se usan para indicar una combinacin de conceptos (\hyperlink{16429337757386989414}{\texttt{remotecall\_fetch()}} como una implementación más eficiente de \texttt{fetch(remotecall(...))}) o como modificadores (\hyperlink{16119876305082002277}{\texttt{sum\_kbn()}}).


\item Se valora la concisión, pero debe evitarse la abreviatura (\hyperlink{16333903346703258373}{\texttt{indexin()}} en lugar de \texttt{indxin()}) ya

\end{itemize}


   que se vuelve difícil recordar si se abrevian palabras particulares y cómo se han abreviado.



Si el nombre de una función requiere varias palabras, considere si podría representar más de un concepto y podría dividirse mejor en partes.



\hypertarget{6945674612943947452}{}


\section{No usar demasiado try-catch}



Es mejor evitar errores que basarse en atraparlos.



\hypertarget{12651663870640588141}{}


\section{No meter entre paréntesis las condiciones}



Julia no necesita que se rodeen entre paréntesis las condiciones en \texttt{if} and \texttt{while}. Escriba:




\begin{minted}{julia}
if a == b
\end{minted}



en lugar de:




\begin{minted}{julia}
if (a == b)
\end{minted}



\hypertarget{1399059940979832870}{}


\section{No usar demasiado \texttt{...}}



El uso de \texttt{...} en los argumentos de función puede ser adictivo. En lugar de \texttt{[a..., b...]}, use \texttt{[a; b]}, que ya concatena arrays. \hyperlink{6278865767444641812}{\texttt{collect(a)}} es mejor que \texttt{[a...]}, pero como \texttt{a} ya es iterable suele ser  incluso mejor d3jarlo solo, y no convertirlo en array.



\hypertarget{3444892234087105832}{}


\section{No usar parámetros estáticos innecesarios}



Una signatura de función:




\begin{minted}{julia}
foo(x::T) where {T<:Real} = ...
\end{minted}



debería ser escrita como




\begin{minted}{julia}
foo(x::Real) = ...
\end{minted}



especialmente si \texttt{T} no se usa en el cuerpo de la función. Incluso si se usa \texttt{T}, se puede reemplazar con \hyperlink{13440452181855594120}{\texttt{typeof(x)}} si es conveniente. No hay diferencia de rendimiento. Tenga en cuenta que esto no es una precaución general contra los parámetros estáticos, solo contra uso donde no son necesarios.



Tenga en cuenta también que los tipos de contenedores, específicamente pueden necesitar parámetros de tipo en las llamadas a función. Consulte las Preguntas frecuentes \hyperlink{14656612614164373357}{Evitar campos con contenedores abstractos} para obtener más información.



\hypertarget{7862251737566613129}{}


\section{Evitar la confusion sobre si algo es una instancia o un tipo}



Conjuntos de definiciones como las siguientes son confusas:




\begin{minted}{julia}
foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)
\end{minted}



Decida si el concepto en cuestión se escribirá como \texttt{MyType} o \texttt{MyType()}, y sígalo.



El estilo preferido es usar instancias por defecto, y solo agregue métodos que incluyan \texttt{Tipo\{MiTipo\}} más tarde si se vuelven necesarios para resolver algún problema.



Si un tipo es efectivamente una enumeración, debe definirse como un tipo único (idealmente, \texttt{immutable struct} o primitivo), con los valores de enumeración como instancias de este. Los constructores y las conversiones pueden verificar si los valores son válidos. Este diseño es preferible a hacer que la enumeración sea un tipo abstracto, con los {\textquotedbl}valores{\textquotedbl} como subtipos.



\hypertarget{14130041226788272022}{}


\section{No abusar de las macros}



Tenga en cuenta cuando una macro realmente podría ser una función en su lugar.



Llamar a \hyperlink{2345597220715550879}{\texttt{eval()}} dentro de una macro es un signo de advertencia particularmente peligroso; significa que la macro solo funcionará cuando se llame al nivel superior. Si tal macro se escribe como una función en su lugar, naturalmente tendrá acceso a los valores en tiempo de ejecución que necesita.



\hypertarget{9807619411236692263}{}


\section{No exponer operaciones inseguras al nivel de interfaz}



Si se tiene un tipo que use un puntero nativo:




\begin{minted}{julia}
mutable struct NativeType
    p::Ptr{UInt8}
    ...
end
\end{minted}



no escriba definiciones como la siguiente:




\begin{minted}{julia}
getindex(x::NativeType, i) = unsafe_load(x.p, i)
\end{minted}



El problema es que los usuarios de este tipo pueden escribir \texttt{x[i]} sin darse cuenta de que la operación no es segura y, luego, ser susceptibles a errores de memoria.



Dicha función debería verificar la operación para asegurarse de que sea segura, o incluir \texttt{unsafe} en alguna parte de su nombre para alertar a las personas que la invocan.



\hypertarget{4479764462310943284}{}


\section{No sobrecargar métodos de tipos de contenedores base}



Es posible escribir definiciones como la siguiente:




\begin{minted}{julia}
show(io::IO, v::Vector{MyType}) = ...
\end{minted}



Esto proporcionaría una muestra personalizada de vectores con un nuevo tipo de elemento específico. Aunque es tentador, es algo que debe evitarse. El problema es que los usuarios esperarán que un tipo conocido como \texttt{Vector()} se comporte de cierta manera, y la personalización excesiva de su comportamiento puede dificultar el trabajo.



\hypertarget{12134743306740676544}{}


\section{Evitar la piratería de tipos}



La {\textquotedbl}Piratería de Tipos{\textquotedbl} se refiere a la práctica de extender o redefinir métodos en Base u otros paquetes en tipos que no han definido. En algunos casos, puede la piratería de tipo va a tener un efecto poco negativo. Sin embargo, en casos extremos, incluso puede bloquear Julia (por ejemplo, si la extensión o redefinición de su método hace que se pase una entrada inválida a \texttt{ccall}). La piratería de tipos puede complicar el razonamiento sobre el código y puede introducir incompatibilidades que son difíciles de predecir y diagnosticar.



Como ejemplo, suponga que quiere definir la multiplicación en símbolos en un módulo: 




\begin{minted}{julia}
module A
import Base.*
*(x::Symbol, y::Symbol) = Symbol(x,y)
end
\end{minted}



El problema es que ahora cualquier otro módulo que use \texttt{Base.*} También verá esta definición. Dado que \texttt{Symbol} se define en Base y es utilizado por otros módulos, esto puede cambiar el comportamiento del código no relacionado de forma inesperada. Aquí hay varias alternativas, incluido el uso de un nombre de función diferente o el ajuste de \texttt{Symbol}s en otro tipo que defina.



Algunas veces, los paquetes acoplados pueden involucrarse en la piratería de tipos para separar las características de las definiciones, especialmente cuando los paquetes fueron diseñados por autores colaboradores, y cuando las definiciones son reutilizables. Por ejemplo, un paquete puede proporcionar algunos tipos útiles para trabajar con colores; otro paquete podría definir métodos para aquellos tipos que permiten conversiones entre espacios de color. Otro ejemplo podría ser un paquete que actúa como un envoltorio delgado para algún código C, que otro paquete podría piratear para implementar una API de nivel superior compatible con Julia.



\hypertarget{3580611542715883953}{}


\section{Ser cuidadoso con la igualdad de tipos}



Por lo general, uno desea utilizar \hyperlink{7066325108767373297}{\texttt{isa()}} y \hyperlink{10973847109239228196}{\texttt{<:}} para los tipos de prueba, no \texttt{==}. La comprobación de los tipos para la igualdad exacta normalmente solo tiene sentido cuando se compara con un tipo concreto conocido (por ejemplo, \texttt{T == Float64}), o si \emph{realmente} uno sabe lo que está haciendo.



\hypertarget{18366734601602290620}{}


\section{No escribir \texttt{x->f(x)}}



Como las funciones de orden superior a menudo se llaman con funciones anónimas, es fácil concluir que esto es deseable o incluso necesario. Pero cualquier función se puede pasar directamente, sin estar {\textquotedbl}envuelta{\textquotedbl} en una función anónima. En lugar de escribir \texttt{map (x-> f(x), a)}, escriba \hyperlink{11483231213869150535}{\texttt{map(f, a)}}.



\hypertarget{13907208518662742165}{}


\section{Evitar usar floats para literales numericos en codigo generico cuando sea posible}



Si escribe código genérico que maneja números, y que se puede esperar que se ejecute con muchos tipos de argumentos numéricos diferentes, intente utilizar literales de un tipo numérico que afectarán los argumentos lo menos posible mediante la promoción.



Por ejemplo,




\begin{minted}{jlcon}
julia> f(x) = 2.0 * x
f (generic function with 1 method)

julia> f(1//2)
1.0

julia> f(1/2)
1.0

julia> f(1)
2.0
\end{minted}



mientras que




\begin{minted}{jlcon}
julia> g(x) = 2 * x
g (generic function with 1 method)

julia> g(1//2)
1//1

julia> g(1/2)
1.0

julia> g(1)
2
\end{minted}



Como puede ver, la segunda versión, donde usamos un literal \texttt{Int}, conserva el tipo de argumento de entrada, mientras que la primera no. Esto se debe a, por ejemplo, \texttt{promote\_type(Int, Float64) == Float64}, y la promoción ocurre con la multiplicación. De manera similar, los literales \hyperlink{8304566144531167610}{\texttt{Rational}} son menos disruptivos que los literales \hyperlink{5027751419500983000}{\texttt{Float64}}, pero son más perjudiciales que los \texttt{Int}s:




\begin{minted}{jlcon}
julia> h(x) = 2//1 * x
h (generic function with 1 method)

julia> h(1//2)
1//1

julia> h(1/2)
1.0

julia> h(1)
2//1
\end{minted}



Por tanto, use literales \texttt{Int} cuando sea posible, con \texttt{Rational\{Int\}} para literales numéricos no enteros, en orden a hacer nuestro código ms fácil de usar.



\hypertarget{2735091372912754285}{}


\chapter{Frequently Asked Questions}



\hypertarget{6346532337786246456}{}


\section{Sessions and the REPL}



\hypertarget{10305692387204937900}{}


\subsection{How do I delete an object in memory?}



Julia does not have an analog of MATLAB{\textquotesingle}s \texttt{clear} function; once a name is defined in a Julia session (technically, in module \texttt{Main}), it is always present.



If memory usage is your concern, you can always replace objects with ones that consume less memory.  For example, if \texttt{A} is a gigabyte-sized array that you no longer need, you can free the memory with \texttt{A = 0}.  The memory will be released the next time the garbage collector runs; you can force this to happen with \hyperlink{13037394137368605126}{\texttt{gc()}}.



\hypertarget{2409321909107091733}{}


\subsection{How can I modify the declaration of a type in my session?}



Perhaps you{\textquotesingle}ve defined a type and then realize you need to add a new field.  If you try this at the REPL, you get the error:




\begin{lstlisting}
ERROR: invalid redefinition of constant MyType
\end{lstlisting}



Types in module \texttt{Main} cannot be redefined.



While this can be inconvenient when you are developing new code, there{\textquotesingle}s an excellent workaround.  Modules can be replaced by redefining them, and so if you wrap all your new code inside a module you can redefine types and constants.  You can{\textquotesingle}t import the type names into \texttt{Main} and then expect to be able to redefine them there, but you can use the module name to resolve the scope.  In other words, while developing you might use a workflow something like this:




\begin{minted}{julia}
include("mynewcode.jl")              # this defines a module MyModule
obj1 = MyModule.ObjConstructor(a, b)
obj2 = MyModule.somefunction(obj1)
# Got an error. Change something in "mynewcode.jl"
include("mynewcode.jl")              # reload the module
obj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct
obj2 = MyModule.somefunction(obj1)   # this time it worked!
obj3 = MyModule.someotherfunction(obj2, c)
...
\end{minted}



\hypertarget{8538207326577378342}{}


\section{Functions}



\hypertarget{12855086270323701749}{}


\subsection{I passed an argument \texttt{x} to a function, modified it inside that function, but on the outside,}



the variable \texttt{x} is still unchanged. Why?



Suppose you call a function like this:




\begin{minted}{jlcon}
julia> x = 10
10

julia> function change_value!(y)
           y = 17
       end
change_value! (generic function with 1 method)

julia> change_value!(x)
17

julia> x # x is unchanged!
10
\end{minted}



In Julia, the binding of a variable \texttt{x} cannot be changed by passing \texttt{x} as an argument to a function. When calling \texttt{change\_value!(x)} in the above example, \texttt{y} is a newly created variable, bound initially to the value of \texttt{x}, i.e. \texttt{10}; then \texttt{y} is rebound to the constant \texttt{17}, while the variable \texttt{x} of the outer scope is left untouched.



But here is a thing you should pay attention to: suppose \texttt{x} is bound to an object of type \texttt{Array} (or any other \emph{mutable} type). From within the function, you cannot {\textquotedbl}unbind{\textquotedbl} \texttt{x} from this Array, but you can change its content. For example:




\begin{minted}{jlcon}
julia> x = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> function change_array!(A)
           A[1] = 5
       end
change_array! (generic function with 1 method)

julia> change_array!(x)
5

julia> x
3-element Array{Int64,1}:
 5
 2
 3
\end{minted}



Here we created a function \texttt{change\_array!()}, that assigns \texttt{5} to the first element of the passed array (bound to \texttt{x} at the call site, and bound to \texttt{A} within the function). Notice that, after the function call, \texttt{x} is still bound to the same array, but the content of that array changed: the variables \texttt{A} and \texttt{x} were distinct bindings refering to the same mutable \texttt{Array} object.



\hypertarget{1083374634946363107}{}


\subsection{Can I use \texttt{using} or \texttt{import} inside a function?}



No, you are not allowed to have a \texttt{using} or \texttt{import} statement inside a function.  If you want to import a module but only use its symbols inside a specific function or set of functions, you have two options:



\begin{itemize}
\item[1. ] Use \texttt{import}:


\begin{minted}{julia}
import Foo
function bar(...)
    # ... refer to Foo symbols via Foo.baz ...
end
\end{minted}

This loads the module \texttt{Foo} and defines a variable \texttt{Foo} that refers to the module, but does not import any of the other symbols from the module into the current namespace.  You refer to the \texttt{Foo} symbols by their qualified names \texttt{Foo.bar} etc.


\item[2. ] Wrap your function in a module:


\begin{minted}{julia}
module Bar
export bar
using Foo
function bar(...)
    # ... refer to Foo.baz as simply baz ....
end
end
using Bar
\end{minted}

This imports all the symbols from \texttt{Foo}, but only inside the module \texttt{Bar}.

\end{itemize}


\hypertarget{12294034902075429755}{}


\subsection{What does the \texttt{...} operator do?}



\hypertarget{13127773043618399697}{}


\subsection{The two uses of the \texttt{...} operator: slurping and splatting}



Many newcomers to Julia find the use of \texttt{...} operator confusing. Part of what makes the \texttt{...} operator confusing is that it means two different things depending on context.



\hypertarget{6000213923717698457}{}


\subsection{\texttt{...} combines many arguments into one argument in function definitions}



In the context of function definitions, the \texttt{...} operator is used to combine many different arguments into a single argument. This use of \texttt{...} for combining many different arguments into a single argument is called slurping:




\begin{minted}{jlcon}
julia> function printargs(args...)
           @printf("%s\n", typeof(args))
           for (i, arg) in enumerate(args)
               @printf("Arg %d = %s\n", i, arg)
           end
       end
printargs (generic function with 1 method)

julia> printargs(1, 2, 3)
Tuple{Int64,Int64,Int64}
Arg 1 = 1
Arg 2 = 2
Arg 3 = 3
\end{minted}



If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as \texttt{<-...} instead of \texttt{...}.



\hypertarget{18215777153354710149}{}


\subsection{\texttt{...} splits one argument into many different arguments in function calls}



In contrast to the use of the \texttt{...} operator to denote slurping many different arguments into one argument when defining a function, the \texttt{...} operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of \texttt{...} is called splatting:




\begin{minted}{jlcon}
julia> function threeargs(a, b, c)
           @printf("a = %s::%s\n", a, typeof(a))
           @printf("b = %s::%s\n", b, typeof(b))
           @printf("c = %s::%s\n", c, typeof(c))
       end
threeargs (generic function with 1 method)

julia> vec = [1, 2, 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> threeargs(vec...)
a = 1::Int64
b = 2::Int64
c = 3::Int64
\end{minted}



If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as \texttt{...->} instead of \texttt{...}.



\hypertarget{13169720538693416930}{}


\section{Types, type declarations, and constructors}



\hypertarget{11170875837665758023}{}


\subsection{What does {\textquotedbl}type-stable{\textquotedbl} mean?}



It means that the type of the output is predictable from the types of the inputs.  In particular, it means that the type of the output cannot vary depending on the \emph{values} of the inputs. The following code is \emph{not} type-stable:




\begin{minted}{jlcon}
julia> function unstable(flag::Bool)
           if flag
               return 1
           else
               return 1.0
           end
       end
unstable (generic function with 1 method)
\end{minted}



It returns either an \texttt{Int} or a \hyperlink{5027751419500983000}{\texttt{Float64}} depending on the value of its argument. Since Julia can{\textquotesingle}t predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.



\hypertarget{6904365807459053438}{}


\subsection{Why does Julia give a \texttt{DomainError} for certain seemingly-sensible operations?}



Certain operations make mathematical sense but result in errors:




\begin{minted}{jlcon}
julia> sqrt(-2.0)
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Float64) at ./math.jl:425

julia> 2^-5
ERROR: DomainError:
Cannot raise an integer x to a negative power -n.
Make x a float by adding a zero decimal (e.g. 2.0^-n instead of 2^-n), or write 1/x^n, float(x)^-n, or (x//1)^-n.
Stacktrace:
 [1] power_by_squaring(::Int64, ::Int64) at ./intfuncs.jl:173
 [2] literal_pow(::Base.#^, ::Int64, ::Type{Val{-5}}) at ./intfuncs.jl:208
\end{minted}



This behavior is an inconvenient consequence of the requirement for type-stability.  In the case of \hyperlink{4178506499510800909}{\texttt{sqrt()}}, most users want \texttt{sqrt(2.0)} to give a real number, and would be unhappy if it produced the complex number \texttt{1.4142135623730951 + 0.0im}.  One could write the \hyperlink{4178506499510800909}{\texttt{sqrt()}} function to switch to a complex-valued output only when passed a negative number (which is what \hyperlink{4178506499510800909}{\texttt{sqrt()}} does in some other languages), but then the result would not be \hyperlink{11170875837665758023}{type-stable} and the \hyperlink{4178506499510800909}{\texttt{sqrt()}} function would have poor performance.



In these and other cases, you can get the result you want by choosing an \emph{input type} that conveys your willingness to accept an \emph{output type} in which the result can be represented:




\begin{minted}{jlcon}
julia> sqrt(-2.0+0im)
0.0 + 1.4142135623730951im

julia> 2.0^-5
0.03125
\end{minted}



\hypertarget{15697426267824518488}{}


\subsection{Why does Julia use native machine integer arithmetic?}



Julia uses machine arithmetic for integer computations. This means that the range of \texttt{Int} values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:




\begin{minted}{jlcon}
julia> typemax(Int)
9223372036854775807

julia> ans+1
-9223372036854775808

julia> -ans
-9223372036854775808

julia> 2*ans
0
\end{minted}



Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.



One alternative to consider would be to check each integer operation for overflow and promote results to bigger integer types such as \hyperlink{8012327724714767060}{\texttt{Int128}} or \hyperlink{423405808990690832}{\texttt{BigInt}} in the case of overflow. Unfortunately, this introduces major overhead on every integer operation (think incrementing a loop counter) – it requires emitting code to perform run-time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this would cause every computation involving integers to be type-unstable. As we mentioned above, \hyperlink{11170875837665758023}{type-stability is crucial} for effective generation of efficient code. If you can{\textquotesingle}t count on the results of integer operations being integers, it{\textquotesingle}s impossible to generate fast, simple code the way C and Fortran compilers do.



A variation on this approach, which avoids the appearance of type instability is to merge the \texttt{Int} and \hyperlink{423405808990690832}{\texttt{BigInt}} types into a single hybrid integer type, that internally changes representation when a result no longer fits into the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this hybrid integer type. This approach \emph{can} be made to work and can even be made quite fast in many cases, but has several drawbacks. One problem is that the in-memory representation of integers and arrays of integers no longer match the natural representation used by C, Fortran and other languages with native machine integers. Thus, to interoperate with those languages, we would ultimately need to introduce native integer types anyway. Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline in an array with fixed-size slots – large integer values will always require separate heap-allocated storage. And of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps – situations where performance degrades unexpectedly. Complex representation, lack of interoperability with C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-performance numerical work.



An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer value. This is precisely what Matlab™ does:




\begin{lstlisting}
>> int64(9223372036854775807)

ans =

  9223372036854775807

>> int64(9223372036854775807) + 1

ans =

  9223372036854775807

>> int64(-9223372036854775808)

ans =

 -9223372036854775808

>> int64(-9223372036854775808) - 1

ans =

 -9223372036854775808
\end{lstlisting}



At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with \hyperlink{3613894539247233488}{\texttt{typemin(Int)}} or \hyperlink{17760305803764597758}{\texttt{typemax(Int)}} as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse – saturating integer arithmetic isn{\textquotesingle}t associative. Consider this Matlab computation:




\begin{lstlisting}
>> n = int64(2)^62
4611686018427387904

>> n + (n - 1)
9223372036854775807

>> (n + n) - 1
9223372036854775806
\end{lstlisting}



This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow \emph{is} associative. Consider finding the midpoint between integer values \texttt{lo} and \texttt{hi} in Julia using the expression \texttt{(lo + hi) >>> 1}:




\begin{minted}{jlcon}
julia> n = 2^62
4611686018427387904

julia> (n + 2n) >>> 1
6917529027641081856
\end{minted}



See? No problem. That{\textquotesingle}s the correct midpoint between 2{\textasciicircum}62 and 2{\textasciicircum}63, despite the fact that \texttt{n + 2n} is -4611686018427387904. Now try it in Matlab:




\begin{lstlisting}
>> (n + 2*n)/2

ans =

  4611686018427387904
\end{lstlisting}



Oops. Adding a \texttt{>>>} operator to Matlab wouldn{\textquotesingle}t help, because saturation that occurs when adding \texttt{n} and \texttt{2n} has already destroyed the information necessary to compute the correct midpoint.



Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it also defeats almost anything compilers might want to do to optimize integer arithmetic. For example, since Julia integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions like \texttt{f(k) = 5k-1}. The machine code for this function is just this:




\begin{minted}{jlcon}
julia> code_native(f, Tuple{Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 1
  leaq  -1(%rdi,%rdi,4), %rax
  popq  %rbp
  retq
  nopl  (%rax,%rax)
\end{minted}



The actual body of the function is a single \texttt{leaq} instruction, which computes the integer multiply and add at once. This is even more beneficial when \texttt{f} gets inlined into another function:




\begin{minted}{jlcon}
julia> function g(k, n)
           for i = 1:n
               k = f(k)
           end
           return k
       end
g (generic function with 1 methods)

julia> code_native(g, Tuple{Int,Int})
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 2
  testq %rsi, %rsi
  jle L26
  nopl  (%rax)
Source line: 3
L16:
  leaq  -1(%rdi,%rdi,4), %rdi
Source line: 2
  decq  %rsi
  jne L16
Source line: 5
L26:
  movq  %rdi, %rax
  popq  %rbp
  retq
  nop
\end{minted}



Since the call to \texttt{f} gets inlined, the loop body ends up being just a single \texttt{leaq} instruction. Next, consider what happens if we make the number of loop iterations fixed:




\begin{minted}{jlcon}
julia> function g(k)
           for i = 1:10
               k = f(k)
           end
           return k
       end
g (generic function with 2 methods)

julia> code_native(g,(Int,))
  .text
Filename: none
  pushq %rbp
  movq  %rsp, %rbp
Source line: 3
  imulq $9765625, %rdi, %rax    # imm = 0x9502F9
  addq  $-2441406, %rax         # imm = 0xFFDABF42
Source line: 5
  popq  %rbp
  retq
  nopw  %cs:(%rax,%rax)
\end{minted}



Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition – neither of which is true of saturating arithmetic – it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.



The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this \href{http://danluu.com/integer-overflow/}{blog post}, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.



\hypertarget{12379471796822806857}{}


\subsection{What are the possible causes of an \texttt{UndefVarError} during remote execution?}



As the error states, an immediate cause of an \texttt{UndefVarError} on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.




\begin{minted}{jlcon}
julia> module Foo
           foo() = remotecall_fetch(x->x, 2, "Hello")
       end

julia> Foo.foo()
ERROR: On worker 2:
UndefVarError: Foo not defined
[...]
\end{minted}



The closure \texttt{x->x} carries a reference to \texttt{Foo}, and since \texttt{Foo} is unavailable on node 2, an \texttt{UndefVarError} is thrown.



Globals under modules other than \texttt{Main} are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under \texttt{Main}) may cause an \texttt{UndefVarError} to be thrown later.




\begin{minted}{jlcon}
julia> @everywhere module Foo
           function foo()
               global gvar = "Hello"
               remotecall_fetch(()->gvar, 2)
           end
       end

julia> Foo.foo()
ERROR: On worker 2:
UndefVarError: gvar not defined
[...]
\end{minted}



In the above example, \texttt{@everywhere module Foo} defined \texttt{Foo} on all nodes. However the call to \texttt{Foo.foo()} created a new global binding \texttt{gvar} on the local node, but this was not found on node 2 resulting in an \texttt{UndefVarError} error.



Note that this does not apply to globals created under module \texttt{Main}. Globals under module \texttt{Main} are serialized and new bindings created under \texttt{Main} on the remote node.




\begin{minted}{jlcon}
julia> gvar_self = "Node1"
"Node1"

julia> remotecall_fetch(()->gvar_self, 2)
"Node1"

julia> remotecall_fetch(whos, 2)
	From worker 2:	                          Base  41762 KB     Module
	From worker 2:	                          Core  27337 KB     Module
	From worker 2:	                           Foo   2477 bytes  Module
	From worker 2:	                          Main  46191 KB     Module
	From worker 2:	                     gvar_self     13 bytes  String
\end{minted}



This does not apply to \texttt{function} or \texttt{type} declarations. However, anonymous functions bound to global variables are serialized as can be seen below.




\begin{minted}{jlcon}
julia> bar() = 1
bar (generic function with 1 method)

julia> remotecall_fetch(bar, 2)
ERROR: On worker 2:
UndefVarError: #bar not defined
[...]

julia> anon_bar  = ()->1
(::#21) (generic function with 1 method)

julia> remotecall_fetch(anon_bar, 2)
1
\end{minted}



\hypertarget{9055376787547294791}{}


\section{Packages and Modules}



\hypertarget{2987319322833292835}{}


\subsection{What is the difference between {\textquotedbl}using{\textquotedbl} and {\textquotedbl}importall{\textquotedbl}?}



There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between \texttt{using} and \texttt{importall} is that with \texttt{using} you need to say \texttt{function Foo.bar(..} to extend module Foo{\textquotesingle}s function bar with a new method, but with \texttt{importall} or \texttt{import Foo.bar}, you only need to say \texttt{function bar(...} and it automatically extends module Foo{\textquotesingle}s function bar.



If you use \texttt{importall}, then \texttt{function Foo.bar(...} and \texttt{function bar(...} become equivalent. If you use \texttt{using}, then they are different.



The reason this is important enough to have been given separate syntax is that you don{\textquotesingle}t want to accidentally extend a function that you didn{\textquotesingle}t know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use \texttt{importall}, then you{\textquotesingle}ll replace the other module{\textquotesingle}s implementation of \texttt{bar(s::AbstractString)} with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).



\hypertarget{259296306383383012}{}


\section{Nothingness and missing values}



\hypertarget{12770241465913898525}{}


\subsection{How does {\textquotedbl}null{\textquotedbl} or {\textquotedbl}nothingness{\textquotedbl} work in Julia?}



Unlike many languages (for example, C and Java), Julia does not have a {\textquotedbl}null{\textquotedbl} value. When a reference (variable, object field, or array element) is uninitialized, accessing it will immediately throw an error. This situation can be detected using the \texttt{isdefined} function.



Some functions are used only for their side effects, and do not need to return a value. In these cases, the convention is to return the value \texttt{nothing}, which is just a singleton object of type \texttt{Void}. This is an ordinary type with no fields; there is nothing special about it except for this convention, and that the REPL does not print anything for it. Some language constructs that would not otherwise have a value also yield \texttt{nothing}, for example \texttt{if false; end}.



For situations where a value exists only sometimes (for example, missing statistical data), it is best to use the \texttt{Nullable\{T\}} type, which allows specifying the type of a missing value.



The empty tuple (\texttt{()}) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.



In code written for Julia prior to version 0.4 you may occasionally see \texttt{None}, which is quite different. It is the empty (or {\textquotedbl}bottom{\textquotedbl}) type, a type with no values and no subtypes (except itself). This is now written as \texttt{Union\{\}} (an empty union type). You will generally not need to use this type.



\hypertarget{3259018490286985422}{}


\section{Memory}



\hypertarget{11679692065584506902}{}


\subsection{Why does \texttt{x += y} allocate memory when \texttt{x} and \texttt{y} are arrays?}



In Julia, \texttt{x += y} gets replaced during parsing by \texttt{x = x + y}. For arrays, this has the consequence that, rather than storing the result in the same location in memory as \texttt{x}, it allocates a new array to store the result.



While this behavior might surprise some, the choice is deliberate. The main reason is the presence of immutable objects within Julia, which cannot change their value once created.  Indeed, a number is an immutable object; the statements \texttt{x = 5; x += 1} do not modify the meaning of \texttt{5}, they modify the value bound to \texttt{x}. For an immutable, the only way to change the value is to reassign it.



To amplify a bit further, consider the following function:




\begin{minted}{julia}
function power_by_squaring(x, n::Int)
    ispow2(n) || error("This implementation only works for powers of 2")
    while n >= 2
        x *= x
        n >>= 1
    end
    x
end
\end{minted}



After a call like \texttt{x = 5; y = power\_by\_squaring(x, 4)}, you would get the expected result: \texttt{x == 5 \&\& y == 625}.  However, now suppose that \texttt{*=}, when used with matrices, instead mutated the left hand side.  There would be two problems:



\begin{itemize}
\item For general square matrices, \texttt{A = A*B} cannot be implemented without temporary storage: \texttt{A[1,1]} gets computed and stored on the left hand side before you{\textquotesingle}re done using it on the right hand side.


\item Suppose you were willing to allocate a temporary for the computation (which would eliminate most of the point of making \texttt{*=} work in-place); if you took advantage of the mutability of \texttt{x}, then this function would behave differently for mutable vs. immutable inputs. In particular, for immutable \texttt{x}, after the call you{\textquotesingle}d have (in general) \texttt{y != x}, but for mutable \texttt{x} you{\textquotesingle}d have \texttt{y == x}.

\end{itemize}


Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like \texttt{+=} and \texttt{*=} work by rebinding new values.



\hypertarget{2869294219122234478}{}


\section{Asynchronous IO and concurrent synchronous writes}



\hypertarget{8021601646076660276}{}


\subsection{Why do concurrent writes to the same stream result in inter-mixed output?}



While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.



Consider the printed output from the following:




\begin{minted}{jlcon}
julia> @sync for i in 1:3
           @async write(STDOUT, string(i), " Foo ", " Bar ")
       end
123 Foo  Foo  Foo  Bar  Bar  Bar
\end{minted}



This is happening because, while the \texttt{write} call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.



\texttt{print} and \texttt{println} {\textquotedbl}lock{\textquotedbl} the stream during a call. Consequently changing \texttt{write} to \texttt{println} in the above example results in:




\begin{minted}{jlcon}
julia> @sync for i in 1:3
           @async println(STDOUT, string(i), " Foo ", " Bar ")
       end
1 Foo  Bar
2 Foo  Bar
3 Foo  Bar
\end{minted}



You can lock your writes with a \texttt{ReentrantLock} like this:




\begin{minted}{jlcon}
julia> l = ReentrantLock()
ReentrantLock(Nullable{Task}(), Condition(Any[]), 0)

julia> @sync for i in 1:3
           @async begin
               lock(l)
               try
                   write(STDOUT, string(i), " Foo ", " Bar ")
               finally
                   unlock(l)
               end
           end
       end
1 Foo  Bar 2 Foo  Bar 3 Foo  Bar
\end{minted}



\hypertarget{11890167907781042305}{}


\section{Julia Releases}



\hypertarget{5265282656824289674}{}


\subsection{Do I want to use a release, beta, or nightly version of Julia?}



You may prefer the release version of Julia if you are looking for a stable code base. Releases generally occur every 6 months, giving you a stable platform for writing code.



You may prefer the beta version of Julia if you don{\textquotesingle}t mind being slightly behind the latest bugfixes and changes, but find the slightly faster rate of changes more appealing. Additionally, these binaries are tested before they are published to ensure they are fully functional.



You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language, and don{\textquotesingle}t mind if the version available today occasionally doesn{\textquotesingle}t actually work.



Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our \href{https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md}{guidelines for contributing}.



Links to each of these download types can be found on the download page at \href{https://julialang.org/downloads/}{https://julialang.org/downloads/}. Note that not all versions of Julia are available for all platforms.



\hypertarget{14356999914957430359}{}


\subsection{When are deprecated functions removed?}



Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release.



\hypertarget{16083606765476288441}{}


\chapter{Diferencias notables con otros idiomas}



\hypertarget{15217928597041721263}{}


\section{Diferencias notables con MATLAB}



Aunque los usuarios de MATLAB pueden encontrar la sintaxis de Julia familiar, Julia no es un clon de MATLAB. Hay importantes diferencias sintácticas y funcionales. Las siguientes son algunas diferencias notables que pueden hacer tropezar a los usuarios de Julia acostumbrados a MATLAB:



\begin{itemize}
\item Los arrays de Julia están indexados con corchetes, \texttt{A[i, j]}.


\item Los arrays de Julia se asignan por referencia. Después de \texttt{A = B}, el cambio de elementos de \texttt{B} también modificará \texttt{A}.


\item Los valores de Julia se pasan y se asignan por referencia. Si una función modifica una matriz, los cambios serán visibles en el código que la invoca.


\item Julia no genera automáticamente matrices en una declaración de asignación. Mientras que en MATLAB \texttt{a(4) = 3.2} puede crear la matriz \texttt{a = [0 0 0 3.2]} y \texttt{a(5) = 7} puede crecer hasta \texttt{a = [0 0 0 3.2 7]}, la declaración correspondiente de Julia \texttt{a[5] = 7} arroja un error si la longitud de \texttt{a} es menor que 5 o si esta afirmación es el primer uso del identificador \texttt{a}. Julia tiene \hyperlink{18026893834387542681}{\texttt{push!()}} y \hyperlink{2587432243763606566}{\texttt{append!()}}, que crecen \texttt{Vector}s mucho más eficientemente que \texttt{a(end + 1) = val} de MATLAB.


\item La unidad imaginaria \texttt{sqrt(-1)} se representa en Julia como \hyperlink{15097910740298861288}{\texttt{im}}, no como \texttt{i} o \texttt{j} como en MATLAB.


\item En Julia, los números literales sin un punto decimal (como \texttt{42}) crean números enteros en lugar de números de coma flotante. Se admiten literales enteros arbitrariamente grandes. Como resultado, algunas operaciones como \texttt{2{\textasciicircum}-1} arrojarán un error de dominio ya que el resultado no es un número entero (ver \hyperlink{6904365807459053438}{la entrada de preguntas frecuentes sobre errores de dominio} para más detalles).


\item En Julia, los valores múltiples se devuelven y se asignan como tuplas, p. \texttt{(a, b) = (1, 2)} o \texttt{a, b = 1, 2}. \texttt{{\textquotedbl}nargout{\textquotedbl}} de MATLAB, que a menudo se usa en MATLAB para hacer trabajos opcionales basados en el número de valores devueltos, no existe en Julia. En cambio, los usuarios pueden usar argumentos opcionales y de palabras clave para lograr capacidades similares.

\begin{itemize}
\item Julia tiene verdaderos arrays unidimensionales. Los vectores columna son de tamaño \texttt{N}, no\texttt{Nx1}. Por ejemplo, \hyperlink{791894090820620170}{\texttt{rand(N)}} forma una matriz de 1 dimensión.


\item En Julia, \texttt{[x, y, z]} siempre construirá una matriz de 3 elementos que contiene \texttt{x},\texttt{y} y \texttt{z}.

\begin{itemize}
\item Para concatenar en la primera dimensión ({\textquotedbl}vertical{\textquotedbl}) se usa \hyperlink{14691815416955507876}{\texttt{vcat(x, y, z)}} o se separa con punto y coma (\texttt{[x; y; z]}).


\item Para concatenar en la segunda dimensión ({\textquotedbl}horizontal{\textquotedbl}), se usa \hyperlink{8862791894748483563}{\texttt{hcat(x, y, z)}} o se separa con espacios (\texttt{[x y z]}).


\item Para construir matrices de bloques (concatenando en las dos primeras dimensiones), se usa \hyperlink{16279083053557795116}{\texttt{hvcat()}} o se combinan espacios y puntos y comas (\texttt{[a b; c d]}).

\end{itemize}
\end{itemize}

\item En Julia, \texttt{a:b} y\texttt{a:b:c} construyen objetos \texttt{Range}. Para construir un vector completo como en MATLAB, use \hyperlink{6278865767444641812}{\texttt{collect(a:b)}}. En general, no es necesario llamar a \texttt{collect} aunque. \texttt{Range} actuará como un array normal en la mayoría de los casos, pero es más eficiente porque calcula perezosamente sus valores. Este patrón de creación de objetos especializados en lugar de matrices completas se usa con frecuencia, y también se ve en funciones como \hyperlink{11519832570242386196}{\texttt{linspace}}, o con iteradores como \texttt{enumerate} y \texttt{zip}. Los objetos especiales se pueden usar principalmente como si fueran matrices normales.


\item Las funciones en Julia devuelven valores de su última expresión o la palabra clave \texttt{return} en lugar de enumerar los nombres de las variables a devolver en la definición de la función (ver \hyperlink{3662186082861906882}{La palabra clave return} para más detalles).


\item Un script de Julia puede contener cualquier cantidad de funciones, y todas las definiciones serán visibles externamente cuando se cargue el archivo. Las definiciones de funciones se pueden cargar desde archivos fuera del directorio de trabajo actual.


\item En Julia, las reducciones como \hyperlink{8666686648688281595}{\texttt{sum()}}, \hyperlink{13484084847910116333}{\texttt{prod()}}, y \hyperlink{7839419811914289844}{\texttt{max()}} se realizan sobre cada elemento de un array cuando se llama con un solo argumento, como en \texttt{sum(A)}, incluso si \texttt{A} tiene más de una dimensión.


\item En Julia, las funciones como \hyperlink{8473525809131227606}{\texttt{sort()}} que operan en forma de columnas por defecto (\texttt{sort(A)} es equivalente a \texttt{sort(A,1)}) no tienen un comportamiento especial para Conjuntos \texttt{1xN}; el argumento se devuelve sin modificar ya que todavía ejecuta \texttt{sort (A,1)}. Para ordenar una matriz \texttt{1xN} como un vector, use \texttt{sort(A,2)}.


\item In Julia, if \texttt{A} is a 2-dimensional array, \texttt{fft(A)} computes a 2D FFT. In particular, it is not equivalent to \texttt{fft(A,1)}, which computes a 1D FFT acting column-wise.


\item En Julia, los paréntesis se deben usar para llamar a una función con cero argumentos, como en \hyperlink{15143202356224875278}{\texttt{tic()}} y \hyperlink{16488371574475401451}{\texttt{toc()}}.


\item Julia desalienta el uso de punto y coma para finalizar las declaraciones. Los resultados de las declaraciones no se imprimen automáticamente (excepto en el aviso interactivo), y las líneas de código no necesitan terminar con punto y coma. \hyperlink{783803254548423222}{\texttt{println()}} o \hyperlink{4087473154660177488}{\texttt{@printf()}} se pueden usar para imprimir resultados específicos.


\item En Julia, si \texttt{A} y\texttt{B} son matrices, las operaciones de comparación lógica como \texttt{A == B} no devuelven una matriz de booleanos. En cambio, use \texttt{A == B}, y de manera similar para los otros operadores booleanos como \hyperlink{702782232449268329}{\texttt{<}}, \hyperlink{8677991761303191103}{\texttt{>}} y \texttt{=}.


\item En Julia, los operadores \hyperlink{1494761116451616317}{\texttt{\&}}, \hyperlink{9633687763646488853}{\texttt{|}} y \hyperlink{7071880015536674935}{\texttt{⊻}} (\hyperlink{7071880015536674935}{\texttt{xor}}) realizan el operaciones a nivel de bit equivalentes a \texttt{y},\texttt{o}, y \texttt{xor} respectivamente en MATLAB, y tienen precedencia similar a los operadores de bit a bit de Python (a diferencia de C). Pueden operar en escalas o en elementos a través de matrices y se pueden usar para combinar matrices lógicas, pero tenga en cuenta la diferencia en el orden de las operaciones: pueden ser necesarios paréntesis (por ejemplo, para seleccionar elementos de {\textquotesingle}A{\textquotesingle} igual a 1 o 2 use \texttt{(A. == 1) | (A. == 2)}).


\item En Julia, los elementos de una colección se pueden pasar como argumentos a una función usando el operador splat \texttt{...}, como en \texttt{xs = [1,2]; f(xs...)}.


\item Julia \hyperlink{14775973623414930183}{\texttt{svd()}} devuelve valores singulares como un vector en lugar de una matriz diagonal densa.


\item En Julia, \texttt{...} no se usa para continuar líneas de código. En cambio, las expresiones incompletas continúan automáticamente en la siguiente línea.


\item Tanto en Julia como en MATLAB, la variable \texttt{ans} se establece en el valor de la última expresión emitida en una sesión interactiva. En Julia, a diferencia de MATLAB, \texttt{ans} no se establece cuando el código de Julia se ejecuta en modo no interactivo.


\item Los \texttt{type}s de Julia no son compatibles con la adición dinámica de campos en el tiempo de ejecución, a diferencia de \texttt{classes} es de MATLAB. En su lugar, use un \hyperlink{3089397136845322041}{\texttt{Dict}}.


\item En Julia, cada módulo tiene su propio ámbito / espacio de nombres global, mientras que en MATLAB solo hay un ámbito global.


\item En MATLAB, una forma idiomática de eliminar valores no deseados es usar la indexación lógica, como en la expresión \texttt{x (x> 3)} o en la declaración \texttt{x (x> 3) = []} para modificar \texttt{x} en -lugar. Por el contrario, Julia proporciona las funciones de orden superior \hyperlink{11445961893478569145}{\texttt{filter()}} y \hyperlink{3384092630307389071}{\texttt{filter!()}}, permitiendo a los usuarios escribir \texttt{filter (z-> z> 3, x)} y \texttt{filter! (z-> z> 3, x)} como alternativas a las transliteraciones correspondientes \texttt{x [x.> 3]} y \texttt{x = x [x.> 3]}. El uso de \hyperlink{3384092630307389071}{\texttt{filter!()}} reduce el uso de matrices temporales.


\item El análogo de extracción (o {\textquotedbl}desreferenciación{\textquotedbl}) de todos los elementos de una matriz de celdas, p. en \texttt{vertcat(A \{:\})} en MATLAB, se escribe utilizando el operador splat en Julia, p. como \texttt{vcat(A ...)}.

\end{itemize}


\hypertarget{3288801241603969990}{}


\section{Diferencias notables con R}



Uno de los objetivos de Julia es proporcionar un lenguaje efectivo para el análisis de datos y la programación estadística. Para los usuarios que vienen a Julia de R, estas son algunas diferencias notables:



\begin{itemize}
\item Las comillas simples de Julia encierran caracteres, no cadenas.


\item Julia puede crear subcadenas indexando en cadenas. En R, las cadenas deben convertirse en vectores de caracteres antes de crear subcadenas.


\item En Julia, como Python pero a diferencia de R, las cadenas se pueden crear con comillas triples \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl} ... {\textquotedbl}{\textquotedbl}{\textquotedbl}}. Esta sintaxis es conveniente para construir cadenas que contienen saltos de línea.


\item En Julia, las variables se especifican utilizando el operador splat \texttt{...}, que siempre sigue el nombre de una variable específica, a diferencia de R, para el que \texttt{...} puede ocurrir de forma aislada.


\item En Julia, el módulo es \texttt{mod(a, b)}, no \texttt{a \%\% b}. \texttt{\%} en Julia es el operador restante.


\item En Julia, no todas las estructuras de datos admiten la indexación lógica. Además, la indexación lógica en Julia solo se admite con vectores de longitud igual al objeto que se indexa. Por ejemplo:

\begin{itemize}
\item En R, \texttt{c (1, 2, 3, 4) [c (TRUE, FALSE)]} es equivalente a \texttt{c (1, 3)}.


\item En R, \texttt{c (1, 2, 3, 4) [c (TRUE, FALSE, TRUE, FALSE)]} es equivalente a \texttt{c (1, 3)}.


\item En Julia, \texttt{[1, 2, 3, 4] [[verdadero, falso]]} arroja un \hyperlink{9731558909100893938}{\texttt{BoundsError}}.


\item En Julia, \texttt{[1, 2, 3, 4] [[verdadero, falso, verdadero, falso]]} produce \texttt{[1, 3]}.

\end{itemize}

\item Como en muchos lenguajes, Julia no siempre permite operaciones en vectores de diferentes longitudes, a diferencia de R, donde los vectores solo necesitan compartir un rango de índice común. Por ejemplo, \texttt{c(1, 2, 3, 4) + c (1, 2)} es válido R pero el equivalente \texttt{[1, 2, 3, 4] + [1, 2]} arrojará un error en Julia.


\item Julia \hyperlink{11483231213869150535}{\texttt{map()}} toma primero la función, luego sus argumentos, a diferencia de \texttt{lapply (<structure>, function, ...)} en R. De forma similar, el equivalente de Julia de \texttt{apply(X, MARGIN , FUN, ...)} en R es\hyperlink{8678396932318499078}{\texttt{mapslices()}} donde la función es el primer argumento.


\item La aplicación multivariada en R, es decir, \texttt{mapply(choose, 11:13, 1: 3)}, se puede escribir como \texttt{broadcast(binomial, 11:13, 1:3)} en Julia. Equivalentemente, Julia ofrece una sintaxis de punto más corta para vectorizar funciones \texttt{binomial.(11:13, 1: 3)}.


\item Julia usa \texttt{end} para denotar el final de bloques condicionales, como\texttt{if}, bloques de bucle, como \texttt{while} /\texttt{for}, y funciones. En lugar de la sentencia de una línea \texttt{if (cond)}, Julia permite las declaraciones de la forma \texttt{if cond; declaración; end}, \texttt{cond \&\& statement} y \texttt{!cond || declaración}. Las declaraciones de asignación en las dos últimas sintaxis deben estar explícitamente entrelazadas entre paréntesis, por ejemplo, \texttt{cond \&\& (x = value)}.


\item En Julia, \texttt{<-},\texttt{<< -}y\texttt{->}no son operadores de asignación.


\item En Julia, \texttt{->} crea una función anónima, como en Python.


\item Julia construye vectores usando corchetes. El \texttt{[1, 2, 3]} de Julia es el equivalente de R a \texttt{c(1, 2, 3)}.


\item El operador de Julia \hyperlink{8486205126068439173}{\texttt{*}} puede realizar la multiplicación de la matriz, a diferencia de R. Si \texttt{A} y\texttt{B} son matrices, entonces \texttt{A * B} denota una multiplicación de matriz en Julia, equivalente a R \texttt{A \%*\% B}. En R, esta misma notación realizaría un producto de elemento (Hadamard). Para obtener la operación de multiplicación por elementos, debe escribir \texttt{A.*B} en Julia.


\item Julia realiza la transposición de la matriz utilizando el operador \texttt{.{\textquotesingle}} y la transposición conjugada con el operador \texttt{{\textquotesingle}}. Por lo tanto, \texttt{A.{\textquotesingle}} de Julia es equivalente a \texttt{t(A)}en R.


\item Julia no requiere paréntesis cuando escribe bucles \texttt{if} o\texttt{for} / \texttt{while}: use\texttt{for i en [1, 2, 3]}en lugar de\texttt{for (i en c (1, 2, 3) )} o \texttt{if i == 1} en lugar de \texttt{if (i == 1)}.


\item Julia no trata los números \texttt{0} y\texttt{1} como booleanos. No puede escribir \texttt{if(1)} en Julia, porque las sentencias \texttt{if} solo aceptan booleanos. En su lugar, puede escribir \texttt{if true} , \texttt{if Bool(1)}, o\texttt{if 1 == 1}.


\item Julia no proporciona \texttt{nrow} y\texttt{ncol}. En su lugar, use \texttt{size(M,1)} para \texttt{nrow(M)} y \texttt{size(M,2)} para \texttt{ncol(M)}.


\item Julia tiene cuidado de distinguir escalares, vectores y matrices. En R, \texttt{1} y \texttt{c(1)} son lo mismo. En Julia, no se pueden usar indistintamente. Un resultado potencialmente confuso de esto es que \texttt{x{\textquotesingle}* y} para los vectores \texttt{x} e \texttt{y} es un vector de 1 elemento, no escalar. Para obtener un escalar, use \hyperlink{697823138745516979}{\texttt{dot(x, y)}}.


\item Julia{\textquotesingle}s \hyperlink{6899395651203530298}{\texttt{diag()}} y \hyperlink{8563936900334873682}{\texttt{diagm()}} no son como R{\textquotesingle}s.


\item Julia no puede asignar los resultados de llamadas a funciones en el lado izquierdo de una operación de asignación: no puede escribir \texttt{diag(M) = ones(n)}.


\item Julia desaconseja llenar el espacio de nombres principal con funciones. La mayoría de las funcionalidades estadísticas para Julia se encuentran en \href{http://pkg.julialang.org/}{paquetes} bajo la \href{https://github.com/JuliaStats}{organización JuliaStats}. Por ejemplo:

\begin{itemize}
\item Las funciones relacionadas con las distribuciones de probabilidad son proporcionadas por el \href{https://github.com/JuliaStats/Distributions.jl}{Paquete Distributions}.


\item El \href{https://github.com/JuliaStats/DataFrames.jl}{paquete DataFrames} proporciona el tipo de datos \texttt{DataFrame}.


\item El \href{https://github.com/JuliaStats/GLM.jl}{paquete GLM} proporciona modelos lineales generalizados.

\end{itemize}

\item Julia proporciona tuplas y tablas hash reales, pero no listas R-style. Al devolver varios elementos, normalmente debe usar una tupla: en lugar de \texttt{list(a = 1, b = 2)}, use \texttt{(1, 2)}.


\item Julia anima a los usuarios a escribir sus propios tipos, que son más fáciles de usar que los objetos S3 o S4 de R. El sistema de despacho múltiple de Julia significa que \texttt{table(x::TypeA)} y \texttt{table(x::TypeB)} actúan como R \texttt{table.TypeA(x)} y \texttt{table.TypeB(x)}.


\item En Julia, los valores se pasan y se asignan por referencia. Si una función modifica una matriz, los cambios serán visibles en el código que invoca la función. Esto es muy diferente de R y permite que las nuevas funciones operen en estructuras de datos de gran tamaño de manera mucho más eficiente.


\item En Julia, los vectores y las matrices se concatenan usando \hyperlink{8862791894748483563}{\texttt{hcat()}}, \hyperlink{14691815416955507876}{\texttt{vcat()}} y \hyperlink{16279083053557795116}{\texttt{hvcat()}}, no \texttt{c} , \texttt{rbind} y\texttt{cbind} como en R.


\item En Julia, un rango como \texttt{a:b} no es una abreviatura para un vector como en R, sino que es un \texttt{Range} especializado que se usa para la iteración sin una gran sobrecarga de memoria. Para convertir un rango en un vector, use \hyperlink{6278865767444641812}{\texttt{collect(a:b)}}.


\item Las funciones de Julia \hyperlink{7839419811914289844}{\texttt{max()}} y \hyperlink{7458766354532817148}{\texttt{min()}} son el equivalente de \texttt{pmax} y \texttt{pmin} respectivamente en R, pero ambos argumentos deben tener las mismas dimensiones. Mientras que \hyperlink{10566500735406837086}{\texttt{maximum()}} y \hyperlink{5463833925251886106}{\texttt{minimum()}} reemplazan \texttt{max} y \texttt{min} en R, hay diferencias importantes.


\item Las funciones de Julia  \hyperlink{8666686648688281595}{\texttt{sum()}}, \hyperlink{13484084847910116333}{\texttt{prod()}}, \hyperlink{10566500735406837086}{\texttt{maximum()}}, y \hyperlink{5463833925251886106}{\texttt{minimum()}} son diferentes de sus contrapartes en R. Todos aceptan uno o dos argumentos. El primer argumento es una colección iterable tal como una matriz. Si hay un segundo argumento, este argumento indica las dimensiones sobre las cuales se lleva a cabo la operación. Por ejemplo, deje \texttt{A = [[1 2], [3 4]]} en Julia y \texttt{B = rbind(c(1,2), c(3,4))} sea la misma matriz en R. Luego \texttt{sum(A)} da el mismo resultado que \texttt{sum(B)}, pero \texttt{sum(A, 1)} es un vector de fila que contiene la suma sobre cada columna y \texttt{suma (A, 2)} es un vector de columna que contiene la suma sobre cada fila. Esto contrasta con el comportamiento de R, donde \texttt{suma (B, 1) = 11} y\texttt{suma (B, 2) = 12}. Si el segundo argumento es un vector, entonces especifica todas las dimensiones sobre las cuales se realiza la suma, por ejemplo, \texttt{suma (A, [1,2]) = 10}. Cabe señalar que no hay errores de comprobación con respecto al segundo argumento.


\item Julia tiene varias funciones que pueden mutar sus argumentos. Por ejemplo, tiene ambos \hyperlink{8473525809131227606}{\texttt{sort()}} y \hyperlink{12296873681374954808}{\texttt{sort!()}}.


\item En R, el rendimiento requiere vectorización. En Julia, casi todo lo contrario es cierto: el código de mejor rendimiento a menudo se logra mediante el uso de bucles devectorized.


\item Julia es evaluada con entusiasmo y no es compatible con la evaluación perezosa de estilo R. Para la mayoría de los usuarios, esto significa que hay muy pocas expresiones sin comillas o nombres de columnas.


\item Julia no admite el tipo \texttt{NULL}.


\item A Julia le falta el equivalente de {\textquotedbl}asignar{\textquotedbl} o {\textquotedbl}obtener{\textquotedbl} de R.


\item En Julia, \texttt{return} no requiere paréntesis.


\item En R, una forma idiomática de eliminar valores no deseados es usar indexación lógica, como en la expresión \texttt{x[x> 3]} o en la declaración \texttt{x = x[x > 3]} para modificar \texttt{x} lugar. Por el contrario, Julia proporciona las funciones de orden superior \hyperlink{11445961893478569145}{\texttt{filter()}} y \hyperlink{3384092630307389071}{\texttt{filter!()}}, permitiendo a los usuarios escribir \texttt{filter (z -> z>3, x)}y\texttt{filter! (z-> z> 3, x)}como alternativas a las transliteraciones correspondientes\texttt{x[x .> 3]}y\texttt{x = x [x.> 3]}. El uso de \hyperlink{3384092630307389071}{\texttt{filter!()}} reduce el uso de matrices temporales.

\end{itemize}


\hypertarget{11105025357668256238}{}


\section{Diferencias notables con Python}



\begin{itemize}
\item Julia requiere \texttt{end} para finalizar un bloque. A diferencia de Python, Julia no tiene la palabra clave \texttt{pass}.


\item En Julia, la indexación de matrices, cadenas, etc. se basa en 1 y no en 0.


\item La indexación de segmentos de Julia incluye el último elemento, a diferencia de Python. \texttt{a[2:3]} en Julia es \texttt{a[1:3]} en Python.


\item Julia no admite índices negativos. En particular, el último elemento de una lista o matriz se indexa con \texttt{end} en Julia, no\texttt{-1} como en Python.


\item Los bloques \texttt{for},\texttt{if}, \texttt{while}, etc. de Julia terminan con la palabra clave \texttt{end}. El nivel de sangría no es significativo ya que está en Python.


\item Julia no tiene sintaxis de continuación de línea: si, al final de una línea, la entrada hasta ahora es una expresión completa, se considera hecho; de lo contrario, la entrada continúa. Una forma de forzar que una expresión continúe es envolverla entre paréntesis.


\item Los arrays de Julia son \emph{column major} (orden de Fortran) mientras que los arrays de NumPy son \emph{row major} (orden de C) por defecto. Para obtener un rendimiento óptimo al alternar sobre matrices, el orden de los bucles debe invertirse en Julia en relación con NumPy (consulte la sección correspondiente de \hyperlink{3908315974291496321}{Sugerencias de rendimiento}).


\item Los operadores de actualización de Julia (por ejemplo, \texttt{+=}, \texttt{-=}, ...) \emph{no están en el lugar} mientras que los de NumPy sí lo están. Esto significa \texttt{A = ones(4); B = A; B += 3} no cambia los valores en \texttt{A}, sino que vuelve a enlazar el nombre\texttt{B} con el resultado del lado derecho \texttt{B = B + 3}, que es una nueva matriz. Para la operación in-situ, use \texttt{B[:] += 3} (vea también \hyperlink{6173297391052343261}{operadores de punto}), loops explícitos, o \texttt{InplaceOps.jl}.


\item Julia evalúa los valores predeterminados de los argumentos de la función cada vez que se invoca el método, a diferencia de Python, donde los valores predeterminados se evalúan solo una vez cuando se define la función. Por ejemplo, la función \texttt{f(x = rand()) = x} devuelve un nuevo número aleatorio cada vez que se invoca sin argumentos. Por otro lado, la función \texttt{g (x = [1,2]) = push!(X, 3)} devuelve \texttt{[1,2,3]} cada vez que se llama como \texttt{g()}.


\item En Julia \texttt{\%} es el operador restante, mientras que en Python es el módulo.

\end{itemize}


\hypertarget{30781051824837113}{}


\section{Noteworthy differences from C/C++}



\begin{itemize}
\item Los arrays de Julia están indexados con corchetes y pueden tener más de una dimensión \texttt{A[i,j]}. Esta sintaxis no es apropiada para una referencia a un puntero o dirección como en C/C ++. Consulte la documentación de Julia sobre la sintaxis para la construcción de matrices (ha cambiado entre versiones).


\item En Julia, la indexación de matrices, cadenas, etc. se basa en 1 y no en 0.


\item Los arrays de Julia se asignan por referencia. Después de \texttt{A = B}, el cambio de elementos de\texttt{B} también modificará \texttt{A}. Los operadores de actualización como \texttt{+ =} no funcionan in situ, son equivalentes a \texttt{A = A + B}, que vuelve a enlazar el lado izquierdo con el resultado de la expresión del lado derecho.


\item Los arrays de Julia \emph{column major} (ordenación de Fortran), mientras que los conjuntos de C/C++ son \emph{row major}. Para obtener un rendimiento óptimo al realizar un bucle sobre matrices, el orden de los bucles debe invertirse en Julia en relación con C/C++ (consulte la sección correspondiente de \hyperlink{3908315974291496321}{Sugerencias de rendimiento}).


\item Los valores de Julia se pasan y se asignan por referencia. Si una función modifica una matriz, los cambios serán visibles en la persona que llama.


\item En Julia, el espacio en blanco es significativo, a diferencia de C/C ++, por lo que se debe tener cuidado al agregar/eliminar espacios en blanco de un programa Julia.


\item En Julia, los números literales sin un punto decimal (como \texttt{42}) crean enteros con signo, de tipo\texttt{Int}, pero los literales demasiado grandes para caber en el tamaño de palabra de la máquina se promocionarán automáticamente a un tipo de tamaño mayor, como \texttt{Int64} (si\texttt{Int} es \texttt{Int32}),\texttt{Int128}, o el tipo arbitrariamente grande \texttt{BigInt}. No hay sufijos literales numéricos, tales como \texttt{L},\texttt{LL}, \texttt{U},\texttt{UL}, \texttt{ULL} para indicar unsigned y/o signed vs. unsigned. Los literales decimales siempre se firman y los literales hexadecimales (que comienzan con \texttt{0x} como C / C ++), no tienen signo. Los literales hexadecimales también, a diferencia de C / C ++ / Java y, a diferencia de los literales decimales en Julia, tienen un tipo basado en la \emph{longitud} del literal, incluidos los primeros 0. Por ejemplo, \texttt{0x0} y \texttt{0x00} tienen el tipo \hyperlink{6609065134969660118}{\texttt{UInt8}},\texttt{0x000} y \texttt{0x0000} tienen el tipo \hyperlink{7018610346698168012}{\texttt{UInt16}}, luego los literales con 5 a 8 dígitos hexadecimales tienen se consideran \texttt{UInt32}, de 9 a 16 dígitos hexadecimales\texttt{UInt64} y de 17 a 32 dígitos hexadecibles \texttt{UInt128}. Esto debe tenerse en cuenta al definir máscaras hexadecimales, por ejemplo \texttt{{\textasciitilde}0xf == 0xf0} es muy diferente de\texttt{{\textasciitilde}0x000f == 0xfff0}. Los literales de 64 bit \texttt{Float64} y 32 bit \hyperlink{8101639384272933082}{\texttt{Float32}} los bit se expresan como \texttt{1.0} y\texttt{1.0f0} respectivamente. Los literales de punto flotante se redondean (y no se promocionan al tipo \texttt{BigFloat}) si no se pueden representar exactamente. Los literales de coma flotante tienen un comportamiento más cercano a C/C ++. Los literales Octal (prefijado con \texttt{0o}) y binario (prefijado con\texttt{0b}) también se tratan como sin signo.


\item Los literales de cadenas se pueden delimitar con los literales delimitados por \texttt{{\textquotedbl}} o \texttt{{\textquotedbl}{\textquotedbl}{\textquotedbl}}, que pueden contener caracteres \texttt{{\textquotedbl}} sin citarlo como \texttt{{\textquotedbl}{\textbackslash}{\textquotedbl} {\textquotedbl}} Los literales de cadena pueden tener valores de otras variables o expresiones interpoladas en ellos, indicadas por \texttt{\$nombrevariable} o\texttt{\$(expresión)}, que evalúa el nombre de la variable o la expresión en el contexto de la función.


\item \texttt{//} indica un número \hyperlink{8304566144531167610}{\texttt{Rational}}, y no un comentario de una sola línea (que es \texttt{\#}en Julia)


\item \texttt{\#=} indica el comienzo de un comentario de líneas múltiples, y \texttt{=\#} lo finaliza.


\item Las funciones en Julia devuelven valores de sus últimas expresiones o la palabra clave \texttt{return}. Pueden devolverse múltiples

\end{itemize}


valores desde funciones y asignarse como tuplas, por ejemplo, \texttt{(a, b) = myfunction ()} o \texttt{a, b = myfunction ()}, en lugar de tener que pasar los punteros a los valores como debería hacerse en C / C ++ (es decir, \texttt{a = myfunction (\&b)}.



\begin{itemize}
\item Julia no requiere el uso de punto y coma para finalizar las declaraciones. Los resultados de las expresiones no se imprimen automáticamente (excepto en el prompt interactivo, es decir, el REPL), y las líneas de código no necesitan terminar con punto y coma. \hyperlink{783803254548423222}{\texttt{println()}} o \hyperlink{4087473154660177488}{\texttt{@printf()}} se pueden usar para imprimir resultados específicos. En REPL, \texttt{;} se puede usar para suprimir la salida. \texttt{;} también tiene un significado diferente dentro de \texttt{[]}, algo de lo que hay que tener cuidado. \texttt{;} se puede usar para separar expresiones en una sola línea, pero no son estrictamente necesarias en muchos casos, y son más una ayuda para la legibilidad.


\item En Julia, el operador \hyperlink{7071880015536674935}{\texttt{⊻}} (\hyperlink{7071880015536674935}{\texttt{xor}}) realiza la operación XOR bit a bit, es decir \hyperlink{5729367935110528960}{\texttt{{\textasciicircum}}} en C / C++. Además, los operadores bit a bit no tienen la misma precedencia que C / C++, por lo que puede ser necesario un paréntesis.


\item Julia \hyperlink{5729367935110528960}{\texttt{{\textasciicircum}}} es exponenciación (pow), no bit a bit XOR como en C / C++ (use \hyperlink{7071880015536674935}{\texttt{⊻}}, o \hyperlink{7071880015536674935}{\texttt{xor}}, en Julia)


\item Julia tiene dos operadores de desplazamiento a la derecha, \texttt{>>} y \texttt{>>>}. \texttt{>>>} realiza un desplazamiento aritmético, \texttt{>>} siempre realiza un desplazamiento lógico, a diferencia de C / C ++, donde el significado de \texttt{>>} depende del tipo del valor que se está desplazando.


\item Julia{\textquotesingle}s \texttt{->} crea una función anónima, no accede a un miembro a través de un puntero.


\item Julia no requiere paréntesis cuando escribe declaraciones \texttt{if} o\texttt{for} / \texttt{while} loops: use\texttt{for i en [1, 2, 3]}en lugar de\texttt{for (int i = 1; i <= 3; i ++)}y\texttt{si i == 1} en lugar de \texttt{if (i == 1)}.


\item Julia no trata los números \texttt{0} y\texttt{1} como booleanos. No puede escribir \texttt{if (1)} en Julia, porque las sentencias \texttt{if} solo aceptan booleanos. En su lugar, puede escribir \texttt{if true},\texttt{if Bool (1)}, o\texttt{if 1 == 1}.


\item Julia usa \texttt{end} para denotar el final de bloques condicionales, como\texttt{if}, bloques de bucle, como \texttt{while} /\texttt{for}, y funciones. En lugar de la sentencia de una línea \texttt{if (cond)}, Julia permite las declaraciones de la forma \texttt{if cond; declaración; end}, \texttt{cond \&\& statement} y \texttt{!cond || declaración}. Las declaraciones de asignación en las dos últimas sintaxis deben estar explícitamente entrelazadas entre paréntesis, p. \texttt{cond \&\& (x = value)}, debido a la precedencia del operador.


\item Julia no tiene sintaxis de continuación de línea: si, al final de una línea, la entrada hasta ahora es una expresión completa, se considera hecho; de lo contrario, la entrada continúa. Una forma de forzar que una expresión continúe es envolverla entre paréntesis.


\item Las macros de Julia operan en expresiones analizadas, en lugar del texto del programa, lo que les permite realizar transformaciones sofisticadas del código de Julia. Los nombres de macro comienzan con el carácter \texttt{@}, y tienen una sintaxis similar a la función, \texttt{@mymacro (arg1, arg2, arg3)}, y una sintaxis similar a una declaración, \texttt{@mymacro arg1 arg2 arg3}. Las formas son intercambiables; la forma de función es particularmente útil si la macro aparece dentro de otra expresión, y es a menudo más clara. La forma similar a una declaración se usa a menudo para anotar bloques, como en la construcción paralela \texttt{for}:\texttt{@parallel para i en 1: n; \# = cuerpo = \#; fin}. Donde el final de la macroconstrucción puede no ser claro, use la forma similar a la función.


\item Julia ahora tiene un tipo de enumeración, expresado con el macro \texttt{@enum (name, value1, value2, ...)} Por ejemplo: \texttt{@enum (Fruit, banana = 1, apple, pear)}


\item Por convención, las funciones que modifican sus argumentos tienen un \texttt{!} Al final del nombre, por ejemplo \texttt{push!}.


\item En C ++, de forma predeterminada, tiene despacho estático, es decir, necesita anotar una función como virtual, para tener un despacho dinámico. Por otro lado, en Julia todos los métodos son {\textquotedbl}virtuales{\textquotedbl} (aunque es más general que eso ya que los métodos se envían en cada tipo de argumento, no solo \texttt{this}, usando la regla de declaración más específica).

\end{itemize}


\hypertarget{7696893994298815226}{}


\chapter{Entrada Unicode}



La siguiente tabla enumera los caracteres Unicode que pueden ingresarse mediante la terminación de pestañas de las abreviaturas similares a LaTeX en Julia REPL (y en otros entornos de edición). También puede obtener información sobre cómo escribir un símbolo ingresándolo en la ayuda REPL, es decir, escribiendo \texttt{?} Y luego ingresando el símbolo en REPL (por ejemplo, mediante copiar y pegar desde algún lugar donde vio el símbolo).



\begin{quote}
\textbf{Warning}

Puede parecer que esta tabla contiene caracteres faltantes en la segunda columna,  o incluso muestra caracteres que son inconsistentes con los caracteres tal como  se representan en Julia REPL. En estos casos, se recomienda encarecidamente a los  usuarios que comprueben la elección de las fuentes en su navegador y entorno REPL,  ya que existen problemas conocidos con los glifos en muchas fuentes.

\end{quote}



\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
Code point(s) & Character(s) & Tab completion sequence(s) & Unicode name(s) \\
\hline
U+000A1 & ¡ & {\textbackslash}textexclamdown & Inverted Exclamation Mark \\
\hline
U+000A3 & £ & {\textbackslash}sterling & Pound Sign \\
\hline
U+000A5 & ¥ & {\textbackslash}yen & Yen Sign \\
\hline
U+000A6 & ¦ & {\textbackslash}textbrokenbar & Broken Bar / Broken Vertical Bar \\
\hline
U+000A7 & § & {\textbackslash}S & Section Sign \\
\hline
U+000A8 & ¨ & {\textbackslash}textasciidieresis & Diaeresis / Spacing Diaeresis \\
\hline
U+000A9 & © & {\textbackslash}copyright, {\textbackslash}:copyright: & Copyright Sign \\
\hline
U+000AA & ª & {\textbackslash}textordfeminine & Feminine Ordinal Indicator \\
\hline
U+000AC & ¬ & {\textbackslash}neg & Not Sign \\
\hline
U+000AE & ® & {\textbackslash}circledR, {\textbackslash}:registered: & Registered Sign / Registered Trade Mark Sign \\
\hline
U+000AF & ¯ & {\textbackslash}textasciimacron & Macron / Spacing Macron \\
\hline
U+000B0 & ° & {\textbackslash}degree & Degree Sign \\
\hline
U+000B1 & ± & {\textbackslash}pm & Plus-minus Sign / Plus-or-minus Sign \\
\hline
U+000B2 & ² & {\textbackslash}{\textasciicircum}2 & Superscript Two / Superscript Digit Two \\
\hline
U+000B3 & ³ & {\textbackslash}{\textasciicircum}3 & Superscript Three / Superscript Digit Three \\
\hline
U+000B4 & ´ & {\textbackslash}textasciiacute & Acute Accent / Spacing Acute \\
\hline
U+000B6 & ¶ & {\textbackslash}P & Pilcrow Sign / Paragraph Sign \\
\hline
U+000B7 & · & {\textbackslash}cdotp & Middle Dot \\
\hline
U+000B9 & ¹ & {\textbackslash}{\textasciicircum}1 & Superscript One / Superscript Digit One \\
\hline
U+000BA & º & {\textbackslash}textordmasculine & Masculine Ordinal Indicator \\
\hline
U+000BC & ¼ & {\textbackslash}textonequarter & Vulgar Fraction One Quarter / Fraction One Quarter \\
\hline
U+000BD & ½ & {\textbackslash}textonehalf & Vulgar Fraction One Half / Fraction One Half \\
\hline
U+000BE & ¾ & {\textbackslash}textthreequarters & Vulgar Fraction Three Quarters / Fraction Three Quarters \\
\hline
U+000BF & ¿ & {\textbackslash}textquestiondown & Inverted Question Mark \\
\hline
U+000C5 & Å & {\textbackslash}AA & Latin Capital Letter A With Ring Above / Latin Capital Letter A Ring \\
\hline
U+000C6 & Æ & {\textbackslash}AE & Latin Capital Letter Ae / Latin Capital Letter A E \\
\hline
U+000D0 & Ð & {\textbackslash}DH & Latin Capital Letter Eth \\
\hline
U+000D7 & × & {\textbackslash}times & Multiplication Sign \\
\hline
U+000D8 & Ø & {\textbackslash}O & Latin Capital Letter O With Stroke / Latin Capital Letter O Slash \\
\hline
U+000DE & Þ & {\textbackslash}TH & Latin Capital Letter Thorn \\
\hline
U+000DF & ß & {\textbackslash}ss & Latin Small Letter Sharp S \\
\hline
U+000E5 & å & {\textbackslash}aa & Latin Small Letter A With Ring Above / Latin Small Letter A Ring \\
\hline
U+000E6 & æ & {\textbackslash}ae & Latin Small Letter Ae / Latin Small Letter A E \\
\hline
U+000F0 & ð & {\textbackslash}eth & Latin Small Letter Eth \\
\hline
U+000F7 & ÷ & {\textbackslash}div & Division Sign \\
\hline
U+000F8 & ø & {\textbackslash}o & Latin Small Letter O With Stroke / Latin Small Letter O Slash \\
\hline
U+000FE & þ & {\textbackslash}th & Latin Small Letter Thorn \\
\hline
U+00110 & Đ & {\textbackslash}DJ & Latin Capital Letter D With Stroke / Latin Capital Letter D Bar \\
\hline
U+00111 & đ & {\textbackslash}dj & Latin Small Letter D With Stroke / Latin Small Letter D Bar \\
\hline
U+00127 & ħ & {\textbackslash}Elzxh, {\textbackslash}hbar & Latin Small Letter H With Stroke / Latin Small Letter H Bar \\
\hline
U+00141 & Ł & {\textbackslash}L & Latin Capital Letter L With Stroke / Latin Capital Letter L Slash \\
\hline
U+00142 & ł & {\textbackslash}l & Latin Small Letter L With Stroke / Latin Small Letter L Slash \\
\hline
U+0014A & Ŋ & {\textbackslash}NG & Latin Capital Letter Eng \\
\hline
U+0014B & ŋ & {\textbackslash}ng & Latin Small Letter Eng \\
\hline
U+00152 & Œ & {\textbackslash}OE & Latin Capital Ligature Oe / Latin Capital Letter O E \\
\hline
U+00153 & œ & {\textbackslash}oe & Latin Small Ligature Oe / Latin Small Letter O E \\
\hline
U+00195 & ƕ & {\textbackslash}texthvlig & Latin Small Letter Hv / Latin Small Letter H V \\
\hline
U+0019E & ƞ & {\textbackslash}textnrleg & Latin Small Letter N With Long Right Leg \\
\hline
U+001B5 & Ƶ & {\textbackslash}Zbar & Latin Capital Letter Z With Stroke / Latin Capital Letter Z Bar \\
\hline
U+001C2 & ǂ & {\textbackslash}textdoublepipe & Latin Letter Alveolar Click / Latin Letter Pipe Double Bar \\
\hline
U+00250 & ɐ & {\textbackslash}Elztrna & Latin Small Letter Turned A \\
\hline
U+00252 & ɒ & {\textbackslash}Elztrnsa & Latin Small Letter Turned Alpha / Latin Small Letter Turned Script A \\
\hline
U+00254 & ɔ & {\textbackslash}Elzopeno & Latin Small Letter Open O \\
\hline
U+00256 & ɖ & {\textbackslash}Elzrtld & Latin Small Letter D With Tail / Latin Small Letter D Retroflex Hook \\
\hline
U+00259 & ə & {\textbackslash}Elzschwa & Latin Small Letter Schwa \\
\hline
U+00263 & ɣ & {\textbackslash}Elzpgamma & Latin Small Letter Gamma \\
\hline
U+00264 & ɤ & {\textbackslash}Elzpbgam & Latin Small Letter Rams Horn / Latin Small Letter Baby Gamma \\
\hline
U+00265 & ɥ & {\textbackslash}Elztrnh & Latin Small Letter Turned H \\
\hline
U+0026C & ɬ & {\textbackslash}Elzbtdl & Latin Small Letter L With Belt / Latin Small Letter L Belt \\
\hline
U+0026D & ɭ & {\textbackslash}Elzrtll & Latin Small Letter L With Retroflex Hook / Latin Small Letter L Retroflex Hook \\
\hline
U+0026F & ɯ & {\textbackslash}Elztrnm & Latin Small Letter Turned M \\
\hline
U+00270 & ɰ & {\textbackslash}Elztrnmlr & Latin Small Letter Turned M With Long Leg \\
\hline
U+00271 & ɱ & {\textbackslash}Elzltlmr & Latin Small Letter M With Hook / Latin Small Letter M Hook \\
\hline
U+00272 & ɲ & {\textbackslash}Elzltln & Latin Small Letter N With Left Hook / Latin Small Letter N Hook \\
\hline
U+00273 & ɳ & {\textbackslash}Elzrtln & Latin Small Letter N With Retroflex Hook / Latin Small Letter N Retroflex Hook \\
\hline
U+00277 & ɷ & {\textbackslash}Elzclomeg & Latin Small Letter Closed Omega \\
\hline
U+00278 & ɸ & {\textbackslash}textphi & Latin Small Letter Phi \\
\hline
U+00279 & ɹ & {\textbackslash}Elztrnr & Latin Small Letter Turned R \\
\hline
U+0027A & ɺ & {\textbackslash}Elztrnrl & Latin Small Letter Turned R With Long Leg \\
\hline
U+0027B & ɻ & {\textbackslash}Elzrttrnr & Latin Small Letter Turned R With Hook / Latin Small Letter Turned R Hook \\
\hline
U+0027C & ɼ & {\textbackslash}Elzrl & Latin Small Letter R With Long Leg \\
\hline
U+0027D & ɽ & {\textbackslash}Elzrtlr & Latin Small Letter R With Tail / Latin Small Letter R Hook \\
\hline
U+0027E & ɾ & {\textbackslash}Elzfhr & Latin Small Letter R With Fishhook / Latin Small Letter Fishhook R \\
\hline
U+00282 & ʂ & {\textbackslash}Elzrtls & Latin Small Letter S With Hook / Latin Small Letter S Hook \\
\hline
U+00283 & ʃ & {\textbackslash}Elzesh & Latin Small Letter Esh \\
\hline
U+00287 & ʇ & {\textbackslash}Elztrnt & Latin Small Letter Turned T \\
\hline
U+00288 & ʈ & {\textbackslash}Elzrtlt & Latin Small Letter T With Retroflex Hook / Latin Small Letter T Retroflex Hook \\
\hline
U+0028A & ʊ & {\textbackslash}Elzpupsil & Latin Small Letter Upsilon \\
\hline
U+0028B & ʋ & {\textbackslash}Elzpscrv & Latin Small Letter V With Hook / Latin Small Letter Script V \\
\hline
U+0028C & ʌ & {\textbackslash}Elzinvv & Latin Small Letter Turned V \\
\hline
U+0028D & ʍ & {\textbackslash}Elzinvw & Latin Small Letter Turned W \\
\hline
U+0028E & ʎ & {\textbackslash}Elztrny & Latin Small Letter Turned Y \\
\hline
U+00290 & ʐ & {\textbackslash}Elzrtlz & Latin Small Letter Z With Retroflex Hook / Latin Small Letter Z Retroflex Hook \\
\hline
U+00292 & ʒ & {\textbackslash}Elzyogh & Latin Small Letter Ezh / Latin Small Letter Yogh \\
\hline
U+00294 & ʔ & {\textbackslash}Elzglst & Latin Letter Glottal Stop \\
\hline
U+00295 & ʕ & {\textbackslash}Elzreglst & Latin Letter Pharyngeal Voiced Fricative / Latin Letter Reversed Glottal Stop \\
\hline
U+00296 & ʖ & {\textbackslash}Elzinglst & Latin Letter Inverted Glottal Stop \\
\hline
U+0029E & ʞ & {\textbackslash}textturnk & Latin Small Letter Turned K \\
\hline
U+002A4 & ʤ & {\textbackslash}Elzdyogh & Latin Small Letter Dezh Digraph / Latin Small Letter D Yogh \\
\hline
U+002A7 & ʧ & {\textbackslash}Elztesh & Latin Small Letter Tesh Digraph / Latin Small Letter T Esh \\
\hline
U+002B0 & ʰ & {\textbackslash}{\textasciicircum}h & Modifier Letter Small H \\
\hline
U+002B2 & ʲ & {\textbackslash}{\textasciicircum}j & Modifier Letter Small J \\
\hline
U+002B3 & ʳ & {\textbackslash}{\textasciicircum}r & Modifier Letter Small R \\
\hline
U+002B7 & ʷ & {\textbackslash}{\textasciicircum}w & Modifier Letter Small W \\
\hline
U+002B8 & ʸ & {\textbackslash}{\textasciicircum}y & Modifier Letter Small Y \\
\hline
U+002BC & ʼ & {\textbackslash}rasp & Modifier Letter Apostrophe \\
\hline
U+002C7 & ˇ & {\textbackslash}textasciicaron & Caron / Modifier Letter Hacek \\
\hline
U+002C8 & ˈ & {\textbackslash}Elzverts & Modifier Letter Vertical Line \\
\hline
U+002CC & ˌ & {\textbackslash}Elzverti & Modifier Letter Low Vertical Line \\
\hline
U+002D0 & ː & {\textbackslash}Elzlmrk & Modifier Letter Triangular Colon \\
\hline
U+002D1 & ˑ & {\textbackslash}Elzhlmrk & Modifier Letter Half Triangular Colon \\
\hline
U+002D2 & ˒ & {\textbackslash}Elzsbrhr & Modifier Letter Centred Right Half Ring / Modifier Letter Centered Right Half Ring \\
\hline
U+002D3 & ˓ & {\textbackslash}Elzsblhr & Modifier Letter Centred Left Half Ring / Modifier Letter Centered Left Half Ring \\
\hline
U+002D4 & ˔ & {\textbackslash}Elzrais & Modifier Letter Up Tack \\
\hline
U+002D5 & ˕ & {\textbackslash}Elzlow & Modifier Letter Down Tack \\
\hline
U+002D8 & ˘ & {\textbackslash}u & Breve / Spacing Breve \\
\hline
U+002DC & ˜ & {\textbackslash}texttildelow & Small Tilde / Spacing Tilde \\
\hline
U+002E1 & ˡ & {\textbackslash}{\textasciicircum}l & Modifier Letter Small L \\
\hline
U+002E2 & ˢ & {\textbackslash}{\textasciicircum}s & Modifier Letter Small S \\
\hline
U+002E3 & ˣ & {\textbackslash}{\textasciicircum}x & Modifier Letter Small X \\
\hline
U+00300 & ◌̀ & {\textbackslash}grave & Combining Grave Accent / Non-spacing Grave \\
\hline
U+00301 & ◌́ & {\textbackslash}acute & Combining Acute Accent / Non-spacing Acute \\
\hline
U+00302 & ◌̂ & {\textbackslash}hat & Combining Circumflex Accent / Non-spacing Circumflex \\
\hline
U+00303 & ◌̃ & {\textbackslash}tilde & Combining Tilde / Non-spacing Tilde \\
\hline
U+00304 & ◌̄ & {\textbackslash}bar & Combining Macron / Non-spacing Macron \\
\hline
U+00305 & ◌̅ & {\textbackslash}overbar & Combining Overline / Non-spacing Overscore \\
\hline
U+00306 & ◌̆ & {\textbackslash}breve & Combining Breve / Non-spacing Breve \\
\hline
U+00307 & ◌̇ & {\textbackslash}dot & Combining Dot Above / Non-spacing Dot Above \\
\hline
U+00308 & ◌̈ & {\textbackslash}ddot & Combining Diaeresis / Non-spacing Diaeresis \\
\hline
U+00309 & ◌̉ & {\textbackslash}ovhook & Combining Hook Above / Non-spacing Hook Above \\
\hline
U+0030A & ◌̊ & {\textbackslash}ocirc & Combining Ring Above / Non-spacing Ring Above \\
\hline
U+0030B & ◌̋ & {\textbackslash}H & Combining Double Acute Accent / Non-spacing Double Acute \\
\hline
U+0030C & ◌̌ & {\textbackslash}check & Combining Caron / Non-spacing Hacek \\
\hline
U+00310 & ◌̐ & {\textbackslash}candra & Combining Candrabindu / Non-spacing Candrabindu \\
\hline
U+00312 & ◌̒ & {\textbackslash}oturnedcomma & Combining Turned Comma Above / Non-spacing Turned Comma Above \\
\hline
U+00315 & ◌̕ & {\textbackslash}ocommatopright & Combining Comma Above Right / Non-spacing Comma Above Right \\
\hline
U+0031A & ◌̚ & {\textbackslash}droang & Combining Left Angle Above / Non-spacing Left Angle Above \\
\hline
U+00321 & ◌̡ & {\textbackslash}Elzpalh & Combining Palatalized Hook Below / Non-spacing Palatalized Hook Below \\
\hline
U+00322 & ◌̢ & {\textbackslash}Elzrh & Combining Retroflex Hook Below / Non-spacing Retroflex Hook Below \\
\hline
U+00327 & ◌̧ & {\textbackslash}c & Combining Cedilla / Non-spacing Cedilla \\
\hline
U+00328 & ◌̨ & {\textbackslash}k & Combining Ogonek / Non-spacing Ogonek \\
\hline
U+0032A & ◌̪ & {\textbackslash}Elzsbbrg & Combining Bridge Below / Non-spacing Bridge Below \\
\hline
U+00330 & ◌̰ & {\textbackslash}wideutilde & Combining Tilde Below / Non-spacing Tilde Below \\
\hline
U+00332 & ◌̲ & {\textbackslash}underbar & Combining Low Line / Non-spacing Underscore \\
\hline
U+00335 & ◌̵ & {\textbackslash}Elzxl & Combining Short Stroke Overlay / Non-spacing Short Bar Overlay \\
\hline
U+00336 & ◌̶ & {\textbackslash}Elzbar, {\textbackslash}sout & Combining Long Stroke Overlay / Non-spacing Long Bar Overlay \\
\hline
U+00338 & ◌̸ & {\textbackslash}not & Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0034D & ◌͍ & {\textbackslash}underleftrightarrow & Combining Left Right Arrow Below \\
\hline
U+00391 & Α & {\textbackslash}Alpha & Greek Capital Letter Alpha \\
\hline
U+00392 & Β & {\textbackslash}Beta & Greek Capital Letter Beta \\
\hline
U+00393 & Γ & {\textbackslash}Gamma & Greek Capital Letter Gamma \\
\hline
U+00394 & Δ & {\textbackslash}Delta & Greek Capital Letter Delta \\
\hline
U+00395 & Ε & {\textbackslash}Epsilon & Greek Capital Letter Epsilon \\
\hline
U+00396 & Ζ & {\textbackslash}Zeta & Greek Capital Letter Zeta \\
\hline
U+00397 & Η & {\textbackslash}Eta & Greek Capital Letter Eta \\
\hline
U+00398 & Θ & {\textbackslash}Theta & Greek Capital Letter Theta \\
\hline
U+00399 & Ι & {\textbackslash}Iota & Greek Capital Letter Iota \\
\hline
U+0039A & Κ & {\textbackslash}Kappa & Greek Capital Letter Kappa \\
\hline
U+0039B & Λ & {\textbackslash}Lambda & Greek Capital Letter Lamda / Greek Capital Letter Lambda \\
\hline
U+0039C & Μ & {\textbackslash}upMu & Greek Capital Letter Mu \\
\hline
U+0039D & Ν & {\textbackslash}upNu & Greek Capital Letter Nu \\
\hline
U+0039E & Ξ & {\textbackslash}Xi & Greek Capital Letter Xi \\
\hline
U+0039F & Ο & {\textbackslash}upOmicron & Greek Capital Letter Omicron \\
\hline
U+003A0 & Π & {\textbackslash}Pi & Greek Capital Letter Pi \\
\hline
U+003A1 & Ρ & {\textbackslash}Rho & Greek Capital Letter Rho \\
\hline
U+003A3 & Σ & {\textbackslash}Sigma & Greek Capital Letter Sigma \\
\hline
U+003A4 & Τ & {\textbackslash}Tau & Greek Capital Letter Tau \\
\hline
U+003A5 & Υ & {\textbackslash}Upsilon & Greek Capital Letter Upsilon \\
\hline
U+003A6 & Φ & {\textbackslash}Phi & Greek Capital Letter Phi \\
\hline
U+003A7 & Χ & {\textbackslash}Chi & Greek Capital Letter Chi \\
\hline
U+003A8 & Ψ & {\textbackslash}Psi & Greek Capital Letter Psi \\
\hline
U+003A9 & Ω & {\textbackslash}Omega & Greek Capital Letter Omega \\
\hline
U+003B1 & α & {\textbackslash}alpha & Greek Small Letter Alpha \\
\hline
U+003B2 & β & {\textbackslash}beta & Greek Small Letter Beta \\
\hline
U+003B3 & γ & {\textbackslash}gamma & Greek Small Letter Gamma \\
\hline
U+003B4 & δ & {\textbackslash}delta & Greek Small Letter Delta \\
\hline
U+003B5 & ε & {\textbackslash}upepsilon, {\textbackslash}varepsilon & Greek Small Letter Epsilon \\
\hline
U+003B6 & ζ & {\textbackslash}zeta & Greek Small Letter Zeta \\
\hline
U+003B7 & η & {\textbackslash}eta & Greek Small Letter Eta \\
\hline
U+003B8 & θ & {\textbackslash}theta & Greek Small Letter Theta \\
\hline
U+003B9 & ι & {\textbackslash}iota & Greek Small Letter Iota \\
\hline
U+003BA & κ & {\textbackslash}kappa & Greek Small Letter Kappa \\
\hline
U+003BB & λ & {\textbackslash}lambda & Greek Small Letter Lamda / Greek Small Letter Lambda \\
\hline
U+003BC & μ & {\textbackslash}mu & Greek Small Letter Mu \\
\hline
U+003BD & ν & {\textbackslash}nu & Greek Small Letter Nu \\
\hline
U+003BE & ξ & {\textbackslash}xi & Greek Small Letter Xi \\
\hline
U+003BF & ο & {\textbackslash}upomicron & Greek Small Letter Omicron \\
\hline
U+003C0 & π & {\textbackslash}pi & Greek Small Letter Pi \\
\hline
U+003C1 & ρ & {\textbackslash}rho & Greek Small Letter Rho \\
\hline
U+003C2 & ς & {\textbackslash}varsigma & Greek Small Letter Final Sigma \\
\hline
U+003C3 & σ & {\textbackslash}sigma & Greek Small Letter Sigma \\
\hline
U+003C4 & τ & {\textbackslash}tau & Greek Small Letter Tau \\
\hline
U+003C5 & υ & {\textbackslash}upsilon & Greek Small Letter Upsilon \\
\hline
U+003C6 & φ & {\textbackslash}varphi & Greek Small Letter Phi \\
\hline
U+003C7 & χ & {\textbackslash}chi & Greek Small Letter Chi \\
\hline
U+003C8 & ψ & {\textbackslash}psi & Greek Small Letter Psi \\
\hline
U+003C9 & ω & {\textbackslash}omega & Greek Small Letter Omega \\
\hline
U+003D0 & ϐ & {\textbackslash}upvarbeta & Greek Beta Symbol / Greek Small Letter Curled Beta \\
\hline
U+003D1 & ϑ & {\textbackslash}vartheta & Greek Theta Symbol / Greek Small Letter Script Theta \\
\hline
U+003D5 & ϕ & {\textbackslash}phi & Greek Phi Symbol / Greek Small Letter Script Phi \\
\hline
U+003D6 & ϖ & {\textbackslash}varpi & Greek Pi Symbol / Greek Small Letter Omega Pi \\
\hline
U+003D8 & Ϙ & {\textbackslash}upoldKoppa & Greek Letter Archaic Koppa \\
\hline
U+003D9 & ϙ & {\textbackslash}upoldkoppa & Greek Small Letter Archaic Koppa \\
\hline
U+003DA & Ϛ & {\textbackslash}Stigma & Greek Letter Stigma / Greek Capital Letter Stigma \\
\hline
U+003DB & ϛ & {\textbackslash}upstigma & Greek Small Letter Stigma \\
\hline
U+003DC & Ϝ & {\textbackslash}Digamma & Greek Letter Digamma / Greek Capital Letter Digamma \\
\hline
U+003DD & ϝ & {\textbackslash}digamma & Greek Small Letter Digamma \\
\hline
U+003DE & Ϟ & {\textbackslash}Koppa & Greek Letter Koppa / Greek Capital Letter Koppa \\
\hline
U+003DF & ϟ & {\textbackslash}upkoppa & Greek Small Letter Koppa \\
\hline
U+003E0 & Ϡ & {\textbackslash}Sampi & Greek Letter Sampi / Greek Capital Letter Sampi \\
\hline
U+003E1 & ϡ & {\textbackslash}upsampi & Greek Small Letter Sampi \\
\hline
U+003F0 & ϰ & {\textbackslash}varkappa & Greek Kappa Symbol / Greek Small Letter Script Kappa \\
\hline
U+003F1 & ϱ & {\textbackslash}varrho & Greek Rho Symbol / Greek Small Letter Tailed Rho \\
\hline
U+003F4 & ϴ & {\textbackslash}textTheta & Greek Capital Theta Symbol \\
\hline
U+003F5 & ϵ & {\textbackslash}epsilon & Greek Lunate Epsilon Symbol \\
\hline
U+003F6 & ϶ & {\textbackslash}backepsilon & Greek Reversed Lunate Epsilon Symbol \\
\hline
U+01D2C & ᴬ & {\textbackslash}{\textasciicircum}A & Modifier Letter Capital A \\
\hline
U+01D2E & ᴮ & {\textbackslash}{\textasciicircum}B & Modifier Letter Capital B \\
\hline
U+01D30 & ᴰ & {\textbackslash}{\textasciicircum}D & Modifier Letter Capital D \\
\hline
U+01D31 & ᴱ & {\textbackslash}{\textasciicircum}E & Modifier Letter Capital E \\
\hline
U+01D33 & ᴳ & {\textbackslash}{\textasciicircum}G & Modifier Letter Capital G \\
\hline
U+01D34 & ᴴ & {\textbackslash}{\textasciicircum}H & Modifier Letter Capital H \\
\hline
U+01D35 & ᴵ & {\textbackslash}{\textasciicircum}I & Modifier Letter Capital I \\
\hline
U+01D36 & ᴶ & {\textbackslash}{\textasciicircum}J & Modifier Letter Capital J \\
\hline
U+01D37 & ᴷ & {\textbackslash}{\textasciicircum}K & Modifier Letter Capital K \\
\hline
U+01D38 & ᴸ & {\textbackslash}{\textasciicircum}L & Modifier Letter Capital L \\
\hline
U+01D39 & ᴹ & {\textbackslash}{\textasciicircum}M & Modifier Letter Capital M \\
\hline
U+01D3A & ᴺ & {\textbackslash}{\textasciicircum}N & Modifier Letter Capital N \\
\hline
U+01D3C & ᴼ & {\textbackslash}{\textasciicircum}O & Modifier Letter Capital O \\
\hline
U+01D3E & ᴾ & {\textbackslash}{\textasciicircum}P & Modifier Letter Capital P \\
\hline
U+01D3F & ᴿ & {\textbackslash}{\textasciicircum}R & Modifier Letter Capital R \\
\hline
U+01D40 & ᵀ & {\textbackslash}{\textasciicircum}T & Modifier Letter Capital T \\
\hline
U+01D41 & ᵁ & {\textbackslash}{\textasciicircum}U & Modifier Letter Capital U \\
\hline
U+01D42 & ᵂ & {\textbackslash}{\textasciicircum}W & Modifier Letter Capital W \\
\hline
U+01D43 & ᵃ & {\textbackslash}{\textasciicircum}a & Modifier Letter Small A \\
\hline
U+01D45 & ᵅ & {\textbackslash}{\textasciicircum}alpha & Modifier Letter Small Alpha \\
\hline
U+01D47 & ᵇ & {\textbackslash}{\textasciicircum}b & Modifier Letter Small B \\
\hline
U+01D48 & ᵈ & {\textbackslash}{\textasciicircum}d & Modifier Letter Small D \\
\hline
U+01D49 & ᵉ & {\textbackslash}{\textasciicircum}e & Modifier Letter Small E \\
\hline
U+01D4B & ᵋ & {\textbackslash}{\textasciicircum}epsilon & Modifier Letter Small Open E \\
\hline
U+01D4D & ᵍ & {\textbackslash}{\textasciicircum}g & Modifier Letter Small G \\
\hline
U+01D4F & ᵏ & {\textbackslash}{\textasciicircum}k & Modifier Letter Small K \\
\hline
U+01D50 & ᵐ & {\textbackslash}{\textasciicircum}m & Modifier Letter Small M \\
\hline
U+01D52 & ᵒ & {\textbackslash}{\textasciicircum}o & Modifier Letter Small O \\
\hline
U+01D56 & ᵖ & {\textbackslash}{\textasciicircum}p & Modifier Letter Small P \\
\hline
U+01D57 & ᵗ & {\textbackslash}{\textasciicircum}t & Modifier Letter Small T \\
\hline
U+01D58 & ᵘ & {\textbackslash}{\textasciicircum}u & Modifier Letter Small U \\
\hline
U+01D5B & ᵛ & {\textbackslash}{\textasciicircum}v & Modifier Letter Small V \\
\hline
U+01D5D & ᵝ & {\textbackslash}{\textasciicircum}beta & Modifier Letter Small Beta \\
\hline
U+01D5E & ᵞ & {\textbackslash}{\textasciicircum}gamma & Modifier Letter Small Greek Gamma \\
\hline
U+01D5F & ᵟ & {\textbackslash}{\textasciicircum}delta & Modifier Letter Small Delta \\
\hline
U+01D60 & ᵠ & {\textbackslash}{\textasciicircum}phi & Modifier Letter Small Greek Phi \\
\hline
U+01D61 & ᵡ & {\textbackslash}{\textasciicircum}chi & Modifier Letter Small Chi \\
\hline
U+01D62 & ᵢ & {\textbackslash}\_i & Latin Subscript Small Letter I \\
\hline
U+01D63 & ᵣ & {\textbackslash}\_r & Latin Subscript Small Letter R \\
\hline
U+01D64 & ᵤ & {\textbackslash}\_u & Latin Subscript Small Letter U \\
\hline
U+01D65 & ᵥ & {\textbackslash}\_v & Latin Subscript Small Letter V \\
\hline
U+01D66 & ᵦ & {\textbackslash}\_beta & Greek Subscript Small Letter Beta \\
\hline
U+01D67 & ᵧ & {\textbackslash}\_gamma & Greek Subscript Small Letter Gamma \\
\hline
U+01D68 & ᵨ & {\textbackslash}\_rho & Greek Subscript Small Letter Rho \\
\hline
U+01D69 & ᵩ & {\textbackslash}\_phi & Greek Subscript Small Letter Phi \\
\hline
U+01D6A & ᵪ & {\textbackslash}\_chi & Greek Subscript Small Letter Chi \\
\hline
U+01D9C & ᶜ & {\textbackslash}{\textasciicircum}c & Modifier Letter Small C \\
\hline
U+01DA0 & ᶠ & {\textbackslash}{\textasciicircum}f & Modifier Letter Small F \\
\hline
U+01DA5 & ᶥ & {\textbackslash}{\textasciicircum}iota & Modifier Letter Small Iota \\
\hline
U+01DB2 & ᶲ & {\textbackslash}{\textasciicircum}Phi & Modifier Letter Small Phi \\
\hline
U+01DBB & ᶻ & {\textbackslash}{\textasciicircum}z & Modifier Letter Small Z \\
\hline
U+01DBF & ᶿ & {\textbackslash}{\textasciicircum}theta & Modifier Letter Small Theta \\
\hline
U+02002 &   & {\textbackslash}enspace & En Space \\
\hline
U+02003 &   & {\textbackslash}quad & Em Space \\
\hline
U+02005 &   & {\textbackslash}thickspace & Four-per-em Space \\
\hline
U+02009 &   & {\textbackslash}thinspace & Thin Space \\
\hline
U+0200A &   & {\textbackslash}hspace & Hair Space \\
\hline
U+02013 & – & {\textbackslash}endash & En Dash \\
\hline
U+02014 & — & {\textbackslash}emdash & Em Dash \\
\hline
U+02016 & ‖ & {\textbackslash}Vert & Double Vertical Line / Double Vertical Bar \\
\hline
U+02018 & ‘ & {\textbackslash}lq & Left Single Quotation Mark / Single Turned Comma Quotation Mark \\
\hline
U+02019 & ’ & {\textbackslash}rq & Right Single Quotation Mark / Single Comma Quotation Mark \\
\hline
U+0201B & ‛ & {\textbackslash}Elzreapos & Single High-reversed-9 Quotation Mark / Single Reversed Comma Quotation Mark \\
\hline
U+0201C & “ & {\textbackslash}textquotedblleft & Left Double Quotation Mark / Double Turned Comma Quotation Mark \\
\hline
U+0201D & ” & {\textbackslash}textquotedblright & Right Double Quotation Mark / Double Comma Quotation Mark \\
\hline
U+02020 & † & {\textbackslash}dagger & Dagger \\
\hline
U+02021 & ‡ & {\textbackslash}ddagger & Double Dagger \\
\hline
U+02022 & • & {\textbackslash}bullet & Bullet \\
\hline
U+02026 & … & {\textbackslash}dots, {\textbackslash}ldots & Horizontal Ellipsis \\
\hline
U+02030 & ‰ & {\textbackslash}textperthousand & Per Mille Sign \\
\hline
U+02031 & ‱ & {\textbackslash}textpertenthousand & Per Ten Thousand Sign \\
\hline
U+02032 & ′ & {\textbackslash}prime & Prime \\
\hline
U+02033 & ″ & {\textbackslash}pprime & Double Prime \\
\hline
U+02034 & ‴ & {\textbackslash}ppprime & Triple Prime \\
\hline
U+02035 & ‵ & {\textbackslash}backprime & Reversed Prime \\
\hline
U+02036 & ‶ & {\textbackslash}backpprime & Reversed Double Prime \\
\hline
U+02037 & ‷ & {\textbackslash}backppprime & Reversed Triple Prime \\
\hline
U+02039 & ‹ & {\textbackslash}guilsinglleft & Single Left-pointing Angle Quotation Mark / Left Pointing Single Guillemet \\
\hline
U+0203A & › & {\textbackslash}guilsinglright & Single Right-pointing Angle Quotation Mark / Right Pointing Single Guillemet \\
\hline
U+0203C & ‼ & {\textbackslash}:bangbang: & Double Exclamation Mark \\
\hline
U+02040 & ⁀ & {\textbackslash}tieconcat & Character Tie \\
\hline
U+02049 & ⁉ & {\textbackslash}:interrobang: & Exclamation Question Mark \\
\hline
U+02057 & ⁗ & {\textbackslash}pppprime & Quadruple Prime \\
\hline
U+02060 & ⁠ & {\textbackslash}nolinebreak & Word Joiner \\
\hline
U+02070 & ⁰ & {\textbackslash}{\textasciicircum}0 & Superscript Zero / Superscript Digit Zero \\
\hline
U+02071 & ⁱ & {\textbackslash}{\textasciicircum}i & Superscript Latin Small Letter I \\
\hline
U+02074 & ⁴ & {\textbackslash}{\textasciicircum}4 & Superscript Four / Superscript Digit Four \\
\hline
U+02075 & ⁵ & {\textbackslash}{\textasciicircum}5 & Superscript Five / Superscript Digit Five \\
\hline
U+02076 & ⁶ & {\textbackslash}{\textasciicircum}6 & Superscript Six / Superscript Digit Six \\
\hline
U+02077 & ⁷ & {\textbackslash}{\textasciicircum}7 & Superscript Seven / Superscript Digit Seven \\
\hline
U+02078 & ⁸ & {\textbackslash}{\textasciicircum}8 & Superscript Eight / Superscript Digit Eight \\
\hline
U+02079 & ⁹ & {\textbackslash}{\textasciicircum}9 & Superscript Nine / Superscript Digit Nine \\
\hline
U+0207A & ⁺ & {\textbackslash}{\textasciicircum}+ & Superscript Plus Sign \\
\hline
U+0207B & ⁻ & {\textbackslash}{\textasciicircum}- & Superscript Minus / Superscript Hyphen-minus \\
\hline
U+0207C & ⁼ & {\textbackslash}{\textasciicircum}= & Superscript Equals Sign \\
\hline
U+0207D & ⁽ & {\textbackslash}{\textasciicircum}( & Superscript Left Parenthesis / Superscript Opening Parenthesis \\
\hline
U+0207E & ⁾ & {\textbackslash}{\textasciicircum}) & Superscript Right Parenthesis / Superscript Closing Parenthesis \\
\hline
U+0207F & ⁿ & {\textbackslash}{\textasciicircum}n & Superscript Latin Small Letter N \\
\hline
U+02080 & ₀ & {\textbackslash}\_0 & Subscript Zero / Subscript Digit Zero \\
\hline
U+02081 & ₁ & {\textbackslash}\_1 & Subscript One / Subscript Digit One \\
\hline
U+02082 & ₂ & {\textbackslash}\_2 & Subscript Two / Subscript Digit Two \\
\hline
U+02083 & ₃ & {\textbackslash}\_3 & Subscript Three / Subscript Digit Three \\
\hline
U+02084 & ₄ & {\textbackslash}\_4 & Subscript Four / Subscript Digit Four \\
\hline
U+02085 & ₅ & {\textbackslash}\_5 & Subscript Five / Subscript Digit Five \\
\hline
U+02086 & ₆ & {\textbackslash}\_6 & Subscript Six / Subscript Digit Six \\
\hline
U+02087 & ₇ & {\textbackslash}\_7 & Subscript Seven / Subscript Digit Seven \\
\hline
U+02088 & ₈ & {\textbackslash}\_8 & Subscript Eight / Subscript Digit Eight \\
\hline
U+02089 & ₉ & {\textbackslash}\_9 & Subscript Nine / Subscript Digit Nine \\
\hline
U+0208A & ₊ & {\textbackslash}\_+ & Subscript Plus Sign \\
\hline
U+0208B & ₋ & {\textbackslash}\_- & Subscript Minus / Subscript Hyphen-minus \\
\hline
U+0208C & ₌ & {\textbackslash}\_= & Subscript Equals Sign \\
\hline
U+0208D & ₍ & {\textbackslash}\_( & Subscript Left Parenthesis / Subscript Opening Parenthesis \\
\hline
U+0208E & ₎ & {\textbackslash}\_) & Subscript Right Parenthesis / Subscript Closing Parenthesis \\
\hline
U+02090 & ₐ & {\textbackslash}\_a & Latin Subscript Small Letter A \\
\hline
U+02091 & ₑ & {\textbackslash}\_e & Latin Subscript Small Letter E \\
\hline
U+02092 & ₒ & {\textbackslash}\_o & Latin Subscript Small Letter O \\
\hline
U+02093 & ₓ & {\textbackslash}\_x & Latin Subscript Small Letter X \\
\hline
U+02094 & ₔ & {\textbackslash}\_schwa & Latin Subscript Small Letter Schwa \\
\hline
U+02095 & ₕ & {\textbackslash}\_h & Latin Subscript Small Letter H \\
\hline
U+02096 & ₖ & {\textbackslash}\_k & Latin Subscript Small Letter K \\
\hline
U+02097 & ₗ & {\textbackslash}\_l & Latin Subscript Small Letter L \\
\hline
U+02098 & ₘ & {\textbackslash}\_m & Latin Subscript Small Letter M \\
\hline
U+02099 & ₙ & {\textbackslash}\_n & Latin Subscript Small Letter N \\
\hline
U+0209A & ₚ & {\textbackslash}\_p & Latin Subscript Small Letter P \\
\hline
U+0209B & ₛ & {\textbackslash}\_s & Latin Subscript Small Letter S \\
\hline
U+0209C & ₜ & {\textbackslash}\_t & Latin Subscript Small Letter T \\
\hline
U+020A7 & ₧ & {\textbackslash}Elzpes & Peseta Sign \\
\hline
U+020AC & € & {\textbackslash}euro & Euro Sign \\
\hline
U+020D0 & ◌⃐ & {\textbackslash}leftharpoonaccent & Combining Left Harpoon Above / Non-spacing Left Harpoon Above \\
\hline
U+020D1 & ◌⃑ & {\textbackslash}rightharpoonaccent & Combining Right Harpoon Above / Non-spacing Right Harpoon Above \\
\hline
U+020D2 & ◌⃒ & {\textbackslash}vertoverlay & Combining Long Vertical Line Overlay / Non-spacing Long Vertical Bar Overlay \\
\hline
U+020D6 & ◌⃖ & {\textbackslash}overleftarrow & Combining Left Arrow Above / Non-spacing Left Arrow Above \\
\hline
U+020D7 & ◌⃗ & {\textbackslash}vec & Combining Right Arrow Above / Non-spacing Right Arrow Above \\
\hline
U+020DB & ◌⃛ & {\textbackslash}dddot & Combining Three Dots Above / Non-spacing Three Dots Above \\
\hline
U+020DC & ◌⃜ & {\textbackslash}ddddot & Combining Four Dots Above / Non-spacing Four Dots Above \\
\hline
U+020DD & ◌⃝ & {\textbackslash}enclosecircle & Combining Enclosing Circle / Enclosing Circle \\
\hline
U+020DE & ◌⃞ & {\textbackslash}enclosesquare & Combining Enclosing Square / Enclosing Square \\
\hline
U+020DF & ◌⃟ & {\textbackslash}enclosediamond & Combining Enclosing Diamond / Enclosing Diamond \\
\hline
U+020E1 & ◌⃡ & {\textbackslash}overleftrightarrow & Combining Left Right Arrow Above / Non-spacing Left Right Arrow Above \\
\hline
U+020E4 & ◌⃤ & {\textbackslash}enclosetriangle & Combining Enclosing Upward Pointing Triangle \\
\hline
U+020E7 & ◌⃧ & {\textbackslash}annuity & Combining Annuity Symbol \\
\hline
U+020E8 & ◌⃨ & {\textbackslash}threeunderdot & Combining Triple Underdot \\
\hline
U+020E9 & ◌⃩ & {\textbackslash}widebridgeabove & Combining Wide Bridge Above \\
\hline
U+020EC & ◌⃬ & {\textbackslash}underrightharpoondown & Combining Rightwards Harpoon With Barb Downwards \\
\hline
U+020ED & ◌⃭ & {\textbackslash}underleftharpoondown & Combining Leftwards Harpoon With Barb Downwards \\
\hline
U+020EE & ◌⃮ & {\textbackslash}underleftarrow & Combining Left Arrow Below \\
\hline
U+020EF & ◌⃯ & {\textbackslash}underrightarrow & Combining Right Arrow Below \\
\hline
U+020F0 & ◌⃰ & {\textbackslash}asteraccent & Combining Asterisk Above \\
\hline
U+02102 & ℂ & {\textbackslash}BbbC & Double-struck Capital C / Double-struck C \\
\hline
U+02107 & ℇ & {\textbackslash}Eulerconst & Euler Constant / Eulers \\
\hline
U+0210A & ℊ & {\textbackslash}mscrg & Script Small G \\
\hline
U+0210B & ℋ & {\textbackslash}mscrH & Script Capital H / Script H \\
\hline
U+0210C & ℌ & {\textbackslash}mfrakH & Black-letter Capital H / Black-letter H \\
\hline
U+0210D & ℍ & {\textbackslash}BbbH & Double-struck Capital H / Double-struck H \\
\hline
U+0210E & ℎ & {\textbackslash}Planckconst & Planck Constant \\
\hline
U+0210F & ℏ & {\textbackslash}hslash & Planck Constant Over Two Pi / Planck Constant Over 2 Pi \\
\hline
U+02110 & ℐ & {\textbackslash}mscrI & Script Capital I / Script I \\
\hline
U+02111 & ℑ & {\textbackslash}Im & Black-letter Capital I / Black-letter I \\
\hline
U+02112 & ℒ & {\textbackslash}mscrL & Script Capital L / Script L \\
\hline
U+02113 & ℓ & {\textbackslash}ell & Script Small L \\
\hline
U+02115 & ℕ & {\textbackslash}BbbN & Double-struck Capital N / Double-struck N \\
\hline
U+02116 & № & {\textbackslash}textnumero & Numero Sign / Numero \\
\hline
U+02118 & ℘ & {\textbackslash}wp & Script Capital P / Script P \\
\hline
U+02119 & ℙ & {\textbackslash}BbbP & Double-struck Capital P / Double-struck P \\
\hline
U+0211A & ℚ & {\textbackslash}BbbQ & Double-struck Capital Q / Double-struck Q \\
\hline
U+0211B & ℛ & {\textbackslash}mscrR & Script Capital R / Script R \\
\hline
U+0211C & ℜ & {\textbackslash}Re & Black-letter Capital R / Black-letter R \\
\hline
U+0211D & ℝ & {\textbackslash}BbbR & Double-struck Capital R / Double-struck R \\
\hline
U+0211E & ℞ & {\textbackslash}Elzxrat & Prescription Take \\
\hline
U+02122 & ™ & {\textbackslash}texttrademark, {\textbackslash}:tm: & Trade Mark Sign / Trademark \\
\hline
U+02124 & ℤ & {\textbackslash}BbbZ & Double-struck Capital Z / Double-struck Z \\
\hline
U+02127 & ℧ & {\textbackslash}mho & Inverted Ohm Sign / Mho \\
\hline
U+02128 & ℨ & {\textbackslash}mfrakZ & Black-letter Capital Z / Black-letter Z \\
\hline
U+02129 & ℩ & {\textbackslash}turnediota & Turned Greek Small Letter Iota \\
\hline
U+0212B & Å & {\textbackslash}Angstrom & Angstrom Sign / Angstrom Unit \\
\hline
U+0212C & ℬ & {\textbackslash}mscrB & Script Capital B / Script B \\
\hline
U+0212D & ℭ & {\textbackslash}mfrakC & Black-letter Capital C / Black-letter C \\
\hline
U+0212F & ℯ & {\textbackslash}mscre & Script Small E \\
\hline
U+02130 & ℰ & {\textbackslash}mscrE & Script Capital E / Script E \\
\hline
U+02131 & ℱ & {\textbackslash}mscrF & Script Capital F / Script F \\
\hline
U+02132 & Ⅎ & {\textbackslash}Finv & Turned Capital F / Turned F \\
\hline
U+02133 & ℳ & {\textbackslash}mscrM & Script Capital M / Script M \\
\hline
U+02134 & ℴ & {\textbackslash}mscro & Script Small O \\
\hline
U+02135 & ℵ & {\textbackslash}aleph & Alef Symbol / First Transfinite Cardinal \\
\hline
U+02136 & ℶ & {\textbackslash}beth & Bet Symbol / Second Transfinite Cardinal \\
\hline
U+02137 & ℷ & {\textbackslash}gimel & Gimel Symbol / Third Transfinite Cardinal \\
\hline
U+02138 & ℸ & {\textbackslash}daleth & Dalet Symbol / Fourth Transfinite Cardinal \\
\hline
U+02139 & ℹ & {\textbackslash}:information\_source: & Information Source \\
\hline
U+0213C & ℼ & {\textbackslash}Bbbpi & Double-struck Small Pi \\
\hline
U+0213D & ℽ & {\textbackslash}Bbbgamma & Double-struck Small Gamma \\
\hline
U+0213E & ℾ & {\textbackslash}BbbGamma & Double-struck Capital Gamma \\
\hline
U+0213F & ℿ & {\textbackslash}BbbPi & Double-struck Capital Pi \\
\hline
U+02140 & ⅀ & {\textbackslash}bbsum & Double-struck N-ary Summation \\
\hline
U+02141 & ⅁ & {\textbackslash}Game & Turned Sans-serif Capital G \\
\hline
U+02142 & ⅂ & {\textbackslash}sansLturned & Turned Sans-serif Capital L \\
\hline
U+02143 & ⅃ & {\textbackslash}sansLmirrored & Reversed Sans-serif Capital L \\
\hline
U+02144 & ⅄ & {\textbackslash}Yup & Turned Sans-serif Capital Y \\
\hline
U+02145 & ⅅ & {\textbackslash}mitBbbD & Double-struck Italic Capital D \\
\hline
U+02146 & ⅆ & {\textbackslash}mitBbbd & Double-struck Italic Small D \\
\hline
U+02147 & ⅇ & {\textbackslash}mitBbbe & Double-struck Italic Small E \\
\hline
U+02148 & ⅈ & {\textbackslash}mitBbbi & Double-struck Italic Small I \\
\hline
U+02149 & ⅉ & {\textbackslash}mitBbbj & Double-struck Italic Small J \\
\hline
U+0214A & ⅊ & {\textbackslash}PropertyLine & Property Line \\
\hline
U+0214B & ⅋ & {\textbackslash}upand & Turned Ampersand \\
\hline
U+02190 & ← & {\textbackslash}leftarrow & Leftwards Arrow / Left Arrow \\
\hline
U+02191 & ↑ & {\textbackslash}uparrow & Upwards Arrow / Up Arrow \\
\hline
U+02192 & → & {\textbackslash}to, {\textbackslash}rightarrow & Rightwards Arrow / Right Arrow \\
\hline
U+02193 & ↓ & {\textbackslash}downarrow & Downwards Arrow / Down Arrow \\
\hline
U+02194 & ↔ & {\textbackslash}leftrightarrow, {\textbackslash}:left\_right\_arrow: & Left Right Arrow \\
\hline
U+02195 & ↕ & {\textbackslash}updownarrow, {\textbackslash}:arrow\_up\_down: & Up Down Arrow \\
\hline
U+02196 & ↖ & {\textbackslash}nwarrow, {\textbackslash}:arrow\_upper\_left: & North West Arrow / Upper Left Arrow \\
\hline
U+02197 & ↗ & {\textbackslash}nearrow, {\textbackslash}:arrow\_upper\_right: & North East Arrow / Upper Right Arrow \\
\hline
U+02198 & ↘ & {\textbackslash}searrow, {\textbackslash}:arrow\_lower\_right: & South East Arrow / Lower Right Arrow \\
\hline
U+02199 & ↙ & {\textbackslash}swarrow, {\textbackslash}:arrow\_lower\_left: & South West Arrow / Lower Left Arrow \\
\hline
U+0219A & ↚ & {\textbackslash}nleftarrow & Leftwards Arrow With Stroke / Left Arrow With Stroke \\
\hline
U+0219B & ↛ & {\textbackslash}nrightarrow & Rightwards Arrow With Stroke / Right Arrow With Stroke \\
\hline
U+0219C & ↜ & {\textbackslash}leftwavearrow & Leftwards Wave Arrow / Left Wave Arrow \\
\hline
U+0219D & ↝ & {\textbackslash}rightwavearrow & Rightwards Wave Arrow / Right Wave Arrow \\
\hline
U+0219E & ↞ & {\textbackslash}twoheadleftarrow & Leftwards Two Headed Arrow / Left Two Headed Arrow \\
\hline
U+0219F & ↟ & {\textbackslash}twoheaduparrow & Upwards Two Headed Arrow / Up Two Headed Arrow \\
\hline
U+021A0 & ↠ & {\textbackslash}twoheadrightarrow & Rightwards Two Headed Arrow / Right Two Headed Arrow \\
\hline
U+021A1 & ↡ & {\textbackslash}twoheaddownarrow & Downwards Two Headed Arrow / Down Two Headed Arrow \\
\hline
U+021A2 & ↢ & {\textbackslash}leftarrowtail & Leftwards Arrow With Tail / Left Arrow With Tail \\
\hline
U+021A3 & ↣ & {\textbackslash}rightarrowtail & Rightwards Arrow With Tail / Right Arrow With Tail \\
\hline
U+021A4 & ↤ & {\textbackslash}mapsfrom & Leftwards Arrow From Bar / Left Arrow From Bar \\
\hline
U+021A5 & ↥ & {\textbackslash}mapsup & Upwards Arrow From Bar / Up Arrow From Bar \\
\hline
U+021A6 & ↦ & {\textbackslash}mapsto & Rightwards Arrow From Bar / Right Arrow From Bar \\
\hline
U+021A7 & ↧ & {\textbackslash}mapsdown & Downwards Arrow From Bar / Down Arrow From Bar \\
\hline
U+021A8 & ↨ & {\textbackslash}updownarrowbar & Up Down Arrow With Base \\
\hline
U+021A9 & ↩ & {\textbackslash}hookleftarrow, {\textbackslash}:leftwards\_arrow\_with\_hook: & Leftwards Arrow With Hook / Left Arrow With Hook \\
\hline
U+021AA & ↪ & {\textbackslash}hookrightarrow, {\textbackslash}:arrow\_right\_hook: & Rightwards Arrow With Hook / Right Arrow With Hook \\
\hline
U+021AB & ↫ & {\textbackslash}looparrowleft & Leftwards Arrow With Loop / Left Arrow With Loop \\
\hline
U+021AC & ↬ & {\textbackslash}looparrowright & Rightwards Arrow With Loop / Right Arrow With Loop \\
\hline
U+021AD & ↭ & {\textbackslash}leftrightsquigarrow & Left Right Wave Arrow \\
\hline
U+021AE & ↮ & {\textbackslash}nleftrightarrow & Left Right Arrow With Stroke \\
\hline
U+021AF & ↯ & {\textbackslash}downzigzagarrow & Downwards Zigzag Arrow / Down Zigzag Arrow \\
\hline
U+021B0 & ↰ & {\textbackslash}Lsh & Upwards Arrow With Tip Leftwards / Up Arrow With Tip Left \\
\hline
U+021B1 & ↱ & {\textbackslash}Rsh & Upwards Arrow With Tip Rightwards / Up Arrow With Tip Right \\
\hline
U+021B2 & ↲ & {\textbackslash}Ldsh & Downwards Arrow With Tip Leftwards / Down Arrow With Tip Left \\
\hline
U+021B3 & ↳ & {\textbackslash}Rdsh & Downwards Arrow With Tip Rightwards / Down Arrow With Tip Right \\
\hline
U+021B4 & ↴ & {\textbackslash}linefeed & Rightwards Arrow With Corner Downwards / Right Arrow With Corner Down \\
\hline
U+021B5 & ↵ & {\textbackslash}carriagereturn & Downwards Arrow With Corner Leftwards / Down Arrow With Corner Left \\
\hline
U+021B6 & ↶ & {\textbackslash}curvearrowleft & Anticlockwise Top Semicircle Arrow \\
\hline
U+021B7 & ↷ & {\textbackslash}curvearrowright & Clockwise Top Semicircle Arrow \\
\hline
U+021B8 & ↸ & {\textbackslash}barovernorthwestarrow & North West Arrow To Long Bar / Upper Left Arrow To Long Bar \\
\hline
U+021B9 & ↹ & {\textbackslash}barleftarrowrightarrowbar & Leftwards Arrow To Bar Over Rightwards Arrow To Bar / Left Arrow To Bar Over Right Arrow To Bar \\
\hline
U+021BA & ↺ & {\textbackslash}circlearrowleft & Anticlockwise Open Circle Arrow \\
\hline
U+021BB & ↻ & {\textbackslash}circlearrowright & Clockwise Open Circle Arrow \\
\hline
U+021BC & ↼ & {\textbackslash}leftharpoonup & Leftwards Harpoon With Barb Upwards / Left Harpoon With Barb Up \\
\hline
U+021BD & ↽ & {\textbackslash}leftharpoondown & Leftwards Harpoon With Barb Downwards / Left Harpoon With Barb Down \\
\hline
U+021BE & ↾ & {\textbackslash}upharpoonleft & Upwards Harpoon With Barb Rightwards / Up Harpoon With Barb Right \\
\hline
U+021BF & ↿ & {\textbackslash}upharpoonright & Upwards Harpoon With Barb Leftwards / Up Harpoon With Barb Left \\
\hline
U+021C0 & ⇀ & {\textbackslash}rightharpoonup & Rightwards Harpoon With Barb Upwards / Right Harpoon With Barb Up \\
\hline
U+021C1 & ⇁ & {\textbackslash}rightharpoondown & Rightwards Harpoon With Barb Downwards / Right Harpoon With Barb Down \\
\hline
U+021C2 & ⇂ & {\textbackslash}downharpoonright & Downwards Harpoon With Barb Rightwards / Down Harpoon With Barb Right \\
\hline
U+021C3 & ⇃ & {\textbackslash}downharpoonleft & Downwards Harpoon With Barb Leftwards / Down Harpoon With Barb Left \\
\hline
U+021C4 & ⇄ & {\textbackslash}rightleftarrows & Rightwards Arrow Over Leftwards Arrow / Right Arrow Over Left Arrow \\
\hline
U+021C5 & ⇅ & {\textbackslash}dblarrowupdown & Upwards Arrow Leftwards Of Downwards Arrow / Up Arrow Left Of Down Arrow \\
\hline
U+021C6 & ⇆ & {\textbackslash}leftrightarrows & Leftwards Arrow Over Rightwards Arrow / Left Arrow Over Right Arrow \\
\hline
U+021C7 & ⇇ & {\textbackslash}leftleftarrows & Leftwards Paired Arrows / Left Paired Arrows \\
\hline
U+021C8 & ⇈ & {\textbackslash}upuparrows & Upwards Paired Arrows / Up Paired Arrows \\
\hline
U+021C9 & ⇉ & {\textbackslash}rightrightarrows & Rightwards Paired Arrows / Right Paired Arrows \\
\hline
U+021CA & ⇊ & {\textbackslash}downdownarrows & Downwards Paired Arrows / Down Paired Arrows \\
\hline
U+021CB & ⇋ & {\textbackslash}leftrightharpoons & Leftwards Harpoon Over Rightwards Harpoon / Left Harpoon Over Right Harpoon \\
\hline
U+021CC & ⇌ & {\textbackslash}rightleftharpoons & Rightwards Harpoon Over Leftwards Harpoon / Right Harpoon Over Left Harpoon \\
\hline
U+021CD & ⇍ & {\textbackslash}nLeftarrow & Leftwards Double Arrow With Stroke / Left Double Arrow With Stroke \\
\hline
U+021CE & ⇎ & {\textbackslash}nLeftrightarrow & Left Right Double Arrow With Stroke \\
\hline
U+021CF & ⇏ & {\textbackslash}nRightarrow & Rightwards Double Arrow With Stroke / Right Double Arrow With Stroke \\
\hline
U+021D0 & ⇐ & {\textbackslash}Leftarrow & Leftwards Double Arrow / Left Double Arrow \\
\hline
U+021D1 & ⇑ & {\textbackslash}Uparrow & Upwards Double Arrow / Up Double Arrow \\
\hline
U+021D2 & ⇒ & {\textbackslash}Rightarrow & Rightwards Double Arrow / Right Double Arrow \\
\hline
U+021D3 & ⇓ & {\textbackslash}Downarrow & Downwards Double Arrow / Down Double Arrow \\
\hline
U+021D4 & ⇔ & {\textbackslash}Leftrightarrow & Left Right Double Arrow \\
\hline
U+021D5 & ⇕ & {\textbackslash}Updownarrow & Up Down Double Arrow \\
\hline
U+021D6 & ⇖ & {\textbackslash}Nwarrow & North West Double Arrow / Upper Left Double Arrow \\
\hline
U+021D7 & ⇗ & {\textbackslash}Nearrow & North East Double Arrow / Upper Right Double Arrow \\
\hline
U+021D8 & ⇘ & {\textbackslash}Searrow & South East Double Arrow / Lower Right Double Arrow \\
\hline
U+021D9 & ⇙ & {\textbackslash}Swarrow & South West Double Arrow / Lower Left Double Arrow \\
\hline
U+021DA & ⇚ & {\textbackslash}Lleftarrow & Leftwards Triple Arrow / Left Triple Arrow \\
\hline
U+021DB & ⇛ & {\textbackslash}Rrightarrow & Rightwards Triple Arrow / Right Triple Arrow \\
\hline
U+021DC & ⇜ & {\textbackslash}leftsquigarrow & Leftwards Squiggle Arrow / Left Squiggle Arrow \\
\hline
U+021DD & ⇝ & {\textbackslash}rightsquigarrow & Rightwards Squiggle Arrow / Right Squiggle Arrow \\
\hline
U+021DE & ⇞ & {\textbackslash}nHuparrow & Upwards Arrow With Double Stroke / Up Arrow With Double Stroke \\
\hline
U+021DF & ⇟ & {\textbackslash}nHdownarrow & Downwards Arrow With Double Stroke / Down Arrow With Double Stroke \\
\hline
U+021E0 & ⇠ & {\textbackslash}leftdasharrow & Leftwards Dashed Arrow / Left Dashed Arrow \\
\hline
U+021E1 & ⇡ & {\textbackslash}updasharrow & Upwards Dashed Arrow / Up Dashed Arrow \\
\hline
U+021E2 & ⇢ & {\textbackslash}rightdasharrow & Rightwards Dashed Arrow / Right Dashed Arrow \\
\hline
U+021E3 & ⇣ & {\textbackslash}downdasharrow & Downwards Dashed Arrow / Down Dashed Arrow \\
\hline
U+021E4 & ⇤ & {\textbackslash}barleftarrow & Leftwards Arrow To Bar / Left Arrow To Bar \\
\hline
U+021E5 & ⇥ & {\textbackslash}rightarrowbar & Rightwards Arrow To Bar / Right Arrow To Bar \\
\hline
U+021E6 & ⇦ & {\textbackslash}leftwhitearrow & Leftwards White Arrow / White Left Arrow \\
\hline
U+021E7 & ⇧ & {\textbackslash}upwhitearrow & Upwards White Arrow / White Up Arrow \\
\hline
U+021E8 & ⇨ & {\textbackslash}rightwhitearrow & Rightwards White Arrow / White Right Arrow \\
\hline
U+021E9 & ⇩ & {\textbackslash}downwhitearrow & Downwards White Arrow / White Down Arrow \\
\hline
U+021EA & ⇪ & {\textbackslash}whitearrowupfrombar & Upwards White Arrow From Bar / White Up Arrow From Bar \\
\hline
U+021F4 & ⇴ & {\textbackslash}circleonrightarrow & Right Arrow With Small Circle \\
\hline
U+021F5 & ⇵ & {\textbackslash}DownArrowUpArrow & Downwards Arrow Leftwards Of Upwards Arrow \\
\hline
U+021F6 & ⇶ & {\textbackslash}rightthreearrows & Three Rightwards Arrows \\
\hline
U+021F7 & ⇷ & {\textbackslash}nvleftarrow & Leftwards Arrow With Vertical Stroke \\
\hline
U+021F8 & ⇸ & {\textbackslash}nvrightarrow & Rightwards Arrow With Vertical Stroke \\
\hline
U+021F9 & ⇹ & {\textbackslash}nvleftrightarrow & Left Right Arrow With Vertical Stroke \\
\hline
U+021FA & ⇺ & {\textbackslash}nVleftarrow & Leftwards Arrow With Double Vertical Stroke \\
\hline
U+021FB & ⇻ & {\textbackslash}nVrightarrow & Rightwards Arrow With Double Vertical Stroke \\
\hline
U+021FC & ⇼ & {\textbackslash}nVleftrightarrow & Left Right Arrow With Double Vertical Stroke \\
\hline
U+021FD & ⇽ & {\textbackslash}leftarrowtriangle & Leftwards Open-headed Arrow \\
\hline
U+021FE & ⇾ & {\textbackslash}rightarrowtriangle & Rightwards Open-headed Arrow \\
\hline
U+021FF & ⇿ & {\textbackslash}leftrightarrowtriangle & Left Right Open-headed Arrow \\
\hline
U+02200 & ∀ & {\textbackslash}forall & For All \\
\hline
U+02201 & ∁ & {\textbackslash}complement & Complement \\
\hline
U+02202 & ∂ & {\textbackslash}partial & Partial Differential \\
\hline
U+02203 & ∃ & {\textbackslash}exists & There Exists \\
\hline
U+02204 & ∄ & {\textbackslash}nexists & There Does Not Exist \\
\hline
U+02205 & ∅ & {\textbackslash}varnothing, {\textbackslash}emptyset & Empty Set \\
\hline
U+02206 & ∆ & {\textbackslash}increment & Increment \\
\hline
U+02207 & ∇ & {\textbackslash}del, {\textbackslash}nabla & Nabla \\
\hline
U+02208 & ∈ & {\textbackslash}in & Element Of \\
\hline
U+02209 & ∉ & {\textbackslash}notin & Not An Element Of \\
\hline
U+0220A & ∊ & {\textbackslash}smallin & Small Element Of \\
\hline
U+0220B & ∋ & {\textbackslash}ni & Contains As Member \\
\hline
U+0220C & ∌ & {\textbackslash}nni & Does Not Contain As Member \\
\hline
U+0220D & ∍ & {\textbackslash}smallni & Small Contains As Member \\
\hline
U+0220E & ∎ & {\textbackslash}QED & End Of Proof \\
\hline
U+0220F & ∏ & {\textbackslash}prod & N-ary Product \\
\hline
U+02210 & ∐ & {\textbackslash}coprod & N-ary Coproduct \\
\hline
U+02211 & ∑ & {\textbackslash}sum & N-ary Summation \\
\hline
U+02212 & − & {\textbackslash}minus & Minus Sign \\
\hline
U+02213 & ∓ & {\textbackslash}mp & Minus-or-plus Sign \\
\hline
U+02214 & ∔ & {\textbackslash}dotplus & Dot Plus \\
\hline
U+02216 & ∖ & {\textbackslash}setminus & Set Minus \\
\hline
U+02217 & ∗ & {\textbackslash}ast & Asterisk Operator \\
\hline
U+02218 & ∘ & {\textbackslash}circ & Ring Operator \\
\hline
U+02219 & ∙ & {\textbackslash}vysmblkcircle & Bullet Operator \\
\hline
U+0221A & √ & {\textbackslash}surd, {\textbackslash}sqrt & Square Root \\
\hline
U+0221B & ∛ & {\textbackslash}cbrt & Cube Root \\
\hline
U+0221C & ∜ & {\textbackslash}fourthroot & Fourth Root \\
\hline
U+0221D & ∝ & {\textbackslash}propto & Proportional To \\
\hline
U+0221E & ∞ & {\textbackslash}infty & Infinity \\
\hline
U+0221F & ∟ & {\textbackslash}rightangle & Right Angle \\
\hline
U+02220 & ∠ & {\textbackslash}angle & Angle \\
\hline
U+02221 & ∡ & {\textbackslash}measuredangle & Measured Angle \\
\hline
U+02222 & ∢ & {\textbackslash}sphericalangle & Spherical Angle \\
\hline
U+02223 & ∣ & {\textbackslash}mid & Divides \\
\hline
U+02224 & ∤ & {\textbackslash}nmid & Does Not Divide \\
\hline
U+02225 & ∥ & {\textbackslash}parallel & Parallel To \\
\hline
U+02226 & ∦ & {\textbackslash}nparallel & Not Parallel To \\
\hline
U+02227 & ∧ & {\textbackslash}wedge & Logical And \\
\hline
U+02228 & ∨ & {\textbackslash}vee & Logical Or \\
\hline
U+02229 & ∩ & {\textbackslash}cap & Intersection \\
\hline
U+0222A & ∪ & {\textbackslash}cup & Union \\
\hline
U+0222B & ∫ & {\textbackslash}int & Integral \\
\hline
U+0222C & ∬ & {\textbackslash}iint & Double Integral \\
\hline
U+0222D & ∭ & {\textbackslash}iiint & Triple Integral \\
\hline
U+0222E & ∮ & {\textbackslash}oint & Contour Integral \\
\hline
U+0222F & ∯ & {\textbackslash}oiint & Surface Integral \\
\hline
U+02230 & ∰ & {\textbackslash}oiiint & Volume Integral \\
\hline
U+02231 & ∱ & {\textbackslash}clwintegral & Clockwise Integral \\
\hline
U+02232 & ∲ & {\textbackslash}varointclockwise & Clockwise Contour Integral \\
\hline
U+02233 & ∳ & {\textbackslash}ointctrclockwise & Anticlockwise Contour Integral \\
\hline
U+02234 & ∴ & {\textbackslash}therefore & Therefore \\
\hline
U+02235 & ∵ & {\textbackslash}because & Because \\
\hline
U+02237 & ∷ & {\textbackslash}Colon & Proportion \\
\hline
U+02238 & ∸ & {\textbackslash}dotminus & Dot Minus \\
\hline
U+0223A & ∺ & {\textbackslash}dotsminusdots & Geometric Proportion \\
\hline
U+0223B & ∻ & {\textbackslash}kernelcontraction & Homothetic \\
\hline
U+0223C & ∼ & {\textbackslash}sim & Tilde Operator \\
\hline
U+0223D & ∽ & {\textbackslash}backsim & Reversed Tilde \\
\hline
U+0223E & ∾ & {\textbackslash}lazysinv & Inverted Lazy S \\
\hline
U+0223F & ∿ & {\textbackslash}sinewave & Sine Wave \\
\hline
U+02240 & ≀ & {\textbackslash}wr & Wreath Product \\
\hline
U+02241 & ≁ & {\textbackslash}nsim & Not Tilde \\
\hline
U+02242 & ≂ & {\textbackslash}eqsim & Minus Tilde \\
\hline
U+02242 + U+00338 & ≂̸ & {\textbackslash}neqsim & Minus Tilde + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02243 & ≃ & {\textbackslash}simeq & Asymptotically Equal To \\
\hline
U+02244 & ≄ & {\textbackslash}nsime & Not Asymptotically Equal To \\
\hline
U+02245 & ≅ & {\textbackslash}cong & Approximately Equal To \\
\hline
U+02246 & ≆ & {\textbackslash}approxnotequal & Approximately But Not Actually Equal To \\
\hline
U+02247 & ≇ & {\textbackslash}ncong & Neither Approximately Nor Actually Equal To \\
\hline
U+02248 & ≈ & {\textbackslash}approx & Almost Equal To \\
\hline
U+02249 & ≉ & {\textbackslash}napprox & Not Almost Equal To \\
\hline
U+0224A & ≊ & {\textbackslash}approxeq & Almost Equal Or Equal To \\
\hline
U+0224B & ≋ & {\textbackslash}tildetrpl & Triple Tilde \\
\hline
U+0224C & ≌ & {\textbackslash}allequal & All Equal To \\
\hline
U+0224D & ≍ & {\textbackslash}asymp & Equivalent To \\
\hline
U+0224E & ≎ & {\textbackslash}Bumpeq & Geometrically Equivalent To \\
\hline
U+0224E + U+00338 & ≎̸ & {\textbackslash}nBumpeq & Geometrically Equivalent To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0224F & ≏ & {\textbackslash}bumpeq & Difference Between \\
\hline
U+0224F + U+00338 & ≏̸ & {\textbackslash}nbumpeq & Difference Between + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02250 & ≐ & {\textbackslash}doteq & Approaches The Limit \\
\hline
U+02251 & ≑ & {\textbackslash}Doteq & Geometrically Equal To \\
\hline
U+02252 & ≒ & {\textbackslash}fallingdotseq & Approximately Equal To Or The Image Of \\
\hline
U+02253 & ≓ & {\textbackslash}risingdotseq & Image Of Or Approximately Equal To \\
\hline
U+02254 & ≔ & {\textbackslash}coloneq & Colon Equals / Colon Equal \\
\hline
U+02255 & ≕ & {\textbackslash}eqcolon & Equals Colon / Equal Colon \\
\hline
U+02256 & ≖ & {\textbackslash}eqcirc & Ring In Equal To \\
\hline
U+02257 & ≗ & {\textbackslash}circeq & Ring Equal To \\
\hline
U+02258 & ≘ & {\textbackslash}arceq & Corresponds To \\
\hline
U+02259 & ≙ & {\textbackslash}wedgeq & Estimates \\
\hline
U+0225A & ≚ & {\textbackslash}veeeq & Equiangular To \\
\hline
U+0225B & ≛ & {\textbackslash}starequal & Star Equals \\
\hline
U+0225C & ≜ & {\textbackslash}triangleq & Delta Equal To \\
\hline
U+0225D & ≝ & {\textbackslash}eqdef & Equal To By Definition \\
\hline
U+0225E & ≞ & {\textbackslash}measeq & Measured By \\
\hline
U+0225F & ≟ & {\textbackslash}questeq & Questioned Equal To \\
\hline
U+02260 & ≠ & {\textbackslash}ne & Not Equal To \\
\hline
U+02261 & ≡ & {\textbackslash}equiv & Identical To \\
\hline
U+02262 & ≢ & {\textbackslash}nequiv & Not Identical To \\
\hline
U+02263 & ≣ & {\textbackslash}Equiv & Strictly Equivalent To \\
\hline
U+02264 & ≤ & {\textbackslash}le & Less-than Or Equal To / Less Than Or Equal To \\
\hline
U+02265 & ≥ & {\textbackslash}ge & Greater-than Or Equal To / Greater Than Or Equal To \\
\hline
U+02266 & ≦ & {\textbackslash}leqq & Less-than Over Equal To / Less Than Over Equal To \\
\hline
U+02267 & ≧ & {\textbackslash}geqq & Greater-than Over Equal To / Greater Than Over Equal To \\
\hline
U+02268 & ≨ & {\textbackslash}lneqq & Less-than But Not Equal To / Less Than But Not Equal To \\
\hline
U+02268 + U+0FE00 & ≨︀ & {\textbackslash}lvertneqq & Less-than But Not Equal To / Less Than But Not Equal To + Variation Selector-1 \\
\hline
U+02269 & ≩ & {\textbackslash}gneqq & Greater-than But Not Equal To / Greater Than But Not Equal To \\
\hline
U+02269 + U+0FE00 & ≩︀ & {\textbackslash}gvertneqq & Greater-than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1 \\
\hline
U+0226A & ≪ & {\textbackslash}ll & Much Less-than / Much Less Than \\
\hline
U+0226A + U+00338 & ≪̸ & {\textbackslash}NotLessLess & Much Less-than / Much Less Than + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0226B & ≫ & {\textbackslash}gg & Much Greater-than / Much Greater Than \\
\hline
U+0226B + U+00338 & ≫̸ & {\textbackslash}NotGreaterGreater & Much Greater-than / Much Greater Than + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0226C & ≬ & {\textbackslash}between & Between \\
\hline
U+0226D & ≭ & {\textbackslash}nasymp & Not Equivalent To \\
\hline
U+0226E & ≮ & {\textbackslash}nless & Not Less-than / Not Less Than \\
\hline
U+0226F & ≯ & {\textbackslash}ngtr & Not Greater-than / Not Greater Than \\
\hline
U+02270 & ≰ & {\textbackslash}nleq & Neither Less-than Nor Equal To / Neither Less Than Nor Equal To \\
\hline
U+02271 & ≱ & {\textbackslash}ngeq & Neither Greater-than Nor Equal To / Neither Greater Than Nor Equal To \\
\hline
U+02272 & ≲ & {\textbackslash}lesssim & Less-than Or Equivalent To / Less Than Or Equivalent To \\
\hline
U+02273 & ≳ & {\textbackslash}gtrsim & Greater-than Or Equivalent To / Greater Than Or Equivalent To \\
\hline
U+02274 & ≴ & {\textbackslash}nlesssim & Neither Less-than Nor Equivalent To / Neither Less Than Nor Equivalent To \\
\hline
U+02275 & ≵ & {\textbackslash}ngtrsim & Neither Greater-than Nor Equivalent To / Neither Greater Than Nor Equivalent To \\
\hline
U+02276 & ≶ & {\textbackslash}lessgtr & Less-than Or Greater-than / Less Than Or Greater Than \\
\hline
U+02277 & ≷ & {\textbackslash}gtrless & Greater-than Or Less-than / Greater Than Or Less Than \\
\hline
U+02278 & ≸ & {\textbackslash}notlessgreater & Neither Less-than Nor Greater-than / Neither Less Than Nor Greater Than \\
\hline
U+02279 & ≹ & {\textbackslash}notgreaterless & Neither Greater-than Nor Less-than / Neither Greater Than Nor Less Than \\
\hline
U+0227A & ≺ & {\textbackslash}prec & Precedes \\
\hline
U+0227B & ≻ & {\textbackslash}succ & Succeeds \\
\hline
U+0227C & ≼ & {\textbackslash}preccurlyeq & Precedes Or Equal To \\
\hline
U+0227D & ≽ & {\textbackslash}succcurlyeq & Succeeds Or Equal To \\
\hline
U+0227E & ≾ & {\textbackslash}precsim & Precedes Or Equivalent To \\
\hline
U+0227E + U+00338 & ≾̸ & {\textbackslash}nprecsim & Precedes Or Equivalent To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+0227F & ≿ & {\textbackslash}succsim & Succeeds Or Equivalent To \\
\hline
U+0227F + U+00338 & ≿̸ & {\textbackslash}nsuccsim & Succeeds Or Equivalent To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02280 & ⊀ & {\textbackslash}nprec & Does Not Precede \\
\hline
U+02281 & ⊁ & {\textbackslash}nsucc & Does Not Succeed \\
\hline
U+02282 & ⊂ & {\textbackslash}subset & Subset Of \\
\hline
U+02283 & ⊃ & {\textbackslash}supset & Superset Of \\
\hline
U+02284 & ⊄ & {\textbackslash}nsubset & Not A Subset Of \\
\hline
U+02285 & ⊅ & {\textbackslash}nsupset & Not A Superset Of \\
\hline
U+02286 & ⊆ & {\textbackslash}subseteq & Subset Of Or Equal To \\
\hline
U+02287 & ⊇ & {\textbackslash}supseteq & Superset Of Or Equal To \\
\hline
U+02288 & ⊈ & {\textbackslash}nsubseteq & Neither A Subset Of Nor Equal To \\
\hline
U+02289 & ⊉ & {\textbackslash}nsupseteq & Neither A Superset Of Nor Equal To \\
\hline
U+0228A & ⊊ & {\textbackslash}subsetneq & Subset Of With Not Equal To / Subset Of Or Not Equal To \\
\hline
U+0228A + U+0FE00 & ⊊︀ & {\textbackslash}varsubsetneqq & Subset Of With Not Equal To / Subset Of Or Not Equal To + Variation Selector-1 \\
\hline
U+0228B & ⊋ & {\textbackslash}supsetneq & Superset Of With Not Equal To / Superset Of Or Not Equal To \\
\hline
U+0228B + U+0FE00 & ⊋︀ & {\textbackslash}varsupsetneq & Superset Of With Not Equal To / Superset Of Or Not Equal To + Variation Selector-1 \\
\hline
U+0228D & ⊍ & {\textbackslash}cupdot & Multiset Multiplication \\
\hline
U+0228E & ⊎ & {\textbackslash}uplus & Multiset Union \\
\hline
U+0228F & ⊏ & {\textbackslash}sqsubset & Square Image Of \\
\hline
U+0228F + U+00338 & ⊏̸ & {\textbackslash}NotSquareSubset & Square Image Of + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02290 & ⊐ & {\textbackslash}sqsupset & Square Original Of \\
\hline
U+02290 + U+00338 & ⊐̸ & {\textbackslash}NotSquareSuperset & Square Original Of + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02291 & ⊑ & {\textbackslash}sqsubseteq & Square Image Of Or Equal To \\
\hline
U+02292 & ⊒ & {\textbackslash}sqsupseteq & Square Original Of Or Equal To \\
\hline
U+02293 & ⊓ & {\textbackslash}sqcap & Square Cap \\
\hline
U+02294 & ⊔ & {\textbackslash}sqcup & Square Cup \\
\hline
U+02295 & ⊕ & {\textbackslash}oplus & Circled Plus \\
\hline
U+02296 & ⊖ & {\textbackslash}ominus & Circled Minus \\
\hline
U+02297 & ⊗ & {\textbackslash}otimes & Circled Times \\
\hline
U+02298 & ⊘ & {\textbackslash}oslash & Circled Division Slash \\
\hline
U+02299 & ⊙ & {\textbackslash}odot & Circled Dot Operator \\
\hline
U+0229A & ⊚ & {\textbackslash}circledcirc & Circled Ring Operator \\
\hline
U+0229B & ⊛ & {\textbackslash}circledast & Circled Asterisk Operator \\
\hline
U+0229C & ⊜ & {\textbackslash}circledequal & Circled Equals \\
\hline
U+0229D & ⊝ & {\textbackslash}circleddash & Circled Dash \\
\hline
U+0229E & ⊞ & {\textbackslash}boxplus & Squared Plus \\
\hline
U+0229F & ⊟ & {\textbackslash}boxminus & Squared Minus \\
\hline
U+022A0 & ⊠ & {\textbackslash}boxtimes & Squared Times \\
\hline
U+022A1 & ⊡ & {\textbackslash}boxdot & Squared Dot Operator \\
\hline
U+022A2 & ⊢ & {\textbackslash}vdash & Right Tack \\
\hline
U+022A3 & ⊣ & {\textbackslash}dashv & Left Tack \\
\hline
U+022A4 & ⊤ & {\textbackslash}top & Down Tack \\
\hline
U+022A5 & ⊥ & {\textbackslash}bot & Up Tack \\
\hline
U+022A7 & ⊧ & {\textbackslash}models & Models \\
\hline
U+022A8 & ⊨ & {\textbackslash}vDash & True \\
\hline
U+022A9 & ⊩ & {\textbackslash}Vdash & Forces \\
\hline
U+022AA & ⊪ & {\textbackslash}Vvdash & Triple Vertical Bar Right Turnstile \\
\hline
U+022AB & ⊫ & {\textbackslash}VDash & Double Vertical Bar Double Right Turnstile \\
\hline
U+022AC & ⊬ & {\textbackslash}nvdash & Does Not Prove \\
\hline
U+022AD & ⊭ & {\textbackslash}nvDash & Not True \\
\hline
U+022AE & ⊮ & {\textbackslash}nVdash & Does Not Force \\
\hline
U+022AF & ⊯ & {\textbackslash}nVDash & Negated Double Vertical Bar Double Right Turnstile \\
\hline
U+022B0 & ⊰ & {\textbackslash}prurel & Precedes Under Relation \\
\hline
U+022B1 & ⊱ & {\textbackslash}scurel & Succeeds Under Relation \\
\hline
U+022B2 & ⊲ & {\textbackslash}vartriangleleft & Normal Subgroup Of \\
\hline
U+022B3 & ⊳ & {\textbackslash}vartriangleright & Contains As Normal Subgroup \\
\hline
U+022B4 & ⊴ & {\textbackslash}trianglelefteq & Normal Subgroup Of Or Equal To \\
\hline
U+022B5 & ⊵ & {\textbackslash}trianglerighteq & Contains As Normal Subgroup Or Equal To \\
\hline
U+022B6 & ⊶ & {\textbackslash}original & Original Of \\
\hline
U+022B7 & ⊷ & {\textbackslash}image & Image Of \\
\hline
U+022B8 & ⊸ & {\textbackslash}multimap & Multimap \\
\hline
U+022B9 & ⊹ & {\textbackslash}hermitconjmatrix & Hermitian Conjugate Matrix \\
\hline
U+022BA & ⊺ & {\textbackslash}intercal & Intercalate \\
\hline
U+022BB & ⊻ & {\textbackslash}veebar, {\textbackslash}xor & Xor \\
\hline
U+022BC & ⊼ & {\textbackslash}barwedge & Nand \\
\hline
U+022BD & ⊽ & {\textbackslash}barvee & Nor \\
\hline
U+022BE & ⊾ & {\textbackslash}rightanglearc & Right Angle With Arc \\
\hline
U+022BF & ⊿ & {\textbackslash}varlrtriangle & Right Triangle \\
\hline
U+022C0 & ⋀ & {\textbackslash}bigwedge & N-ary Logical And \\
\hline
U+022C1 & ⋁ & {\textbackslash}bigvee & N-ary Logical Or \\
\hline
U+022C2 & ⋂ & {\textbackslash}bigcap & N-ary Intersection \\
\hline
U+022C3 & ⋃ & {\textbackslash}bigcup & N-ary Union \\
\hline
U+022C4 & ⋄ & {\textbackslash}diamond & Diamond Operator \\
\hline
U+022C5 & ⋅ & {\textbackslash}cdot & Dot Operator \\
\hline
U+022C6 & ⋆ & {\textbackslash}star & Star Operator \\
\hline
U+022C7 & ⋇ & {\textbackslash}divideontimes & Division Times \\
\hline
U+022C8 & ⋈ & {\textbackslash}bowtie & Bowtie \\
\hline
U+022C9 & ⋉ & {\textbackslash}ltimes & Left Normal Factor Semidirect Product \\
\hline
U+022CA & ⋊ & {\textbackslash}rtimes & Right Normal Factor Semidirect Product \\
\hline
U+022CB & ⋋ & {\textbackslash}leftthreetimes & Left Semidirect Product \\
\hline
U+022CC & ⋌ & {\textbackslash}rightthreetimes & Right Semidirect Product \\
\hline
U+022CD & ⋍ & {\textbackslash}backsimeq & Reversed Tilde Equals \\
\hline
U+022CE & ⋎ & {\textbackslash}curlyvee & Curly Logical Or \\
\hline
U+022CF & ⋏ & {\textbackslash}curlywedge & Curly Logical And \\
\hline
U+022D0 & ⋐ & {\textbackslash}Subset & Double Subset \\
\hline
U+022D1 & ⋑ & {\textbackslash}Supset & Double Superset \\
\hline
U+022D2 & ⋒ & {\textbackslash}Cap & Double Intersection \\
\hline
U+022D3 & ⋓ & {\textbackslash}Cup & Double Union \\
\hline
U+022D4 & ⋔ & {\textbackslash}pitchfork & Pitchfork \\
\hline
U+022D5 & ⋕ & {\textbackslash}equalparallel & Equal And Parallel To \\
\hline
U+022D6 & ⋖ & {\textbackslash}lessdot & Less-than With Dot / Less Than With Dot \\
\hline
U+022D7 & ⋗ & {\textbackslash}gtrdot & Greater-than With Dot / Greater Than With Dot \\
\hline
U+022D8 & ⋘ & {\textbackslash}verymuchless & Very Much Less-than / Very Much Less Than \\
\hline
U+022D9 & ⋙ & {\textbackslash}ggg & Very Much Greater-than / Very Much Greater Than \\
\hline
U+022DA & ⋚ & {\textbackslash}lesseqgtr & Less-than Equal To Or Greater-than / Less Than Equal To Or Greater Than \\
\hline
U+022DB & ⋛ & {\textbackslash}gtreqless & Greater-than Equal To Or Less-than / Greater Than Equal To Or Less Than \\
\hline
U+022DC & ⋜ & {\textbackslash}eqless & Equal To Or Less-than / Equal To Or Less Than \\
\hline
U+022DD & ⋝ & {\textbackslash}eqgtr & Equal To Or Greater-than / Equal To Or Greater Than \\
\hline
U+022DE & ⋞ & {\textbackslash}curlyeqprec & Equal To Or Precedes \\
\hline
U+022DF & ⋟ & {\textbackslash}curlyeqsucc & Equal To Or Succeeds \\
\hline
U+022E0 & ⋠ & {\textbackslash}npreccurlyeq & Does Not Precede Or Equal \\
\hline
U+022E1 & ⋡ & {\textbackslash}nsucccurlyeq & Does Not Succeed Or Equal \\
\hline
U+022E2 & ⋢ & {\textbackslash}nsqsubseteq & Not Square Image Of Or Equal To \\
\hline
U+022E3 & ⋣ & {\textbackslash}nsqsupseteq & Not Square Original Of Or Equal To \\
\hline
U+022E4 & ⋤ & {\textbackslash}sqsubsetneq & Square Image Of Or Not Equal To \\
\hline
U+022E5 & ⋥ & {\textbackslash}Elzsqspne & Square Original Of Or Not Equal To \\
\hline
U+022E6 & ⋦ & {\textbackslash}lnsim & Less-than But Not Equivalent To / Less Than But Not Equivalent To \\
\hline
U+022E7 & ⋧ & {\textbackslash}gnsim & Greater-than But Not Equivalent To / Greater Than But Not Equivalent To \\
\hline
U+022E8 & ⋨ & {\textbackslash}precnsim & Precedes But Not Equivalent To \\
\hline
U+022E9 & ⋩ & {\textbackslash}succnsim & Succeeds But Not Equivalent To \\
\hline
U+022EA & ⋪ & {\textbackslash}ntriangleleft & Not Normal Subgroup Of \\
\hline
U+022EB & ⋫ & {\textbackslash}ntriangleright & Does Not Contain As Normal Subgroup \\
\hline
U+022EC & ⋬ & {\textbackslash}ntrianglelefteq & Not Normal Subgroup Of Or Equal To \\
\hline
U+022ED & ⋭ & {\textbackslash}ntrianglerighteq & Does Not Contain As Normal Subgroup Or Equal \\
\hline
U+022EE & ⋮ & {\textbackslash}vdots & Vertical Ellipsis \\
\hline
U+022EF & ⋯ & {\textbackslash}cdots & Midline Horizontal Ellipsis \\
\hline
U+022F0 & ⋰ & {\textbackslash}adots & Up Right Diagonal Ellipsis \\
\hline
U+022F1 & ⋱ & {\textbackslash}ddots & Down Right Diagonal Ellipsis \\
\hline
U+022F2 & ⋲ & {\textbackslash}disin & Element Of With Long Horizontal Stroke \\
\hline
U+022F3 & ⋳ & {\textbackslash}varisins & Element Of With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022F4 & ⋴ & {\textbackslash}isins & Small Element Of With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022F5 & ⋵ & {\textbackslash}isindot & Element Of With Dot Above \\
\hline
U+022F6 & ⋶ & {\textbackslash}varisinobar & Element Of With Overbar \\
\hline
U+022F7 & ⋷ & {\textbackslash}isinobar & Small Element Of With Overbar \\
\hline
U+022F8 & ⋸ & {\textbackslash}isinvb & Element Of With Underbar \\
\hline
U+022F9 & ⋹ & {\textbackslash}isinE & Element Of With Two Horizontal Strokes \\
\hline
U+022FA & ⋺ & {\textbackslash}nisd & Contains With Long Horizontal Stroke \\
\hline
U+022FB & ⋻ & {\textbackslash}varnis & Contains With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022FC & ⋼ & {\textbackslash}nis & Small Contains With Vertical Bar At End Of Horizontal Stroke \\
\hline
U+022FD & ⋽ & {\textbackslash}varniobar & Contains With Overbar \\
\hline
U+022FE & ⋾ & {\textbackslash}niobar & Small Contains With Overbar \\
\hline
U+022FF & ⋿ & {\textbackslash}bagmember & Z Notation Bag Membership \\
\hline
U+02300 & ⌀ & {\textbackslash}diameter & Diameter Sign \\
\hline
U+02302 & ⌂ & {\textbackslash}house & House \\
\hline
U+02305 & ⌅ & {\textbackslash}varbarwedge & Projective \\
\hline
U+02306 & ⌆ & {\textbackslash}vardoublebarwedge & Perspective \\
\hline
U+02308 & ⌈ & {\textbackslash}lceil & Left Ceiling \\
\hline
U+02309 & ⌉ & {\textbackslash}rceil & Right Ceiling \\
\hline
U+0230A & ⌊ & {\textbackslash}lfloor & Left Floor \\
\hline
U+0230B & ⌋ & {\textbackslash}rfloor & Right Floor \\
\hline
U+02310 & ⌐ & {\textbackslash}invnot & Reversed Not Sign \\
\hline
U+02311 & ⌑ & {\textbackslash}sqlozenge & Square Lozenge \\
\hline
U+02312 & ⌒ & {\textbackslash}profline & Arc \\
\hline
U+02313 & ⌓ & {\textbackslash}profsurf & Segment \\
\hline
U+02315 & ⌕ & {\textbackslash}recorder & Telephone Recorder \\
\hline
U+02317 & ⌗ & {\textbackslash}viewdata & Viewdata Square \\
\hline
U+02319 & ⌙ & {\textbackslash}turnednot & Turned Not Sign \\
\hline
U+0231A & ⌚ & {\textbackslash}:watch: & Watch \\
\hline
U+0231B & ⌛ & {\textbackslash}:hourglass: & Hourglass \\
\hline
U+0231C & ⌜ & {\textbackslash}ulcorner & Top Left Corner \\
\hline
U+0231D & ⌝ & {\textbackslash}urcorner & Top Right Corner \\
\hline
U+0231E & ⌞ & {\textbackslash}llcorner & Bottom Left Corner \\
\hline
U+0231F & ⌟ & {\textbackslash}lrcorner & Bottom Right Corner \\
\hline
U+02322 & ⌢ & {\textbackslash}frown & Frown \\
\hline
U+02323 & ⌣ & {\textbackslash}smile & Smile \\
\hline
U+0232C & ⌬ & {\textbackslash}varhexagonlrbonds & Benzene Ring \\
\hline
U+02332 & ⌲ & {\textbackslash}conictaper & Conical Taper \\
\hline
U+02336 & ⌶ & {\textbackslash}topbot & Apl Functional Symbol I-beam \\
\hline
U+0233D & ⌽ & {\textbackslash}obar & Apl Functional Symbol Circle Stile \\
\hline
U+0233F & ⌿ & {\textbackslash}APLnotslash & Apl Functional Symbol Slash Bar \\
\hline
U+02340 & ⍀ & {\textbackslash}APLnotbackslash & Apl Functional Symbol Backslash Bar \\
\hline
U+02353 & ⍓ & {\textbackslash}APLboxupcaret & Apl Functional Symbol Quad Up Caret \\
\hline
U+02370 & ⍰ & {\textbackslash}APLboxquestion & Apl Functional Symbol Quad Question \\
\hline
U+02394 & ⎔ & {\textbackslash}hexagon & Software-function Symbol \\
\hline
U+023A3 & ⎣ & {\textbackslash}Elzdlcorn & Left Square Bracket Lower Corner \\
\hline
U+023B0 & ⎰ & {\textbackslash}lmoustache & Upper Left Or Lower Right Curly Bracket Section \\
\hline
U+023B1 & ⎱ & {\textbackslash}rmoustache & Upper Right Or Lower Left Curly Bracket Section \\
\hline
U+023B4 & ⎴ & {\textbackslash}overbracket & Top Square Bracket \\
\hline
U+023B5 & ⎵ & {\textbackslash}underbracket & Bottom Square Bracket \\
\hline
U+023B6 & ⎶ & {\textbackslash}bbrktbrk & Bottom Square Bracket Over Top Square Bracket \\
\hline
U+023B7 & ⎷ & {\textbackslash}sqrtbottom & Radical Symbol Bottom \\
\hline
U+023B8 & ⎸ & {\textbackslash}lvboxline & Left Vertical Box Line \\
\hline
U+023B9 & ⎹ & {\textbackslash}rvboxline & Right Vertical Box Line \\
\hline
U+023CE & ⏎ & {\textbackslash}varcarriagereturn & Return Symbol \\
\hline
U+023DE & ⏞ & {\textbackslash}overbrace & Top Curly Bracket \\
\hline
U+023DF & ⏟ & {\textbackslash}underbrace & Bottom Curly Bracket \\
\hline
U+023E2 & ⏢ & {\textbackslash}trapezium & White Trapezium \\
\hline
U+023E3 & ⏣ & {\textbackslash}benzenr & Benzene Ring With Circle \\
\hline
U+023E4 & ⏤ & {\textbackslash}strns & Straightness \\
\hline
U+023E5 & ⏥ & {\textbackslash}fltns & Flatness \\
\hline
U+023E6 & ⏦ & {\textbackslash}accurrent & Ac Current \\
\hline
U+023E7 & ⏧ & {\textbackslash}elinters & Electrical Intersection \\
\hline
U+023E9 & ⏩ & {\textbackslash}:fast\_forward: & Black Right-pointing Double Triangle \\
\hline
U+023EA & ⏪ & {\textbackslash}:rewind: & Black Left-pointing Double Triangle \\
\hline
U+023EB & ⏫ & {\textbackslash}:arrow\_double\_up: & Black Up-pointing Double Triangle \\
\hline
U+023EC & ⏬ & {\textbackslash}:arrow\_double\_down: & Black Down-pointing Double Triangle \\
\hline
U+023F0 & ⏰ & {\textbackslash}:alarm\_clock: & Alarm Clock \\
\hline
U+023F3 & ⏳ & {\textbackslash}:hourglass\_flowing\_sand: & Hourglass With Flowing Sand \\
\hline
U+02422 & ␢ & {\textbackslash}blanksymbol & Blank Symbol / Blank \\
\hline
U+02423 & ␣ & {\textbackslash}textvisiblespace & Open Box \\
\hline
U+024C2 & Ⓜ & {\textbackslash}:m: & Circled Latin Capital Letter M \\
\hline
U+024C8 & Ⓢ & {\textbackslash}circledS & Circled Latin Capital Letter S \\
\hline
U+02506 & ┆ & {\textbackslash}Elzdshfnc & Box Drawings Light Triple Dash Vertical / Forms Light Triple Dash Vertical \\
\hline
U+02519 & ┙ & {\textbackslash}Elzsqfnw & Box Drawings Up Light And Left Heavy / Forms Up Light And Left Heavy \\
\hline
U+02571 & ╱ & {\textbackslash}diagup & Box Drawings Light Diagonal Upper Right To Lower Left / Forms Light Diagonal Upper Right To Lower Left \\
\hline
U+02572 & ╲ & {\textbackslash}diagdown & Box Drawings Light Diagonal Upper Left To Lower Right / Forms Light Diagonal Upper Left To Lower Right \\
\hline
U+02580 & ▀ & {\textbackslash}blockuphalf & Upper Half Block \\
\hline
U+02584 & ▄ & {\textbackslash}blocklowhalf & Lower Half Block \\
\hline
U+02588 & █ & {\textbackslash}blockfull & Full Block \\
\hline
U+0258C & ▌ & {\textbackslash}blocklefthalf & Left Half Block \\
\hline
U+02590 & ▐ & {\textbackslash}blockrighthalf & Right Half Block \\
\hline
U+02591 & ░ & {\textbackslash}blockqtrshaded & Light Shade \\
\hline
U+02592 & ▒ & {\textbackslash}blockhalfshaded & Medium Shade \\
\hline
U+02593 & ▓ & {\textbackslash}blockthreeqtrshaded & Dark Shade \\
\hline
U+025A0 & ■ & {\textbackslash}blacksquare & Black Square \\
\hline
U+025A1 & □ & {\textbackslash}square & White Square \\
\hline
U+025A2 & ▢ & {\textbackslash}squoval & White Square With Rounded Corners \\
\hline
U+025A3 & ▣ & {\textbackslash}blackinwhitesquare & White Square Containing Black Small Square \\
\hline
U+025A4 & ▤ & {\textbackslash}squarehfill & Square With Horizontal Fill \\
\hline
U+025A5 & ▥ & {\textbackslash}squarevfill & Square With Vertical Fill \\
\hline
U+025A6 & ▦ & {\textbackslash}squarehvfill & Square With Orthogonal Crosshatch Fill \\
\hline
U+025A7 & ▧ & {\textbackslash}squarenwsefill & Square With Upper Left To Lower Right Fill \\
\hline
U+025A8 & ▨ & {\textbackslash}squareneswfill & Square With Upper Right To Lower Left Fill \\
\hline
U+025A9 & ▩ & {\textbackslash}squarecrossfill & Square With Diagonal Crosshatch Fill \\
\hline
U+025AA & ▪ & {\textbackslash}smblksquare, {\textbackslash}:black\_small\_square: & Black Small Square \\
\hline
U+025AB & ▫ & {\textbackslash}smwhtsquare, {\textbackslash}:white\_small\_square: & White Small Square \\
\hline
U+025AC & ▬ & {\textbackslash}hrectangleblack & Black Rectangle \\
\hline
U+025AD & ▭ & {\textbackslash}hrectangle & White Rectangle \\
\hline
U+025AE & ▮ & {\textbackslash}vrectangleblack & Black Vertical Rectangle \\
\hline
U+025AF & ▯ & {\textbackslash}Elzvrecto & White Vertical Rectangle \\
\hline
U+025B0 & ▰ & {\textbackslash}parallelogramblack & Black Parallelogram \\
\hline
U+025B1 & ▱ & {\textbackslash}parallelogram & White Parallelogram \\
\hline
U+025B2 & ▲ & {\textbackslash}bigblacktriangleup & Black Up-pointing Triangle / Black Up Pointing Triangle \\
\hline
U+025B3 & △ & {\textbackslash}bigtriangleup & White Up-pointing Triangle / White Up Pointing Triangle \\
\hline
U+025B4 & ▴ & {\textbackslash}blacktriangle & Black Up-pointing Small Triangle / Black Up Pointing Small Triangle \\
\hline
U+025B5 & ▵ & {\textbackslash}vartriangle & White Up-pointing Small Triangle / White Up Pointing Small Triangle \\
\hline
U+025B6 & ▶ & {\textbackslash}blacktriangleright, {\textbackslash}:arrow\_forward: & Black Right-pointing Triangle / Black Right Pointing Triangle \\
\hline
U+025B7 & ▷ & {\textbackslash}triangleright & White Right-pointing Triangle / White Right Pointing Triangle \\
\hline
U+025B8 & ▸ & {\textbackslash}smallblacktriangleright & Black Right-pointing Small Triangle / Black Right Pointing Small Triangle \\
\hline
U+025B9 & ▹ & {\textbackslash}smalltriangleright & White Right-pointing Small Triangle / White Right Pointing Small Triangle \\
\hline
U+025BA & ► & {\textbackslash}blackpointerright & Black Right-pointing Pointer / Black Right Pointing Pointer \\
\hline
U+025BB & ▻ & {\textbackslash}whitepointerright & White Right-pointing Pointer / White Right Pointing Pointer \\
\hline
U+025BC & ▼ & {\textbackslash}bigblacktriangledown & Black Down-pointing Triangle / Black Down Pointing Triangle \\
\hline
U+025BD & ▽ & {\textbackslash}bigtriangledown & White Down-pointing Triangle / White Down Pointing Triangle \\
\hline
U+025BE & ▾ & {\textbackslash}blacktriangledown & Black Down-pointing Small Triangle / Black Down Pointing Small Triangle \\
\hline
U+025BF & ▿ & {\textbackslash}triangledown & White Down-pointing Small Triangle / White Down Pointing Small Triangle \\
\hline
U+025C0 & ◀ & {\textbackslash}blacktriangleleft, {\textbackslash}:arrow\_backward: & Black Left-pointing Triangle / Black Left Pointing Triangle \\
\hline
U+025C1 & ◁ & {\textbackslash}triangleleft & White Left-pointing Triangle / White Left Pointing Triangle \\
\hline
U+025C2 & ◂ & {\textbackslash}smallblacktriangleleft & Black Left-pointing Small Triangle / Black Left Pointing Small Triangle \\
\hline
U+025C3 & ◃ & {\textbackslash}smalltriangleleft & White Left-pointing Small Triangle / White Left Pointing Small Triangle \\
\hline
U+025C4 & ◄ & {\textbackslash}blackpointerleft & Black Left-pointing Pointer / Black Left Pointing Pointer \\
\hline
U+025C5 & ◅ & {\textbackslash}whitepointerleft & White Left-pointing Pointer / White Left Pointing Pointer \\
\hline
U+025C6 & ◆ & {\textbackslash}mdlgblkdiamond & Black Diamond \\
\hline
U+025C7 & ◇ & {\textbackslash}mdlgwhtdiamond & White Diamond \\
\hline
U+025C8 & ◈ & {\textbackslash}blackinwhitediamond & White Diamond Containing Black Small Diamond \\
\hline
U+025C9 & ◉ & {\textbackslash}fisheye & Fisheye \\
\hline
U+025CA & ◊ & {\textbackslash}lozenge & Lozenge \\
\hline
U+025CB & ○ & {\textbackslash}bigcirc & White Circle \\
\hline
U+025CC & ◌ & {\textbackslash}dottedcircle & Dotted Circle \\
\hline
U+025CD & ◍ & {\textbackslash}circlevertfill & Circle With Vertical Fill \\
\hline
U+025CE & ◎ & {\textbackslash}bullseye & Bullseye \\
\hline
U+025CF & ● & {\textbackslash}mdlgblkcircle & Black Circle \\
\hline
U+025D0 & ◐ & {\textbackslash}Elzcirfl & Circle With Left Half Black \\
\hline
U+025D1 & ◑ & {\textbackslash}Elzcirfr & Circle With Right Half Black \\
\hline
U+025D2 & ◒ & {\textbackslash}Elzcirfb & Circle With Lower Half Black \\
\hline
U+025D3 & ◓ & {\textbackslash}circletophalfblack & Circle With Upper Half Black \\
\hline
U+025D4 & ◔ & {\textbackslash}circleurquadblack & Circle With Upper Right Quadrant Black \\
\hline
U+025D5 & ◕ & {\textbackslash}blackcircleulquadwhite & Circle With All But Upper Left Quadrant Black \\
\hline
U+025D6 & ◖ & {\textbackslash}blacklefthalfcircle & Left Half Black Circle \\
\hline
U+025D7 & ◗ & {\textbackslash}blackrighthalfcircle & Right Half Black Circle \\
\hline
U+025D8 & ◘ & {\textbackslash}Elzrvbull & Inverse Bullet \\
\hline
U+025D9 & ◙ & {\textbackslash}inversewhitecircle & Inverse White Circle \\
\hline
U+025DA & ◚ & {\textbackslash}invwhiteupperhalfcircle & Upper Half Inverse White Circle \\
\hline
U+025DB & ◛ & {\textbackslash}invwhitelowerhalfcircle & Lower Half Inverse White Circle \\
\hline
U+025DC & ◜ & {\textbackslash}ularc & Upper Left Quadrant Circular Arc \\
\hline
U+025DD & ◝ & {\textbackslash}urarc & Upper Right Quadrant Circular Arc \\
\hline
U+025DE & ◞ & {\textbackslash}lrarc & Lower Right Quadrant Circular Arc \\
\hline
U+025DF & ◟ & {\textbackslash}llarc & Lower Left Quadrant Circular Arc \\
\hline
U+025E0 & ◠ & {\textbackslash}topsemicircle & Upper Half Circle \\
\hline
U+025E1 & ◡ & {\textbackslash}botsemicircle & Lower Half Circle \\
\hline
U+025E2 & ◢ & {\textbackslash}lrblacktriangle & Black Lower Right Triangle \\
\hline
U+025E3 & ◣ & {\textbackslash}llblacktriangle & Black Lower Left Triangle \\
\hline
U+025E4 & ◤ & {\textbackslash}ulblacktriangle & Black Upper Left Triangle \\
\hline
U+025E5 & ◥ & {\textbackslash}urblacktriangle & Black Upper Right Triangle \\
\hline
U+025E6 & ◦ & {\textbackslash}smwhtcircle & White Bullet \\
\hline
U+025E7 & ◧ & {\textbackslash}Elzsqfl & Square With Left Half Black \\
\hline
U+025E8 & ◨ & {\textbackslash}Elzsqfr & Square With Right Half Black \\
\hline
U+025E9 & ◩ & {\textbackslash}squareulblack & Square With Upper Left Diagonal Half Black \\
\hline
U+025EA & ◪ & {\textbackslash}Elzsqfse & Square With Lower Right Diagonal Half Black \\
\hline
U+025EB & ◫ & {\textbackslash}boxbar & White Square With Vertical Bisecting Line \\
\hline
U+025EC & ◬ & {\textbackslash}trianglecdot & White Up-pointing Triangle With Dot / White Up Pointing Triangle With Dot \\
\hline
U+025ED & ◭ & {\textbackslash}triangleleftblack & Up-pointing Triangle With Left Half Black / Up Pointing Triangle With Left Half Black \\
\hline
U+025EE & ◮ & {\textbackslash}trianglerightblack & Up-pointing Triangle With Right Half Black / Up Pointing Triangle With Right Half Black \\
\hline
U+025EF & ◯ & {\textbackslash}lgwhtcircle & Large Circle \\
\hline
U+025F0 & ◰ & {\textbackslash}squareulquad & White Square With Upper Left Quadrant \\
\hline
U+025F1 & ◱ & {\textbackslash}squarellquad & White Square With Lower Left Quadrant \\
\hline
U+025F2 & ◲ & {\textbackslash}squarelrquad & White Square With Lower Right Quadrant \\
\hline
U+025F3 & ◳ & {\textbackslash}squareurquad & White Square With Upper Right Quadrant \\
\hline
U+025F4 & ◴ & {\textbackslash}circleulquad & White Circle With Upper Left Quadrant \\
\hline
U+025F5 & ◵ & {\textbackslash}circlellquad & White Circle With Lower Left Quadrant \\
\hline
U+025F6 & ◶ & {\textbackslash}circlelrquad & White Circle With Lower Right Quadrant \\
\hline
U+025F7 & ◷ & {\textbackslash}circleurquad & White Circle With Upper Right Quadrant \\
\hline
U+025F8 & ◸ & {\textbackslash}ultriangle & Upper Left Triangle \\
\hline
U+025F9 & ◹ & {\textbackslash}urtriangle & Upper Right Triangle \\
\hline
U+025FA & ◺ & {\textbackslash}lltriangle & Lower Left Triangle \\
\hline
U+025FB & ◻ & {\textbackslash}mdwhtsquare, {\textbackslash}:white\_medium\_square: & White Medium Square \\
\hline
U+025FC & ◼ & {\textbackslash}mdblksquare, {\textbackslash}:black\_medium\_square: & Black Medium Square \\
\hline
U+025FD & ◽ & {\textbackslash}mdsmwhtsquare, {\textbackslash}:white\_medium\_small\_square: & White Medium Small Square \\
\hline
U+025FE & ◾ & {\textbackslash}mdsmblksquare, {\textbackslash}:black\_medium\_small\_square: & Black Medium Small Square \\
\hline
U+025FF & ◿ & {\textbackslash}lrtriangle & Lower Right Triangle \\
\hline
U+02600 & ☀ & {\textbackslash}:sunny: & Black Sun With Rays \\
\hline
U+02601 & ☁ & {\textbackslash}:cloud: & Cloud \\
\hline
U+02605 & ★ & {\textbackslash}bigstar & Black Star \\
\hline
U+02606 & ☆ & {\textbackslash}bigwhitestar & White Star \\
\hline
U+02609 & ☉ & {\textbackslash}astrosun & Sun \\
\hline
U+0260E & ☎ & {\textbackslash}:phone: & Black Telephone \\
\hline
U+02611 & ☑ & {\textbackslash}:ballot\_box\_with\_check: & Ballot Box With Check \\
\hline
U+02614 & ☔ & {\textbackslash}:umbrella: & Umbrella With Rain Drops \\
\hline
U+02615 & ☕ & {\textbackslash}:coffee: & Hot Beverage \\
\hline
U+0261D & ☝ & {\textbackslash}:point\_up: & White Up Pointing Index \\
\hline
U+02621 & ☡ & {\textbackslash}danger & Caution Sign \\
\hline
U+0263A & ☺ & {\textbackslash}:relaxed: & White Smiling Face \\
\hline
U+0263B & ☻ & {\textbackslash}blacksmiley & Black Smiling Face \\
\hline
U+0263C & ☼ & {\textbackslash}sun & White Sun With Rays \\
\hline
U+0263D & ☽ & {\textbackslash}rightmoon & First Quarter Moon \\
\hline
U+0263E & ☾ & {\textbackslash}leftmoon & Last Quarter Moon \\
\hline
U+0263F & ☿ & {\textbackslash}mercury & Mercury \\
\hline
U+02640 & ♀ & {\textbackslash}venus, {\textbackslash}female & Female Sign \\
\hline
U+02642 & ♂ & {\textbackslash}male, {\textbackslash}mars & Male Sign \\
\hline
U+02643 & ♃ & {\textbackslash}jupiter & Jupiter \\
\hline
U+02644 & ♄ & {\textbackslash}saturn & Saturn \\
\hline
U+02645 & ♅ & {\textbackslash}uranus & Uranus \\
\hline
U+02646 & ♆ & {\textbackslash}neptune & Neptune \\
\hline
U+02647 & ♇ & {\textbackslash}pluto & Pluto \\
\hline
U+02648 & ♈ & {\textbackslash}aries, {\textbackslash}:aries: & Aries \\
\hline
U+02649 & ♉ & {\textbackslash}taurus, {\textbackslash}:taurus: & Taurus \\
\hline
U+0264A & ♊ & {\textbackslash}gemini, {\textbackslash}:gemini: & Gemini \\
\hline
U+0264B & ♋ & {\textbackslash}cancer, {\textbackslash}:cancer: & Cancer \\
\hline
U+0264C & ♌ & {\textbackslash}leo, {\textbackslash}:leo: & Leo \\
\hline
U+0264D & ♍ & {\textbackslash}virgo, {\textbackslash}:virgo: & Virgo \\
\hline
U+0264E & ♎ & {\textbackslash}libra, {\textbackslash}:libra: & Libra \\
\hline
U+0264F & ♏ & {\textbackslash}scorpio, {\textbackslash}:scorpius: & Scorpius \\
\hline
U+02650 & ♐ & {\textbackslash}sagittarius, {\textbackslash}:sagittarius: & Sagittarius \\
\hline
U+02651 & ♑ & {\textbackslash}capricornus, {\textbackslash}:capricorn: & Capricorn \\
\hline
U+02652 & ♒ & {\textbackslash}aquarius, {\textbackslash}:aquarius: & Aquarius \\
\hline
U+02653 & ♓ & {\textbackslash}pisces, {\textbackslash}:pisces: & Pisces \\
\hline
U+02660 & ♠ & {\textbackslash}spadesuit, {\textbackslash}:spades: & Black Spade Suit \\
\hline
U+02661 & ♡ & {\textbackslash}heartsuit & White Heart Suit \\
\hline
U+02662 & ♢ & {\textbackslash}diamondsuit & White Diamond Suit \\
\hline
U+02663 & ♣ & {\textbackslash}clubsuit, {\textbackslash}:clubs: & Black Club Suit \\
\hline
U+02664 & ♤ & {\textbackslash}varspadesuit & White Spade Suit \\
\hline
U+02665 & ♥ & {\textbackslash}varheartsuit, {\textbackslash}:hearts: & Black Heart Suit \\
\hline
U+02666 & ♦ & {\textbackslash}vardiamondsuit, {\textbackslash}:diamonds: & Black Diamond Suit \\
\hline
U+02667 & ♧ & {\textbackslash}varclubsuit & White Club Suit \\
\hline
U+02668 & ♨ & {\textbackslash}:hotsprings: & Hot Springs \\
\hline
U+02669 & ♩ & {\textbackslash}quarternote & Quarter Note \\
\hline
U+0266A & ♪ & {\textbackslash}eighthnote & Eighth Note \\
\hline
U+0266B & ♫ & {\textbackslash}twonotes & Beamed Eighth Notes / Barred Eighth Notes \\
\hline
U+0266D & ♭ & {\textbackslash}flat & Music Flat Sign / Flat \\
\hline
U+0266E & ♮ & {\textbackslash}natural & Music Natural Sign / Natural \\
\hline
U+0266F & ♯ & {\textbackslash}sharp & Music Sharp Sign / Sharp \\
\hline
U+0267B & ♻ & {\textbackslash}:recycle: & Black Universal Recycling Symbol \\
\hline
U+0267E & ♾ & {\textbackslash}acidfree & Permanent Paper Sign \\
\hline
U+0267F & ♿ & {\textbackslash}:wheelchair: & Wheelchair Symbol \\
\hline
U+02680 & ⚀ & {\textbackslash}dicei & Die Face-1 \\
\hline
U+02681 & ⚁ & {\textbackslash}diceii & Die Face-2 \\
\hline
U+02682 & ⚂ & {\textbackslash}diceiii & Die Face-3 \\
\hline
U+02683 & ⚃ & {\textbackslash}diceiv & Die Face-4 \\
\hline
U+02684 & ⚄ & {\textbackslash}dicev & Die Face-5 \\
\hline
U+02685 & ⚅ & {\textbackslash}dicevi & Die Face-6 \\
\hline
U+02686 & ⚆ & {\textbackslash}circledrightdot & White Circle With Dot Right \\
\hline
U+02687 & ⚇ & {\textbackslash}circledtwodots & White Circle With Two Dots \\
\hline
U+02688 & ⚈ & {\textbackslash}blackcircledrightdot & Black Circle With White Dot Right \\
\hline
U+02689 & ⚉ & {\textbackslash}blackcircledtwodots & Black Circle With Two White Dots \\
\hline
U+02693 & ⚓ & {\textbackslash}:anchor: & Anchor \\
\hline
U+026A0 & ⚠ & {\textbackslash}:warning: & Warning Sign \\
\hline
U+026A1 & ⚡ & {\textbackslash}:zap: & High Voltage Sign \\
\hline
U+026A5 & ⚥ & {\textbackslash}Hermaphrodite & Male And Female Sign \\
\hline
U+026AA & ⚪ & {\textbackslash}mdwhtcircle, {\textbackslash}:white\_circle: & Medium White Circle \\
\hline
U+026AB & ⚫ & {\textbackslash}mdblkcircle, {\textbackslash}:black\_circle: & Medium Black Circle \\
\hline
U+026AC & ⚬ & {\textbackslash}mdsmwhtcircle & Medium Small White Circle \\
\hline
U+026B2 & ⚲ & {\textbackslash}neuter & Neuter \\
\hline
U+026BD & ⚽ & {\textbackslash}:soccer: & Soccer Ball \\
\hline
U+026BE & ⚾ & {\textbackslash}:baseball: & Baseball \\
\hline
U+026C4 & ⛄ & {\textbackslash}:snowman: & Snowman Without Snow \\
\hline
U+026C5 & ⛅ & {\textbackslash}:partly\_sunny: & Sun Behind Cloud \\
\hline
U+026CE & ⛎ & {\textbackslash}:ophiuchus: & Ophiuchus \\
\hline
U+026D4 & ⛔ & {\textbackslash}:no\_entry: & No Entry \\
\hline
U+026EA & ⛪ & {\textbackslash}:church: & Church \\
\hline
U+026F2 & ⛲ & {\textbackslash}:fountain: & Fountain \\
\hline
U+026F3 & ⛳ & {\textbackslash}:golf: & Flag In Hole \\
\hline
U+026F5 & ⛵ & {\textbackslash}:boat: & Sailboat \\
\hline
U+026FA & ⛺ & {\textbackslash}:tent: & Tent \\
\hline
U+026FD & ⛽ & {\textbackslash}:fuelpump: & Fuel Pump \\
\hline
U+02702 & ✂ & {\textbackslash}:scissors: & Black Scissors \\
\hline
U+02705 & ✅ & {\textbackslash}:white\_check\_mark: & White Heavy Check Mark \\
\hline
U+02708 & ✈ & {\textbackslash}:airplane: & Airplane \\
\hline
U+02709 & ✉ & {\textbackslash}:email: & Envelope \\
\hline
U+0270A & ✊ & {\textbackslash}:fist: & Raised Fist \\
\hline
U+0270B & ✋ & {\textbackslash}:hand: & Raised Hand \\
\hline
U+0270C & ✌ & {\textbackslash}:v: & Victory Hand \\
\hline
U+0270F & ✏ & {\textbackslash}:pencil2: & Pencil \\
\hline
U+02712 & ✒ & {\textbackslash}:black\_nib: & Black Nib \\
\hline
U+02713 & ✓ & {\textbackslash}checkmark & Check Mark \\
\hline
U+02714 & ✔ & {\textbackslash}:heavy\_check\_mark: & Heavy Check Mark \\
\hline
U+02716 & ✖ & {\textbackslash}:heavy\_multiplication\_x: & Heavy Multiplication X \\
\hline
U+02720 & ✠ & {\textbackslash}maltese & Maltese Cross \\
\hline
U+02728 & ✨ & {\textbackslash}:sparkles: & Sparkles \\
\hline
U+0272A & ✪ & {\textbackslash}circledstar & Circled White Star \\
\hline
U+02733 & ✳ & {\textbackslash}:eight\_spoked\_asterisk: & Eight Spoked Asterisk \\
\hline
U+02734 & ✴ & {\textbackslash}:eight\_pointed\_black\_star: & Eight Pointed Black Star \\
\hline
U+02736 & ✶ & {\textbackslash}varstar & Six Pointed Black Star \\
\hline
U+0273D & ✽ & {\textbackslash}dingasterisk & Heavy Teardrop-spoked Asterisk \\
\hline
U+02744 & ❄ & {\textbackslash}:snowflake: & Snowflake \\
\hline
U+02747 & ❇ & {\textbackslash}:sparkle: & Sparkle \\
\hline
U+0274C & ❌ & {\textbackslash}:x: & Cross Mark \\
\hline
U+0274E & ❎ & {\textbackslash}:negative\_squared\_cross\_mark: & Negative Squared Cross Mark \\
\hline
U+02753 & ❓ & {\textbackslash}:question: & Black Question Mark Ornament \\
\hline
U+02754 & ❔ & {\textbackslash}:grey\_question: & White Question Mark Ornament \\
\hline
U+02755 & ❕ & {\textbackslash}:grey\_exclamation: & White Exclamation Mark Ornament \\
\hline
U+02757 & ❗ & {\textbackslash}:exclamation: & Heavy Exclamation Mark Symbol \\
\hline
U+02764 & ❤ & {\textbackslash}:heart: & Heavy Black Heart \\
\hline
U+02795 & ➕ & {\textbackslash}:heavy\_plus\_sign: & Heavy Plus Sign \\
\hline
U+02796 & ➖ & {\textbackslash}:heavy\_minus\_sign: & Heavy Minus Sign \\
\hline
U+02797 & ➗ & {\textbackslash}:heavy\_division\_sign: & Heavy Division Sign \\
\hline
U+0279B & ➛ & {\textbackslash}draftingarrow & Drafting Point Rightwards Arrow / Drafting Point Right Arrow \\
\hline
U+027A1 & ➡ & {\textbackslash}:arrow\_right: & Black Rightwards Arrow / Black Right Arrow \\
\hline
U+027B0 & ➰ & {\textbackslash}:curly\_loop: & Curly Loop \\
\hline
U+027BF & ➿ & {\textbackslash}:loop: & Double Curly Loop \\
\hline
U+027C0 & ⟀ & {\textbackslash}threedangle & Three Dimensional Angle \\
\hline
U+027C1 & ⟁ & {\textbackslash}whiteinwhitetriangle & White Triangle Containing Small White Triangle \\
\hline
U+027C2 & ⟂ & {\textbackslash}perp & Perpendicular \\
\hline
U+027C8 & ⟈ & {\textbackslash}bsolhsub & Reverse Solidus Preceding Subset \\
\hline
U+027C9 & ⟉ & {\textbackslash}suphsol & Superset Preceding Solidus \\
\hline
U+027D1 & ⟑ & {\textbackslash}wedgedot & And With Dot \\
\hline
U+027D2 & ⟒ & {\textbackslash}upin & Element Of Opening Upwards \\
\hline
U+027D5 & ⟕ & {\textbackslash}leftouterjoin & Left Outer Join \\
\hline
U+027D6 & ⟖ & {\textbackslash}rightouterjoin & Right Outer Join \\
\hline
U+027D7 & ⟗ & {\textbackslash}fullouterjoin & Full Outer Join \\
\hline
U+027D8 & ⟘ & {\textbackslash}bigbot & Large Up Tack \\
\hline
U+027D9 & ⟙ & {\textbackslash}bigtop & Large Down Tack \\
\hline
U+027E6 & ⟦ & {\textbackslash}llbracket, {\textbackslash}openbracketleft & Mathematical Left White Square Bracket \\
\hline
U+027E7 & ⟧ & {\textbackslash}openbracketright, {\textbackslash}rrbracket & Mathematical Right White Square Bracket \\
\hline
U+027E8 & ⟨ & {\textbackslash}langle & Mathematical Left Angle Bracket \\
\hline
U+027E9 & ⟩ & {\textbackslash}rangle & Mathematical Right Angle Bracket \\
\hline
U+027F0 & ⟰ & {\textbackslash}UUparrow & Upwards Quadruple Arrow \\
\hline
U+027F1 & ⟱ & {\textbackslash}DDownarrow & Downwards Quadruple Arrow \\
\hline
U+027F5 & ⟵ & {\textbackslash}longleftarrow & Long Leftwards Arrow \\
\hline
U+027F6 & ⟶ & {\textbackslash}longrightarrow & Long Rightwards Arrow \\
\hline
U+027F7 & ⟷ & {\textbackslash}longleftrightarrow & Long Left Right Arrow \\
\hline
U+027F8 & ⟸ & {\textbackslash}impliedby, {\textbackslash}Longleftarrow & Long Leftwards Double Arrow \\
\hline
U+027F9 & ⟹ & {\textbackslash}implies, {\textbackslash}Longrightarrow & Long Rightwards Double Arrow \\
\hline
U+027FA & ⟺ & {\textbackslash}Longleftrightarrow, {\textbackslash}iff & Long Left Right Double Arrow \\
\hline
U+027FB & ⟻ & {\textbackslash}longmapsfrom & Long Leftwards Arrow From Bar \\
\hline
U+027FC & ⟼ & {\textbackslash}longmapsto & Long Rightwards Arrow From Bar \\
\hline
U+027FD & ⟽ & {\textbackslash}Longmapsfrom & Long Leftwards Double Arrow From Bar \\
\hline
U+027FE & ⟾ & {\textbackslash}Longmapsto & Long Rightwards Double Arrow From Bar \\
\hline
U+027FF & ⟿ & {\textbackslash}longrightsquigarrow & Long Rightwards Squiggle Arrow \\
\hline
U+02900 & ⤀ & {\textbackslash}nvtwoheadrightarrow & Rightwards Two-headed Arrow With Vertical Stroke \\
\hline
U+02901 & ⤁ & {\textbackslash}nVtwoheadrightarrow & Rightwards Two-headed Arrow With Double Vertical Stroke \\
\hline
U+02902 & ⤂ & {\textbackslash}nvLeftarrow & Leftwards Double Arrow With Vertical Stroke \\
\hline
U+02903 & ⤃ & {\textbackslash}nvRightarrow & Rightwards Double Arrow With Vertical Stroke \\
\hline
U+02904 & ⤄ & {\textbackslash}nvLeftrightarrow & Left Right Double Arrow With Vertical Stroke \\
\hline
U+02905 & ⤅ & {\textbackslash}twoheadmapsto & Rightwards Two-headed Arrow From Bar \\
\hline
U+02906 & ⤆ & {\textbackslash}Mapsfrom & Leftwards Double Arrow From Bar \\
\hline
U+02907 & ⤇ & {\textbackslash}Mapsto & Rightwards Double Arrow From Bar \\
\hline
U+02908 & ⤈ & {\textbackslash}downarrowbarred & Downwards Arrow With Horizontal Stroke \\
\hline
U+02909 & ⤉ & {\textbackslash}uparrowbarred & Upwards Arrow With Horizontal Stroke \\
\hline
U+0290A & ⤊ & {\textbackslash}Uuparrow & Upwards Triple Arrow \\
\hline
U+0290B & ⤋ & {\textbackslash}Ddownarrow & Downwards Triple Arrow \\
\hline
U+0290C & ⤌ & {\textbackslash}leftbkarrow & Leftwards Double Dash Arrow \\
\hline
U+0290D & ⤍ & {\textbackslash}bkarow & Rightwards Double Dash Arrow \\
\hline
U+0290E & ⤎ & {\textbackslash}leftdbkarrow & Leftwards Triple Dash Arrow \\
\hline
U+0290F & ⤏ & {\textbackslash}dbkarow & Rightwards Triple Dash Arrow \\
\hline
U+02910 & ⤐ & {\textbackslash}drbkarrow & Rightwards Two-headed Triple Dash Arrow \\
\hline
U+02911 & ⤑ & {\textbackslash}rightdotarrow & Rightwards Arrow With Dotted Stem \\
\hline
U+02912 & ⤒ & {\textbackslash}UpArrowBar & Upwards Arrow To Bar \\
\hline
U+02913 & ⤓ & {\textbackslash}DownArrowBar & Downwards Arrow To Bar \\
\hline
U+02914 & ⤔ & {\textbackslash}nvrightarrowtail & Rightwards Arrow With Tail With Vertical Stroke \\
\hline
U+02915 & ⤕ & {\textbackslash}nVrightarrowtail & Rightwards Arrow With Tail With Double Vertical Stroke \\
\hline
U+02916 & ⤖ & {\textbackslash}twoheadrightarrowtail & Rightwards Two-headed Arrow With Tail \\
\hline
U+02917 & ⤗ & {\textbackslash}nvtwoheadrightarrowtail & Rightwards Two-headed Arrow With Tail With Vertical Stroke \\
\hline
U+02918 & ⤘ & {\textbackslash}nVtwoheadrightarrowtail & Rightwards Two-headed Arrow With Tail With Double Vertical Stroke \\
\hline
U+0291D & ⤝ & {\textbackslash}diamondleftarrow & Leftwards Arrow To Black Diamond \\
\hline
U+0291E & ⤞ & {\textbackslash}rightarrowdiamond & Rightwards Arrow To Black Diamond \\
\hline
U+0291F & ⤟ & {\textbackslash}diamondleftarrowbar & Leftwards Arrow From Bar To Black Diamond \\
\hline
U+02920 & ⤠ & {\textbackslash}barrightarrowdiamond & Rightwards Arrow From Bar To Black Diamond \\
\hline
U+02925 & ⤥ & {\textbackslash}hksearow & South East Arrow With Hook \\
\hline
U+02926 & ⤦ & {\textbackslash}hkswarow & South West Arrow With Hook \\
\hline
U+02927 & ⤧ & {\textbackslash}tona & North West Arrow And North East Arrow \\
\hline
U+02928 & ⤨ & {\textbackslash}toea & North East Arrow And South East Arrow \\
\hline
U+02929 & ⤩ & {\textbackslash}tosa & South East Arrow And South West Arrow \\
\hline
U+0292A & ⤪ & {\textbackslash}towa & South West Arrow And North West Arrow \\
\hline
U+0292B & ⤫ & {\textbackslash}rdiagovfdiag & Rising Diagonal Crossing Falling Diagonal \\
\hline
U+0292C & ⤬ & {\textbackslash}fdiagovrdiag & Falling Diagonal Crossing Rising Diagonal \\
\hline
U+0292D & ⤭ & {\textbackslash}seovnearrow & South East Arrow Crossing North East Arrow \\
\hline
U+0292E & ⤮ & {\textbackslash}neovsearrow & North East Arrow Crossing South East Arrow \\
\hline
U+0292F & ⤯ & {\textbackslash}fdiagovnearrow & Falling Diagonal Crossing North East Arrow \\
\hline
U+02930 & ⤰ & {\textbackslash}rdiagovsearrow & Rising Diagonal Crossing South East Arrow \\
\hline
U+02931 & ⤱ & {\textbackslash}neovnwarrow & North East Arrow Crossing North West Arrow \\
\hline
U+02932 & ⤲ & {\textbackslash}nwovnearrow & North West Arrow Crossing North East Arrow \\
\hline
U+02934 & ⤴ & {\textbackslash}:arrow\_heading\_up: & Arrow Pointing Rightwards Then Curving Upwards \\
\hline
U+02935 & ⤵ & {\textbackslash}:arrow\_heading\_down: & Arrow Pointing Rightwards Then Curving Downwards \\
\hline
U+02942 & ⥂ & {\textbackslash}ElzRlarr & Rightwards Arrow Above Short Leftwards Arrow \\
\hline
U+02944 & ⥄ & {\textbackslash}ElzrLarr & Short Rightwards Arrow Above Leftwards Arrow \\
\hline
U+02945 & ⥅ & {\textbackslash}rightarrowplus & Rightwards Arrow With Plus Below \\
\hline
U+02946 & ⥆ & {\textbackslash}leftarrowplus & Leftwards Arrow With Plus Below \\
\hline
U+02947 & ⥇ & {\textbackslash}Elzrarrx & Rightwards Arrow Through X \\
\hline
U+02948 & ⥈ & {\textbackslash}leftrightarrowcircle & Left Right Arrow Through Small Circle \\
\hline
U+02949 & ⥉ & {\textbackslash}twoheaduparrowcircle & Upwards Two-headed Arrow From Small Circle \\
\hline
U+0294A & ⥊ & {\textbackslash}leftrightharpoonupdown & Left Barb Up Right Barb Down Harpoon \\
\hline
U+0294B & ⥋ & {\textbackslash}leftrightharpoondownup & Left Barb Down Right Barb Up Harpoon \\
\hline
U+0294C & ⥌ & {\textbackslash}updownharpoonrightleft & Up Barb Right Down Barb Left Harpoon \\
\hline
U+0294D & ⥍ & {\textbackslash}updownharpoonleftright & Up Barb Left Down Barb Right Harpoon \\
\hline
U+0294E & ⥎ & {\textbackslash}LeftRightVector & Left Barb Up Right Barb Up Harpoon \\
\hline
U+0294F & ⥏ & {\textbackslash}RightUpDownVector & Up Barb Right Down Barb Right Harpoon \\
\hline
U+02950 & ⥐ & {\textbackslash}DownLeftRightVector & Left Barb Down Right Barb Down Harpoon \\
\hline
U+02951 & ⥑ & {\textbackslash}LeftUpDownVector & Up Barb Left Down Barb Left Harpoon \\
\hline
U+02952 & ⥒ & {\textbackslash}LeftVectorBar & Leftwards Harpoon With Barb Up To Bar \\
\hline
U+02953 & ⥓ & {\textbackslash}RightVectorBar & Rightwards Harpoon With Barb Up To Bar \\
\hline
U+02954 & ⥔ & {\textbackslash}RightUpVectorBar & Upwards Harpoon With Barb Right To Bar \\
\hline
U+02955 & ⥕ & {\textbackslash}RightDownVectorBar & Downwards Harpoon With Barb Right To Bar \\
\hline
U+02956 & ⥖ & {\textbackslash}DownLeftVectorBar & Leftwards Harpoon With Barb Down To Bar \\
\hline
U+02957 & ⥗ & {\textbackslash}DownRightVectorBar & Rightwards Harpoon With Barb Down To Bar \\
\hline
U+02958 & ⥘ & {\textbackslash}LeftUpVectorBar & Upwards Harpoon With Barb Left To Bar \\
\hline
U+02959 & ⥙ & {\textbackslash}LeftDownVectorBar & Downwards Harpoon With Barb Left To Bar \\
\hline
U+0295A & ⥚ & {\textbackslash}LeftTeeVector & Leftwards Harpoon With Barb Up From Bar \\
\hline
U+0295B & ⥛ & {\textbackslash}RightTeeVector & Rightwards Harpoon With Barb Up From Bar \\
\hline
U+0295C & ⥜ & {\textbackslash}RightUpTeeVector & Upwards Harpoon With Barb Right From Bar \\
\hline
U+0295D & ⥝ & {\textbackslash}RightDownTeeVector & Downwards Harpoon With Barb Right From Bar \\
\hline
U+0295E & ⥞ & {\textbackslash}DownLeftTeeVector & Leftwards Harpoon With Barb Down From Bar \\
\hline
U+0295F & ⥟ & {\textbackslash}DownRightTeeVector & Rightwards Harpoon With Barb Down From Bar \\
\hline
U+02960 & ⥠ & {\textbackslash}LeftUpTeeVector & Upwards Harpoon With Barb Left From Bar \\
\hline
U+02961 & ⥡ & {\textbackslash}LeftDownTeeVector & Downwards Harpoon With Barb Left From Bar \\
\hline
U+02962 & ⥢ & {\textbackslash}leftharpoonsupdown & Leftwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Down \\
\hline
U+02963 & ⥣ & {\textbackslash}upharpoonsleftright & Upwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right \\
\hline
U+02964 & ⥤ & {\textbackslash}rightharpoonsupdown & Rightwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Down \\
\hline
U+02965 & ⥥ & {\textbackslash}downharpoonsleftright & Downwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right \\
\hline
U+02966 & ⥦ & {\textbackslash}leftrightharpoonsup & Leftwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Up \\
\hline
U+02967 & ⥧ & {\textbackslash}leftrightharpoonsdown & Leftwards Harpoon With Barb Down Above Rightwards Harpoon With Barb Down \\
\hline
U+02968 & ⥨ & {\textbackslash}rightleftharpoonsup & Rightwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Up \\
\hline
U+02969 & ⥩ & {\textbackslash}rightleftharpoonsdown & Rightwards Harpoon With Barb Down Above Leftwards Harpoon With Barb Down \\
\hline
U+0296A & ⥪ & {\textbackslash}leftharpoonupdash & Leftwards Harpoon With Barb Up Above Long Dash \\
\hline
U+0296B & ⥫ & {\textbackslash}dashleftharpoondown & Leftwards Harpoon With Barb Down Below Long Dash \\
\hline
U+0296C & ⥬ & {\textbackslash}rightharpoonupdash & Rightwards Harpoon With Barb Up Above Long Dash \\
\hline
U+0296D & ⥭ & {\textbackslash}dashrightharpoondown & Rightwards Harpoon With Barb Down Below Long Dash \\
\hline
U+0296E & ⥮ & {\textbackslash}UpEquilibrium & Upwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right \\
\hline
U+0296F & ⥯ & {\textbackslash}ReverseUpEquilibrium & Downwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right \\
\hline
U+02970 & ⥰ & {\textbackslash}RoundImplies & Right Double Arrow With Rounded Head \\
\hline
U+02980 & ⦀ & {\textbackslash}Vvert & Triple Vertical Bar Delimiter \\
\hline
U+02986 & ⦆ & {\textbackslash}Elroang & Right White Parenthesis \\
\hline
U+02999 & ⦙ & {\textbackslash}Elzddfnc & Dotted Fence \\
\hline
U+0299B & ⦛ & {\textbackslash}measuredangleleft & Measured Angle Opening Left \\
\hline
U+0299C & ⦜ & {\textbackslash}Angle & Right Angle Variant With Square \\
\hline
U+0299D & ⦝ & {\textbackslash}rightanglemdot & Measured Right Angle With Dot \\
\hline
U+0299E & ⦞ & {\textbackslash}angles & Angle With S Inside \\
\hline
U+0299F & ⦟ & {\textbackslash}angdnr & Acute Angle \\
\hline
U+029A0 & ⦠ & {\textbackslash}Elzlpargt & Spherical Angle Opening Left \\
\hline
U+029A1 & ⦡ & {\textbackslash}sphericalangleup & Spherical Angle Opening Up \\
\hline
U+029A2 & ⦢ & {\textbackslash}turnangle & Turned Angle \\
\hline
U+029A3 & ⦣ & {\textbackslash}revangle & Reversed Angle \\
\hline
U+029A4 & ⦤ & {\textbackslash}angleubar & Angle With Underbar \\
\hline
U+029A5 & ⦥ & {\textbackslash}revangleubar & Reversed Angle With Underbar \\
\hline
U+029A6 & ⦦ & {\textbackslash}wideangledown & Oblique Angle Opening Up \\
\hline
U+029A7 & ⦧ & {\textbackslash}wideangleup & Oblique Angle Opening Down \\
\hline
U+029A8 & ⦨ & {\textbackslash}measanglerutone & Measured Angle With Open Arm Ending In Arrow Pointing Up And Right \\
\hline
U+029A9 & ⦩ & {\textbackslash}measanglelutonw & Measured Angle With Open Arm Ending In Arrow Pointing Up And Left \\
\hline
U+029AA & ⦪ & {\textbackslash}measanglerdtose & Measured Angle With Open Arm Ending In Arrow Pointing Down And Right \\
\hline
U+029AB & ⦫ & {\textbackslash}measangleldtosw & Measured Angle With Open Arm Ending In Arrow Pointing Down And Left \\
\hline
U+029AC & ⦬ & {\textbackslash}measangleurtone & Measured Angle With Open Arm Ending In Arrow Pointing Right And Up \\
\hline
U+029AD & ⦭ & {\textbackslash}measangleultonw & Measured Angle With Open Arm Ending In Arrow Pointing Left And Up \\
\hline
U+029AE & ⦮ & {\textbackslash}measangledrtose & Measured Angle With Open Arm Ending In Arrow Pointing Right And Down \\
\hline
U+029AF & ⦯ & {\textbackslash}measangledltosw & Measured Angle With Open Arm Ending In Arrow Pointing Left And Down \\
\hline
U+029B0 & ⦰ & {\textbackslash}revemptyset & Reversed Empty Set \\
\hline
U+029B1 & ⦱ & {\textbackslash}emptysetobar & Empty Set With Overbar \\
\hline
U+029B2 & ⦲ & {\textbackslash}emptysetocirc & Empty Set With Small Circle Above \\
\hline
U+029B3 & ⦳ & {\textbackslash}emptysetoarr & Empty Set With Right Arrow Above \\
\hline
U+029B4 & ⦴ & {\textbackslash}emptysetoarrl & Empty Set With Left Arrow Above \\
\hline
U+029B7 & ⦷ & {\textbackslash}circledparallel & Circled Parallel \\
\hline
U+029B8 & ⦸ & {\textbackslash}obslash & Circled Reverse Solidus \\
\hline
U+029BC & ⦼ & {\textbackslash}odotslashdot & Circled Anticlockwise-rotated Division Sign \\
\hline
U+029BE & ⦾ & {\textbackslash}circledwhitebullet & Circled White Bullet \\
\hline
U+029BF & ⦿ & {\textbackslash}circledbullet & Circled Bullet \\
\hline
U+029C0 & ⧀ & {\textbackslash}olessthan & Circled Less-than \\
\hline
U+029C1 & ⧁ & {\textbackslash}ogreaterthan & Circled Greater-than \\
\hline
U+029C4 & ⧄ & {\textbackslash}boxdiag & Squared Rising Diagonal Slash \\
\hline
U+029C5 & ⧅ & {\textbackslash}boxbslash & Squared Falling Diagonal Slash \\
\hline
U+029C6 & ⧆ & {\textbackslash}boxast & Squared Asterisk \\
\hline
U+029C7 & ⧇ & {\textbackslash}boxcircle & Squared Small Circle \\
\hline
U+029CA & ⧊ & {\textbackslash}ElzLap & Triangle With Dot Above \\
\hline
U+029CB & ⧋ & {\textbackslash}Elzdefas & Triangle With Underbar \\
\hline
U+029CF & ⧏ & {\textbackslash}LeftTriangleBar & Left Triangle Beside Vertical Bar \\
\hline
U+029CF + U+00338 & ⧏̸ & {\textbackslash}NotLeftTriangleBar & Left Triangle Beside Vertical Bar + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+029D0 & ⧐ & {\textbackslash}RightTriangleBar & Vertical Bar Beside Right Triangle \\
\hline
U+029D0 + U+00338 & ⧐̸ & {\textbackslash}NotRightTriangleBar & Vertical Bar Beside Right Triangle + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+029DF & ⧟ & {\textbackslash}dualmap & Double-ended Multimap \\
\hline
U+029E1 & ⧡ & {\textbackslash}lrtriangleeq & Increases As \\
\hline
U+029E2 & ⧢ & {\textbackslash}shuffle & Shuffle Product \\
\hline
U+029E3 & ⧣ & {\textbackslash}eparsl & Equals Sign And Slanted Parallel \\
\hline
U+029E4 & ⧤ & {\textbackslash}smeparsl & Equals Sign And Slanted Parallel With Tilde Above \\
\hline
U+029E5 & ⧥ & {\textbackslash}eqvparsl & Identical To And Slanted Parallel \\
\hline
U+029EB & ⧫ & {\textbackslash}blacklozenge & Black Lozenge \\
\hline
U+029F4 & ⧴ & {\textbackslash}RuleDelayed & Rule-delayed \\
\hline
U+029F6 & ⧶ & {\textbackslash}dsol & Solidus With Overbar \\
\hline
U+029F7 & ⧷ & {\textbackslash}rsolbar & Reverse Solidus With Horizontal Stroke \\
\hline
U+029FA & ⧺ & {\textbackslash}doubleplus & Double Plus \\
\hline
U+029FB & ⧻ & {\textbackslash}tripleplus & Triple Plus \\
\hline
U+02A00 & ⨀ & {\textbackslash}bigodot & N-ary Circled Dot Operator \\
\hline
U+02A01 & ⨁ & {\textbackslash}bigoplus & N-ary Circled Plus Operator \\
\hline
U+02A02 & ⨂ & {\textbackslash}bigotimes & N-ary Circled Times Operator \\
\hline
U+02A03 & ⨃ & {\textbackslash}bigcupdot & N-ary Union Operator With Dot \\
\hline
U+02A04 & ⨄ & {\textbackslash}biguplus & N-ary Union Operator With Plus \\
\hline
U+02A05 & ⨅ & {\textbackslash}bigsqcap & N-ary Square Intersection Operator \\
\hline
U+02A06 & ⨆ & {\textbackslash}bigsqcup & N-ary Square Union Operator \\
\hline
U+02A07 & ⨇ & {\textbackslash}conjquant & Two Logical And Operator \\
\hline
U+02A08 & ⨈ & {\textbackslash}disjquant & Two Logical Or Operator \\
\hline
U+02A09 & ⨉ & {\textbackslash}bigtimes & N-ary Times Operator \\
\hline
U+02A0A & ⨊ & {\textbackslash}modtwosum & Modulo Two Sum \\
\hline
U+02A0B & ⨋ & {\textbackslash}sumint & Summation With Integral \\
\hline
U+02A0C & ⨌ & {\textbackslash}iiiint & Quadruple Integral Operator \\
\hline
U+02A0D & ⨍ & {\textbackslash}intbar & Finite Part Integral \\
\hline
U+02A0E & ⨎ & {\textbackslash}intBar & Integral With Double Stroke \\
\hline
U+02A0F & ⨏ & {\textbackslash}clockoint & Integral Average With Slash \\
\hline
U+02A10 & ⨐ & {\textbackslash}cirfnint & Circulation Function \\
\hline
U+02A11 & ⨑ & {\textbackslash}awint & Anticlockwise Integration \\
\hline
U+02A12 & ⨒ & {\textbackslash}rppolint & Line Integration With Rectangular Path Around Pole \\
\hline
U+02A13 & ⨓ & {\textbackslash}scpolint & Line Integration With Semicircular Path Around Pole \\
\hline
U+02A14 & ⨔ & {\textbackslash}npolint & Line Integration Not Including The Pole \\
\hline
U+02A15 & ⨕ & {\textbackslash}pointint & Integral Around A Point Operator \\
\hline
U+02A16 & ⨖ & {\textbackslash}sqrint & Quaternion Integral Operator \\
\hline
U+02A18 & ⨘ & {\textbackslash}intx & Integral With Times Sign \\
\hline
U+02A19 & ⨙ & {\textbackslash}intcap & Integral With Intersection \\
\hline
U+02A1A & ⨚ & {\textbackslash}intcup & Integral With Union \\
\hline
U+02A1B & ⨛ & {\textbackslash}upint & Integral With Overbar \\
\hline
U+02A1C & ⨜ & {\textbackslash}lowint & Integral With Underbar \\
\hline
U+02A1D & ⨝ & {\textbackslash}Join & Join \\
\hline
U+02A22 & ⨢ & {\textbackslash}ringplus & Plus Sign With Small Circle Above \\
\hline
U+02A23 & ⨣ & {\textbackslash}plushat & Plus Sign With Circumflex Accent Above \\
\hline
U+02A24 & ⨤ & {\textbackslash}simplus & Plus Sign With Tilde Above \\
\hline
U+02A25 & ⨥ & {\textbackslash}plusdot & Plus Sign With Dot Below \\
\hline
U+02A26 & ⨦ & {\textbackslash}plussim & Plus Sign With Tilde Below \\
\hline
U+02A27 & ⨧ & {\textbackslash}plussubtwo & Plus Sign With Subscript Two \\
\hline
U+02A28 & ⨨ & {\textbackslash}plustrif & Plus Sign With Black Triangle \\
\hline
U+02A29 & ⨩ & {\textbackslash}commaminus & Minus Sign With Comma Above \\
\hline
U+02A2A & ⨪ & {\textbackslash}minusdot & Minus Sign With Dot Below \\
\hline
U+02A2B & ⨫ & {\textbackslash}minusfdots & Minus Sign With Falling Dots \\
\hline
U+02A2C & ⨬ & {\textbackslash}minusrdots & Minus Sign With Rising Dots \\
\hline
U+02A2D & ⨭ & {\textbackslash}opluslhrim & Plus Sign In Left Half Circle \\
\hline
U+02A2E & ⨮ & {\textbackslash}oplusrhrim & Plus Sign In Right Half Circle \\
\hline
U+02A2F & ⨯ & {\textbackslash}ElzTimes & Vector Or Cross Product \\
\hline
U+02A30 & ⨰ & {\textbackslash}dottimes & Multiplication Sign With Dot Above \\
\hline
U+02A31 & ⨱ & {\textbackslash}timesbar & Multiplication Sign With Underbar \\
\hline
U+02A32 & ⨲ & {\textbackslash}btimes & Semidirect Product With Bottom Closed \\
\hline
U+02A33 & ⨳ & {\textbackslash}smashtimes & Smash Product \\
\hline
U+02A34 & ⨴ & {\textbackslash}otimeslhrim & Multiplication Sign In Left Half Circle \\
\hline
U+02A35 & ⨵ & {\textbackslash}otimesrhrim & Multiplication Sign In Right Half Circle \\
\hline
U+02A36 & ⨶ & {\textbackslash}otimeshat & Circled Multiplication Sign With Circumflex Accent \\
\hline
U+02A37 & ⨷ & {\textbackslash}Otimes & Multiplication Sign In Double Circle \\
\hline
U+02A38 & ⨸ & {\textbackslash}odiv & Circled Division Sign \\
\hline
U+02A39 & ⨹ & {\textbackslash}triangleplus & Plus Sign In Triangle \\
\hline
U+02A3A & ⨺ & {\textbackslash}triangleminus & Minus Sign In Triangle \\
\hline
U+02A3B & ⨻ & {\textbackslash}triangletimes & Multiplication Sign In Triangle \\
\hline
U+02A3C & ⨼ & {\textbackslash}intprod & Interior Product \\
\hline
U+02A3D & ⨽ & {\textbackslash}intprodr & Righthand Interior Product \\
\hline
U+02A3F & ⨿ & {\textbackslash}amalg & Amalgamation Or Coproduct \\
\hline
U+02A40 & ⩀ & {\textbackslash}capdot & Intersection With Dot \\
\hline
U+02A41 & ⩁ & {\textbackslash}uminus & Union With Minus Sign \\
\hline
U+02A42 & ⩂ & {\textbackslash}barcup & Union With Overbar \\
\hline
U+02A43 & ⩃ & {\textbackslash}barcap & Intersection With Overbar \\
\hline
U+02A44 & ⩄ & {\textbackslash}capwedge & Intersection With Logical And \\
\hline
U+02A45 & ⩅ & {\textbackslash}cupvee & Union With Logical Or \\
\hline
U+02A4A & ⩊ & {\textbackslash}twocups & Union Beside And Joined With Union \\
\hline
U+02A4B & ⩋ & {\textbackslash}twocaps & Intersection Beside And Joined With Intersection \\
\hline
U+02A4C & ⩌ & {\textbackslash}closedvarcup & Closed Union With Serifs \\
\hline
U+02A4D & ⩍ & {\textbackslash}closedvarcap & Closed Intersection With Serifs \\
\hline
U+02A4E & ⩎ & {\textbackslash}Sqcap & Double Square Intersection \\
\hline
U+02A4F & ⩏ & {\textbackslash}Sqcup & Double Square Union \\
\hline
U+02A50 & ⩐ & {\textbackslash}closedvarcupsmashprod & Closed Union With Serifs And Smash Product \\
\hline
U+02A51 & ⩑ & {\textbackslash}wedgeodot & Logical And With Dot Above \\
\hline
U+02A52 & ⩒ & {\textbackslash}veeodot & Logical Or With Dot Above \\
\hline
U+02A53 & ⩓ & {\textbackslash}ElzAnd & Double Logical And \\
\hline
U+02A54 & ⩔ & {\textbackslash}ElzOr & Double Logical Or \\
\hline
U+02A55 & ⩕ & {\textbackslash}wedgeonwedge & Two Intersecting Logical And \\
\hline
U+02A56 & ⩖ & {\textbackslash}ElOr & Two Intersecting Logical Or \\
\hline
U+02A57 & ⩗ & {\textbackslash}bigslopedvee & Sloping Large Or \\
\hline
U+02A58 & ⩘ & {\textbackslash}bigslopedwedge & Sloping Large And \\
\hline
U+02A5A & ⩚ & {\textbackslash}wedgemidvert & Logical And With Middle Stem \\
\hline
U+02A5B & ⩛ & {\textbackslash}veemidvert & Logical Or With Middle Stem \\
\hline
U+02A5C & ⩜ & {\textbackslash}midbarwedge & Logical And With Horizontal Dash \\
\hline
U+02A5D & ⩝ & {\textbackslash}midbarvee & Logical Or With Horizontal Dash \\
\hline
U+02A5E & ⩞ & {\textbackslash}perspcorrespond & Logical And With Double Overbar \\
\hline
U+02A5F & ⩟ & {\textbackslash}Elzminhat & Logical And With Underbar \\
\hline
U+02A60 & ⩠ & {\textbackslash}wedgedoublebar & Logical And With Double Underbar \\
\hline
U+02A61 & ⩡ & {\textbackslash}varveebar & Small Vee With Underbar \\
\hline
U+02A62 & ⩢ & {\textbackslash}doublebarvee & Logical Or With Double Overbar \\
\hline
U+02A63 & ⩣ & {\textbackslash}veedoublebar & Logical Or With Double Underbar \\
\hline
U+02A66 & ⩦ & {\textbackslash}eqdot & Equals Sign With Dot Below \\
\hline
U+02A67 & ⩧ & {\textbackslash}dotequiv & Identical With Dot Above \\
\hline
U+02A6A & ⩪ & {\textbackslash}dotsim & Tilde Operator With Dot Above \\
\hline
U+02A6B & ⩫ & {\textbackslash}simrdots & Tilde Operator With Rising Dots \\
\hline
U+02A6C & ⩬ & {\textbackslash}simminussim & Similar Minus Similar \\
\hline
U+02A6D & ⩭ & {\textbackslash}congdot & Congruent With Dot Above \\
\hline
U+02A6E & ⩮ & {\textbackslash}asteq & Equals With Asterisk \\
\hline
U+02A6F & ⩯ & {\textbackslash}hatapprox & Almost Equal To With Circumflex Accent \\
\hline
U+02A70 & ⩰ & {\textbackslash}approxeqq & Approximately Equal Or Equal To \\
\hline
U+02A71 & ⩱ & {\textbackslash}eqqplus & Equals Sign Above Plus Sign \\
\hline
U+02A72 & ⩲ & {\textbackslash}pluseqq & Plus Sign Above Equals Sign \\
\hline
U+02A73 & ⩳ & {\textbackslash}eqqsim & Equals Sign Above Tilde Operator \\
\hline
U+02A74 & ⩴ & {\textbackslash}Coloneq & Double Colon Equal \\
\hline
U+02A75 & ⩵ & {\textbackslash}Equal & Two Consecutive Equals Signs \\
\hline
U+02A76 & ⩶ & {\textbackslash}eqeqeq & Three Consecutive Equals Signs \\
\hline
U+02A77 & ⩷ & {\textbackslash}ddotseq & Equals Sign With Two Dots Above And Two Dots Below \\
\hline
U+02A78 & ⩸ & {\textbackslash}equivDD & Equivalent With Four Dots Above \\
\hline
U+02A79 & ⩹ & {\textbackslash}ltcir & Less-than With Circle Inside \\
\hline
U+02A7A & ⩺ & {\textbackslash}gtcir & Greater-than With Circle Inside \\
\hline
U+02A7B & ⩻ & {\textbackslash}ltquest & Less-than With Question Mark Above \\
\hline
U+02A7C & ⩼ & {\textbackslash}gtquest & Greater-than With Question Mark Above \\
\hline
U+02A7D & ⩽ & {\textbackslash}leqslant & Less-than Or Slanted Equal To \\
\hline
U+02A7D + U+00338 & ⩽̸ & {\textbackslash}nleqslant & Less-than Or Slanted Equal To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02A7E & ⩾ & {\textbackslash}geqslant & Greater-than Or Slanted Equal To \\
\hline
U+02A7E + U+00338 & ⩾̸ & {\textbackslash}ngeqslant & Greater-than Or Slanted Equal To + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02A7F & ⩿ & {\textbackslash}lesdot & Less-than Or Slanted Equal To With Dot Inside \\
\hline
U+02A80 & ⪀ & {\textbackslash}gesdot & Greater-than Or Slanted Equal To With Dot Inside \\
\hline
U+02A81 & ⪁ & {\textbackslash}lesdoto & Less-than Or Slanted Equal To With Dot Above \\
\hline
U+02A82 & ⪂ & {\textbackslash}gesdoto & Greater-than Or Slanted Equal To With Dot Above \\
\hline
U+02A83 & ⪃ & {\textbackslash}lesdotor & Less-than Or Slanted Equal To With Dot Above Right \\
\hline
U+02A84 & ⪄ & {\textbackslash}gesdotol & Greater-than Or Slanted Equal To With Dot Above Left \\
\hline
U+02A85 & ⪅ & {\textbackslash}lessapprox & Less-than Or Approximate \\
\hline
U+02A86 & ⪆ & {\textbackslash}gtrapprox & Greater-than Or Approximate \\
\hline
U+02A87 & ⪇ & {\textbackslash}lneq & Less-than And Single-line Not Equal To \\
\hline
U+02A88 & ⪈ & {\textbackslash}gneq & Greater-than And Single-line Not Equal To \\
\hline
U+02A89 & ⪉ & {\textbackslash}lnapprox & Less-than And Not Approximate \\
\hline
U+02A8A & ⪊ & {\textbackslash}gnapprox & Greater-than And Not Approximate \\
\hline
U+02A8B & ⪋ & {\textbackslash}lesseqqgtr & Less-than Above Double-line Equal Above Greater-than \\
\hline
U+02A8C & ⪌ & {\textbackslash}gtreqqless & Greater-than Above Double-line Equal Above Less-than \\
\hline
U+02A8D & ⪍ & {\textbackslash}lsime & Less-than Above Similar Or Equal \\
\hline
U+02A8E & ⪎ & {\textbackslash}gsime & Greater-than Above Similar Or Equal \\
\hline
U+02A8F & ⪏ & {\textbackslash}lsimg & Less-than Above Similar Above Greater-than \\
\hline
U+02A90 & ⪐ & {\textbackslash}gsiml & Greater-than Above Similar Above Less-than \\
\hline
U+02A91 & ⪑ & {\textbackslash}lgE & Less-than Above Greater-than Above Double-line Equal \\
\hline
U+02A92 & ⪒ & {\textbackslash}glE & Greater-than Above Less-than Above Double-line Equal \\
\hline
U+02A93 & ⪓ & {\textbackslash}lesges & Less-than Above Slanted Equal Above Greater-than Above Slanted Equal \\
\hline
U+02A94 & ⪔ & {\textbackslash}gesles & Greater-than Above Slanted Equal Above Less-than Above Slanted Equal \\
\hline
U+02A95 & ⪕ & {\textbackslash}eqslantless & Slanted Equal To Or Less-than \\
\hline
U+02A96 & ⪖ & {\textbackslash}eqslantgtr & Slanted Equal To Or Greater-than \\
\hline
U+02A97 & ⪗ & {\textbackslash}elsdot & Slanted Equal To Or Less-than With Dot Inside \\
\hline
U+02A98 & ⪘ & {\textbackslash}egsdot & Slanted Equal To Or Greater-than With Dot Inside \\
\hline
U+02A99 & ⪙ & {\textbackslash}eqqless & Double-line Equal To Or Less-than \\
\hline
U+02A9A & ⪚ & {\textbackslash}eqqgtr & Double-line Equal To Or Greater-than \\
\hline
U+02A9B & ⪛ & {\textbackslash}eqqslantless & Double-line Slanted Equal To Or Less-than \\
\hline
U+02A9C & ⪜ & {\textbackslash}eqqslantgtr & Double-line Slanted Equal To Or Greater-than \\
\hline
U+02A9D & ⪝ & {\textbackslash}simless & Similar Or Less-than \\
\hline
U+02A9E & ⪞ & {\textbackslash}simgtr & Similar Or Greater-than \\
\hline
U+02A9F & ⪟ & {\textbackslash}simlE & Similar Above Less-than Above Equals Sign \\
\hline
U+02AA0 & ⪠ & {\textbackslash}simgE & Similar Above Greater-than Above Equals Sign \\
\hline
U+02AA1 & ⪡ & {\textbackslash}NestedLessLess & Double Nested Less-than \\
\hline
U+02AA1 + U+00338 & ⪡̸ & {\textbackslash}NotNestedLessLess & Double Nested Less-than + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AA2 & ⪢ & {\textbackslash}NestedGreaterGreater & Double Nested Greater-than \\
\hline
U+02AA2 + U+00338 & ⪢̸ & {\textbackslash}NotNestedGreaterGreater & Double Nested Greater-than + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AA3 & ⪣ & {\textbackslash}partialmeetcontraction & Double Nested Less-than With Underbar \\
\hline
U+02AA4 & ⪤ & {\textbackslash}glj & Greater-than Overlapping Less-than \\
\hline
U+02AA5 & ⪥ & {\textbackslash}gla & Greater-than Beside Less-than \\
\hline
U+02AA6 & ⪦ & {\textbackslash}ltcc & Less-than Closed By Curve \\
\hline
U+02AA7 & ⪧ & {\textbackslash}gtcc & Greater-than Closed By Curve \\
\hline
U+02AA8 & ⪨ & {\textbackslash}lescc & Less-than Closed By Curve Above Slanted Equal \\
\hline
U+02AA9 & ⪩ & {\textbackslash}gescc & Greater-than Closed By Curve Above Slanted Equal \\
\hline
U+02AAA & ⪪ & {\textbackslash}smt & Smaller Than \\
\hline
U+02AAB & ⪫ & {\textbackslash}lat & Larger Than \\
\hline
U+02AAC & ⪬ & {\textbackslash}smte & Smaller Than Or Equal To \\
\hline
U+02AAD & ⪭ & {\textbackslash}late & Larger Than Or Equal To \\
\hline
U+02AAE & ⪮ & {\textbackslash}bumpeqq & Equals Sign With Bumpy Above \\
\hline
U+02AAF & ⪯ & {\textbackslash}preceq & Precedes Above Single-line Equals Sign \\
\hline
U+02AAF + U+00338 & ⪯̸ & {\textbackslash}npreceq & Precedes Above Single-line Equals Sign + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AB0 & ⪰ & {\textbackslash}succeq & Succeeds Above Single-line Equals Sign \\
\hline
U+02AB0 + U+00338 & ⪰̸ & {\textbackslash}nsucceq & Succeeds Above Single-line Equals Sign + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AB1 & ⪱ & {\textbackslash}precneq & Precedes Above Single-line Not Equal To \\
\hline
U+02AB2 & ⪲ & {\textbackslash}succneq & Succeeds Above Single-line Not Equal To \\
\hline
U+02AB3 & ⪳ & {\textbackslash}preceqq & Precedes Above Equals Sign \\
\hline
U+02AB4 & ⪴ & {\textbackslash}succeqq & Succeeds Above Equals Sign \\
\hline
U+02AB5 & ⪵ & {\textbackslash}precneqq & Precedes Above Not Equal To \\
\hline
U+02AB6 & ⪶ & {\textbackslash}succneqq & Succeeds Above Not Equal To \\
\hline
U+02AB7 & ⪷ & {\textbackslash}precapprox & Precedes Above Almost Equal To \\
\hline
U+02AB8 & ⪸ & {\textbackslash}succapprox & Succeeds Above Almost Equal To \\
\hline
U+02AB9 & ⪹ & {\textbackslash}precnapprox & Precedes Above Not Almost Equal To \\
\hline
U+02ABA & ⪺ & {\textbackslash}succnapprox & Succeeds Above Not Almost Equal To \\
\hline
U+02ABB & ⪻ & {\textbackslash}Prec & Double Precedes \\
\hline
U+02ABC & ⪼ & {\textbackslash}Succ & Double Succeeds \\
\hline
U+02ABD & ⪽ & {\textbackslash}subsetdot & Subset With Dot \\
\hline
U+02ABE & ⪾ & {\textbackslash}supsetdot & Superset With Dot \\
\hline
U+02ABF & ⪿ & {\textbackslash}subsetplus & Subset With Plus Sign Below \\
\hline
U+02AC0 & ⫀ & {\textbackslash}supsetplus & Superset With Plus Sign Below \\
\hline
U+02AC1 & ⫁ & {\textbackslash}submult & Subset With Multiplication Sign Below \\
\hline
U+02AC2 & ⫂ & {\textbackslash}supmult & Superset With Multiplication Sign Below \\
\hline
U+02AC3 & ⫃ & {\textbackslash}subedot & Subset Of Or Equal To With Dot Above \\
\hline
U+02AC4 & ⫄ & {\textbackslash}supedot & Superset Of Or Equal To With Dot Above \\
\hline
U+02AC5 & ⫅ & {\textbackslash}subseteqq & Subset Of Above Equals Sign \\
\hline
U+02AC5 + U+00338 & ⫅̸ & {\textbackslash}nsubseteqq & Subset Of Above Equals Sign + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AC6 & ⫆ & {\textbackslash}supseteqq & Superset Of Above Equals Sign \\
\hline
U+02AC6 + U+00338 & ⫆̸ & {\textbackslash}nsupseteqq & Superset Of Above Equals Sign + Combining Long Solidus Overlay / Non-spacing Long Slash Overlay \\
\hline
U+02AC7 & ⫇ & {\textbackslash}subsim & Subset Of Above Tilde Operator \\
\hline
U+02AC8 & ⫈ & {\textbackslash}supsim & Superset Of Above Tilde Operator \\
\hline
U+02AC9 & ⫉ & {\textbackslash}subsetapprox & Subset Of Above Almost Equal To \\
\hline
U+02ACA & ⫊ & {\textbackslash}supsetapprox & Superset Of Above Almost Equal To \\
\hline
U+02ACB & ⫋ & {\textbackslash}subsetneqq & Subset Of Above Not Equal To \\
\hline
U+02ACC & ⫌ & {\textbackslash}supsetneqq & Superset Of Above Not Equal To \\
\hline
U+02ACD & ⫍ & {\textbackslash}lsqhook & Square Left Open Box Operator \\
\hline
U+02ACE & ⫎ & {\textbackslash}rsqhook & Square Right Open Box Operator \\
\hline
U+02ACF & ⫏ & {\textbackslash}csub & Closed Subset \\
\hline
U+02AD0 & ⫐ & {\textbackslash}csup & Closed Superset \\
\hline
U+02AD1 & ⫑ & {\textbackslash}csube & Closed Subset Or Equal To \\
\hline
U+02AD2 & ⫒ & {\textbackslash}csupe & Closed Superset Or Equal To \\
\hline
U+02AD3 & ⫓ & {\textbackslash}subsup & Subset Above Superset \\
\hline
U+02AD4 & ⫔ & {\textbackslash}supsub & Superset Above Subset \\
\hline
U+02AD5 & ⫕ & {\textbackslash}subsub & Subset Above Subset \\
\hline
U+02AD6 & ⫖ & {\textbackslash}supsup & Superset Above Superset \\
\hline
U+02AD7 & ⫗ & {\textbackslash}suphsub & Superset Beside Subset \\
\hline
U+02AD8 & ⫘ & {\textbackslash}supdsub & Superset Beside And Joined By Dash With Subset \\
\hline
U+02AD9 & ⫙ & {\textbackslash}forkv & Element Of Opening Downwards \\
\hline
U+02ADB & ⫛ & {\textbackslash}mlcp & Transversal Intersection \\
\hline
U+02ADC & ⫝̸ & {\textbackslash}forks & Forking \\
\hline
U+02ADD & ⫝ & {\textbackslash}forksnot & Nonforking \\
\hline
U+02AE3 & ⫣ & {\textbackslash}dashV & Double Vertical Bar Left Turnstile \\
\hline
U+02AE4 & ⫤ & {\textbackslash}Dashv & Vertical Bar Double Left Turnstile \\
\hline
U+02AF4 & ⫴ & {\textbackslash}interleave & Triple Vertical Bar Binary Relation \\
\hline
U+02AF6 & ⫶ & {\textbackslash}Elztdcol & Triple Colon Operator \\
\hline
U+02AF7 & ⫷ & {\textbackslash}lllnest & Triple Nested Less-than \\
\hline
U+02AF8 & ⫸ & {\textbackslash}gggnest & Triple Nested Greater-than \\
\hline
U+02AF9 & ⫹ & {\textbackslash}leqqslant & Double-line Slanted Less-than Or Equal To \\
\hline
U+02AFA & ⫺ & {\textbackslash}geqqslant & Double-line Slanted Greater-than Or Equal To \\
\hline
U+02B05 & ⬅ & {\textbackslash}:arrow\_left: & Leftwards Black Arrow \\
\hline
U+02B06 & ⬆ & {\textbackslash}:arrow\_up: & Upwards Black Arrow \\
\hline
U+02B07 & ⬇ & {\textbackslash}:arrow\_down: & Downwards Black Arrow \\
\hline
U+02B12 & ⬒ & {\textbackslash}squaretopblack & Square With Top Half Black \\
\hline
U+02B13 & ⬓ & {\textbackslash}squarebotblack & Square With Bottom Half Black \\
\hline
U+02B14 & ⬔ & {\textbackslash}squareurblack & Square With Upper Right Diagonal Half Black \\
\hline
U+02B15 & ⬕ & {\textbackslash}squarellblack & Square With Lower Left Diagonal Half Black \\
\hline
U+02B16 & ⬖ & {\textbackslash}diamondleftblack & Diamond With Left Half Black \\
\hline
U+02B17 & ⬗ & {\textbackslash}diamondrightblack & Diamond With Right Half Black \\
\hline
U+02B18 & ⬘ & {\textbackslash}diamondtopblack & Diamond With Top Half Black \\
\hline
U+02B19 & ⬙ & {\textbackslash}diamondbotblack & Diamond With Bottom Half Black \\
\hline
U+02B1A & ⬚ & {\textbackslash}dottedsquare & Dotted Square \\
\hline
U+02B1B & ⬛ & {\textbackslash}lgblksquare, {\textbackslash}:black\_large\_square: & Black Large Square \\
\hline
U+02B1C & ⬜ & {\textbackslash}lgwhtsquare, {\textbackslash}:white\_large\_square: & White Large Square \\
\hline
U+02B1D & ⬝ & {\textbackslash}vysmblksquare & Black Very Small Square \\
\hline
U+02B1E & ⬞ & {\textbackslash}vysmwhtsquare & White Very Small Square \\
\hline
U+02B1F & ⬟ & {\textbackslash}pentagonblack & Black Pentagon \\
\hline
U+02B20 & ⬠ & {\textbackslash}pentagon & White Pentagon \\
\hline
U+02B21 & ⬡ & {\textbackslash}varhexagon & White Hexagon \\
\hline
U+02B22 & ⬢ & {\textbackslash}varhexagonblack & Black Hexagon \\
\hline
U+02B23 & ⬣ & {\textbackslash}hexagonblack & Horizontal Black Hexagon \\
\hline
U+02B24 & ⬤ & {\textbackslash}lgblkcircle & Black Large Circle \\
\hline
U+02B25 & ⬥ & {\textbackslash}mdblkdiamond & Black Medium Diamond \\
\hline
U+02B26 & ⬦ & {\textbackslash}mdwhtdiamond & White Medium Diamond \\
\hline
U+02B27 & ⬧ & {\textbackslash}mdblklozenge & Black Medium Lozenge \\
\hline
U+02B28 & ⬨ & {\textbackslash}mdwhtlozenge & White Medium Lozenge \\
\hline
U+02B29 & ⬩ & {\textbackslash}smblkdiamond & Black Small Diamond \\
\hline
U+02B2A & ⬪ & {\textbackslash}smblklozenge & Black Small Lozenge \\
\hline
U+02B2B & ⬫ & {\textbackslash}smwhtlozenge & White Small Lozenge \\
\hline
U+02B2C & ⬬ & {\textbackslash}blkhorzoval & Black Horizontal Ellipse \\
\hline
U+02B2D & ⬭ & {\textbackslash}whthorzoval & White Horizontal Ellipse \\
\hline
U+02B2E & ⬮ & {\textbackslash}blkvertoval & Black Vertical Ellipse \\
\hline
U+02B2F & ⬯ & {\textbackslash}whtvertoval & White Vertical Ellipse \\
\hline
U+02B30 & ⬰ & {\textbackslash}circleonleftarrow & Left Arrow With Small Circle \\
\hline
U+02B31 & ⬱ & {\textbackslash}leftthreearrows & Three Leftwards Arrows \\
\hline
U+02B32 & ⬲ & {\textbackslash}leftarrowonoplus & Left Arrow With Circled Plus \\
\hline
U+02B33 & ⬳ & {\textbackslash}longleftsquigarrow & Long Leftwards Squiggle Arrow \\
\hline
U+02B34 & ⬴ & {\textbackslash}nvtwoheadleftarrow & Leftwards Two-headed Arrow With Vertical Stroke \\
\hline
U+02B35 & ⬵ & {\textbackslash}nVtwoheadleftarrow & Leftwards Two-headed Arrow With Double Vertical Stroke \\
\hline
U+02B36 & ⬶ & {\textbackslash}twoheadmapsfrom & Leftwards Two-headed Arrow From Bar \\
\hline
U+02B37 & ⬷ & {\textbackslash}twoheadleftdbkarrow & Leftwards Two-headed Triple Dash Arrow \\
\hline
U+02B38 & ⬸ & {\textbackslash}leftdotarrow & Leftwards Arrow With Dotted Stem \\
\hline
U+02B39 & ⬹ & {\textbackslash}nvleftarrowtail & Leftwards Arrow With Tail With Vertical Stroke \\
\hline
U+02B3A & ⬺ & {\textbackslash}nVleftarrowtail & Leftwards Arrow With Tail With Double Vertical Stroke \\
\hline
U+02B3B & ⬻ & {\textbackslash}twoheadleftarrowtail & Leftwards Two-headed Arrow With Tail \\
\hline
U+02B3C & ⬼ & {\textbackslash}nvtwoheadleftarrowtail & Leftwards Two-headed Arrow With Tail With Vertical Stroke \\
\hline
U+02B3D & ⬽ & {\textbackslash}nVtwoheadleftarrowtail & Leftwards Two-headed Arrow With Tail With Double Vertical Stroke \\
\hline
U+02B3E & ⬾ & {\textbackslash}leftarrowx & Leftwards Arrow Through X \\
\hline
U+02B3F & ⬿ & {\textbackslash}leftcurvedarrow & Wave Arrow Pointing Directly Left \\
\hline
U+02B40 & ⭀ & {\textbackslash}equalleftarrow & Equals Sign Above Leftwards Arrow \\
\hline
U+02B41 & ⭁ & {\textbackslash}bsimilarleftarrow & Reverse Tilde Operator Above Leftwards Arrow \\
\hline
U+02B42 & ⭂ & {\textbackslash}leftarrowbackapprox & Leftwards Arrow Above Reverse Almost Equal To \\
\hline
U+02B43 & ⭃ & {\textbackslash}rightarrowgtr & Rightwards Arrow Through Greater-than \\
\hline
U+02B44 & ⭄ & {\textbackslash}rightarrowsupset & Rightwards Arrow Through Superset \\
\hline
U+02B45 & ⭅ & {\textbackslash}LLeftarrow & Leftwards Quadruple Arrow \\
\hline
U+02B46 & ⭆ & {\textbackslash}RRightarrow & Rightwards Quadruple Arrow \\
\hline
U+02B47 & ⭇ & {\textbackslash}bsimilarrightarrow & Reverse Tilde Operator Above Rightwards Arrow \\
\hline
U+02B48 & ⭈ & {\textbackslash}rightarrowbackapprox & Rightwards Arrow Above Reverse Almost Equal To \\
\hline
U+02B49 & ⭉ & {\textbackslash}similarleftarrow & Tilde Operator Above Leftwards Arrow \\
\hline
U+02B4A & ⭊ & {\textbackslash}leftarrowapprox & Leftwards Arrow Above Almost Equal To \\
\hline
U+02B4B & ⭋ & {\textbackslash}leftarrowbsimilar & Leftwards Arrow Above Reverse Tilde Operator \\
\hline
U+02B4C & ⭌ & {\textbackslash}rightarrowbsimilar & Rightwards Arrow Above Reverse Tilde Operator \\
\hline
U+02B50 & ⭐ & {\textbackslash}medwhitestar, {\textbackslash}:star: & White Medium Star \\
\hline
U+02B51 & ⭑ & {\textbackslash}medblackstar & Black Small Star \\
\hline
U+02B52 & ⭒ & {\textbackslash}smwhitestar & White Small Star \\
\hline
U+02B53 & ⭓ & {\textbackslash}rightpentagonblack & Black Right-pointing Pentagon \\
\hline
U+02B54 & ⭔ & {\textbackslash}rightpentagon & White Right-pointing Pentagon \\
\hline
U+02B55 & ⭕ & {\textbackslash}:o: & Heavy Large Circle \\
\hline
U+02C7C & ⱼ & {\textbackslash}\_j & Latin Subscript Small Letter J \\
\hline
U+02C7D & ⱽ & {\textbackslash}{\textasciicircum}V & Modifier Letter Capital V \\
\hline
U+03012 & 〒 & {\textbackslash}postalmark & Postal Mark \\
\hline
U+03030 & 〰 & {\textbackslash}:wavy\_dash: & Wavy Dash \\
\hline
U+0303D & 〽 & {\textbackslash}:part\_alternation\_mark: & Part Alternation Mark \\
\hline
U+03297 & ㊗ & {\textbackslash}:congratulations: & Circled Ideograph Congratulation \\
\hline
U+03299 & ㊙ & {\textbackslash}:secret: & Circled Ideograph Secret \\
\hline
U+1D400 & 𝐀 & {\textbackslash}mbfA & Mathematical Bold Capital A \\
\hline
U+1D401 & 𝐁 & {\textbackslash}mbfB & Mathematical Bold Capital B \\
\hline
U+1D402 & 𝐂 & {\textbackslash}mbfC & Mathematical Bold Capital C \\
\hline
U+1D403 & 𝐃 & {\textbackslash}mbfD & Mathematical Bold Capital D \\
\hline
U+1D404 & 𝐄 & {\textbackslash}mbfE & Mathematical Bold Capital E \\
\hline
U+1D405 & 𝐅 & {\textbackslash}mbfF & Mathematical Bold Capital F \\
\hline
U+1D406 & 𝐆 & {\textbackslash}mbfG & Mathematical Bold Capital G \\
\hline
U+1D407 & 𝐇 & {\textbackslash}mbfH & Mathematical Bold Capital H \\
\hline
U+1D408 & 𝐈 & {\textbackslash}mbfI & Mathematical Bold Capital I \\
\hline
U+1D409 & 𝐉 & {\textbackslash}mbfJ & Mathematical Bold Capital J \\
\hline
U+1D40A & 𝐊 & {\textbackslash}mbfK & Mathematical Bold Capital K \\
\hline
U+1D40B & 𝐋 & {\textbackslash}mbfL & Mathematical Bold Capital L \\
\hline
U+1D40C & 𝐌 & {\textbackslash}mbfM & Mathematical Bold Capital M \\
\hline
U+1D40D & 𝐍 & {\textbackslash}mbfN & Mathematical Bold Capital N \\
\hline
U+1D40E & 𝐎 & {\textbackslash}mbfO & Mathematical Bold Capital O \\
\hline
U+1D40F & 𝐏 & {\textbackslash}mbfP & Mathematical Bold Capital P \\
\hline
U+1D410 & 𝐐 & {\textbackslash}mbfQ & Mathematical Bold Capital Q \\
\hline
U+1D411 & 𝐑 & {\textbackslash}mbfR & Mathematical Bold Capital R \\
\hline
U+1D412 & 𝐒 & {\textbackslash}mbfS & Mathematical Bold Capital S \\
\hline
U+1D413 & 𝐓 & {\textbackslash}mbfT & Mathematical Bold Capital T \\
\hline
U+1D414 & 𝐔 & {\textbackslash}mbfU & Mathematical Bold Capital U \\
\hline
U+1D415 & 𝐕 & {\textbackslash}mbfV & Mathematical Bold Capital V \\
\hline
U+1D416 & 𝐖 & {\textbackslash}mbfW & Mathematical Bold Capital W \\
\hline
U+1D417 & 𝐗 & {\textbackslash}mbfX & Mathematical Bold Capital X \\
\hline
U+1D418 & 𝐘 & {\textbackslash}mbfY & Mathematical Bold Capital Y \\
\hline
U+1D419 & 𝐙 & {\textbackslash}mbfZ & Mathematical Bold Capital Z \\
\hline
U+1D41A & 𝐚 & {\textbackslash}mbfa & Mathematical Bold Small A \\
\hline
U+1D41B & 𝐛 & {\textbackslash}mbfb & Mathematical Bold Small B \\
\hline
U+1D41C & 𝐜 & {\textbackslash}mbfc & Mathematical Bold Small C \\
\hline
U+1D41D & 𝐝 & {\textbackslash}mbfd & Mathematical Bold Small D \\
\hline
U+1D41E & 𝐞 & {\textbackslash}mbfe & Mathematical Bold Small E \\
\hline
U+1D41F & 𝐟 & {\textbackslash}mbff & Mathematical Bold Small F \\
\hline
U+1D420 & 𝐠 & {\textbackslash}mbfg & Mathematical Bold Small G \\
\hline
U+1D421 & 𝐡 & {\textbackslash}mbfh & Mathematical Bold Small H \\
\hline
U+1D422 & 𝐢 & {\textbackslash}mbfi & Mathematical Bold Small I \\
\hline
U+1D423 & 𝐣 & {\textbackslash}mbfj & Mathematical Bold Small J \\
\hline
U+1D424 & 𝐤 & {\textbackslash}mbfk & Mathematical Bold Small K \\
\hline
U+1D425 & 𝐥 & {\textbackslash}mbfl & Mathematical Bold Small L \\
\hline
U+1D426 & 𝐦 & {\textbackslash}mbfm & Mathematical Bold Small M \\
\hline
U+1D427 & 𝐧 & {\textbackslash}mbfn & Mathematical Bold Small N \\
\hline
U+1D428 & 𝐨 & {\textbackslash}mbfo & Mathematical Bold Small O \\
\hline
U+1D429 & 𝐩 & {\textbackslash}mbfp & Mathematical Bold Small P \\
\hline
U+1D42A & 𝐪 & {\textbackslash}mbfq & Mathematical Bold Small Q \\
\hline
U+1D42B & 𝐫 & {\textbackslash}mbfr & Mathematical Bold Small R \\
\hline
U+1D42C & 𝐬 & {\textbackslash}mbfs & Mathematical Bold Small S \\
\hline
U+1D42D & 𝐭 & {\textbackslash}mbft & Mathematical Bold Small T \\
\hline
U+1D42E & 𝐮 & {\textbackslash}mbfu & Mathematical Bold Small U \\
\hline
U+1D42F & 𝐯 & {\textbackslash}mbfv & Mathematical Bold Small V \\
\hline
U+1D430 & 𝐰 & {\textbackslash}mbfw & Mathematical Bold Small W \\
\hline
U+1D431 & 𝐱 & {\textbackslash}mbfx & Mathematical Bold Small X \\
\hline
U+1D432 & 𝐲 & {\textbackslash}mbfy & Mathematical Bold Small Y \\
\hline
U+1D433 & 𝐳 & {\textbackslash}mbfz & Mathematical Bold Small Z \\
\hline
U+1D434 & 𝐴 & {\textbackslash}mitA & Mathematical Italic Capital A \\
\hline
U+1D435 & 𝐵 & {\textbackslash}mitB & Mathematical Italic Capital B \\
\hline
U+1D436 & 𝐶 & {\textbackslash}mitC & Mathematical Italic Capital C \\
\hline
U+1D437 & 𝐷 & {\textbackslash}mitD & Mathematical Italic Capital D \\
\hline
U+1D438 & 𝐸 & {\textbackslash}mitE & Mathematical Italic Capital E \\
\hline
U+1D439 & 𝐹 & {\textbackslash}mitF & Mathematical Italic Capital F \\
\hline
U+1D43A & 𝐺 & {\textbackslash}mitG & Mathematical Italic Capital G \\
\hline
U+1D43B & 𝐻 & {\textbackslash}mitH & Mathematical Italic Capital H \\
\hline
U+1D43C & 𝐼 & {\textbackslash}mitI & Mathematical Italic Capital I \\
\hline
U+1D43D & 𝐽 & {\textbackslash}mitJ & Mathematical Italic Capital J \\
\hline
U+1D43E & 𝐾 & {\textbackslash}mitK & Mathematical Italic Capital K \\
\hline
U+1D43F & 𝐿 & {\textbackslash}mitL & Mathematical Italic Capital L \\
\hline
U+1D440 & 𝑀 & {\textbackslash}mitM & Mathematical Italic Capital M \\
\hline
U+1D441 & 𝑁 & {\textbackslash}mitN & Mathematical Italic Capital N \\
\hline
U+1D442 & 𝑂 & {\textbackslash}mitO & Mathematical Italic Capital O \\
\hline
U+1D443 & 𝑃 & {\textbackslash}mitP & Mathematical Italic Capital P \\
\hline
U+1D444 & 𝑄 & {\textbackslash}mitQ & Mathematical Italic Capital Q \\
\hline
U+1D445 & 𝑅 & {\textbackslash}mitR & Mathematical Italic Capital R \\
\hline
U+1D446 & 𝑆 & {\textbackslash}mitS & Mathematical Italic Capital S \\
\hline
U+1D447 & 𝑇 & {\textbackslash}mitT & Mathematical Italic Capital T \\
\hline
U+1D448 & 𝑈 & {\textbackslash}mitU & Mathematical Italic Capital U \\
\hline
U+1D449 & 𝑉 & {\textbackslash}mitV & Mathematical Italic Capital V \\
\hline
U+1D44A & 𝑊 & {\textbackslash}mitW & Mathematical Italic Capital W \\
\hline
U+1D44B & 𝑋 & {\textbackslash}mitX & Mathematical Italic Capital X \\
\hline
U+1D44C & 𝑌 & {\textbackslash}mitY & Mathematical Italic Capital Y \\
\hline
U+1D44D & 𝑍 & {\textbackslash}mitZ & Mathematical Italic Capital Z \\
\hline
U+1D44E & 𝑎 & {\textbackslash}mita & Mathematical Italic Small A \\
\hline
U+1D44F & 𝑏 & {\textbackslash}mitb & Mathematical Italic Small B \\
\hline
U+1D450 & 𝑐 & {\textbackslash}mitc & Mathematical Italic Small C \\
\hline
U+1D451 & 𝑑 & {\textbackslash}mitd & Mathematical Italic Small D \\
\hline
U+1D452 & 𝑒 & {\textbackslash}mite & Mathematical Italic Small E \\
\hline
U+1D453 & 𝑓 & {\textbackslash}mitf & Mathematical Italic Small F \\
\hline
U+1D454 & 𝑔 & {\textbackslash}mitg & Mathematical Italic Small G \\
\hline
U+1D456 & 𝑖 & {\textbackslash}miti & Mathematical Italic Small I \\
\hline
U+1D457 & 𝑗 & {\textbackslash}mitj & Mathematical Italic Small J \\
\hline
U+1D458 & 𝑘 & {\textbackslash}mitk & Mathematical Italic Small K \\
\hline
U+1D459 & 𝑙 & {\textbackslash}mitl & Mathematical Italic Small L \\
\hline
U+1D45A & 𝑚 & {\textbackslash}mitm & Mathematical Italic Small M \\
\hline
U+1D45B & 𝑛 & {\textbackslash}mitn & Mathematical Italic Small N \\
\hline
U+1D45C & 𝑜 & {\textbackslash}mito & Mathematical Italic Small O \\
\hline
U+1D45D & 𝑝 & {\textbackslash}mitp & Mathematical Italic Small P \\
\hline
U+1D45E & 𝑞 & {\textbackslash}mitq & Mathematical Italic Small Q \\
\hline
U+1D45F & 𝑟 & {\textbackslash}mitr & Mathematical Italic Small R \\
\hline
U+1D460 & 𝑠 & {\textbackslash}mits & Mathematical Italic Small S \\
\hline
U+1D461 & 𝑡 & {\textbackslash}mitt & Mathematical Italic Small T \\
\hline
U+1D462 & 𝑢 & {\textbackslash}mitu & Mathematical Italic Small U \\
\hline
U+1D463 & 𝑣 & {\textbackslash}mitv & Mathematical Italic Small V \\
\hline
U+1D464 & 𝑤 & {\textbackslash}mitw & Mathematical Italic Small W \\
\hline
U+1D465 & 𝑥 & {\textbackslash}mitx & Mathematical Italic Small X \\
\hline
U+1D466 & 𝑦 & {\textbackslash}mity & Mathematical Italic Small Y \\
\hline
U+1D467 & 𝑧 & {\textbackslash}mitz & Mathematical Italic Small Z \\
\hline
U+1D468 & 𝑨 & {\textbackslash}mbfitA & Mathematical Bold Italic Capital A \\
\hline
U+1D469 & 𝑩 & {\textbackslash}mbfitB & Mathematical Bold Italic Capital B \\
\hline
U+1D46A & 𝑪 & {\textbackslash}mbfitC & Mathematical Bold Italic Capital C \\
\hline
U+1D46B & 𝑫 & {\textbackslash}mbfitD & Mathematical Bold Italic Capital D \\
\hline
U+1D46C & 𝑬 & {\textbackslash}mbfitE & Mathematical Bold Italic Capital E \\
\hline
U+1D46D & 𝑭 & {\textbackslash}mbfitF & Mathematical Bold Italic Capital F \\
\hline
U+1D46E & 𝑮 & {\textbackslash}mbfitG & Mathematical Bold Italic Capital G \\
\hline
U+1D46F & 𝑯 & {\textbackslash}mbfitH & Mathematical Bold Italic Capital H \\
\hline
U+1D470 & 𝑰 & {\textbackslash}mbfitI & Mathematical Bold Italic Capital I \\
\hline
U+1D471 & 𝑱 & {\textbackslash}mbfitJ & Mathematical Bold Italic Capital J \\
\hline
U+1D472 & 𝑲 & {\textbackslash}mbfitK & Mathematical Bold Italic Capital K \\
\hline
U+1D473 & 𝑳 & {\textbackslash}mbfitL & Mathematical Bold Italic Capital L \\
\hline
U+1D474 & 𝑴 & {\textbackslash}mbfitM & Mathematical Bold Italic Capital M \\
\hline
U+1D475 & 𝑵 & {\textbackslash}mbfitN & Mathematical Bold Italic Capital N \\
\hline
U+1D476 & 𝑶 & {\textbackslash}mbfitO & Mathematical Bold Italic Capital O \\
\hline
U+1D477 & 𝑷 & {\textbackslash}mbfitP & Mathematical Bold Italic Capital P \\
\hline
U+1D478 & 𝑸 & {\textbackslash}mbfitQ & Mathematical Bold Italic Capital Q \\
\hline
U+1D479 & 𝑹 & {\textbackslash}mbfitR & Mathematical Bold Italic Capital R \\
\hline
U+1D47A & 𝑺 & {\textbackslash}mbfitS & Mathematical Bold Italic Capital S \\
\hline
U+1D47B & 𝑻 & {\textbackslash}mbfitT & Mathematical Bold Italic Capital T \\
\hline
U+1D47C & 𝑼 & {\textbackslash}mbfitU & Mathematical Bold Italic Capital U \\
\hline
U+1D47D & 𝑽 & {\textbackslash}mbfitV & Mathematical Bold Italic Capital V \\
\hline
U+1D47E & 𝑾 & {\textbackslash}mbfitW & Mathematical Bold Italic Capital W \\
\hline
U+1D47F & 𝑿 & {\textbackslash}mbfitX & Mathematical Bold Italic Capital X \\
\hline
U+1D480 & 𝒀 & {\textbackslash}mbfitY & Mathematical Bold Italic Capital Y \\
\hline
U+1D481 & 𝒁 & {\textbackslash}mbfitZ & Mathematical Bold Italic Capital Z \\
\hline
U+1D482 & 𝒂 & {\textbackslash}mbfita & Mathematical Bold Italic Small A \\
\hline
U+1D483 & 𝒃 & {\textbackslash}mbfitb & Mathematical Bold Italic Small B \\
\hline
U+1D484 & 𝒄 & {\textbackslash}mbfitc & Mathematical Bold Italic Small C \\
\hline
U+1D485 & 𝒅 & {\textbackslash}mbfitd & Mathematical Bold Italic Small D \\
\hline
U+1D486 & 𝒆 & {\textbackslash}mbfite & Mathematical Bold Italic Small E \\
\hline
U+1D487 & 𝒇 & {\textbackslash}mbfitf & Mathematical Bold Italic Small F \\
\hline
U+1D488 & 𝒈 & {\textbackslash}mbfitg & Mathematical Bold Italic Small G \\
\hline
U+1D489 & 𝒉 & {\textbackslash}mbfith & Mathematical Bold Italic Small H \\
\hline
U+1D48A & 𝒊 & {\textbackslash}mbfiti & Mathematical Bold Italic Small I \\
\hline
U+1D48B & 𝒋 & {\textbackslash}mbfitj & Mathematical Bold Italic Small J \\
\hline
U+1D48C & 𝒌 & {\textbackslash}mbfitk & Mathematical Bold Italic Small K \\
\hline
U+1D48D & 𝒍 & {\textbackslash}mbfitl & Mathematical Bold Italic Small L \\
\hline
U+1D48E & 𝒎 & {\textbackslash}mbfitm & Mathematical Bold Italic Small M \\
\hline
U+1D48F & 𝒏 & {\textbackslash}mbfitn & Mathematical Bold Italic Small N \\
\hline
U+1D490 & 𝒐 & {\textbackslash}mbfito & Mathematical Bold Italic Small O \\
\hline
U+1D491 & 𝒑 & {\textbackslash}mbfitp & Mathematical Bold Italic Small P \\
\hline
U+1D492 & 𝒒 & {\textbackslash}mbfitq & Mathematical Bold Italic Small Q \\
\hline
U+1D493 & 𝒓 & {\textbackslash}mbfitr & Mathematical Bold Italic Small R \\
\hline
U+1D494 & 𝒔 & {\textbackslash}mbfits & Mathematical Bold Italic Small S \\
\hline
U+1D495 & 𝒕 & {\textbackslash}mbfitt & Mathematical Bold Italic Small T \\
\hline
U+1D496 & 𝒖 & {\textbackslash}mbfitu & Mathematical Bold Italic Small U \\
\hline
U+1D497 & 𝒗 & {\textbackslash}mbfitv & Mathematical Bold Italic Small V \\
\hline
U+1D498 & 𝒘 & {\textbackslash}mbfitw & Mathematical Bold Italic Small W \\
\hline
U+1D499 & 𝒙 & {\textbackslash}mbfitx & Mathematical Bold Italic Small X \\
\hline
U+1D49A & 𝒚 & {\textbackslash}mbfity & Mathematical Bold Italic Small Y \\
\hline
U+1D49B & 𝒛 & {\textbackslash}mbfitz & Mathematical Bold Italic Small Z \\
\hline
U+1D49C & 𝒜 & {\textbackslash}mscrA & Mathematical Script Capital A \\
\hline
U+1D49E & 𝒞 & {\textbackslash}mscrC & Mathematical Script Capital C \\
\hline
U+1D49F & 𝒟 & {\textbackslash}mscrD & Mathematical Script Capital D \\
\hline
U+1D4A2 & 𝒢 & {\textbackslash}mscrG & Mathematical Script Capital G \\
\hline
U+1D4A5 & 𝒥 & {\textbackslash}mscrJ & Mathematical Script Capital J \\
\hline
U+1D4A6 & 𝒦 & {\textbackslash}mscrK & Mathematical Script Capital K \\
\hline
U+1D4A9 & 𝒩 & {\textbackslash}mscrN & Mathematical Script Capital N \\
\hline
U+1D4AA & 𝒪 & {\textbackslash}mscrO & Mathematical Script Capital O \\
\hline
U+1D4AB & 𝒫 & {\textbackslash}mscrP & Mathematical Script Capital P \\
\hline
U+1D4AC & 𝒬 & {\textbackslash}mscrQ & Mathematical Script Capital Q \\
\hline
U+1D4AE & 𝒮 & {\textbackslash}mscrS & Mathematical Script Capital S \\
\hline
U+1D4AF & 𝒯 & {\textbackslash}mscrT & Mathematical Script Capital T \\
\hline
U+1D4B0 & 𝒰 & {\textbackslash}mscrU & Mathematical Script Capital U \\
\hline
U+1D4B1 & 𝒱 & {\textbackslash}mscrV & Mathematical Script Capital V \\
\hline
U+1D4B2 & 𝒲 & {\textbackslash}mscrW & Mathematical Script Capital W \\
\hline
U+1D4B3 & 𝒳 & {\textbackslash}mscrX & Mathematical Script Capital X \\
\hline
U+1D4B4 & 𝒴 & {\textbackslash}mscrY & Mathematical Script Capital Y \\
\hline
U+1D4B5 & 𝒵 & {\textbackslash}mscrZ & Mathematical Script Capital Z \\
\hline
U+1D4B6 & 𝒶 & {\textbackslash}mscra & Mathematical Script Small A \\
\hline
U+1D4B7 & 𝒷 & {\textbackslash}mscrb & Mathematical Script Small B \\
\hline
U+1D4B8 & 𝒸 & {\textbackslash}mscrc & Mathematical Script Small C \\
\hline
U+1D4B9 & 𝒹 & {\textbackslash}mscrd & Mathematical Script Small D \\
\hline
U+1D4BB & 𝒻 & {\textbackslash}mscrf & Mathematical Script Small F \\
\hline
U+1D4BD & 𝒽 & {\textbackslash}mscrh & Mathematical Script Small H \\
\hline
U+1D4BE & 𝒾 & {\textbackslash}mscri & Mathematical Script Small I \\
\hline
U+1D4BF & 𝒿 & {\textbackslash}mscrj & Mathematical Script Small J \\
\hline
U+1D4C0 & 𝓀 & {\textbackslash}mscrk & Mathematical Script Small K \\
\hline
U+1D4C1 & 𝓁 & {\textbackslash}mscrl & Mathematical Script Small L \\
\hline
U+1D4C2 & 𝓂 & {\textbackslash}mscrm & Mathematical Script Small M \\
\hline
U+1D4C3 & 𝓃 & {\textbackslash}mscrn & Mathematical Script Small N \\
\hline
U+1D4C5 & 𝓅 & {\textbackslash}mscrp & Mathematical Script Small P \\
\hline
U+1D4C6 & 𝓆 & {\textbackslash}mscrq & Mathematical Script Small Q \\
\hline
U+1D4C7 & 𝓇 & {\textbackslash}mscrr & Mathematical Script Small R \\
\hline
U+1D4C8 & 𝓈 & {\textbackslash}mscrs & Mathematical Script Small S \\
\hline
U+1D4C9 & 𝓉 & {\textbackslash}mscrt & Mathematical Script Small T \\
\hline
U+1D4CA & 𝓊 & {\textbackslash}mscru & Mathematical Script Small U \\
\hline
U+1D4CB & 𝓋 & {\textbackslash}mscrv & Mathematical Script Small V \\
\hline
U+1D4CC & 𝓌 & {\textbackslash}mscrw & Mathematical Script Small W \\
\hline
U+1D4CD & 𝓍 & {\textbackslash}mscrx & Mathematical Script Small X \\
\hline
U+1D4CE & 𝓎 & {\textbackslash}mscry & Mathematical Script Small Y \\
\hline
U+1D4CF & 𝓏 & {\textbackslash}mscrz & Mathematical Script Small Z \\
\hline
U+1D4D0 & 𝓐 & {\textbackslash}mbfscrA & Mathematical Bold Script Capital A \\
\hline
U+1D4D1 & 𝓑 & {\textbackslash}mbfscrB & Mathematical Bold Script Capital B \\
\hline
U+1D4D2 & 𝓒 & {\textbackslash}mbfscrC & Mathematical Bold Script Capital C \\
\hline
U+1D4D3 & 𝓓 & {\textbackslash}mbfscrD & Mathematical Bold Script Capital D \\
\hline
U+1D4D4 & 𝓔 & {\textbackslash}mbfscrE & Mathematical Bold Script Capital E \\
\hline
U+1D4D5 & 𝓕 & {\textbackslash}mbfscrF & Mathematical Bold Script Capital F \\
\hline
U+1D4D6 & 𝓖 & {\textbackslash}mbfscrG & Mathematical Bold Script Capital G \\
\hline
U+1D4D7 & 𝓗 & {\textbackslash}mbfscrH & Mathematical Bold Script Capital H \\
\hline
U+1D4D8 & 𝓘 & {\textbackslash}mbfscrI & Mathematical Bold Script Capital I \\
\hline
U+1D4D9 & 𝓙 & {\textbackslash}mbfscrJ & Mathematical Bold Script Capital J \\
\hline
U+1D4DA & 𝓚 & {\textbackslash}mbfscrK & Mathematical Bold Script Capital K \\
\hline
U+1D4DB & 𝓛 & {\textbackslash}mbfscrL & Mathematical Bold Script Capital L \\
\hline
U+1D4DC & 𝓜 & {\textbackslash}mbfscrM & Mathematical Bold Script Capital M \\
\hline
U+1D4DD & 𝓝 & {\textbackslash}mbfscrN & Mathematical Bold Script Capital N \\
\hline
U+1D4DE & 𝓞 & {\textbackslash}mbfscrO & Mathematical Bold Script Capital O \\
\hline
U+1D4DF & 𝓟 & {\textbackslash}mbfscrP & Mathematical Bold Script Capital P \\
\hline
U+1D4E0 & 𝓠 & {\textbackslash}mbfscrQ & Mathematical Bold Script Capital Q \\
\hline
U+1D4E1 & 𝓡 & {\textbackslash}mbfscrR & Mathematical Bold Script Capital R \\
\hline
U+1D4E2 & 𝓢 & {\textbackslash}mbfscrS & Mathematical Bold Script Capital S \\
\hline
U+1D4E3 & 𝓣 & {\textbackslash}mbfscrT & Mathematical Bold Script Capital T \\
\hline
U+1D4E4 & 𝓤 & {\textbackslash}mbfscrU & Mathematical Bold Script Capital U \\
\hline
U+1D4E5 & 𝓥 & {\textbackslash}mbfscrV & Mathematical Bold Script Capital V \\
\hline
U+1D4E6 & 𝓦 & {\textbackslash}mbfscrW & Mathematical Bold Script Capital W \\
\hline
U+1D4E7 & 𝓧 & {\textbackslash}mbfscrX & Mathematical Bold Script Capital X \\
\hline
U+1D4E8 & 𝓨 & {\textbackslash}mbfscrY & Mathematical Bold Script Capital Y \\
\hline
U+1D4E9 & 𝓩 & {\textbackslash}mbfscrZ & Mathematical Bold Script Capital Z \\
\hline
U+1D4EA & 𝓪 & {\textbackslash}mbfscra & Mathematical Bold Script Small A \\
\hline
U+1D4EB & 𝓫 & {\textbackslash}mbfscrb & Mathematical Bold Script Small B \\
\hline
U+1D4EC & 𝓬 & {\textbackslash}mbfscrc & Mathematical Bold Script Small C \\
\hline
U+1D4ED & 𝓭 & {\textbackslash}mbfscrd & Mathematical Bold Script Small D \\
\hline
U+1D4EE & 𝓮 & {\textbackslash}mbfscre & Mathematical Bold Script Small E \\
\hline
U+1D4EF & 𝓯 & {\textbackslash}mbfscrf & Mathematical Bold Script Small F \\
\hline
U+1D4F0 & 𝓰 & {\textbackslash}mbfscrg & Mathematical Bold Script Small G \\
\hline
U+1D4F1 & 𝓱 & {\textbackslash}mbfscrh & Mathematical Bold Script Small H \\
\hline
U+1D4F2 & 𝓲 & {\textbackslash}mbfscri & Mathematical Bold Script Small I \\
\hline
U+1D4F3 & 𝓳 & {\textbackslash}mbfscrj & Mathematical Bold Script Small J \\
\hline
U+1D4F4 & 𝓴 & {\textbackslash}mbfscrk & Mathematical Bold Script Small K \\
\hline
U+1D4F5 & 𝓵 & {\textbackslash}mbfscrl & Mathematical Bold Script Small L \\
\hline
U+1D4F6 & 𝓶 & {\textbackslash}mbfscrm & Mathematical Bold Script Small M \\
\hline
U+1D4F7 & 𝓷 & {\textbackslash}mbfscrn & Mathematical Bold Script Small N \\
\hline
U+1D4F8 & 𝓸 & {\textbackslash}mbfscro & Mathematical Bold Script Small O \\
\hline
U+1D4F9 & 𝓹 & {\textbackslash}mbfscrp & Mathematical Bold Script Small P \\
\hline
U+1D4FA & 𝓺 & {\textbackslash}mbfscrq & Mathematical Bold Script Small Q \\
\hline
U+1D4FB & 𝓻 & {\textbackslash}mbfscrr & Mathematical Bold Script Small R \\
\hline
U+1D4FC & 𝓼 & {\textbackslash}mbfscrs & Mathematical Bold Script Small S \\
\hline
U+1D4FD & 𝓽 & {\textbackslash}mbfscrt & Mathematical Bold Script Small T \\
\hline
U+1D4FE & 𝓾 & {\textbackslash}mbfscru & Mathematical Bold Script Small U \\
\hline
U+1D4FF & 𝓿 & {\textbackslash}mbfscrv & Mathematical Bold Script Small V \\
\hline
U+1D500 & 𝔀 & {\textbackslash}mbfscrw & Mathematical Bold Script Small W \\
\hline
U+1D501 & 𝔁 & {\textbackslash}mbfscrx & Mathematical Bold Script Small X \\
\hline
U+1D502 & 𝔂 & {\textbackslash}mbfscry & Mathematical Bold Script Small Y \\
\hline
U+1D503 & 𝔃 & {\textbackslash}mbfscrz & Mathematical Bold Script Small Z \\
\hline
U+1D504 & 𝔄 & {\textbackslash}mfrakA & Mathematical Fraktur Capital A \\
\hline
U+1D505 & 𝔅 & {\textbackslash}mfrakB & Mathematical Fraktur Capital B \\
\hline
U+1D507 & 𝔇 & {\textbackslash}mfrakD & Mathematical Fraktur Capital D \\
\hline
U+1D508 & 𝔈 & {\textbackslash}mfrakE & Mathematical Fraktur Capital E \\
\hline
U+1D509 & 𝔉 & {\textbackslash}mfrakF & Mathematical Fraktur Capital F \\
\hline
U+1D50A & 𝔊 & {\textbackslash}mfrakG & Mathematical Fraktur Capital G \\
\hline
U+1D50D & 𝔍 & {\textbackslash}mfrakJ & Mathematical Fraktur Capital J \\
\hline
U+1D50E & 𝔎 & {\textbackslash}mfrakK & Mathematical Fraktur Capital K \\
\hline
U+1D50F & 𝔏 & {\textbackslash}mfrakL & Mathematical Fraktur Capital L \\
\hline
U+1D510 & 𝔐 & {\textbackslash}mfrakM & Mathematical Fraktur Capital M \\
\hline
U+1D511 & 𝔑 & {\textbackslash}mfrakN & Mathematical Fraktur Capital N \\
\hline
U+1D512 & 𝔒 & {\textbackslash}mfrakO & Mathematical Fraktur Capital O \\
\hline
U+1D513 & 𝔓 & {\textbackslash}mfrakP & Mathematical Fraktur Capital P \\
\hline
U+1D514 & 𝔔 & {\textbackslash}mfrakQ & Mathematical Fraktur Capital Q \\
\hline
U+1D516 & 𝔖 & {\textbackslash}mfrakS & Mathematical Fraktur Capital S \\
\hline
U+1D517 & 𝔗 & {\textbackslash}mfrakT & Mathematical Fraktur Capital T \\
\hline
U+1D518 & 𝔘 & {\textbackslash}mfrakU & Mathematical Fraktur Capital U \\
\hline
U+1D519 & 𝔙 & {\textbackslash}mfrakV & Mathematical Fraktur Capital V \\
\hline
U+1D51A & 𝔚 & {\textbackslash}mfrakW & Mathematical Fraktur Capital W \\
\hline
U+1D51B & 𝔛 & {\textbackslash}mfrakX & Mathematical Fraktur Capital X \\
\hline
U+1D51C & 𝔜 & {\textbackslash}mfrakY & Mathematical Fraktur Capital Y \\
\hline
U+1D51E & 𝔞 & {\textbackslash}mfraka & Mathematical Fraktur Small A \\
\hline
U+1D51F & 𝔟 & {\textbackslash}mfrakb & Mathematical Fraktur Small B \\
\hline
U+1D520 & 𝔠 & {\textbackslash}mfrakc & Mathematical Fraktur Small C \\
\hline
U+1D521 & 𝔡 & {\textbackslash}mfrakd & Mathematical Fraktur Small D \\
\hline
U+1D522 & 𝔢 & {\textbackslash}mfrake & Mathematical Fraktur Small E \\
\hline
U+1D523 & 𝔣 & {\textbackslash}mfrakf & Mathematical Fraktur Small F \\
\hline
U+1D524 & 𝔤 & {\textbackslash}mfrakg & Mathematical Fraktur Small G \\
\hline
U+1D525 & 𝔥 & {\textbackslash}mfrakh & Mathematical Fraktur Small H \\
\hline
U+1D526 & 𝔦 & {\textbackslash}mfraki & Mathematical Fraktur Small I \\
\hline
U+1D527 & 𝔧 & {\textbackslash}mfrakj & Mathematical Fraktur Small J \\
\hline
U+1D528 & 𝔨 & {\textbackslash}mfrakk & Mathematical Fraktur Small K \\
\hline
U+1D529 & 𝔩 & {\textbackslash}mfrakl & Mathematical Fraktur Small L \\
\hline
U+1D52A & 𝔪 & {\textbackslash}mfrakm & Mathematical Fraktur Small M \\
\hline
U+1D52B & 𝔫 & {\textbackslash}mfrakn & Mathematical Fraktur Small N \\
\hline
U+1D52C & 𝔬 & {\textbackslash}mfrako & Mathematical Fraktur Small O \\
\hline
U+1D52D & 𝔭 & {\textbackslash}mfrakp & Mathematical Fraktur Small P \\
\hline
U+1D52E & 𝔮 & {\textbackslash}mfrakq & Mathematical Fraktur Small Q \\
\hline
U+1D52F & 𝔯 & {\textbackslash}mfrakr & Mathematical Fraktur Small R \\
\hline
U+1D530 & 𝔰 & {\textbackslash}mfraks & Mathematical Fraktur Small S \\
\hline
U+1D531 & 𝔱 & {\textbackslash}mfrakt & Mathematical Fraktur Small T \\
\hline
U+1D532 & 𝔲 & {\textbackslash}mfraku & Mathematical Fraktur Small U \\
\hline
U+1D533 & 𝔳 & {\textbackslash}mfrakv & Mathematical Fraktur Small V \\
\hline
U+1D534 & 𝔴 & {\textbackslash}mfrakw & Mathematical Fraktur Small W \\
\hline
U+1D535 & 𝔵 & {\textbackslash}mfrakx & Mathematical Fraktur Small X \\
\hline
U+1D536 & 𝔶 & {\textbackslash}mfraky & Mathematical Fraktur Small Y \\
\hline
U+1D537 & 𝔷 & {\textbackslash}mfrakz & Mathematical Fraktur Small Z \\
\hline
U+1D538 & 𝔸 & {\textbackslash}BbbA & Mathematical Double-struck Capital A \\
\hline
U+1D539 & 𝔹 & {\textbackslash}BbbB & Mathematical Double-struck Capital B \\
\hline
U+1D53B & 𝔻 & {\textbackslash}BbbD & Mathematical Double-struck Capital D \\
\hline
U+1D53C & 𝔼 & {\textbackslash}BbbE & Mathematical Double-struck Capital E \\
\hline
U+1D53D & 𝔽 & {\textbackslash}BbbF & Mathematical Double-struck Capital F \\
\hline
U+1D53E & 𝔾 & {\textbackslash}BbbG & Mathematical Double-struck Capital G \\
\hline
U+1D540 & 𝕀 & {\textbackslash}BbbI & Mathematical Double-struck Capital I \\
\hline
U+1D541 & 𝕁 & {\textbackslash}BbbJ & Mathematical Double-struck Capital J \\
\hline
U+1D542 & 𝕂 & {\textbackslash}BbbK & Mathematical Double-struck Capital K \\
\hline
U+1D543 & 𝕃 & {\textbackslash}BbbL & Mathematical Double-struck Capital L \\
\hline
U+1D544 & 𝕄 & {\textbackslash}BbbM & Mathematical Double-struck Capital M \\
\hline
U+1D546 & 𝕆 & {\textbackslash}BbbO & Mathematical Double-struck Capital O \\
\hline
U+1D54A & 𝕊 & {\textbackslash}BbbS & Mathematical Double-struck Capital S \\
\hline
U+1D54B & 𝕋 & {\textbackslash}BbbT & Mathematical Double-struck Capital T \\
\hline
U+1D54C & 𝕌 & {\textbackslash}BbbU & Mathematical Double-struck Capital U \\
\hline
U+1D54D & 𝕍 & {\textbackslash}BbbV & Mathematical Double-struck Capital V \\
\hline
U+1D54E & 𝕎 & {\textbackslash}BbbW & Mathematical Double-struck Capital W \\
\hline
U+1D54F & 𝕏 & {\textbackslash}BbbX & Mathematical Double-struck Capital X \\
\hline
U+1D550 & 𝕐 & {\textbackslash}BbbY & Mathematical Double-struck Capital Y \\
\hline
U+1D552 & 𝕒 & {\textbackslash}Bbba & Mathematical Double-struck Small A \\
\hline
U+1D553 & 𝕓 & {\textbackslash}Bbbb & Mathematical Double-struck Small B \\
\hline
U+1D554 & 𝕔 & {\textbackslash}Bbbc & Mathematical Double-struck Small C \\
\hline
U+1D555 & 𝕕 & {\textbackslash}Bbbd & Mathematical Double-struck Small D \\
\hline
U+1D556 & 𝕖 & {\textbackslash}Bbbe & Mathematical Double-struck Small E \\
\hline
U+1D557 & 𝕗 & {\textbackslash}Bbbf & Mathematical Double-struck Small F \\
\hline
U+1D558 & 𝕘 & {\textbackslash}Bbbg & Mathematical Double-struck Small G \\
\hline
U+1D559 & 𝕙 & {\textbackslash}Bbbh & Mathematical Double-struck Small H \\
\hline
U+1D55A & 𝕚 & {\textbackslash}Bbbi & Mathematical Double-struck Small I \\
\hline
U+1D55B & 𝕛 & {\textbackslash}Bbbj & Mathematical Double-struck Small J \\
\hline
U+1D55C & 𝕜 & {\textbackslash}Bbbk & Mathematical Double-struck Small K \\
\hline
U+1D55D & 𝕝 & {\textbackslash}Bbbl & Mathematical Double-struck Small L \\
\hline
U+1D55E & 𝕞 & {\textbackslash}Bbbm & Mathematical Double-struck Small M \\
\hline
U+1D55F & 𝕟 & {\textbackslash}Bbbn & Mathematical Double-struck Small N \\
\hline
U+1D560 & 𝕠 & {\textbackslash}Bbbo & Mathematical Double-struck Small O \\
\hline
U+1D561 & 𝕡 & {\textbackslash}Bbbp & Mathematical Double-struck Small P \\
\hline
U+1D562 & 𝕢 & {\textbackslash}Bbbq & Mathematical Double-struck Small Q \\
\hline
U+1D563 & 𝕣 & {\textbackslash}Bbbr & Mathematical Double-struck Small R \\
\hline
U+1D564 & 𝕤 & {\textbackslash}Bbbs & Mathematical Double-struck Small S \\
\hline
U+1D565 & 𝕥 & {\textbackslash}Bbbt & Mathematical Double-struck Small T \\
\hline
U+1D566 & 𝕦 & {\textbackslash}Bbbu & Mathematical Double-struck Small U \\
\hline
U+1D567 & 𝕧 & {\textbackslash}Bbbv & Mathematical Double-struck Small V \\
\hline
U+1D568 & 𝕨 & {\textbackslash}Bbbw & Mathematical Double-struck Small W \\
\hline
U+1D569 & 𝕩 & {\textbackslash}Bbbx & Mathematical Double-struck Small X \\
\hline
U+1D56A & 𝕪 & {\textbackslash}Bbby & Mathematical Double-struck Small Y \\
\hline
U+1D56B & 𝕫 & {\textbackslash}Bbbz & Mathematical Double-struck Small Z \\
\hline
U+1D56C & 𝕬 & {\textbackslash}mbffrakA & Mathematical Bold Fraktur Capital A \\
\hline
U+1D56D & 𝕭 & {\textbackslash}mbffrakB & Mathematical Bold Fraktur Capital B \\
\hline
U+1D56E & 𝕮 & {\textbackslash}mbffrakC & Mathematical Bold Fraktur Capital C \\
\hline
U+1D56F & 𝕯 & {\textbackslash}mbffrakD & Mathematical Bold Fraktur Capital D \\
\hline
U+1D570 & 𝕰 & {\textbackslash}mbffrakE & Mathematical Bold Fraktur Capital E \\
\hline
U+1D571 & 𝕱 & {\textbackslash}mbffrakF & Mathematical Bold Fraktur Capital F \\
\hline
U+1D572 & 𝕲 & {\textbackslash}mbffrakG & Mathematical Bold Fraktur Capital G \\
\hline
U+1D573 & 𝕳 & {\textbackslash}mbffrakH & Mathematical Bold Fraktur Capital H \\
\hline
U+1D574 & 𝕴 & {\textbackslash}mbffrakI & Mathematical Bold Fraktur Capital I \\
\hline
U+1D575 & 𝕵 & {\textbackslash}mbffrakJ & Mathematical Bold Fraktur Capital J \\
\hline
U+1D576 & 𝕶 & {\textbackslash}mbffrakK & Mathematical Bold Fraktur Capital K \\
\hline
U+1D577 & 𝕷 & {\textbackslash}mbffrakL & Mathematical Bold Fraktur Capital L \\
\hline
U+1D578 & 𝕸 & {\textbackslash}mbffrakM & Mathematical Bold Fraktur Capital M \\
\hline
U+1D579 & 𝕹 & {\textbackslash}mbffrakN & Mathematical Bold Fraktur Capital N \\
\hline
U+1D57A & 𝕺 & {\textbackslash}mbffrakO & Mathematical Bold Fraktur Capital O \\
\hline
U+1D57B & 𝕻 & {\textbackslash}mbffrakP & Mathematical Bold Fraktur Capital P \\
\hline
U+1D57C & 𝕼 & {\textbackslash}mbffrakQ & Mathematical Bold Fraktur Capital Q \\
\hline
U+1D57D & 𝕽 & {\textbackslash}mbffrakR & Mathematical Bold Fraktur Capital R \\
\hline
U+1D57E & 𝕾 & {\textbackslash}mbffrakS & Mathematical Bold Fraktur Capital S \\
\hline
U+1D57F & 𝕿 & {\textbackslash}mbffrakT & Mathematical Bold Fraktur Capital T \\
\hline
U+1D580 & 𝖀 & {\textbackslash}mbffrakU & Mathematical Bold Fraktur Capital U \\
\hline
U+1D581 & 𝖁 & {\textbackslash}mbffrakV & Mathematical Bold Fraktur Capital V \\
\hline
U+1D582 & 𝖂 & {\textbackslash}mbffrakW & Mathematical Bold Fraktur Capital W \\
\hline
U+1D583 & 𝖃 & {\textbackslash}mbffrakX & Mathematical Bold Fraktur Capital X \\
\hline
U+1D584 & 𝖄 & {\textbackslash}mbffrakY & Mathematical Bold Fraktur Capital Y \\
\hline
U+1D585 & 𝖅 & {\textbackslash}mbffrakZ & Mathematical Bold Fraktur Capital Z \\
\hline
U+1D586 & 𝖆 & {\textbackslash}mbffraka & Mathematical Bold Fraktur Small A \\
\hline
U+1D587 & 𝖇 & {\textbackslash}mbffrakb & Mathematical Bold Fraktur Small B \\
\hline
U+1D588 & 𝖈 & {\textbackslash}mbffrakc & Mathematical Bold Fraktur Small C \\
\hline
U+1D589 & 𝖉 & {\textbackslash}mbffrakd & Mathematical Bold Fraktur Small D \\
\hline
U+1D58A & 𝖊 & {\textbackslash}mbffrake & Mathematical Bold Fraktur Small E \\
\hline
U+1D58B & 𝖋 & {\textbackslash}mbffrakf & Mathematical Bold Fraktur Small F \\
\hline
U+1D58C & 𝖌 & {\textbackslash}mbffrakg & Mathematical Bold Fraktur Small G \\
\hline
U+1D58D & 𝖍 & {\textbackslash}mbffrakh & Mathematical Bold Fraktur Small H \\
\hline
U+1D58E & 𝖎 & {\textbackslash}mbffraki & Mathematical Bold Fraktur Small I \\
\hline
U+1D58F & 𝖏 & {\textbackslash}mbffrakj & Mathematical Bold Fraktur Small J \\
\hline
U+1D590 & 𝖐 & {\textbackslash}mbffrakk & Mathematical Bold Fraktur Small K \\
\hline
U+1D591 & 𝖑 & {\textbackslash}mbffrakl & Mathematical Bold Fraktur Small L \\
\hline
U+1D592 & 𝖒 & {\textbackslash}mbffrakm & Mathematical Bold Fraktur Small M \\
\hline
U+1D593 & 𝖓 & {\textbackslash}mbffrakn & Mathematical Bold Fraktur Small N \\
\hline
U+1D594 & 𝖔 & {\textbackslash}mbffrako & Mathematical Bold Fraktur Small O \\
\hline
U+1D595 & 𝖕 & {\textbackslash}mbffrakp & Mathematical Bold Fraktur Small P \\
\hline
U+1D596 & 𝖖 & {\textbackslash}mbffrakq & Mathematical Bold Fraktur Small Q \\
\hline
U+1D597 & 𝖗 & {\textbackslash}mbffrakr & Mathematical Bold Fraktur Small R \\
\hline
U+1D598 & 𝖘 & {\textbackslash}mbffraks & Mathematical Bold Fraktur Small S \\
\hline
U+1D599 & 𝖙 & {\textbackslash}mbffrakt & Mathematical Bold Fraktur Small T \\
\hline
U+1D59A & 𝖚 & {\textbackslash}mbffraku & Mathematical Bold Fraktur Small U \\
\hline
U+1D59B & 𝖛 & {\textbackslash}mbffrakv & Mathematical Bold Fraktur Small V \\
\hline
U+1D59C & 𝖜 & {\textbackslash}mbffrakw & Mathematical Bold Fraktur Small W \\
\hline
U+1D59D & 𝖝 & {\textbackslash}mbffrakx & Mathematical Bold Fraktur Small X \\
\hline
U+1D59E & 𝖞 & {\textbackslash}mbffraky & Mathematical Bold Fraktur Small Y \\
\hline
U+1D59F & 𝖟 & {\textbackslash}mbffrakz & Mathematical Bold Fraktur Small Z \\
\hline
U+1D5A0 & 𝖠 & {\textbackslash}msansA & Mathematical Sans-serif Capital A \\
\hline
U+1D5A1 & 𝖡 & {\textbackslash}msansB & Mathematical Sans-serif Capital B \\
\hline
U+1D5A2 & 𝖢 & {\textbackslash}msansC & Mathematical Sans-serif Capital C \\
\hline
U+1D5A3 & 𝖣 & {\textbackslash}msansD & Mathematical Sans-serif Capital D \\
\hline
U+1D5A4 & 𝖤 & {\textbackslash}msansE & Mathematical Sans-serif Capital E \\
\hline
U+1D5A5 & 𝖥 & {\textbackslash}msansF & Mathematical Sans-serif Capital F \\
\hline
U+1D5A6 & 𝖦 & {\textbackslash}msansG & Mathematical Sans-serif Capital G \\
\hline
U+1D5A7 & 𝖧 & {\textbackslash}msansH & Mathematical Sans-serif Capital H \\
\hline
U+1D5A8 & 𝖨 & {\textbackslash}msansI & Mathematical Sans-serif Capital I \\
\hline
U+1D5A9 & 𝖩 & {\textbackslash}msansJ & Mathematical Sans-serif Capital J \\
\hline
U+1D5AA & 𝖪 & {\textbackslash}msansK & Mathematical Sans-serif Capital K \\
\hline
U+1D5AB & 𝖫 & {\textbackslash}msansL & Mathematical Sans-serif Capital L \\
\hline
U+1D5AC & 𝖬 & {\textbackslash}msansM & Mathematical Sans-serif Capital M \\
\hline
U+1D5AD & 𝖭 & {\textbackslash}msansN & Mathematical Sans-serif Capital N \\
\hline
U+1D5AE & 𝖮 & {\textbackslash}msansO & Mathematical Sans-serif Capital O \\
\hline
U+1D5AF & 𝖯 & {\textbackslash}msansP & Mathematical Sans-serif Capital P \\
\hline
U+1D5B0 & 𝖰 & {\textbackslash}msansQ & Mathematical Sans-serif Capital Q \\
\hline
U+1D5B1 & 𝖱 & {\textbackslash}msansR & Mathematical Sans-serif Capital R \\
\hline
U+1D5B2 & 𝖲 & {\textbackslash}msansS & Mathematical Sans-serif Capital S \\
\hline
U+1D5B3 & 𝖳 & {\textbackslash}msansT & Mathematical Sans-serif Capital T \\
\hline
U+1D5B4 & 𝖴 & {\textbackslash}msansU & Mathematical Sans-serif Capital U \\
\hline
U+1D5B5 & 𝖵 & {\textbackslash}msansV & Mathematical Sans-serif Capital V \\
\hline
U+1D5B6 & 𝖶 & {\textbackslash}msansW & Mathematical Sans-serif Capital W \\
\hline
U+1D5B7 & 𝖷 & {\textbackslash}msansX & Mathematical Sans-serif Capital X \\
\hline
U+1D5B8 & 𝖸 & {\textbackslash}msansY & Mathematical Sans-serif Capital Y \\
\hline
U+1D5B9 & 𝖹 & {\textbackslash}msansZ & Mathematical Sans-serif Capital Z \\
\hline
U+1D5BA & 𝖺 & {\textbackslash}msansa & Mathematical Sans-serif Small A \\
\hline
U+1D5BB & 𝖻 & {\textbackslash}msansb & Mathematical Sans-serif Small B \\
\hline
U+1D5BC & 𝖼 & {\textbackslash}msansc & Mathematical Sans-serif Small C \\
\hline
U+1D5BD & 𝖽 & {\textbackslash}msansd & Mathematical Sans-serif Small D \\
\hline
U+1D5BE & 𝖾 & {\textbackslash}msanse & Mathematical Sans-serif Small E \\
\hline
U+1D5BF & 𝖿 & {\textbackslash}msansf & Mathematical Sans-serif Small F \\
\hline
U+1D5C0 & 𝗀 & {\textbackslash}msansg & Mathematical Sans-serif Small G \\
\hline
U+1D5C1 & 𝗁 & {\textbackslash}msansh & Mathematical Sans-serif Small H \\
\hline
U+1D5C2 & 𝗂 & {\textbackslash}msansi & Mathematical Sans-serif Small I \\
\hline
U+1D5C3 & 𝗃 & {\textbackslash}msansj & Mathematical Sans-serif Small J \\
\hline
U+1D5C4 & 𝗄 & {\textbackslash}msansk & Mathematical Sans-serif Small K \\
\hline
U+1D5C5 & 𝗅 & {\textbackslash}msansl & Mathematical Sans-serif Small L \\
\hline
U+1D5C6 & 𝗆 & {\textbackslash}msansm & Mathematical Sans-serif Small M \\
\hline
U+1D5C7 & 𝗇 & {\textbackslash}msansn & Mathematical Sans-serif Small N \\
\hline
U+1D5C8 & 𝗈 & {\textbackslash}msanso & Mathematical Sans-serif Small O \\
\hline
U+1D5C9 & 𝗉 & {\textbackslash}msansp & Mathematical Sans-serif Small P \\
\hline
U+1D5CA & 𝗊 & {\textbackslash}msansq & Mathematical Sans-serif Small Q \\
\hline
U+1D5CB & 𝗋 & {\textbackslash}msansr & Mathematical Sans-serif Small R \\
\hline
U+1D5CC & 𝗌 & {\textbackslash}msanss & Mathematical Sans-serif Small S \\
\hline
U+1D5CD & 𝗍 & {\textbackslash}msanst & Mathematical Sans-serif Small T \\
\hline
U+1D5CE & 𝗎 & {\textbackslash}msansu & Mathematical Sans-serif Small U \\
\hline
U+1D5CF & 𝗏 & {\textbackslash}msansv & Mathematical Sans-serif Small V \\
\hline
U+1D5D0 & 𝗐 & {\textbackslash}msansw & Mathematical Sans-serif Small W \\
\hline
U+1D5D1 & 𝗑 & {\textbackslash}msansx & Mathematical Sans-serif Small X \\
\hline
U+1D5D2 & 𝗒 & {\textbackslash}msansy & Mathematical Sans-serif Small Y \\
\hline
U+1D5D3 & 𝗓 & {\textbackslash}msansz & Mathematical Sans-serif Small Z \\
\hline
U+1D5D4 & 𝗔 & {\textbackslash}mbfsansA & Mathematical Sans-serif Bold Capital A \\
\hline
U+1D5D5 & 𝗕 & {\textbackslash}mbfsansB & Mathematical Sans-serif Bold Capital B \\
\hline
U+1D5D6 & 𝗖 & {\textbackslash}mbfsansC & Mathematical Sans-serif Bold Capital C \\
\hline
U+1D5D7 & 𝗗 & {\textbackslash}mbfsansD & Mathematical Sans-serif Bold Capital D \\
\hline
U+1D5D8 & 𝗘 & {\textbackslash}mbfsansE & Mathematical Sans-serif Bold Capital E \\
\hline
U+1D5D9 & 𝗙 & {\textbackslash}mbfsansF & Mathematical Sans-serif Bold Capital F \\
\hline
U+1D5DA & 𝗚 & {\textbackslash}mbfsansG & Mathematical Sans-serif Bold Capital G \\
\hline
U+1D5DB & 𝗛 & {\textbackslash}mbfsansH & Mathematical Sans-serif Bold Capital H \\
\hline
U+1D5DC & 𝗜 & {\textbackslash}mbfsansI & Mathematical Sans-serif Bold Capital I \\
\hline
U+1D5DD & 𝗝 & {\textbackslash}mbfsansJ & Mathematical Sans-serif Bold Capital J \\
\hline
U+1D5DE & 𝗞 & {\textbackslash}mbfsansK & Mathematical Sans-serif Bold Capital K \\
\hline
U+1D5DF & 𝗟 & {\textbackslash}mbfsansL & Mathematical Sans-serif Bold Capital L \\
\hline
U+1D5E0 & 𝗠 & {\textbackslash}mbfsansM & Mathematical Sans-serif Bold Capital M \\
\hline
U+1D5E1 & 𝗡 & {\textbackslash}mbfsansN & Mathematical Sans-serif Bold Capital N \\
\hline
U+1D5E2 & 𝗢 & {\textbackslash}mbfsansO & Mathematical Sans-serif Bold Capital O \\
\hline
U+1D5E3 & 𝗣 & {\textbackslash}mbfsansP & Mathematical Sans-serif Bold Capital P \\
\hline
U+1D5E4 & 𝗤 & {\textbackslash}mbfsansQ & Mathematical Sans-serif Bold Capital Q \\
\hline
U+1D5E5 & 𝗥 & {\textbackslash}mbfsansR & Mathematical Sans-serif Bold Capital R \\
\hline
U+1D5E6 & 𝗦 & {\textbackslash}mbfsansS & Mathematical Sans-serif Bold Capital S \\
\hline
U+1D5E7 & 𝗧 & {\textbackslash}mbfsansT & Mathematical Sans-serif Bold Capital T \\
\hline
U+1D5E8 & 𝗨 & {\textbackslash}mbfsansU & Mathematical Sans-serif Bold Capital U \\
\hline
U+1D5E9 & 𝗩 & {\textbackslash}mbfsansV & Mathematical Sans-serif Bold Capital V \\
\hline
U+1D5EA & 𝗪 & {\textbackslash}mbfsansW & Mathematical Sans-serif Bold Capital W \\
\hline
U+1D5EB & 𝗫 & {\textbackslash}mbfsansX & Mathematical Sans-serif Bold Capital X \\
\hline
U+1D5EC & 𝗬 & {\textbackslash}mbfsansY & Mathematical Sans-serif Bold Capital Y \\
\hline
U+1D5ED & 𝗭 & {\textbackslash}mbfsansZ & Mathematical Sans-serif Bold Capital Z \\
\hline
U+1D5EE & 𝗮 & {\textbackslash}mbfsansa & Mathematical Sans-serif Bold Small A \\
\hline
U+1D5EF & 𝗯 & {\textbackslash}mbfsansb & Mathematical Sans-serif Bold Small B \\
\hline
U+1D5F0 & 𝗰 & {\textbackslash}mbfsansc & Mathematical Sans-serif Bold Small C \\
\hline
U+1D5F1 & 𝗱 & {\textbackslash}mbfsansd & Mathematical Sans-serif Bold Small D \\
\hline
U+1D5F2 & 𝗲 & {\textbackslash}mbfsanse & Mathematical Sans-serif Bold Small E \\
\hline
U+1D5F3 & 𝗳 & {\textbackslash}mbfsansf & Mathematical Sans-serif Bold Small F \\
\hline
U+1D5F4 & 𝗴 & {\textbackslash}mbfsansg & Mathematical Sans-serif Bold Small G \\
\hline
U+1D5F5 & 𝗵 & {\textbackslash}mbfsansh & Mathematical Sans-serif Bold Small H \\
\hline
U+1D5F6 & 𝗶 & {\textbackslash}mbfsansi & Mathematical Sans-serif Bold Small I \\
\hline
U+1D5F7 & 𝗷 & {\textbackslash}mbfsansj & Mathematical Sans-serif Bold Small J \\
\hline
U+1D5F8 & 𝗸 & {\textbackslash}mbfsansk & Mathematical Sans-serif Bold Small K \\
\hline
U+1D5F9 & 𝗹 & {\textbackslash}mbfsansl & Mathematical Sans-serif Bold Small L \\
\hline
U+1D5FA & 𝗺 & {\textbackslash}mbfsansm & Mathematical Sans-serif Bold Small M \\
\hline
U+1D5FB & 𝗻 & {\textbackslash}mbfsansn & Mathematical Sans-serif Bold Small N \\
\hline
U+1D5FC & 𝗼 & {\textbackslash}mbfsanso & Mathematical Sans-serif Bold Small O \\
\hline
U+1D5FD & 𝗽 & {\textbackslash}mbfsansp & Mathematical Sans-serif Bold Small P \\
\hline
U+1D5FE & 𝗾 & {\textbackslash}mbfsansq & Mathematical Sans-serif Bold Small Q \\
\hline
U+1D5FF & 𝗿 & {\textbackslash}mbfsansr & Mathematical Sans-serif Bold Small R \\
\hline
U+1D600 & 𝘀 & {\textbackslash}mbfsanss & Mathematical Sans-serif Bold Small S \\
\hline
U+1D601 & 𝘁 & {\textbackslash}mbfsanst & Mathematical Sans-serif Bold Small T \\
\hline
U+1D602 & 𝘂 & {\textbackslash}mbfsansu & Mathematical Sans-serif Bold Small U \\
\hline
U+1D603 & 𝘃 & {\textbackslash}mbfsansv & Mathematical Sans-serif Bold Small V \\
\hline
U+1D604 & 𝘄 & {\textbackslash}mbfsansw & Mathematical Sans-serif Bold Small W \\
\hline
U+1D605 & 𝘅 & {\textbackslash}mbfsansx & Mathematical Sans-serif Bold Small X \\
\hline
U+1D606 & 𝘆 & {\textbackslash}mbfsansy & Mathematical Sans-serif Bold Small Y \\
\hline
U+1D607 & 𝘇 & {\textbackslash}mbfsansz & Mathematical Sans-serif Bold Small Z \\
\hline
U+1D608 & 𝘈 & {\textbackslash}mitsansA & Mathematical Sans-serif Italic Capital A \\
\hline
U+1D609 & 𝘉 & {\textbackslash}mitsansB & Mathematical Sans-serif Italic Capital B \\
\hline
U+1D60A & 𝘊 & {\textbackslash}mitsansC & Mathematical Sans-serif Italic Capital C \\
\hline
U+1D60B & 𝘋 & {\textbackslash}mitsansD & Mathematical Sans-serif Italic Capital D \\
\hline
U+1D60C & 𝘌 & {\textbackslash}mitsansE & Mathematical Sans-serif Italic Capital E \\
\hline
U+1D60D & 𝘍 & {\textbackslash}mitsansF & Mathematical Sans-serif Italic Capital F \\
\hline
U+1D60E & 𝘎 & {\textbackslash}mitsansG & Mathematical Sans-serif Italic Capital G \\
\hline
U+1D60F & 𝘏 & {\textbackslash}mitsansH & Mathematical Sans-serif Italic Capital H \\
\hline
U+1D610 & 𝘐 & {\textbackslash}mitsansI & Mathematical Sans-serif Italic Capital I \\
\hline
U+1D611 & 𝘑 & {\textbackslash}mitsansJ & Mathematical Sans-serif Italic Capital J \\
\hline
U+1D612 & 𝘒 & {\textbackslash}mitsansK & Mathematical Sans-serif Italic Capital K \\
\hline
U+1D613 & 𝘓 & {\textbackslash}mitsansL & Mathematical Sans-serif Italic Capital L \\
\hline
U+1D614 & 𝘔 & {\textbackslash}mitsansM & Mathematical Sans-serif Italic Capital M \\
\hline
U+1D615 & 𝘕 & {\textbackslash}mitsansN & Mathematical Sans-serif Italic Capital N \\
\hline
U+1D616 & 𝘖 & {\textbackslash}mitsansO & Mathematical Sans-serif Italic Capital O \\
\hline
U+1D617 & 𝘗 & {\textbackslash}mitsansP & Mathematical Sans-serif Italic Capital P \\
\hline
U+1D618 & 𝘘 & {\textbackslash}mitsansQ & Mathematical Sans-serif Italic Capital Q \\
\hline
U+1D619 & 𝘙 & {\textbackslash}mitsansR & Mathematical Sans-serif Italic Capital R \\
\hline
U+1D61A & 𝘚 & {\textbackslash}mitsansS & Mathematical Sans-serif Italic Capital S \\
\hline
U+1D61B & 𝘛 & {\textbackslash}mitsansT & Mathematical Sans-serif Italic Capital T \\
\hline
U+1D61C & 𝘜 & {\textbackslash}mitsansU & Mathematical Sans-serif Italic Capital U \\
\hline
U+1D61D & 𝘝 & {\textbackslash}mitsansV & Mathematical Sans-serif Italic Capital V \\
\hline
U+1D61E & 𝘞 & {\textbackslash}mitsansW & Mathematical Sans-serif Italic Capital W \\
\hline
U+1D61F & 𝘟 & {\textbackslash}mitsansX & Mathematical Sans-serif Italic Capital X \\
\hline
U+1D620 & 𝘠 & {\textbackslash}mitsansY & Mathematical Sans-serif Italic Capital Y \\
\hline
U+1D621 & 𝘡 & {\textbackslash}mitsansZ & Mathematical Sans-serif Italic Capital Z \\
\hline
U+1D622 & 𝘢 & {\textbackslash}mitsansa & Mathematical Sans-serif Italic Small A \\
\hline
U+1D623 & 𝘣 & {\textbackslash}mitsansb & Mathematical Sans-serif Italic Small B \\
\hline
U+1D624 & 𝘤 & {\textbackslash}mitsansc & Mathematical Sans-serif Italic Small C \\
\hline
U+1D625 & 𝘥 & {\textbackslash}mitsansd & Mathematical Sans-serif Italic Small D \\
\hline
U+1D626 & 𝘦 & {\textbackslash}mitsanse & Mathematical Sans-serif Italic Small E \\
\hline
U+1D627 & 𝘧 & {\textbackslash}mitsansf & Mathematical Sans-serif Italic Small F \\
\hline
U+1D628 & 𝘨 & {\textbackslash}mitsansg & Mathematical Sans-serif Italic Small G \\
\hline
U+1D629 & 𝘩 & {\textbackslash}mitsansh & Mathematical Sans-serif Italic Small H \\
\hline
U+1D62A & 𝘪 & {\textbackslash}mitsansi & Mathematical Sans-serif Italic Small I \\
\hline
U+1D62B & 𝘫 & {\textbackslash}mitsansj & Mathematical Sans-serif Italic Small J \\
\hline
U+1D62C & 𝘬 & {\textbackslash}mitsansk & Mathematical Sans-serif Italic Small K \\
\hline
U+1D62D & 𝘭 & {\textbackslash}mitsansl & Mathematical Sans-serif Italic Small L \\
\hline
U+1D62E & 𝘮 & {\textbackslash}mitsansm & Mathematical Sans-serif Italic Small M \\
\hline
U+1D62F & 𝘯 & {\textbackslash}mitsansn & Mathematical Sans-serif Italic Small N \\
\hline
U+1D630 & 𝘰 & {\textbackslash}mitsanso & Mathematical Sans-serif Italic Small O \\
\hline
U+1D631 & 𝘱 & {\textbackslash}mitsansp & Mathematical Sans-serif Italic Small P \\
\hline
U+1D632 & 𝘲 & {\textbackslash}mitsansq & Mathematical Sans-serif Italic Small Q \\
\hline
U+1D633 & 𝘳 & {\textbackslash}mitsansr & Mathematical Sans-serif Italic Small R \\
\hline
U+1D634 & 𝘴 & {\textbackslash}mitsanss & Mathematical Sans-serif Italic Small S \\
\hline
U+1D635 & 𝘵 & {\textbackslash}mitsanst & Mathematical Sans-serif Italic Small T \\
\hline
U+1D636 & 𝘶 & {\textbackslash}mitsansu & Mathematical Sans-serif Italic Small U \\
\hline
U+1D637 & 𝘷 & {\textbackslash}mitsansv & Mathematical Sans-serif Italic Small V \\
\hline
U+1D638 & 𝘸 & {\textbackslash}mitsansw & Mathematical Sans-serif Italic Small W \\
\hline
U+1D639 & 𝘹 & {\textbackslash}mitsansx & Mathematical Sans-serif Italic Small X \\
\hline
U+1D63A & 𝘺 & {\textbackslash}mitsansy & Mathematical Sans-serif Italic Small Y \\
\hline
U+1D63B & 𝘻 & {\textbackslash}mitsansz & Mathematical Sans-serif Italic Small Z \\
\hline
U+1D63C & 𝘼 & {\textbackslash}mbfitsansA & Mathematical Sans-serif Bold Italic Capital A \\
\hline
U+1D63D & 𝘽 & {\textbackslash}mbfitsansB & Mathematical Sans-serif Bold Italic Capital B \\
\hline
U+1D63E & 𝘾 & {\textbackslash}mbfitsansC & Mathematical Sans-serif Bold Italic Capital C \\
\hline
U+1D63F & 𝘿 & {\textbackslash}mbfitsansD & Mathematical Sans-serif Bold Italic Capital D \\
\hline
U+1D640 & 𝙀 & {\textbackslash}mbfitsansE & Mathematical Sans-serif Bold Italic Capital E \\
\hline
U+1D641 & 𝙁 & {\textbackslash}mbfitsansF & Mathematical Sans-serif Bold Italic Capital F \\
\hline
U+1D642 & 𝙂 & {\textbackslash}mbfitsansG & Mathematical Sans-serif Bold Italic Capital G \\
\hline
U+1D643 & 𝙃 & {\textbackslash}mbfitsansH & Mathematical Sans-serif Bold Italic Capital H \\
\hline
U+1D644 & 𝙄 & {\textbackslash}mbfitsansI & Mathematical Sans-serif Bold Italic Capital I \\
\hline
U+1D645 & 𝙅 & {\textbackslash}mbfitsansJ & Mathematical Sans-serif Bold Italic Capital J \\
\hline
U+1D646 & 𝙆 & {\textbackslash}mbfitsansK & Mathematical Sans-serif Bold Italic Capital K \\
\hline
U+1D647 & 𝙇 & {\textbackslash}mbfitsansL & Mathematical Sans-serif Bold Italic Capital L \\
\hline
U+1D648 & 𝙈 & {\textbackslash}mbfitsansM & Mathematical Sans-serif Bold Italic Capital M \\
\hline
U+1D649 & 𝙉 & {\textbackslash}mbfitsansN & Mathematical Sans-serif Bold Italic Capital N \\
\hline
U+1D64A & 𝙊 & {\textbackslash}mbfitsansO & Mathematical Sans-serif Bold Italic Capital O \\
\hline
U+1D64B & 𝙋 & {\textbackslash}mbfitsansP & Mathematical Sans-serif Bold Italic Capital P \\
\hline
U+1D64C & 𝙌 & {\textbackslash}mbfitsansQ & Mathematical Sans-serif Bold Italic Capital Q \\
\hline
U+1D64D & 𝙍 & {\textbackslash}mbfitsansR & Mathematical Sans-serif Bold Italic Capital R \\
\hline
U+1D64E & 𝙎 & {\textbackslash}mbfitsansS & Mathematical Sans-serif Bold Italic Capital S \\
\hline
U+1D64F & 𝙏 & {\textbackslash}mbfitsansT & Mathematical Sans-serif Bold Italic Capital T \\
\hline
U+1D650 & 𝙐 & {\textbackslash}mbfitsansU & Mathematical Sans-serif Bold Italic Capital U \\
\hline
U+1D651 & 𝙑 & {\textbackslash}mbfitsansV & Mathematical Sans-serif Bold Italic Capital V \\
\hline
U+1D652 & 𝙒 & {\textbackslash}mbfitsansW & Mathematical Sans-serif Bold Italic Capital W \\
\hline
U+1D653 & 𝙓 & {\textbackslash}mbfitsansX & Mathematical Sans-serif Bold Italic Capital X \\
\hline
U+1D654 & 𝙔 & {\textbackslash}mbfitsansY & Mathematical Sans-serif Bold Italic Capital Y \\
\hline
U+1D655 & 𝙕 & {\textbackslash}mbfitsansZ & Mathematical Sans-serif Bold Italic Capital Z \\
\hline
U+1D656 & 𝙖 & {\textbackslash}mbfitsansa & Mathematical Sans-serif Bold Italic Small A \\
\hline
U+1D657 & 𝙗 & {\textbackslash}mbfitsansb & Mathematical Sans-serif Bold Italic Small B \\
\hline
U+1D658 & 𝙘 & {\textbackslash}mbfitsansc & Mathematical Sans-serif Bold Italic Small C \\
\hline
U+1D659 & 𝙙 & {\textbackslash}mbfitsansd & Mathematical Sans-serif Bold Italic Small D \\
\hline
U+1D65A & 𝙚 & {\textbackslash}mbfitsanse & Mathematical Sans-serif Bold Italic Small E \\
\hline
U+1D65B & 𝙛 & {\textbackslash}mbfitsansf & Mathematical Sans-serif Bold Italic Small F \\
\hline
U+1D65C & 𝙜 & {\textbackslash}mbfitsansg & Mathematical Sans-serif Bold Italic Small G \\
\hline
U+1D65D & 𝙝 & {\textbackslash}mbfitsansh & Mathematical Sans-serif Bold Italic Small H \\
\hline
U+1D65E & 𝙞 & {\textbackslash}mbfitsansi & Mathematical Sans-serif Bold Italic Small I \\
\hline
U+1D65F & 𝙟 & {\textbackslash}mbfitsansj & Mathematical Sans-serif Bold Italic Small J \\
\hline
U+1D660 & 𝙠 & {\textbackslash}mbfitsansk & Mathematical Sans-serif Bold Italic Small K \\
\hline
U+1D661 & 𝙡 & {\textbackslash}mbfitsansl & Mathematical Sans-serif Bold Italic Small L \\
\hline
U+1D662 & 𝙢 & {\textbackslash}mbfitsansm & Mathematical Sans-serif Bold Italic Small M \\
\hline
U+1D663 & 𝙣 & {\textbackslash}mbfitsansn & Mathematical Sans-serif Bold Italic Small N \\
\hline
U+1D664 & 𝙤 & {\textbackslash}mbfitsanso & Mathematical Sans-serif Bold Italic Small O \\
\hline
U+1D665 & 𝙥 & {\textbackslash}mbfitsansp & Mathematical Sans-serif Bold Italic Small P \\
\hline
U+1D666 & 𝙦 & {\textbackslash}mbfitsansq & Mathematical Sans-serif Bold Italic Small Q \\
\hline
U+1D667 & 𝙧 & {\textbackslash}mbfitsansr & Mathematical Sans-serif Bold Italic Small R \\
\hline
U+1D668 & 𝙨 & {\textbackslash}mbfitsanss & Mathematical Sans-serif Bold Italic Small S \\
\hline
U+1D669 & 𝙩 & {\textbackslash}mbfitsanst & Mathematical Sans-serif Bold Italic Small T \\
\hline
U+1D66A & 𝙪 & {\textbackslash}mbfitsansu & Mathematical Sans-serif Bold Italic Small U \\
\hline
U+1D66B & 𝙫 & {\textbackslash}mbfitsansv & Mathematical Sans-serif Bold Italic Small V \\
\hline
U+1D66C & 𝙬 & {\textbackslash}mbfitsansw & Mathematical Sans-serif Bold Italic Small W \\
\hline
U+1D66D & 𝙭 & {\textbackslash}mbfitsansx & Mathematical Sans-serif Bold Italic Small X \\
\hline
U+1D66E & 𝙮 & {\textbackslash}mbfitsansy & Mathematical Sans-serif Bold Italic Small Y \\
\hline
U+1D66F & 𝙯 & {\textbackslash}mbfitsansz & Mathematical Sans-serif Bold Italic Small Z \\
\hline
U+1D670 & 𝙰 & {\textbackslash}mttA & Mathematical Monospace Capital A \\
\hline
U+1D671 & 𝙱 & {\textbackslash}mttB & Mathematical Monospace Capital B \\
\hline
U+1D672 & 𝙲 & {\textbackslash}mttC & Mathematical Monospace Capital C \\
\hline
U+1D673 & 𝙳 & {\textbackslash}mttD & Mathematical Monospace Capital D \\
\hline
U+1D674 & 𝙴 & {\textbackslash}mttE & Mathematical Monospace Capital E \\
\hline
U+1D675 & 𝙵 & {\textbackslash}mttF & Mathematical Monospace Capital F \\
\hline
U+1D676 & 𝙶 & {\textbackslash}mttG & Mathematical Monospace Capital G \\
\hline
U+1D677 & 𝙷 & {\textbackslash}mttH & Mathematical Monospace Capital H \\
\hline
U+1D678 & 𝙸 & {\textbackslash}mttI & Mathematical Monospace Capital I \\
\hline
U+1D679 & 𝙹 & {\textbackslash}mttJ & Mathematical Monospace Capital J \\
\hline
U+1D67A & 𝙺 & {\textbackslash}mttK & Mathematical Monospace Capital K \\
\hline
U+1D67B & 𝙻 & {\textbackslash}mttL & Mathematical Monospace Capital L \\
\hline
U+1D67C & 𝙼 & {\textbackslash}mttM & Mathematical Monospace Capital M \\
\hline
U+1D67D & 𝙽 & {\textbackslash}mttN & Mathematical Monospace Capital N \\
\hline
U+1D67E & 𝙾 & {\textbackslash}mttO & Mathematical Monospace Capital O \\
\hline
U+1D67F & 𝙿 & {\textbackslash}mttP & Mathematical Monospace Capital P \\
\hline
U+1D680 & 𝚀 & {\textbackslash}mttQ & Mathematical Monospace Capital Q \\
\hline
U+1D681 & 𝚁 & {\textbackslash}mttR & Mathematical Monospace Capital R \\
\hline
U+1D682 & 𝚂 & {\textbackslash}mttS & Mathematical Monospace Capital S \\
\hline
U+1D683 & 𝚃 & {\textbackslash}mttT & Mathematical Monospace Capital T \\
\hline
U+1D684 & 𝚄 & {\textbackslash}mttU & Mathematical Monospace Capital U \\
\hline
U+1D685 & 𝚅 & {\textbackslash}mttV & Mathematical Monospace Capital V \\
\hline
U+1D686 & 𝚆 & {\textbackslash}mttW & Mathematical Monospace Capital W \\
\hline
U+1D687 & 𝚇 & {\textbackslash}mttX & Mathematical Monospace Capital X \\
\hline
U+1D688 & 𝚈 & {\textbackslash}mttY & Mathematical Monospace Capital Y \\
\hline
U+1D689 & 𝚉 & {\textbackslash}mttZ & Mathematical Monospace Capital Z \\
\hline
U+1D68A & 𝚊 & {\textbackslash}mtta & Mathematical Monospace Small A \\
\hline
U+1D68B & 𝚋 & {\textbackslash}mttb & Mathematical Monospace Small B \\
\hline
U+1D68C & 𝚌 & {\textbackslash}mttc & Mathematical Monospace Small C \\
\hline
U+1D68D & 𝚍 & {\textbackslash}mttd & Mathematical Monospace Small D \\
\hline
U+1D68E & 𝚎 & {\textbackslash}mtte & Mathematical Monospace Small E \\
\hline
U+1D68F & 𝚏 & {\textbackslash}mttf & Mathematical Monospace Small F \\
\hline
U+1D690 & 𝚐 & {\textbackslash}mttg & Mathematical Monospace Small G \\
\hline
U+1D691 & 𝚑 & {\textbackslash}mtth & Mathematical Monospace Small H \\
\hline
U+1D692 & 𝚒 & {\textbackslash}mtti & Mathematical Monospace Small I \\
\hline
U+1D693 & 𝚓 & {\textbackslash}mttj & Mathematical Monospace Small J \\
\hline
U+1D694 & 𝚔 & {\textbackslash}mttk & Mathematical Monospace Small K \\
\hline
U+1D695 & 𝚕 & {\textbackslash}mttl & Mathematical Monospace Small L \\
\hline
U+1D696 & 𝚖 & {\textbackslash}mttm & Mathematical Monospace Small M \\
\hline
U+1D697 & 𝚗 & {\textbackslash}mttn & Mathematical Monospace Small N \\
\hline
U+1D698 & 𝚘 & {\textbackslash}mtto & Mathematical Monospace Small O \\
\hline
U+1D699 & 𝚙 & {\textbackslash}mttp & Mathematical Monospace Small P \\
\hline
U+1D69A & 𝚚 & {\textbackslash}mttq & Mathematical Monospace Small Q \\
\hline
U+1D69B & 𝚛 & {\textbackslash}mttr & Mathematical Monospace Small R \\
\hline
U+1D69C & 𝚜 & {\textbackslash}mtts & Mathematical Monospace Small S \\
\hline
U+1D69D & 𝚝 & {\textbackslash}mttt & Mathematical Monospace Small T \\
\hline
U+1D69E & 𝚞 & {\textbackslash}mttu & Mathematical Monospace Small U \\
\hline
U+1D69F & 𝚟 & {\textbackslash}mttv & Mathematical Monospace Small V \\
\hline
U+1D6A0 & 𝚠 & {\textbackslash}mttw & Mathematical Monospace Small W \\
\hline
U+1D6A1 & 𝚡 & {\textbackslash}mttx & Mathematical Monospace Small X \\
\hline
U+1D6A2 & 𝚢 & {\textbackslash}mtty & Mathematical Monospace Small Y \\
\hline
U+1D6A3 & 𝚣 & {\textbackslash}mttz & Mathematical Monospace Small Z \\
\hline
U+1D6A4 & 𝚤 & {\textbackslash}imath & Mathematical Italic Small Dotless I \\
\hline
U+1D6A5 & 𝚥 & {\textbackslash}jmath & Mathematical Italic Small Dotless J \\
\hline
U+1D6A8 & 𝚨 & {\textbackslash}mbfAlpha & Mathematical Bold Capital Alpha \\
\hline
U+1D6A9 & 𝚩 & {\textbackslash}mbfBeta & Mathematical Bold Capital Beta \\
\hline
U+1D6AA & 𝚪 & {\textbackslash}mbfGamma & Mathematical Bold Capital Gamma \\
\hline
U+1D6AB & 𝚫 & {\textbackslash}mbfDelta & Mathematical Bold Capital Delta \\
\hline
U+1D6AC & 𝚬 & {\textbackslash}mbfEpsilon & Mathematical Bold Capital Epsilon \\
\hline
U+1D6AD & 𝚭 & {\textbackslash}mbfZeta & Mathematical Bold Capital Zeta \\
\hline
U+1D6AE & 𝚮 & {\textbackslash}mbfEta & Mathematical Bold Capital Eta \\
\hline
U+1D6AF & 𝚯 & {\textbackslash}mbfTheta & Mathematical Bold Capital Theta \\
\hline
U+1D6B0 & 𝚰 & {\textbackslash}mbfIota & Mathematical Bold Capital Iota \\
\hline
U+1D6B1 & 𝚱 & {\textbackslash}mbfKappa & Mathematical Bold Capital Kappa \\
\hline
U+1D6B2 & 𝚲 & {\textbackslash}mbfLambda & Mathematical Bold Capital Lamda \\
\hline
U+1D6B3 & 𝚳 & {\textbackslash}mbfMu & Mathematical Bold Capital Mu \\
\hline
U+1D6B4 & 𝚴 & {\textbackslash}mbfNu & Mathematical Bold Capital Nu \\
\hline
U+1D6B5 & 𝚵 & {\textbackslash}mbfXi & Mathematical Bold Capital Xi \\
\hline
U+1D6B6 & 𝚶 & {\textbackslash}mbfOmicron & Mathematical Bold Capital Omicron \\
\hline
U+1D6B7 & 𝚷 & {\textbackslash}mbfPi & Mathematical Bold Capital Pi \\
\hline
U+1D6B8 & 𝚸 & {\textbackslash}mbfRho & Mathematical Bold Capital Rho \\
\hline
U+1D6B9 & 𝚹 & {\textbackslash}mbfvarTheta & Mathematical Bold Capital Theta Symbol \\
\hline
U+1D6BA & 𝚺 & {\textbackslash}mbfSigma & Mathematical Bold Capital Sigma \\
\hline
U+1D6BB & 𝚻 & {\textbackslash}mbfTau & Mathematical Bold Capital Tau \\
\hline
U+1D6BC & 𝚼 & {\textbackslash}mbfUpsilon & Mathematical Bold Capital Upsilon \\
\hline
U+1D6BD & 𝚽 & {\textbackslash}mbfPhi & Mathematical Bold Capital Phi \\
\hline
U+1D6BE & 𝚾 & {\textbackslash}mbfChi & Mathematical Bold Capital Chi \\
\hline
U+1D6BF & 𝚿 & {\textbackslash}mbfPsi & Mathematical Bold Capital Psi \\
\hline
U+1D6C0 & 𝛀 & {\textbackslash}mbfOmega & Mathematical Bold Capital Omega \\
\hline
U+1D6C1 & 𝛁 & {\textbackslash}mbfnabla & Mathematical Bold Nabla \\
\hline
U+1D6C2 & 𝛂 & {\textbackslash}mbfalpha & Mathematical Bold Small Alpha \\
\hline
U+1D6C3 & 𝛃 & {\textbackslash}mbfbeta & Mathematical Bold Small Beta \\
\hline
U+1D6C4 & 𝛄 & {\textbackslash}mbfgamma & Mathematical Bold Small Gamma \\
\hline
U+1D6C5 & 𝛅 & {\textbackslash}mbfdelta & Mathematical Bold Small Delta \\
\hline
U+1D6C6 & 𝛆 & {\textbackslash}mbfepsilon & Mathematical Bold Small Epsilon \\
\hline
U+1D6C7 & 𝛇 & {\textbackslash}mbfzeta & Mathematical Bold Small Zeta \\
\hline
U+1D6C8 & 𝛈 & {\textbackslash}mbfeta & Mathematical Bold Small Eta \\
\hline
U+1D6C9 & 𝛉 & {\textbackslash}mbftheta & Mathematical Bold Small Theta \\
\hline
U+1D6CA & 𝛊 & {\textbackslash}mbfiota & Mathematical Bold Small Iota \\
\hline
U+1D6CB & 𝛋 & {\textbackslash}mbfkappa & Mathematical Bold Small Kappa \\
\hline
U+1D6CC & 𝛌 & {\textbackslash}mbflambda & Mathematical Bold Small Lamda \\
\hline
U+1D6CD & 𝛍 & {\textbackslash}mbfmu & Mathematical Bold Small Mu \\
\hline
U+1D6CE & 𝛎 & {\textbackslash}mbfnu & Mathematical Bold Small Nu \\
\hline
U+1D6CF & 𝛏 & {\textbackslash}mbfxi & Mathematical Bold Small Xi \\
\hline
U+1D6D0 & 𝛐 & {\textbackslash}mbfomicron & Mathematical Bold Small Omicron \\
\hline
U+1D6D1 & 𝛑 & {\textbackslash}mbfpi & Mathematical Bold Small Pi \\
\hline
U+1D6D2 & 𝛒 & {\textbackslash}mbfrho & Mathematical Bold Small Rho \\
\hline
U+1D6D3 & 𝛓 & {\textbackslash}mbfvarsigma & Mathematical Bold Small Final Sigma \\
\hline
U+1D6D4 & 𝛔 & {\textbackslash}mbfsigma & Mathematical Bold Small Sigma \\
\hline
U+1D6D5 & 𝛕 & {\textbackslash}mbftau & Mathematical Bold Small Tau \\
\hline
U+1D6D6 & 𝛖 & {\textbackslash}mbfupsilon & Mathematical Bold Small Upsilon \\
\hline
U+1D6D7 & 𝛗 & {\textbackslash}mbfvarphi & Mathematical Bold Small Phi \\
\hline
U+1D6D8 & 𝛘 & {\textbackslash}mbfchi & Mathematical Bold Small Chi \\
\hline
U+1D6D9 & 𝛙 & {\textbackslash}mbfpsi & Mathematical Bold Small Psi \\
\hline
U+1D6DA & 𝛚 & {\textbackslash}mbfomega & Mathematical Bold Small Omega \\
\hline
U+1D6DB & 𝛛 & {\textbackslash}mbfpartial & Mathematical Bold Partial Differential \\
\hline
U+1D6DC & 𝛜 & {\textbackslash}mbfvarepsilon & Mathematical Bold Epsilon Symbol \\
\hline
U+1D6DD & 𝛝 & {\textbackslash}mbfvartheta & Mathematical Bold Theta Symbol \\
\hline
U+1D6DE & 𝛞 & {\textbackslash}mbfvarkappa & Mathematical Bold Kappa Symbol \\
\hline
U+1D6DF & 𝛟 & {\textbackslash}mbfphi & Mathematical Bold Phi Symbol \\
\hline
U+1D6E0 & 𝛠 & {\textbackslash}mbfvarrho & Mathematical Bold Rho Symbol \\
\hline
U+1D6E1 & 𝛡 & {\textbackslash}mbfvarpi & Mathematical Bold Pi Symbol \\
\hline
U+1D6E2 & 𝛢 & {\textbackslash}mitAlpha & Mathematical Italic Capital Alpha \\
\hline
U+1D6E3 & 𝛣 & {\textbackslash}mitBeta & Mathematical Italic Capital Beta \\
\hline
U+1D6E4 & 𝛤 & {\textbackslash}mitGamma & Mathematical Italic Capital Gamma \\
\hline
U+1D6E5 & 𝛥 & {\textbackslash}mitDelta & Mathematical Italic Capital Delta \\
\hline
U+1D6E6 & 𝛦 & {\textbackslash}mitEpsilon & Mathematical Italic Capital Epsilon \\
\hline
U+1D6E7 & 𝛧 & {\textbackslash}mitZeta & Mathematical Italic Capital Zeta \\
\hline
U+1D6E8 & 𝛨 & {\textbackslash}mitEta & Mathematical Italic Capital Eta \\
\hline
U+1D6E9 & 𝛩 & {\textbackslash}mitTheta & Mathematical Italic Capital Theta \\
\hline
U+1D6EA & 𝛪 & {\textbackslash}mitIota & Mathematical Italic Capital Iota \\
\hline
U+1D6EB & 𝛫 & {\textbackslash}mitKappa & Mathematical Italic Capital Kappa \\
\hline
U+1D6EC & 𝛬 & {\textbackslash}mitLambda & Mathematical Italic Capital Lamda \\
\hline
U+1D6ED & 𝛭 & {\textbackslash}mitMu & Mathematical Italic Capital Mu \\
\hline
U+1D6EE & 𝛮 & {\textbackslash}mitNu & Mathematical Italic Capital Nu \\
\hline
U+1D6EF & 𝛯 & {\textbackslash}mitXi & Mathematical Italic Capital Xi \\
\hline
U+1D6F0 & 𝛰 & {\textbackslash}mitOmicron & Mathematical Italic Capital Omicron \\
\hline
U+1D6F1 & 𝛱 & {\textbackslash}mitPi & Mathematical Italic Capital Pi \\
\hline
U+1D6F2 & 𝛲 & {\textbackslash}mitRho & Mathematical Italic Capital Rho \\
\hline
U+1D6F3 & 𝛳 & {\textbackslash}mitvarTheta & Mathematical Italic Capital Theta Symbol \\
\hline
U+1D6F4 & 𝛴 & {\textbackslash}mitSigma & Mathematical Italic Capital Sigma \\
\hline
U+1D6F5 & 𝛵 & {\textbackslash}mitTau & Mathematical Italic Capital Tau \\
\hline
U+1D6F6 & 𝛶 & {\textbackslash}mitUpsilon & Mathematical Italic Capital Upsilon \\
\hline
U+1D6F7 & 𝛷 & {\textbackslash}mitPhi & Mathematical Italic Capital Phi \\
\hline
U+1D6F8 & 𝛸 & {\textbackslash}mitChi & Mathematical Italic Capital Chi \\
\hline
U+1D6F9 & 𝛹 & {\textbackslash}mitPsi & Mathematical Italic Capital Psi \\
\hline
U+1D6FA & 𝛺 & {\textbackslash}mitOmega & Mathematical Italic Capital Omega \\
\hline
U+1D6FB & 𝛻 & {\textbackslash}mitnabla & Mathematical Italic Nabla \\
\hline
U+1D6FC & 𝛼 & {\textbackslash}mitalpha & Mathematical Italic Small Alpha \\
\hline
U+1D6FD & 𝛽 & {\textbackslash}mitbeta & Mathematical Italic Small Beta \\
\hline
U+1D6FE & 𝛾 & {\textbackslash}mitgamma & Mathematical Italic Small Gamma \\
\hline
U+1D6FF & 𝛿 & {\textbackslash}mitdelta & Mathematical Italic Small Delta \\
\hline
U+1D700 & 𝜀 & {\textbackslash}mitepsilon & Mathematical Italic Small Epsilon \\
\hline
U+1D701 & 𝜁 & {\textbackslash}mitzeta & Mathematical Italic Small Zeta \\
\hline
U+1D702 & 𝜂 & {\textbackslash}miteta & Mathematical Italic Small Eta \\
\hline
U+1D703 & 𝜃 & {\textbackslash}mittheta & Mathematical Italic Small Theta \\
\hline
U+1D704 & 𝜄 & {\textbackslash}mitiota & Mathematical Italic Small Iota \\
\hline
U+1D705 & 𝜅 & {\textbackslash}mitkappa & Mathematical Italic Small Kappa \\
\hline
U+1D706 & 𝜆 & {\textbackslash}mitlambda & Mathematical Italic Small Lamda \\
\hline
U+1D707 & 𝜇 & {\textbackslash}mitmu & Mathematical Italic Small Mu \\
\hline
U+1D708 & 𝜈 & {\textbackslash}mitnu & Mathematical Italic Small Nu \\
\hline
U+1D709 & 𝜉 & {\textbackslash}mitxi & Mathematical Italic Small Xi \\
\hline
U+1D70A & 𝜊 & {\textbackslash}mitomicron & Mathematical Italic Small Omicron \\
\hline
U+1D70B & 𝜋 & {\textbackslash}mitpi & Mathematical Italic Small Pi \\
\hline
U+1D70C & 𝜌 & {\textbackslash}mitrho & Mathematical Italic Small Rho \\
\hline
U+1D70D & 𝜍 & {\textbackslash}mitvarsigma & Mathematical Italic Small Final Sigma \\
\hline
U+1D70E & 𝜎 & {\textbackslash}mitsigma & Mathematical Italic Small Sigma \\
\hline
U+1D70F & 𝜏 & {\textbackslash}mittau & Mathematical Italic Small Tau \\
\hline
U+1D710 & 𝜐 & {\textbackslash}mitupsilon & Mathematical Italic Small Upsilon \\
\hline
U+1D711 & 𝜑 & {\textbackslash}mitphi & Mathematical Italic Small Phi \\
\hline
U+1D712 & 𝜒 & {\textbackslash}mitchi & Mathematical Italic Small Chi \\
\hline
U+1D713 & 𝜓 & {\textbackslash}mitpsi & Mathematical Italic Small Psi \\
\hline
U+1D714 & 𝜔 & {\textbackslash}mitomega & Mathematical Italic Small Omega \\
\hline
U+1D715 & 𝜕 & {\textbackslash}mitpartial & Mathematical Italic Partial Differential \\
\hline
U+1D716 & 𝜖 & {\textbackslash}mitvarepsilon & Mathematical Italic Epsilon Symbol \\
\hline
U+1D717 & 𝜗 & {\textbackslash}mitvartheta & Mathematical Italic Theta Symbol \\
\hline
U+1D718 & 𝜘 & {\textbackslash}mitvarkappa & Mathematical Italic Kappa Symbol \\
\hline
U+1D719 & 𝜙 & {\textbackslash}mitvarphi & Mathematical Italic Phi Symbol \\
\hline
U+1D71A & 𝜚 & {\textbackslash}mitvarrho & Mathematical Italic Rho Symbol \\
\hline
U+1D71B & 𝜛 & {\textbackslash}mitvarpi & Mathematical Italic Pi Symbol \\
\hline
U+1D71C & 𝜜 & {\textbackslash}mbfitAlpha & Mathematical Bold Italic Capital Alpha \\
\hline
U+1D71D & 𝜝 & {\textbackslash}mbfitBeta & Mathematical Bold Italic Capital Beta \\
\hline
U+1D71E & 𝜞 & {\textbackslash}mbfitGamma & Mathematical Bold Italic Capital Gamma \\
\hline
U+1D71F & 𝜟 & {\textbackslash}mbfitDelta & Mathematical Bold Italic Capital Delta \\
\hline
U+1D720 & 𝜠 & {\textbackslash}mbfitEpsilon & Mathematical Bold Italic Capital Epsilon \\
\hline
U+1D721 & 𝜡 & {\textbackslash}mbfitZeta & Mathematical Bold Italic Capital Zeta \\
\hline
U+1D722 & 𝜢 & {\textbackslash}mbfitEta & Mathematical Bold Italic Capital Eta \\
\hline
U+1D723 & 𝜣 & {\textbackslash}mbfitTheta & Mathematical Bold Italic Capital Theta \\
\hline
U+1D724 & 𝜤 & {\textbackslash}mbfitIota & Mathematical Bold Italic Capital Iota \\
\hline
U+1D725 & 𝜥 & {\textbackslash}mbfitKappa & Mathematical Bold Italic Capital Kappa \\
\hline
U+1D726 & 𝜦 & {\textbackslash}mbfitLambda & Mathematical Bold Italic Capital Lamda \\
\hline
U+1D727 & 𝜧 & {\textbackslash}mbfitMu & Mathematical Bold Italic Capital Mu \\
\hline
U+1D728 & 𝜨 & {\textbackslash}mbfitNu & Mathematical Bold Italic Capital Nu \\
\hline
U+1D729 & 𝜩 & {\textbackslash}mbfitXi & Mathematical Bold Italic Capital Xi \\
\hline
U+1D72A & 𝜪 & {\textbackslash}mbfitOmicron & Mathematical Bold Italic Capital Omicron \\
\hline
U+1D72B & 𝜫 & {\textbackslash}mbfitPi & Mathematical Bold Italic Capital Pi \\
\hline
U+1D72C & 𝜬 & {\textbackslash}mbfitRho & Mathematical Bold Italic Capital Rho \\
\hline
U+1D72D & 𝜭 & {\textbackslash}mbfitvarTheta & Mathematical Bold Italic Capital Theta Symbol \\
\hline
U+1D72E & 𝜮 & {\textbackslash}mbfitSigma & Mathematical Bold Italic Capital Sigma \\
\hline
U+1D72F & 𝜯 & {\textbackslash}mbfitTau & Mathematical Bold Italic Capital Tau \\
\hline
U+1D730 & 𝜰 & {\textbackslash}mbfitUpsilon & Mathematical Bold Italic Capital Upsilon \\
\hline
U+1D731 & 𝜱 & {\textbackslash}mbfitPhi & Mathematical Bold Italic Capital Phi \\
\hline
U+1D732 & 𝜲 & {\textbackslash}mbfitChi & Mathematical Bold Italic Capital Chi \\
\hline
U+1D733 & 𝜳 & {\textbackslash}mbfitPsi & Mathematical Bold Italic Capital Psi \\
\hline
U+1D734 & 𝜴 & {\textbackslash}mbfitOmega & Mathematical Bold Italic Capital Omega \\
\hline
U+1D735 & 𝜵 & {\textbackslash}mbfitnabla & Mathematical Bold Italic Nabla \\
\hline
U+1D736 & 𝜶 & {\textbackslash}mbfitalpha & Mathematical Bold Italic Small Alpha \\
\hline
U+1D737 & 𝜷 & {\textbackslash}mbfitbeta & Mathematical Bold Italic Small Beta \\
\hline
U+1D738 & 𝜸 & {\textbackslash}mbfitgamma & Mathematical Bold Italic Small Gamma \\
\hline
U+1D739 & 𝜹 & {\textbackslash}mbfitdelta & Mathematical Bold Italic Small Delta \\
\hline
U+1D73A & 𝜺 & {\textbackslash}mbfitepsilon & Mathematical Bold Italic Small Epsilon \\
\hline
U+1D73B & 𝜻 & {\textbackslash}mbfitzeta & Mathematical Bold Italic Small Zeta \\
\hline
U+1D73C & 𝜼 & {\textbackslash}mbfiteta & Mathematical Bold Italic Small Eta \\
\hline
U+1D73D & 𝜽 & {\textbackslash}mbfittheta & Mathematical Bold Italic Small Theta \\
\hline
U+1D73E & 𝜾 & {\textbackslash}mbfitiota & Mathematical Bold Italic Small Iota \\
\hline
U+1D73F & 𝜿 & {\textbackslash}mbfitkappa & Mathematical Bold Italic Small Kappa \\
\hline
U+1D740 & 𝝀 & {\textbackslash}mbfitlambda & Mathematical Bold Italic Small Lamda \\
\hline
U+1D741 & 𝝁 & {\textbackslash}mbfitmu & Mathematical Bold Italic Small Mu \\
\hline
U+1D742 & 𝝂 & {\textbackslash}mbfitnu & Mathematical Bold Italic Small Nu \\
\hline
U+1D743 & 𝝃 & {\textbackslash}mbfitxi & Mathematical Bold Italic Small Xi \\
\hline
U+1D744 & 𝝄 & {\textbackslash}mbfitomicron & Mathematical Bold Italic Small Omicron \\
\hline
U+1D745 & 𝝅 & {\textbackslash}mbfitpi & Mathematical Bold Italic Small Pi \\
\hline
U+1D746 & 𝝆 & {\textbackslash}mbfitrho & Mathematical Bold Italic Small Rho \\
\hline
U+1D747 & 𝝇 & {\textbackslash}mbfitvarsigma & Mathematical Bold Italic Small Final Sigma \\
\hline
U+1D748 & 𝝈 & {\textbackslash}mbfitsigma & Mathematical Bold Italic Small Sigma \\
\hline
U+1D749 & 𝝉 & {\textbackslash}mbfittau & Mathematical Bold Italic Small Tau \\
\hline
U+1D74A & 𝝊 & {\textbackslash}mbfitupsilon & Mathematical Bold Italic Small Upsilon \\
\hline
U+1D74B & 𝝋 & {\textbackslash}mbfitphi & Mathematical Bold Italic Small Phi \\
\hline
U+1D74C & 𝝌 & {\textbackslash}mbfitchi & Mathematical Bold Italic Small Chi \\
\hline
U+1D74D & 𝝍 & {\textbackslash}mbfitpsi & Mathematical Bold Italic Small Psi \\
\hline
U+1D74E & 𝝎 & {\textbackslash}mbfitomega & Mathematical Bold Italic Small Omega \\
\hline
U+1D74F & 𝝏 & {\textbackslash}mbfitpartial & Mathematical Bold Italic Partial Differential \\
\hline
U+1D750 & 𝝐 & {\textbackslash}mbfitvarepsilon & Mathematical Bold Italic Epsilon Symbol \\
\hline
U+1D751 & 𝝑 & {\textbackslash}mbfitvartheta & Mathematical Bold Italic Theta Symbol \\
\hline
U+1D752 & 𝝒 & {\textbackslash}mbfitvarkappa & Mathematical Bold Italic Kappa Symbol \\
\hline
U+1D753 & 𝝓 & {\textbackslash}mbfitvarphi & Mathematical Bold Italic Phi Symbol \\
\hline
U+1D754 & 𝝔 & {\textbackslash}mbfitvarrho & Mathematical Bold Italic Rho Symbol \\
\hline
U+1D755 & 𝝕 & {\textbackslash}mbfitvarpi & Mathematical Bold Italic Pi Symbol \\
\hline
U+1D756 & 𝝖 & {\textbackslash}mbfsansAlpha & Mathematical Sans-serif Bold Capital Alpha \\
\hline
U+1D757 & 𝝗 & {\textbackslash}mbfsansBeta & Mathematical Sans-serif Bold Capital Beta \\
\hline
U+1D758 & 𝝘 & {\textbackslash}mbfsansGamma & Mathematical Sans-serif Bold Capital Gamma \\
\hline
U+1D759 & 𝝙 & {\textbackslash}mbfsansDelta & Mathematical Sans-serif Bold Capital Delta \\
\hline
U+1D75A & 𝝚 & {\textbackslash}mbfsansEpsilon & Mathematical Sans-serif Bold Capital Epsilon \\
\hline
U+1D75B & 𝝛 & {\textbackslash}mbfsansZeta & Mathematical Sans-serif Bold Capital Zeta \\
\hline
U+1D75C & 𝝜 & {\textbackslash}mbfsansEta & Mathematical Sans-serif Bold Capital Eta \\
\hline
U+1D75D & 𝝝 & {\textbackslash}mbfsansTheta & Mathematical Sans-serif Bold Capital Theta \\
\hline
U+1D75E & 𝝞 & {\textbackslash}mbfsansIota & Mathematical Sans-serif Bold Capital Iota \\
\hline
U+1D75F & 𝝟 & {\textbackslash}mbfsansKappa & Mathematical Sans-serif Bold Capital Kappa \\
\hline
U+1D760 & 𝝠 & {\textbackslash}mbfsansLambda & Mathematical Sans-serif Bold Capital Lamda \\
\hline
U+1D761 & 𝝡 & {\textbackslash}mbfsansMu & Mathematical Sans-serif Bold Capital Mu \\
\hline
U+1D762 & 𝝢 & {\textbackslash}mbfsansNu & Mathematical Sans-serif Bold Capital Nu \\
\hline
U+1D763 & 𝝣 & {\textbackslash}mbfsansXi & Mathematical Sans-serif Bold Capital Xi \\
\hline
U+1D764 & 𝝤 & {\textbackslash}mbfsansOmicron & Mathematical Sans-serif Bold Capital Omicron \\
\hline
U+1D765 & 𝝥 & {\textbackslash}mbfsansPi & Mathematical Sans-serif Bold Capital Pi \\
\hline
U+1D766 & 𝝦 & {\textbackslash}mbfsansRho & Mathematical Sans-serif Bold Capital Rho \\
\hline
U+1D767 & 𝝧 & {\textbackslash}mbfsansvarTheta & Mathematical Sans-serif Bold Capital Theta Symbol \\
\hline
U+1D768 & 𝝨 & {\textbackslash}mbfsansSigma & Mathematical Sans-serif Bold Capital Sigma \\
\hline
U+1D769 & 𝝩 & {\textbackslash}mbfsansTau & Mathematical Sans-serif Bold Capital Tau \\
\hline
U+1D76A & 𝝪 & {\textbackslash}mbfsansUpsilon & Mathematical Sans-serif Bold Capital Upsilon \\
\hline
U+1D76B & 𝝫 & {\textbackslash}mbfsansPhi & Mathematical Sans-serif Bold Capital Phi \\
\hline
U+1D76C & 𝝬 & {\textbackslash}mbfsansChi & Mathematical Sans-serif Bold Capital Chi \\
\hline
U+1D76D & 𝝭 & {\textbackslash}mbfsansPsi & Mathematical Sans-serif Bold Capital Psi \\
\hline
U+1D76E & 𝝮 & {\textbackslash}mbfsansOmega & Mathematical Sans-serif Bold Capital Omega \\
\hline
U+1D76F & 𝝯 & {\textbackslash}mbfsansnabla & Mathematical Sans-serif Bold Nabla \\
\hline
U+1D770 & 𝝰 & {\textbackslash}mbfsansalpha & Mathematical Sans-serif Bold Small Alpha \\
\hline
U+1D771 & 𝝱 & {\textbackslash}mbfsansbeta & Mathematical Sans-serif Bold Small Beta \\
\hline
U+1D772 & 𝝲 & {\textbackslash}mbfsansgamma & Mathematical Sans-serif Bold Small Gamma \\
\hline
U+1D773 & 𝝳 & {\textbackslash}mbfsansdelta & Mathematical Sans-serif Bold Small Delta \\
\hline
U+1D774 & 𝝴 & {\textbackslash}mbfsansepsilon & Mathematical Sans-serif Bold Small Epsilon \\
\hline
U+1D775 & 𝝵 & {\textbackslash}mbfsanszeta & Mathematical Sans-serif Bold Small Zeta \\
\hline
U+1D776 & 𝝶 & {\textbackslash}mbfsanseta & Mathematical Sans-serif Bold Small Eta \\
\hline
U+1D777 & 𝝷 & {\textbackslash}mbfsanstheta & Mathematical Sans-serif Bold Small Theta \\
\hline
U+1D778 & 𝝸 & {\textbackslash}mbfsansiota & Mathematical Sans-serif Bold Small Iota \\
\hline
U+1D779 & 𝝹 & {\textbackslash}mbfsanskappa & Mathematical Sans-serif Bold Small Kappa \\
\hline
U+1D77A & 𝝺 & {\textbackslash}mbfsanslambda & Mathematical Sans-serif Bold Small Lamda \\
\hline
U+1D77B & 𝝻 & {\textbackslash}mbfsansmu & Mathematical Sans-serif Bold Small Mu \\
\hline
U+1D77C & 𝝼 & {\textbackslash}mbfsansnu & Mathematical Sans-serif Bold Small Nu \\
\hline
U+1D77D & 𝝽 & {\textbackslash}mbfsansxi & Mathematical Sans-serif Bold Small Xi \\
\hline
U+1D77E & 𝝾 & {\textbackslash}mbfsansomicron & Mathematical Sans-serif Bold Small Omicron \\
\hline
U+1D77F & 𝝿 & {\textbackslash}mbfsanspi & Mathematical Sans-serif Bold Small Pi \\
\hline
U+1D780 & 𝞀 & {\textbackslash}mbfsansrho & Mathematical Sans-serif Bold Small Rho \\
\hline
U+1D781 & 𝞁 & {\textbackslash}mbfsansvarsigma & Mathematical Sans-serif Bold Small Final Sigma \\
\hline
U+1D782 & 𝞂 & {\textbackslash}mbfsanssigma & Mathematical Sans-serif Bold Small Sigma \\
\hline
U+1D783 & 𝞃 & {\textbackslash}mbfsanstau & Mathematical Sans-serif Bold Small Tau \\
\hline
U+1D784 & 𝞄 & {\textbackslash}mbfsansupsilon & Mathematical Sans-serif Bold Small Upsilon \\
\hline
U+1D785 & 𝞅 & {\textbackslash}mbfsansphi & Mathematical Sans-serif Bold Small Phi \\
\hline
U+1D786 & 𝞆 & {\textbackslash}mbfsanschi & Mathematical Sans-serif Bold Small Chi \\
\hline
U+1D787 & 𝞇 & {\textbackslash}mbfsanspsi & Mathematical Sans-serif Bold Small Psi \\
\hline
U+1D788 & 𝞈 & {\textbackslash}mbfsansomega & Mathematical Sans-serif Bold Small Omega \\
\hline
U+1D789 & 𝞉 & {\textbackslash}mbfsanspartial & Mathematical Sans-serif Bold Partial Differential \\
\hline
U+1D78A & 𝞊 & {\textbackslash}mbfsansvarepsilon & Mathematical Sans-serif Bold Epsilon Symbol \\
\hline
U+1D78B & 𝞋 & {\textbackslash}mbfsansvartheta & Mathematical Sans-serif Bold Theta Symbol \\
\hline
U+1D78C & 𝞌 & {\textbackslash}mbfsansvarkappa & Mathematical Sans-serif Bold Kappa Symbol \\
\hline
U+1D78D & 𝞍 & {\textbackslash}mbfsansvarphi & Mathematical Sans-serif Bold Phi Symbol \\
\hline
U+1D78E & 𝞎 & {\textbackslash}mbfsansvarrho & Mathematical Sans-serif Bold Rho Symbol \\
\hline
U+1D78F & 𝞏 & {\textbackslash}mbfsansvarpi & Mathematical Sans-serif Bold Pi Symbol \\
\hline
U+1D790 & 𝞐 & {\textbackslash}mbfitsansAlpha & Mathematical Sans-serif Bold Italic Capital Alpha \\
\hline
U+1D791 & 𝞑 & {\textbackslash}mbfitsansBeta & Mathematical Sans-serif Bold Italic Capital Beta \\
\hline
U+1D792 & 𝞒 & {\textbackslash}mbfitsansGamma & Mathematical Sans-serif Bold Italic Capital Gamma \\
\hline
U+1D793 & 𝞓 & {\textbackslash}mbfitsansDelta & Mathematical Sans-serif Bold Italic Capital Delta \\
\hline
U+1D794 & 𝞔 & {\textbackslash}mbfitsansEpsilon & Mathematical Sans-serif Bold Italic Capital Epsilon \\
\hline
U+1D795 & 𝞕 & {\textbackslash}mbfitsansZeta & Mathematical Sans-serif Bold Italic Capital Zeta \\
\hline
U+1D796 & 𝞖 & {\textbackslash}mbfitsansEta & Mathematical Sans-serif Bold Italic Capital Eta \\
\hline
U+1D797 & 𝞗 & {\textbackslash}mbfitsansTheta & Mathematical Sans-serif Bold Italic Capital Theta \\
\hline
U+1D798 & 𝞘 & {\textbackslash}mbfitsansIota & Mathematical Sans-serif Bold Italic Capital Iota \\
\hline
U+1D799 & 𝞙 & {\textbackslash}mbfitsansKappa & Mathematical Sans-serif Bold Italic Capital Kappa \\
\hline
U+1D79A & 𝞚 & {\textbackslash}mbfitsansLambda & Mathematical Sans-serif Bold Italic Capital Lamda \\
\hline
U+1D79B & 𝞛 & {\textbackslash}mbfitsansMu & Mathematical Sans-serif Bold Italic Capital Mu \\
\hline
U+1D79C & 𝞜 & {\textbackslash}mbfitsansNu & Mathematical Sans-serif Bold Italic Capital Nu \\
\hline
U+1D79D & 𝞝 & {\textbackslash}mbfitsansXi & Mathematical Sans-serif Bold Italic Capital Xi \\
\hline
U+1D79E & 𝞞 & {\textbackslash}mbfitsansOmicron & Mathematical Sans-serif Bold Italic Capital Omicron \\
\hline
U+1D79F & 𝞟 & {\textbackslash}mbfitsansPi & Mathematical Sans-serif Bold Italic Capital Pi \\
\hline
U+1D7A0 & 𝞠 & {\textbackslash}mbfitsansRho & Mathematical Sans-serif Bold Italic Capital Rho \\
\hline
U+1D7A1 & 𝞡 & {\textbackslash}mbfitsansvarTheta & Mathematical Sans-serif Bold Italic Capital Theta Symbol \\
\hline
U+1D7A2 & 𝞢 & {\textbackslash}mbfitsansSigma & Mathematical Sans-serif Bold Italic Capital Sigma \\
\hline
U+1D7A3 & 𝞣 & {\textbackslash}mbfitsansTau & Mathematical Sans-serif Bold Italic Capital Tau \\
\hline
U+1D7A4 & 𝞤 & {\textbackslash}mbfitsansUpsilon & Mathematical Sans-serif Bold Italic Capital Upsilon \\
\hline
U+1D7A5 & 𝞥 & {\textbackslash}mbfitsansPhi & Mathematical Sans-serif Bold Italic Capital Phi \\
\hline
U+1D7A6 & 𝞦 & {\textbackslash}mbfitsansChi & Mathematical Sans-serif Bold Italic Capital Chi \\
\hline
U+1D7A7 & 𝞧 & {\textbackslash}mbfitsansPsi & Mathematical Sans-serif Bold Italic Capital Psi \\
\hline
U+1D7A8 & 𝞨 & {\textbackslash}mbfitsansOmega & Mathematical Sans-serif Bold Italic Capital Omega \\
\hline
U+1D7A9 & 𝞩 & {\textbackslash}mbfitsansnabla & Mathematical Sans-serif Bold Italic Nabla \\
\hline
U+1D7AA & 𝞪 & {\textbackslash}mbfitsansalpha & Mathematical Sans-serif Bold Italic Small Alpha \\
\hline
U+1D7AB & 𝞫 & {\textbackslash}mbfitsansbeta & Mathematical Sans-serif Bold Italic Small Beta \\
\hline
U+1D7AC & 𝞬 & {\textbackslash}mbfitsansgamma & Mathematical Sans-serif Bold Italic Small Gamma \\
\hline
U+1D7AD & 𝞭 & {\textbackslash}mbfitsansdelta & Mathematical Sans-serif Bold Italic Small Delta \\
\hline
U+1D7AE & 𝞮 & {\textbackslash}mbfitsansepsilon & Mathematical Sans-serif Bold Italic Small Epsilon \\
\hline
U+1D7AF & 𝞯 & {\textbackslash}mbfitsanszeta & Mathematical Sans-serif Bold Italic Small Zeta \\
\hline
U+1D7B0 & 𝞰 & {\textbackslash}mbfitsanseta & Mathematical Sans-serif Bold Italic Small Eta \\
\hline
U+1D7B1 & 𝞱 & {\textbackslash}mbfitsanstheta & Mathematical Sans-serif Bold Italic Small Theta \\
\hline
U+1D7B2 & 𝞲 & {\textbackslash}mbfitsansiota & Mathematical Sans-serif Bold Italic Small Iota \\
\hline
U+1D7B3 & 𝞳 & {\textbackslash}mbfitsanskappa & Mathematical Sans-serif Bold Italic Small Kappa \\
\hline
U+1D7B4 & 𝞴 & {\textbackslash}mbfitsanslambda & Mathematical Sans-serif Bold Italic Small Lamda \\
\hline
U+1D7B5 & 𝞵 & {\textbackslash}mbfitsansmu & Mathematical Sans-serif Bold Italic Small Mu \\
\hline
U+1D7B6 & 𝞶 & {\textbackslash}mbfitsansnu & Mathematical Sans-serif Bold Italic Small Nu \\
\hline
U+1D7B7 & 𝞷 & {\textbackslash}mbfitsansxi & Mathematical Sans-serif Bold Italic Small Xi \\
\hline
U+1D7B8 & 𝞸 & {\textbackslash}mbfitsansomicron & Mathematical Sans-serif Bold Italic Small Omicron \\
\hline
U+1D7B9 & 𝞹 & {\textbackslash}mbfitsanspi & Mathematical Sans-serif Bold Italic Small Pi \\
\hline
U+1D7BA & 𝞺 & {\textbackslash}mbfitsansrho & Mathematical Sans-serif Bold Italic Small Rho \\
\hline
U+1D7BB & 𝞻 & {\textbackslash}mbfitsansvarsigma & Mathematical Sans-serif Bold Italic Small Final Sigma \\
\hline
U+1D7BC & 𝞼 & {\textbackslash}mbfitsanssigma & Mathematical Sans-serif Bold Italic Small Sigma \\
\hline
U+1D7BD & 𝞽 & {\textbackslash}mbfitsanstau & Mathematical Sans-serif Bold Italic Small Tau \\
\hline
U+1D7BE & 𝞾 & {\textbackslash}mbfitsansupsilon & Mathematical Sans-serif Bold Italic Small Upsilon \\
\hline
U+1D7BF & 𝞿 & {\textbackslash}mbfitsansphi & Mathematical Sans-serif Bold Italic Small Phi \\
\hline
U+1D7C0 & 𝟀 & {\textbackslash}mbfitsanschi & Mathematical Sans-serif Bold Italic Small Chi \\
\hline
U+1D7C1 & 𝟁 & {\textbackslash}mbfitsanspsi & Mathematical Sans-serif Bold Italic Small Psi \\
\hline
U+1D7C2 & 𝟂 & {\textbackslash}mbfitsansomega & Mathematical Sans-serif Bold Italic Small Omega \\
\hline
U+1D7C3 & 𝟃 & {\textbackslash}mbfitsanspartial & Mathematical Sans-serif Bold Italic Partial Differential \\
\hline
U+1D7C4 & 𝟄 & {\textbackslash}mbfitsansvarepsilon & Mathematical Sans-serif Bold Italic Epsilon Symbol \\
\hline
U+1D7C5 & 𝟅 & {\textbackslash}mbfitsansvartheta & Mathematical Sans-serif Bold Italic Theta Symbol \\
\hline
U+1D7C6 & 𝟆 & {\textbackslash}mbfitsansvarkappa & Mathematical Sans-serif Bold Italic Kappa Symbol \\
\hline
U+1D7C7 & 𝟇 & {\textbackslash}mbfitsansvarphi & Mathematical Sans-serif Bold Italic Phi Symbol \\
\hline
U+1D7C8 & 𝟈 & {\textbackslash}mbfitsansvarrho & Mathematical Sans-serif Bold Italic Rho Symbol \\
\hline
U+1D7C9 & 𝟉 & {\textbackslash}mbfitsansvarpi & Mathematical Sans-serif Bold Italic Pi Symbol \\
\hline
U+1D7CA & 𝟊 & {\textbackslash}mbfDigamma & Mathematical Bold Capital Digamma \\
\hline
U+1D7CB & 𝟋 & {\textbackslash}mbfdigamma & Mathematical Bold Small Digamma \\
\hline
U+1D7CE & 𝟎 & {\textbackslash}mbfzero & Mathematical Bold Digit Zero \\
\hline
U+1D7CF & 𝟏 & {\textbackslash}mbfone & Mathematical Bold Digit One \\
\hline
U+1D7D0 & 𝟐 & {\textbackslash}mbftwo & Mathematical Bold Digit Two \\
\hline
U+1D7D1 & 𝟑 & {\textbackslash}mbfthree & Mathematical Bold Digit Three \\
\hline
U+1D7D2 & 𝟒 & {\textbackslash}mbffour & Mathematical Bold Digit Four \\
\hline
U+1D7D3 & 𝟓 & {\textbackslash}mbffive & Mathematical Bold Digit Five \\
\hline
U+1D7D4 & 𝟔 & {\textbackslash}mbfsix & Mathematical Bold Digit Six \\
\hline
U+1D7D5 & 𝟕 & {\textbackslash}mbfseven & Mathematical Bold Digit Seven \\
\hline
U+1D7D6 & 𝟖 & {\textbackslash}mbfeight & Mathematical Bold Digit Eight \\
\hline
U+1D7D7 & 𝟗 & {\textbackslash}mbfnine & Mathematical Bold Digit Nine \\
\hline
U+1D7D8 & 𝟘 & {\textbackslash}Bbbzero & Mathematical Double-struck Digit Zero \\
\hline
U+1D7D9 & 𝟙 & {\textbackslash}Bbbone & Mathematical Double-struck Digit One \\
\hline
U+1D7DA & 𝟚 & {\textbackslash}Bbbtwo & Mathematical Double-struck Digit Two \\
\hline
U+1D7DB & 𝟛 & {\textbackslash}Bbbthree & Mathematical Double-struck Digit Three \\
\hline
U+1D7DC & 𝟜 & {\textbackslash}Bbbfour & Mathematical Double-struck Digit Four \\
\hline
U+1D7DD & 𝟝 & {\textbackslash}Bbbfive & Mathematical Double-struck Digit Five \\
\hline
U+1D7DE & 𝟞 & {\textbackslash}Bbbsix & Mathematical Double-struck Digit Six \\
\hline
U+1D7DF & 𝟟 & {\textbackslash}Bbbseven & Mathematical Double-struck Digit Seven \\
\hline
U+1D7E0 & 𝟠 & {\textbackslash}Bbbeight & Mathematical Double-struck Digit Eight \\
\hline
U+1D7E1 & 𝟡 & {\textbackslash}Bbbnine & Mathematical Double-struck Digit Nine \\
\hline
U+1D7E2 & 𝟢 & {\textbackslash}msanszero & Mathematical Sans-serif Digit Zero \\
\hline
U+1D7E3 & 𝟣 & {\textbackslash}msansone & Mathematical Sans-serif Digit One \\
\hline
U+1D7E4 & 𝟤 & {\textbackslash}msanstwo & Mathematical Sans-serif Digit Two \\
\hline
U+1D7E5 & 𝟥 & {\textbackslash}msansthree & Mathematical Sans-serif Digit Three \\
\hline
U+1D7E6 & 𝟦 & {\textbackslash}msansfour & Mathematical Sans-serif Digit Four \\
\hline
U+1D7E7 & 𝟧 & {\textbackslash}msansfive & Mathematical Sans-serif Digit Five \\
\hline
U+1D7E8 & 𝟨 & {\textbackslash}msanssix & Mathematical Sans-serif Digit Six \\
\hline
U+1D7E9 & 𝟩 & {\textbackslash}msansseven & Mathematical Sans-serif Digit Seven \\
\hline
U+1D7EA & 𝟪 & {\textbackslash}msanseight & Mathematical Sans-serif Digit Eight \\
\hline
U+1D7EB & 𝟫 & {\textbackslash}msansnine & Mathematical Sans-serif Digit Nine \\
\hline
U+1D7EC & 𝟬 & {\textbackslash}mbfsanszero & Mathematical Sans-serif Bold Digit Zero \\
\hline
U+1D7ED & 𝟭 & {\textbackslash}mbfsansone & Mathematical Sans-serif Bold Digit One \\
\hline
U+1D7EE & 𝟮 & {\textbackslash}mbfsanstwo & Mathematical Sans-serif Bold Digit Two \\
\hline
U+1D7EF & 𝟯 & {\textbackslash}mbfsansthree & Mathematical Sans-serif Bold Digit Three \\
\hline
U+1D7F0 & 𝟰 & {\textbackslash}mbfsansfour & Mathematical Sans-serif Bold Digit Four \\
\hline
U+1D7F1 & 𝟱 & {\textbackslash}mbfsansfive & Mathematical Sans-serif Bold Digit Five \\
\hline
U+1D7F2 & 𝟲 & {\textbackslash}mbfsanssix & Mathematical Sans-serif Bold Digit Six \\
\hline
U+1D7F3 & 𝟳 & {\textbackslash}mbfsansseven & Mathematical Sans-serif Bold Digit Seven \\
\hline
U+1D7F4 & 𝟴 & {\textbackslash}mbfsanseight & Mathematical Sans-serif Bold Digit Eight \\
\hline
U+1D7F5 & 𝟵 & {\textbackslash}mbfsansnine & Mathematical Sans-serif Bold Digit Nine \\
\hline
U+1D7F6 & 𝟶 & {\textbackslash}mttzero & Mathematical Monospace Digit Zero \\
\hline
U+1D7F7 & 𝟷 & {\textbackslash}mttone & Mathematical Monospace Digit One \\
\hline
U+1D7F8 & 𝟸 & {\textbackslash}mtttwo & Mathematical Monospace Digit Two \\
\hline
U+1D7F9 & 𝟹 & {\textbackslash}mttthree & Mathematical Monospace Digit Three \\
\hline
U+1D7FA & 𝟺 & {\textbackslash}mttfour & Mathematical Monospace Digit Four \\
\hline
U+1D7FB & 𝟻 & {\textbackslash}mttfive & Mathematical Monospace Digit Five \\
\hline
U+1D7FC & 𝟼 & {\textbackslash}mttsix & Mathematical Monospace Digit Six \\
\hline
U+1D7FD & 𝟽 & {\textbackslash}mttseven & Mathematical Monospace Digit Seven \\
\hline
U+1D7FE & 𝟾 & {\textbackslash}mtteight & Mathematical Monospace Digit Eight \\
\hline
U+1D7FF & 𝟿 & {\textbackslash}mttnine & Mathematical Monospace Digit Nine \\
\hline
U+1F004 & 🀄 & {\textbackslash}:mahjong: & Mahjong Tile Red Dragon \\
\hline
U+1F0CF & 🃏 & {\textbackslash}:black\_joker: & Playing Card Black Joker \\
\hline
U+1F170 & 🅰 & {\textbackslash}:a: & Negative Squared Latin Capital Letter A \\
\hline
U+1F171 & 🅱 & {\textbackslash}:b: & Negative Squared Latin Capital Letter B \\
\hline
U+1F17E & 🅾 & {\textbackslash}:o2: & Negative Squared Latin Capital Letter O \\
\hline
U+1F17F & 🅿 & {\textbackslash}:parking: & Negative Squared Latin Capital Letter P \\
\hline
U+1F18E & 🆎 & {\textbackslash}:ab: & Negative Squared Ab \\
\hline
U+1F191 & 🆑 & {\textbackslash}:cl: & Squared Cl \\
\hline
U+1F192 & 🆒 & {\textbackslash}:cool: & Squared Cool \\
\hline
U+1F193 & 🆓 & {\textbackslash}:free: & Squared Free \\
\hline
U+1F194 & 🆔 & {\textbackslash}:id: & Squared Id \\
\hline
U+1F195 & 🆕 & {\textbackslash}:new: & Squared New \\
\hline
U+1F196 & 🆖 & {\textbackslash}:ng: & Squared Ng \\
\hline
U+1F197 & 🆗 & {\textbackslash}:ok: & Squared Ok \\
\hline
U+1F198 & 🆘 & {\textbackslash}:sos: & Squared Sos \\
\hline
U+1F199 & 🆙 & {\textbackslash}:up: & Squared Up With Exclamation Mark \\
\hline
U+1F19A & 🆚 & {\textbackslash}:vs: & Squared Vs \\
\hline
U+1F201 & 🈁 & {\textbackslash}:koko: & Squared Katakana Koko \\
\hline
U+1F202 & 🈂 & {\textbackslash}:sa: & Squared Katakana Sa \\
\hline
U+1F21A & 🈚 & {\textbackslash}:u7121: & Squared Cjk Unified Ideograph-7121 \\
\hline
U+1F22F & 🈯 & {\textbackslash}:u6307: & Squared Cjk Unified Ideograph-6307 \\
\hline
U+1F232 & 🈲 & {\textbackslash}:u7981: & Squared Cjk Unified Ideograph-7981 \\
\hline
U+1F233 & 🈳 & {\textbackslash}:u7a7a: & Squared Cjk Unified Ideograph-7a7a \\
\hline
U+1F234 & 🈴 & {\textbackslash}:u5408: & Squared Cjk Unified Ideograph-5408 \\
\hline
U+1F235 & 🈵 & {\textbackslash}:u6e80: & Squared Cjk Unified Ideograph-6e80 \\
\hline
U+1F236 & 🈶 & {\textbackslash}:u6709: & Squared Cjk Unified Ideograph-6709 \\
\hline
U+1F237 & 🈷 & {\textbackslash}:u6708: & Squared Cjk Unified Ideograph-6708 \\
\hline
U+1F238 & 🈸 & {\textbackslash}:u7533: & Squared Cjk Unified Ideograph-7533 \\
\hline
U+1F239 & 🈹 & {\textbackslash}:u5272: & Squared Cjk Unified Ideograph-5272 \\
\hline
U+1F23A & 🈺 & {\textbackslash}:u55b6: & Squared Cjk Unified Ideograph-55b6 \\
\hline
U+1F250 & 🉐 & {\textbackslash}:ideograph\_advantage: & Circled Ideograph Advantage \\
\hline
U+1F251 & 🉑 & {\textbackslash}:accept: & Circled Ideograph Accept \\
\hline
U+1F300 & 🌀 & {\textbackslash}:cyclone: & Cyclone \\
\hline
U+1F301 & 🌁 & {\textbackslash}:foggy: & Foggy \\
\hline
U+1F302 & 🌂 & {\textbackslash}:closed\_umbrella: & Closed Umbrella \\
\hline
U+1F303 & 🌃 & {\textbackslash}:night\_with\_stars: & Night With Stars \\
\hline
U+1F304 & 🌄 & {\textbackslash}:sunrise\_over\_mountains: & Sunrise Over Mountains \\
\hline
U+1F305 & 🌅 & {\textbackslash}:sunrise: & Sunrise \\
\hline
U+1F306 & 🌆 & {\textbackslash}:city\_sunset: & Cityscape At Dusk \\
\hline
U+1F307 & 🌇 & {\textbackslash}:city\_sunrise: & Sunset Over Buildings \\
\hline
U+1F308 & 🌈 & {\textbackslash}:rainbow: & Rainbow \\
\hline
U+1F309 & 🌉 & {\textbackslash}:bridge\_at\_night: & Bridge At Night \\
\hline
U+1F30A & 🌊 & {\textbackslash}:ocean: & Water Wave \\
\hline
U+1F30B & 🌋 & {\textbackslash}:volcano: & Volcano \\
\hline
U+1F30C & 🌌 & {\textbackslash}:milky\_way: & Milky Way \\
\hline
U+1F30D & 🌍 & {\textbackslash}:earth\_africa: & Earth Globe Europe-africa \\
\hline
U+1F30E & 🌎 & {\textbackslash}:earth\_americas: & Earth Globe Americas \\
\hline
U+1F30F & 🌏 & {\textbackslash}:earth\_asia: & Earth Globe Asia-australia \\
\hline
U+1F310 & 🌐 & {\textbackslash}:globe\_with\_meridians: & Globe With Meridians \\
\hline
U+1F311 & 🌑 & {\textbackslash}:new\_moon: & New Moon Symbol \\
\hline
U+1F312 & 🌒 & {\textbackslash}:waxing\_crescent\_moon: & Waxing Crescent Moon Symbol \\
\hline
U+1F313 & 🌓 & {\textbackslash}:first\_quarter\_moon: & First Quarter Moon Symbol \\
\hline
U+1F314 & 🌔 & {\textbackslash}:moon: & Waxing Gibbous Moon Symbol \\
\hline
U+1F315 & 🌕 & {\textbackslash}:full\_moon: & Full Moon Symbol \\
\hline
U+1F316 & 🌖 & {\textbackslash}:waning\_gibbous\_moon: & Waning Gibbous Moon Symbol \\
\hline
U+1F317 & 🌗 & {\textbackslash}:last\_quarter\_moon: & Last Quarter Moon Symbol \\
\hline
U+1F318 & 🌘 & {\textbackslash}:waning\_crescent\_moon: & Waning Crescent Moon Symbol \\
\hline
U+1F319 & 🌙 & {\textbackslash}:crescent\_moon: & Crescent Moon \\
\hline
U+1F31A & 🌚 & {\textbackslash}:new\_moon\_with\_face: & New Moon With Face \\
\hline
U+1F31B & 🌛 & {\textbackslash}:first\_quarter\_moon\_with\_face: & First Quarter Moon With Face \\
\hline
U+1F31C & 🌜 & {\textbackslash}:last\_quarter\_moon\_with\_face: & Last Quarter Moon With Face \\
\hline
U+1F31D & 🌝 & {\textbackslash}:full\_moon\_with\_face: & Full Moon With Face \\
\hline
U+1F31E & 🌞 & {\textbackslash}:sun\_with\_face: & Sun With Face \\
\hline
U+1F31F & 🌟 & {\textbackslash}:star2: & Glowing Star \\
\hline
U+1F320 & 🌠 & {\textbackslash}:stars: & Shooting Star \\
\hline
U+1F330 & 🌰 & {\textbackslash}:chestnut: & Chestnut \\
\hline
U+1F331 & 🌱 & {\textbackslash}:seedling: & Seedling \\
\hline
U+1F332 & 🌲 & {\textbackslash}:evergreen\_tree: & Evergreen Tree \\
\hline
U+1F333 & 🌳 & {\textbackslash}:deciduous\_tree: & Deciduous Tree \\
\hline
U+1F334 & 🌴 & {\textbackslash}:palm\_tree: & Palm Tree \\
\hline
U+1F335 & 🌵 & {\textbackslash}:cactus: & Cactus \\
\hline
U+1F337 & 🌷 & {\textbackslash}:tulip: & Tulip \\
\hline
U+1F338 & 🌸 & {\textbackslash}:cherry\_blossom: & Cherry Blossom \\
\hline
U+1F339 & 🌹 & {\textbackslash}:rose: & Rose \\
\hline
U+1F33A & 🌺 & {\textbackslash}:hibiscus: & Hibiscus \\
\hline
U+1F33B & 🌻 & {\textbackslash}:sunflower: & Sunflower \\
\hline
U+1F33C & 🌼 & {\textbackslash}:blossom: & Blossom \\
\hline
U+1F33D & 🌽 & {\textbackslash}:corn: & Ear Of Maize \\
\hline
U+1F33E & 🌾 & {\textbackslash}:ear\_of\_rice: & Ear Of Rice \\
\hline
U+1F33F & 🌿 & {\textbackslash}:herb: & Herb \\
\hline
U+1F340 & 🍀 & {\textbackslash}:four\_leaf\_clover: & Four Leaf Clover \\
\hline
U+1F341 & 🍁 & {\textbackslash}:maple\_leaf: & Maple Leaf \\
\hline
U+1F342 & 🍂 & {\textbackslash}:fallen\_leaf: & Fallen Leaf \\
\hline
U+1F343 & 🍃 & {\textbackslash}:leaves: & Leaf Fluttering In Wind \\
\hline
U+1F344 & 🍄 & {\textbackslash}:mushroom: & Mushroom \\
\hline
U+1F345 & 🍅 & {\textbackslash}:tomato: & Tomato \\
\hline
U+1F346 & 🍆 & {\textbackslash}:eggplant: & Aubergine \\
\hline
U+1F347 & 🍇 & {\textbackslash}:grapes: & Grapes \\
\hline
U+1F348 & 🍈 & {\textbackslash}:melon: & Melon \\
\hline
U+1F349 & 🍉 & {\textbackslash}:watermelon: & Watermelon \\
\hline
U+1F34A & 🍊 & {\textbackslash}:tangerine: & Tangerine \\
\hline
U+1F34B & 🍋 & {\textbackslash}:lemon: & Lemon \\
\hline
U+1F34C & 🍌 & {\textbackslash}:banana: & Banana \\
\hline
U+1F34D & 🍍 & {\textbackslash}:pineapple: & Pineapple \\
\hline
U+1F34E & 🍎 & {\textbackslash}:apple: & Red Apple \\
\hline
U+1F34F & 🍏 & {\textbackslash}:green\_apple: & Green Apple \\
\hline
U+1F350 & 🍐 & {\textbackslash}:pear: & Pear \\
\hline
U+1F351 & 🍑 & {\textbackslash}:peach: & Peach \\
\hline
U+1F352 & 🍒 & {\textbackslash}:cherries: & Cherries \\
\hline
U+1F353 & 🍓 & {\textbackslash}:strawberry: & Strawberry \\
\hline
U+1F354 & 🍔 & {\textbackslash}:hamburger: & Hamburger \\
\hline
U+1F355 & 🍕 & {\textbackslash}:pizza: & Slice Of Pizza \\
\hline
U+1F356 & 🍖 & {\textbackslash}:meat\_on\_bone: & Meat On Bone \\
\hline
U+1F357 & 🍗 & {\textbackslash}:poultry\_leg: & Poultry Leg \\
\hline
U+1F358 & 🍘 & {\textbackslash}:rice\_cracker: & Rice Cracker \\
\hline
U+1F359 & 🍙 & {\textbackslash}:rice\_ball: & Rice Ball \\
\hline
U+1F35A & 🍚 & {\textbackslash}:rice: & Cooked Rice \\
\hline
U+1F35B & 🍛 & {\textbackslash}:curry: & Curry And Rice \\
\hline
U+1F35C & 🍜 & {\textbackslash}:ramen: & Steaming Bowl \\
\hline
U+1F35D & 🍝 & {\textbackslash}:spaghetti: & Spaghetti \\
\hline
U+1F35E & 🍞 & {\textbackslash}:bread: & Bread \\
\hline
U+1F35F & 🍟 & {\textbackslash}:fries: & French Fries \\
\hline
U+1F360 & 🍠 & {\textbackslash}:sweet\_potato: & Roasted Sweet Potato \\
\hline
U+1F361 & 🍡 & {\textbackslash}:dango: & Dango \\
\hline
U+1F362 & 🍢 & {\textbackslash}:oden: & Oden \\
\hline
U+1F363 & 🍣 & {\textbackslash}:sushi: & Sushi \\
\hline
U+1F364 & 🍤 & {\textbackslash}:fried\_shrimp: & Fried Shrimp \\
\hline
U+1F365 & 🍥 & {\textbackslash}:fish\_cake: & Fish Cake With Swirl Design \\
\hline
U+1F366 & 🍦 & {\textbackslash}:icecream: & Soft Ice Cream \\
\hline
U+1F367 & 🍧 & {\textbackslash}:shaved\_ice: & Shaved Ice \\
\hline
U+1F368 & 🍨 & {\textbackslash}:ice\_cream: & Ice Cream \\
\hline
U+1F369 & 🍩 & {\textbackslash}:doughnut: & Doughnut \\
\hline
U+1F36A & 🍪 & {\textbackslash}:cookie: & Cookie \\
\hline
U+1F36B & 🍫 & {\textbackslash}:chocolate\_bar: & Chocolate Bar \\
\hline
U+1F36C & 🍬 & {\textbackslash}:candy: & Candy \\
\hline
U+1F36D & 🍭 & {\textbackslash}:lollipop: & Lollipop \\
\hline
U+1F36E & 🍮 & {\textbackslash}:custard: & Custard \\
\hline
U+1F36F & 🍯 & {\textbackslash}:honey\_pot: & Honey Pot \\
\hline
U+1F370 & 🍰 & {\textbackslash}:cake: & Shortcake \\
\hline
U+1F371 & 🍱 & {\textbackslash}:bento: & Bento Box \\
\hline
U+1F372 & 🍲 & {\textbackslash}:stew: & Pot Of Food \\
\hline
U+1F373 & 🍳 & {\textbackslash}:egg: & Cooking \\
\hline
U+1F374 & 🍴 & {\textbackslash}:fork\_and\_knife: & Fork And Knife \\
\hline
U+1F375 & 🍵 & {\textbackslash}:tea: & Teacup Without Handle \\
\hline
U+1F376 & 🍶 & {\textbackslash}:sake: & Sake Bottle And Cup \\
\hline
U+1F377 & 🍷 & {\textbackslash}:wine\_glass: & Wine Glass \\
\hline
U+1F378 & 🍸 & {\textbackslash}:cocktail: & Cocktail Glass \\
\hline
U+1F379 & 🍹 & {\textbackslash}:tropical\_drink: & Tropical Drink \\
\hline
U+1F37A & 🍺 & {\textbackslash}:beer: & Beer Mug \\
\hline
U+1F37B & 🍻 & {\textbackslash}:beers: & Clinking Beer Mugs \\
\hline
U+1F37C & 🍼 & {\textbackslash}:baby\_bottle: & Baby Bottle \\
\hline
U+1F380 & 🎀 & {\textbackslash}:ribbon: & Ribbon \\
\hline
U+1F381 & 🎁 & {\textbackslash}:gift: & Wrapped Present \\
\hline
U+1F382 & 🎂 & {\textbackslash}:birthday: & Birthday Cake \\
\hline
U+1F383 & 🎃 & {\textbackslash}:jack\_o\_lantern: & Jack-o-lantern \\
\hline
U+1F384 & 🎄 & {\textbackslash}:christmas\_tree: & Christmas Tree \\
\hline
U+1F385 & 🎅 & {\textbackslash}:santa: & Father Christmas \\
\hline
U+1F386 & 🎆 & {\textbackslash}:fireworks: & Fireworks \\
\hline
U+1F387 & 🎇 & {\textbackslash}:sparkler: & Firework Sparkler \\
\hline
U+1F388 & 🎈 & {\textbackslash}:balloon: & Balloon \\
\hline
U+1F389 & 🎉 & {\textbackslash}:tada: & Party Popper \\
\hline
U+1F38A & 🎊 & {\textbackslash}:confetti\_ball: & Confetti Ball \\
\hline
U+1F38B & 🎋 & {\textbackslash}:tanabata\_tree: & Tanabata Tree \\
\hline
U+1F38C & 🎌 & {\textbackslash}:crossed\_flags: & Crossed Flags \\
\hline
U+1F38D & 🎍 & {\textbackslash}:bamboo: & Pine Decoration \\
\hline
U+1F38E & 🎎 & {\textbackslash}:dolls: & Japanese Dolls \\
\hline
U+1F38F & 🎏 & {\textbackslash}:flags: & Carp Streamer \\
\hline
U+1F390 & 🎐 & {\textbackslash}:wind\_chime: & Wind Chime \\
\hline
U+1F391 & 🎑 & {\textbackslash}:rice\_scene: & Moon Viewing Ceremony \\
\hline
U+1F392 & 🎒 & {\textbackslash}:school\_satchel: & School Satchel \\
\hline
U+1F393 & 🎓 & {\textbackslash}:mortar\_board: & Graduation Cap \\
\hline
U+1F3A0 & 🎠 & {\textbackslash}:carousel\_horse: & Carousel Horse \\
\hline
U+1F3A1 & 🎡 & {\textbackslash}:ferris\_wheel: & Ferris Wheel \\
\hline
U+1F3A2 & 🎢 & {\textbackslash}:roller\_coaster: & Roller Coaster \\
\hline
U+1F3A3 & 🎣 & {\textbackslash}:fishing\_pole\_and\_fish: & Fishing Pole And Fish \\
\hline
U+1F3A4 & 🎤 & {\textbackslash}:microphone: & Microphone \\
\hline
U+1F3A5 & 🎥 & {\textbackslash}:movie\_camera: & Movie Camera \\
\hline
U+1F3A6 & 🎦 & {\textbackslash}:cinema: & Cinema \\
\hline
U+1F3A7 & 🎧 & {\textbackslash}:headphones: & Headphone \\
\hline
U+1F3A8 & 🎨 & {\textbackslash}:art: & Artist Palette \\
\hline
U+1F3A9 & 🎩 & {\textbackslash}:tophat: & Top Hat \\
\hline
U+1F3AA & 🎪 & {\textbackslash}:circus\_tent: & Circus Tent \\
\hline
U+1F3AB & 🎫 & {\textbackslash}:ticket: & Ticket \\
\hline
U+1F3AC & 🎬 & {\textbackslash}:clapper: & Clapper Board \\
\hline
U+1F3AD & 🎭 & {\textbackslash}:performing\_arts: & Performing Arts \\
\hline
U+1F3AE & 🎮 & {\textbackslash}:video\_game: & Video Game \\
\hline
U+1F3AF & 🎯 & {\textbackslash}:dart: & Direct Hit \\
\hline
U+1F3B0 & 🎰 & {\textbackslash}:slot\_machine: & Slot Machine \\
\hline
U+1F3B1 & 🎱 & {\textbackslash}:8ball: & Billiards \\
\hline
U+1F3B2 & 🎲 & {\textbackslash}:game\_die: & Game Die \\
\hline
U+1F3B3 & 🎳 & {\textbackslash}:bowling: & Bowling \\
\hline
U+1F3B4 & 🎴 & {\textbackslash}:flower\_playing\_cards: & Flower Playing Cards \\
\hline
U+1F3B5 & 🎵 & {\textbackslash}:musical\_note: & Musical Note \\
\hline
U+1F3B6 & 🎶 & {\textbackslash}:notes: & Multiple Musical Notes \\
\hline
U+1F3B7 & 🎷 & {\textbackslash}:saxophone: & Saxophone \\
\hline
U+1F3B8 & 🎸 & {\textbackslash}:guitar: & Guitar \\
\hline
U+1F3B9 & 🎹 & {\textbackslash}:musical\_keyboard: & Musical Keyboard \\
\hline
U+1F3BA & 🎺 & {\textbackslash}:trumpet: & Trumpet \\
\hline
U+1F3BB & 🎻 & {\textbackslash}:violin: & Violin \\
\hline
U+1F3BC & 🎼 & {\textbackslash}:musical\_score: & Musical Score \\
\hline
U+1F3BD & 🎽 & {\textbackslash}:running\_shirt\_with\_sash: & Running Shirt With Sash \\
\hline
U+1F3BE & 🎾 & {\textbackslash}:tennis: & Tennis Racquet And Ball \\
\hline
U+1F3BF & 🎿 & {\textbackslash}:ski: & Ski And Ski Boot \\
\hline
U+1F3C0 & 🏀 & {\textbackslash}:basketball: & Basketball And Hoop \\
\hline
U+1F3C1 & 🏁 & {\textbackslash}:checkered\_flag: & Chequered Flag \\
\hline
U+1F3C2 & 🏂 & {\textbackslash}:snowboarder: & Snowboarder \\
\hline
U+1F3C3 & 🏃 & {\textbackslash}:runner: & Runner \\
\hline
U+1F3C4 & 🏄 & {\textbackslash}:surfer: & Surfer \\
\hline
U+1F3C6 & 🏆 & {\textbackslash}:trophy: & Trophy \\
\hline
U+1F3C7 & 🏇 & {\textbackslash}:horse\_racing: & Horse Racing \\
\hline
U+1F3C8 & 🏈 & {\textbackslash}:football: & American Football \\
\hline
U+1F3C9 & 🏉 & {\textbackslash}:rugby\_football: & Rugby Football \\
\hline
U+1F3CA & 🏊 & {\textbackslash}:swimmer: & Swimmer \\
\hline
U+1F3E0 & 🏠 & {\textbackslash}:house: & House Building \\
\hline
U+1F3E1 & 🏡 & {\textbackslash}:house\_with\_garden: & House With Garden \\
\hline
U+1F3E2 & 🏢 & {\textbackslash}:office: & Office Building \\
\hline
U+1F3E3 & 🏣 & {\textbackslash}:post\_office: & Japanese Post Office \\
\hline
U+1F3E4 & 🏤 & {\textbackslash}:european\_post\_office: & European Post Office \\
\hline
U+1F3E5 & 🏥 & {\textbackslash}:hospital: & Hospital \\
\hline
U+1F3E6 & 🏦 & {\textbackslash}:bank: & Bank \\
\hline
U+1F3E7 & 🏧 & {\textbackslash}:atm: & Automated Teller Machine \\
\hline
U+1F3E8 & 🏨 & {\textbackslash}:hotel: & Hotel \\
\hline
U+1F3E9 & 🏩 & {\textbackslash}:love\_hotel: & Love Hotel \\
\hline
U+1F3EA & 🏪 & {\textbackslash}:convenience\_store: & Convenience Store \\
\hline
U+1F3EB & 🏫 & {\textbackslash}:school: & School \\
\hline
U+1F3EC & 🏬 & {\textbackslash}:department\_store: & Department Store \\
\hline
U+1F3ED & 🏭 & {\textbackslash}:factory: & Factory \\
\hline
U+1F3EE & 🏮 & {\textbackslash}:izakaya\_lantern: & Izakaya Lantern \\
\hline
U+1F3EF & 🏯 & {\textbackslash}:japanese\_castle: & Japanese Castle \\
\hline
U+1F3F0 & 🏰 & {\textbackslash}:european\_castle: & European Castle \\
\hline
U+1F3FB & 🏻 & {\textbackslash}:skin-tone-2: & Emoji Modifier Fitzpatrick Type-1-2 \\
\hline
U+1F3FC & 🏼 & {\textbackslash}:skin-tone-3: & Emoji Modifier Fitzpatrick Type-3 \\
\hline
U+1F3FD & 🏽 & {\textbackslash}:skin-tone-4: & Emoji Modifier Fitzpatrick Type-4 \\
\hline
U+1F3FE & 🏾 & {\textbackslash}:skin-tone-5: & Emoji Modifier Fitzpatrick Type-5 \\
\hline
U+1F3FF & 🏿 & {\textbackslash}:skin-tone-6: & Emoji Modifier Fitzpatrick Type-6 \\
\hline
U+1F400 & 🐀 & {\textbackslash}:rat: & Rat \\
\hline
U+1F401 & 🐁 & {\textbackslash}:mouse2: & Mouse \\
\hline
U+1F402 & 🐂 & {\textbackslash}:ox: & Ox \\
\hline
U+1F403 & 🐃 & {\textbackslash}:water\_buffalo: & Water Buffalo \\
\hline
U+1F404 & 🐄 & {\textbackslash}:cow2: & Cow \\
\hline
U+1F405 & 🐅 & {\textbackslash}:tiger2: & Tiger \\
\hline
U+1F406 & 🐆 & {\textbackslash}:leopard: & Leopard \\
\hline
U+1F407 & 🐇 & {\textbackslash}:rabbit2: & Rabbit \\
\hline
U+1F408 & 🐈 & {\textbackslash}:cat2: & Cat \\
\hline
U+1F409 & 🐉 & {\textbackslash}:dragon: & Dragon \\
\hline
U+1F40A & 🐊 & {\textbackslash}:crocodile: & Crocodile \\
\hline
U+1F40B & 🐋 & {\textbackslash}:whale2: & Whale \\
\hline
U+1F40C & 🐌 & {\textbackslash}:snail: & Snail \\
\hline
U+1F40D & 🐍 & {\textbackslash}:snake: & Snake \\
\hline
U+1F40E & 🐎 & {\textbackslash}:racehorse: & Horse \\
\hline
U+1F40F & 🐏 & {\textbackslash}:ram: & Ram \\
\hline
U+1F410 & 🐐 & {\textbackslash}:goat: & Goat \\
\hline
U+1F411 & 🐑 & {\textbackslash}:sheep: & Sheep \\
\hline
U+1F412 & 🐒 & {\textbackslash}:monkey: & Monkey \\
\hline
U+1F413 & 🐓 & {\textbackslash}:rooster: & Rooster \\
\hline
U+1F414 & 🐔 & {\textbackslash}:chicken: & Chicken \\
\hline
U+1F415 & 🐕 & {\textbackslash}:dog2: & Dog \\
\hline
U+1F416 & 🐖 & {\textbackslash}:pig2: & Pig \\
\hline
U+1F417 & 🐗 & {\textbackslash}:boar: & Boar \\
\hline
U+1F418 & 🐘 & {\textbackslash}:elephant: & Elephant \\
\hline
U+1F419 & 🐙 & {\textbackslash}:octopus: & Octopus \\
\hline
U+1F41A & 🐚 & {\textbackslash}:shell: & Spiral Shell \\
\hline
U+1F41B & 🐛 & {\textbackslash}:bug: & Bug \\
\hline
U+1F41C & 🐜 & {\textbackslash}:ant: & Ant \\
\hline
U+1F41D & 🐝 & {\textbackslash}:bee: & Honeybee \\
\hline
U+1F41E & 🐞 & {\textbackslash}:beetle: & Lady Beetle \\
\hline
U+1F41F & 🐟 & {\textbackslash}:fish: & Fish \\
\hline
U+1F420 & 🐠 & {\textbackslash}:tropical\_fish: & Tropical Fish \\
\hline
U+1F421 & 🐡 & {\textbackslash}:blowfish: & Blowfish \\
\hline
U+1F422 & 🐢 & {\textbackslash}:turtle: & Turtle \\
\hline
U+1F423 & 🐣 & {\textbackslash}:hatching\_chick: & Hatching Chick \\
\hline
U+1F424 & 🐤 & {\textbackslash}:baby\_chick: & Baby Chick \\
\hline
U+1F425 & 🐥 & {\textbackslash}:hatched\_chick: & Front-facing Baby Chick \\
\hline
U+1F426 & 🐦 & {\textbackslash}:bird: & Bird \\
\hline
U+1F427 & 🐧 & {\textbackslash}:penguin: & Penguin \\
\hline
U+1F428 & 🐨 & {\textbackslash}:koala: & Koala \\
\hline
U+1F429 & 🐩 & {\textbackslash}:poodle: & Poodle \\
\hline
U+1F42A & 🐪 & {\textbackslash}:dromedary\_camel: & Dromedary Camel \\
\hline
U+1F42B & 🐫 & {\textbackslash}:camel: & Bactrian Camel \\
\hline
U+1F42C & 🐬 & {\textbackslash}:dolphin: & Dolphin \\
\hline
U+1F42D & 🐭 & {\textbackslash}:mouse: & Mouse Face \\
\hline
U+1F42E & 🐮 & {\textbackslash}:cow: & Cow Face \\
\hline
U+1F42F & 🐯 & {\textbackslash}:tiger: & Tiger Face \\
\hline
U+1F430 & 🐰 & {\textbackslash}:rabbit: & Rabbit Face \\
\hline
U+1F431 & 🐱 & {\textbackslash}:cat: & Cat Face \\
\hline
U+1F432 & 🐲 & {\textbackslash}:dragon\_face: & Dragon Face \\
\hline
U+1F433 & 🐳 & {\textbackslash}:whale: & Spouting Whale \\
\hline
U+1F434 & 🐴 & {\textbackslash}:horse: & Horse Face \\
\hline
U+1F435 & 🐵 & {\textbackslash}:monkey\_face: & Monkey Face \\
\hline
U+1F436 & 🐶 & {\textbackslash}:dog: & Dog Face \\
\hline
U+1F437 & 🐷 & {\textbackslash}:pig: & Pig Face \\
\hline
U+1F438 & 🐸 & {\textbackslash}:frog: & Frog Face \\
\hline
U+1F439 & 🐹 & {\textbackslash}:hamster: & Hamster Face \\
\hline
U+1F43A & 🐺 & {\textbackslash}:wolf: & Wolf Face \\
\hline
U+1F43B & 🐻 & {\textbackslash}:bear: & Bear Face \\
\hline
U+1F43C & 🐼 & {\textbackslash}:panda\_face: & Panda Face \\
\hline
U+1F43D & 🐽 & {\textbackslash}:pig\_nose: & Pig Nose \\
\hline
U+1F43E & 🐾 & {\textbackslash}:feet: & Paw Prints \\
\hline
U+1F440 & 👀 & {\textbackslash}:eyes: & Eyes \\
\hline
U+1F442 & 👂 & {\textbackslash}:ear: & Ear \\
\hline
U+1F443 & 👃 & {\textbackslash}:nose: & Nose \\
\hline
U+1F444 & 👄 & {\textbackslash}:lips: & Mouth \\
\hline
U+1F445 & 👅 & {\textbackslash}:tongue: & Tongue \\
\hline
U+1F446 & 👆 & {\textbackslash}:point\_up\_2: & White Up Pointing Backhand Index \\
\hline
U+1F447 & 👇 & {\textbackslash}:point\_down: & White Down Pointing Backhand Index \\
\hline
U+1F448 & 👈 & {\textbackslash}:point\_left: & White Left Pointing Backhand Index \\
\hline
U+1F449 & 👉 & {\textbackslash}:point\_right: & White Right Pointing Backhand Index \\
\hline
U+1F44A & 👊 & {\textbackslash}:facepunch: & Fisted Hand Sign \\
\hline
U+1F44B & 👋 & {\textbackslash}:wave: & Waving Hand Sign \\
\hline
U+1F44C & 👌 & {\textbackslash}:ok\_hand: & Ok Hand Sign \\
\hline
U+1F44D & 👍 & {\textbackslash}:+1: & Thumbs Up Sign \\
\hline
U+1F44E & 👎 & {\textbackslash}:-1: & Thumbs Down Sign \\
\hline
U+1F44F & 👏 & {\textbackslash}:clap: & Clapping Hands Sign \\
\hline
U+1F450 & 👐 & {\textbackslash}:open\_hands: & Open Hands Sign \\
\hline
U+1F451 & 👑 & {\textbackslash}:crown: & Crown \\
\hline
U+1F452 & 👒 & {\textbackslash}:womans\_hat: & Womans Hat \\
\hline
U+1F453 & 👓 & {\textbackslash}:eyeglasses: & Eyeglasses \\
\hline
U+1F454 & 👔 & {\textbackslash}:necktie: & Necktie \\
\hline
U+1F455 & 👕 & {\textbackslash}:shirt: & T-shirt \\
\hline
U+1F456 & 👖 & {\textbackslash}:jeans: & Jeans \\
\hline
U+1F457 & 👗 & {\textbackslash}:dress: & Dress \\
\hline
U+1F458 & 👘 & {\textbackslash}:kimono: & Kimono \\
\hline
U+1F459 & 👙 & {\textbackslash}:bikini: & Bikini \\
\hline
U+1F45A & 👚 & {\textbackslash}:womans\_clothes: & Womans Clothes \\
\hline
U+1F45B & 👛 & {\textbackslash}:purse: & Purse \\
\hline
U+1F45C & 👜 & {\textbackslash}:handbag: & Handbag \\
\hline
U+1F45D & 👝 & {\textbackslash}:pouch: & Pouch \\
\hline
U+1F45E & 👞 & {\textbackslash}:mans\_shoe: & Mans Shoe \\
\hline
U+1F45F & 👟 & {\textbackslash}:athletic\_shoe: & Athletic Shoe \\
\hline
U+1F460 & 👠 & {\textbackslash}:high\_heel: & High-heeled Shoe \\
\hline
U+1F461 & 👡 & {\textbackslash}:sandal: & Womans Sandal \\
\hline
U+1F462 & 👢 & {\textbackslash}:boot: & Womans Boots \\
\hline
U+1F463 & 👣 & {\textbackslash}:footprints: & Footprints \\
\hline
U+1F464 & 👤 & {\textbackslash}:bust\_in\_silhouette: & Bust In Silhouette \\
\hline
U+1F465 & 👥 & {\textbackslash}:busts\_in\_silhouette: & Busts In Silhouette \\
\hline
U+1F466 & 👦 & {\textbackslash}:boy: & Boy \\
\hline
U+1F467 & 👧 & {\textbackslash}:girl: & Girl \\
\hline
U+1F468 & 👨 & {\textbackslash}:man: & Man \\
\hline
U+1F469 & 👩 & {\textbackslash}:woman: & Woman \\
\hline
U+1F46A & 👪 & {\textbackslash}:family: & Family \\
\hline
U+1F46B & 👫 & {\textbackslash}:couple: & Man And Woman Holding Hands \\
\hline
U+1F46C & 👬 & {\textbackslash}:two\_men\_holding\_hands: & Two Men Holding Hands \\
\hline
U+1F46D & 👭 & {\textbackslash}:two\_women\_holding\_hands: & Two Women Holding Hands \\
\hline
U+1F46E & 👮 & {\textbackslash}:cop: & Police Officer \\
\hline
U+1F46F & 👯 & {\textbackslash}:dancers: & Woman With Bunny Ears \\
\hline
U+1F470 & 👰 & {\textbackslash}:bride\_with\_veil: & Bride With Veil \\
\hline
U+1F471 & 👱 & {\textbackslash}:person\_with\_blond\_hair: & Person With Blond Hair \\
\hline
U+1F472 & 👲 & {\textbackslash}:man\_with\_gua\_pi\_mao: & Man With Gua Pi Mao \\
\hline
U+1F473 & 👳 & {\textbackslash}:man\_with\_turban: & Man With Turban \\
\hline
U+1F474 & 👴 & {\textbackslash}:older\_man: & Older Man \\
\hline
U+1F475 & 👵 & {\textbackslash}:older\_woman: & Older Woman \\
\hline
U+1F476 & 👶 & {\textbackslash}:baby: & Baby \\
\hline
U+1F477 & 👷 & {\textbackslash}:construction\_worker: & Construction Worker \\
\hline
U+1F478 & 👸 & {\textbackslash}:princess: & Princess \\
\hline
U+1F479 & 👹 & {\textbackslash}:japanese\_ogre: & Japanese Ogre \\
\hline
U+1F47A & 👺 & {\textbackslash}:japanese\_goblin: & Japanese Goblin \\
\hline
U+1F47B & 👻 & {\textbackslash}:ghost: & Ghost \\
\hline
U+1F47C & 👼 & {\textbackslash}:angel: & Baby Angel \\
\hline
U+1F47D & 👽 & {\textbackslash}:alien: & Extraterrestrial Alien \\
\hline
U+1F47E & 👾 & {\textbackslash}:space\_invader: & Alien Monster \\
\hline
U+1F47F & 👿 & {\textbackslash}:imp: & Imp \\
\hline
U+1F480 & 💀 & {\textbackslash}:skull: & Skull \\
\hline
U+1F481 & 💁 & {\textbackslash}:information\_desk\_person: & Information Desk Person \\
\hline
U+1F482 & 💂 & {\textbackslash}:guardsman: & Guardsman \\
\hline
U+1F483 & 💃 & {\textbackslash}:dancer: & Dancer \\
\hline
U+1F484 & 💄 & {\textbackslash}:lipstick: & Lipstick \\
\hline
U+1F485 & 💅 & {\textbackslash}:nail\_care: & Nail Polish \\
\hline
U+1F486 & 💆 & {\textbackslash}:massage: & Face Massage \\
\hline
U+1F487 & 💇 & {\textbackslash}:haircut: & Haircut \\
\hline
U+1F488 & 💈 & {\textbackslash}:barber: & Barber Pole \\
\hline
U+1F489 & 💉 & {\textbackslash}:syringe: & Syringe \\
\hline
U+1F48A & 💊 & {\textbackslash}:pill: & Pill \\
\hline
U+1F48B & 💋 & {\textbackslash}:kiss: & Kiss Mark \\
\hline
U+1F48C & 💌 & {\textbackslash}:love\_letter: & Love Letter \\
\hline
U+1F48D & 💍 & {\textbackslash}:ring: & Ring \\
\hline
U+1F48E & 💎 & {\textbackslash}:gem: & Gem Stone \\
\hline
U+1F48F & 💏 & {\textbackslash}:couplekiss: & Kiss \\
\hline
U+1F490 & 💐 & {\textbackslash}:bouquet: & Bouquet \\
\hline
U+1F491 & 💑 & {\textbackslash}:couple\_with\_heart: & Couple With Heart \\
\hline
U+1F492 & 💒 & {\textbackslash}:wedding: & Wedding \\
\hline
U+1F493 & 💓 & {\textbackslash}:heartbeat: & Beating Heart \\
\hline
U+1F494 & 💔 & {\textbackslash}:broken\_heart: & Broken Heart \\
\hline
U+1F495 & 💕 & {\textbackslash}:two\_hearts: & Two Hearts \\
\hline
U+1F496 & 💖 & {\textbackslash}:sparkling\_heart: & Sparkling Heart \\
\hline
U+1F497 & 💗 & {\textbackslash}:heartpulse: & Growing Heart \\
\hline
U+1F498 & 💘 & {\textbackslash}:cupid: & Heart With Arrow \\
\hline
U+1F499 & 💙 & {\textbackslash}:blue\_heart: & Blue Heart \\
\hline
U+1F49A & 💚 & {\textbackslash}:green\_heart: & Green Heart \\
\hline
U+1F49B & 💛 & {\textbackslash}:yellow\_heart: & Yellow Heart \\
\hline
U+1F49C & 💜 & {\textbackslash}:purple\_heart: & Purple Heart \\
\hline
U+1F49D & 💝 & {\textbackslash}:gift\_heart: & Heart With Ribbon \\
\hline
U+1F49E & 💞 & {\textbackslash}:revolving\_hearts: & Revolving Hearts \\
\hline
U+1F49F & 💟 & {\textbackslash}:heart\_decoration: & Heart Decoration \\
\hline
U+1F4A0 & 💠 & {\textbackslash}:diamond\_shape\_with\_a\_dot\_inside: & Diamond Shape With A Dot Inside \\
\hline
U+1F4A1 & 💡 & {\textbackslash}:bulb: & Electric Light Bulb \\
\hline
U+1F4A2 & 💢 & {\textbackslash}:anger: & Anger Symbol \\
\hline
U+1F4A3 & 💣 & {\textbackslash}:bomb: & Bomb \\
\hline
U+1F4A4 & 💤 & {\textbackslash}:zzz: & Sleeping Symbol \\
\hline
U+1F4A5 & 💥 & {\textbackslash}:boom: & Collision Symbol \\
\hline
U+1F4A6 & 💦 & {\textbackslash}:sweat\_drops: & Splashing Sweat Symbol \\
\hline
U+1F4A7 & 💧 & {\textbackslash}:droplet: & Droplet \\
\hline
U+1F4A8 & 💨 & {\textbackslash}:dash: & Dash Symbol \\
\hline
U+1F4A9 & 💩 & {\textbackslash}:hankey: & Pile Of Poo \\
\hline
U+1F4AA & 💪 & {\textbackslash}:muscle: & Flexed Biceps \\
\hline
U+1F4AB & 💫 & {\textbackslash}:dizzy: & Dizzy Symbol \\
\hline
U+1F4AC & 💬 & {\textbackslash}:speech\_balloon: & Speech Balloon \\
\hline
U+1F4AD & 💭 & {\textbackslash}:thought\_balloon: & Thought Balloon \\
\hline
U+1F4AE & 💮 & {\textbackslash}:white\_flower: & White Flower \\
\hline
U+1F4AF & 💯 & {\textbackslash}:100: & Hundred Points Symbol \\
\hline
U+1F4B0 & 💰 & {\textbackslash}:moneybag: & Money Bag \\
\hline
U+1F4B1 & 💱 & {\textbackslash}:currency\_exchange: & Currency Exchange \\
\hline
U+1F4B2 & 💲 & {\textbackslash}:heavy\_dollar\_sign: & Heavy Dollar Sign \\
\hline
U+1F4B3 & 💳 & {\textbackslash}:credit\_card: & Credit Card \\
\hline
U+1F4B4 & 💴 & {\textbackslash}:yen: & Banknote With Yen Sign \\
\hline
U+1F4B5 & 💵 & {\textbackslash}:dollar: & Banknote With Dollar Sign \\
\hline
U+1F4B6 & 💶 & {\textbackslash}:euro: & Banknote With Euro Sign \\
\hline
U+1F4B7 & 💷 & {\textbackslash}:pound: & Banknote With Pound Sign \\
\hline
U+1F4B8 & 💸 & {\textbackslash}:money\_with\_wings: & Money With Wings \\
\hline
U+1F4B9 & 💹 & {\textbackslash}:chart: & Chart With Upwards Trend And Yen Sign \\
\hline
U+1F4BA & 💺 & {\textbackslash}:seat: & Seat \\
\hline
U+1F4BB & 💻 & {\textbackslash}:computer: & Personal Computer \\
\hline
U+1F4BC & 💼 & {\textbackslash}:briefcase: & Briefcase \\
\hline
U+1F4BD & 💽 & {\textbackslash}:minidisc: & Minidisc \\
\hline
U+1F4BE & 💾 & {\textbackslash}:floppy\_disk: & Floppy Disk \\
\hline
U+1F4BF & 💿 & {\textbackslash}:cd: & Optical Disc \\
\hline
U+1F4C0 & 📀 & {\textbackslash}:dvd: & Dvd \\
\hline
U+1F4C1 & 📁 & {\textbackslash}:file\_folder: & File Folder \\
\hline
U+1F4C2 & 📂 & {\textbackslash}:open\_file\_folder: & Open File Folder \\
\hline
U+1F4C3 & 📃 & {\textbackslash}:page\_with\_curl: & Page With Curl \\
\hline
U+1F4C4 & 📄 & {\textbackslash}:page\_facing\_up: & Page Facing Up \\
\hline
U+1F4C5 & 📅 & {\textbackslash}:date: & Calendar \\
\hline
U+1F4C6 & 📆 & {\textbackslash}:calendar: & Tear-off Calendar \\
\hline
U+1F4C7 & 📇 & {\textbackslash}:card\_index: & Card Index \\
\hline
U+1F4C8 & 📈 & {\textbackslash}:chart\_with\_upwards\_trend: & Chart With Upwards Trend \\
\hline
U+1F4C9 & 📉 & {\textbackslash}:chart\_with\_downwards\_trend: & Chart With Downwards Trend \\
\hline
U+1F4CA & 📊 & {\textbackslash}:bar\_chart: & Bar Chart \\
\hline
U+1F4CB & 📋 & {\textbackslash}:clipboard: & Clipboard \\
\hline
U+1F4CC & 📌 & {\textbackslash}:pushpin: & Pushpin \\
\hline
U+1F4CD & 📍 & {\textbackslash}:round\_pushpin: & Round Pushpin \\
\hline
U+1F4CE & 📎 & {\textbackslash}:paperclip: & Paperclip \\
\hline
U+1F4CF & 📏 & {\textbackslash}:straight\_ruler: & Straight Ruler \\
\hline
U+1F4D0 & 📐 & {\textbackslash}:triangular\_ruler: & Triangular Ruler \\
\hline
U+1F4D1 & 📑 & {\textbackslash}:bookmark\_tabs: & Bookmark Tabs \\
\hline
U+1F4D2 & 📒 & {\textbackslash}:ledger: & Ledger \\
\hline
U+1F4D3 & 📓 & {\textbackslash}:notebook: & Notebook \\
\hline
U+1F4D4 & 📔 & {\textbackslash}:notebook\_with\_decorative\_cover: & Notebook With Decorative Cover \\
\hline
U+1F4D5 & 📕 & {\textbackslash}:closed\_book: & Closed Book \\
\hline
U+1F4D6 & 📖 & {\textbackslash}:book: & Open Book \\
\hline
U+1F4D7 & 📗 & {\textbackslash}:green\_book: & Green Book \\
\hline
U+1F4D8 & 📘 & {\textbackslash}:blue\_book: & Blue Book \\
\hline
U+1F4D9 & 📙 & {\textbackslash}:orange\_book: & Orange Book \\
\hline
U+1F4DA & 📚 & {\textbackslash}:books: & Books \\
\hline
U+1F4DB & 📛 & {\textbackslash}:name\_badge: & Name Badge \\
\hline
U+1F4DC & 📜 & {\textbackslash}:scroll: & Scroll \\
\hline
U+1F4DD & 📝 & {\textbackslash}:memo: & Memo \\
\hline
U+1F4DE & 📞 & {\textbackslash}:telephone\_receiver: & Telephone Receiver \\
\hline
U+1F4DF & 📟 & {\textbackslash}:pager: & Pager \\
\hline
U+1F4E0 & 📠 & {\textbackslash}:fax: & Fax Machine \\
\hline
U+1F4E1 & 📡 & {\textbackslash}:satellite: & Satellite Antenna \\
\hline
U+1F4E2 & 📢 & {\textbackslash}:loudspeaker: & Public Address Loudspeaker \\
\hline
U+1F4E3 & 📣 & {\textbackslash}:mega: & Cheering Megaphone \\
\hline
U+1F4E4 & 📤 & {\textbackslash}:outbox\_tray: & Outbox Tray \\
\hline
U+1F4E5 & 📥 & {\textbackslash}:inbox\_tray: & Inbox Tray \\
\hline
U+1F4E6 & 📦 & {\textbackslash}:package: & Package \\
\hline
U+1F4E7 & 📧 & {\textbackslash}:e-mail: & E-mail Symbol \\
\hline
U+1F4E8 & 📨 & {\textbackslash}:incoming\_envelope: & Incoming Envelope \\
\hline
U+1F4E9 & 📩 & {\textbackslash}:envelope\_with\_arrow: & Envelope With Downwards Arrow Above \\
\hline
U+1F4EA & 📪 & {\textbackslash}:mailbox\_closed: & Closed Mailbox With Lowered Flag \\
\hline
U+1F4EB & 📫 & {\textbackslash}:mailbox: & Closed Mailbox With Raised Flag \\
\hline
U+1F4EC & 📬 & {\textbackslash}:mailbox\_with\_mail: & Open Mailbox With Raised Flag \\
\hline
U+1F4ED & 📭 & {\textbackslash}:mailbox\_with\_no\_mail: & Open Mailbox With Lowered Flag \\
\hline
U+1F4EE & 📮 & {\textbackslash}:postbox: & Postbox \\
\hline
U+1F4EF & 📯 & {\textbackslash}:postal\_horn: & Postal Horn \\
\hline
U+1F4F0 & 📰 & {\textbackslash}:newspaper: & Newspaper \\
\hline
U+1F4F1 & 📱 & {\textbackslash}:iphone: & Mobile Phone \\
\hline
U+1F4F2 & 📲 & {\textbackslash}:calling: & Mobile Phone With Rightwards Arrow At Left \\
\hline
U+1F4F3 & 📳 & {\textbackslash}:vibration\_mode: & Vibration Mode \\
\hline
U+1F4F4 & 📴 & {\textbackslash}:mobile\_phone\_off: & Mobile Phone Off \\
\hline
U+1F4F5 & 📵 & {\textbackslash}:no\_mobile\_phones: & No Mobile Phones \\
\hline
U+1F4F6 & 📶 & {\textbackslash}:signal\_strength: & Antenna With Bars \\
\hline
U+1F4F7 & 📷 & {\textbackslash}:camera: & Camera \\
\hline
U+1F4F9 & 📹 & {\textbackslash}:video\_camera: & Video Camera \\
\hline
U+1F4FA & 📺 & {\textbackslash}:tv: & Television \\
\hline
U+1F4FB & 📻 & {\textbackslash}:radio: & Radio \\
\hline
U+1F4FC & 📼 & {\textbackslash}:vhs: & Videocassette \\
\hline
U+1F500 & 🔀 & {\textbackslash}:twisted\_rightwards\_arrows: & Twisted Rightwards Arrows \\
\hline
U+1F501 & 🔁 & {\textbackslash}:repeat: & Clockwise Rightwards And Leftwards Open Circle Arrows \\
\hline
U+1F502 & 🔂 & {\textbackslash}:repeat\_one: & Clockwise Rightwards And Leftwards Open Circle Arrows With Circled One Overlay \\
\hline
U+1F503 & 🔃 & {\textbackslash}:arrows\_clockwise: & Clockwise Downwards And Upwards Open Circle Arrows \\
\hline
U+1F504 & 🔄 & {\textbackslash}:arrows\_counterclockwise: & Anticlockwise Downwards And Upwards Open Circle Arrows \\
\hline
U+1F505 & 🔅 & {\textbackslash}:low\_brightness: & Low Brightness Symbol \\
\hline
U+1F506 & 🔆 & {\textbackslash}:high\_brightness: & High Brightness Symbol \\
\hline
U+1F507 & 🔇 & {\textbackslash}:mute: & Speaker With Cancellation Stroke \\
\hline
U+1F508 & 🔈 & {\textbackslash}:speaker: & Speaker \\
\hline
U+1F509 & 🔉 & {\textbackslash}:sound: & Speaker With One Sound Wave \\
\hline
U+1F50A & 🔊 & {\textbackslash}:loud\_sound: & Speaker With Three Sound Waves \\
\hline
U+1F50B & 🔋 & {\textbackslash}:battery: & Battery \\
\hline
U+1F50C & 🔌 & {\textbackslash}:electric\_plug: & Electric Plug \\
\hline
U+1F50D & 🔍 & {\textbackslash}:mag: & Left-pointing Magnifying Glass \\
\hline
U+1F50E & 🔎 & {\textbackslash}:mag\_right: & Right-pointing Magnifying Glass \\
\hline
U+1F50F & 🔏 & {\textbackslash}:lock\_with\_ink\_pen: & Lock With Ink Pen \\
\hline
U+1F510 & 🔐 & {\textbackslash}:closed\_lock\_with\_key: & Closed Lock With Key \\
\hline
U+1F511 & 🔑 & {\textbackslash}:key: & Key \\
\hline
U+1F512 & 🔒 & {\textbackslash}:lock: & Lock \\
\hline
U+1F513 & 🔓 & {\textbackslash}:unlock: & Open Lock \\
\hline
U+1F514 & 🔔 & {\textbackslash}:bell: & Bell \\
\hline
U+1F515 & 🔕 & {\textbackslash}:no\_bell: & Bell With Cancellation Stroke \\
\hline
U+1F516 & 🔖 & {\textbackslash}:bookmark: & Bookmark \\
\hline
U+1F517 & 🔗 & {\textbackslash}:link: & Link Symbol \\
\hline
U+1F518 & 🔘 & {\textbackslash}:radio\_button: & Radio Button \\
\hline
U+1F519 & 🔙 & {\textbackslash}:back: & Back With Leftwards Arrow Above \\
\hline
U+1F51A & 🔚 & {\textbackslash}:end: & End With Leftwards Arrow Above \\
\hline
U+1F51B & 🔛 & {\textbackslash}:on: & On With Exclamation Mark With Left Right Arrow Above \\
\hline
U+1F51C & 🔜 & {\textbackslash}:soon: & Soon With Rightwards Arrow Above \\
\hline
U+1F51D & 🔝 & {\textbackslash}:top: & Top With Upwards Arrow Above \\
\hline
U+1F51E & 🔞 & {\textbackslash}:underage: & No One Under Eighteen Symbol \\
\hline
U+1F51F & 🔟 & {\textbackslash}:keycap\_ten: & Keycap Ten \\
\hline
U+1F520 & 🔠 & {\textbackslash}:capital\_abcd: & Input Symbol For Latin Capital Letters \\
\hline
U+1F521 & 🔡 & {\textbackslash}:abcd: & Input Symbol For Latin Small Letters \\
\hline
U+1F522 & 🔢 & {\textbackslash}:1234: & Input Symbol For Numbers \\
\hline
U+1F523 & 🔣 & {\textbackslash}:symbols: & Input Symbol For Symbols \\
\hline
U+1F524 & 🔤 & {\textbackslash}:abc: & Input Symbol For Latin Letters \\
\hline
U+1F525 & 🔥 & {\textbackslash}:fire: & Fire \\
\hline
U+1F526 & 🔦 & {\textbackslash}:flashlight: & Electric Torch \\
\hline
U+1F527 & 🔧 & {\textbackslash}:wrench: & Wrench \\
\hline
U+1F528 & 🔨 & {\textbackslash}:hammer: & Hammer \\
\hline
U+1F529 & 🔩 & {\textbackslash}:nut\_and\_bolt: & Nut And Bolt \\
\hline
U+1F52A & 🔪 & {\textbackslash}:hocho: & Hocho \\
\hline
U+1F52B & 🔫 & {\textbackslash}:gun: & Pistol \\
\hline
U+1F52C & 🔬 & {\textbackslash}:microscope: & Microscope \\
\hline
U+1F52D & 🔭 & {\textbackslash}:telescope: & Telescope \\
\hline
U+1F52E & 🔮 & {\textbackslash}:crystal\_ball: & Crystal Ball \\
\hline
U+1F52F & 🔯 & {\textbackslash}:six\_pointed\_star: & Six Pointed Star With Middle Dot \\
\hline
U+1F530 & 🔰 & {\textbackslash}:beginner: & Japanese Symbol For Beginner \\
\hline
U+1F531 & 🔱 & {\textbackslash}:trident: & Trident Emblem \\
\hline
U+1F532 & 🔲 & {\textbackslash}:black\_square\_button: & Black Square Button \\
\hline
U+1F533 & 🔳 & {\textbackslash}:white\_square\_button: & White Square Button \\
\hline
U+1F534 & 🔴 & {\textbackslash}:red\_circle: & Large Red Circle \\
\hline
U+1F535 & 🔵 & {\textbackslash}:large\_blue\_circle: & Large Blue Circle \\
\hline
U+1F536 & 🔶 & {\textbackslash}:large\_orange\_diamond: & Large Orange Diamond \\
\hline
U+1F537 & 🔷 & {\textbackslash}:large\_blue\_diamond: & Large Blue Diamond \\
\hline
U+1F538 & 🔸 & {\textbackslash}:small\_orange\_diamond: & Small Orange Diamond \\
\hline
U+1F539 & 🔹 & {\textbackslash}:small\_blue\_diamond: & Small Blue Diamond \\
\hline
U+1F53A & 🔺 & {\textbackslash}:small\_red\_triangle: & Up-pointing Red Triangle \\
\hline
U+1F53B & 🔻 & {\textbackslash}:small\_red\_triangle\_down: & Down-pointing Red Triangle \\
\hline
U+1F53C & 🔼 & {\textbackslash}:arrow\_up\_small: & Up-pointing Small Red Triangle \\
\hline
U+1F53D & 🔽 & {\textbackslash}:arrow\_down\_small: & Down-pointing Small Red Triangle \\
\hline
U+1F550 & 🕐 & {\textbackslash}:clock1: & Clock Face One Oclock \\
\hline
U+1F551 & 🕑 & {\textbackslash}:clock2: & Clock Face Two Oclock \\
\hline
U+1F552 & 🕒 & {\textbackslash}:clock3: & Clock Face Three Oclock \\
\hline
U+1F553 & 🕓 & {\textbackslash}:clock4: & Clock Face Four Oclock \\
\hline
U+1F554 & 🕔 & {\textbackslash}:clock5: & Clock Face Five Oclock \\
\hline
U+1F555 & 🕕 & {\textbackslash}:clock6: & Clock Face Six Oclock \\
\hline
U+1F556 & 🕖 & {\textbackslash}:clock7: & Clock Face Seven Oclock \\
\hline
U+1F557 & 🕗 & {\textbackslash}:clock8: & Clock Face Eight Oclock \\
\hline
U+1F558 & 🕘 & {\textbackslash}:clock9: & Clock Face Nine Oclock \\
\hline
U+1F559 & 🕙 & {\textbackslash}:clock10: & Clock Face Ten Oclock \\
\hline
U+1F55A & 🕚 & {\textbackslash}:clock11: & Clock Face Eleven Oclock \\
\hline
U+1F55B & 🕛 & {\textbackslash}:clock12: & Clock Face Twelve Oclock \\
\hline
U+1F55C & 🕜 & {\textbackslash}:clock130: & Clock Face One-thirty \\
\hline
U+1F55D & 🕝 & {\textbackslash}:clock230: & Clock Face Two-thirty \\
\hline
U+1F55E & 🕞 & {\textbackslash}:clock330: & Clock Face Three-thirty \\
\hline
U+1F55F & 🕟 & {\textbackslash}:clock430: & Clock Face Four-thirty \\
\hline
U+1F560 & 🕠 & {\textbackslash}:clock530: & Clock Face Five-thirty \\
\hline
U+1F561 & 🕡 & {\textbackslash}:clock630: & Clock Face Six-thirty \\
\hline
U+1F562 & 🕢 & {\textbackslash}:clock730: & Clock Face Seven-thirty \\
\hline
U+1F563 & 🕣 & {\textbackslash}:clock830: & Clock Face Eight-thirty \\
\hline
U+1F564 & 🕤 & {\textbackslash}:clock930: & Clock Face Nine-thirty \\
\hline
U+1F565 & 🕥 & {\textbackslash}:clock1030: & Clock Face Ten-thirty \\
\hline
U+1F566 & 🕦 & {\textbackslash}:clock1130: & Clock Face Eleven-thirty \\
\hline
U+1F567 & 🕧 & {\textbackslash}:clock1230: & Clock Face Twelve-thirty \\
\hline
U+1F5FB & 🗻 & {\textbackslash}:mount\_fuji: & Mount Fuji \\
\hline
U+1F5FC & 🗼 & {\textbackslash}:tokyo\_tower: & Tokyo Tower \\
\hline
U+1F5FD & 🗽 & {\textbackslash}:statue\_of\_liberty: & Statue Of Liberty \\
\hline
U+1F5FE & 🗾 & {\textbackslash}:japan: & Silhouette Of Japan \\
\hline
U+1F5FF & 🗿 & {\textbackslash}:moyai: & Moyai \\
\hline
U+1F600 & 😀 & {\textbackslash}:grinning: & Grinning Face \\
\hline
U+1F601 & 😁 & {\textbackslash}:grin: & Grinning Face With Smiling Eyes \\
\hline
U+1F602 & 😂 & {\textbackslash}:joy: & Face With Tears Of Joy \\
\hline
U+1F603 & 😃 & {\textbackslash}:smiley: & Smiling Face With Open Mouth \\
\hline
U+1F604 & 😄 & {\textbackslash}:smile: & Smiling Face With Open Mouth And Smiling Eyes \\
\hline
U+1F605 & 😅 & {\textbackslash}:sweat\_smile: & Smiling Face With Open Mouth And Cold Sweat \\
\hline
U+1F606 & 😆 & {\textbackslash}:laughing: & Smiling Face With Open Mouth And Tightly-closed Eyes \\
\hline
U+1F607 & 😇 & {\textbackslash}:innocent: & Smiling Face With Halo \\
\hline
U+1F608 & 😈 & {\textbackslash}:smiling\_imp: & Smiling Face With Horns \\
\hline
U+1F609 & 😉 & {\textbackslash}:wink: & Winking Face \\
\hline
U+1F60A & 😊 & {\textbackslash}:blush: & Smiling Face With Smiling Eyes \\
\hline
U+1F60B & 😋 & {\textbackslash}:yum: & Face Savouring Delicious Food \\
\hline
U+1F60C & 😌 & {\textbackslash}:relieved: & Relieved Face \\
\hline
U+1F60D & 😍 & {\textbackslash}:heart\_eyes: & Smiling Face With Heart-shaped Eyes \\
\hline
U+1F60E & 😎 & {\textbackslash}:sunglasses: & Smiling Face With Sunglasses \\
\hline
U+1F60F & 😏 & {\textbackslash}:smirk: & Smirking Face \\
\hline
U+1F610 & 😐 & {\textbackslash}:neutral\_face: & Neutral Face \\
\hline
U+1F611 & 😑 & {\textbackslash}:expressionless: & Expressionless Face \\
\hline
U+1F612 & 😒 & {\textbackslash}:unamused: & Unamused Face \\
\hline
U+1F613 & 😓 & {\textbackslash}:sweat: & Face With Cold Sweat \\
\hline
U+1F614 & 😔 & {\textbackslash}:pensive: & Pensive Face \\
\hline
U+1F615 & 😕 & {\textbackslash}:confused: & Confused Face \\
\hline
U+1F616 & 😖 & {\textbackslash}:confounded: & Confounded Face \\
\hline
U+1F617 & 😗 & {\textbackslash}:kissing: & Kissing Face \\
\hline
U+1F618 & 😘 & {\textbackslash}:kissing\_heart: & Face Throwing A Kiss \\
\hline
U+1F619 & 😙 & {\textbackslash}:kissing\_smiling\_eyes: & Kissing Face With Smiling Eyes \\
\hline
U+1F61A & 😚 & {\textbackslash}:kissing\_closed\_eyes: & Kissing Face With Closed Eyes \\
\hline
U+1F61B & 😛 & {\textbackslash}:stuck\_out\_tongue: & Face With Stuck-out Tongue \\
\hline
U+1F61C & 😜 & {\textbackslash}:stuck\_out\_tongue\_winking\_eye: & Face With Stuck-out Tongue And Winking Eye \\
\hline
U+1F61D & 😝 & {\textbackslash}:stuck\_out\_tongue\_closed\_eyes: & Face With Stuck-out Tongue And Tightly-closed Eyes \\
\hline
U+1F61E & 😞 & {\textbackslash}:disappointed: & Disappointed Face \\
\hline
U+1F61F & 😟 & {\textbackslash}:worried: & Worried Face \\
\hline
U+1F620 & 😠 & {\textbackslash}:angry: & Angry Face \\
\hline
U+1F621 & 😡 & {\textbackslash}:rage: & Pouting Face \\
\hline
U+1F622 & 😢 & {\textbackslash}:cry: & Crying Face \\
\hline
U+1F623 & 😣 & {\textbackslash}:persevere: & Persevering Face \\
\hline
U+1F624 & 😤 & {\textbackslash}:triumph: & Face With Look Of Triumph \\
\hline
U+1F625 & 😥 & {\textbackslash}:disappointed\_relieved: & Disappointed But Relieved Face \\
\hline
U+1F626 & 😦 & {\textbackslash}:frowning: & Frowning Face With Open Mouth \\
\hline
U+1F627 & 😧 & {\textbackslash}:anguished: & Anguished Face \\
\hline
U+1F628 & 😨 & {\textbackslash}:fearful: & Fearful Face \\
\hline
U+1F629 & 😩 & {\textbackslash}:weary: & Weary Face \\
\hline
U+1F62A & 😪 & {\textbackslash}:sleepy: & Sleepy Face \\
\hline
U+1F62B & 😫 & {\textbackslash}:tired\_face: & Tired Face \\
\hline
U+1F62C & 😬 & {\textbackslash}:grimacing: & Grimacing Face \\
\hline
U+1F62D & 😭 & {\textbackslash}:sob: & Loudly Crying Face \\
\hline
U+1F62E & 😮 & {\textbackslash}:open\_mouth: & Face With Open Mouth \\
\hline
U+1F62F & 😯 & {\textbackslash}:hushed: & Hushed Face \\
\hline
U+1F630 & 😰 & {\textbackslash}:cold\_sweat: & Face With Open Mouth And Cold Sweat \\
\hline
U+1F631 & 😱 & {\textbackslash}:scream: & Face Screaming In Fear \\
\hline
U+1F632 & 😲 & {\textbackslash}:astonished: & Astonished Face \\
\hline
U+1F633 & 😳 & {\textbackslash}:flushed: & Flushed Face \\
\hline
U+1F634 & 😴 & {\textbackslash}:sleeping: & Sleeping Face \\
\hline
U+1F635 & 😵 & {\textbackslash}:dizzy\_face: & Dizzy Face \\
\hline
U+1F636 & 😶 & {\textbackslash}:no\_mouth: & Face Without Mouth \\
\hline
U+1F637 & 😷 & {\textbackslash}:mask: & Face With Medical Mask \\
\hline
U+1F638 & 😸 & {\textbackslash}:smile\_cat: & Grinning Cat Face With Smiling Eyes \\
\hline
U+1F639 & 😹 & {\textbackslash}:joy\_cat: & Cat Face With Tears Of Joy \\
\hline
U+1F63A & 😺 & {\textbackslash}:smiley\_cat: & Smiling Cat Face With Open Mouth \\
\hline
U+1F63B & 😻 & {\textbackslash}:heart\_eyes\_cat: & Smiling Cat Face With Heart-shaped Eyes \\
\hline
U+1F63C & 😼 & {\textbackslash}:smirk\_cat: & Cat Face With Wry Smile \\
\hline
U+1F63D & 😽 & {\textbackslash}:kissing\_cat: & Kissing Cat Face With Closed Eyes \\
\hline
U+1F63E & 😾 & {\textbackslash}:pouting\_cat: & Pouting Cat Face \\
\hline
U+1F63F & 😿 & {\textbackslash}:crying\_cat\_face: & Crying Cat Face \\
\hline
U+1F640 & 🙀 & {\textbackslash}:scream\_cat: & Weary Cat Face \\
\hline
U+1F645 & 🙅 & {\textbackslash}:no\_good: & Face With No Good Gesture \\
\hline
U+1F646 & 🙆 & {\textbackslash}:ok\_woman: & Face With Ok Gesture \\
\hline
U+1F647 & 🙇 & {\textbackslash}:bow: & Person Bowing Deeply \\
\hline
U+1F648 & 🙈 & {\textbackslash}:see\_no\_evil: & See-no-evil Monkey \\
\hline
U+1F649 & 🙉 & {\textbackslash}:hear\_no\_evil: & Hear-no-evil Monkey \\
\hline
U+1F64A & 🙊 & {\textbackslash}:speak\_no\_evil: & Speak-no-evil Monkey \\
\hline
U+1F64B & 🙋 & {\textbackslash}:raising\_hand: & Happy Person Raising One Hand \\
\hline
U+1F64C & 🙌 & {\textbackslash}:raised\_hands: & Person Raising Both Hands In Celebration \\
\hline
U+1F64D & 🙍 & {\textbackslash}:person\_frowning: & Person Frowning \\
\hline
U+1F64E & 🙎 & {\textbackslash}:person\_with\_pouting\_face: & Person With Pouting Face \\
\hline
U+1F64F & 🙏 & {\textbackslash}:pray: & Person With Folded Hands \\
\hline
U+1F680 & 🚀 & {\textbackslash}:rocket: & Rocket \\
\hline
U+1F681 & 🚁 & {\textbackslash}:helicopter: & Helicopter \\
\hline
U+1F682 & 🚂 & {\textbackslash}:steam\_locomotive: & Steam Locomotive \\
\hline
U+1F683 & 🚃 & {\textbackslash}:railway\_car: & Railway Car \\
\hline
U+1F684 & 🚄 & {\textbackslash}:bullettrain\_side: & High-speed Train \\
\hline
U+1F685 & 🚅 & {\textbackslash}:bullettrain\_front: & High-speed Train With Bullet Nose \\
\hline
U+1F686 & 🚆 & {\textbackslash}:train2: & Train \\
\hline
U+1F687 & 🚇 & {\textbackslash}:metro: & Metro \\
\hline
U+1F688 & 🚈 & {\textbackslash}:light\_rail: & Light Rail \\
\hline
U+1F689 & 🚉 & {\textbackslash}:station: & Station \\
\hline
U+1F68A & 🚊 & {\textbackslash}:tram: & Tram \\
\hline
U+1F68B & 🚋 & {\textbackslash}:train: & Tram Car \\
\hline
U+1F68C & 🚌 & {\textbackslash}:bus: & Bus \\
\hline
U+1F68D & 🚍 & {\textbackslash}:oncoming\_bus: & Oncoming Bus \\
\hline
U+1F68E & 🚎 & {\textbackslash}:trolleybus: & Trolleybus \\
\hline
U+1F68F & 🚏 & {\textbackslash}:busstop: & Bus Stop \\
\hline
U+1F690 & 🚐 & {\textbackslash}:minibus: & Minibus \\
\hline
U+1F691 & 🚑 & {\textbackslash}:ambulance: & Ambulance \\
\hline
U+1F692 & 🚒 & {\textbackslash}:fire\_engine: & Fire Engine \\
\hline
U+1F693 & 🚓 & {\textbackslash}:police\_car: & Police Car \\
\hline
U+1F694 & 🚔 & {\textbackslash}:oncoming\_police\_car: & Oncoming Police Car \\
\hline
U+1F695 & 🚕 & {\textbackslash}:taxi: & Taxi \\
\hline
U+1F696 & 🚖 & {\textbackslash}:oncoming\_taxi: & Oncoming Taxi \\
\hline
U+1F697 & 🚗 & {\textbackslash}:car: & Automobile \\
\hline
U+1F698 & 🚘 & {\textbackslash}:oncoming\_automobile: & Oncoming Automobile \\
\hline
U+1F699 & 🚙 & {\textbackslash}:blue\_car: & Recreational Vehicle \\
\hline
U+1F69A & 🚚 & {\textbackslash}:truck: & Delivery Truck \\
\hline
U+1F69B & 🚛 & {\textbackslash}:articulated\_lorry: & Articulated Lorry \\
\hline
U+1F69C & 🚜 & {\textbackslash}:tractor: & Tractor \\
\hline
U+1F69D & 🚝 & {\textbackslash}:monorail: & Monorail \\
\hline
U+1F69E & 🚞 & {\textbackslash}:mountain\_railway: & Mountain Railway \\
\hline
U+1F69F & 🚟 & {\textbackslash}:suspension\_railway: & Suspension Railway \\
\hline
U+1F6A0 & 🚠 & {\textbackslash}:mountain\_cableway: & Mountain Cableway \\
\hline
U+1F6A1 & 🚡 & {\textbackslash}:aerial\_tramway: & Aerial Tramway \\
\hline
U+1F6A2 & 🚢 & {\textbackslash}:ship: & Ship \\
\hline
U+1F6A3 & 🚣 & {\textbackslash}:rowboat: & Rowboat \\
\hline
U+1F6A4 & 🚤 & {\textbackslash}:speedboat: & Speedboat \\
\hline
U+1F6A5 & 🚥 & {\textbackslash}:traffic\_light: & Horizontal Traffic Light \\
\hline
U+1F6A6 & 🚦 & {\textbackslash}:vertical\_traffic\_light: & Vertical Traffic Light \\
\hline
U+1F6A7 & 🚧 & {\textbackslash}:construction: & Construction Sign \\
\hline
U+1F6A8 & 🚨 & {\textbackslash}:rotating\_light: & Police Cars Revolving Light \\
\hline
U+1F6A9 & 🚩 & {\textbackslash}:triangular\_flag\_on\_post: & Triangular Flag On Post \\
\hline
U+1F6AA & 🚪 & {\textbackslash}:door: & Door \\
\hline
U+1F6AB & 🚫 & {\textbackslash}:no\_entry\_sign: & No Entry Sign \\
\hline
U+1F6AC & 🚬 & {\textbackslash}:smoking: & Smoking Symbol \\
\hline
U+1F6AD & 🚭 & {\textbackslash}:no\_smoking: & No Smoking Symbol \\
\hline
U+1F6AE & 🚮 & {\textbackslash}:put\_litter\_in\_its\_place: & Put Litter In Its Place Symbol \\
\hline
U+1F6AF & 🚯 & {\textbackslash}:do\_not\_litter: & Do Not Litter Symbol \\
\hline
U+1F6B0 & 🚰 & {\textbackslash}:potable\_water: & Potable Water Symbol \\
\hline
U+1F6B1 & 🚱 & {\textbackslash}:non-potable\_water: & Non-potable Water Symbol \\
\hline
U+1F6B2 & 🚲 & {\textbackslash}:bike: & Bicycle \\
\hline
U+1F6B3 & 🚳 & {\textbackslash}:no\_bicycles: & No Bicycles \\
\hline
U+1F6B4 & 🚴 & {\textbackslash}:bicyclist: & Bicyclist \\
\hline
U+1F6B5 & 🚵 & {\textbackslash}:mountain\_bicyclist: & Mountain Bicyclist \\
\hline
U+1F6B6 & 🚶 & {\textbackslash}:walking: & Pedestrian \\
\hline
U+1F6B7 & 🚷 & {\textbackslash}:no\_pedestrians: & No Pedestrians \\
\hline
U+1F6B8 & 🚸 & {\textbackslash}:children\_crossing: & Children Crossing \\
\hline
U+1F6B9 & 🚹 & {\textbackslash}:mens: & Mens Symbol \\
\hline
U+1F6BA & 🚺 & {\textbackslash}:womens: & Womens Symbol \\
\hline
U+1F6BB & 🚻 & {\textbackslash}:restroom: & Restroom \\
\hline
U+1F6BC & 🚼 & {\textbackslash}:baby\_symbol: & Baby Symbol \\
\hline
U+1F6BD & 🚽 & {\textbackslash}:toilet: & Toilet \\
\hline
U+1F6BE & 🚾 & {\textbackslash}:wc: & Water Closet \\
\hline
U+1F6BF & 🚿 & {\textbackslash}:shower: & Shower \\
\hline
U+1F6C0 & 🛀 & {\textbackslash}:bath: & Bath \\
\hline
U+1F6C1 & 🛁 & {\textbackslash}:bathtub: & Bathtub \\
\hline
U+1F6C2 & 🛂 & {\textbackslash}:passport\_control: & Passport Control \\
\hline
U+1F6C3 & 🛃 & {\textbackslash}:customs: & Customs \\
\hline
U+1F6C4 & 🛄 & {\textbackslash}:baggage\_claim: & Baggage Claim \\
\hline
U+1F6C5 & 🛅 & {\textbackslash}:left\_luggage: & Left Luggage \\
\hline
\end{tabulary}

\end{table}



\part{Standard Library}


\hypertarget{4709349624826687157}{}


\chapter{Essentials}



\hypertarget{13021703007540981984}{}


\section{Introducción}



La librería estándar de Julia contiene un rango de funciones y marcos apropiados para realizar  computación científica y numérica, pero es también tan amplia como la de muchos lenguajes de  programación de propósito general. También hay funcionalidad adicional disponible en una  creciente colección de paquetes disponibles. Las funciones están agrupadas abajo por temas.



Algunas notas generales:



\begin{itemize}
\item Excepto para las funciones en los módulos predefinidos (\texttt{Pkg}, \texttt{Collections}, \texttt{Test} 

\end{itemize}


y \texttt{Profile}), todas las funciones documentadas aquí están disponibles  para ser usadas en programas directamente.



\begin{itemize}
\item Para usar funciones de módulos, usar \texttt{import Module} para importar el módulo, y \texttt{Module.fn(x)} 

\end{itemize}


para usar las funciones.



\begin{itemize}
\item Alternativamente \texttt{using Module} importará todas las funciones exportadas por el módulo en 

\end{itemize}


el espacio de nombres actual.



\begin{itemize}
\item Por convenio, los nombres de funciones que acaban con un signo de admiración (\texttt{!}) 

\end{itemize}


modifican sus argumentos. Algunas funciones tienen las dos versiones (con y sin modificación  de los argumentos).



\hypertarget{17258528125521332489}{}


\section{Moviéndose}


\hypertarget{14846984688570889934}{} 
\hyperlink{14846984688570889934}{\texttt{Base.exit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exit([code])
\end{lstlisting}

Quit (or control-D at the prompt). The default exit code is zero, indicating that the processes completed successfully.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2486-L2491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14713431028777529629}{} 
\hyperlink{14713431028777529629}{\texttt{Base.quit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
quit()
\end{lstlisting}

Quit the program indicating that the processes completed successfully. This function calls \texttt{exit(0)} (see \hyperlink{14846984688570889934}{\texttt{exit}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1381-L1386}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17479944696971324992}{} 
\hyperlink{17479944696971324992}{\texttt{Base.atexit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atexit(f)
\end{lstlisting}

Register a zero-argument function \texttt{f()} to be called at process exit. \texttt{atexit()} hooks are called in last in first out (LIFO) order and run before object finalizers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1569-L1574}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1741947168860119796}{} 
\hyperlink{1741947168860119796}{\texttt{Base.atreplinit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atreplinit(f)
\end{lstlisting}

Register a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of \texttt{f} is the REPL object. This function should be called from within the \texttt{.juliarc.jl} initialization file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/client.jl#L344-L351}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10304111149900708910}{} 
\hyperlink{10304111149900708910}{\texttt{Base.isinteractive}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isinteractive() -> Bool
\end{lstlisting}

Determine whether Julia is running an interactive session.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L537-L541}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6120892747206868704}{} 
\hyperlink{6120892747206868704}{\texttt{Base.whos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
whos(io::IO=STDOUT, m::Module=current_module(), pattern::Regex=r"")
\end{lstlisting}

Print information about exported global variables in a module, optionally restricted to those matching \texttt{pattern}.

The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L699-L705}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959611366931029689}{} 
\hyperlink{16959611366931029689}{\texttt{Base.summarysize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -> Int
\end{lstlisting}

Compute the amount of memory used by all unique objects reachable from the argument.

\textbf{Keyword Arguments}

\begin{itemize}
\item \texttt{exclude}: specifies the types of objects to exclude from the traversal.


\item \texttt{chargeall}: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/summarysize.jl#L12-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7044880690333675643}{} 
\hyperlink{7044880690333675643}{\texttt{Base.edit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
edit(path::AbstractString, line::Integer=0)
\end{lstlisting}

Edit a file or directory optionally providing a line number to edit the file at. Returns to the \texttt{julia} prompt when you quit the editor. The editor can be changed by setting \texttt{JULIA\_EDITOR}, \texttt{VISUAL} or \texttt{EDITOR} as an environment variable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L26-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{427647396423486761}{} 
\hyperlink{427647396423486761}{\texttt{Base.edit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
edit(function, [types])
\end{lstlisting}

Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. The editor can be changed by setting \texttt{JULIA\_EDITOR}, \texttt{VISUAL} or \texttt{EDITOR} as an environment variable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L80-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17602563839609547712}{} 
\hyperlink{17602563839609547712}{\texttt{Base.@edit}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@edit
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls the \texttt{edit} function on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L469-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2845783434878498384}{} 
\hyperlink{2845783434878498384}{\texttt{Base.less}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
less(file::AbstractString, [line::Integer])
\end{lstlisting}

Show a file using the default pager, optionally providing a starting line number. Returns to the \texttt{julia} prompt when you quit the pager.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L106-L111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13199804309598213666}{} 
\hyperlink{13199804309598213666}{\texttt{Base.less}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
less(function, [types])
\end{lstlisting}

Show the definition of a function using the default pager, optionally specifying a tuple of types to indicate which method to see.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L114-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18315670497626788540}{} 
\hyperlink{18315670497626788540}{\texttt{Base.@less}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@less
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls the \texttt{less} function on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L461-L466}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13156769095888501950}{} 
\hyperlink{13156769095888501950}{\texttt{Base.clipboard}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clipboard(x)
\end{lstlisting}

Send a printed form of \texttt{x} to the operating system clipboard ({\textquotedbl}copy{\textquotedbl}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L203-L207}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13167214404646874260}{} 
\hyperlink{13167214404646874260}{\texttt{Base.clipboard}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clipboard() -> AbstractString
\end{lstlisting}

Return a string with the contents of the operating system clipboard ({\textquotedbl}paste{\textquotedbl}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L210-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6072703247917948688}{} 
\hyperlink{6072703247917948688}{\texttt{Base.reload}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reload(name::AbstractString)
\end{lstlisting}

Force reloading of a package, even if it has been loaded before. This is intended for use during package development as code is modified.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L366-L371}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16690217505788642360}{} 
\hyperlink{16690217505788642360}{\texttt{Base.require}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
require(module::Symbol)
\end{lstlisting}

This function is part of the implementation of \texttt{using} / \texttt{import}, if a module is not already defined in \texttt{Main}. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).

Loads a source file, in the context of the \texttt{Main} module, on every active node, searching standard locations for files. \texttt{require} is considered a top-level operation, so it sets the current \texttt{include} path but does not use it to search for files (see help for \texttt{include}). This function is typically used to load library code, and is implicitly called by \texttt{using} to load packages.

When searching for files, \texttt{require} first looks for package code under \texttt{Pkg.dir()}, then tries paths in the global array \texttt{LOAD\_PATH}. \texttt{require} is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L385-L403}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15403934372637978246}{} 
\hyperlink{15403934372637978246}{\texttt{Base.compilecache}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.compilecache(module::String)
\end{lstlisting}

Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in \texttt{LOAD\_CACHE\_PATH[1]}, which defaults to \texttt{{\textasciitilde}/.julia/lib/VERSION}. See \hyperlink{16564935669398681292}{Module initialization and precompilation} for important notes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L666-L675}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9213488790068613847}{} 
\hyperlink{9213488790068613847}{\texttt{Base.\_\_precompile\_\_}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
__precompile__(isprecompilable::Bool=true)
\end{lstlisting}

Specify whether the file calling this function is precompilable. If \texttt{isprecompilable} is \texttt{true}, then \texttt{\_\_precompile\_\_} throws an exception when the file is loaded by \texttt{using}/\texttt{import}/\texttt{require} \emph{unless} the file is being precompiled, and in a module file it causes the module to be automatically precompiled when it is imported. Typically, \texttt{\_\_precompile\_\_()} should occur before the \texttt{module} declaration in the file, or better yet \texttt{VERSION >= v{\textquotedbl}0.4{\textquotedbl} \&\& \_\_precompile\_\_()} in order to be backward-compatible with Julia 0.3.

If a module or file is \emph{not} safely precompilable, it should call \texttt{\_\_precompile\_\_(false)} in order to throw an error if Julia attempts to precompile it.

\texttt{\_\_precompile\_\_()} should \emph{not} be used in a module unless all of its dependencies are also using \texttt{\_\_precompile\_\_()}. Failure to do so can result in a runtime error when loading the module.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L321-L336}{\texttt{source}}


\end{adjustwidth}
\hypertarget{438355891087818425}{} 
\hyperlink{438355891087818425}{\texttt{Base.include}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
include(path::AbstractString)
\end{lstlisting}

Evaluate the contents of the input source file in the current context. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to \texttt{include} will search relative to that path. All paths refer to files on node 1 when running in parallel, and files will be fetched from node 1. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L591-L600}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2796348696499086186}{} 
\hyperlink{2796348696499086186}{\texttt{Base.include\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
include_string(code::AbstractString, filename::AbstractString="string")
\end{lstlisting}

Like \texttt{include}, except reads code from the given string rather than from a file. Since there is no file path involved, no path processing or fetching from node 1 is done.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L516-L521}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13423629850785876688}{} 
\hyperlink{13423629850785876688}{\texttt{Base.include\_dependency}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
include_dependency(path::AbstractString)
\end{lstlisting}

In a module, declare that the file specified by \texttt{path} (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.

This is only needed if your module depends on a file that is not used via \texttt{include}. It has no effect outside of compilation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L287-L296}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6069714544176255543}{} 
\hyperlink{6069714544176255543}{\texttt{Base.Docs.apropos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
apropos(string)
\end{lstlisting}

Search through all documentation for a string, ignoring case.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/utils.jl#L440-L444}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17355831054812136492}{} 
\hyperlink{17355831054812136492}{\texttt{Base.which}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
which(f, types)
\end{lstlisting}

Returns the method of \texttt{f} (a \texttt{Method} object) that would be called for arguments of the given \texttt{types}.

If \texttt{types} is an abstract type, then the method that would be called by \texttt{invoke} is returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L809-L815}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13771745306106792154}{} 
\hyperlink{13771745306106792154}{\texttt{Base.which}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
which(symbol)
\end{lstlisting}

Return the module in which the binding for the variable referenced by \texttt{symbol} was created.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L841-L845}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1849198515397717858}{} 
\hyperlink{1849198515397717858}{\texttt{Base.@which}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@which
\end{lstlisting}

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the \texttt{Method} object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the \texttt{which} function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L451-L458}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3025953302266245919}{} 
\hyperlink{3025953302266245919}{\texttt{Base.methods}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
methods(f, [types])
\end{lstlisting}

Returns the method table for \texttt{f}.

If \texttt{types} is specified, returns an array of methods whose types match.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L572-L578}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12860964732831752396}{} 
\hyperlink{12860964732831752396}{\texttt{Base.methodswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
methodswith(typ[, module or function][, showparents::Bool=false])
\end{lstlisting}

Return an array of methods with an argument of type \texttt{typ}.

The optional second argument restricts the search to a particular module or function (the default is all modules, starting from Main).

If optional \texttt{showparents} is \texttt{true}, also return arguments with a parent type of \texttt{typ}, excluding type \texttt{Any}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L534-L544}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13133508810150623671}{} 
\hyperlink{13133508810150623671}{\texttt{Base.@show}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@show
\end{lstlisting}

Show an expression and result, returning the result.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L815-L819}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4959604240462971450}{} 
\hyperlink{4959604240462971450}{\texttt{Base.versioninfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
versioninfo(io::IO=STDOUT, verbose::Bool=false)
\end{lstlisting}

Print information about the version of Julia in use. If the \texttt{verbose} argument is \texttt{true}, detailed system information is shown as well.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L247-L252}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7789928938295338947}{} 
\hyperlink{7789928938295338947}{\texttt{Base.workspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
workspace()
\end{lstlisting}

Replace the top-level module (\texttt{Main}) with a new one, providing a clean workspace. The previous \texttt{Main} module is made available as \texttt{LastMain}. A previously-loaded package can be accessed using a statement such as \texttt{using LastMain.Package}.

This function should only be used interactively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L648-L656}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11288188119698492222}{} 
\hyperlink{11288188119698492222}{\texttt{ans}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ans
\end{lstlisting}

A variable referring to the last computed value, automatically set at the interactive prompt.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L684-L688}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14831108203714113824}{}


\section{Todos los Objetos}


\hypertarget{7974744969331231272}{} 
\hyperlink{7974744969331231272}{\texttt{Core.:===}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
===(x,y) -> Bool
≡(x,y) -> Bool
\end{lstlisting}

Determine whether \texttt{x} and \texttt{y} are identical, in the sense that no program could distinguish them. Compares mutable objects by address in memory, and compares immutable objects (such as numbers) by contents at the bit level. This function is sometimes called \texttt{egal}.


\begin{minted}{jlcon}
julia> a = [1, 2]; b = [1, 2];

julia> a == b
true

julia> a === b
false

julia> a === a
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L132-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7066325108767373297}{} 
\hyperlink{7066325108767373297}{\texttt{Core.isa}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isa(x, type) -> Bool
\end{lstlisting}

Determine whether \texttt{x} is of the given \texttt{type}. Can also be used as an infix operator, e.g. \texttt{x isa type}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2146-L2151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12829995639916057841}{} 
\hyperlink{12829995639916057841}{\texttt{Base.isequal}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isequal(x, y)
\end{lstlisting}

Similar to \texttt{==}, except treats all floating-point \texttt{NaN} values as equal to each other, and treats \texttt{-0.0} as unequal to \texttt{0.0}. The default implementation of \texttt{isequal} calls \texttt{==}, so if you have a type that doesn{\textquotesingle}t have these floating-point subtleties then you probably only need to define \texttt{==}.

\texttt{isequal} is the comparison function used by hash tables (\texttt{Dict}). \texttt{isequal(x,y)} must imply that \texttt{hash(x) == hash(y)}.

This typically means that if you define your own \texttt{==} function then you must define a corresponding \texttt{hash} (and vice versa). Collections typically implement \texttt{isequal} by calling \texttt{isequal} recursively on all contents.

Scalar types generally do not need to implement \texttt{isequal} separate from \texttt{==}, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on \texttt{isnan}, \texttt{signbit}, and \texttt{==}).


\begin{minted}{jlcon}
julia> isequal([1., NaN], [1., NaN])
true

julia> [1., NaN] == [1., NaN]
false

julia> 0.0 == -0.0
true

julia> isequal(0.0, -0.0)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L54-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15106114209632897560}{} 
\hyperlink{15106114209632897560}{\texttt{Base.isequal}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isequal(x, y)
\end{lstlisting}

Similar to \texttt{==}, except treats all floating-point \texttt{NaN} values as equal to each other, and treats \texttt{-0.0} as unequal to \texttt{0.0}. The default implementation of \texttt{isequal} calls \texttt{==}, so if you have a type that doesn{\textquotesingle}t have these floating-point subtleties then you probably only need to define \texttt{==}.

\texttt{isequal} is the comparison function used by hash tables (\texttt{Dict}). \texttt{isequal(x,y)} must imply that \texttt{hash(x) == hash(y)}.

This typically means that if you define your own \texttt{==} function then you must define a corresponding \texttt{hash} (and vice versa). Collections typically implement \texttt{isequal} by calling \texttt{isequal} recursively on all contents.

Scalar types generally do not need to implement \texttt{isequal} separate from \texttt{==}, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on \texttt{isnan}, \texttt{signbit}, and \texttt{==}).


\begin{minted}{jlcon}
julia> isequal([1., NaN], [1., NaN])
true

julia> [1., NaN] == [1., NaN]
false

julia> 0.0 == -0.0
true

julia> isequal(0.0, -0.0)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L54-L86}{\texttt{source}}



\begin{lstlisting}
isequal(x::Nullable, y::Nullable)
\end{lstlisting}

If neither \texttt{x} nor \texttt{y} is null, compare them according to their values (i.e. \texttt{isequal(get(x), get(y))}). Else, return \texttt{true} if both arguments are null, and \texttt{false} if one is null but not the other: nulls are considered equal.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L198-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8062916604071842790}{} 
\hyperlink{8062916604071842790}{\texttt{Base.isless}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isless(x, y)
\end{lstlisting}

Test whether \texttt{x} is less than \texttt{y}, according to a canonical total order. Values that are normally unordered, such as \texttt{NaN}, are ordered in an arbitrary but consistent fashion. This is the default comparison used by \hyperlink{8473525809131227606}{\texttt{sort}}. Non-numeric types with a canonical total order should implement this function. Numeric types only need to implement it if they have special values such as \texttt{NaN}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1743-L1751}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16562333801171100234}{} 
\hyperlink{16562333801171100234}{\texttt{Base.isless}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isless(x::Nullable, y::Nullable)
\end{lstlisting}

If neither \texttt{x} nor \texttt{y} is null, compare them according to their values (i.e. \texttt{isless(get(x), get(y))}). Else, return \texttt{true} if only \texttt{y} is null, and \texttt{false} otherwise: nulls are always considered greater than non-nulls, but not greater than another null.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L217-L224}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9861487635347877687}{} 
\hyperlink{9861487635347877687}{\texttt{Base.ifelse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ifelse(condition::Bool, x, y)
\end{lstlisting}

Return \texttt{x} if \texttt{condition} is \texttt{true}, otherwise return \texttt{y}. This differs from \texttt{?} or \texttt{if} in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using \texttt{ifelse} instead of an \texttt{if} statement can eliminate the branch in generated code and provide higher performance in tight loops.


\begin{minted}{jlcon}
julia> ifelse(1 > 2, 1, 2)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L269-L281}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15219532373351781780}{} 
\hyperlink{15219532373351781780}{\texttt{Base.lexcmp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lexcmp(x, y)
\end{lstlisting}

Compare \texttt{x} and \texttt{y} lexicographically and return -1, 0, or 1 depending on whether \texttt{x} is less than, equal to, or greater than \texttt{y}, respectively. This function should be defined for lexicographically comparable types, and \texttt{lexless} will call \texttt{lexcmp} by default.


\begin{minted}{jlcon}
julia> lexcmp("abc", "abd")
-1

julia> lexcmp("abc", "abc")
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L305-L319}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6010337650622228595}{} 
\hyperlink{6010337650622228595}{\texttt{Base.lexless}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lexless(x, y)
\end{lstlisting}

Determine whether \texttt{x} is lexicographically less than \texttt{y}.


\begin{minted}{jlcon}
julia> lexless("abc", "abd")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L322-L331}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13440452181855594120}{} 
\hyperlink{13440452181855594120}{\texttt{Core.typeof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typeof(x)
\end{lstlisting}

Get the concrete type of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1017-L1021}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12342862450082530092}{} 
\hyperlink{12342862450082530092}{\texttt{Core.tuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tuple(xs...)
\end{lstlisting}

Construct a tuple of the given objects.

\textbf{Example}


\begin{minted}{jlcon}
julia> tuple(1, 'a', pi)
(1, 'a', π = 3.1415926535897...)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L580-L590}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11196859324054101444}{} 
\hyperlink{11196859324054101444}{\texttt{Base.ntuple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ntuple(f::Function, n::Integer)
\end{lstlisting}

Create a tuple of length \texttt{n}, computing each element as \texttt{f(i)}, where \texttt{i} is the index of the element.


\begin{minted}{jlcon}
julia> ntuple(i -> 2*i, 4)
(2, 4, 6, 8)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/tuple.jl#L96-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16410505889262851104}{} 
\hyperlink{16410505889262851104}{\texttt{Base.object\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
object_id(x)
\end{lstlisting}

Get a hash value for \texttt{x} based on object identity. \texttt{object\_id(x)==object\_id(y)} if \texttt{x === y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1829-L1833}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13797072367283572032}{} 
\hyperlink{13797072367283572032}{\texttt{Base.hash}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hash(x[, h::UInt])
\end{lstlisting}

Compute an integer hash code such that \texttt{isequal(x,y)} implies \texttt{hash(x)==hash(y)}. The optional second argument \texttt{h} is a hash code to be mixed with the result.

New types should implement the 2-argument form, typically by calling the 2-argument \texttt{hash} method recursively in order to mix hashes of the contents with each other (and with \texttt{h}). Typically, any type that implements \texttt{hash} should also implement its own \texttt{==} (hence \texttt{isequal}) to guarantee the property mentioned above.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1469-L1479}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4805357059330171046}{} 
\hyperlink{4805357059330171046}{\texttt{Base.finalizer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
finalizer(x, f)
\end{lstlisting}

Register a function \texttt{f(x)} to be called when there are no program-accessible references to \texttt{x}. The type of \texttt{x} must be a \texttt{mutable struct}, otherwise the behavior of this function is unpredictable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1879-L1885}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6584919147438336166}{} 
\hyperlink{6584919147438336166}{\texttt{Base.finalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
finalize(x)
\end{lstlisting}

Immediately run finalizers registered for object \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1129-L1133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15665284441316555522}{} 
\hyperlink{15665284441316555522}{\texttt{Base.copy}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copy(x)
\end{lstlisting}

Create a shallow copy of \texttt{x}: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1577-L1583}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3259459540194502889}{} 
\hyperlink{3259459540194502889}{\texttt{Base.deepcopy}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deepcopy(x)
\end{lstlisting}

Create a deep copy of \texttt{x}: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling \texttt{deepcopy} on an object should generally have the same effect as serializing and then deserializing it.

As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.

While it isn{\textquotesingle}t normally necessary, user-defined types can override the default \texttt{deepcopy} behavior by defining a specialized version of the function \texttt{deepcopy\_internal(x::T, dict::ObjectIdDict)} (which shouldn{\textquotesingle}t otherwise be used), where \texttt{T} is the type to be specialized for, and \texttt{dict} keeps track of objects copied so far within the recursion. Within the definition, \texttt{deepcopy\_internal} should be used in place of \texttt{deepcopy}, and the \texttt{dict} variable should be updated as appropriate before returning.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2518-L2536}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11212950246505288748}{} 
\hyperlink{11212950246505288748}{\texttt{Core.isdefined}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdefined([m::Module,] s::Symbol)
isdefined(object, s::Symbol)
isdefined(object, index::Int)
\end{lstlisting}

Tests whether an assignable location is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index. With a single symbol argument, tests whether a global variable with that name is defined in \hyperlink{14046118357995428445}{\texttt{current\_module()}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1526-L1534}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1846942650946171605}{} 
\hyperlink{1846942650946171605}{\texttt{Base.convert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
convert(T, x)
\end{lstlisting}

Convert \texttt{x} to a value of type \texttt{T}.

If \texttt{T} is an \hyperlink{8469131683393450448}{\texttt{Integer}} type, an \hyperlink{5399118524830636312}{\texttt{InexactError}} will be raised if \texttt{x} is not representable by \texttt{T}, for example if \texttt{x} is not integer-valued, or is outside the range supported by \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> convert(Int, 3.0)
3

julia> convert(Int, 3.5)
ERROR: InexactError()
Stacktrace:
 [1] convert(::Type{Int64}, ::Float64) at ./float.jl:679
\end{minted}

If \texttt{T} is a \hyperlink{11465394427882483091}{\texttt{AbstractFloat}} or \hyperlink{8304566144531167610}{\texttt{Rational}} type, then it will return the closest value to \texttt{x} representable by \texttt{T}.


\begin{minted}{jlcon}
julia> x = 1/3
0.3333333333333333

julia> convert(Float32, x)
0.33333334f0

julia> convert(Rational{Int32}, x)
1//3

julia> convert(Rational{Int64}, x)
6004799503160661//18014398509481984
\end{minted}

If \texttt{T} is a collection type and \texttt{x} a collection, the result of \texttt{convert(T, x)} may alias \texttt{x}.


\begin{minted}{jlcon}
julia> x = Int[1,2,3];

julia> y = convert(Vector{Int}, x);

julia> y === x
true
\end{minted}

Similarly, if \texttt{T} is a composite type and \texttt{x} a related instance, the result of \texttt{convert(T, x)} may alias part or all of \texttt{x}.


\begin{minted}{jlcon}
julia> x = speye(5);

julia> typeof(x)
SparseMatrixCSC{Float64,Int64}

julia> y = convert(SparseMatrixCSC{Float64,Int64}, x);

julia> z = convert(SparseMatrixCSC{Float32,Int64}, y);

julia> y === x
true

julia> z === x
false

julia> z.colptr === x.colptr
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2173-L2241}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1760874576431605095}{} 
\hyperlink{1760874576431605095}{\texttt{Base.promote}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
promote(xs...)
\end{lstlisting}

Convert all arguments to their common promotion type (if any), and return them all (as a tuple).

\textbf{Example}


\begin{minted}{jlcon}
julia> promote(Int8(1), Float16(4.5), Float32(4.1))
(1.0f0, 4.5f0, 4.1f0)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L407-L417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{374166931194490566}{} 
\hyperlink{374166931194490566}{\texttt{Base.oftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
oftype(x, y)
\end{lstlisting}

Convert \texttt{y} to the type of \texttt{x} (\texttt{convert(typeof(x), y)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L377-L381}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18091106262785739128}{} 
\hyperlink{18091106262785739128}{\texttt{Base.widen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
widen(x)
\end{lstlisting}

If \texttt{x} is a type, return a {\textquotedbl}larger{\textquotedbl} type (for numeric types, this will be a type with at least as much range and precision as the argument, and usually more). Otherwise \texttt{x} is converted to \texttt{widen(typeof(x))}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> widen(Int32)
Int64

julia> widen(1.5f0)
1.5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2539-L2554}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18150582836499084779}{} 
\hyperlink{18150582836499084779}{\texttt{Base.identity}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
identity(x)
\end{lstlisting}

The identity function. Returns its argument.


\begin{minted}{jlcon}
julia> identity("Well, what did you expect?")
"Well, what did you expect?"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L387-L396}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11424388444523813863}{}


\section{Tipos}


\hypertarget{12192788431675298651}{} 
\hyperlink{12192788431675298651}{\texttt{Base.supertype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
supertype(T::DataType)
\end{lstlisting}

Return the supertype of DataType \texttt{T}.


\begin{minted}{jlcon}
julia> supertype(Int32)
Signed
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L30-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5954612615304731643}{} 
\hyperlink{5954612615304731643}{\texttt{Core.issubtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issubtype(type1, type2)
\end{lstlisting}

Return \texttt{true} if and only if all values of \texttt{type1} are also of \texttt{type2}. Can also be written using the \texttt{<:} infix operator as \texttt{type1 <: type2}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issubtype(Int8, Int32)
false

julia> Int8 <: Integer
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1862-L1876}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10973847109239228196}{} 
\hyperlink{10973847109239228196}{\texttt{Base.:<:}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
<:(T1, T2)
\end{lstlisting}

Subtype operator, equivalent to \texttt{issubtype(T1, T2)}.


\begin{minted}{jlcon}
julia> Float64 <: AbstractFloat
true

julia> Vector{Int} <: AbstractArray
true

julia> Matrix{Float64} <: Matrix{AbstractFloat}
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L5-L20}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13074915255343859584}{} 
\hyperlink{13074915255343859584}{\texttt{Base.:>:}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>:(T1, T2)
\end{lstlisting}

Supertype operator, equivalent to \texttt{issubtype(T2, T1)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L23-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18325429904830593994}{} 
\hyperlink{18325429904830593994}{\texttt{Base.subtypes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
subtypes(T::DataType)
\end{lstlisting}

Return a list of immediate subtypes of DataType \texttt{T}. Note that all currently loaded subtypes are included, including those not visible in the current module.


\begin{minted}{jlcon}
julia> subtypes(Integer)
4-element Array{Union{DataType, UnionAll},1}:
 BigInt
 Bool
 Signed
 Unsigned
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L445-L459}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3613894539247233488}{} 
\hyperlink{3613894539247233488}{\texttt{Base.typemin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typemin(T)
\end{lstlisting}

The lowest value representable by the given (real) numeric DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> typemin(Float16)
-Inf16

julia> typemin(Float32)
-Inf32
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1001-L1014}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17760305803764597758}{} 
\hyperlink{17760305803764597758}{\texttt{Base.typemax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typemax(T)
\end{lstlisting}

The highest value representable by the given (real) numeric \texttt{DataType}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1616-L1620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12203155268347273277}{} 
\hyperlink{12203155268347273277}{\texttt{Base.realmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
realmin(T)
\end{lstlisting}

The smallest in absolute value non-subnormal value representable by the given floating-point DataType \texttt{T}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2504-L2508}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1776131488016104529}{} 
\hyperlink{1776131488016104529}{\texttt{Base.realmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
realmax(T)
\end{lstlisting}

The highest finite value representable by the given floating-point DataType \texttt{T}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> realmax(Float16)
Float16(6.55e4)

julia> realmax(Float32)
3.4028235f38
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L974-L987}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5283633936957536148}{} 
\hyperlink{5283633936957536148}{\texttt{Base.maxintfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
maxintfloat(T)
\end{lstlisting}

The largest integer losslessly representable by the given floating-point DataType \texttt{T}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1316-L1320}{\texttt{source}}



\begin{lstlisting}
maxintfloat(T, S)
\end{lstlisting}

The largest integer losslessly representable by the given floating-point DataType \texttt{T} that also does not exceed the maximum integer representable by the integer DataType \texttt{S}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1323-L1328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10394541563305653720}{} 
\hyperlink{10394541563305653720}{\texttt{Base.sizeof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sizeof(T)
\end{lstlisting}

Size, in bytes, of the canonical binary representation of the given DataType \texttt{T}, if any.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sizeof(Float32)
4

julia> sizeof(Complex128)
16
\end{minted}

If \texttt{T} does not have a specific size, an error is thrown.


\begin{minted}{jlcon}
julia> sizeof(Base.LinAlg.LU)
ERROR: argument is an abstract type; size is indeterminate
Stacktrace:
 [1] sizeof(::Type{T} where T) at ./essentials.jl:159
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L332-L354}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11829482654697677043}{} 
\hyperlink{11829482654697677043}{\texttt{Base.eps}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eps(::Type{T}) where T<:AbstractFloat
eps()
\end{lstlisting}

Returns the \emph{machine epsilon} of the floating point type \texttt{T} (\texttt{T = Float64} by default). This is defined as the gap between 1 and the next largest value representable by \texttt{T}, and is equivalent to \texttt{eps(one(T))}.


\begin{minted}{jlcon}
julia> eps()
2.220446049250313e-16

julia> eps(Float32)
1.1920929f-7

julia> 1.0 + eps()
1.0000000000000002

julia> 1.0 + eps()/2
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L718-L739}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8678379894267468692}{} 
\hyperlink{8678379894267468692}{\texttt{Base.eps}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eps(x::AbstractFloat)
\end{lstlisting}

Returns the \emph{unit in last place} (ulp) of \texttt{x}. This is the distance between consecutive representable floating point values at \texttt{x}. In most cases, if the distance on either side of \texttt{x} is different, then the larger of the two is taken, that is


\begin{lstlisting}
eps(x) == max(x-prevfloat(x), nextfloat(x)-x)
\end{lstlisting}

The exceptions to this rule are the smallest and largest finite values (e.g. \texttt{nextfloat(-Inf)} and \texttt{prevfloat(Inf)} for \hyperlink{5027751419500983000}{\texttt{Float64}}), which round to the smaller of the values.

The rationale for this behavior is that \texttt{eps} bounds the floating point rounding error. Under the default \texttt{RoundNearest} rounding mode, if \(y\) is a real number and \(x\) is the nearest floating point number to \(y\), then

\begin{equation*}
\begin{split}|y-x| \leq \operatorname{eps}(x)/2.\end{split}\end{equation*}

\begin{minted}{jlcon}
julia> eps(1.0)
2.220446049250313e-16

julia> eps(prevfloat(2.0))
2.220446049250313e-16

julia> eps(2.0)
4.440892098500626e-16

julia> x = prevfloat(Inf)      # largest finite Float64
1.7976931348623157e308

julia> x + eps(x)/2            # rounds up
Inf

julia> x + prevfloat(eps(x)/2) # rounds down
1.7976931348623157e308
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L742-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15048881762587391286}{} 
\hyperlink{15048881762587391286}{\texttt{Base.promote\_type}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
promote_type(type1, type2)
\end{lstlisting}

Determine a type big enough to hold values of each argument type without loss, whenever possible. In some cases, where no type exists to which both types can be promoted losslessly, some loss is tolerated; for example, \texttt{promote\_type(Int64, Float64)} returns \hyperlink{5027751419500983000}{\texttt{Float64}} even though strictly, not all \hyperlink{7720564657383125058}{\texttt{Int64}} values can be represented exactly as \texttt{Float64} values.


\begin{minted}{jlcon}
julia> promote_type(Int64, Float64)
Float64

julia> promote_type(Int32, Int64)
Int64

julia> promote_type(Float32, BigInt)
BigFloat
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/promotion.jl#L134-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16547112220540026290}{} 
\hyperlink{16547112220540026290}{\texttt{Base.promote\_rule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
promote_rule(type1, type2)
\end{lstlisting}

Specifies what type should be used by \hyperlink{1760874576431605095}{\texttt{promote}} when given values of types \texttt{type1} and \texttt{type2}. This function should not be called directly, but should have definitions added to it for new types as appropriate.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2086-L2092}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13312214354258464709}{} 
\hyperlink{13312214354258464709}{\texttt{Core.getfield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getfield(value, name::Symbol)
\end{lstlisting}

Extract a named field from a \texttt{value} of composite type. The syntax \texttt{a.b} calls \texttt{getfield(a, :b)}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1//2
1//2

julia> getfield(a, :num)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L836-L850}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11796708313392299971}{} 
\hyperlink{11796708313392299971}{\texttt{Core.setfield!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setfield!(value, name::Symbol, x)
\end{lstlisting}

Assign \texttt{x} to a named field in \texttt{value} of composite type. The syntax \texttt{a.b = c} calls \texttt{setfield!(a, :b, c)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1909-L1914}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6956980533195055227}{} 
\hyperlink{6956980533195055227}{\texttt{Base.fieldoffset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fieldoffset(type, i)
\end{lstlisting}

The byte offset of field \texttt{i} of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:


\begin{minted}{jlcon}
julia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:nfields(T)];

julia> structinfo(Base.Filesystem.StatStruct)
12-element Array{Tuple{UInt64,Symbol,DataType},1}:
 (0x0000000000000000, :device, UInt64)
 (0x0000000000000008, :inode, UInt64)
 (0x0000000000000010, :mode, UInt64)
 (0x0000000000000018, :nlink, Int64)
 (0x0000000000000020, :uid, UInt64)
 (0x0000000000000028, :gid, UInt64)
 (0x0000000000000030, :rdev, UInt64)
 (0x0000000000000038, :size, Int64)
 (0x0000000000000040, :blksize, Int64)
 (0x0000000000000048, :blocks, Int64)
 (0x0000000000000050, :mtime, Float64)
 (0x0000000000000058, :ctime, Float64)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L310-L334}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17091563430048909487}{} 
\hyperlink{17091563430048909487}{\texttt{Core.fieldtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fieldtype(T, name::Symbol | index::Int)
\end{lstlisting}

Determine the declared type of a field (specified by name or index) in a composite DataType \texttt{T}.


\begin{minted}{jlcon}
julia> struct Foo
           x::Int64
           y::String
       end

julia> fieldtype(Foo, :x)
Int64

julia> fieldtype(Foo, 2)
String
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L337-L354}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13869545361033105546}{} 
\hyperlink{13869545361033105546}{\texttt{Base.isimmutable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isimmutable(v)
\end{lstlisting}

Return \texttt{true} iff value \texttt{v} is immutable.  See \hyperlink{4895133348259895821}{Mutable Composite Types} for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of \texttt{DataType} is mutable.


\begin{minted}{jlcon}
julia> isimmutable(1)
true

julia> isimmutable([1,2])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L199-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12980593021531333073}{} 
\hyperlink{12980593021531333073}{\texttt{Base.isbits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isbits(T)
\end{lstlisting}

Return \texttt{true} if \texttt{T} is a {\textquotedbl}plain data{\textquotedbl} type, meaning it is immutable and contains no references to other values. Typical examples are numeric types such as \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, and \hyperlink{11302502367029942782}{\texttt{Complex\{Float64\}}}.


\begin{minted}{jlcon}
julia> isbits(Complex{Float64})
true

julia> isbits(Complex)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L218-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4142150919569135392}{} 
\hyperlink{4142150919569135392}{\texttt{Base.isleaftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isleaftype(T)
\end{lstlisting}

Determine whether \texttt{T}{\textquotesingle}s only subtypes are itself and \texttt{Union\{\}}. This means \texttt{T} is a concrete type that can have instances.


\begin{minted}{jlcon}
julia> isleaftype(Complex)
false

julia> isleaftype(Complex{Float32})
true

julia> isleaftype(Vector{Complex})
true

julia> isleaftype(Vector{Complex{Float32}})
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L237-L256}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6895589781245489183}{} 
\hyperlink{6895589781245489183}{\texttt{Base.typejoin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typejoin(T, S)
\end{lstlisting}

Compute a type that contains both \texttt{T} and \texttt{S}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1389-L1393}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1869272868531275554}{} 
\hyperlink{1869272868531275554}{\texttt{Base.typeintersect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
typeintersect(T, S)
\end{lstlisting}

Compute a type that contains the intersection of \texttt{T} and \texttt{S}. Usually this will be the smallest such type or one close to it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L301-L306}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1312938105781775871}{} 
\hyperlink{1312938105781775871}{\texttt{Base.Val}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Val{c}
\end{lstlisting}

Create a {\textquotedbl}value type{\textquotedbl} out of \texttt{c}, which must be an \texttt{isbits} value. The intent of this construct is to be able to dispatch on constants, e.g., \texttt{f(Val\{false\})} allows you to dispatch directly (at compile-time) to an implementation \texttt{f(::Type\{Val\{false\}\})}, without having to test the boolean value at runtime.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2574-L2581}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18177775477210803027}{} 
\hyperlink{18177775477210803027}{\texttt{Base.Enums.@enum}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@enum EnumName[::BaseType] value1[=x] value2[=y]
\end{lstlisting}

Create an \texttt{Enum\{BaseType\}} subtype with name \texttt{EnumName} and enum member values of \texttt{value1} and \texttt{value2} with optional assigned values of \texttt{x} and \texttt{y}, respectively. \texttt{EnumName} can be used just like other types and enum member values as regular values, such as


\begin{minted}{jlcon}
julia> @enum Fruit apple=1 orange=2 kiwi=3

julia> f(x::Fruit) = "I'm a Fruit with value: $(Int(x))"
f (generic function with 1 method)

julia> f(apple)
"I'm a Fruit with value: 1"
\end{minted}

\texttt{BaseType}, which defaults to \hyperlink{10103694114785108551}{\texttt{Int32}}, must be a primitive subtype of \texttt{Integer}. Member values can be converted between the enum type and \texttt{BaseType}. \texttt{read} and \texttt{write} perform these conversions automatically.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/Enums.jl#L31-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1621796923312060494}{} 
\hyperlink{1621796923312060494}{\texttt{Base.instances}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
instances(T::Type)
\end{lstlisting}

Return a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see \texttt{@enum}).


\begin{minted}{jlcon}
julia> @enum Color red blue green

julia> instances(Color)
(red::Color = 0, blue::Color = 1, green::Color = 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L386-L398}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14185067953421617661}{}


\section{Funciones Genéricas}


\hypertarget{2744637612596423318}{} 
\hyperlink{2744637612596423318}{\texttt{Core.Function}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Function
\end{lstlisting}

Abstract type of all functions.


\begin{minted}{jlcon}
julia> isa(+, Function)
true

julia> typeof(sin)
Base.#sin

julia> ans <: Function
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L726-L741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7096441800037644952}{} 
\hyperlink{7096441800037644952}{\texttt{Base.method\_exists}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
method_exists(f, Tuple type, world=typemax(UInt)) -> Bool
\end{lstlisting}

Determine whether the given generic function has a method matching the given \texttt{Tuple} of argument types with the upper bound of world age given by \texttt{world}.


\begin{minted}{jlcon}
julia> method_exists(length, Tuple{Array})
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L921-L931}{\texttt{source}}


\end{adjustwidth}
\hypertarget{366019948759111192}{} 
\hyperlink{366019948759111192}{\texttt{Core.applicable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
applicable(f, args...) -> Bool
\end{lstlisting}

Determine whether the given generic function has a method applicable to the given arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function f(x, y)
           x + y
       end;

julia> applicable(f, 1)
false

julia> applicable(f, 1, 2)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2244-L2261}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14356043600121087376}{} 
\hyperlink{14356043600121087376}{\texttt{Core.invoke}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
invoke(f, types <: Tuple, args...)
\end{lstlisting}

Invoke a method for the given generic function matching the specified types, on the specified arguments. The arguments must be compatible with the specified types. This allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1143-L1151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15240876280767285272}{} 
\hyperlink{15240876280767285272}{\texttt{Base.invokelatest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
invokelatest(f, args...)
\end{lstlisting}

Calls \texttt{f(args...)}, but guarantees that the most recent method of \texttt{f} will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function \texttt{f}. (The drawback is that \texttt{invokelatest} is somewhat slower than calling \texttt{f} directly, and the type of the result cannot be inferred by the compiler.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L360-L369}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5135459825603202944}{} 
\hyperlink{5135459825603202944}{\texttt{Base.:|>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
|>(x, f)
\end{lstlisting}

Applies a function to the preceding argument. This allows for easy function chaining.


\begin{minted}{jlcon}
julia> [1:5;] |> x->x.^2 |> sum |> inv
0.01818181818181818
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L852-L861}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8400062617555407555}{} 
\hyperlink{8400062617555407555}{\texttt{Base.:∘}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
f ∘ g
\end{lstlisting}

Compose functions: i.e. \texttt{(f ∘ g)(args...)} means \texttt{f(g(args...))}. The \texttt{∘} symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing \texttt{{\textbackslash}circ<tab>}. Example:


\begin{minted}{jlcon}
julia> map(uppercase∘hex, 250:255)
6-element Array{String,1}:
 "FA"
 "FB"
 "FC"
 "FD"
 "FE"
 "FF"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L866-L883}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7670568709019810759}{}


\section{Sintaxis}


\hypertarget{2345597220715550879}{} 
\hyperlink{2345597220715550879}{\texttt{Core.eval}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eval([m::Module], expr::Expr)
\end{lstlisting}

Evaluate an expression in the given module and return the result. Every \texttt{Module} (except those defined with \texttt{baremodule}) has its own 1-argument definition of \texttt{eval}, which evaluates expressions in that module.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L102-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12895501458291832858}{} 
\hyperlink{12895501458291832858}{\texttt{Base.@eval}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@eval [mod,] ex
\end{lstlisting}

Evaluate an expression with values interpolated into it using \texttt{eval}. If two arguments are provided, the first is the module to evaluate in.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L46-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1049904639707765509}{} 
\hyperlink{1049904639707765509}{\texttt{Base.evalfile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
evalfile(path::AbstractString, args::Vector{String}=String[])
\end{lstlisting}

Load the file using \hyperlink{438355891087818425}{\texttt{include}}, evaluate all expressions, and return the value of the last one.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L603-L608}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17861659594346526773}{} 
\hyperlink{17861659594346526773}{\texttt{Base.esc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
esc(e::ANY)
\end{lstlisting}

Only valid in the context of an \texttt{Expr} returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the \hyperlink{11146454106624591870}{Macros} section of the Metaprogramming chapter of the manual for more details and examples.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L193-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9619263577270933060}{} 
\hyperlink{9619263577270933060}{\texttt{Base.@inbounds}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@inbounds(blk)
\end{lstlisting}

Eliminates array bounds checking within expressions.

In the example below the bound check of array A is skipped to improve performance.


\begin{minted}{julia}
function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end
\end{minted}

\begin{quote}
\textbf{Warning}

Using \texttt{@inbounds} may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L209-L230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18060766522149343036}{} 
\hyperlink{18060766522149343036}{\texttt{Base.@inline}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@inline
\end{lstlisting}

Give a hint to the compiler that this function is worth inlining.

Small functions typically do not need the \texttt{@inline} annotation, as the compiler does it automatically. By using \texttt{@inline} on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:


\begin{minted}{julia}
@inline function bigfunction(x)
    #=
        Function Definition
    =#
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L111-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13090632948127397341}{} 
\hyperlink{13090632948127397341}{\texttt{Base.@noinline}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@noinline
\end{lstlisting}

Prevents the compiler from inlining a function.

Small functions are typically inlined automatically. By using \texttt{@noinline} on small functions, auto-inlining can be prevented. This is shown in the following example:


\begin{minted}{julia}
@noinline function smallfunction(x)
    #=
        Function Definition
    =#
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L133-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3515345868651201289}{} 
\hyperlink{3515345868651201289}{\texttt{Base.gensym}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gensym([tag])
\end{lstlisting}

Generates a symbol which will not conflict with other variable names.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1574260997115674041}{} 
\hyperlink{1574260997115674041}{\texttt{Base.@gensym}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@gensym
\end{lstlisting}

Generates a gensym symbol for a variable. For example, \texttt{@gensym x y} is transformed into \texttt{x = gensym({\textquotedbl}x{\textquotedbl}); y = gensym({\textquotedbl}y{\textquotedbl})}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L18-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17097218075487180587}{} 
\hyperlink{17097218075487180587}{\texttt{Base.@polly}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@polly
\end{lstlisting}

Tells the compiler to apply the polyhedral optimizer Polly to a function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L173-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4644249546022001645}{} 
\hyperlink{4644249546022001645}{\texttt{Base.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parse(str, start; greedy=true, raise=true)
\end{lstlisting}

Parse the expression string and return an expression (which could later be passed to eval for execution). \texttt{start} is the index of the first character to start parsing. If \texttt{greedy} is \texttt{true} (default), \texttt{parse} will try to consume as much input as it can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntactically valid expressions will return \texttt{Expr(:incomplete, {\textquotedbl}(error message){\textquotedbl})}. If \texttt{raise} is \texttt{true} (default), syntax errors other than incomplete expressions will raise an error. If \texttt{raise} is \texttt{false}, \texttt{parse} will return an expression that will raise an error upon evaluation.


\begin{minted}{jlcon}
julia> parse("x = 3, y = 5", 7)
(:(y = 5), 13)

julia> parse("x = 3, y = 5", 5)
(:((3, y) = 5), 13)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1154-L1172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12837389312481960786}{} 
\hyperlink{12837389312481960786}{\texttt{Base.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parse(str; raise=true)
\end{lstlisting}

Parse the expression string greedily, returning a single expression. An error is thrown if there are additional characters after the first expression. If \texttt{raise} is \texttt{true} (default), syntax errors will raise an error; otherwise, \texttt{parse} will return an expression that will raise an error upon evaluation.


\begin{minted}{jlcon}
julia> parse("x = 3")
:(x = 3)

julia> parse("x = ")
:($(Expr(:incomplete, "incomplete: premature end of input")))

julia> parse("1.0.2")
ERROR: ParseError("invalid numeric constant \"1.0.\"")
Stacktrace:
[...]

julia> parse("1.0.2"; raise = false)
:($(Expr(:error, "invalid numeric constant \"1.0.\"")))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1175-L1198}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7136056273836631018}{}


\section{\emph{Nullables}}


\hypertarget{2208920129454296646}{} 
\hyperlink{2208920129454296646}{\texttt{Base.Nullable}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Nullable(x, hasvalue::Bool=true)
\end{lstlisting}

Wrap value \texttt{x} in an object of type \texttt{Nullable}, which indicates whether a value is present. \texttt{Nullable(x)} yields a non-empty wrapper and \texttt{Nullable\{T\}()} yields an empty instance of a wrapper that might contain a value of type \texttt{T}.

\texttt{Nullable(x, false)} yields \texttt{Nullable\{typeof(x)\}()} with \texttt{x} stored in the result{\textquotesingle}s \texttt{value} field.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Nullable(1)
Nullable{Int64}(1)

julia> Nullable{Int64}()
Nullable{Int64}()

julia> Nullable(1, false)
Nullable{Int64}()

julia> dump(Nullable(1, false))
Nullable{Int64}
  hasvalue: Bool false
  value: Int64 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L6-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18027826894922685265}{} 
\hyperlink{18027826894922685265}{\texttt{Base.get}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get(x::Nullable[, y])
\end{lstlisting}

Attempt to access the value of \texttt{x}. Returns the value if it is present; otherwise, returns \texttt{y} if provided, or throws a \texttt{NullException} if not.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L78-L83}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16547052476421706505}{} 
\hyperlink{16547052476421706505}{\texttt{Base.isnull}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isnull(x)
\end{lstlisting}

Return whether or not \texttt{x} is null for \hyperlink{2208920129454296646}{\texttt{Nullable}} \texttt{x}; return \texttt{false} for all other \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> x = Nullable(1, false)
Nullable{Int64}()

julia> isnull(x)
true

julia> x = Nullable(1, true)
Nullable{Int64}(1)

julia> isnull(x)
false

julia> x = 1
1

julia> isnull(x)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L128-L155}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3572883435317165937}{} 
\hyperlink{3572883435317165937}{\texttt{Base.unsafe\_get}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_get(x)
\end{lstlisting}

Return the value of \texttt{x} for \hyperlink{2208920129454296646}{\texttt{Nullable}} \texttt{x}; return \texttt{x} for all other \texttt{x}.

This method does not check whether or not \texttt{x} is null before attempting to access the value of \texttt{x} for \texttt{x::Nullable} (hence {\textquotedbl}unsafe{\textquotedbl}).


\begin{minted}{jlcon}
julia> x = Nullable(1)
Nullable{Int64}(1)

julia> unsafe_get(x)
1

julia> x = Nullable{String}()
Nullable{String}()

julia> unsafe_get(x)
ERROR: UndefRefError: access to undefined reference
Stacktrace:
 [1] unsafe_get(::Nullable{String}) at ./nullable.jl:125

julia> x = 1
1

julia> unsafe_get(x)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L94-L124}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11616143092700767042}{}


\section{Sistema}


\hypertarget{18309243184998755104}{} 
\hyperlink{18309243184998755104}{\texttt{Base.run}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
run(command, args...)
\end{lstlisting}

Run a command object, constructed with backticks. Throws an error if anything goes wrong, including the process exiting with a non-zero status.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L643-L648}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16140521581008447772}{} 
\hyperlink{16140521581008447772}{\texttt{Base.spawn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
spawn(command)
\end{lstlisting}

Run a command object asynchronously, returning the resulting \texttt{Process} object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1519-L1523}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4360435189397200427}{} 
\hyperlink{4360435189397200427}{\texttt{Base.DevNull}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DevNull
\end{lstlisting}

Used in a stream redirect to discard all data written to it. Essentially equivalent to /dev/null on Unix or NUL on Windows. Usage:


\begin{minted}{julia}
run(pipeline(`cat test.txt`, DevNull))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L714-L723}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3068527349757478883}{} 
\hyperlink{3068527349757478883}{\texttt{Base.success}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
success(command)
\end{lstlisting}

Run a command object, constructed with backticks, and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L672-L677}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15578977278493337913}{} 
\hyperlink{15578977278493337913}{\texttt{Base.process\_running}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
process_running(p::Process)
\end{lstlisting}

Determine whether a process is currently running.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L728-L732}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13017420786720044448}{} 
\hyperlink{13017420786720044448}{\texttt{Base.process\_exited}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
process_exited(p::Process)
\end{lstlisting}

Determine whether a process has exited.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L737-L741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1615401929219773934}{} 
\hyperlink{1615401929219773934}{\texttt{Base.kill}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
kill(p::Process, signum=SIGTERM)
\end{lstlisting}

Send a signal to a process. The default is to terminate the process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L705-L709}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18437818836884264741}{} 
\hyperlink{18437818836884264741}{\texttt{Base.Sys.set\_process\_title}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.set_process_title(title::AbstractString)
\end{lstlisting}

Set the process title. No-op on some operating systems.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L181-L185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10090978748613293378}{} 
\hyperlink{10090978748613293378}{\texttt{Base.Sys.get\_process\_title}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.get_process_title()
\end{lstlisting}

Get the process title. On some systems, will always return an empty string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L169-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17772484058356229014}{} 
\hyperlink{17772484058356229014}{\texttt{Base.readandwrite}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readandwrite(command)
\end{lstlisting}

Starts running a command asynchronously, and returns a tuple (stdout,stdin,process) of the output stream and input stream of the process, and the process object itself.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L614-L619}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14924556434347277048}{} 
\hyperlink{14924556434347277048}{\texttt{Base.ignorestatus}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ignorestatus(command)
\end{lstlisting}

Mark a command object so that running it will not throw an error if the result code is non-zero.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L180-L184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3965292339357216921}{} 
\hyperlink{3965292339357216921}{\texttt{Base.detach}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
detach(command)
\end{lstlisting}

Mark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L189-L193}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10541952265148699805}{} 
\hyperlink{10541952265148699805}{\texttt{Base.Cmd}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)
\end{lstlisting}

Construct a new \texttt{Cmd} object, representing an external program and arguments, from \texttt{cmd}, while changing the settings of the optional keyword arguments:

\begin{itemize}
\item \texttt{ignorestatus::Bool}: If \texttt{true} (defaults to \texttt{false}), then the \texttt{Cmd} will not throw an error if the return code is nonzero.


\item \texttt{detach::Bool}: If \texttt{true} (defaults to \texttt{false}), then the \texttt{Cmd} will be run in a new process group, allowing it to outlive the \texttt{julia} process and not have Ctrl-C passed to it.


\item \texttt{windows\_verbatim::Bool}: If \texttt{true} (defaults to \texttt{false}), then on Windows the \texttt{Cmd} will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single {\textquotedbl}command-line{\textquotedbl} string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes \texttt{{\textquotedbl}} in the command line, and \texttt{{\textbackslash}} or \texttt{{\textquotedbl}} are preceded by backslashes. \texttt{windows\_verbatim=true} is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.


\item \texttt{windows\_hide::Bool}: If \texttt{true} (defaults to \texttt{false}), then on Windows no new console window is displayed when the \texttt{Cmd} is executed. This has no effect if a console is already open or on non-Windows systems.


\item \texttt{env}: Set environment variables to use when running the \texttt{Cmd}. \texttt{env} is either a dictionary mapping strings to strings, an array of strings of the form \texttt{{\textquotedbl}var=val{\textquotedbl}}, an array or tuple of \texttt{{\textquotedbl}var{\textquotedbl}=>val} pairs, or \texttt{nothing}. In order to modify (rather than replace) the existing environment, create \texttt{env} by \texttt{copy(ENV)} and then set \texttt{env[{\textquotedbl}var{\textquotedbl}]=val} as desired.


\item \texttt{dir::AbstractString}: Specify a working directory for the command (instead of the current directory).

\end{itemize}
For any keywords that are not specified, the current settings from \texttt{cmd} are used. Normally, to create a \texttt{Cmd} object in the first place, one uses backticks, e.g.


\begin{lstlisting}
Cmd(`echo "Hello world"`, ignorestatus=true, detach=false)
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L33-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14476048880059260855}{} 
\hyperlink{14476048880059260855}{\texttt{Base.setenv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setenv(command::Cmd, env; dir="")
\end{lstlisting}

Set environment variables to use when running the given \texttt{command}. \texttt{env} is either a dictionary mapping strings to strings, an array of strings of the form \texttt{{\textquotedbl}var=val{\textquotedbl}}, or zero or more \texttt{{\textquotedbl}var{\textquotedbl}=>val} pair arguments. In order to modify (rather than replace) the existing environment, create \texttt{env} by \texttt{copy(ENV)} and then setting \texttt{env[{\textquotedbl}var{\textquotedbl}]=val} as desired, or use \texttt{withenv}.

The \texttt{dir} keyword argument can be used to specify a working directory for the command.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L214-L224}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16080922180039851128}{} 
\hyperlink{16080922180039851128}{\texttt{Base.withenv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
withenv(f::Function, kv::Pair...)
\end{lstlisting}

Execute \texttt{f()} in an environment that is temporarily modified (not replaced as in \texttt{setenv}) by zero or more \texttt{{\textquotedbl}var{\textquotedbl}=>val} arguments \texttt{kv}. \texttt{withenv} is generally used via the \texttt{withenv(kv...) do ... end} syntax. A value of \texttt{nothing} can be used to temporarily unset an environment variable (if it is set). When \texttt{withenv} returns, the original environment has been restored.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/env.jl#L142-L150}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17710887576380723118}{} 
\hyperlink{17710887576380723118}{\texttt{Base.pipeline}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pipeline(from, to, ...)
\end{lstlisting}

Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other \texttt{pipeline} calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example \texttt{pipeline(a,b,c)} is equivalent to \texttt{pipeline(pipeline(a,b),c)}. This provides a more concise way to specify multi-stage pipelines.

\textbf{Examples}:


\begin{minted}{julia}
run(pipeline(`ls`, `grep xyz`))
run(pipeline(`ls`, "out.txt"))
run(pipeline("out.txt", `grep xyz`))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L283-L300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14749518171354514193}{} 
\hyperlink{14749518171354514193}{\texttt{Base.pipeline}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pipeline(command; stdin, stdout, stderr, append=false)
\end{lstlisting}

Redirect I/O to or from the given \texttt{command}. Keyword arguments specify which of the command{\textquotesingle}s streams should be redirected. \texttt{append} controls whether file output appends to the file. This is a more general version of the 2-argument \texttt{pipeline} function. \texttt{pipeline(from, to)} is equivalent to \texttt{pipeline(from, stdout=to)} when \texttt{from} is a command, and to \texttt{pipeline(to, stdin=from)} when \texttt{from} is another kind of data source.

\textbf{Examples}:


\begin{minted}{julia}
run(pipeline(`dothings`, stdout="out.txt", stderr="errs.txt"))
run(pipeline(`update`, stdout="log.txt", append=true))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L248-L263}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1938096715296079780}{} 
\hyperlink{1938096715296079780}{\texttt{Base.Libc.gethostname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gethostname() -> AbstractString
\end{lstlisting}

Get the local machine{\textquotesingle}s host name.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L236-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10073849928652659753}{} 
\hyperlink{10073849928652659753}{\texttt{Base.getipaddr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getipaddr() -> IPAddr
\end{lstlisting}

Get the IP address of the local machine.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L666-L670}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13507906219795618929}{} 
\hyperlink{13507906219795618929}{\texttt{Base.Libc.getpid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getpid() -> Int32
\end{lstlisting}

Get Julia{\textquotesingle}s process ID.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L227-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2441622941271736623}{} 
\hyperlink{2441622941271736623}{\texttt{Base.Libc.time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
time()
\end{lstlisting}

Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1926-L1930}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3638234932564609978}{} 
\hyperlink{3638234932564609978}{\texttt{Base.time\_ns}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
time_ns()
\end{lstlisting}

Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L9-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15143202356224875278}{} 
\hyperlink{15143202356224875278}{\texttt{Base.tic}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tic()
\end{lstlisting}

Set a timer to be read by the next call to \hyperlink{16488371574475401451}{\texttt{toc}} or \hyperlink{1910653784566466253}{\texttt{toq}}. The macro call \texttt{@time expr} can also be used to time evaluation.


\begin{minted}{jlcon}
julia> tic()
0x0000c45bc7abac95

julia> sleep(0.3)

julia> toc()
elapsed time: 0.302745944 seconds
0.302745944
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L79-L95}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16488371574475401451}{} 
\hyperlink{16488371574475401451}{\texttt{Base.toc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
toc()
\end{lstlisting}

Print and return the time elapsed since the last \hyperlink{15143202356224875278}{\texttt{tic}}. The macro call \texttt{@time expr} can also be used to time evaluation.


\begin{minted}{jlcon}
julia> tic()
0x0000c45bc7abac95

julia> sleep(0.3)

julia> toc()
elapsed time: 0.302745944 seconds
0.302745944
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L129-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1910653784566466253}{} 
\hyperlink{1910653784566466253}{\texttt{Base.toq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
toq()
\end{lstlisting}

Return, but do not print, the time elapsed since the last \hyperlink{15143202356224875278}{\texttt{tic}}. The macro calls \texttt{@timed expr} and \texttt{@elapsed expr} also return evaluation time.


\begin{minted}{jlcon}
julia> tic()
0x0000c46477a9675d

julia> sleep(0.3)

julia> toq()
0.302251004
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L102-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8029752041511656628}{} 
\hyperlink{8029752041511656628}{\texttt{Base.@time}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@time
\end{lstlisting}

A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression.

See also \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @time rand(10^6);
  0.001525 seconds (7 allocations: 7.630 MiB)

julia> @time begin
           sleep(0.3)
           1+1
       end
  0.301395 seconds (8 allocations: 336 bytes)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L212-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16435014226257034667}{} 
\hyperlink{16435014226257034667}{\texttt{Base.@timev}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@timev
\end{lstlisting}

This is a verbose version of the \texttt{@time} macro. It first prints the same information as \texttt{@time}, then any non-zero memory allocation counters, and then returns the value of the expression.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @timev rand(10^6);
  0.001006 seconds (7 allocations: 7.630 MiB)
elapsed time (ns): 1005567
bytes allocated:   8000256
pool allocs:       6
malloc() calls:    1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L246-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6506376105249440645}{} 
\hyperlink{6506376105249440645}{\texttt{Base.@timed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@timed
\end{lstlisting}

A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{13321256500037064321}{\texttt{@elapsed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> val, t, bytes, gctime, memallocs = @timed rand(10^6);

julia> t
0.006634834

julia> bytes
8000256

julia> gctime
0.0055765

julia> fieldnames(typeof(memallocs))
9-element Array{Symbol,1}:
 :allocd
 :malloc
 :realloc
 :poolalloc
 :bigalloc
 :freecall
 :total_time
 :pause
 :full_sweep

julia> memallocs.total_time
5576500
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L336-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13321256500037064321}{} 
\hyperlink{13321256500037064321}{\texttt{Base.@elapsed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@elapsed
\end{lstlisting}

A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, and \hyperlink{5377755456008435782}{\texttt{@allocated}}.


\begin{minted}{jlcon}
julia> @elapsed sleep(0.3)
0.301391426
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L276-L289}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5377755456008435782}{} 
\hyperlink{5377755456008435782}{\texttt{Base.@allocated}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@allocated
\end{lstlisting}

A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression. Note: the expression is evaluated inside a local function, instead of the current context, in order to eliminate the effects of compilation, however, there still may be some allocations due to JIT compilation. This also makes the results inconsistent with the \texttt{@time} macros, which do not try to adjust for the effects of compilation.

See also \hyperlink{8029752041511656628}{\texttt{@time}}, \hyperlink{16435014226257034667}{\texttt{@timev}}, \hyperlink{6506376105249440645}{\texttt{@timed}}, and \hyperlink{13321256500037064321}{\texttt{@elapsed}}.


\begin{minted}{jlcon}
julia> @allocated rand(10^6)
8000080
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L304-L321}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15720283866375224773}{} 
\hyperlink{15720283866375224773}{\texttt{Base.EnvHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
EnvHash() -> EnvHash
\end{lstlisting}

A singleton of this type provides a hash table interface to environment variables.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/env.jl#L61-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{196658496437650743}{} 
\hyperlink{196658496437650743}{\texttt{Base.ENV}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ENV
\end{lstlisting}

Reference to the singleton \texttt{EnvHash}, providing a dictionary interface to system environment variables.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/env.jl#L68-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7664224894560703317}{} 
\hyperlink{7664224894560703317}{\texttt{Base.is\_unix}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_unix([os])
\end{lstlisting}

Predicate for testing if the OS provides a Unix-like interface. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13038973210639903213}{} 
\hyperlink{13038973210639903213}{\texttt{Base.is\_apple}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_apple([os])
\end{lstlisting}

Predicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L43-L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10663187403531386839}{} 
\hyperlink{10663187403531386839}{\texttt{Base.is\_linux}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_linux([os])
\end{lstlisting}

Predicate for testing if the OS is a derivative of Linux. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L19-L24}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9955919844501906767}{} 
\hyperlink{9955919844501906767}{\texttt{Base.is\_bsd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_bsd([os])
\end{lstlisting}

Predicate for testing if the OS is a derivative of BSD. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L27-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14679690639893984598}{} 
\hyperlink{14679690639893984598}{\texttt{Base.is\_windows}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_windows([os])
\end{lstlisting}

Predicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation in \hyperlink{4478407192401635368}{Handling Operating System Variation}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L35-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17167896699654870190}{} 
\hyperlink{17167896699654870190}{\texttt{Base.Sys.windows\_version}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.windows_version()
\end{lstlisting}

Returns the version number for the Windows NT Kernel as a (major, minor) pair, or \texttt{(0, 0)} if this is not running on Windows.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L201-L206}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15508347639286112437}{} 
\hyperlink{15508347639286112437}{\texttt{Base.@static}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@static
\end{lstlisting}

Partially evaluates an expression at parse time.

For example, \texttt{@static is\_windows() ? foo : bar} will evaluate \texttt{is\_windows()} and insert either \texttt{foo} or \texttt{bar} into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a \texttt{ccall} to a non-existent function. \texttt{@static if is\_apple() foo end} and \texttt{@static foo <\&\&,||> bar} are also valid syntax.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/osutils.jl#L51-L60}{\texttt{source}}


\end{adjustwidth}

\hypertarget{16959204746128130100}{}


\section{Errores}


\hypertarget{17992125292605951734}{} 
\hyperlink{17992125292605951734}{\texttt{Base.error}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
error(message::AbstractString)
\end{lstlisting}

Raise an \texttt{ErrorException} with the given message.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1761-L1765}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16410366672587017456}{} 
\hyperlink{16410366672587017456}{\texttt{Core.throw}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
throw(e)
\end{lstlisting}

Throw an object as an exception.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2319-L2323}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2102349972401293064}{} 
\hyperlink{2102349972401293064}{\texttt{Base.rethrow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rethrow([e])
\end{lstlisting}

Throw an object without changing the current exception backtrace. The default argument is the current exception (if called within a \texttt{catch} block).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6187626674327343338}{} 
\hyperlink{6187626674327343338}{\texttt{Base.backtrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
backtrace()
\end{lstlisting}

Get a backtrace object for the current program point.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L41-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{98342946516168163}{} 
\hyperlink{98342946516168163}{\texttt{Base.catch\_backtrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
catch_backtrace()
\end{lstlisting}

Get the backtrace of the current exception, for use within \texttt{catch} blocks.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L48-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5092756097523818100}{} 
\hyperlink{5092756097523818100}{\texttt{Base.assert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
assert(cond)
\end{lstlisting}

Throw an \hyperlink{5674833187700802207}{\texttt{AssertionError}} if \texttt{cond} is \texttt{false}. Also available as the macro \texttt{@assert expr}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L182-L187}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4796942656392369899}{} 
\hyperlink{4796942656392369899}{\texttt{Base.@assert}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@assert cond [text]
\end{lstlisting}

Throw an \texttt{AssertionError} if \texttt{cond} is \texttt{false}. Preferred syntax for writing assertions. Message \texttt{text} is optionally displayed upon assertion failure.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1989-L1994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1600362634474051736}{} 
\hyperlink{1600362634474051736}{\texttt{Base.ArgumentError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ArgumentError(msg)
\end{lstlisting}

The parameters to a function call do not match a valid signature. Argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L27-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5674833187700802207}{} 
\hyperlink{5674833187700802207}{\texttt{Base.AssertionError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AssertionError([msg])
\end{lstlisting}

The asserted condition did not evaluate to \texttt{true}. Optional argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L79-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9731558909100893938}{} 
\hyperlink{9731558909100893938}{\texttt{Core.BoundsError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BoundsError([a],[i])
\end{lstlisting}

An indexing operation into an array, \texttt{a}, tried to access an out-of-bounds element, \texttt{i}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1136-L1140}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13752533629496758140}{} 
\hyperlink{13752533629496758140}{\texttt{Base.DimensionMismatch}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DimensionMismatch([msg])
\end{lstlisting}

The objects called do not have matching dimensionality. Optional argument \texttt{msg} is a descriptive error string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L68-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4168463413201806292}{} 
\hyperlink{4168463413201806292}{\texttt{Core.DivideError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DivideError()
\end{lstlisting}

Integer division was attempted with a denominator value of 0.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2661-L2665}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14085880504701688639}{} 
\hyperlink{14085880504701688639}{\texttt{Core.DomainError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DomainError()
\end{lstlisting}

The arguments to a function or constructor are outside the valid domain.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1623-L1627}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2683611566077490148}{} 
\hyperlink{2683611566077490148}{\texttt{Base.EOFError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
EOFError()
\end{lstlisting}

No more data was available to read from a file or stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L61-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12102596058483452470}{} 
\hyperlink{12102596058483452470}{\texttt{Core.ErrorException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ErrorException(msg)
\end{lstlisting}

Generic error type. The error message, in the \texttt{.msg} field, may provide more specific details.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L693-L697}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5399118524830636312}{} 
\hyperlink{5399118524830636312}{\texttt{Core.InexactError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
InexactError()
\end{lstlisting}

Type conversion cannot be done exactly.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1609-L1613}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11255134339055983338}{} 
\hyperlink{11255134339055983338}{\texttt{Core.InterruptException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
InterruptException()
\end{lstlisting}

The process was stopped by a terminal interrupt (CTRL+C).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2048-L2052}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12862287453053981792}{} 
\hyperlink{12862287453053981792}{\texttt{Base.KeyError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
KeyError(key)
\end{lstlisting}

An indexing operation into an \texttt{Associative} (\texttt{Dict}) or \texttt{Set} like object tried to access or delete a non-existent element.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L37-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{943337379161919670}{} 
\hyperlink{943337379161919670}{\texttt{Base.LoadError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LoadError(file::AbstractString, line::Int, error)
\end{lstlisting}

An error occurred while \texttt{include}ing, \texttt{require}ing, or \texttt{using} a file. The error specifics should be available in the \texttt{.error} field.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L95-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14644228586476494020}{} 
\hyperlink{14644228586476494020}{\texttt{Base.MethodError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
MethodError(f, args)
\end{lstlisting}

A method with the required type signature does not exist in the given generic function. Alternatively, there is no unique most-specific method.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L47-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3710635130313494548}{} 
\hyperlink{3710635130313494548}{\texttt{Base.NullException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
NullException()
\end{lstlisting}

An attempted access to a \hyperlink{2208920129454296646}{\texttt{Nullable}} with no defined value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2062-L2066}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9656432107553099418}{} 
\hyperlink{9656432107553099418}{\texttt{Core.OutOfMemoryError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
OutOfMemoryError()
\end{lstlisting}

An operation allocated too much memory for either the system or the garbage collector to handle properly.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1121-L1126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5617183776424836760}{} 
\hyperlink{5617183776424836760}{\texttt{Core.ReadOnlyMemoryError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ReadOnlyMemoryError()
\end{lstlisting}

An operation tried to write to memory that is read-only.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L357-L361}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10461069697702909970}{} 
\hyperlink{10461069697702909970}{\texttt{Core.OverflowError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
OverflowError()
\end{lstlisting}

The result of an expression is too large for the specified type and will cause a wraparound.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1822-L1826}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17891414672434519487}{} 
\hyperlink{17891414672434519487}{\texttt{Base.ParseError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ParseError(msg)
\end{lstlisting}

The expression passed to the \texttt{parse} function could not be interpreted as a valid Julia expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L17-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8063442678075539898}{} 
\hyperlink{8063442678075539898}{\texttt{Base.Distributed.ProcessExitedException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ProcessExitedException()
\end{lstlisting}

After a client Julia process has exited, further attempts to reference the dead child will throw this exception.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L815-L820}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10362102427170738683}{} 
\hyperlink{10362102427170738683}{\texttt{Core.StackOverflowError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
StackOverflowError()
\end{lstlisting}

The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1666-L1671}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16303515589950241655}{} 
\hyperlink{16303515589950241655}{\texttt{Base.SystemError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SystemError(prefix::AbstractString, [errno::Int32])
\end{lstlisting}

A system call failed with an error code (in the \texttt{errno} global variable).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2622693721821893139}{} 
\hyperlink{2622693721821893139}{\texttt{Core.TypeError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
TypeError(func::Symbol, context::AbstractString, expected::Type, got)
\end{lstlisting}

A type assertion failure, or calling an intrinsic function with an incorrect argument type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1902-L1906}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7764749529861419421}{} 
\hyperlink{7764749529861419421}{\texttt{Core.UndefRefError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UndefRefError()
\end{lstlisting}

The item or field is not defined for the given object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L749-L753}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4452889246677411554}{} 
\hyperlink{4452889246677411554}{\texttt{Core.UndefVarError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UndefVarError(var::Symbol)
\end{lstlisting}

A symbol in the current scope is not defined.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1775-L1779}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9529417803286937185}{} 
\hyperlink{9529417803286937185}{\texttt{Base.InitError}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
InitError(mod::Symbol, error)
\end{lstlisting}

An error occurred when running a module{\textquotesingle}s \texttt{\_\_init\_\_} function. The actual error thrown is available in the \texttt{.error} field.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base.jl#L107-L112}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13615447016541985376}{} 
\hyperlink{13615447016541985376}{\texttt{Base.retry}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
retry(f::Function;  delays=ExponentialBackOff(), check=nothing) -> Function
\end{lstlisting}

Returns an anonymous function that calls function \texttt{f}.  If an exception arises, \texttt{f} is repeatedly called again, each time \texttt{check} returns \texttt{true}, after waiting the number of seconds specified in \texttt{delays}.  \texttt{check} should input \texttt{delays}{\textquotesingle}s current state and the \texttt{Exception}.

\textbf{Examples}


\begin{minted}{julia}
retry(f, delays=fill(5.0, 3))
retry(f, delays=rand(5:10, 2))
retry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))
retry(http_get, check=(s,e)->e.status == "503")(url)
retry(read, check=(s,e)->isa(e, UVError))(io, 128; all=false)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L117-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5330798934113311579}{} 
\hyperlink{5330798934113311579}{\texttt{Base.ExponentialBackOff}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)
\end{lstlisting}

A \hyperlink{5027751419500983000}{\texttt{Float64}} iterator of length \texttt{n} whose elements exponentially increase at a rate in the interval \texttt{factor} * (1 ± \texttt{jitter}).  The first element is \texttt{first\_delay} and all elements are clamped to \texttt{max\_delay}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L98-L104}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7189567184193504348}{}


\section{Eventos}


\hypertarget{6898559495318758836}{} 
\hyperlink{6898559495318758836}{\texttt{Base.Timer}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Timer(callback::Function, delay, repeat=0)
\end{lstlisting}

Create a timer to call the given \texttt{callback} function. The \texttt{callback} is passed one argument, the timer object itself. The callback will be invoked after the specified initial \texttt{delay}, and then repeating with the given \texttt{repeat} interval. If \texttt{repeat} is \texttt{0}, the timer is only triggered once. Times are in seconds. A timer is stopped and has its resources freed by calling \hyperlink{5331333469799487255}{\texttt{close}} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L416-L424}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11288834678466677845}{} 
\hyperlink{11288834678466677845}{\texttt{Base.Timer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Timer(delay, repeat=0)
\end{lstlisting}

Create a timer that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the timer object) at a specified interval.  Times are in seconds.  Waiting tasks are woken with an error when the timer is closed (by \hyperlink{5331333469799487255}{\texttt{close}}. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether a timer is still active.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L316-L322}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6110056827764884232}{} 
\hyperlink{6110056827764884232}{\texttt{Base.AsyncCondition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AsyncCondition()
\end{lstlisting}

Create a async condition that wakes up tasks waiting for it (by calling \hyperlink{13761789780433862250}{\texttt{wait}} on the object) when notified from C by a call to \texttt{uv\_async\_send}. Waiting tasks are woken with an error when the object is closed (by \hyperlink{5331333469799487255}{\texttt{close}}. Use \hyperlink{12411519405593851135}{\texttt{isopen}} to check whether it is still active.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L259-L267}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11991658286161618588}{} 
\hyperlink{11991658286161618588}{\texttt{Base.AsyncCondition}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AsyncCondition(callback::Function)
\end{lstlisting}

Create a async condition that calls the given \texttt{callback} function. The \texttt{callback} is passed one argument, the async condition object itself.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L289-L294}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4885888444005292595}{}


\section{Reflexión}


\hypertarget{12295122498718682195}{} 
\hyperlink{12295122498718682195}{\texttt{Base.module\_name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
module_name(m::Module) -> Symbol
\end{lstlisting}

Get the name of a \texttt{Module} as a \texttt{Symbol}.


\begin{minted}{jlcon}
julia> module_name(Base.LinAlg)
:LinAlg
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L5-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17894080543604890899}{} 
\hyperlink{17894080543604890899}{\texttt{Base.module\_parent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
module_parent(m::Module) -> Module
\end{lstlisting}

Get a module{\textquotesingle}s enclosing \texttt{Module}. \texttt{Main} is its own parent, as is \texttt{LastMain} after \texttt{workspace()}.


\begin{minted}{jlcon}
julia> module_parent(Main)
Main

julia> module_parent(Base.LinAlg.BLAS)
Base.LinAlg
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L17-L29}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14046118357995428445}{} 
\hyperlink{14046118357995428445}{\texttt{Base.current\_module}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
current_module() -> Module
\end{lstlisting}

Get the \emph{dynamically} current \texttt{Module}, which is the \texttt{Module} code is currently being read from. In general, this is not the same as the module containing the call to this function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17712571889684451973}{} 
\hyperlink{17712571889684451973}{\texttt{Base.fullname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fullname(m::Module)
\end{lstlisting}

Get the fully-qualified name of a module as a tuple of symbols. For example,


\begin{minted}{jlcon}
julia> fullname(Base.Pkg)
(:Base, :Pkg)

julia> fullname(Main)
()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L40-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6473328671144201991}{} 
\hyperlink{6473328671144201991}{\texttt{Base.names}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
names(x::Module, all::Bool=false, imported::Bool=false)
\end{lstlisting}

Get an array of the names exported by a \texttt{Module}, excluding deprecated names. If \texttt{all} is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If \texttt{imported} is true, then names explicitly imported from other modules are also included.

As a special case, all names defined in \texttt{Main} are considered {\textquotedbl}exported{\textquotedbl}, since it is not idiomatic to explicitly export names from \texttt{Main}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L75-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4268493915558726264}{} 
\hyperlink{4268493915558726264}{\texttt{Core.nfields}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nfields(x::DataType) -> Int
\end{lstlisting}

Get the number of fields of a \texttt{DataType}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1698-L1702}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17481253338332315021}{} 
\hyperlink{17481253338332315021}{\texttt{Base.fieldnames}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fieldnames(x::DataType)
\end{lstlisting}

Get an array of the fields of a \texttt{DataType}.


\begin{minted}{jlcon}
julia> fieldnames(Hermitian)
2-element Array{Symbol,1}:
 :data
 :uplo
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L124-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3835503835621011695}{} 
\hyperlink{3835503835621011695}{\texttt{Base.fieldname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fieldname(x::DataType, i::Integer)
\end{lstlisting}

Get the name of field \texttt{i} of a \texttt{DataType}.


\begin{minted}{jlcon}
julia> fieldname(SparseMatrixCSC,1)
:m

julia> fieldname(SparseMatrixCSC,5)
:nzval
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L107-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5224737502013877598}{} 
\hyperlink{5224737502013877598}{\texttt{Base.datatype\_module}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.datatype_module(t::DataType) -> Module
\end{lstlisting}

Determine the module containing the definition of a \texttt{DataType}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L155-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5132196598270925116}{} 
\hyperlink{5132196598270925116}{\texttt{Base.datatype\_name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.datatype_name(t) -> Symbol
\end{lstlisting}

Get the name of a (potentially UnionAll-wrapped) \texttt{DataType} (without its parent module) as a symbol.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L147-L151}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15692280320547071693}{} 
\hyperlink{15692280320547071693}{\texttt{Base.isconst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isconst([m::Module], s::Symbol) -> Bool
\end{lstlisting}

Determine whether a global is declared \texttt{const} in a given \texttt{Module}. The default \texttt{Module} argument is \hyperlink{14046118357995428445}{\texttt{current\_module()}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L164-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6543026310027559438}{} 
\hyperlink{6543026310027559438}{\texttt{Base.function\_name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.function_name(f::Function) -> Symbol
\end{lstlisting}

Get the name of a generic \texttt{Function} as a symbol, or \texttt{:anonymous}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L856-L860}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15782281595582274098}{} 
\hyperlink{15782281595582274098}{\texttt{Base.function\_module}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.function_module(f::Function) -> Module
\end{lstlisting}

Determine the module containing the (first) definition of a generic function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L900-L905}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2162167294498760423}{} 
\hyperlink{2162167294498760423}{\texttt{Base.function\_module}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.function_module(f::Function, types) -> Module
\end{lstlisting}

Determine the module containing a given definition of a generic function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L908-L912}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4995931598335689542}{} 
\hyperlink{4995931598335689542}{\texttt{Base.functionloc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
functionloc(f::Function, types)
\end{lstlisting}

Returns a tuple \texttt{(filename,line)} giving the location of a generic \texttt{Function} definition.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L878-L882}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10700244958032489972}{} 
\hyperlink{10700244958032489972}{\texttt{Base.functionloc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
functionloc(m::Method)
\end{lstlisting}

Returns a tuple \texttt{(filename,line)} giving the location of a \texttt{Method} definition.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L865-L869}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9579246293212867177}{} 
\hyperlink{9579246293212867177}{\texttt{Base.@functionloc}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@functionloc
\end{lstlisting}

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple \texttt{(filename,line)} giving the location for the method that would be called for those arguments. It calls out to the \texttt{functionloc} function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L477-L483}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3385721083108370416}{}


\section{Interioridades}


\hypertarget{13037394137368605126}{} 
\hyperlink{13037394137368605126}{\texttt{Base.gc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gc()
\end{lstlisting}

Perform garbage collection. This should not generally be used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1782-L1786}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4474101916623001692}{} 
\hyperlink{4474101916623001692}{\texttt{Base.gc\_enable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gc_enable(on::Bool)
\end{lstlisting}

Control whether garbage collection is enabled using a boolean argument (\texttt{true} for enabled, \texttt{false} for disabled). Returns previous GC state. Disabling garbage collection should be used only with extreme caution, as it can cause memory use to grow without bound.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1806-L1812}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8018172489611994488}{} 
\hyperlink{8018172489611994488}{\texttt{Base.macroexpand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
macroexpand(x)
\end{lstlisting}

Takes the expression \texttt{x} and returns an equivalent expression with all macros removed (expanded).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L56-L60}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14913190777653949565}{} 
\hyperlink{14913190777653949565}{\texttt{Base.@macroexpand}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@macroexpand
\end{lstlisting}

Return equivalent expression with all macros removed (expanded).

There is a subtle difference between \texttt{@macroexpand} and \texttt{macroexpand} in that expansion takes place in different contexts. This is best seen in the following example:


\begin{minted}{jlcon}
julia> module M
           macro m()
               1
           end
           function f()
               (@macroexpand(@m), macroexpand(:(@m)))
           end
       end
M

julia> macro m()
           2
       end
@m (macro with 1 method)

julia> M.f()
(1, 2)
\end{minted}

With \texttt{@macroexpand} the expression expands where \texttt{@macroexpand} appears in the code (module \texttt{M} in the example). With \texttt{macroexpand} the expression expands in the current module where the code was finally called (REPL in the example). Note that when calling \texttt{macroexpand} or \texttt{@macroexpand} directly from the REPL, both of these contexts coincide, hence there is no difference.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L63-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14846157655101111909}{} 
\hyperlink{14846157655101111909}{\texttt{Base.expand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
expand(x)
\end{lstlisting}

Takes the expression \texttt{x} and returns an equivalent expression in lowered form. See also \hyperlink{18235967286596219009}{\texttt{code\_lowered}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/expr.jl#L48-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18235967286596219009}{} 
\hyperlink{18235967286596219009}{\texttt{Base.code\_lowered}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_lowered(f, types)
\end{lstlisting}

Returns an array of lowered ASTs for the methods matching the given generic function and type signature.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L479-L483}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10170271820987078660}{} 
\hyperlink{10170271820987078660}{\texttt{Base.@code\_lowered}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_lowered
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{18235967286596219009}{\texttt{code\_lowered}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L502-L507}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14801595959157535515}{} 
\hyperlink{14801595959157535515}{\texttt{Base.code\_typed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_typed(f, types; optimize=true)
\end{lstlisting}

Returns an array of lowered and type-inferred ASTs for the methods matching the given generic function and type signature. The keyword argument \texttt{optimize} controls whether additional optimizations, such as inlining, are also applied.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L766-L772}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12279119633919839581}{} 
\hyperlink{12279119633919839581}{\texttt{Base.@code\_typed}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_typed
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{14801595959157535515}{\texttt{code\_typed}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L486-L491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16883039507765569860}{} 
\hyperlink{16883039507765569860}{\texttt{Base.code\_warntype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_warntype([io::IO], f, types)
\end{lstlisting}

Prints lowered and type-inferred ASTs for the methods matching the given generic function and type signature to \texttt{io} which defaults to \texttt{STDOUT}. The ASTs are annotated in such a way as to cause {\textquotedbl}non-leaf{\textquotedbl} types to be emphasized (if color is available, displayed in red). This serves as a warning of potential type instability. Not all non-leaf types are particularly problematic for performance, so the results need to be used judiciously. See \hyperlink{7082991166860772411}{\texttt{@code\_warntype}} for more information.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L316-L325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7509450972834198661}{} 
\hyperlink{7509450972834198661}{\texttt{Base.@code\_warntype}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_warntype
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{16883039507765569860}{\texttt{code\_warntype}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L494-L499}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17587317969597936788}{} 
\hyperlink{17587317969597936788}{\texttt{Base.code\_llvm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_llvm([io], f, types)
\end{lstlisting}

Prints the LLVM bitcodes generated for running the method matching the given generic function and type signature to \texttt{io} which defaults to \texttt{STDOUT}.

All metadata and dbg.* calls are removed from the printed bitcode. Use code\_llvm\_raw for the full IR.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L732-L739}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4715999780877895760}{} 
\hyperlink{4715999780877895760}{\texttt{Base.@code\_llvm}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_llvm
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{17587317969597936788}{\texttt{code\_llvm}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L510-L515}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1731537926898979255}{} 
\hyperlink{1731537926898979255}{\texttt{Base.code\_native}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
code_native([io], f, types, [syntax])
\end{lstlisting}

Prints the native assembly instructions generated for running the method matching the given generic function and type signature to \texttt{io} which defaults to \texttt{STDOUT}. Switch assembly syntax using \texttt{syntax} symbol parameter set to \texttt{:att} for AT\&T syntax or \texttt{:intel} for Intel syntax. Output is AT\&T syntax by default.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reflection.jl#L745-L751}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2366615256687729425}{} 
\hyperlink{2366615256687729425}{\texttt{Base.@code\_native}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@code_native
\end{lstlisting}

Evaluates the arguments to the function or macro call, determines their types, and calls \hyperlink{1731537926898979255}{\texttt{code\_native}} on the resulting expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L518-L523}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11532354486541587545}{} 
\hyperlink{11532354486541587545}{\texttt{Base.precompile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
precompile(f,args::Tuple{Vararg{Any}})
\end{lstlisting}

Compile the given function \texttt{f} for the argument tuple (of types) \texttt{args}, but do not execute it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1404-L1408}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4056407506084571511}{}


\chapter{Colecciones y Estructuras de Datos}



\hypertarget{405296213558195800}{}


\section{Iteración}



La iteración secuencial es implementada por los métodos \hyperlink{1075601569170970796}{\texttt{start()}}, \hyperlink{6277510345882109527}{\texttt{done()}} y \hyperlink{11903630693622759236}{\texttt{next()}}. El bucle \texttt{for} general:




\begin{minted}{julia}
for i = I   # o  "for i in I"
    # cuerpo
end
\end{minted}



es traducido a:




\begin{minted}{julia}
state = start(I)
while !done(I, state)
    (i, state) = next(I, state)
    # cuerpo
end
\end{minted}



El objeto \texttt{state} puede ser cualquier cosa, y debería ser elegido apropiadamente para cada tipo iterable. Ver la \hyperlink{5510379658285713272}{sección del manual sobre la interfaz de iteración} para más detalles sobre definir un tipo iterable personalizado.


\hypertarget{1075601569170970796}{} 
\hyperlink{1075601569170970796}{\texttt{Base.start}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
start(iter) -> state
\end{lstlisting}

Get initial iteration state for an iterable object.

\textbf{Examples}


\begin{minted}{jlcon}
julia> start(1:5)
1

julia> start([1;2;3])
1

julia> start([4;2;3])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2119-L2135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6277510345882109527}{} 
\hyperlink{6277510345882109527}{\texttt{Base.done}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
done(iter, state) -> Bool
\end{lstlisting}

Test whether we are done iterating.

\textbf{Examples}


\begin{minted}{jlcon}
julia> done(1:5, 3)
false

julia> done(1:5, 5)
false

julia> done(1:5, 6)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2154-L2170}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11903630693622759236}{} 
\hyperlink{11903630693622759236}{\texttt{Base.next}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
next(iter, state) -> item, state
\end{lstlisting}

For a given iterable object and iteration state, return the current item and the next iteration state.

\textbf{Examples}


\begin{minted}{jlcon}
julia> next(1:5, 3)
(3, 4)

julia> next(1:5, 5)
(5, 6)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1098-L1111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14791729846404811261}{} 
\hyperlink{14791729846404811261}{\texttt{Base.iteratorsize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iteratorsize(itertype::Type) -> IteratorSize
\end{lstlisting}

Given the type of an iterator, returns one of the following values:

\begin{itemize}
\item \texttt{SizeUnknown()} if the length (number of elements) cannot be determined in advance.


\item \texttt{HasLength()} if there is a fixed, finite length.


\item \texttt{HasShape()} if there is a known length plus a notion of multidimensional shape (as for an array).  In this case the \hyperlink{17888996102305087038}{\texttt{size}} function is valid for the iterator.


\item \texttt{IsInfinite()} if the iterator yields values forever.

\end{itemize}
The default value (for iterators that do not define this function) is \texttt{HasLength()}. This means that most iterators are assumed to implement \hyperlink{3699181304419743826}{\texttt{length}}.

This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.


\begin{minted}{jlcon}
julia> Base.iteratorsize(1:5)
Base.HasShape()

julia> Base.iteratorsize((2,3))
Base.HasLength()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/generator.jl#L57-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10753302439396218154}{} 
\hyperlink{10753302439396218154}{\texttt{Base.iteratoreltype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iteratoreltype(itertype::Type) -> IteratorEltype
\end{lstlisting}

Given the type of an iterator, returns one of the following values:

\begin{itemize}
\item \texttt{EltypeUnknown()} if the type of elements yielded by the iterator is not known in advance.


\item \texttt{HasEltype()} if the element type is known, and \hyperlink{6396209842929672718}{\texttt{eltype}} would return a meaningful value.

\end{itemize}
\texttt{HasEltype()} is the default, since iterators are assumed to implement \hyperlink{6396209842929672718}{\texttt{eltype}}.

This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.


\begin{minted}{jlcon}
julia> Base.iteratoreltype(1:5)
Base.HasEltype()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/generator.jl#L89-L107}{\texttt{source}}


\end{adjustwidth}

Completamente implementada por:



\begin{itemize}
\item \texttt{Range}


\item \texttt{UnitRange}


\item \texttt{Tuple}


\item \texttt{Number}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \hyperlink{8428136537376557806}{\texttt{IntSet}}


\item \hyperlink{11235697656281157373}{\texttt{ObjectIdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{EachLine}


\item \texttt{AbstractString}


\item \hyperlink{1143189053501747033}{\texttt{Set}}

\end{itemize}


\hypertarget{12307698572459486963}{}


\section{Colecciones Generales}


\hypertarget{16079064795802595318}{} 
\hyperlink{16079064795802595318}{\texttt{Base.isempty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isempty(collection) -> Bool
\end{lstlisting}

Determine whether a collection is empty (has no elements).

\textbf{Examples}


\begin{minted}{jlcon}
julia> isempty([])
true

julia> isempty([1 2 3])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1586-L1599}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014622222736498057}{} 
\hyperlink{11014622222736498057}{\texttt{Base.empty!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
empty!(collection) -> collection
\end{lstlisting}

Remove all elements from a \texttt{collection}.


\begin{minted}{jlcon}
julia> A = Dict("a" => 1, "b" => 2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> empty!(A);

julia> A
Dict{String,Int64} with 0 entries
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L286-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4781133548011803693}{} 
\hyperlink{4781133548011803693}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
length(collection) -> Integer
\end{lstlisting}

For ordered, indexable collections, returns the maximum index \texttt{i} for which \texttt{getindex(collection, i)} is valid. For unordered collections, returns the number of elements.

\textbf{Examples}


\begin{minted}{jlcon}
julia> length(1:5)
5

julia> length([1; 2; 3; 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2008-L2023}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7288835006555308491}{} 
\hyperlink{7288835006555308491}{\texttt{Base.endof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
endof(collection) -> Integer
\end{lstlisting}

Returns the last index of the collection.

\textbf{Example}


\begin{minted}{jlcon}
julia> endof([1,2,4])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1085-L1095}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \texttt{Range}


\item \texttt{UnitRange}


\item \texttt{Tuple}


\item \texttt{Number}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \hyperlink{8428136537376557806}{\texttt{IntSet}}


\item \hyperlink{11235697656281157373}{\texttt{ObjectIdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{AbstractString}


\item \hyperlink{1143189053501747033}{\texttt{Set}}

\end{itemize}


\hypertarget{9478060066348011050}{}


\section{Colecciones Iterables}


\hypertarget{17277603976666670638}{} 
\hyperlink{17277603976666670638}{\texttt{Base.in}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
in(item, collection) -> Bool
∈(item,collection) -> Bool
∋(collection,item) -> Bool
∉(item,collection) -> Bool
∌(collection,item) -> Bool
\end{lstlisting}

Determine whether an item is in the given collection, in the sense that it is \texttt{==} to one of the values generated by iterating over the collection. Some collections need a slightly different definition; for example \hyperlink{1143189053501747033}{\texttt{Set}}s check whether the item \hyperlink{12829995639916057841}{\texttt{isequal}} to one of the elements. \hyperlink{3089397136845322041}{\texttt{Dict}}s look for \texttt{(key,value)} pairs, and the key is compared using \hyperlink{12829995639916057841}{\texttt{isequal}}. To test for the presence of a key in a dictionary, use \hyperlink{16178429961779994033}{\texttt{haskey}} or \texttt{k in keys(dict)}.


\begin{minted}{jlcon}
julia> a = 1:3:20
1:3:19

julia> 4 in a
true

julia> 5 in a
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L606-L630}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6396209842929672718}{} 
\hyperlink{6396209842929672718}{\texttt{Base.eltype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eltype(type)
\end{lstlisting}

Determine the type of the elements generated by iterating a collection of the given \texttt{type}. For associative collection types, this will be a \texttt{Pair\{KeyType,ValType\}}. The definition \texttt{eltype(x) = eltype(typeof(x))} is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.


\begin{minted}{jlcon}
julia> eltype(ones(Float32,2,2))
Float32

julia> eltype(ones(Int8,2,2))
Int8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L26-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16333903346703258373}{} 
\hyperlink{16333903346703258373}{\texttt{Base.indexin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indexin(a, b)
\end{lstlisting}

Returns a vector containing the highest index in \texttt{b} for each value in \texttt{a} that is a member of \texttt{b} . The output vector contains 0 wherever \texttt{a} is not a member of \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = ['a', 'b', 'c', 'b', 'd', 'a'];

julia> b = ['a','b','c'];

julia> indexin(a,b)
6-element Array{Int64,1}:
 1
 2
 3
 2
 0
 1

julia> indexin(b,a)
3-element Array{Int64,1}:
 6
 4
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1779-L1807}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17244150057565634576}{} 
\hyperlink{17244150057565634576}{\texttt{Base.findin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findin(a, b)
\end{lstlisting}

Returns the indices of elements in collection \texttt{a} that appear in collection \texttt{b}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = collect(1:3:15)
5-element Array{Int64,1}:
  1
  4
  7
 10
 13

julia> b = collect(2:4:10)
3-element Array{Int64,1}:
  2
  6
 10

julia> findin(a,b) # 10 is the only common element
1-element Array{Int64,1}:
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1813-L1838}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11470702940123921114}{} 
\hyperlink{11470702940123921114}{\texttt{Base.unique}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unique(itr)
\end{lstlisting}

Returns an array containing one value from \texttt{itr} for each unique value, as determined by \hyperlink{12829995639916057841}{\texttt{isequal}}.


\begin{minted}{jlcon}
julia> unique([1; 2; 2; 6])
3-element Array{Int64,1}:
 1
 2
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/set.jl#L115-L128}{\texttt{source}}



\begin{lstlisting}
unique(f, itr)
\end{lstlisting}

Returns an array containing one value from \texttt{itr} for each unique value produced by \texttt{f} applied to elements of \texttt{itr}.


\begin{minted}{jlcon}
julia> unique(isodd, [1; 2; 2; 6])
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/set.jl#L170-L182}{\texttt{source}}



\begin{lstlisting}
unique(itr[, dim])
\end{lstlisting}

Returns an array containing only the unique elements of the iterable \texttt{itr}, in the order that the first of each set of equivalent elements originally appears. If \texttt{dim} is specified, returns unique regions of the array \texttt{itr} along \texttt{dim}.


\begin{minted}{jlcon}
julia> A = map(isodd, reshape(collect(1:8), (2,2,2)))
2×2×2 Array{Bool,3}:
[:, :, 1] =
  true   true
 false  false

[:, :, 2] =
  true   true
 false  false

julia> unique(A)
2-element Array{Bool,1}:
  true
 false

julia> unique(A, 2)
2×1×2 Array{Bool,3}:
[:, :, 1] =
  true
 false

[:, :, 2] =
  true
 false

julia> unique(A, 3)
2×2×1 Array{Bool,3}:
[:, :, 1] =
  true   true
 false  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L1353-L1392}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7704267519153156361}{} 
\hyperlink{7704267519153156361}{\texttt{Base.allunique}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
allunique(itr) -> Bool
\end{lstlisting}

Return \texttt{true} if all values from \texttt{itr} are distinct when compared with \hyperlink{12829995639916057841}{\texttt{isequal}}.


\begin{minted}{jlcon}
julia> a = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> allunique([a, a])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/set.jl#L196-L211}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2662613255229698805}{} 
\hyperlink{2662613255229698805}{\texttt{Base.reduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reduce(op, v0, itr)
\end{lstlisting}

Reduce the given collection \texttt{ìtr} with the given binary operator \texttt{op}. \texttt{v0} must be a neutral element for \texttt{op} that will be returned for empty collections. It is unspecified whether \texttt{v0} is used for non-empty collections.

Reductions for certain commonly-used operators have special implementations which should be used instead: \texttt{maximum(itr)}, \texttt{minimum(itr)}, \texttt{sum(itr)}, \texttt{prod(itr)}, \texttt{any(itr)}, \texttt{all(itr)}.

The associativity of the reduction is implementation dependent. This means that you can{\textquotesingle}t use non-associative operations like \texttt{-} because it is undefined whether \texttt{reduce(-,[1,2,3])} should be evaluated as \texttt{(1-2)-3} or \texttt{1-(2-3)}. Use \hyperlink{10555237964956281648}{\texttt{foldl}} or \hyperlink{13997312259064792310}{\texttt{foldr}} instead for guaranteed left or right associativity.

Some operations accumulate error, and parallelism will also be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.

\textbf{Examples}


\begin{minted}{jlcon}
julia> reduce(*, 1, [2; 3; 4])
24
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L289-L315}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12844407765882691496}{} 
\hyperlink{12844407765882691496}{\texttt{Base.reduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reduce(op, itr)
\end{lstlisting}

Like \texttt{reduce(op, v0, itr)}. This cannot be used with empty collections, except for some special cases (e.g. when \texttt{op} is one of \texttt{+}, \texttt{*}, \texttt{max}, \texttt{min}, \texttt{\&}, \texttt{|}) when Julia can determine the neutral element of \texttt{op}.


\begin{minted}{jlcon}
julia> reduce(*, [2; 3; 4])
24
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L318-L329}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10555237964956281648}{} 
\hyperlink{10555237964956281648}{\texttt{Base.foldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foldl(op, v0, itr)
\end{lstlisting}

Like \hyperlink{2662613255229698805}{\texttt{reduce}}, but with guaranteed left associativity. \texttt{v0} will be used exactly once.


\begin{minted}{jlcon}
julia> foldl(-, 1, 2:5)
-13
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L76-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3612301023460122482}{} 
\hyperlink{3612301023460122482}{\texttt{Base.foldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foldl(op, itr)
\end{lstlisting}

Like \texttt{foldl(op, v0, itr)}, but using the first element of \texttt{itr} as \texttt{v0}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).


\begin{minted}{jlcon}
julia> foldl(-, 2:5)
-10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L89-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13997312259064792310}{} 
\hyperlink{13997312259064792310}{\texttt{Base.foldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foldr(op, v0, itr)
\end{lstlisting}

Like \hyperlink{2662613255229698805}{\texttt{reduce}}, but with guaranteed right associativity. \texttt{v0} will be used exactly once.


\begin{minted}{jlcon}
julia> foldr(-, 1, 2:5)
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L142-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4241312416601225037}{} 
\hyperlink{4241312416601225037}{\texttt{Base.foldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foldr(op, itr)
\end{lstlisting}

Like \texttt{foldr(op, v0, itr)}, but using the last element of \texttt{itr} as \texttt{v0}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).


\begin{minted}{jlcon}
julia> foldr(-, 2:5)
-2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L155-L165}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10566500735406837086}{} 
\hyperlink{10566500735406837086}{\texttt{Base.maximum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
maximum(itr)
\end{lstlisting}

Returns the largest element in a collection.


\begin{minted}{jlcon}
julia> maximum(-20.5:10)
9.5

julia> maximum([1,2,3])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L441-L453}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9034891716194434843}{} 
\hyperlink{9034891716194434843}{\texttt{Base.maximum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
maximum(A, dims)
\end{lstlisting}

Compute the maximum value of an array over the given dimensions. See also the \hyperlink{7839419811914289844}{\texttt{max(a,b)}} function to take the maximum of two or more arguments, which can be applied elementwise to arrays via \texttt{max.(a,b)}.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> maximum(A, 1)
1×2 Array{Int64,2}:
 3  4

julia> maximum(A, 2)
2×1 Array{Int64,2}:
 2
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L378-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8410756622363562035}{} 
\hyperlink{8410756622363562035}{\texttt{Base.maximum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
maximum!(r, A)
\end{lstlisting}

Compute the maximum value of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> maximum!([1; 1], A)
2-element Array{Int64,1}:
 2
 4

julia> maximum!([1 1], A)
1×2 Array{Int64,2}:
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L403-L424}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5463833925251886106}{} 
\hyperlink{5463833925251886106}{\texttt{Base.minimum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minimum(itr)
\end{lstlisting}

Returns the smallest element in a collection.


\begin{minted}{jlcon}
julia> minimum(-20.5:10)
-20.5

julia> minimum([1,2,3])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L456-L468}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3689019602970178455}{} 
\hyperlink{3689019602970178455}{\texttt{Base.minimum}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minimum(A, dims)
\end{lstlisting}

Compute the minimum value of an array over the given dimensions. See also the \hyperlink{7458766354532817148}{\texttt{min(a,b)}} function to take the minimum of two or more arguments, which can be applied elementwise to arrays via \texttt{min.(a,b)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> minimum(A, 1)
1×2 Array{Int64,2}:
 1  2

julia> minimum(A, 2)
2×1 Array{Int64,2}:
 1
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L427-L450}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15755225581375550665}{} 
\hyperlink{15755225581375550665}{\texttt{Base.minimum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minimum!(r, A)
\end{lstlisting}

Compute the minimum value of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> minimum!([1; 1], A)
2-element Array{Int64,1}:
 1
 3

julia> minimum!([1 1], A)
1×2 Array{Int64,2}:
 1  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L453-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3146721823766527688}{} 
\hyperlink{3146721823766527688}{\texttt{Base.extrema}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
extrema(itr) -> Tuple
\end{lstlisting}

Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.


\begin{minted}{jlcon}
julia> extrema(2:10)
(2, 10)

julia> extrema([9,pi,4.5])
(3.141592653589793, 9.0)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L476-L488}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3049658346780856618}{} 
\hyperlink{3049658346780856618}{\texttt{Base.extrema}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
extrema(A, dims) -> Array{Tuple}
\end{lstlisting}

Compute the minimum and maximum elements of an array over the given dimensions.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = reshape(collect(1:2:16), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  5
 3  7

[:, :, 2] =
  9  13
 11  15

julia> extrema(A, (1,2))
1×1×2 Array{Tuple{Int64,Int64},3}:
[:, :, 1] =
 (1, 7)

[:, :, 2] =
 (9, 15)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L1464-L1489}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9729163628056325681}{} 
\hyperlink{9729163628056325681}{\texttt{Base.indmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indmax(itr) -> Integer
\end{lstlisting}

Returns the index of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned. \texttt{NaN} values are ignored, unless all elements are \texttt{NaN}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> indmax([8,0.1,-9,pi])
1

julia> indmax([1,7,7,6])
2

julia> indmax([1,7,7,NaN])
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1732-L1752}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15078154128225819537}{} 
\hyperlink{15078154128225819537}{\texttt{Base.indmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indmin(itr) -> Integer
\end{lstlisting}

Returns the index of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned. \texttt{NaN} values are ignored, unless all elements are \texttt{NaN}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> indmin([8,0.1,-9,pi])
3

julia> indmin([7,1,1,6])
2

julia> indmin([7,1,1,NaN])
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1755-L1775}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13469499455756199806}{} 
\hyperlink{13469499455756199806}{\texttt{Base.findmax}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmax(itr) -> (x, index)
\end{lstlisting}

Returns the maximum element of the collection \texttt{itr} and its index. If there are multiple maximal elements, then the first one will be returned. \texttt{NaN} values are ignored, unless all elements are \texttt{NaN}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findmax([8,0.1,-9,pi])
(8.0, 1)

julia> findmax([1,7,7,6])
(7, 2)

julia> findmax([1,7,7,NaN])
(7.0, 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1654-L1674}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13261215783822577177}{} 
\hyperlink{13261215783822577177}{\texttt{Base.findmax}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmax(A, region) -> (maxval, index)
\end{lstlisting}

For an array input, returns the value and index of the maximum over the given region.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> findmax(A,1)
([3 4], [2 4])

julia> findmax(A,2)
([2; 4], [3; 4])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L687-L705}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11896407635566615538}{} 
\hyperlink{11896407635566615538}{\texttt{Base.findmin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmin(itr) -> (x, index)
\end{lstlisting}

Returns the minimum element of the collection \texttt{itr} and its index. If there are multiple minimal elements, then the first one will be returned. \texttt{NaN} values are ignored, unless all elements are \texttt{NaN}.

The collection must not be empty.

\textbf{Examples}


\begin{minted}{jlcon}
julia> findmin([8,0.1,-9,pi])
(-9.0, 3)

julia> findmin([7,1,1,6])
(1, 2)

julia> findmin([7,1,1,NaN])
(1.0, 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1693-L1713}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17274328252977351321}{} 
\hyperlink{17274328252977351321}{\texttt{Base.findmin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmin(A, region) -> (minval, index)
\end{lstlisting}

For an array input, returns the value and index of the minimum over the given region.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> findmin(A, 1)
([1 2], [1 3])

julia> findmin(A, 2)
([1; 3], [1; 2])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L648-L666}{\texttt{source}}


\end{adjustwidth}
\hypertarget{585571988055972211}{} 
\hyperlink{585571988055972211}{\texttt{Base.findmax!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmax!(rval, rind, A, [init=true]) -> (maxval, index)
\end{lstlisting}

Find the maximum of \texttt{A} and the corresponding linear index along singleton dimensions of \texttt{rval} and \texttt{rind}, and store the results in \texttt{rval} and \texttt{rind}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L676-L681}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6616116230203866531}{} 
\hyperlink{6616116230203866531}{\texttt{Base.findmin!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findmin!(rval, rind, A, [init=true]) -> (minval, index)
\end{lstlisting}

Find the minimum of \texttt{A} and the corresponding linear index along singleton dimensions of \texttt{rval} and \texttt{rind}, and store the results in \texttt{rval} and \texttt{rind}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L637-L642}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8666686648688281595}{} 
\hyperlink{8666686648688281595}{\texttt{Base.sum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sum(f, itr)
\end{lstlisting}

Sum the results of calling function \texttt{f} on each element of \texttt{itr}.


\begin{minted}{jlcon}
julia> sum(abs2, [2; 3; 4])
29
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L337-L346}{\texttt{source}}



\begin{lstlisting}
sum(itr)
\end{lstlisting}

Returns the sum of all elements in a collection.


\begin{minted}{jlcon}
julia> sum(1:20)
210
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L349-L358}{\texttt{source}}



\begin{lstlisting}
sum(A, dims)
\end{lstlisting}

Sum elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> sum(A, 1)
1×2 Array{Int64,2}:
 4  6

julia> sum(A, 2)
2×1 Array{Int64,2}:
 3
 7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L282-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6277092149981507138}{} 
\hyperlink{6277092149981507138}{\texttt{Base.sum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sum!(r, A)
\end{lstlisting}

Sum elements of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> sum!([1; 1], A)
2-element Array{Int64,1}:
 3
 7

julia> sum!([1 1], A)
1×2 Array{Int64,2}:
 4  6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L306-L327}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13484084847910116333}{} 
\hyperlink{13484084847910116333}{\texttt{Base.prod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prod(f, itr)
\end{lstlisting}

Returns the product of \texttt{f} applied to each element of \texttt{itr}.


\begin{minted}{jlcon}
julia> prod(abs2, [2; 3; 4])
576
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L395-L404}{\texttt{source}}



\begin{lstlisting}
prod(itr)
\end{lstlisting}

Returns the product of all elements of a collection.


\begin{minted}{jlcon}
julia> prod(1:20)
2432902008176640000
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L407-L416}{\texttt{source}}



\begin{lstlisting}
prod(A, dims)
\end{lstlisting}

Multiply elements of an array over the given dimensions.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> prod(A, 1)
1×2 Array{Int64,2}:
 3  8

julia> prod(A, 2)
2×1 Array{Int64,2}:
  2
 12
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L330-L351}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15969471860599880580}{} 
\hyperlink{15969471860599880580}{\texttt{Base.prod!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prod!(r, A)
\end{lstlisting}

Multiply elements of \texttt{A} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> prod!([1; 1], A)
2-element Array{Int64,1}:
  2
 12

julia> prod!([1 1], A)
1×2 Array{Int64,2}:
 3  8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L354-L375}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14612039032155203548}{} 
\hyperlink{14612039032155203548}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
any(itr) -> Bool
\end{lstlisting}

Test whether any elements of a boolean collection are \texttt{true}, returning \texttt{true} as soon as the first \texttt{true} value in \texttt{itr} is encountered (short-circuiting).


\begin{minted}{jlcon}
julia> a = [true,false,false,true]
4-element Array{Bool,1}:
  true
 false
 false
  true

julia> any(a)
true

julia> any((println(i); v) for (i, v) in enumerate(a))
1
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L504-L525}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13269987351988461926}{} 
\hyperlink{13269987351988461926}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
any(A, dims)
\end{lstlisting}

Test whether any values along the given dimensions of an array are \texttt{true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia> any(A, 1)
1×2 Array{Bool,2}:
 true  false

julia> any(A, 2)
2×1 Array{Bool,2}:
 true
 true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L525-L546}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8281403281900865383}{} 
\hyperlink{8281403281900865383}{\texttt{Base.any!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
any!(r, A)
\end{lstlisting}

Test whether any values in \texttt{A} along the singleton dimensions of \texttt{r} are \texttt{true}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia> any!([1; 1], A)
2-element Array{Int64,1}:
 1
 1

julia> any!([1 1], A)
1×2 Array{Int64,2}:
 1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L549-L571}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7942004983516218646}{} 
\hyperlink{7942004983516218646}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
all(itr) -> Bool
\end{lstlisting}

Test whether all elements of a boolean collection are \texttt{true}, returning \texttt{false} as soon as the first \texttt{false} value in \texttt{itr} is encountered (short-circuiting).


\begin{minted}{jlcon}
julia> a = [true,false,false,true]
4-element Array{Bool,1}:
  true
 false
 false
  true

julia> all(a)
false

julia> all((println(i); v) for (i, v) in enumerate(a))
1
2
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L528-L550}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2312198897330859084}{} 
\hyperlink{2312198897330859084}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
all(A, dims)
\end{lstlisting}

Test whether all values along the given dimensions of an array are \texttt{true}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true true]
2×2 Array{Bool,2}:
 true  false
 true   true

julia> all(A, 1)
1×2 Array{Bool,2}:
 true  false

julia> all(A, 2)
2×1 Array{Bool,2}:
 false
  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L477-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1382810654686121973}{} 
\hyperlink{1382810654686121973}{\texttt{Base.all!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
all!(r, A)
\end{lstlisting}

Test whether all values in \texttt{A} along the singleton dimensions of \texttt{r} are \texttt{true}, and write results to \texttt{r}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia> all!([1; 1], A)
2-element Array{Int64,1}:
 0
 0

julia> all!([1 1], A)
1×2 Array{Int64,2}:
 1  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L501-L522}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4123799324867706690}{} 
\hyperlink{4123799324867706690}{\texttt{Base.count}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
count(p, itr) -> Integer
count(itr) -> Integer
\end{lstlisting}

Count the number of elements in \texttt{itr} for which predicate \texttt{p} returns \texttt{true}. If \texttt{p} is omitted, counts the number of \texttt{true} elements in \texttt{itr} (which should be a collection of boolean values).


\begin{minted}{jlcon}
julia> count(i->(4<=i<=6), [2,3,4,5,6])
3

julia> count([true, false, true, true])
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L673-L688}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5656508174326485968}{} 
\hyperlink{5656508174326485968}{\texttt{Base.any}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
any(p, itr) -> Bool
\end{lstlisting}

Determine whether predicate \texttt{p} returns \texttt{true} for any elements of \texttt{itr}, returning \texttt{true} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{true} is encountered (short-circuiting).


\begin{minted}{jlcon}
julia> any(i->(4<=i<=6), [3,5,7])
true

julia> any(i -> (println(i); i > 3), 1:10)
1
2
3
4
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L553-L571}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8835516150928560592}{} 
\hyperlink{8835516150928560592}{\texttt{Base.all}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
all(p, itr) -> Bool
\end{lstlisting}

Determine whether predicate \texttt{p} returns \texttt{true} for all elements of \texttt{itr}, returning \texttt{false} as soon as the first item in \texttt{itr} for which \texttt{p} returns \texttt{false} is encountered (short-circuiting).


\begin{minted}{jlcon}
julia> all(i->(4<=i<=6), [4,5,6])
true

julia> all(i -> (println(i); i < 3), 1:10)
1
2
3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L579-L596}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8999415072542722396}{} 
\hyperlink{8999415072542722396}{\texttt{Base.foreach}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
foreach(f, c...) -> Void
\end{lstlisting}

Call function \texttt{f} on each element of iterable \texttt{c}. For multiple iterable arguments, \texttt{f} is called elementwise. \texttt{foreach} should be used instead of \texttt{map} when the results of \texttt{f} are not needed, for example in \texttt{foreach(println, array)}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1:3:7;

julia> foreach(x -> println(x^2), a)
1
16
49
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1714-L1731}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11483231213869150535}{} 
\hyperlink{11483231213869150535}{\texttt{Base.map}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
map(f, c...) -> collection
\end{lstlisting}

Transform collection \texttt{c} by applying \texttt{f} to each element. For multiple collection arguments, apply \texttt{f} elementwise.

\textbf{Examples}


\begin{minted}{jlcon}
julia> map(x -> x * 2, [1, 2, 3])
3-element Array{Int64,1}:
 2
 4
 6

julia> map(+, [1, 2, 3], [10, 20, 30])
3-element Array{Int64,1}:
 11
 22
 33
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1871-L1891}{\texttt{source}}



\begin{lstlisting}
map(f, x::Nullable)
\end{lstlisting}

Return \texttt{f} applied to the value of \texttt{x} if it has one, as a \texttt{Nullable}. If \texttt{x} is null, then return a null value of type \texttt{Nullable\{S\}}. \texttt{S} is guaranteed to be either \texttt{Union\{\}} or a concrete type. Whichever of these is chosen is an implementation detail, but typically the choice that maximizes performance would be used. If \texttt{x} has a value, then the return type is guaranteed to be of type \texttt{Nullable\{typeof(f(x))\}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L270-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11037843636480523134}{} 
\hyperlink{11037843636480523134}{\texttt{Base.map!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
map!(function, destination, collection...)
\end{lstlisting}

Like \hyperlink{11483231213869150535}{\texttt{map}}, but stores the result in \texttt{destination} rather than a new collection. \texttt{destination} must be at least as large as the first collection.

\textbf{Example}


\begin{minted}{jlcon}
julia> x = zeros(3);

julia> map!(x -> x * 2, x, [1, 2, 3]);

julia> x
3-element Array{Float64,1}:
 2.0
 4.0
 6.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1914-L1932}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7665709493711303537}{} 
\hyperlink{7665709493711303537}{\texttt{Base.mapreduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapreduce(f, op, v0, itr)
\end{lstlisting}

Apply function \texttt{f} to each element in \texttt{itr}, and then reduce the result using the binary function \texttt{op}. \texttt{v0} must be a neutral element for \texttt{op} that will be returned for empty collections. It is unspecified whether \texttt{v0} is used for non-empty collections.

\hyperlink{7665709493711303537}{\texttt{mapreduce}} is functionally equivalent to calling \texttt{reduce(op, v0, map(f, itr))}, but will in general execute faster since no intermediate collection needs to be created. See documentation for \hyperlink{2662613255229698805}{\texttt{reduce}} and \hyperlink{11483231213869150535}{\texttt{map}}.


\begin{minted}{jlcon}
julia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9
14
\end{minted}

The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of \texttt{f} for elements that appear multiple times in \texttt{itr}. Use \hyperlink{7201860476364147871}{\texttt{mapfoldl}} or \hyperlink{13917513354174607167}{\texttt{mapfoldr}} instead for guaranteed left or right associativity and invocation of \texttt{f} for every value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L208-L228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10927609949347955937}{} 
\hyperlink{10927609949347955937}{\texttt{Base.mapreduce}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapreduce(f, op, itr)
\end{lstlisting}

Like \texttt{mapreduce(f, op, v0, itr)}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L200-L205}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7201860476364147871}{} 
\hyperlink{7201860476364147871}{\texttt{Base.mapfoldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapfoldl(f, op, v0, itr)
\end{lstlisting}

Like \hyperlink{7665709493711303537}{\texttt{mapreduce}}, but with guaranteed left associativity, as in \hyperlink{10555237964956281648}{\texttt{foldl}}. \texttt{v0} will be used exactly once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L52-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14886875186313200647}{} 
\hyperlink{14886875186313200647}{\texttt{Base.mapfoldl}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapfoldl(f, op, itr)
\end{lstlisting}

Like \texttt{mapfoldl(f, op, v0, itr)}, but using the first element of \texttt{itr} as \texttt{v0}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L60-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13917513354174607167}{} 
\hyperlink{13917513354174607167}{\texttt{Base.mapfoldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapfoldr(f, op, v0, itr)
\end{lstlisting}

Like \hyperlink{7665709493711303537}{\texttt{mapreduce}}, but with guaranteed right associativity, as in \hyperlink{13997312259064792310}{\texttt{foldr}}. \texttt{v0} will be used exactly once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L120-L125}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14828426243224858846}{} 
\hyperlink{14828426243224858846}{\texttt{Base.mapfoldr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapfoldr(f, op, itr)
\end{lstlisting}

Like \texttt{mapfoldr(f, op, v0, itr)}, but using the first element of \texttt{itr} as \texttt{v0}. In general, this cannot be used with empty collections (see \texttt{reduce(op, itr)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L128-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10301663699427216331}{} 
\hyperlink{10301663699427216331}{\texttt{Base.first}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
first(coll)
\end{lstlisting}

Get the first element of an iterable collection. Returns the start point of a \texttt{Range} even if it is empty.


\begin{minted}{jlcon}
julia> first(2:2:10)
2

julia> first([1; 2; 3; 4])
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L137-L150}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7482613677577278193}{} 
\hyperlink{7482613677577278193}{\texttt{Base.last}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
last(coll)
\end{lstlisting}

Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling \hyperlink{7288835006555308491}{\texttt{endof}} to get the last index. Returns the end point of a \texttt{Range} even if it is empty.


\begin{minted}{jlcon}
julia> last(1:2:10)
9

julia> last([1; 2; 3; 4])
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L157-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6276843274198881822}{} 
\hyperlink{6276843274198881822}{\texttt{Base.step}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
step(r)
\end{lstlisting}

Get the step size of a \texttt{Range} object.


\begin{minted}{jlcon}
julia> step(1:10)
1

julia> step(1:2:10)
2

julia> step(2.5:0.3:10.9)
0.3

julia> step(linspace(2.5,10.9,85))
0.1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L343-L360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6278865767444641812}{} 
\hyperlink{6278865767444641812}{\texttt{Base.collect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
collect(collection)
\end{lstlisting}

Return an \texttt{Array} of all items in a collection or iterator. For associative collections, returns \texttt{Pair\{KeyType, ValType\}}. If the argument is array-like or is an iterator with the \texttt{HasShape()} trait, the result will have the same shape and number of dimensions as the argument.

\textbf{Example}


\begin{minted}{jlcon}
julia> collect(1:2:13)
7-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11
 13
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L411-L430}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3539644528130741625}{} 
\hyperlink{3539644528130741625}{\texttt{Base.collect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
collect(element_type, collection)
\end{lstlisting}

Return an \texttt{Array} with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as \texttt{collection}.


\begin{minted}{jlcon}
julia> collect(Float64, 1:2:5)
3-element Array{Float64,1}:
 1.0
 3.0
 5.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L379-L392}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4941392674716223104}{} 
\hyperlink{4941392674716223104}{\texttt{Base.issubset}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issubset(a, b)
⊆(a,b) -> Bool
⊈(a,b) -> Bool
⊊(a,b) -> Bool
\end{lstlisting}

Determine whether every element of \texttt{a} is also in \texttt{b}, using \hyperlink{17277603976666670638}{\texttt{in}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issubset([1, 2], [1, 2, 3])
true

julia> issubset([1, 2, 3], [1, 2])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2326-L2342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11445961893478569145}{} 
\hyperlink{11445961893478569145}{\texttt{Base.filter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filter(function, collection)
\end{lstlisting}

Return a copy of \texttt{collection}, removing elements for which \texttt{function} is \texttt{false}. For associative collections, the function is passed two arguments (key and value).

\textbf{Examples}


\begin{lstlisting}
julia> a = 1:10
1:10

julia> filter(isodd, a)
5-element Array{Int64,1}:
 1
 3
 5
 7
 9

julia> d = Dict(1=>"a", 2=>"b")
Dict{Int64,String} with 2 entries:
  2 => "b"
  1 => "a"

julia> filter((x,y)->isodd(x), d)
Dict{Int64,String} with 1 entry:
  1 => "a"
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1874-L1902}{\texttt{source}}



\begin{lstlisting}
filter(p, x::Nullable)
\end{lstlisting}

Return null if either \texttt{x} is null or \texttt{p(get(x))} is false, and \texttt{x} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L251-L255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3384092630307389071}{} 
\hyperlink{3384092630307389071}{\texttt{Base.filter!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filter!(function, collection)
\end{lstlisting}

Update \texttt{collection}, removing elements for which \texttt{function} is \texttt{false}. For associative collections, the function is passed two arguments (key and value).

\textbf{Example}


\begin{minted}{jlcon}
julia> filter!(isodd, collect(1:10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L313-L329}{\texttt{source}}


\end{adjustwidth}

\hypertarget{994871259414187011}{}


\section{Colecciones Indexables}


\hypertarget{13252273446470485800}{} 
\hyperlink{13252273446470485800}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getindex(collection, key...)
\end{lstlisting}

Retrieve the value(s) stored at the given key or index within a collection. The syntax \texttt{a[i,j,...]} is converted by the compiler to \texttt{getindex(a, i, j, ...)}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = Dict("a" => 1, "b" => 2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> getindex(A, "a")
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L150-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17628459644208174650}{} 
\hyperlink{17628459644208174650}{\texttt{Base.setindex!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setindex!(collection, value, key...)
\end{lstlisting}

Store the given value at the given key or index within a collection. The syntax \texttt{a[i,j,...] = x} is converted by the compiler to \texttt{(setindex!(a, x, i, j, ...); x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2295-L2300}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \hyperlink{15492651498431872487}{\texttt{Array}}


\item \hyperlink{18015155802543401629}{\texttt{BitArray}}


\item \hyperlink{6514416309183787338}{\texttt{AbstractArray}}


\item \texttt{SubArray}


\item \hyperlink{11235697656281157373}{\texttt{ObjectIdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}


\item \texttt{AbstractString}

\end{itemize}


Parcialmente implementado por:



\begin{itemize}
\item \texttt{Range}


\item \texttt{UnitRange}


\item \texttt{Tuple}

\end{itemize}


\hypertarget{719388353867456603}{}


\section{Colecciones Asociativas}



\hyperlink{3089397136845322041}{\texttt{Dict}} es la colección asociativa estándar. Su implementación usa \hyperlink{13797072367283572032}{\texttt{hash()}} como función de hashing para la clave, e \hyperlink{12829995639916057841}{\texttt{isequal()}} para determinar la igualdad. Si redefine estas dos funciones en un tipo personalizado, sobreescribirán cómo se almacenan dichos tipos en una tabla hash.



\hyperlink{11235697656281157373}{\texttt{ObjectIdDict}} es una tabla hash especial donde las claves son siempre identidades de objeto.



\hyperlink{17958922440222792850}{\texttt{WeakKeyDict}} es una implementación de tabla hash donde las claves son referencias débiles a los objetos y, por lo tanto, permiten recolección de basura recogida incluso cuando se referencian en una tabla hash.



\hyperlink{3089397136845322041}{\texttt{Dict}}s se pueden crear pasando pares de objetos construidos con \texttt{=>()} a un constructor \hyperlink{3089397136845322041}{\texttt{Dict}}: \texttt{Dict ({\textquotedbl}A{\textquotedbl}=> 1,{\textquotedbl} B {\textquotedbl}=> 2)}. Esta llamada intentará inferir información sobre el tipo de las claves y los valores (es decir, este ejemplo crea un \texttt{Dict\{String, Int64\}}). Para especificar los tipos explícitamente, use la sintaxis \texttt{Dict\{KeyType,ValueType\}(...)}. Por ejemplo, \texttt{Dict\{String,Int32\}({\textquotedbl} A {\textquotedbl}=> 1,{\textquotedbl} B {\textquotedbl}=> 2)}.



Las colecciones asociativas también pueden ser creadas con generadores. Por ejemplo, \texttt{Dict(i => f(i) for i = 1:10)}.



Dado un diccionario \texttt{D}, la sintaxis \texttt{D[x]} devuelve el valor de la clave \texttt{x} (si existe) o arroja un error, y \texttt{D[x] = y} almacena el par de clave-valor \texttt{x => y} en \texttt{D} (reemplazando cualquier valor existente para la clave\texttt{x}). Múltiples argumentos para \texttt{D [...]} se convierten a tuplas; por ejemplo, la sintaxis \texttt{D[x,y]} es equivalente a \texttt{D[(x,y)]}, es decir, se refiere al valor introducido para la tupla \texttt{(x,y)}.


\hypertarget{3089397136845322041}{} 
\hyperlink{3089397136845322041}{\texttt{Base.Dict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Dict([itr])
\end{lstlisting}

\texttt{Dict\{K,V\}()} constructs a hash table with keys of type \texttt{K} and values of type \texttt{V}.

Given a single iterable argument, constructs a \hyperlink{3089397136845322041}{\texttt{Dict}} whose key-value pairs are taken from 2-tuples \texttt{(key,value)} generated by the argument.


\begin{minted}{jlcon}
julia> Dict([("A", 1), ("B", 2)])
Dict{String,Int64} with 2 entries:
  "B" => 2
  "A" => 1
\end{minted}

Alternatively, a sequence of pair arguments may be passed.


\begin{minted}{jlcon}
julia> Dict("A"=>1, "B"=>2)
Dict{String,Int64} with 2 entries:
  "B" => 2
  "A" => 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L68-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11235697656281157373}{} 
\hyperlink{11235697656281157373}{\texttt{Base.ObjectIdDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ObjectIdDict([itr])
\end{lstlisting}

\texttt{ObjectIdDict()} constructs a hash table where the keys are (always) object identities.  Unlike \texttt{Dict} it is not parameterized on its key and value type and thus its \texttt{eltype} is always \texttt{Pair\{Any,Any\}}.

See \hyperlink{3089397136845322041}{\texttt{Dict}} for further help.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L379-L387}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17958922440222792850}{} 
\hyperlink{17958922440222792850}{\texttt{Base.WeakKeyDict}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
WeakKeyDict([itr])
\end{lstlisting}

\texttt{WeakKeyDict()} constructs a hash table where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.

See \hyperlink{3089397136845322041}{\texttt{Dict}} for further help.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/weakkeydict.jl#L5-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16178429961779994033}{} 
\hyperlink{16178429961779994033}{\texttt{Base.haskey}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
haskey(collection, key) -> Bool
\end{lstlisting}

Determine whether a collection has a mapping for a given key.


\begin{minted}{jlcon}
julia> a = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'b' => 3
  'a' => 2

julia> haskey(a,'a')
true

julia> haskey(a,'c')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L487-L504}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1600067245044904172}{} 
\hyperlink{1600067245044904172}{\texttt{Base.get}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get(collection, key, default)
\end{lstlisting}

Return the value stored for the given key, or the given default value if no mapping for the key is present.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2);

julia> get(d, "a", 3)
1

julia> get(d, "c", 3)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1418-L1434}{\texttt{source}}


\end{adjustwidth}
\hypertarget{282460992333585641}{} 
\hyperlink{282460992333585641}{\texttt{Base.get}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get(f::Function, collection, key)
\end{lstlisting}

Return the value stored for the given key, or if no mapping for the key is present, return \texttt{f()}.  Use \hyperlink{1533836558345014565}{\texttt{get!}} to also store the default value in the dictionary.

This is intended to be called using \texttt{do} block syntax


\begin{minted}{julia}
get(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1437-L1451}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1533836558345014565}{} 
\hyperlink{1533836558345014565}{\texttt{Base.get!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get!(collection, key, default)
\end{lstlisting}

Return the value stored for the given key, or if no mapping for the key is present, store \texttt{key => default}, and return \texttt{default}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> get!(d, "a", 5)
1

julia> get!(d, "d", 4)
4

julia> d
Dict{String,Int64} with 4 entries:
  "c" => 3
  "b" => 2
  "a" => 1
  "d" => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1947-L1970}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8556034432039635706}{} 
\hyperlink{8556034432039635706}{\texttt{Base.get!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get!(f::Function, collection, key)
\end{lstlisting}

Return the value stored for the given key, or if no mapping for the key is present, store \texttt{key => f()}, and return \texttt{f()}.

This is intended to be called using \texttt{do} block syntax:


\begin{minted}{julia}
get!(dict, key) do
    # default value calculated here
    time()
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1973-L1986}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7350451602884809264}{} 
\hyperlink{7350451602884809264}{\texttt{Base.getkey}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getkey(collection, key, default)
\end{lstlisting}

Return the key matching argument \texttt{key} if one exists in \texttt{collection}, otherwise return \texttt{default}.


\begin{minted}{jlcon}
julia> a = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'b' => 3
  'a' => 2

julia> getkey(a,'a',1)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> getkey(a,'d','a')
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L508-L525}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2012894417553832980}{} 
\hyperlink{2012894417553832980}{\texttt{Base.delete!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
delete!(collection, key)
\end{lstlisting}

Delete the mapping for the given key in a collection, and return the collection.

\textbf{Example}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2)
Dict{String,Int64} with 2 entries:
  "b" => 2
  "a" => 1

julia> delete!(d, "b")
Dict{String,Int64} with 1 entry:
  "a" => 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1331-L1347}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8214834680518266248}{} 
\hyperlink{8214834680518266248}{\texttt{Base.pop!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pop!(collection, key[, default])
\end{lstlisting}

Delete and return the mapping for \texttt{key} if it exists in \texttt{collection}, otherwise return \texttt{default}, or throw an error if \texttt{default} is not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> d = Dict("a"=>1, "b"=>2, "c"=>3);

julia> pop!(d, "a")
1

julia> pop!(d, "d")
ERROR: KeyError: key "d" not found
Stacktrace:
 [1] pop!(::Dict{String,Int64}, ::String) at ./dict.jl:539

julia> pop!(d, "e", 4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2600-L2621}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6023948435845840069}{} 
\hyperlink{6023948435845840069}{\texttt{Base.keys}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
keys(a::Associative)
\end{lstlisting}

Return an iterator over all keys in a collection. \texttt{collect(keys(a))} returns an array of keys. Since the keys are stored internally in a hash table, the order in which they are returned may vary. But \texttt{keys(a)} and \texttt{values(a)} both iterate \texttt{a} and return the elements in the same order.


\begin{minted}{jlcon}
julia> a = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'b' => 3
  'a' => 2

julia> collect(keys(a))
2-element Array{Char,1}:
 'b'
 'a'
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L63-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14429101350359443046}{} 
\hyperlink{14429101350359443046}{\texttt{Base.values}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
values(a::Associative)
\end{lstlisting}

Return an iterator over all values in a collection. \texttt{collect(values(a))} returns an array of values. Since the values are stored internally in a hash table, the order in which they are returned may vary. But \texttt{keys(a)} and \texttt{values(a)} both iterate \texttt{a} and return the elements in the same order.


\begin{minted}{jlcon}
julia> a = Dict('a'=>2, 'b'=>3)
Dict{Char,Int64} with 2 entries:
  'b' => 3
  'a' => 2

julia> collect(values(a))
2-element Array{Int64,1}:
 3
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L88-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2980395915971142404}{} 
\hyperlink{2980395915971142404}{\texttt{Base.merge}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
merge(d::Associative, others::Associative...)
\end{lstlisting}

Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.


\begin{minted}{jlcon}
julia> a = Dict("foo" => 0.0, "bar" => 42.0)
Dict{String,Float64} with 2 entries:
  "bar" => 42.0
  "foo" => 0.0

julia> b = Dict("baz" => 17, "bar" => 4711)
Dict{String,Int64} with 2 entries:
  "bar" => 4711
  "baz" => 17

julia> merge(a, b)
Dict{String,Float64} with 3 entries:
  "bar" => 4711.0
  "baz" => 17.0
  "foo" => 0.0

julia> merge(b, a)
Dict{String,Float64} with 3 entries:
  "bar" => 42.0
  "baz" => 17.0
  "foo" => 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L224-L255}{\texttt{source}}



\begin{lstlisting}
merge(combine, d::Associative, others::Associative...)
\end{lstlisting}

Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.


\begin{minted}{jlcon}
julia> a = Dict("foo" => 0.0, "bar" => 42.0)
Dict{String,Float64} with 2 entries:
  "bar" => 42.0
  "foo" => 0.0

julia> b = Dict("baz" => 17, "bar" => 4711)
Dict{String,Int64} with 2 entries:
  "bar" => 4711
  "baz" => 17

julia> merge(+, a, b)
Dict{String,Float64} with 3 entries:
  "bar" => 4753.0
  "baz" => 17.0
  "foo" => 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L259-L284}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6445163593036205863}{} 
\hyperlink{6445163593036205863}{\texttt{Base.merge!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
merge!(d::Associative, others::Associative...)
\end{lstlisting}

Update collection with pairs from the other collections. See also \hyperlink{2980395915971142404}{\texttt{merge}}.


\begin{minted}{jlcon}
julia> d1 = Dict(1 => 2, 3 => 4);

julia> d2 = Dict(1 => 4, 4 => 5);

julia> merge!(d1, d2);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 5
  3 => 4
  1 => 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L120-L139}{\texttt{source}}



\begin{lstlisting}
merge!(combine, d::Associative, others::Associative...)
\end{lstlisting}

Update collection with pairs from the other collections. Values with the same key will be combined using the combiner function.


\begin{minted}{jlcon}
julia> d1 = Dict(1 => 2, 3 => 4);

julia> d2 = Dict(1 => 4, 4 => 5);

julia> merge!(+, d1, d2);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 5
  3 => 4
  1 => 6

julia> merge!(-, d1, d1);

julia> d1
Dict{Int64,Int64} with 3 entries:
  4 => 0
  3 => 0
  1 => 0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L149-L177}{\texttt{source}}


Merge changes into current head 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/merge.jl#L66}{\texttt{source}}


Internal implementation of merge. Returns \texttt{true} if merge was successful, otherwise \texttt{false}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/merge.jl#L80-L83}{\texttt{source}}



\begin{lstlisting}
merge!(repo::GitRepo; kwargs...) -> Bool
\end{lstlisting}

Perform a git merge on the repository \texttt{repo}, merging commits with diverging history into the current branch. Returns \texttt{true} if the merge succeeded, \texttt{false} if not.

The keyword arguments are:

\begin{itemize}
\item \texttt{committish::AbstractString={\textquotedbl}{\textquotedbl}}: Merge the named commit(s) in \texttt{committish}.


\item \texttt{branch::AbstractString={\textquotedbl}{\textquotedbl}}: Merge the branch \texttt{branch} and all its commits since it diverged from the current branch.


\item \texttt{fastforward::Bool=false}: If \texttt{fastforward} is \texttt{true}, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return \texttt{false}. This is equivalent to the git CLI option \texttt{--ff-only}.


\item \texttt{merge\_opts::MergeOptions=MergeOptions()}: \texttt{merge\_opts} specifies options for the merge, such as merge strategy in case of conflicts.


\item \texttt{checkout\_opts::CheckoutOptions=CheckoutOptions()}: \texttt{checkout\_opts} specifies options for the checkout step.

\end{itemize}
Equivalent to \texttt{git merge [--ff-only] [<committish> | <branch>]}.

\begin{quote}
\textbf{Note}

If you specify a \texttt{branch}, this must be done in reference format, since the string will be turned into a \texttt{GitReference}. For example, if you wanted to merge branch \texttt{branch\_a}, you would call \texttt{merge!(repo, branch={\textquotedbl}refs/heads/branch\_a{\textquotedbl})}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L625-L652}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15797102328828238137}{} 
\hyperlink{15797102328828238137}{\texttt{Base.sizehint!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sizehint!(s, n)
\end{lstlisting}

Suggest that collection \texttt{s} reserve capacity for at least \texttt{n} elements. This can improve performance.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1114-L1118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7157735428816224008}{} 
\hyperlink{7157735428816224008}{\texttt{Base.keytype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
keytype(type)
\end{lstlisting}

Get the key type of an associative collection type. Behaves similarly to \hyperlink{6396209842929672718}{\texttt{eltype}}.


\begin{minted}{jlcon}
julia> keytype(Dict(Int32(1) => "foo"))
Int32
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L196-L205}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1758642341593311431}{} 
\hyperlink{1758642341593311431}{\texttt{Base.valtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
valtype(type)
\end{lstlisting}

Get the value type of an associative collection type. Behaves similarly to \hyperlink{6396209842929672718}{\texttt{eltype}}.


\begin{minted}{jlcon}
julia> valtype(Dict(Int32(1) => "foo"))
String
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L210-L219}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \hyperlink{11235697656281157373}{\texttt{ObjectIdDict}}


\item \hyperlink{3089397136845322041}{\texttt{Dict}}


\item \hyperlink{17958922440222792850}{\texttt{WeakKeyDict}}

\end{itemize}


Parcialmente implementado por:



\begin{itemize}
\item \hyperlink{8428136537376557806}{\texttt{IntSet}}


\item \hyperlink{1143189053501747033}{\texttt{Set}}


\item \hyperlink{15720283866375224773}{\texttt{EnvHash}}


\item \hyperlink{15492651498431872487}{\texttt{Array}}


\item \hyperlink{18015155802543401629}{\texttt{BitArray}}

\end{itemize}


\hypertarget{8739480466831557874}{}


\section{Colecciones de tipo Conjunto}


\hypertarget{1143189053501747033}{} 
\hyperlink{1143189053501747033}{\texttt{Base.Set}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Set([itr])
\end{lstlisting}

Construct a \hyperlink{1143189053501747033}{\texttt{Set}} of the values generated by the given iterable object, or an empty set. Should be used instead of \hyperlink{8428136537376557806}{\texttt{IntSet}} for sparse integer sets, or for sets of arbitrary objects.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2557-L2563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8428136537376557806}{} 
\hyperlink{8428136537376557806}{\texttt{Base.IntSet}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IntSet([itr])
\end{lstlisting}

Construct a sorted set of positive \texttt{Int}s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. Only \texttt{Int}s greater than 0 can be stored. If the set will be sparse (for example holding a few very large integers), use \hyperlink{1143189053501747033}{\texttt{Set}} instead.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1630-L1637}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6278797112644055704}{} 
\hyperlink{6278797112644055704}{\texttt{Base.union}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
union(s1,s2...)
∪(s1,s2...)
\end{lstlisting}

Construct the union of two or more sets. Maintains order with arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> union([1, 2], [3, 4])
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> union([1, 2], [2, 4])
3-element Array{Int64,1}:
 1
 2
 4

julia> union([4, 2], [1, 2])
3-element Array{Int64,1}:
 4
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L944-L971}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12706236051336451682}{} 
\hyperlink{12706236051336451682}{\texttt{Base.union!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
union!(s, iterable)
\end{lstlisting}

Union each element of \texttt{iterable} into set \texttt{s} in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2511-L2515}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17029201757338520959}{} 
\hyperlink{17029201757338520959}{\texttt{Base.intersect}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
intersect(s1,s2...)
∩(s1,s2)
\end{lstlisting}

Construct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2069-L2075}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11050652365145191041}{} 
\hyperlink{11050652365145191041}{\texttt{Base.setdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setdiff(a, b)
\end{lstlisting}

Construct the set of elements in \texttt{a} but not \texttt{b}. Maintains order with arrays. Note that both arguments must be collections, and both will be iterated over. In particular, \texttt{setdiff(set,element)} where \texttt{element} is a potential member of \texttt{set}, will not work in general.

\textbf{Example}


\begin{minted}{jlcon}
julia> setdiff([1,2,3],[3,4,5])
2-element Array{Int64,1}:
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1968-L1983}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12326722559100879167}{} 
\hyperlink{12326722559100879167}{\texttt{Base.setdiff!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setdiff!(s, iterable)
\end{lstlisting}

Remove each element of \texttt{iterable} from set \texttt{s} in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L792-L796}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4317834782250216015}{} 
\hyperlink{4317834782250216015}{\texttt{Base.symdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symdiff(a, b, rest...)
\end{lstlisting}

Construct the symmetric difference of elements in the passed in sets or arrays. Maintains order with arrays.

\textbf{Example}


\begin{minted}{jlcon}
julia> symdiff([1,2,3],[3,4,5],[4,5,6])
3-element Array{Int64,1}:
 1
 2
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L2004-L2018}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17482124157118607228}{} 
\hyperlink{17482124157118607228}{\texttt{Base.symdiff!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symdiff!(s, n)
\end{lstlisting}

The set \texttt{s} is destructively modified to toggle the inclusion of integer \texttt{n}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L137-L141}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15071236761362803413}{} 
\hyperlink{15071236761362803413}{\texttt{Base.symdiff!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symdiff!(s, itr)
\end{lstlisting}

For each element in \texttt{itr}, destructively toggle its inclusion in set \texttt{s}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L131-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14588756314269897163}{} 
\hyperlink{14588756314269897163}{\texttt{Base.symdiff!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symdiff!(s, itr)
\end{lstlisting}

For each element in \texttt{itr}, destructively toggle its inclusion in set \texttt{s}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L131-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18401946028185283153}{} 
\hyperlink{18401946028185283153}{\texttt{Base.intersect!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
intersect!(s1::IntSet, s2::IntSet)
\end{lstlisting}

Intersects sets \texttt{s1} and \texttt{s2} and overwrites the set \texttt{s1} with the result. If needed, \texttt{s1} will be expanded to the size of \texttt{s2}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L112-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18158680907243266011}{} 
\hyperlink{18158680907243266011}{\texttt{Base.issubset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issubset(A, S) -> Bool
⊆(A,S) -> Bool
\end{lstlisting}

Return \texttt{true} if \texttt{A} is a subset of or equal to \texttt{S}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2345-L2350}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \hyperlink{8428136537376557806}{\texttt{IntSet}}


\item \hyperlink{1143189053501747033}{\texttt{Set}}

\end{itemize}


Parcialmente implementado por:



\begin{itemize}
\item \hyperlink{15492651498431872487}{\texttt{Array}}

\end{itemize}


\hypertarget{14814959928232183731}{}


\section{Acciones relacionadas con Colas}


\hypertarget{18026893834387542681}{} 
\hyperlink{18026893834387542681}{\texttt{Base.push!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
push!(collection, items...) -> collection
\end{lstlisting}

Insert one or more \texttt{items} at the end of \texttt{collection}.

\textbf{Example}


\begin{minted}{jlcon}
julia> push!([1, 2, 3], 4, 5, 6)
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
\end{minted}

Use \hyperlink{2587432243763606566}{\texttt{append!}} to add all the elements of another collection to \texttt{collection}. The result of the preceding example is equivalent to \texttt{append!([1, 2, 3], [4, 5, 6])}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L384-L404}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5793500518919030851}{} 
\hyperlink{5793500518919030851}{\texttt{Base.pop!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pop!(collection) -> item
\end{lstlisting}

Remove the last item in \texttt{collection} and return it.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A=[1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia> pop!(A)
6

julia> A
5-element Array{Int64,1}:
 1
 2
 3
 4
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2624-L2651}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13472234694981819983}{} 
\hyperlink{13472234694981819983}{\texttt{Base.unshift!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unshift!(collection, items...) -> collection
\end{lstlisting}

Insert one or more \texttt{items} at the beginning of \texttt{collection}.

\textbf{Example}


\begin{minted}{jlcon}
julia> unshift!([1, 2, 3, 4], 5, 6)
6-element Array{Int64,1}:
 5
 6
 1
 2
 3
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L798-L814}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9705305782876235366}{} 
\hyperlink{9705305782876235366}{\texttt{Base.shift!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
shift!(collection) -> item
\end{lstlisting}

Remove the first \texttt{item} from \texttt{collection}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia> shift!(A)
1

julia> A
5-element Array{Int64,1}:
 2
 3
 4
 5
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1489-L1516}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2077968578228414845}{} 
\hyperlink{2077968578228414845}{\texttt{Base.insert!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
insert!(a::Vector, index::Integer, item)
\end{lstlisting}

Insert an \texttt{item} into \texttt{a} at the given \texttt{index}. \texttt{index} is the index of \texttt{item} in the resulting \texttt{a}.

\textbf{Example}


\begin{minted}{jlcon}
julia> insert!([6, 5, 4, 2, 1], 4, 3)
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L831-L848}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16790471737745785097}{} 
\hyperlink{16790471737745785097}{\texttt{Base.deleteat!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deleteat!(a::Vector, i::Integer)
\end{lstlisting}

Remove the item at the given \texttt{i} and return the modified \texttt{a}. Subsequent items are shifted to fill the resulting gap.

\textbf{Example}


\begin{minted}{jlcon}
julia> deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Array{Int64,1}:
 6
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L858-L874}{\texttt{source}}



\begin{lstlisting}
deleteat!(a::Vector, inds)
\end{lstlisting}

Remove the items at the indices given by \texttt{inds}, and return the modified \texttt{a}. Subsequent items are shifted to fill the resulting gap.

\texttt{inds} can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as \texttt{a} with \texttt{true} indicating entries to delete.

\textbf{Examples}


\begin{minted}{jlcon}
julia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Array{Int64,1}:
 5
 3
 1

julia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])
3-element Array{Int64,1}:
 5
 3
 1

julia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
Stacktrace:
 [1] _deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:926
 [2] deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:913
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L883-L912}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13785507599688955371}{} 
\hyperlink{13785507599688955371}{\texttt{Base.splice!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
splice!(a::Vector, index::Integer, [replacement]) -> item
\end{lstlisting}

Remove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.

\textbf{Examples}


\begin{lstlisting}
julia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia> A
5-element Array{Int64,1}:
 6
 5
 4
 3
 1

julia> splice!(A, 5, -1)
1

julia> A
5-element Array{Int64,1}:
  6
  5
  4
  3
 -1

julia> splice!(A, 1, [-1, -2, -3])
6

julia> A
7-element Array{Int64,1}:
 -1
 -2
 -3
  5
  4
  3
 -1
\end{lstlisting}

To insert \texttt{replacement} before an index \texttt{n} without removing any items, use \texttt{splice!(collection, n:n-1, replacement)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L960-L1008}{\texttt{source}}



\begin{lstlisting}
splice!(a::Vector, range, [replacement]) -> items
\end{lstlisting}

Remove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.

To insert \texttt{replacement} before an index \texttt{n} without removing any items, use \texttt{splice!(collection, n:n-1, replacement)}.

\textbf{Example}


\begin{lstlisting}
julia> splice!(A, 4:3, 2)
0-element Array{Int64,1}

julia> A
8-element Array{Int64,1}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1027-L1055}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10980093798189218206}{} 
\hyperlink{10980093798189218206}{\texttt{Base.resize!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
resize!(a::Vector, n::Integer) -> Vector
\end{lstlisting}

Resize \texttt{a} to contain \texttt{n} elements. If \texttt{n} is smaller than the current collection length, the first \texttt{n} elements will be retained. If \texttt{n} is larger, the new elements are not guaranteed to be initialized.

\textbf{Examples}


\begin{minted}{jlcon}
julia> resize!([6, 5, 4, 3, 2, 1], 3)
3-element Array{Int64,1}:
 6
 5
 4

julia> a = resize!([6, 5, 4, 3, 2, 1], 8);

julia> length(a)
8

julia> a[1:6]
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L741-L770}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2587432243763606566}{} 
\hyperlink{2587432243763606566}{\texttt{Base.append!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
append!(collection, collection2) -> collection.
\end{lstlisting}

Add the elements of \texttt{collection2} to the end of \texttt{collection}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> append!([1],[2,3])
3-element Array{Int64,1}:
 1
 2
 3

julia> append!([1, 2, 3], [4, 5, 6])
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
\end{minted}

Use \hyperlink{18026893834387542681}{\texttt{push!}} to add individual items to \texttt{collection} which are not already themselves in another collection. The result is of the preceding example is equivalent to \texttt{push!([1, 2, 3], 4, 5, 6)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L756-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9292529440147652243}{} 
\hyperlink{9292529440147652243}{\texttt{Base.prepend!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prepend!(a::Vector, items) -> collection
\end{lstlisting}

Insert the elements of \texttt{items} to the beginning of \texttt{a}.

\textbf{Example}


\begin{minted}{jlcon}
julia> prepend!([3],[1,2])
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L690-L703}{\texttt{source}}


\end{adjustwidth}

Completamente implementado por:



\begin{itemize}
\item \texttt{Vector} (también conocido como 1-dimensional \hyperlink{15492651498431872487}{\texttt{Array}})


\item \texttt{BitVector} (también conocido como 1-dimensional \hyperlink{18015155802543401629}{\texttt{BitArray}})

\end{itemize}


\hypertarget{8551667013795262933}{}


\chapter{Matemáticas}



\hypertarget{15714690155437633961}{}


\section{Operadores Matemáticos}


\hypertarget{8228207173393714756}{} 
\hyperlink{8228207173393714756}{\texttt{Base.:-}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
-(x)
\end{lstlisting}

Unary minus operator.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L66-L70}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3677358729494553841}{} 
\hyperlink{3677358729494553841}{\texttt{Base.:+}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
+(x, y...)
\end{lstlisting}

Addition operator. \texttt{x+y+z+...} calls this function with all arguments, i.e. \texttt{+(x, y, z, ...)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2281-L2285}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11135345846828585592}{} 
\hyperlink{11135345846828585592}{\texttt{Base.:-}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
-(x, y)
\end{lstlisting}

Subtraction operator.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L73-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7592762607639177347}{} 
\hyperlink{7592762607639177347}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
*(x, y...)
\end{lstlisting}

Multiplication operator. \texttt{x*y*z*...} calls this function with all arguments, i.e. \texttt{*(x, y, z, ...)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1917-L1923}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4103478871488785445}{} 
\hyperlink{4103478871488785445}{\texttt{Base.:/}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
/(x, y)
\end{lstlisting}

Right division operator: multiplication of \texttt{x} by the inverse of \texttt{y} on the right. Gives floating-point results for integer arguments.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L522-L527}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4639577998029770435}{} 
\hyperlink{4639577998029770435}{\texttt{Base.:{\textbackslash}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
\(x, y)
\end{lstlisting}

Left division operator: multiplication of \texttt{y} by the inverse of \texttt{x} on the left. Gives floating-point results for integer arguments.


\begin{minted}{jlcon}
julia> 3 \ 6
2.0

julia> inv(3) * 6
2.0

julia> A = [1 2; 3 4]; x = [5, 6];

julia> A \ x
2-element Array{Float64,1}:
 -4.0
  4.5

julia> inv(A) * x
2-element Array{Float64,1}:
 -4.0
  4.5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L431-L456}{\texttt{source}}


\end{adjustwidth}
\hypertarget{462277561264792021}{} 
\hyperlink{462277561264792021}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
^(x, y)
\end{lstlisting}

Exponentiation operator. If \texttt{x} is a matrix, computes matrix exponentiation.

If \texttt{y} is an \texttt{Int} literal (e.g. \texttt{2} in \texttt{x{\textasciicircum}2} or \texttt{-3} in \texttt{x{\textasciicircum}-3}), the Julia code \texttt{x{\textasciicircum}y} is transformed by the compiler to \texttt{Base.literal\_pow({\textasciicircum}, x, Val\{y\})}, to enable compile-time specialization on the value of the exponent. (As a default fallback we have \texttt{Base.literal\_pow({\textasciicircum}, x, Val\{y\}) = {\textasciicircum}(x,y)}, where usually \texttt{{\textasciicircum} == Base.{\textasciicircum}} unless \texttt{{\textasciicircum}} has been defined in the calling namespace.)


\begin{minted}{jlcon}
julia> 3^5
243

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> A^3
2×2 Array{Int64,2}:
 37   54
 81  118
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/promotion.jl#L254-L280}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17935587874085983500}{} 
\hyperlink{17935587874085983500}{\texttt{Base.fma}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fma(x, y, z)
\end{lstlisting}

Computes \texttt{x*y+z} without rounding the intermediate result \texttt{x*y}. On some systems this is significantly more expensive than \texttt{x*y+z}. \texttt{fma} is used to improve accuracy in certain algorithms. See \hyperlink{7153024527713262493}{\texttt{muladd}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2264-L2270}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7153024527713262493}{} 
\hyperlink{7153024527713262493}{\texttt{Base.muladd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
muladd(x, y, z)
\end{lstlisting}

Combined multiply-add, computes \texttt{x*y+z} in an efficient manner. This may on some systems be equivalent to \texttt{x*y+z}, or to \texttt{fma(x,y,z)}. \texttt{muladd} is used to improve performance. See \hyperlink{17935587874085983500}{\texttt{fma}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> muladd(3, 2, 1)
7

julia> 3 * 2 + 1
7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L927-L942}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8020976424566491334}{} 
\hyperlink{8020976424566491334}{\texttt{Base.div}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
div(x, y)
÷(x, y)
\end{lstlisting}

The quotient from Euclidean division. Computes \texttt{x/y}, truncated to an integer.


\begin{minted}{jlcon}
julia> 9 ÷ 4
2

julia> -5 ÷ 3
-1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L616-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15067916827074788527}{} 
\hyperlink{15067916827074788527}{\texttt{Base.fld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fld(x, y)
\end{lstlisting}

Largest integer less than or equal to \texttt{x/y}.


\begin{minted}{jlcon}
julia> fld(7.3,5.5)
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L568-L577}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7922388465305816555}{} 
\hyperlink{7922388465305816555}{\texttt{Base.cld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cld(x, y)
\end{lstlisting}

Smallest integer larger than or equal to \texttt{x/y}.


\begin{minted}{jlcon}
julia> cld(5.5,2.2)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L580-L588}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2082041235715276573}{} 
\hyperlink{2082041235715276573}{\texttt{Base.mod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mod(x, y)
rem(x, y, RoundDown)
\end{lstlisting}

The reduction of \texttt{x} modulo \texttt{y}, or equivalently, the remainder of \texttt{x} after floored division by \texttt{y}, i.e.


\begin{minted}{julia}
x - y*fld(x,y)
\end{minted}

if computed without intermediate rounding.

The result will have the same sign as \texttt{y}, and magnitude less than \texttt{abs(y)} (with some exceptions, see note below).

\begin{quote}
\textbf{Note}

When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to \texttt{y}, then it may be rounded to \texttt{y}.

\end{quote}

\begin{minted}{jlcon}
julia> mod(8, 3)
2

julia> mod(9, 3)
0

julia> mod(8.9, 3)
2.9000000000000004

julia> mod(eps(), 3)
2.220446049250313e-16

julia> mod(-eps(), 3)
3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L132-L168}{\texttt{source}}



\begin{lstlisting}
rem(x::Integer, T::Type{<:Integer}) -> T
mod(x::Integer, T::Type{<:Integer}) -> T
%(x::Integer, T::Type{<:Integer}) -> T
\end{lstlisting}

Find \texttt{y::T} such that \texttt{x} ≡ \texttt{y} (mod n), where n is the number of integers representable in \texttt{T}, and \texttt{y} is an integer in \texttt{[typemin(T),typemax(T)]}. If \texttt{T} can represent any integer (e.g. \texttt{T == BigInt}), then this operation corresponds to a conversion to \texttt{T}.


\begin{minted}{jlcon}
julia> 129 % Int8
-127
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L369-L383}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3827563084771191385}{} 
\hyperlink{3827563084771191385}{\texttt{Base.rem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rem(x, y)
%(x, y)
\end{lstlisting}

Remainder from Euclidean division, returning a value of the same sign as \texttt{x}, and smaller in magnitude than \texttt{y}. This value is always exact.


\begin{minted}{jlcon}
julia> x = 15; y = 4;

julia> x % y
3

julia> x == div(x, y) * y + rem(x, y)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L596-L612}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7552737171387915272}{} 
\hyperlink{7552737171387915272}{\texttt{Base.Math.rem2pi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rem2pi(x, r::RoundingMode)
\end{lstlisting}

Compute the remainder of \texttt{x} after integer division by \texttt{2π}, with the quotient rounded according to the rounding mode \texttt{r}. In other words, the quantity


\begin{lstlisting}
x - 2π*round(x/(2π),r)
\end{lstlisting}

without any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than \texttt{rem(x,2π,r)}

\begin{itemize}
\item if \texttt{r == RoundNearest}, then the result is in the interval \([-π, π]\). This will generally be the most accurate result.


\item if \texttt{r == RoundToZero}, then the result is in the interval \([0, 2π]\) if \texttt{x} is positive,. or \([-2π, 0]\) otherwise.


\item if \texttt{r == RoundDown}, then the result is in the interval \([0, 2π]\).


\item if \texttt{r == RoundUp}, then the result is in the interval \([-2π, 0]\).

\end{itemize}
\textbf{Example}


\begin{minted}{jlcon}
julia> rem2pi(7pi/4, RoundNearest)
-0.7853981633974485

julia> rem2pi(7pi/4, RoundDown)
5.497787143782138
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L761-L790}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15322754370885673769}{} 
\hyperlink{15322754370885673769}{\texttt{Base.Math.mod2pi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mod2pi(x)
\end{lstlisting}

Modulus after division by \texttt{2π}, returning in the range \([0,2π)\).

This function computes a floating point representation of the modulus after division by numerically exact \texttt{2π}, and is therefore not exactly the same as \texttt{mod(x,2π)}, which would compute the modulus of \texttt{x} relative to division by the floating-point number \texttt{2π}.

\textbf{Example}


\begin{minted}{jlcon}
julia> mod2pi(9*pi/4)
0.7853981633974481
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L908-L922}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6106909621813654214}{} 
\hyperlink{6106909621813654214}{\texttt{Base.divrem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
divrem(x, y)
\end{lstlisting}

The quotient and remainder from Euclidean division. Equivalent to \texttt{(div(x,y), rem(x,y))} or \texttt{(x÷y, x\%y)}.


\begin{minted}{jlcon}
julia> divrem(3,7)
(0, 3)

julia> divrem(7,3)
(2, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L50-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2806360720034558325}{} 
\hyperlink{2806360720034558325}{\texttt{Base.fldmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fldmod(x, y)
\end{lstlisting}

The floored quotient and modulus after division. Equivalent to \texttt{(fld(x,y), mod(x,y))}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L66-L70}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2046682076337602867}{} 
\hyperlink{2046682076337602867}{\texttt{Base.fld1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fld1(x, y)
\end{lstlisting}

Flooring division, returning a value consistent with \texttt{mod1(x,y)}

See also: \hyperlink{13778479217547823795}{\texttt{mod1}}.


\begin{minted}{jlcon}
julia> x = 15; y = 4;

julia> fld1(x, y)
4

julia> x == fld(x, y) * y + mod(x, y)
true

julia> x == (fld1(x, y) - 1) * y + mod1(x, y)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L652-L671}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13778479217547823795}{} 
\hyperlink{13778479217547823795}{\texttt{Base.mod1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mod1(x, y)
\end{lstlisting}

Modulus after flooring division, returning a value \texttt{r} such that \texttt{mod(r, y) == mod(x, y)} in the range \((0, y]\) for positive \texttt{y} and in the range \([y,0)\) for negative \texttt{y}.


\begin{minted}{jlcon}
julia> mod1(4, 2)
2

julia> mod1(4, 3)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L633-L646}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3908876301745770865}{} 
\hyperlink{3908876301745770865}{\texttt{Base.fldmod1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fldmod1(x, y)
\end{lstlisting}

Return \texttt{(fld1(x,y), mod1(x,y))}.

See also: \hyperlink{2046682076337602867}{\texttt{fld1}}, \hyperlink{13778479217547823795}{\texttt{mod1}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L676-L682}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17539582191808611917}{} 
\hyperlink{17539582191808611917}{\texttt{Base.://}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
//(num, den)
\end{lstlisting}

Divide two integers or rational numbers, giving a \hyperlink{8304566144531167610}{\texttt{Rational}} result.


\begin{minted}{jlcon}
julia> 3 // 5
3//5

julia> (3 // 5) // (2 // 1)
3//10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L27-L39}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6368672003928643787}{} 
\hyperlink{6368672003928643787}{\texttt{Base.rationalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rationalize([T<:Integer=Int,] x; tol::Real=eps(x))
\end{lstlisting}

Approximate floating point number \texttt{x} as a \hyperlink{8304566144531167610}{\texttt{Rational}} number with components of the given integer type. The result will differ from \texttt{x} by no more than \texttt{tol}. If \texttt{T} is not provided, it defaults to \texttt{Int}.


\begin{minted}{jlcon}
julia> rationalize(5.6)
28//5

julia> a = rationalize(BigInt, 10.3)
103//10

julia> typeof(numerator(a))
BigInt
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L109-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7885506453580572157}{} 
\hyperlink{7885506453580572157}{\texttt{Base.numerator}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
numerator(x)
\end{lstlisting}

Numerator of the rational representation of \texttt{x}.


\begin{minted}{jlcon}
julia> numerator(2//3)
2

julia> numerator(4)
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L189-L201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12407209279719593434}{} 
\hyperlink{12407209279719593434}{\texttt{Base.denominator}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
denominator(x)
\end{lstlisting}

Denominator of the rational representation of \texttt{x}.


\begin{minted}{jlcon}
julia> denominator(2//3)
3

julia> denominator(4)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L205-L217}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2724916807067930829}{} 
\hyperlink{2724916807067930829}{\texttt{Base.:<<}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
<<(x, n)
\end{lstlisting}

Left bit shift operator, \texttt{x << n}. For \texttt{n >= 0}, the result is \texttt{x} shifted left by \texttt{n} bits, filling with \texttt{0}s. This is equivalent to \texttt{x * 2{\textasciicircum}n}. For \texttt{n < 0}, this is equivalent to \texttt{x >> -n}.


\begin{minted}{jlcon}
julia> Int8(3) << 2
12

julia> bits(Int8(3))
"00000011"

julia> bits(Int8(12))
"00001100"
\end{minted}

See also \hyperlink{6883264745383491304}{\texttt{>>}}, \hyperlink{16613216773443333487}{\texttt{>>>}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L463-L481}{\texttt{source}}



\begin{lstlisting}
<<(B::BitVector, n) -> BitVector
\end{lstlisting}

Left bit shift operator, \texttt{B << n}. For \texttt{n >= 0}, the result is \texttt{B} with elements shifted \texttt{n} positions backwards, filling with \texttt{false} values. If \texttt{n < 0}, elements are shifted forwards. Equivalent to \texttt{B >> -n}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia> B << 1
5-element BitArray{1}:
 false
  true
 false
 false
 false

julia> B << -1
5-element BitArray{1}:
 false
  true
 false
  true
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1422-L1457}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6883264745383491304}{} 
\hyperlink{6883264745383491304}{\texttt{Base.:>>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>>(x, n)
\end{lstlisting}

Right bit shift operator, \texttt{x >> n}. For \texttt{n >= 0}, the result is \texttt{x} shifted right by \texttt{n} bits, where \texttt{n >= 0}, filling with \texttt{0}s if \texttt{x >= 0}, \texttt{1}s if \texttt{x < 0}, preserving the sign of \texttt{x}. This is equivalent to \texttt{fld(x, 2{\textasciicircum}n)}. For \texttt{n < 0}, this is equivalent to \texttt{x << -n}.


\begin{minted}{jlcon}
julia> Int8(13) >> 2
3

julia> bits(Int8(13))
"00001101"

julia> bits(Int8(3))
"00000011"

julia> Int8(-14) >> 2
-4

julia> bits(Int8(-14))
"11110010"

julia> bits(Int8(-4))
"11111100"
\end{minted}

See also \hyperlink{16613216773443333487}{\texttt{>>>}}, \hyperlink{2724916807067930829}{\texttt{<<}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L491-L520}{\texttt{source}}



\begin{lstlisting}
>>(B::BitVector, n) -> BitVector
\end{lstlisting}

Right bit shift operator, \texttt{B >> n}. For \texttt{n >= 0}, the result is \texttt{B} with elements shifted \texttt{n} positions forward, filling with \texttt{false} values. If \texttt{n < 0}, elements are shifted backwards. Equivalent to \texttt{B << -n}.

\textbf{Example}


\begin{minted}{jlcon}
julia> B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia> B >> 1
5-element BitArray{1}:
 false
  true
 false
  true
 false

julia> B >> -1
5-element BitArray{1}:
 false
  true
 false
 false
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1383-L1418}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16613216773443333487}{} 
\hyperlink{16613216773443333487}{\texttt{Base.:>>>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>>>(x, n)
\end{lstlisting}

Unsigned right bit shift operator, \texttt{x >>> n}. For \texttt{n >= 0}, the result is \texttt{x} shifted right by \texttt{n} bits, where \texttt{n >= 0}, filling with \texttt{0}s. For \texttt{n < 0}, this is equivalent to \texttt{x << -n}.

For \hyperlink{4780971278803506664}{\texttt{Unsigned}} integer types, this is equivalent to \hyperlink{6883264745383491304}{\texttt{>>}}. For \hyperlink{14154866400772377486}{\texttt{Signed}} integer types, this is equivalent to \texttt{signed(unsigned(x) >> n)}.


\begin{minted}{jlcon}
julia> Int8(-14) >>> 2
60

julia> bits(Int8(-14))
"11110010"

julia> bits(Int8(60))
"00111100"
\end{minted}

\hyperlink{423405808990690832}{\texttt{BigInt}}s are treated as if having infinite size, so no filling is required and this is equivalent to \hyperlink{6883264745383491304}{\texttt{>>}}.

See also \hyperlink{6883264745383491304}{\texttt{>>}}, \hyperlink{2724916807067930829}{\texttt{<<}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L530-L555}{\texttt{source}}



\begin{lstlisting}
>>>(B::BitVector, n) -> BitVector
\end{lstlisting}

Unsigned right bitshift operator, \texttt{B >>> n}. Equivalent to \texttt{B >> n}. See \hyperlink{6883264745383491304}{\texttt{>>}} for details and examples.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1460-L1465}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8118178594303305099}{} 
\hyperlink{8118178594303305099}{\texttt{Base.colon}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
colon(start, [step], stop)
\end{lstlisting}

Called by \texttt{:} syntax for constructing ranges.


\begin{minted}{jlcon}
julia> colon(1, 2, 5)
1:2:5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L18-L27}{\texttt{source}}



\begin{lstlisting}
:(start, [step], stop)
\end{lstlisting}

Range operator. \texttt{a:b} constructs a range from \texttt{a} to \texttt{b} with a step size of 1, and \texttt{a:s:b} is similar but uses a step size of \texttt{s}. These syntaxes call the function \texttt{colon}. The colon is also used in indexing to select whole dimensions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L39-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{737600656772861535}{} 
\hyperlink{737600656772861535}{\texttt{Base.range}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
range(start, [step], length)
\end{lstlisting}

Construct a range by length, given a starting value and optional step (defaults to 1).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L55-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7189994599038205424}{} 
\hyperlink{7189994599038205424}{\texttt{Base.OneTo}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.OneTo(n)
\end{lstlisting}

Define an \texttt{AbstractUnitRange} that behaves like \texttt{1:n}, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L166-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6593444000385137506}{} 
\hyperlink{6593444000385137506}{\texttt{Base.StepRangeLen}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1])
\end{lstlisting}

A range \texttt{r} where \texttt{r[i]} produces values of type \texttt{T}, parametrized by a \texttt{ref}erence value, a \texttt{step}, and the \texttt{len}gth.  By default \texttt{ref} is the starting value \texttt{r[1]}, but alternatively you can supply it as the value of \texttt{r[offset]} for some other index \texttt{1 <= offset <= len}.  In conjunction with \texttt{TwicePrecision} this can be used to implement ranges that are free of roundoff error.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L181-L190}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15143149452920304570}{} 
\hyperlink{15143149452920304570}{\texttt{Base.:==}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
==(x, y)
\end{lstlisting}

Generic equality operator, giving a single \hyperlink{46725311238864537}{\texttt{Bool}} result. Falls back to \texttt{===}. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding.

Follows IEEE semantics for floating-point numbers.

Collections should generally implement \texttt{==} by calling \texttt{==} recursively on all contents.

New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1674-L1688}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3046079188653285114}{} 
\hyperlink{3046079188653285114}{\texttt{Base.:!=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
!=(x, y)
≠(x,y)
\end{lstlisting}

Not-equals comparison operator. Always gives the opposite answer as \texttt{==}. New types should generally not implement this, and rely on the fallback definition \texttt{!=(x,y) = !(x==y)} instead.


\begin{minted}{jlcon}
julia> 3 != 2
true

julia> "foo" ≠ "foo"
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L114-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3509174727635606109}{} 
\hyperlink{3509174727635606109}{\texttt{Base.:!==}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
!==(x, y)
≢(x,y)
\end{lstlisting}

Equivalent to \texttt{!(x === y)}.


\begin{minted}{jlcon}
julia> a = [1, 2]; b = [1, 2];

julia> a ≢ b
true

julia> a ≢ a
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L156-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{702782232449268329}{} 
\hyperlink{702782232449268329}{\texttt{Base.:<}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
<(x, y)
\end{lstlisting}

Less-than comparison operator. New numeric types should implement this function for two arguments of the new type. Because of the behavior of floating-point NaN values, \texttt{<} implements a partial order. Types with a canonical partial order should implement \texttt{<}, and types with a canonical total order should implement \texttt{isless}.


\begin{minted}{jlcon}
julia> 'a' < 'b'
true

julia> "abc" < "abd"
true

julia> 5 < 3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L175-L193}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11411050964021316526}{} 
\hyperlink{11411050964021316526}{\texttt{Base.:<=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
<=(x, y)
≤(x,y)
\end{lstlisting}

Less-than-or-equals comparison operator.


\begin{minted}{jlcon}
julia> 'a' <= 'b'
true

julia> 7 ≤ 7 ≤ 9
true

julia> "abc" ≤ "abc"
true

julia> 5 <= 3
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L218-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8677991761303191103}{} 
\hyperlink{8677991761303191103}{\texttt{Base.:>}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>(x, y)
\end{lstlisting}

Greater-than comparison operator. Generally, new types should implement \texttt{<} instead of this function, and rely on the fallback definition \texttt{>(x, y) = y < x}.


\begin{minted}{jlcon}
julia> 'a' > 'b'
false

julia> 7 > 3 > 1
true

julia> "abc" > "abd"
false

julia> 5 > 3
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L196-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7019639580556993898}{} 
\hyperlink{7019639580556993898}{\texttt{Base.:>=}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
>=(x, y)
≥(x,y)
\end{lstlisting}

Greater-than-or-equals comparison operator.


\begin{minted}{jlcon}
julia> 'a' >= 'b'
false

julia> 7 ≥ 7 ≥ 3
true

julia> "abc" ≥ "abc"
true

julia> 5 >= 3
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L241-L260}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8951185024259053949}{} 
\hyperlink{8951185024259053949}{\texttt{Base.cmp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cmp(x,y)
\end{lstlisting}

Return -1, 0, or 1 depending on whether \texttt{x} is less than, equal to, or greater than \texttt{y}, respectively. Uses the total order implemented by \texttt{isless}. For floating-point numbers, uses \texttt{<} but throws an error for unordered arguments.


\begin{minted}{jlcon}
julia> cmp(1, 2)
-1

julia> cmp(2, 1)
1

julia> cmp(2+im, 3-im)
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L284-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2433030275488323500}{} 
\hyperlink{2433030275488323500}{\texttt{Base.:{\textasciitilde}}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
~(x)
\end{lstlisting}

Bitwise not.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ~4
-5

julia> ~10
-11

julia> ~true
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1275-L1291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1494761116451616317}{} 
\hyperlink{1494761116451616317}{\texttt{Base.:\&}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
&(x, y)
\end{lstlisting}

Bitwise and.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 4 & 10
0

julia> 4 & 12
4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L639-L652}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9633687763646488853}{} 
\hyperlink{9633687763646488853}{\texttt{Base.:|}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
|(x, y)
\end{lstlisting}

Bitwise or.

\textbf{Examples}


\begin{minted}{jlcon}
julia> 4 | 10
14

julia> 4 | 1
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2584-L2597}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7071880015536674935}{} 
\hyperlink{7071880015536674935}{\texttt{Base.xor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
xor(x, y)
⊻(x, y)
\end{lstlisting}

Bitwise exclusive or of \texttt{x} and \texttt{y}.  The infix operation \texttt{a ⊻ b} is a synonym for \texttt{xor(a,b)}, and \texttt{⊻} can be typed by tab-completing \texttt{{\textbackslash}xor} or \texttt{{\textbackslash}veebar} in the Julia REPL.


\begin{minted}{jlcon}
julia> [true; true; false] .⊻ [true; false; false]
3-element BitArray{1}:
 false
  true
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bool.jl#L44-L60}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4329035214952292986}{} 
\hyperlink{4329035214952292986}{\texttt{Base.:!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
!(x)
\end{lstlisting}

Boolean not.


\begin{minted}{jlcon}
julia> !true
false

julia> !false
true

julia> .![true false true]
1×3 BitArray{2}:
 false  true  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bool.jl#L17-L33}{\texttt{source}}



\begin{lstlisting}
!f::Function
\end{lstlisting}

Predicate function negation: when the argument of \texttt{!} is a function, it returns a function which computes the boolean negation of \texttt{f}. Example:


\begin{minted}{jlcon}
julia> str = "∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"
"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"

julia> filter(isalpha, str)
"εδxyδfxfyε"

julia> filter(!isalpha, str)
"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < "
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L887-L903}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4714012140247170866}{} 
\hyperlink{4714012140247170866}{\texttt{\&\&}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
x && y
\end{lstlisting}

Short-circuiting boolean AND.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L543-L547}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2053797086840563251}{} 
\hyperlink{2053797086840563251}{\texttt{||}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
x || y
\end{lstlisting}

Short-circuiting boolean OR.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L550-L554}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8251612812642852850}{}


\section{Funciones Matemáticas}


\hypertarget{12499503887608197213}{} 
\hyperlink{12499503887608197213}{\texttt{Base.isapprox}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isapprox(x, y; rtol::Real=sqrt(eps), atol::Real=0, nans::Bool=false, norm::Function)
\end{lstlisting}

Inexact equality comparison: \texttt{true} if \texttt{norm(x-y) <= atol + rtol*max(norm(x), norm(y))}. The default \texttt{atol} is zero and the default \texttt{rtol} depends on the types of \texttt{x} and \texttt{y}. The keyword argument \texttt{nans} determines whether or not NaN values are considered equal (defaults to false).

For real or complex floating-point values, \texttt{rtol} defaults to \texttt{sqrt(eps(typeof(real(x-y))))}. This corresponds to requiring equality of about half of the significand digits. For other types, \texttt{rtol} defaults to zero.

\texttt{x} and \texttt{y} may also be arrays of numbers, in which case \texttt{norm} defaults to \texttt{vecnorm} but may be changed by passing a \texttt{norm::Function} keyword argument. (For numbers, \texttt{norm} is the same thing as \texttt{abs}.) When \texttt{x} and \texttt{y} are arrays, if \texttt{norm(x-y)} is not finite (i.e. \texttt{±Inf} or \texttt{NaN}), the comparison falls back to checking whether all elements of \texttt{x} and \texttt{y} are approximately equal component-wise.

The binary operator \texttt{≈} is equivalent to \texttt{isapprox} with the default arguments, and \texttt{x ≉ y} is equivalent to \texttt{!isapprox(x,y)}.


\begin{minted}{jlcon}
julia> 0.1 ≈ (0.1 - 1e-10)
true

julia> isapprox(10, 11; atol = 2)
true

julia> isapprox([10.0^9, 1.0], [10.0^9, 2.0])
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/floatfuncs.jl#L173-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1413692256182243634}{} 
\hyperlink{1413692256182243634}{\texttt{Base.sin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sin(x)
\end{lstlisting}

Compute sine of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L303-L307}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3839439755891439510}{} 
\hyperlink{3839439755891439510}{\texttt{Base.cos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cos(x)
\end{lstlisting}

Compute cosine of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L310-L314}{\texttt{source}}


\end{adjustwidth}
\hypertarget{875859158779400131}{} 
\hyperlink{875859158779400131}{\texttt{Base.tan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tan(x)
\end{lstlisting}

Compute tangent of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L317-L321}{\texttt{source}}


\end{adjustwidth}
\hypertarget{38337471195460170}{} 
\hyperlink{38337471195460170}{\texttt{Base.Math.sind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sind(x)
\end{lstlisting}

Compute sine of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L413-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6437354581891939537}{} 
\hyperlink{6437354581891939537}{\texttt{Base.Math.cosd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cosd(x)
\end{lstlisting}

Compute cosine of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L413-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10125316154174803495}{} 
\hyperlink{10125316154174803495}{\texttt{Base.Math.tand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tand(x)
\end{lstlisting}

Compute tangent of \texttt{x}, where \texttt{x} is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L413-L415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16554510911661822298}{} 
\hyperlink{16554510911661822298}{\texttt{Base.Math.sinpi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sinpi(x)
\end{lstlisting}

Compute \(\sin(\pi x)\) more accurately than \texttt{sin(pi*x)}, especially for large \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L101-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2974547424856180253}{} 
\hyperlink{2974547424856180253}{\texttt{Base.Math.cospi}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cospi(x)
\end{lstlisting}

Compute \(\cos(\pi x)\) more accurately than \texttt{cos(pi*x)}, especially for large \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L164-L168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5181646255621667089}{} 
\hyperlink{5181646255621667089}{\texttt{Base.sinh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sinh(x)
\end{lstlisting}

Compute hyperbolic sine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L195-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3329134313078667573}{} 
\hyperlink{3329134313078667573}{\texttt{Base.cosh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cosh(x)
\end{lstlisting}

Compute hyperbolic cosine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L202-L206}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11556677775153310560}{} 
\hyperlink{11556677775153310560}{\texttt{Base.tanh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tanh(x)
\end{lstlisting}

Compute hyperbolic tangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L209-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2780084174302963520}{} 
\hyperlink{2780084174302963520}{\texttt{Base.asin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asin(x)
\end{lstlisting}

Compute the inverse sine of \texttt{x}, where the output is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L324-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9075308317485607956}{} 
\hyperlink{9075308317485607956}{\texttt{Base.acos}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acos(x)
\end{lstlisting}

Compute the inverse cosine of \texttt{x}, where the output is in radians



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L331-L335}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7954015677485259843}{} 
\hyperlink{7954015677485259843}{\texttt{Base.atan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atan(x)
\end{lstlisting}

Compute the inverse tangent of \texttt{x}, where the output is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L216-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14548930143416451643}{} 
\hyperlink{14548930143416451643}{\texttt{Base.Math.atan2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atan2(y, x)
\end{lstlisting}

Compute the inverse tangent of \texttt{y/x}, using the signs of both \texttt{x} and \texttt{y} to determine the quadrant of the return value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L488-L493}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11304354062744129101}{} 
\hyperlink{11304354062744129101}{\texttt{Base.Math.asind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asind(x)
\end{lstlisting}

Compute the inverse sine of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9068426203671659431}{} 
\hyperlink{9068426203671659431}{\texttt{Base.Math.acosd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acosd(x)
\end{lstlisting}

Compute the inverse cosine of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16709452940889335182}{} 
\hyperlink{16709452940889335182}{\texttt{Base.Math.atand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atand(x)
\end{lstlisting}

Compute the inverse tangent of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14099135455017918456}{} 
\hyperlink{14099135455017918456}{\texttt{Base.Math.sec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sec(x)
\end{lstlisting}

Compute the secant of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1895-L1899}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4884849677881797647}{} 
\hyperlink{4884849677881797647}{\texttt{Base.Math.csc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
csc(x)
\end{lstlisting}

Compute the cosecant of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1462-L1466}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3862797501947473111}{} 
\hyperlink{3862797501947473111}{\texttt{Base.Math.cot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cot(x)
\end{lstlisting}

Compute the cotangent of \texttt{x}, where \texttt{x} is in radians.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1411-L1415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3627927627858191087}{} 
\hyperlink{3627927627858191087}{\texttt{Base.Math.secd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
secd(x)
\end{lstlisting}

Compute the secant of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1815-L1819}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5282241990933081613}{} 
\hyperlink{5282241990933081613}{\texttt{Base.Math.cscd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cscd(x)
\end{lstlisting}

Compute the cosecant of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2471-L2475}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10552388625489786427}{} 
\hyperlink{10552388625489786427}{\texttt{Base.Math.cotd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cotd(x)
\end{lstlisting}

Compute the cotangent of \texttt{x}, where \texttt{x} is in degrees.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1537-L1541}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11957141737062775737}{} 
\hyperlink{11957141737062775737}{\texttt{Base.Math.asec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asec(x)
\end{lstlisting}

Compute the inverse secant of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L323-L325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4883715079741069599}{} 
\hyperlink{4883715079741069599}{\texttt{Base.Math.acsc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acsc(x)
\end{lstlisting}

Compute the inverse cosecant of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L323-L325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15052830344020086660}{} 
\hyperlink{15052830344020086660}{\texttt{Base.Math.acot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acot(x)
\end{lstlisting}

Compute the inverse cotangent of \texttt{x}, where the output is in radians. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L323-L325}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11130798465735678102}{} 
\hyperlink{11130798465735678102}{\texttt{Base.Math.asecd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asecd(x)
\end{lstlisting}

Compute the inverse secant of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4156782540452156093}{} 
\hyperlink{4156782540452156093}{\texttt{Base.Math.acscd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acscd(x)
\end{lstlisting}

Compute the inverse cosecant of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8127927203221847430}{} 
\hyperlink{8127927203221847430}{\texttt{Base.Math.acotd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acotd(x)
\end{lstlisting}

Compute the inverse cotangent of \texttt{x}, where the output is in degrees. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6710905779265456786}{} 
\hyperlink{6710905779265456786}{\texttt{Base.Math.sech}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sech(x)
\end{lstlisting}

Compute the hyperbolic secant of \texttt{x}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L190-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12699005275601525751}{} 
\hyperlink{12699005275601525751}{\texttt{Base.Math.csch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
csch(x)
\end{lstlisting}

Compute the hyperbolic cosecant of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1888-L1892}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15539047088574298259}{} 
\hyperlink{15539047088574298259}{\texttt{Base.Math.coth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
coth(x)
\end{lstlisting}

Compute the hyperbolic cotangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2112-L2116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15539429965228872041}{} 
\hyperlink{15539429965228872041}{\texttt{Base.asinh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asinh(x)
\end{lstlisting}

Compute the inverse hyperbolic sine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L223-L227}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16766917678182986345}{} 
\hyperlink{16766917678182986345}{\texttt{Base.acosh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acosh(x)
\end{lstlisting}

Compute the inverse hyperbolic cosine of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L338-L342}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7005502320333033073}{} 
\hyperlink{7005502320333033073}{\texttt{Base.atanh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
atanh(x)
\end{lstlisting}

Compute the inverse hyperbolic tangent of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L345-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7333053894423460686}{} 
\hyperlink{7333053894423460686}{\texttt{Base.Math.asech}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asech(x)
\end{lstlisting}

Compute the inverse hyperbolic secant of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L326-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1665506352762766435}{} 
\hyperlink{1665506352762766435}{\texttt{Base.Math.acsch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acsch(x)
\end{lstlisting}

Compute the inverse hyperbolic cosecant of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L326-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6288003572537523273}{} 
\hyperlink{6288003572537523273}{\texttt{Base.Math.acoth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acoth(x)
\end{lstlisting}

Compute the inverse hyperbolic cotangent of \texttt{x}. 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L326-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16625449660258120296}{} 
\hyperlink{16625449660258120296}{\texttt{Base.Math.sinc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sinc(x)
\end{lstlisting}

Compute \(\sin(\pi x) / (\pi x)\) if \(x \neq 0\), and \(1\) if \(x = 0\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L288-L292}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16278225468798010360}{} 
\hyperlink{16278225468798010360}{\texttt{Base.Math.cosc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cosc(x)
\end{lstlisting}

Compute \(\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)\) if \(x \neq 0\), and \(0\) if \(x = 0\). This is the derivative of \texttt{sinc(x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L298-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11016541033238436876}{} 
\hyperlink{11016541033238436876}{\texttt{Base.Math.deg2rad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deg2rad(x)
\end{lstlisting}

Convert \texttt{x} from degrees to radians.


\begin{minted}{jlcon}
julia> deg2rad(90)
1.5707963267948966
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L145-L154}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17164560583584594903}{} 
\hyperlink{17164560583584594903}{\texttt{Base.Math.rad2deg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rad2deg(x)
\end{lstlisting}

Convert \texttt{x} from radians to degrees.


\begin{minted}{jlcon}
julia> rad2deg(pi)
180.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L133-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18304489571285447949}{} 
\hyperlink{18304489571285447949}{\texttt{Base.Math.hypot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hypot(x, y)
\end{lstlisting}

Compute the hypotenuse \(\sqrt{x^2+y^2}\) avoiding overflow and underflow.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = 10^10;

julia> hypot(a, a)
1.4142135623730951e10

julia> √(a^2 + a^2) # a^2 overflows
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Int64) at ./math.jl:434
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L436-L454}{\texttt{source}}



\begin{lstlisting}
hypot(x...)
\end{lstlisting}

Compute the hypotenuse \(\sqrt{\sum x_i^2}\) avoiding overflow and underflow.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L481-L485}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8009828793607756367}{} 
\hyperlink{8009828793607756367}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log(x)
\end{lstlisting}

Compute the natural logarithm of \texttt{x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments. Use complex negative arguments to obtain complex results.

There is an experimental variant in the \texttt{Base.Math.JuliaLibm} module, which is typically faster and more accurate.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L352-L360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10582107494419543982}{} 
\hyperlink{10582107494419543982}{\texttt{Base.log}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log(b,x)
\end{lstlisting}

Compute the base \texttt{b} logarithm of \texttt{x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.


\begin{minted}{jlcon}
julia> log(4,8)
1.5

julia> log(4,2)
0.5
\end{minted}

\begin{quote}
\textbf{Note}

If \texttt{b} is a power of 2 or 10, \hyperlink{18341149201477905713}{\texttt{log2}} or \hyperlink{3481560771470480868}{\texttt{log10}} should be used, as these will typically be faster and more accurate. For example,


\begin{minted}{jlcon}
julia> log(100,1000000)
2.9999999999999996

julia> log10(1000000)/2
3.0
\end{minted}

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L161-L186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18341149201477905713}{} 
\hyperlink{18341149201477905713}{\texttt{Base.log2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log2(x)
\end{lstlisting}

Compute the logarithm of \texttt{x} to base 2. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Example}


\begin{minted}{jlcon}
julia> log2(4)
2.0

julia> log2(10)
3.321928094887362
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L363-L377}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3481560771470480868}{} 
\hyperlink{3481560771470480868}{\texttt{Base.log10}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log10(x)
\end{lstlisting}

Compute the logarithm of \texttt{x} to base 10. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments.

\textbf{Example}


\begin{minted}{jlcon}
julia> log10(100)
2.0

julia> log10(2)
0.3010299956639812
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L380-L394}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5533050447473188877}{} 
\hyperlink{5533050447473188877}{\texttt{Base.log1p}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
log1p(x)
\end{lstlisting}

Accurate natural logarithm of \texttt{1+x}. Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for \hyperlink{6175959395021454412}{\texttt{Real}} arguments less than -1.

There is an experimental variant in the \texttt{Base.Math.JuliaLibm} module, which is typically faster and more accurate.

\textbf{Examples}


\begin{minted}{jlcon}
julia> log1p(-0.5)
-0.6931471805599453

julia> log1p(0)
0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L397-L414}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12570003490345822061}{} 
\hyperlink{12570003490345822061}{\texttt{Base.Math.frexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
frexp(val)
\end{lstlisting}

Return \texttt{(x,exp)} such that \texttt{x} has a magnitude in the interval \([1/2, 1)\) or 0, and \texttt{val} is equal to \(x \times 2^{exp}\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L614-L619}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5754159997488499390}{} 
\hyperlink{5754159997488499390}{\texttt{Base.exp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exp(x)
\end{lstlisting}

Compute the natural base exponential of \texttt{x}, in other words \(e^x\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/exp.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12542609616026627164}{} 
\hyperlink{12542609616026627164}{\texttt{Base.exp2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exp2(x)
\end{lstlisting}

Compute \(2^x\).


\begin{minted}{jlcon}
julia> exp2(5)
32.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L262-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4510833300532946775}{} 
\hyperlink{4510833300532946775}{\texttt{Base.exp10}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exp10(x)
\end{lstlisting}

Compute \(10^x\).

\textbf{Examples}


\begin{minted}{jlcon}
julia> exp10(2)
100.0

julia> exp10(0.2)
1.5848931924611136
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L623-L636}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14721177606508229464}{} 
\hyperlink{14721177606508229464}{\texttt{Base.Math.ldexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ldexp(x, n)
\end{lstlisting}

Compute \(x \times 2^n\).

\textbf{Example}


\begin{minted}{jlcon}
julia> ldexp(5., 2)
20.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L512-L522}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7336011242447784962}{} 
\hyperlink{7336011242447784962}{\texttt{Base.Math.modf}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
modf(x)
\end{lstlisting}

Return a tuple (fpart,ipart) of the fractional and integral parts of a number. Both parts have the same sign as the argument.

\textbf{Example}


\begin{minted}{jlcon}
julia> modf(3.5)
(0.5, 3.0)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L673-L684}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4939309737829480377}{} 
\hyperlink{4939309737829480377}{\texttt{Base.expm1}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
expm1(x)
\end{lstlisting}

Accurately compute \(e^x-1\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L230-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12930779325193350739}{} 
\hyperlink{12930779325193350739}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
round([T,] x, [digits, [base]], [r::RoundingMode])
\end{lstlisting}

Rounds \texttt{x} to an integer value according to the provided \hyperlink{16713322195952720212}{\texttt{RoundingMode}}, returning a value of the same type as \texttt{x}. When not specifying a rounding mode the global mode will be used (see \hyperlink{6511778857518292792}{\texttt{rounding}}), which by default is round to the nearest integer (\hyperlink{868115654703135309}{\texttt{RoundNearest}} mode), with ties (fractional values of 0.5) being rounded to the nearest even integer.


\begin{minted}{jlcon}
julia> round(1.7)
2.0

julia> round(1.5)
2.0

julia> round(2.5)
2.0
\end{minted}

The optional \hyperlink{16713322195952720212}{\texttt{RoundingMode}} argument will change how the number gets rounded.

\texttt{round(T, x, [r::RoundingMode])} converts the result to type \texttt{T}, throwing an \hyperlink{5399118524830636312}{\texttt{InexactError}} if the value is not representable.

\texttt{round(x, digits)} rounds to the specified number of digits after the decimal place (or before if negative). \texttt{round(x, digits, base)} rounds using a base other than 10.


\begin{minted}{jlcon}
julia> round(pi, 2)
3.14

julia> round(pi, 3, 2)
3.125
\end{minted}

\begin{quote}
\textbf{Note}

Rounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the \hyperlink{5027751419500983000}{\texttt{Float64}} value represented by \texttt{1.15} is actually \emph{less} than 1.15, yet will be rounded to 1.2.


\begin{minted}{jlcon}
julia> x = 1.15
1.15

julia> @sprintf "%.20f" x
"1.14999999999999991118"

julia> x < 115//100
true

julia> round(x, 1)
1.2
\end{minted}

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/floatfuncs.jl#L42-L99}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16713322195952720212}{} 
\hyperlink{16713322195952720212}{\texttt{Base.Rounding.RoundingMode}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundingMode
\end{lstlisting}

A type used for controlling the rounding mode of floating point operations (via \hyperlink{6511778857518292792}{\texttt{rounding}}/\hyperlink{12025922235501343815}{\texttt{setrounding}} functions), or as optional arguments for rounding to the nearest integer (via the \hyperlink{7894166454005036294}{\texttt{round}} function).

Currently supported rounding modes are:

\begin{itemize}
\item \hyperlink{868115654703135309}{\texttt{RoundNearest}} (default)


\item \hyperlink{975776970636292472}{\texttt{RoundNearestTiesAway}}


\item \hyperlink{9147917195826641690}{\texttt{RoundNearestTiesUp}}


\item \hyperlink{7760059079134067537}{\texttt{RoundToZero}}


\item \texttt{RoundFromZero} (\hyperlink{749816618809421837}{\texttt{BigFloat}} only)


\item \hyperlink{874246484265932239}{\texttt{RoundUp}}


\item \hyperlink{3648739763580508258}{\texttt{RoundDown}}

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L26-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{868115654703135309}{} 
\hyperlink{868115654703135309}{\texttt{Base.Rounding.RoundNearest}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundNearest
\end{lstlisting}

The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L46-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{975776970636292472}{} 
\hyperlink{975776970636292472}{\texttt{Base.Rounding.RoundNearestTiesAway}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundNearestTiesAway
\end{lstlisting}

Rounds to nearest integer, with ties rounded away from zero (C/C++ \hyperlink{7894166454005036294}{\texttt{round}} behaviour).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L77-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9147917195826641690}{} 
\hyperlink{9147917195826641690}{\texttt{Base.Rounding.RoundNearestTiesUp}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundNearestTiesUp
\end{lstlisting}

Rounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript \hyperlink{7894166454005036294}{\texttt{round}} behaviour).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L85-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7760059079134067537}{} 
\hyperlink{7760059079134067537}{\texttt{Base.Rounding.RoundToZero}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundToZero
\end{lstlisting}

\hyperlink{7894166454005036294}{\texttt{round}} using this rounding mode is an alias for \hyperlink{1728363361565303194}{\texttt{trunc}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{874246484265932239}{} 
\hyperlink{874246484265932239}{\texttt{Base.Rounding.RoundUp}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundUp
\end{lstlisting}

\hyperlink{7894166454005036294}{\texttt{round}} using this rounding mode is an alias for \hyperlink{10519509038312853061}{\texttt{ceil}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L61-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3648739763580508258}{} 
\hyperlink{3648739763580508258}{\texttt{Base.Rounding.RoundDown}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RoundDown
\end{lstlisting}

\hyperlink{7894166454005036294}{\texttt{round}} using this rounding mode is an alias for \hyperlink{11115257331910840693}{\texttt{floor}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L68-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17596897159817666741}{} 
\hyperlink{17596897159817666741}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
round(z, RoundingModeReal, RoundingModeImaginary)
\end{lstlisting}

Returns the nearest integral value of the same type as the complex-valued \texttt{z} to \texttt{z}, breaking ties using the specified \hyperlink{16713322195952720212}{\texttt{RoundingMode}}s. The first \hyperlink{16713322195952720212}{\texttt{RoundingMode}} is used for rounding the real components while the second is used for rounding the imaginary components.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L876-L883}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10519509038312853061}{} 
\hyperlink{10519509038312853061}{\texttt{Base.ceil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ceil([T,] x, [digits, [base]])
\end{lstlisting}

\texttt{ceil(x)} returns the nearest integral value of the same type as \texttt{x} that is greater than or equal to \texttt{x}.

\texttt{ceil(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits} and \texttt{base} work as for \hyperlink{7894166454005036294}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L364-L374}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11115257331910840693}{} 
\hyperlink{11115257331910840693}{\texttt{Base.floor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
floor([T,] x, [digits, [base]])
\end{lstlisting}

\texttt{floor(x)} returns the nearest integral value of the same type as \texttt{x} that is less than or equal to \texttt{x}.

\texttt{floor(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits} and \texttt{base} work as for \hyperlink{7894166454005036294}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L680-L690}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1728363361565303194}{} 
\hyperlink{1728363361565303194}{\texttt{Base.trunc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trunc([T,] x, [digits, [base]])
\end{lstlisting}

\texttt{trunc(x)} returns the nearest integral value of the same type as \texttt{x} whose absolute value is less than or equal to \texttt{x}.

\texttt{trunc(T, x)} converts the result to type \texttt{T}, throwing an \texttt{InexactError} if the value is not representable.

\texttt{digits} and \texttt{base} work as for \hyperlink{7894166454005036294}{\texttt{round}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1024-L1034}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6382984648980626356}{} 
\hyperlink{6382984648980626356}{\texttt{Base.unsafe\_trunc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_trunc(T, x)
\end{lstlisting}

\texttt{unsafe\_trunc(T, x)} returns the nearest integral value of type \texttt{T} whose absolute value is less than or equal to \texttt{x}. If the value is not representable by \texttt{T}, an arbitrary value will be returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1789-L1795}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11117199371278593126}{} 
\hyperlink{11117199371278593126}{\texttt{Base.signif}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
signif(x, digits, [base])
\end{lstlisting}

Rounds (in the sense of \hyperlink{7894166454005036294}{\texttt{round}}) \texttt{x} so that there are \texttt{digits} significant digits, under a base \texttt{base} representation, default 10. E.g., \texttt{signif(123.456, 2)} is \texttt{120.0}, and \texttt{signif(357.913, 4, 2)} is \texttt{352.0}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2303-L2309}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7458766354532817148}{} 
\hyperlink{7458766354532817148}{\texttt{Base.min}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
min(x, y, ...)
\end{lstlisting}

Return the minimum of the arguments. See also the \hyperlink{5463833925251886106}{\texttt{minimum}} function to take the minimum element from a collection.


\begin{minted}{jlcon}
julia> min(2, 5, 1)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L350-L360}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7839419811914289844}{} 
\hyperlink{7839419811914289844}{\texttt{Base.max}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
max(x, y, ...)
\end{lstlisting}

Return the maximum of the arguments. See also the \hyperlink{10566500735406837086}{\texttt{maximum}} function to take the maximum element from a collection.


\begin{minted}{jlcon}
julia> max(2, 5, 1)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L337-L347}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9004904914922806611}{} 
\hyperlink{9004904914922806611}{\texttt{Base.minmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minmax(x, y)
\end{lstlisting}

Return \texttt{(min(x,y), max(x,y))}. See also: \hyperlink{3146721823766527688}{\texttt{extrema}} that returns \texttt{(minimum(x), maximum(x))}.


\begin{minted}{jlcon}
julia> minmax('c','b')
('b', 'c')
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L363-L372}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2549437629093220350}{} 
\hyperlink{2549437629093220350}{\texttt{Base.Math.clamp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clamp(x, lo, hi)
\end{lstlisting}

Return \texttt{x} if \texttt{lo <= x <= hi}. If \texttt{x < lo}, return \texttt{lo}. If \texttt{x > hi}, return \texttt{hi}. Arguments are promoted to a common type.


\begin{minted}{jlcon}
julia> clamp.([pi, 1.0, big(10.)], 2., 9.)
3-element Array{BigFloat,1}:
 3.141592653589793238462643383279502884197169399375105820974944592307816406286198
 2.000000000000000000000000000000000000000000000000000000000000000000000000000000
 9.000000000000000000000000000000000000000000000000000000000000000000000000000000
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L42-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15974741233540534893}{} 
\hyperlink{15974741233540534893}{\texttt{Base.Math.clamp!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clamp!(array::AbstractArray, lo, hi)
\end{lstlisting}

Restrict values in \texttt{array} to the specified range, in-place. See also \hyperlink{2549437629093220350}{\texttt{clamp}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L62-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9614495866226399167}{} 
\hyperlink{9614495866226399167}{\texttt{Base.abs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
abs(x)
\end{lstlisting}

The absolute value of \texttt{x}.

When \texttt{abs} is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when \texttt{abs} is applied to the minimum representable value of a signed integer. That is, when \texttt{x == typemin(typeof(x))}, \texttt{abs(x) == x < 0}, not \texttt{-x} as might be expected.


\begin{minted}{jlcon}
julia> abs(-3)
3

julia> abs(1 + im)
1.4142135623730951

julia> abs(typemin(Int64))
-9223372036854775808
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L87-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10885135672778604809}{} 
\hyperlink{10885135672778604809}{\texttt{Base.Checked.checked\_abs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_abs(x)
\end{lstlisting}

Calculates \texttt{abs(x)}, checking for overflow errors where applicable. For example, standard two{\textquotesingle}s complement signed integers (e.g. \texttt{Int}) cannot represent \texttt{abs(typemin(Int))}, thus leading to an overflow.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L107-L115}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13229568824844995103}{} 
\hyperlink{13229568824844995103}{\texttt{Base.Checked.checked\_neg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_neg(x)
\end{lstlisting}

Calculates \texttt{-x}, checking for overflow errors where applicable. For example, standard two{\textquotesingle}s complement signed integers (e.g. \texttt{Int}) cannot represent \texttt{-typemin(Int)}, thus leading to an overflow.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L81-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2964592337942314373}{} 
\hyperlink{2964592337942314373}{\texttt{Base.Checked.checked\_add}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_add(x, y)
\end{lstlisting}

Calculates \texttt{x+y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L155-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10268341695343039853}{} 
\hyperlink{10268341695343039853}{\texttt{Base.Checked.checked\_sub}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_sub(x, y)
\end{lstlisting}

Calculates \texttt{x-y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L212-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4390963153143215118}{} 
\hyperlink{4390963153143215118}{\texttt{Base.Checked.checked\_mul}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_mul(x, y)
\end{lstlisting}

Calculates \texttt{x*y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L277-L283}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6689390039928836022}{} 
\hyperlink{6689390039928836022}{\texttt{Base.Checked.checked\_div}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_div(x, y)
\end{lstlisting}

Calculates \texttt{div(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L306-L312}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12129844323919398781}{} 
\hyperlink{12129844323919398781}{\texttt{Base.Checked.checked\_rem}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_rem(x, y)
\end{lstlisting}

Calculates \texttt{x\%y}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L315-L321}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3745431966407804814}{} 
\hyperlink{3745431966407804814}{\texttt{Base.Checked.checked\_fld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_fld(x, y)
\end{lstlisting}

Calculates \texttt{fld(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L324-L330}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2512435134040972090}{} 
\hyperlink{2512435134040972090}{\texttt{Base.Checked.checked\_mod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_mod(x, y)
\end{lstlisting}

Calculates \texttt{mod(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L333-L339}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1863194407625991652}{} 
\hyperlink{1863194407625991652}{\texttt{Base.Checked.checked\_cld}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.checked_cld(x, y)
\end{lstlisting}

Calculates \texttt{cld(x,y)}, checking for overflow errors where applicable.

The overflow protection may impose a perceptible performance penalty.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L342-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862869478194651358}{} 
\hyperlink{8862869478194651358}{\texttt{Base.Checked.add\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.add_with_overflow(x, y) -> (r, f)
\end{lstlisting}

Calculates \texttt{r = x+y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L128-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2951243344761333492}{} 
\hyperlink{2951243344761333492}{\texttt{Base.Checked.sub\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.sub_with_overflow(x, y) -> (r, f)
\end{lstlisting}

Calculates \texttt{r = x-y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L187-L191}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9052860252825488939}{} 
\hyperlink{9052860252825488939}{\texttt{Base.Checked.mul\_with\_overflow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.mul_with_overflow(x, y) -> (r, f)
\end{lstlisting}

Calculates \texttt{r = x*y}, with the flag \texttt{f} indicating whether overflow has occurred.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L227-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15686257922156163743}{} 
\hyperlink{15686257922156163743}{\texttt{Base.abs2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
abs2(x)
\end{lstlisting}

Squared absolute value of \texttt{x}.


\begin{minted}{jlcon}
julia> abs2(-3)
9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L84-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6024566200716053110}{} 
\hyperlink{6024566200716053110}{\texttt{Base.copysign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copysign(x, y) -> z
\end{lstlisting}

Return \texttt{z} which has the magnitude of \texttt{x} and the same sign as \texttt{y}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> copysign(1, -2)
-1

julia> copysign(-1, 2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L799-L812}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14349105033929355161}{} 
\hyperlink{14349105033929355161}{\texttt{Base.sign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sign(x)
\end{lstlisting}

Return zero if \texttt{x==0} and \(x/|x|\) otherwise (i.e., ±1 for real \texttt{x}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L74-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9457038569823603490}{} 
\hyperlink{9457038569823603490}{\texttt{Base.signbit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
signbit(x)
\end{lstlisting}

Returns \texttt{true} if the value of the sign of \texttt{x} is negative, otherwise \texttt{false}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> signbit(-4)
true

julia> signbit(5)
false

julia> signbit(5.5)
false

julia> signbit(-4.1)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2449-L2468}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2689022981470151558}{} 
\hyperlink{2689022981470151558}{\texttt{Base.flipsign}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flipsign(x, y)
\end{lstlisting}

Return \texttt{x} with its sign flipped if \texttt{y} is negative. For example \texttt{abs(x) = flipsign(x,x)}.


\begin{minted}{jlcon}
julia> flipsign(5, 3)
5

julia> flipsign(5, -3)
-5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L96-L108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4178506499510800909}{} 
\hyperlink{4178506499510800909}{\texttt{Base.sqrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sqrt(x)
\end{lstlisting}

Return \(\sqrt{x}\). Throws \hyperlink{14085880504701688639}{\texttt{DomainError}} for negative \hyperlink{6175959395021454412}{\texttt{Real}} arguments. Use complex negative arguments instead. The prefix operator \texttt{√} is equivalent to \texttt{sqrt}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L428-L433}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13061326033497045577}{} 
\hyperlink{13061326033497045577}{\texttt{Base.isqrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isqrt(n::Integer)
\end{lstlisting}

Integer square root: the largest integer \texttt{m} such that \texttt{m*m <= n}.


\begin{minted}{jlcon}
julia> isqrt(5)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L745-L754}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15104025502404840355}{} 
\hyperlink{15104025502404840355}{\texttt{Base.Math.cbrt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cbrt(x::Real)
\end{lstlisting}

Return the cube root of \texttt{x}, i.e. \(x^{1/3}\). Negative values are accepted (returning the negative real root when \(x < 0\)).

The prefix operator \texttt{∛} is equivalent to \texttt{cbrt}.


\begin{minted}{jlcon}
julia> cbrt(big(27))
3.000000000000000000000000000000000000000000000000000000000000000000000000000000
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L247-L259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10579540000886584250}{} 
\hyperlink{10579540000886584250}{\texttt{Base.real}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
real(z)
\end{lstlisting}

Return the real part of the complex number \texttt{z}.


\begin{minted}{jlcon}
julia> real(1 + 3im)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L44-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13331686588901351068}{} 
\hyperlink{13331686588901351068}{\texttt{Base.imag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
imag(z)
\end{lstlisting}

Return the imaginary part of the complex number \texttt{z}.


\begin{minted}{jlcon}
julia> imag(1 + 3im)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L56-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4559968878634602058}{} 
\hyperlink{4559968878634602058}{\texttt{Base.reim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reim(z)
\end{lstlisting}

Return both the real and imaginary parts of the complex number \texttt{z}.


\begin{minted}{jlcon}
julia> reim(1 + 3im)
(1, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L70-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9940023991150673697}{} 
\hyperlink{9940023991150673697}{\texttt{Base.conj}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
conj(z)
\end{lstlisting}

Compute the complex conjugate of a complex number \texttt{z}.


\begin{minted}{jlcon}
julia> conj(1 + 3im)
1 - 3im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L204-L213}{\texttt{source}}



\begin{lstlisting}
conj(v::RowVector)
\end{lstlisting}

Returns a \hyperlink{5185144354217809072}{\texttt{ConjArray}} lazy view of the input, where each element is conjugated.

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [1+im, 1-im].'
1×2 RowVector{Complex{Int64},Array{Complex{Int64},1}}:
 1+1im  1-1im

julia> conj(v)
1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:
 1-1im  1+1im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/rowvector.jl#L88-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9465547375318501186}{} 
\hyperlink{9465547375318501186}{\texttt{Base.angle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
angle(z)
\end{lstlisting}

Compute the phase angle in radians of a complex number \texttt{z}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L444-L448}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4687572676090761946}{} 
\hyperlink{4687572676090761946}{\texttt{Base.cis}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cis(z)
\end{lstlisting}

Return \(\exp(iz)\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L434-L438}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7127784108654808529}{} 
\hyperlink{7127784108654808529}{\texttt{Base.binomial}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
binomial(n, k)
\end{lstlisting}

Number of ways to choose \texttt{k} out of \texttt{n} items.

\textbf{Example}


\begin{minted}{jlcon}
julia> binomial(5, 3)
10

julia> factorial(5) ÷ (factorial(5-3) * factorial(3))
10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L776-L789}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1793920701415589315}{} 
\hyperlink{1793920701415589315}{\texttt{Base.factorial}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
factorial(n)
\end{lstlisting}

Factorial of \texttt{n}. If \texttt{n} is an \hyperlink{8469131683393450448}{\texttt{Integer}}, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if \texttt{n} is not small, but you can use \texttt{factorial(big(n))} to compute the result exactly in arbitrary precision. If \texttt{n} is not an \texttt{Integer}, \texttt{factorial(n)} is equivalent to \hyperlink{12101057483100859108}{\texttt{gamma(n+1)}}.


\begin{minted}{jlcon}
julia> factorial(6)
720

julia> factorial(21)
ERROR: OverflowError()
[...]

julia> factorial(21.0)
5.109094217170944e19

julia> factorial(big(21))
51090942171709440000
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L216-L238}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15906911311436241979}{} 
\hyperlink{15906911311436241979}{\texttt{Base.gcd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gcd(x,y)
\end{lstlisting}

Greatest common (positive) divisor (or zero if \texttt{x} and \texttt{y} are both zero).

\textbf{Examples}


\begin{minted}{jlcon}
julia> gcd(6,9)
3

julia> gcd(6,-9)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L5-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12975400110924105221}{} 
\hyperlink{12975400110924105221}{\texttt{Base.lcm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lcm(x,y)
\end{lstlisting}

Least common (non-negative) multiple.

\textbf{Examples}


\begin{minted}{jlcon}
julia> lcm(2,3)
6

julia> lcm(-2,3)
6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L51-L64}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18359524628605105681}{} 
\hyperlink{18359524628605105681}{\texttt{Base.gcdx}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gcdx(x,y)
\end{lstlisting}

Computes the greatest common (positive) divisor of \texttt{x} and \texttt{y} and their Bézout coefficients, i.e. the integer coefficients \texttt{u} and \texttt{v} that satisfy \(ux+vy = d = gcd(x,y)\). \(gcdx(x,y)\) returns \((d,u,v)\).

\textbf{Examples}


\begin{minted}{jlcon}
julia> gcdx(12, 42)
(6, -3, 1)

julia> gcdx(240, 46)
(2, -9, 47)
\end{minted}

\begin{quote}
\textbf{Note}

Bézout coefficients are \emph{not} uniquely defined. \texttt{gcdx} returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients \texttt{u} and \texttt{v} are minimal in the sense that \(|u| < |y/d|\) and \(|v| < |x/d|\). Furthermore, the signs of \texttt{u} and \texttt{v} are chosen so that \texttt{d} is positive. For unsigned integers, the coefficients \texttt{u} and \texttt{v} might be near their \texttt{typemax}, and the identity then holds only via the unsigned integers{\textquotesingle} modulo arithmetic.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L85-L111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{598817088840034027}{} 
\hyperlink{598817088840034027}{\texttt{Base.ispow2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ispow2(n::Integer) -> Bool
\end{lstlisting}

Test whether \texttt{n} is a power of two.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ispow2(4)
true

julia> ispow2(5)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L311-L324}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4594482809725895873}{} 
\hyperlink{4594482809725895873}{\texttt{Base.nextpow2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextpow2(n::Integer)
\end{lstlisting}

The smallest power of two not less than \texttt{n}. Returns 0 for \texttt{n==0}, and returns \texttt{-nextpow2(-n)} for negative arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nextpow2(16)
16

julia> nextpow2(17)
32
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L275-L289}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16846138768010848855}{} 
\hyperlink{16846138768010848855}{\texttt{Base.prevpow2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prevpow2(n::Integer)
\end{lstlisting}

The largest power of two not greater than \texttt{n}. Returns 0 for \texttt{n==0}, and returns \texttt{-prevpow2(-n)} for negative arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prevpow2(5)
4

julia> prevpow2(0)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L293-L307}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14955572944376366290}{} 
\hyperlink{14955572944376366290}{\texttt{Base.nextpow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextpow(a, x)
\end{lstlisting}

The smallest \texttt{a{\textasciicircum}n} not less than \texttt{x}, where \texttt{n} is a non-negative integer. \texttt{a} must be greater than 1, and \texttt{x} must be greater than 0.

\textbf{Examples}


\begin{minted}{jlcon}
julia> nextpow(2, 7)
8

julia> nextpow(2, 9)
16

julia> nextpow(5, 20)
25

julia> nextpow(4, 16)
16
\end{minted}

See also \hyperlink{488025580584649031}{\texttt{prevpow}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L327-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{488025580584649031}{} 
\hyperlink{488025580584649031}{\texttt{Base.prevpow}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prevpow(a, x)
\end{lstlisting}

The largest \texttt{a{\textasciicircum}n} not greater than \texttt{x}, where \texttt{n} is a non-negative integer. \texttt{a} must be greater than 1, and \texttt{x} must not be less than 1.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prevpow(2, 7)
4

julia> prevpow(2, 9)
8

julia> prevpow(5, 20)
5

julia> prevpow(4, 16)
16
\end{minted}

See also \hyperlink{14955572944376366290}{\texttt{nextpow}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L359-L380}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9591900175500358341}{} 
\hyperlink{9591900175500358341}{\texttt{Base.nextprod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextprod([k_1, k_2,...], n)
\end{lstlisting}

Next integer greater than or equal to \texttt{n} that can be written as \(\prod k_i^{p_i}\) for integers \(p_1\), \(p_2\), etc.

\textbf{Example}


\begin{minted}{jlcon}
julia> nextprod([2, 3], 105)
108

julia> 2^2 * 3^3
108
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L234-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17191792848451148355}{} 
\hyperlink{17191792848451148355}{\texttt{Base.invmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
invmod(x,m)
\end{lstlisting}

Take the inverse of \texttt{x} modulo \texttt{m}: \texttt{y} such that \(x y = 1 \pmod m\), with \(div(x,y) = 0\). This is undefined for \(m = 0\), or if \(gcd(x,m) \neq 1\).

\textbf{Examples}


\begin{minted}{jlcon}
julia> invmod(2,5)
3

julia> invmod(2,3)
2

julia> invmod(5,6)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L129-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5886563157147453257}{} 
\hyperlink{5886563157147453257}{\texttt{Base.powermod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
powermod(x::Integer, p::Integer, m)
\end{lstlisting}

Compute \(x^p \pmod m\).

\textbf{Examples}


\begin{minted}{jlcon}
julia> powermod(2, 6, 5)
4

julia> mod(2^6, 5)
4

julia> powermod(5, 2, 20)
5

julia> powermod(5, 2, 19)
6

julia> powermod(5, 3, 19)
11
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L226-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12101057483100859108}{} 
\hyperlink{12101057483100859108}{\texttt{Base.Math.gamma}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gamma(x)
\end{lstlisting}

Compute the gamma function of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L6-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16944460120463679422}{} 
\hyperlink{16944460120463679422}{\texttt{Base.Math.lgamma}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lgamma(x)
\end{lstlisting}

Compute the logarithm of the absolute value of \hyperlink{12101057483100859108}{\texttt{gamma}} for \hyperlink{6175959395021454412}{\texttt{Real}} \texttt{x}, while for \hyperlink{11302502367029942782}{\texttt{Complex}} \texttt{x} compute the principal branch cut of the logarithm of \texttt{gamma(x)} (defined for negative \texttt{real(x)} by analytic continuation from positive \texttt{real(x)}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L36-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15642673718348524569}{} 
\hyperlink{15642673718348524569}{\texttt{Base.Math.lfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lfact(x)
\end{lstlisting}

Compute the logarithmic factorial of a nonnegative integer \texttt{x}. Equivalent to \hyperlink{16944460120463679422}{\texttt{lgamma}} of \texttt{x + 1}, but \texttt{lgamma} extends this function to non-integer \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L27-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3070115649335374621}{} 
\hyperlink{3070115649335374621}{\texttt{Base.Math.beta}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
beta(x, y)
\end{lstlisting}

Euler integral of the first kind \(\operatorname{B}(x,y) = \Gamma(x)\Gamma(y)/\Gamma(x+y)\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L139-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15599420217619146595}{} 
\hyperlink{15599420217619146595}{\texttt{Base.Math.lbeta}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lbeta(x, y)
\end{lstlisting}

Natural logarithm of the absolute value of the \hyperlink{3070115649335374621}{\texttt{beta}} function \(\log(|\operatorname{B}(x,y)|)\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L151-L156}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7415013084438358060}{} 
\hyperlink{7415013084438358060}{\texttt{Base.ndigits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ndigits(n::Integer, b::Integer=10)
\end{lstlisting}

Compute the number of digits in integer \texttt{n} written in base \texttt{b}. The base \texttt{b} must not be in \texttt{[-1, 0, 1]}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ndigits(12345)
5

julia> ndigits(1022, 16)
3

julia> base(16, 1022)
"3fe"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L481-L498}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4564031682097452426}{} 
\hyperlink{4564031682097452426}{\texttt{Base.widemul}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
widemul(x, y)
\end{lstlisting}

Multiply \texttt{x} and \texttt{y}, giving the result as a larger type.


\begin{minted}{jlcon}
julia> widemul(Float32(3.), 4.)
1.200000000000000000000000000000000000000000000000000000000000000000000000000000e+01
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L118-L127}{\texttt{source}}


\end{adjustwidth}
\hypertarget{552638784001429566}{} 
\hyperlink{552638784001429566}{\texttt{Base.Math.@evalpoly}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@evalpoly(z, c...)
\end{lstlisting}

Evaluate the polynomial \(\sum_k c[k] z^{k-1}\) for the coefficients \texttt{c[1]}, \texttt{c[2]}, ...; that is, the coefficients are given in ascending order by power of \texttt{z}.  This macro expands to efficient inline code that uses either Horner{\textquotesingle}s method or, for complex \texttt{z}, a more efficient Goertzel-like algorithm.


\begin{minted}{jlcon}
julia> @evalpoly(3, 1, 0, 1)
10

julia> @evalpoly(2, 1, 0, 1)
5

julia> @evalpoly(2, 1, 1, 1)
7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L89-L107}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9525826009664353115}{}


\section{Estadística}


\hypertarget{2002825322838319654}{} 
\hyperlink{2002825322838319654}{\texttt{Base.mean}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mean(f::Function, v)
\end{lstlisting}

Apply the function \texttt{f} to each element of \texttt{v} and take the mean.


\begin{minted}{jlcon}
julia> mean(√, [1, 2, 3])
1.3820881233139908

julia> mean([√1, √2, √3])
1.3820881233139908
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L5-L17}{\texttt{source}}



\begin{lstlisting}
mean(v[, region])
\end{lstlisting}

Compute the mean of whole array \texttt{v}, or optionally along the dimensions in \texttt{region}.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L48-L56}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11275601330930982108}{} 
\hyperlink{11275601330930982108}{\texttt{Base.mean!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mean!(r, v)
\end{lstlisting}

Compute the mean of \texttt{v} over the singleton dimensions of \texttt{r}, and write results to \texttt{r}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1736-L1740}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8821409723106968118}{} 
\hyperlink{8821409723106968118}{\texttt{Base.std}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
std(v[, region]; corrected::Bool=true, mean=nothing)
\end{lstlisting}

Compute the sample standard deviation of a vector or array \texttt{v}, optionally along dimensions in \texttt{region}. The algorithm returns an estimator of the generative distribution{\textquotesingle}s standard deviation under the assumption that each entry of \texttt{v} is an IID drawn from that generative distribution. This computation is equivalent to calculating \texttt{sqrt(sum((v - mean(v)).{\textasciicircum}2) / (length(v) - 1))}. A pre-computed \texttt{mean} may be provided. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L249-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4196140908140297324}{} 
\hyperlink{4196140908140297324}{\texttt{Base.stdm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stdm(v, m::Number; corrected::Bool=true)
\end{lstlisting}

Compute the sample standard deviation of a vector \texttt{v} with known mean \texttt{m}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L271-L283}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7174335757357744571}{} 
\hyperlink{7174335757357744571}{\texttt{Base.var}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
var(v[, region]; corrected::Bool=true, mean=nothing)
\end{lstlisting}

Compute the sample variance of a vector or array \texttt{v}, optionally along dimensions in \texttt{region}. The algorithm will return an estimator of the generative distribution{\textquotesingle}s variance under the assumption that each entry of \texttt{v} is an IID drawn from that generative distribution. This computation is equivalent to calculating \texttt{sum(abs2, v - mean(v)) / (length(v) - 1)}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}. The mean \texttt{mean} over the region may be provided.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L188-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5349278597847317202}{} 
\hyperlink{5349278597847317202}{\texttt{Base.varm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
varm(v, m[, region]; corrected::Bool=true)
\end{lstlisting}

Compute the sample variance of a collection \texttt{v} with known mean(s) \texttt{m}, optionally over \texttt{region}. \texttt{m} may contain means for each dimension of \texttt{v}. If \texttt{corrected} is \texttt{true}, then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L167-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17123713281788045930}{} 
\hyperlink{17123713281788045930}{\texttt{Base.middle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
middle(x)
\end{lstlisting}

Compute the middle of a scalar value, which is equivalent to \texttt{x} itself, but of the type of \texttt{middle(x, x)} for consistency.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L533-L537}{\texttt{source}}



\begin{lstlisting}
middle(x, y)
\end{lstlisting}

Compute the middle of two reals \texttt{x} and \texttt{y}, which is equivalent in both value and type to computing their mean (\texttt{(x + y) / 2}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L543-L548}{\texttt{source}}



\begin{lstlisting}
middle(range)
\end{lstlisting}

Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.


\begin{minted}{jlcon}
julia> middle(1:10)
5.5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L551-L561}{\texttt{source}}



\begin{lstlisting}
middle(a)
\end{lstlisting}

Compute the middle of an array \texttt{a}, which consists of finding its extrema and then computing their mean.


\begin{minted}{jlcon}
julia> a = [1,2,3.6,10.9]
4-element Array{Float64,1}:
  1.0
  2.0
  3.6
 10.9

julia> middle(a)
5.95
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L564-L581}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11179782716658704342}{} 
\hyperlink{11179782716658704342}{\texttt{Base.median}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
median(v[, region])
\end{lstlisting}

Compute the median of an entire array \texttt{v}, or, optionally, along the dimensions in \texttt{region}. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L609-L620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9482186025590628546}{} 
\hyperlink{9482186025590628546}{\texttt{Base.median!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
median!(v)
\end{lstlisting}

Like \hyperlink{11179782716658704342}{\texttt{median}}, but may overwrite the input vector.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L584-L588}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16460295794470869961}{} 
\hyperlink{16460295794470869961}{\texttt{Base.quantile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
quantile(v, p; sorted=false)
\end{lstlisting}

Compute the quantile(s) of a vector \texttt{v} at a specified probability or vector \texttt{p}. The keyword argument \texttt{sorted} indicates whether \texttt{v} can be assumed to be sorted.

The \texttt{p} should be on the interval [0,1], and \texttt{v} should not have any \texttt{NaN} values.

Quantiles are computed via linear interpolation between the points \texttt{((k-1)/(n-1), v[k])}, for \texttt{k = 1:n} where \texttt{n = length(v)}. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended. \texttt{quantile} will throw an \texttt{ArgumentError} in the presence of \texttt{NaN} values in the data array.

\end{quote}
\begin{itemize}
\item Hyndman, R.J and Fan, Y. (1996) {\textquotedbl}Sample Quantiles in Statistical Packages{\textquotedbl}, \emph{The American Statistician}, Vol. 50, No. 4, pp. 361-365

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L719-L738}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8191466670466322000}{} 
\hyperlink{8191466670466322000}{\texttt{Base.quantile!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
quantile!([q, ] v, p; sorted=false)
\end{lstlisting}

Compute the quantile(s) of a vector \texttt{v} at the probabilities \texttt{p}, with optional output into array \texttt{q} (if not provided, a new output array is created). The keyword argument \texttt{sorted} indicates whether \texttt{v} can be assumed to be sorted; if \texttt{false} (the default), then the elements of \texttt{v} may be partially sorted.

The elements of \texttt{p} should be on the interval [0,1], and \texttt{v} should not have any \texttt{NaN} values.

Quantiles are computed via linear interpolation between the points \texttt{((k-1)/(n-1), v[k])}, for \texttt{k = 1:n} where \texttt{n = length(v)}. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.

\begin{quote}
\textbf{Note}

Julia does not ignore \texttt{NaN} values in the computation. For applications requiring the handling of missing data, the \texttt{DataArrays.jl} package is recommended. \texttt{quantile!} will throw an \texttt{ArgumentError} in the presence of \texttt{NaN} values in the data array.

\end{quote}
\begin{itemize}
\item Hyndman, R.J and Fan, Y. (1996) {\textquotedbl}Sample Quantiles in Statistical Packages{\textquotedbl}, \emph{The American Statistician}, Vol. 50, No. 4, pp. 361-365

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L625-L647}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17277490353628239858}{} 
\hyperlink{17277490353628239858}{\texttt{Base.cov}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cov(x[, corrected=true])
\end{lstlisting}

Compute the variance of the vector \texttt{x}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = length(x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L342-L347}{\texttt{source}}



\begin{lstlisting}
cov(X[, vardim=1, corrected=true])
\end{lstlisting}

Compute the covariance matrix of the matrix \texttt{X} along the dimension \texttt{vardim}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = size(X, vardim)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L352-L358}{\texttt{source}}



\begin{lstlisting}
cov(x, y[, corrected=true])
\end{lstlisting}

Compute the covariance between the vectors \texttt{x} and \texttt{y}. If \texttt{corrected} is \texttt{true} (the default), computes \(\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*\) where \(*\) denotes the complex conjugate and \texttt{n = length(x) = length(y)}. If \texttt{corrected} is \texttt{false}, computes \(rac{1}{n}sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L364-L371}{\texttt{source}}



\begin{lstlisting}
cov(X, Y[, vardim=1, corrected=true])
\end{lstlisting}

Compute the covariance between the vectors or matrices \texttt{X} and \texttt{Y} along the dimension \texttt{vardim}. If \texttt{corrected} is \texttt{true} (the default) then the sum is scaled with \texttt{n-1}, whereas the sum is scaled with \texttt{n} if \texttt{corrected} is \texttt{false} where \texttt{n = size(X, vardim) = size(Y, vardim)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L378-L384}{\texttt{source}}


\end{adjustwidth}
\hypertarget{635640719787866143}{} 
\hyperlink{635640719787866143}{\texttt{Base.cor}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cor(x)
\end{lstlisting}

Return the number one.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L494-L498}{\texttt{source}}



\begin{lstlisting}
cor(X[, vardim=1])
\end{lstlisting}

Compute the Pearson correlation matrix of the matrix \texttt{X} along the dimension \texttt{vardim}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L502-L506}{\texttt{source}}



\begin{lstlisting}
cor(x, y)
\end{lstlisting}

Compute the Pearson correlation between the vectors \texttt{x} and \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L511-L515}{\texttt{source}}



\begin{lstlisting}
cor(X, Y[, vardim=1])
\end{lstlisting}

Compute the Pearson correlation between the vectors or matrices \texttt{X} and \texttt{Y} along the dimension \texttt{vardim}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L519-L523}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13906896320449862424}{}


\section{Procesamiento de Señales}



Las funciones de transformada rápida de Fourier (\emph{Fast Fourier transform} – FFT) en Julia están implementadas mediante llamadas a funciones de la librería \href{http://www.fftw.org}{FFTW}.


\hypertarget{3985477341468132593}{} 
\hyperlink{3985477341468132593}{\texttt{Base.DFT.fft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fft(A [, dims])
\end{lstlisting}

Performs a multidimensional FFT of the array \texttt{A}. The optional \texttt{dims} argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of \texttt{A} along the transformed dimensions is a product of small primes; see \texttt{nextprod()}. See also \texttt{plan\_fft()} for even greater efficiency.

A one-dimensional FFT computes the one-dimensional discrete Fourier transform (DFT) as defined by

\begin{equation*}
\begin{split}\operatorname{DFT}(A)[k] =
  \sum_{n=1}^{\operatorname{length}(A)}
  \exp\left(-i\frac{2\pi
  (n-1)(k-1)}{\operatorname{length}(A)} \right) A[n].\end{split}\end{equation*}
A multidimensional FFT simply performs this operation along each transformed dimension of \texttt{A}.

\begin{quote}
\textbf{Note}

\begin{itemize}
\item Julia starts FFTW up with 1 thread by default. Higher performance is usually possible by increasing number of threads. Use \texttt{FFTW.set\_num\_threads(Sys.CPU\_CORES)} to use as many threads as cores on your system.


\item This performs a multidimensional FFT by default. FFT libraries in other languages such as Python and Octave perform a one-dimensional FFT along the first non-singleton dimension of the array. This is worth noting while performing comparisons. For more details, refer to the \hyperlink{16083606765476288441}{Noteworthy Differences from other Languages} section of the manual.

\end{itemize}
\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L401-L431}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5173091226550296763}{} 
\hyperlink{5173091226550296763}{\texttt{Base.DFT.fft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fft!(A [, dims])
\end{lstlisting}

Same as \hyperlink{3985477341468132593}{\texttt{fft}}, but operates in-place on \texttt{A}, which must be an array of complex floating-point numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L169-L174}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13595721344189188463}{} 
\hyperlink{13595721344189188463}{\texttt{Base.DFT.ifft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ifft(A [, dims])
\end{lstlisting}

Multidimensional inverse FFT.

A one-dimensional inverse FFT computes

\begin{equation*}
\begin{split}\operatorname{IDFT}(A)[k] = \frac{1}{\operatorname{length}(A)}
\sum_{n=1}^{\operatorname{length}(A)} \exp\left(+i\frac{2\pi (n-1)(k-1)}
{\operatorname{length}(A)} \right) A[n].\end{split}\end{equation*}
A multidimensional inverse FFT simply performs this operation along each transformed dimension of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L152-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4986013805597074777}{} 
\hyperlink{4986013805597074777}{\texttt{Base.DFT.ifft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ifft!(A [, dims])
\end{lstlisting}

Same as \hyperlink{13595721344189188463}{\texttt{ifft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L145-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17084266922751986269}{} 
\hyperlink{17084266922751986269}{\texttt{Base.DFT.bfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bfft(A [, dims])
\end{lstlisting}

Similar to \hyperlink{13595721344189188463}{\texttt{ifft}}, but computes an unnormalized inverse (backward) transform, which must be divided by the product of the sizes of the transformed dimensions in order to obtain the inverse. (This is slightly more efficient than \hyperlink{13595721344189188463}{\texttt{ifft}} because it omits a scaling step, which in some applications can be combined with other computational steps elsewhere.)

\begin{equation*}
\begin{split}\operatorname{BDFT}(A)[k] = \operatorname{length}(A) \operatorname{IDFT}(A)[k]\end{split}\end{equation*}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L177-L189}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4223518985457844046}{} 
\hyperlink{4223518985457844046}{\texttt{Base.DFT.bfft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bfft!(A [, dims])
\end{lstlisting}

Same as \hyperlink{17084266922751986269}{\texttt{bfft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L192-L196}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5662326709694019683}{} 
\hyperlink{5662326709694019683}{\texttt{Base.DFT.plan\_fft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_fft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Pre-plan an optimized FFT along given dimensions (\texttt{dims}) of arrays matching the shape and type of \texttt{A}.  (The first two arguments have the same meaning as for \hyperlink{3985477341468132593}{\texttt{fft}}.) Returns an object \texttt{P} which represents the linear operator computed by the FFT, and which contains all of the information needed to compute \texttt{fft(A, dims)} quickly.

To apply \texttt{P} to an array \texttt{A}, use \texttt{P * A}; in general, the syntax for applying plans is much like that of matrices.  (A plan can only be applied to arrays of the same size as the \texttt{A} for which the plan was created.)  You can also apply a plan with a preallocated output array \texttt{Â} by calling \texttt{A\_mul\_B!(Â, plan, A)}.  (For \texttt{A\_mul\_B!}, however, the input array \texttt{A} must be a complex floating-point array like the output \texttt{Â}.) You can compute the inverse-transform plan by \texttt{inv(P)} and apply the inverse plan with \texttt{P {\textbackslash} Â} (the inverse plan is cached and reused for subsequent calls to \texttt{inv} or \texttt{{\textbackslash}}), and apply the inverse plan to a pre-allocated output array \texttt{A} with \texttt{A\_ldiv\_B!(A, P, Â)}.

The \texttt{flags} argument is a bitwise-or of FFTW planner flags, defaulting to \texttt{FFTW.ESTIMATE}. e.g. passing \texttt{FFTW.MEASURE} or \texttt{FFTW.PATIENT} will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags.  The optional \texttt{timelimit} argument specifies a rough upper bound on the allowed planning time, in seconds. Passing \texttt{FFTW.MEASURE} or \texttt{FFTW.PATIENT} may cause the input array \texttt{A} to be overwritten with zeros during plan creation.

\hyperlink{4167351963411530120}{\texttt{plan\_fft!}} is the same as \hyperlink{5662326709694019683}{\texttt{plan\_fft}} but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). \hyperlink{11132438775767023322}{\texttt{plan\_ifft}} and so on are similar but produce plans that perform the equivalent of the inverse transforms \hyperlink{13595721344189188463}{\texttt{ifft}} and so on.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L92-L121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11132438775767023322}{} 
\hyperlink{11132438775767023322}{\texttt{Base.DFT.plan\_ifft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_ifft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{5662326709694019683}{\texttt{plan\_fft}}, but produces a plan that performs inverse transforms \hyperlink{13595721344189188463}{\texttt{ifft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L62-L67}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5148058741299398507}{} 
\hyperlink{5148058741299398507}{\texttt{Base.DFT.plan\_bfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_bfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{5662326709694019683}{\texttt{plan\_fft}}, but produces a plan that performs an unnormalized backwards transform \hyperlink{17084266922751986269}{\texttt{bfft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L84-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4167351963411530120}{} 
\hyperlink{4167351963411530120}{\texttt{Base.DFT.plan\_fft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_fft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{5662326709694019683}{\texttt{plan\_fft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L124-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18249851546818355203}{} 
\hyperlink{18249851546818355203}{\texttt{Base.DFT.plan\_ifft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_ifft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{11132438775767023322}{\texttt{plan\_ifft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L70-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6203327325390100148}{} 
\hyperlink{6203327325390100148}{\texttt{Base.DFT.plan\_bfft!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_bfft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Same as \hyperlink{5148058741299398507}{\texttt{plan\_bfft}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L77-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10962439848710721870}{} 
\hyperlink{10962439848710721870}{\texttt{Base.DFT.rfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rfft(A [, dims])
\end{lstlisting}

Multidimensional FFT of a real array \texttt{A}, exploiting the fact that the transform has conjugate symmetry in order to save roughly half the computational time and storage costs compared with \hyperlink{3985477341468132593}{\texttt{fft}}. If \texttt{A} has size \texttt{(n\_1, ..., n\_d)}, the result has size \texttt{(div(n\_1,2)+1, ..., n\_d)}.

The optional \texttt{dims} argument specifies an iterable subset of one or more dimensions of \texttt{A} to transform, similar to \hyperlink{3985477341468132593}{\texttt{fft}}. Instead of (roughly) halving the first dimension of \texttt{A} in the result, the \texttt{dims[1]} dimension is (roughly) halved in the same way.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L131-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2841119442394337591}{} 
\hyperlink{2841119442394337591}{\texttt{Base.DFT.irfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
irfft(A, d [, dims])
\end{lstlisting}

Inverse of \hyperlink{10962439848710721870}{\texttt{rfft}}: for a complex array \texttt{A}, gives the corresponding real array whose FFT yields \texttt{A} in the first half. As for \hyperlink{10962439848710721870}{\texttt{rfft}}, \texttt{dims} is an optional subset of dimensions to transform, defaulting to \texttt{1:ndims(A)}.

\texttt{d} is the length of the transformed real array along the \texttt{dims[1]} dimension, which must satisfy \texttt{div(d,2)+1 == size(A,dims[1])}. (This parameter cannot be inferred from \texttt{size(A)} since both \texttt{2*size(A,dims[1])-2} as well as \texttt{2*size(A,dims[1])-1} are valid sizes for the transformed real array.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L302-L313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15795936628254264831}{} 
\hyperlink{15795936628254264831}{\texttt{Base.DFT.brfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
brfft(A, d [, dims])
\end{lstlisting}

Similar to \hyperlink{2841119442394337591}{\texttt{irfft}} but computes an unnormalized inverse transform (similar to \hyperlink{17084266922751986269}{\texttt{bfft}}), which must be divided by the product of the sizes of the transformed dimensions (of the real output array) in order to obtain the inverse transform.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L316-L322}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9764256859829273381}{} 
\hyperlink{9764256859829273381}{\texttt{Base.DFT.plan\_rfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_rfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Pre-plan an optimized real-input FFT, similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}} except for \hyperlink{10962439848710721870}{\texttt{rfft}} instead of \hyperlink{3985477341468132593}{\texttt{fft}}. The first two arguments, and the size of the transformed result, are the same as for \hyperlink{10962439848710721870}{\texttt{rfft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L434-L440}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17882312537894422737}{} 
\hyperlink{17882312537894422737}{\texttt{Base.DFT.plan\_brfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_brfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Pre-plan an optimized real-input unnormalized transform, similar to \hyperlink{9764256859829273381}{\texttt{plan\_rfft}} except for \hyperlink{15795936628254264831}{\texttt{brfft}} instead of \hyperlink{10962439848710721870}{\texttt{rfft}}. The first two arguments and the size of the transformed result, are the same as for \hyperlink{15795936628254264831}{\texttt{brfft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L443-L450}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7411543459302942660}{} 
\hyperlink{7411543459302942660}{\texttt{Base.DFT.plan\_irfft}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_irfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)
\end{lstlisting}

Pre-plan an optimized inverse real-input FFT, similar to \hyperlink{9764256859829273381}{\texttt{plan\_rfft}} except for \hyperlink{2841119442394337591}{\texttt{irfft}} and \hyperlink{15795936628254264831}{\texttt{brfft}}, respectively. The first three arguments have the same meaning as for \hyperlink{2841119442394337591}{\texttt{irfft}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L344-L350}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7333038527866016312}{} 
\hyperlink{7333038527866016312}{\texttt{Base.DFT.FFTW.dct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dct(A [, dims])
\end{lstlisting}

Performs a multidimensional type-II discrete cosine transform (DCT) of the array \texttt{A}, using the unitary normalization of the DCT. The optional \texttt{dims} argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along.  Most efficient if the size of \texttt{A} along the transformed dimensions is a product of small primes; see \hyperlink{9591900175500358341}{\texttt{nextprod}}. See also \hyperlink{16521473777634385764}{\texttt{plan\_dct}} for even greater efficiency.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L494-L503}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17481908707827491950}{} 
\hyperlink{17481908707827491950}{\texttt{Base.DFT.FFTW.dct!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dct!(A [, dims])
\end{lstlisting}

Same as \hyperlink{17481908707827491950}{\texttt{dct!}}, except that it operates in-place on \texttt{A}, which must be an array of real or complex floating-point values.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L518-L523}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5888602804203711650}{} 
\hyperlink{5888602804203711650}{\texttt{Base.DFT.FFTW.idct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
idct(A [, dims])
\end{lstlisting}

Computes the multidimensional inverse discrete cosine transform (DCT) of the array \texttt{A} (technically, a type-III DCT with the unitary normalization). The optional \texttt{dims} argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along.  Most efficient if the size of \texttt{A} along the transformed dimensions is a product of small primes; see \hyperlink{9591900175500358341}{\texttt{nextprod}}.  See also \hyperlink{17542025272603481562}{\texttt{plan\_idct}} for even greater efficiency.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L506-L515}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1798327509127332273}{} 
\hyperlink{1798327509127332273}{\texttt{Base.DFT.FFTW.idct!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
idct!(A [, dims])
\end{lstlisting}

Same as \hyperlink{1798327509127332273}{\texttt{idct!}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L526-L530}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16521473777634385764}{} 
\hyperlink{16521473777634385764}{\texttt{Base.DFT.FFTW.plan\_dct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_dct(A [, dims [, flags [, timelimit]]])
\end{lstlisting}

Pre-plan an optimized discrete cosine transform (DCT), similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}} except producing a function that computes \hyperlink{7333038527866016312}{\texttt{dct}}. The first two arguments have the same meaning as for \hyperlink{7333038527866016312}{\texttt{dct}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L477-L484}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11618475594877507716}{} 
\hyperlink{11618475594877507716}{\texttt{Base.DFT.FFTW.plan\_dct!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_dct!(A [, dims [, flags [, timelimit]]])
\end{lstlisting}

Same as \hyperlink{16521473777634385764}{\texttt{plan\_dct}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L460-L464}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17542025272603481562}{} 
\hyperlink{17542025272603481562}{\texttt{Base.DFT.FFTW.plan\_idct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_idct(A [, dims [, flags [, timelimit]]])
\end{lstlisting}

Pre-plan an optimized inverse discrete cosine transform (DCT), similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}} except producing a function that computes \hyperlink{5888602804203711650}{\texttt{idct}}. The first two arguments have the same meaning as for \hyperlink{5888602804203711650}{\texttt{idct}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L467-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3911513489803128060}{} 
\hyperlink{3911513489803128060}{\texttt{Base.DFT.FFTW.plan\_idct!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_idct!(A [, dims [, flags [, timelimit]]])
\end{lstlisting}

Same as \hyperlink{17542025272603481562}{\texttt{plan\_idct}}, but operates in-place on \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L487-L491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11783177028290610958}{} 
\hyperlink{11783177028290610958}{\texttt{Base.DFT.fftshift}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fftshift(x)
\end{lstlisting}

Swap the first and second halves of each dimension of \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L359-L363}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15316294171790549537}{} 
\hyperlink{15316294171790549537}{\texttt{Base.DFT.fftshift}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fftshift(x,dim)
\end{lstlisting}

Swap the first and second halves of the given dimension or iterable of dimensions of array \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L374-L378}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11093965455991767579}{} 
\hyperlink{11093965455991767579}{\texttt{Base.DFT.ifftshift}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ifftshift(x, [dim])
\end{lstlisting}

Undoes the effect of \texttt{fftshift}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L383-L387}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4032689265202828824}{} 
\hyperlink{4032689265202828824}{\texttt{Base.DSP.filt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filt(b, a, x, [si])
\end{lstlisting}

Apply filter described by vectors \texttt{a} and \texttt{b} to vector \texttt{x}, with an optional initial filter state vector \texttt{si} (defaults to zeros).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L11-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6936084423679867241}{} 
\hyperlink{6936084423679867241}{\texttt{Base.DSP.filt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filt!(out, b, a, x, [si])
\end{lstlisting}

Same as \hyperlink{4032689265202828824}{\texttt{filt}} but writes the result into the \texttt{out} argument, which may alias the input \texttt{x} to modify it in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L25-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3218079418813875795}{} 
\hyperlink{3218079418813875795}{\texttt{Base.DSP.deconv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deconv(b,a) -> c
\end{lstlisting}

Construct vector \texttt{c} such that \texttt{b = conv(a,c) + r}. Equivalent to polynomial division.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L105-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16464652106793971903}{} 
\hyperlink{16464652106793971903}{\texttt{Base.DSP.conv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
conv(u,v)
\end{lstlisting}

Convolution of two vectors. Uses FFT algorithm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L123-L127}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12320048174617111011}{} 
\hyperlink{12320048174617111011}{\texttt{Base.DSP.conv2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
conv2(u,v,A)
\end{lstlisting}

2-D convolution of the matrix \texttt{A} with the 2-D separable kernel generated by the vectors \texttt{u} and \texttt{v}. Uses 2-D FFT algorithm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L148-L154}{\texttt{source}}



\begin{lstlisting}
conv2(B,A)
\end{lstlisting}

2-D convolution of the matrix \texttt{B} with the matrix \texttt{A}. Uses 2-D FFT algorithm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L169-L173}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7370255343750411311}{} 
\hyperlink{7370255343750411311}{\texttt{Base.DSP.xcorr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
xcorr(u,v)
\end{lstlisting}

Compute the cross-correlation of two vectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L192-L196}{\texttt{source}}


\end{adjustwidth}

Las siguientes funciones están definidas dentro del módulo \texttt{Base.FFTW}.


\hypertarget{14687703779290255687}{} 
\hyperlink{14687703779290255687}{\texttt{Base.DFT.FFTW.r2r}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
r2r(A, kind [, dims])
\end{lstlisting}

Performs a multidimensional real-input/real-output (r2r) transform of type \texttt{kind} of the array \texttt{A}, as defined in the FFTW manual. \texttt{kind} specifies either a discrete cosine transform of various types (\texttt{FFTW.REDFT00}, \texttt{FFTW.REDFT01}, \texttt{FFTW.REDFT10}, or \texttt{FFTW.REDFT11}), a discrete sine transform of various types (\texttt{FFTW.RODFT00}, \texttt{FFTW.RODFT01}, \texttt{FFTW.RODFT10}, or \texttt{FFTW.RODFT11}), a real-input DFT with halfcomplex-format output (\texttt{FFTW.R2HC} and its inverse \texttt{FFTW.HC2R}), or a discrete Hartley transform (\texttt{FFTW.DHT}).  The \texttt{kind} argument may be an array or tuple in order to specify different transform types along the different dimensions of \texttt{A}; \texttt{kind[end]} is used for any unspecified dimensions.  See the FFTW manual for precise definitions of these transform types, at http://www.fftw.org/doc.

The optional \texttt{dims} argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. \texttt{kind[i]} is then the transform type for \texttt{dims[i]}, with \texttt{kind[end]} being used for \texttt{i > length(kind)}.

See also \hyperlink{6641116333364172687}{\texttt{plan\_r2r}} to pre-plan optimized r2r transforms.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L533-L556}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14749561168372739927}{} 
\hyperlink{14749561168372739927}{\texttt{Base.DFT.FFTW.r2r!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
r2r!(A, kind [, dims])
\end{lstlisting}

Same as \hyperlink{14687703779290255687}{\texttt{r2r}}, but operates in-place on \texttt{A}, which must be an array of real or complex floating-point numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L559-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6641116333364172687}{} 
\hyperlink{6641116333364172687}{\texttt{Base.DFT.FFTW.plan\_r2r}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_r2r(A, kind [, dims [, flags [, timelimit]]])
\end{lstlisting}

Pre-plan an optimized r2r transform, similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}} except that the transforms (and the first three arguments) correspond to \hyperlink{14687703779290255687}{\texttt{r2r}} and \hyperlink{14749561168372739927}{\texttt{r2r!}}, respectively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L574-L580}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13859363726116484202}{} 
\hyperlink{13859363726116484202}{\texttt{Base.DFT.FFTW.plan\_r2r!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
plan_r2r!(A, kind [, dims [, flags [, timelimit]]])
\end{lstlisting}

Similar to \hyperlink{5662326709694019683}{\texttt{plan\_fft}}, but corresponds to \hyperlink{14749561168372739927}{\texttt{r2r!}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L567-L571}{\texttt{source}}


\end{adjustwidth}

\hypertarget{856545484690558276}{}


\chapter{Números}



\hypertarget{5094626598663504020}{}


\section{Tipos Numéricos Estándar}



\hypertarget{2979437205044461587}{}


\subsection{Tipos Numéricos Abstractos}


\hypertarget{1990584313715697055}{} 
\hyperlink{1990584313715697055}{\texttt{Core.Number}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Number
\end{lstlisting}

Abstract supertype for all number types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2668-L2672}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6175959395021454412}{} 
\hyperlink{6175959395021454412}{\texttt{Core.Real}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Real <: Number
\end{lstlisting}

Abstract supertype for all real numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2675-L2679}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11465394427882483091}{} 
\hyperlink{11465394427882483091}{\texttt{Core.AbstractFloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AbstractFloat <: Real
\end{lstlisting}

Abstract supertype for all floating point numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2682-L2686}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8469131683393450448}{} 
\hyperlink{8469131683393450448}{\texttt{Core.Integer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Integer <: Real
\end{lstlisting}

Abstract supertype for all integers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2689-L2693}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14154866400772377486}{} 
\hyperlink{14154866400772377486}{\texttt{Core.Signed}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Signed <: Integer
\end{lstlisting}

Abstract supertype for all signed integers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2696-L2700}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4780971278803506664}{} 
\hyperlink{4780971278803506664}{\texttt{Core.Unsigned}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Unsigned <: Integer
\end{lstlisting}

Abstract supertype for all unsigned integers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2703-L2707}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11572379769881488316}{}


\subsection{Tipos Numéricos Concretos}


\hypertarget{2727296760866702904}{} 
\hyperlink{2727296760866702904}{\texttt{Core.Float16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float16 <: AbstractFloat
\end{lstlisting}

16-bit floating point number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2719-L2723}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8101639384272933082}{} 
\hyperlink{8101639384272933082}{\texttt{Core.Float32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float32 <: AbstractFloat
\end{lstlisting}

32-bit floating point number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2719-L2723}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5027751419500983000}{} 
\hyperlink{5027751419500983000}{\texttt{Core.Float64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float64 <: AbstractFloat
\end{lstlisting}

64-bit floating point number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2719-L2723}{\texttt{source}}


\end{adjustwidth}
\hypertarget{749816618809421837}{} 
\hyperlink{749816618809421837}{\texttt{Base.MPFR.BigFloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat <: AbstractFloat
\end{lstlisting}

Arbitrary precision floating point number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L43-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{46725311238864537}{} 
\hyperlink{46725311238864537}{\texttt{Core.Bool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Bool <: Integer
\end{lstlisting}

Boolean type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2710-L2714}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5857518405103968275}{} 
\hyperlink{5857518405103968275}{\texttt{Core.Int8}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int8 <: Signed
\end{lstlisting}

8-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6609065134969660118}{} 
\hyperlink{6609065134969660118}{\texttt{Core.UInt8}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt8 <: Unsigned
\end{lstlisting}

8-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6667287249103968645}{} 
\hyperlink{6667287249103968645}{\texttt{Core.Int16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int16 <: Signed
\end{lstlisting}

16-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7018610346698168012}{} 
\hyperlink{7018610346698168012}{\texttt{Core.UInt16}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt16 <: Unsigned
\end{lstlisting}

16-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10103694114785108551}{} 
\hyperlink{10103694114785108551}{\texttt{Core.Int32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int32 <: Signed
\end{lstlisting}

32-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8690996847580776341}{} 
\hyperlink{8690996847580776341}{\texttt{Core.UInt32}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt32 <: Unsigned
\end{lstlisting}

32-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7720564657383125058}{} 
\hyperlink{7720564657383125058}{\texttt{Core.Int64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int64 <: Signed
\end{lstlisting}

64-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5500998675195555601}{} 
\hyperlink{5500998675195555601}{\texttt{Core.UInt64}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt64 <: Unsigned
\end{lstlisting}

64-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8012327724714767060}{} 
\hyperlink{8012327724714767060}{\texttt{Core.Int128}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Int128 <: Signed
\end{lstlisting}

128-bit signed integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14811222188335428522}{} 
\hyperlink{14811222188335428522}{\texttt{Core.UInt128}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UInt128 <: Unsigned
\end{lstlisting}

128-bit unsigned integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741}{\texttt{source}}


\end{adjustwidth}
\hypertarget{423405808990690832}{} 
\hyperlink{423405808990690832}{\texttt{Base.GMP.BigInt}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigInt <: Integer
\end{lstlisting}

Arbitrary precision integer type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/gmp.jl#L40-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11302502367029942782}{} 
\hyperlink{11302502367029942782}{\texttt{Base.Complex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Complex{T<:Real} <: Number
\end{lstlisting}

Complex number type with real and imaginary part of type \texttt{T}.

\texttt{Complex32}, \texttt{Complex64} and \texttt{Complex128} are aliases for \texttt{Complex\{Float16\}}, \texttt{Complex\{Float32\}} and \texttt{Complex\{Float64\}} respectively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L3-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8304566144531167610}{} 
\hyperlink{8304566144531167610}{\texttt{Base.Rational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Rational{T<:Integer} <: Real
\end{lstlisting}

Rational number type, with numerator and denominator of type \texttt{T}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5993828909973077529}{} 
\hyperlink{5993828909973077529}{\texttt{Base.Irrational}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Irrational <: Real
\end{lstlisting}

Irrational number type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7990310119520784797}{}


\section{Formatos de Datos}


\hypertarget{16742420098960517985}{} 
\hyperlink{16742420098960517985}{\texttt{Base.bin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bin(n, pad::Int=1)
\end{lstlisting}

Convert an integer to a binary string, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> bin(10,2)
"1010"

julia> bin(10,8)
"00001010"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L601-L613}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14394143983309720145}{} 
\hyperlink{14394143983309720145}{\texttt{Base.hex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hex(n, pad::Int=1)
\end{lstlisting}

Convert an integer to a hexadecimal string, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> hex(20)
"14"

julia> hex(20, 3)
"014"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L616-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12862597547050958664}{} 
\hyperlink{12862597547050958664}{\texttt{Base.dec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dec(n, pad::Int=1)
\end{lstlisting}

Convert an integer to a decimal string, optionally specifying a number of digits to pad to.

\textbf{Examples}


\begin{minted}{jlcon}
julia> dec(20)
"20"

julia> dec(20, 3)
"020"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L648-L662}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11886519039750543945}{} 
\hyperlink{11886519039750543945}{\texttt{Base.oct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
oct(n, pad::Int=1)
\end{lstlisting}

Convert an integer to an octal string, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> oct(20)
"24"

julia> oct(20, 3)
"024"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L632-L645}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13209172751165879613}{} 
\hyperlink{13209172751165879613}{\texttt{Base.base}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
base(base::Integer, n::Integer, pad::Integer=1)
\end{lstlisting}

Convert an integer \texttt{n} to a string in the given \texttt{base}, optionally specifying a number of digits to pad to.


\begin{minted}{jlcon}
julia> base(13,5,4)
"0005"

julia> base(5,13,4)
"0023"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L574-L587}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17983913084963570964}{} 
\hyperlink{17983913084963570964}{\texttt{Base.digits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
digits([T<:Integer], n::Integer, base::T=10, pad::Integer=1)
\end{lstlisting}

Returns an array with element type \texttt{T} (default \texttt{Int}) of the digits of \texttt{n} in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indexes, such that \texttt{n == sum([digits[k]*base{\textasciicircum}(k-1) for k=1:length(digits)])}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> digits(10, 10)
2-element Array{Int64,1}:
 0
 1

julia> digits(10, 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia> digits(10, 2, 6)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L671-L701}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18145156230339025572}{} 
\hyperlink{18145156230339025572}{\texttt{Base.digits!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
digits!(array, n::Integer, base::Integer=10)
\end{lstlisting}

Fills an array of the digits of \texttt{n} in the given base. More significant digits are at higher indexes. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.

\textbf{Examples}


\begin{minted}{jlcon}
julia> digits!([2,2,2,2], 10, 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia> digits!([2,2,2,2,2,2], 10, 2)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L709-L734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11853073945412805100}{} 
\hyperlink{11853073945412805100}{\texttt{Base.bits}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bits(n)
\end{lstlisting}

A string giving the literal bit representation of a number.

\textbf{Example}


\begin{minted}{jlcon}
julia> bits(4)
"0000000000000000000000000000000000000000000000000000000000000100"

julia> bits(2.2)
"0100000000000001100110011001100110011001100110011001100110011010"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L80-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13108503824143481717}{} 
\hyperlink{13108503824143481717}{\texttt{Base.parse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parse(type, str, [base])
\end{lstlisting}

Parse a string as a number. If the type is an integer type, then a base can be specified (the default is 10). If the type is a floating point type, the string is parsed as a decimal floating point number. If the string does not contain a valid number, an error is raised.


\begin{minted}{jlcon}
julia> parse(Int, "1234")
1234

julia> parse(Int, "1234", 5)
194

julia> parse(Int, "afc", 16)
2812

julia> parse(Float64, "1.2e-3")
0.0012
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1201-L1221}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16455869400787770938}{} 
\hyperlink{16455869400787770938}{\texttt{Base.tryparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tryparse(type, str, [base])
\end{lstlisting}

Like \hyperlink{13108503824143481717}{\texttt{parse}}, but returns a \hyperlink{2208920129454296646}{\texttt{Nullable}} of the requested type. The result will be null if the string does not contain a valid number.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2478-L2483}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2266887946765468938}{} 
\hyperlink{2266887946765468938}{\texttt{Base.big}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
big(x)
\end{lstlisting}

Convert a number to a maximum precision representation (typically \hyperlink{423405808990690832}{\texttt{BigInt}} or \texttt{BigFloat}). See \hyperlink{749816618809421837}{\texttt{BigFloat}} for information about some pitfalls with floating-point numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1373-L1378}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8153758211648029368}{} 
\hyperlink{8153758211648029368}{\texttt{Base.signed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
signed(x)
\end{lstlisting}

Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2566-L2571}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5348292453497802071}{} 
\hyperlink{5348292453497802071}{\texttt{Base.unsigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsigned(x) -> Unsigned
\end{lstlisting}

Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.

\textbf{Examples}


\begin{minted}{jlcon}
julia> unsigned(-2)
0xfffffffffffffffe

julia> unsigned(2)
0x0000000000000002

julia> signed(unsigned(-2))
-2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2420-L2437}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6134868769696830446}{} 
\hyperlink{6134868769696830446}{\texttt{Base.float}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
float(x)
\end{lstlisting}

Convert a number or array to a floating point data type. When passed a string, this function is equivalent to \texttt{parse(Float64, x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L252-L257}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11312242195671521747}{} 
\hyperlink{11312242195671521747}{\texttt{Base.Math.significand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
significand(x)
\end{lstlisting}

Extract the \texttt{significand(s)} (a.k.a. mantissa), in binary representation, of a floating-point number. If \texttt{x} is a non-zero finite number, then the result will be a number of the same type on the interval \([1,2)\). Otherwise \texttt{x} is returned.

\textbf{Examples}


\begin{minted}{jlcon}
julia> significand(15.2)/15.2
0.125

julia> significand(15.2)*8
15.2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L584-L599}{\texttt{source}}


\end{adjustwidth}
\hypertarget{39736318364195845}{} 
\hyperlink{39736318364195845}{\texttt{Base.Math.exponent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
exponent(x) -> Int
\end{lstlisting}

Get the exponent of a normalized floating-point number.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L567-L571}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16014240202095271744}{} 
\hyperlink{16014240202095271744}{\texttt{Base.complex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
complex(r, [i])
\end{lstlisting}

Convert real numbers or arrays to complex. \texttt{i} defaults to zero.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L122-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{931573217390904193}{} 
\hyperlink{931573217390904193}{\texttt{Base.bswap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bswap(n)
\end{lstlisting}

Byte-swap an integer. Flip the bits of its binary representation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = bswap(4)
288230376151711744

julia> bswap(a)
4

julia> bin(1)
"1"

julia> bin(bswap(1))
"100000000000000000000000000000000000000000000000000000000"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1294-L1313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12462501897843140144}{} 
\hyperlink{12462501897843140144}{\texttt{Base.num2hex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
num2hex(f)
\end{lstlisting}

Get a hexadecimal string of the binary representation of a floating point number.

\textbf{Example}


\begin{minted}{jlcon}
julia> num2hex(2.2)
"400199999999999a"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L602-L612}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14747299776663320553}{} 
\hyperlink{14747299776663320553}{\texttt{Base.hex2num}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hex2num(str)
\end{lstlisting}

Convert a hexadecimal string to the floating point number it represents.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1602-L1606}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7748090932723143403}{} 
\hyperlink{7748090932723143403}{\texttt{Base.hex2bytes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hex2bytes(s::AbstractString)
\end{lstlisting}

Convert an arbitrarily long hexadecimal string to its binary representation. Returns an \texttt{Array\{UInt8,1\}}, i.e. an array of bytes.


\begin{minted}{jlcon}
julia> a = hex(12345)
"3039"

julia> hex2bytes(a)
2-element Array{UInt8,1}:
 0x30
 0x39
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L408-L423}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14739363105735559529}{} 
\hyperlink{14739363105735559529}{\texttt{Base.bytes2hex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bytes2hex(bin_arr::Array{UInt8, 1}) -> String
\end{lstlisting}

Convert an array of bytes to its hexadecimal representation. All characters are in lower-case.


\begin{minted}{jlcon}
julia> a = hex(12345)
"3039"

julia> b = hex2bytes(a)
2-element Array{UInt8,1}:
 0x30
 0x39

julia> bytes2hex(b)
"3039"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L446-L464}{\texttt{source}}


\end{adjustwidth}

\hypertarget{20674632076187775}{}


\section{Constantes y Funciones de Números Generales}


\hypertarget{11395333326208453101}{} 
\hyperlink{11395333326208453101}{\texttt{Base.one}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
one(x)
one(T::type)
\end{lstlisting}

Return a multiplicative identity for \texttt{x}: a value such that \texttt{one(x)*x == x*one(x) == x}.  Alternatively \texttt{one(T)} can take a type \texttt{T}, in which case \texttt{one} returns a multiplicative identity for any \texttt{x} of type \texttt{T}.

If possible, \texttt{one(x)} returns a value of the same type as \texttt{x}, and \texttt{one(T)} returns a value of type \texttt{T}.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, \texttt{one(x)} should return an identity value of the same precision (and shape, for matrices) as \texttt{x}.

If you want a quantity that is of the same type as \texttt{x}, or of type \texttt{T}, even if \texttt{x} is dimensionful, use \hyperlink{2310843180104103470}{\texttt{oneunit}} instead.


\begin{minted}{jlcon}
julia> one(3.7)
1.0

julia> one(Int)
1

julia> one(Dates.Day(1))
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L159-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2310843180104103470}{} 
\hyperlink{2310843180104103470}{\texttt{Base.oneunit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
oneunit(x::T)
oneunit(T::Type)
\end{lstlisting}

Returns \texttt{T(one(x))}, where \texttt{T} is either the type of the argument or (if a type is passed) the argument.  This differs from \hyperlink{11395333326208453101}{\texttt{one}} for dimensionful quantities: \texttt{one} is dimensionless (a multiplicative identity) while \texttt{oneunit} is dimensionful (of the same type as \texttt{x}, or of type \texttt{T}).


\begin{minted}{jlcon}
julia> oneunit(3.7)
1.0

julia> oneunit(Dates.Day)
1 day
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L194-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{240596739242881814}{} 
\hyperlink{240596739242881814}{\texttt{Base.zero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
zero(x)
\end{lstlisting}

Get the additive identity element for the type of \texttt{x} (\texttt{x} can also specify the type itself).


\begin{minted}{jlcon}
julia> zero(1)
0

julia> zero(big"2.0")
0.000000000000000000000000000000000000000000000000000000000000000000000000000000

julia> zero(rand(2,2))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L138-L155}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13833999108924821801}{} 
\hyperlink{13833999108924821801}{\texttt{Base.pi}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pi
π
\end{lstlisting}

The constant pi.


\begin{minted}{jlcon}
julia> pi
π = 3.1415926535897...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L149-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15097910740298861288}{} 
\hyperlink{15097910740298861288}{\texttt{Base.im}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
im
\end{lstlisting}

The imaginary unit.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L18-L22}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8882024759165097447}{} 
\hyperlink{8882024759165097447}{\texttt{Base.eu}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
e
eu
\end{lstlisting}

The constant e.


\begin{minted}{jlcon}
julia> e
e = 2.7182818284590...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L162-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5865454847212735454}{} 
\hyperlink{5865454847212735454}{\texttt{Base.catalan}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
catalan
\end{lstlisting}

Catalan{\textquotesingle}s constant.


\begin{minted}{jlcon}
julia> catalan
catalan = 0.9159655941772...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L201-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2767346061767229384}{} 
\hyperlink{2767346061767229384}{\texttt{Base.eulergamma}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
γ
eulergamma
\end{lstlisting}

Euler{\textquotesingle}s constant.


\begin{minted}{jlcon}
julia> eulergamma
γ = 0.5772156649015...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L175-L185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2819181135704960927}{} 
\hyperlink{2819181135704960927}{\texttt{Base.golden}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
φ
golden
\end{lstlisting}

The golden ratio.


\begin{minted}{jlcon}
julia> golden
φ = 1.6180339887498...
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L188-L198}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1907914141659611007}{} 
\hyperlink{1907914141659611007}{\texttt{Base.Inf}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Inf
\end{lstlisting}

Positive infinity of type \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L32-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7827423203261078742}{} 
\hyperlink{7827423203261078742}{\texttt{Base.Inf32}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Inf32
\end{lstlisting}

Positive infinity of type \hyperlink{8101639384272933082}{\texttt{Float32}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L17-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7656978911755578336}{} 
\hyperlink{7656978911755578336}{\texttt{Base.Inf16}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Inf16
\end{lstlisting}

Positive infinity of type \hyperlink{2727296760866702904}{\texttt{Float16}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11449618129446476597}{} 
\hyperlink{11449618129446476597}{\texttt{Base.NaN}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
NaN
\end{lstlisting}

A not-a-number value of type \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L38-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3173013683234902743}{} 
\hyperlink{3173013683234902743}{\texttt{Base.NaN32}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
NaN32
\end{lstlisting}

A not-a-number value of type \hyperlink{8101639384272933082}{\texttt{Float32}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L23-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1412633859926300302}{} 
\hyperlink{1412633859926300302}{\texttt{Base.NaN16}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
NaN16
\end{lstlisting}

A not-a-number value of type \hyperlink{2727296760866702904}{\texttt{Float16}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L11-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10864939112775145474}{} 
\hyperlink{10864939112775145474}{\texttt{Base.issubnormal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issubnormal(f) -> Bool
\end{lstlisting}

Test whether a floating point number is subnormal.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2055-L2059}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2906021895910968108}{} 
\hyperlink{2906021895910968108}{\texttt{Base.isfinite}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isfinite(f) -> Bool
\end{lstlisting}

Test whether a number is finite.


\begin{minted}{jlcon}
julia> isfinite(5)
true

julia> isfinite(NaN32)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L525-L537}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4492113908831448207}{} 
\hyperlink{4492113908831448207}{\texttt{Base.isinf}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isinf(f) -> Bool
\end{lstlisting}

Test whether a number is infinite.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L543-L547}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6770390199496851634}{} 
\hyperlink{6770390199496851634}{\texttt{Base.isnan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isnan(f) -> Bool
\end{lstlisting}

Test whether a floating point number is not a number (NaN).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L516-L520}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17648248624761612718}{} 
\hyperlink{17648248624761612718}{\texttt{Base.iszero}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iszero(x)
\end{lstlisting}

Return \texttt{true} if \texttt{x == zero(x)}; if \texttt{x} is an array, this checks whether all of the elements of \texttt{x} are zero.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L16-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8339500090035450608}{} 
\hyperlink{8339500090035450608}{\texttt{Base.nextfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextfloat(x::AbstractFloat, n::Integer)
\end{lstlisting}

The result of \texttt{n} iterative applications of \texttt{nextfloat} to \texttt{x} if \texttt{n >= 0}, or \texttt{-n} applications of \texttt{prevfloat} if \texttt{n < 0}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L580-L585}{\texttt{source}}



\begin{lstlisting}
nextfloat(x::AbstractFloat)
\end{lstlisting}

Returns the smallest floating point number \texttt{y} of the same type as \texttt{x} such \texttt{x < y}. If no such \texttt{y} exists (e.g. if \texttt{x} is \texttt{Inf} or \texttt{NaN}), then returns \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L624-L629}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14035790731013288499}{} 
\hyperlink{14035790731013288499}{\texttt{Base.prevfloat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prevfloat(x::AbstractFloat)
\end{lstlisting}

Returns the largest floating point number \texttt{y} of the same type as \texttt{x} such \texttt{y < x}. If no such \texttt{y} exists (e.g. if \texttt{x} is \texttt{-Inf} or \texttt{NaN}), then returns \texttt{x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L632-L637}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1292047667500506923}{} 
\hyperlink{1292047667500506923}{\texttt{Base.isinteger}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isinteger(x) -> Bool
\end{lstlisting}

Test whether \texttt{x} is numerically equal to some integer.


\begin{minted}{jlcon}
julia> isinteger(4.0)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L4-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11869977035061433209}{} 
\hyperlink{11869977035061433209}{\texttt{Base.isreal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isreal(x) -> Bool
\end{lstlisting}

Test whether \texttt{x} or all its elements are numerically equal to some real number.


\begin{minted}{jlcon}
julia> isreal(5.)
true

julia> isreal([4.; complex(0,1)])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L101-L113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11475816161015002523}{} 
\hyperlink{11475816161015002523}{\texttt{Core.Float32}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float32(x [, mode::RoundingMode])
\end{lstlisting}

Create a Float32 from \texttt{x}. If \texttt{x} is not exactly representable then \texttt{mode} determines how \texttt{x} is rounded.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float32(1/3, RoundDown)
0.3333333f0

julia> Float32(1/3, RoundUp)
0.33333334f0
\end{minted}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L221-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5076205197474650253}{} 
\hyperlink{5076205197474650253}{\texttt{Core.Float64}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Float64(x [, mode::RoundingMode])
\end{lstlisting}

Create a Float64 from \texttt{x}. If \texttt{x} is not exactly representable then \texttt{mode} determines how \texttt{x} is rounded.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Float64(pi, RoundDown)
3.141592653589793

julia> Float64(pi, RoundUp)
3.1415926535897936
\end{minted}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L925-L941}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11702055980905109221}{} 
\hyperlink{11702055980905109221}{\texttt{Base.GMP.BigInt}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigInt(x)
\end{lstlisting}

Create an arbitrary precision integer. \texttt{x} may be an \texttt{Int} (or anything that can be converted to an \texttt{Int}). The usual mathematical operators are defined for this type, and results are promoted to a \hyperlink{423405808990690832}{\texttt{BigInt}}.

Instances can be constructed from strings via \hyperlink{13108503824143481717}{\texttt{parse}}, or using the \texttt{big} string literal.


\begin{minted}{jlcon}
julia> parse(BigInt, "42")
42

julia> big"313"
313
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/gmp.jl#L61-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4271393203106392383}{} 
\hyperlink{4271393203106392383}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x)
\end{lstlisting}

Create an arbitrary precision floating point number. \texttt{x} may be an \hyperlink{8469131683393450448}{\texttt{Integer}}, a \hyperlink{5027751419500983000}{\texttt{Float64}} or a \hyperlink{423405808990690832}{\texttt{BigInt}}. The usual mathematical operators are defined for this type, and results are promoted to a \hyperlink{749816618809421837}{\texttt{BigFloat}}.

Note that because decimal literals are converted to floating point numbers when parsed, \texttt{BigFloat(2.1)} may not yield what you expect. You may instead prefer to initialize constants from strings via \hyperlink{13108503824143481717}{\texttt{parse}}, or using the \texttt{big} string literal.


\begin{minted}{jlcon}
julia> BigFloat(2.1)
2.100000000000000088817841970012523233890533447265625000000000000000000000000000

julia> big"2.1"
2.099999999999999999999999999999999999999999999999999999999999999999999999999986
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L68-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6511778857518292792}{} 
\hyperlink{6511778857518292792}{\texttt{Base.Rounding.rounding}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rounding(T)
\end{lstlisting}

Get the current floating point rounding mode for type \texttt{T}, controlling the rounding of basic arithmetic functions (\hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{8486205126068439173}{\texttt{*}}, \hyperlink{4103478871488785445}{\texttt{/}} and \hyperlink{4178506499510800909}{\texttt{sqrt}}) and type conversion.

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available modes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L131-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12025922235501343815}{} 
\hyperlink{12025922235501343815}{\texttt{Base.Rounding.setrounding}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setrounding(T, mode)
\end{lstlisting}

Set the rounding mode of floating point type \texttt{T}, controlling the rounding of basic arithmetic functions (\hyperlink{3677358729494553841}{\texttt{+}}, \hyperlink{8228207173393714756}{\texttt{-}}, \hyperlink{8486205126068439173}{\texttt{*}}, \hyperlink{4103478871488785445}{\texttt{/}} and \hyperlink{4178506499510800909}{\texttt{sqrt}}) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default \texttt{RoundNearest}.

Note that this may affect other types, for instance changing the rounding mode of \hyperlink{5027751419500983000}{\texttt{Float64}} will change the rounding mode of \hyperlink{8101639384272933082}{\texttt{Float32}}. See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available modes.

\begin{quote}
\textbf{Warning}

This feature is still experimental, and may give unexpected or incorrect values.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L112-L128}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9774741470027705214}{} 
\hyperlink{9774741470027705214}{\texttt{Base.Rounding.setrounding}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setrounding(f::Function, T, mode)
\end{lstlisting}

Change the rounding mode of floating point type \texttt{T} for the duration of \texttt{f}. It is logically equivalent to:


\begin{lstlisting}
old = rounding(T)
setrounding(T, mode)
f()
setrounding(T, old)
\end{lstlisting}

See \hyperlink{16713322195952720212}{\texttt{RoundingMode}} for available rounding modes.

\begin{quote}
\textbf{Warning}

This feature is still experimental, and may give unexpected or incorrect values. A known problem is the interaction with compiler optimisations, e.g.


\begin{lstlisting}
julia> setrounding(Float64,RoundDown) do
           1.1 + 0.1
       end
1.2000000000000002
\end{lstlisting}

Here the compiler is \emph{constant folding}, that is evaluating a known constant expression at compile time, however the rounding mode is only changed at runtime, so this is not reflected in the function result. This can be avoided by moving constants outside the expression, e.g.


\begin{lstlisting}
julia> x = 1.1; y = 0.1;

julia> setrounding(Float64,RoundDown) do
           x + y
       end
1.2
\end{lstlisting}

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L148-L182}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13184231496538414617}{} 
\hyperlink{13184231496538414617}{\texttt{Base.Rounding.get\_zero\_subnormals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get_zero_subnormals() -> Bool
\end{lstlisting}

Returns \texttt{false} if operations on subnormal floating-point values ({\textquotedbl}denormals{\textquotedbl}) obey rules for IEEE arithmetic, and \texttt{true} if they might be converted to zeros.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L235-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2845950135157372113}{} 
\hyperlink{2845950135157372113}{\texttt{Base.Rounding.set\_zero\_subnormals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
set_zero_subnormals(yes::Bool) -> Bool
\end{lstlisting}

If \texttt{yes} is \texttt{false}, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values ({\textquotedbl}denormals{\textquotedbl}). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns \texttt{true} unless \texttt{yes==true} but the hardware does not support zeroing of subnormal numbers.

\texttt{set\_zero\_subnormals(true)} can speed up some computations on some hardware. However, it can break identities such as \texttt{(x-y==0) == (x==y)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L222-L232}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13973154041881077585}{}


\subsection{Enteros}


\hypertarget{4179288755987827924}{} 
\hyperlink{4179288755987827924}{\texttt{Base.count\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
count_ones(x::Integer) -> Integer
\end{lstlisting}

Number of ones in the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> count_ones(7)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L216-L225}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7870666257802898093}{} 
\hyperlink{7870666257802898093}{\texttt{Base.count\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
count_zeros(x::Integer) -> Integer
\end{lstlisting}

Number of zeros in the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> count_zeros(Int32(2 ^ 16 - 1))
16
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L252-L261}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7979293123371436933}{} 
\hyperlink{7979293123371436933}{\texttt{Base.leading\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
leading_zeros(x::Integer) -> Integer
\end{lstlisting}

Number of zeros leading the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> leading_zeros(Int32(1))
31
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L228-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9160604458117919092}{} 
\hyperlink{9160604458117919092}{\texttt{Base.leading\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
leading_ones(x::Integer) -> Integer
\end{lstlisting}

Number of ones leading the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> leading_ones(UInt32(2 ^ 32 - 2))
31
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L264-L273}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4757748081622484794}{} 
\hyperlink{4757748081622484794}{\texttt{Base.trailing\_zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trailing_zeros(x::Integer) -> Integer
\end{lstlisting}

Number of zeros trailing the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> trailing_zeros(2)
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L240-L249}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1557366507921404436}{} 
\hyperlink{1557366507921404436}{\texttt{Base.trailing\_ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trailing_ones(x::Integer) -> Integer
\end{lstlisting}

Number of ones trailing the binary representation of \texttt{x}.


\begin{minted}{jlcon}
julia> trailing_ones(3)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L276-L285}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2288006657111547854}{} 
\hyperlink{2288006657111547854}{\texttt{Base.isodd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isodd(x::Integer) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{x} is odd (that is, not divisible by 2), and \texttt{false} otherwise.


\begin{minted}{jlcon}
julia> isodd(9)
true

julia> isodd(10)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L40-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6755629456808693979}{} 
\hyperlink{6755629456808693979}{\texttt{Base.iseven}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iseven(x::Integer) -> Bool
\end{lstlisting}

Returns \texttt{true} is \texttt{x} is even (that is, divisible by 2), and \texttt{false} otherwise.


\begin{minted}{jlcon}
julia> iseven(9)
false

julia> iseven(10)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L55-L67}{\texttt{source}}


\end{adjustwidth}

\hypertarget{49378622553144223}{}


\section{BigFloats}



El tipo \hyperlink{749816618809421837}{\texttt{BigFloat}} implementa el punto flotante de precisión arbitraria usando la librería \href{http://www.mpfr.org/}{GNU MPFR library}.


\hypertarget{13742359768532654153}{} 
\hyperlink{13742359768532654153}{\texttt{Base.precision}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
precision(num::AbstractFloat)
\end{lstlisting}

Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L58-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6555036846799841969}{} 
\hyperlink{6555036846799841969}{\texttt{Base.precision}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
precision(BigFloat)
\end{lstlisting}

Get the precision (in bits) currently used for \hyperlink{749816618809421837}{\texttt{BigFloat}} arithmetic.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L715-L719}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3543074496498234209}{} 
\hyperlink{3543074496498234209}{\texttt{Base.MPFR.setprecision}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setprecision([T=BigFloat,] precision::Int)
\end{lstlisting}

Set the precision (in bits) to be used for \texttt{T} arithmetic.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L722-L726}{\texttt{source}}



\begin{lstlisting}
setprecision(f::Function, [T=BigFloat,] precision::Integer)
\end{lstlisting}

Change the \texttt{T} arithmetic precision (in bits) for the duration of \texttt{f}. It is logically equivalent to:


\begin{lstlisting}
old = precision(BigFloat)
setprecision(BigFloat, precision)
f()
setprecision(BigFloat, old)
\end{lstlisting}

Often used as \texttt{setprecision(T, precision) do ... end}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L859-L871}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13864548194538713914}{} 
\hyperlink{13864548194538713914}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x, prec::Int)
\end{lstlisting}

Create a representation of \texttt{x} as a \hyperlink{749816618809421837}{\texttt{BigFloat}} with precision \texttt{prec}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L129-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17009103194016650356}{} 
\hyperlink{17009103194016650356}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x, rounding::RoundingMode)
\end{lstlisting}

Create a representation of \texttt{x} as a \hyperlink{749816618809421837}{\texttt{BigFloat}} with the current global precision and rounding mode \texttt{rounding}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L152-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17130792833108028378}{} 
\hyperlink{17130792833108028378}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x, prec::Int, rounding::RoundingMode)
\end{lstlisting}

Create a representation of \texttt{x} as a \hyperlink{749816618809421837}{\texttt{BigFloat}} with precision \texttt{prec} and rounding mode \texttt{rounding}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L140-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16434633818001249494}{} 
\hyperlink{16434633818001249494}{\texttt{Base.MPFR.BigFloat}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BigFloat(x::String)
\end{lstlisting}

Create a representation of the string \texttt{x} as a \hyperlink{749816618809421837}{\texttt{BigFloat}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L162-L166}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4868036498049031913}{}


\section{Números Aleatorios}



La generación de números aleatorios en Julia utiliza la \href{http://www.math.sci.hiroshima-u.ac.jp/{\textasciitilde}m-mat/MT/SFMT/\#dSFMT}{librería Mersenne Twister} a través de objetos \texttt{MersenneTwister}. Julia tiene un RNG global que es usado por defecto. Pueden conectarse otros tipos RNG heredando del tipo \texttt{AbstractRNG}; estos pueden ser usados entonces para tener múltiples flujos de números aleatorios. Ademas de \texttt{MersenneTwister}, Julia proporciona el tipo RNG \texttt{RandomDevice} que es un \emph{wrapper} sobre la entropía proporcionada por el SO.



La mayoría de las funciones relacionadas con la generación aleatoria aceptan un \texttt{AbstractRNG} opcional como primer argumento,\texttt{rng}, que se predetermina al global si no se proporciona. Además, algunos de ellos aceptan opcionalmente especificaciones de dimensión \texttt{dims ...} (que pueden darse como una tupla) para generar matrices de valores aleatorios.



Un RNG de tipo \texttt{MersenneTwister} o \texttt{RandomDevice} puede generar números aleatorios de los siguientes tipos: \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{46725311238864537}{\texttt{Bool}}, \hyperlink{5857518405103968275}{\texttt{Int8}}, \hyperlink{6609065134969660118}{\texttt{UInt8}}, \hyperlink{6667287249103968645}{\texttt{Int16}}, \hyperlink{7018610346698168012}{\texttt{UInt16}}, \hyperlink{10103694114785108551}{\texttt{Int32}}, \hyperlink{8690996847580776341}{\texttt{UInt32}}, \hyperlink{7720564657383125058}{\texttt{Int64}}, \hyperlink{5500998675195555601}{\texttt{UInt64}}, \hyperlink{8012327724714767060}{\texttt{Int128}}, \hyperlink{14811222188335428522}{\texttt{UInt128}}, \hyperlink{423405808990690832}{\texttt{BigInt}} (o números complejos de estos tipos). Los números aleatorios en punto flotante son generados uniformemente en \([0, 1)\). Como \texttt{BigInt} representa números sin límite, el intervalo debe ser especificado (por ejemplo, \texttt{rand(big(1:6))}).


\hypertarget{17286498223669350061}{} 
\hyperlink{17286498223669350061}{\texttt{Base.Random.srand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
srand([rng=GLOBAL_RNG], [seed]) -> rng
srand([rng=GLOBAL_RNG], filename, n=4) -> rng
\end{lstlisting}

Reseed the random number generator. If a \texttt{seed} is provided, the RNG will give a reproducible sequence of numbers, otherwise Julia will get entropy from the system. For \texttt{MersenneTwister}, the \texttt{seed} may be a non-negative integer, a vector of \hyperlink{8690996847580776341}{\texttt{UInt32}} integers or a filename, in which case the seed is read from a file (\texttt{4n} bytes are read from the file, where \texttt{n} is an optional argument). \texttt{RandomDevice} does not support seeding.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L227-L236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{551200304137770185}{} 
\hyperlink{551200304137770185}{\texttt{Base.Random.MersenneTwister}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
MersenneTwister(seed)
\end{lstlisting}

Create a \texttt{MersenneTwister} RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L91-L101}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5947748412776859033}{} 
\hyperlink{5947748412776859033}{\texttt{Base.Random.RandomDevice}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RandomDevice()
\end{lstlisting}

Create a \texttt{RandomDevice} RNG object. Two such objects will always generate different streams of random numbers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L58-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{791894090820620170}{} 
\hyperlink{791894090820620170}{\texttt{Base.Random.rand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rand([rng=GLOBAL_RNG], [S], [dims...])
\end{lstlisting}

Pick a random element or array of random elements from the set of values specified by \texttt{S}; \texttt{S} can be

\begin{itemize}
\item an indexable collection (for example \texttt{1:n} or \texttt{[{\textquotesingle}x{\textquotesingle},{\textquotesingle}y{\textquotesingle},{\textquotesingle}z{\textquotesingle}]}), or


\item a type: the set of values to pick from is then equivalent to \texttt{typemin(S):typemax(S)} for integers (this is not applicable to \hyperlink{423405808990690832}{\texttt{BigInt}}), and to \([0, 1)\) for floating point numbers;

\end{itemize}
\texttt{S} defaults to \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L270-L281}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16989846397353234661}{} 
\hyperlink{16989846397353234661}{\texttt{Base.Random.rand!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rand!([rng=GLOBAL_RNG], A, [coll])
\end{lstlisting}

Populate the array \texttt{A} with random values. If the indexable collection \texttt{coll} is specified, the values are picked randomly from \texttt{coll}. This is equivalent to \texttt{copy!(A, rand(rng, coll, size(A)))} or \texttt{copy!(A, rand(rng, eltype(A), size(A)))} but without allocating a new array.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> rand!(rng, zeros(5))
5-element Array{Float64,1}:
 0.590845
 0.766797
 0.566237
 0.460085
 0.794026
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L292-L312}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13054959906721930538}{} 
\hyperlink{13054959906721930538}{\texttt{Base.Random.bitrand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bitrand([rng=GLOBAL_RNG], [dims...])
\end{lstlisting}

Generate a \texttt{BitArray} of random boolean values.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> bitrand(rng, 10)
10-element BitArray{1}:
  true
  true
  true
 false
  true
 false
 false
  true
 false
  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L710-L733}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8153706463199753760}{} 
\hyperlink{8153706463199753760}{\texttt{Base.Random.randn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randn([rng=GLOBAL_RNG], [T=Float64], [dims...])
\end{lstlisting}

Generate a normally-distributed random number of type \texttt{T} with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The \texttt{Base} module currently provides an implementation for the types \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}} (the default).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randn(rng, Float64)
0.8673472019512456

julia> randn(rng, Float32, (2, 4))
2×4 Array{Float32,2}:
 -0.901744  -0.902914  2.21188   -0.271735
 -0.494479   0.864401  0.532813   0.502334
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1234-L1255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2222955760771131822}{} 
\hyperlink{2222955760771131822}{\texttt{Base.Random.randn!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randn!([rng=GLOBAL_RNG], A::AbstractArray) -> A
\end{lstlisting}

Fill the array \texttt{A} with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the \hyperlink{791894090820620170}{\texttt{rand}} function.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randn!(rng, zeros(5))
5-element Array{Float64,1}:
  0.867347
 -0.901744
 -0.494479
 -0.902914
  0.864401
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1325-L1344}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8327808895184947306}{} 
\hyperlink{8327808895184947306}{\texttt{Base.Random.randexp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randexp([rng=GLOBAL_RNG], [T=Float64], [dims...])
\end{lstlisting}

Generate a random number of type \texttt{T} according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The \texttt{Base} module currently provides an implementation for the types \hyperlink{2727296760866702904}{\texttt{Float16}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, and \hyperlink{5027751419500983000}{\texttt{Float64}} (the default).

\textbf{Examples}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randexp(rng, Float32)
2.4835055f0

julia> randexp(rng, 3, 3)
3×3 Array{Float64,2}:
 1.5167    1.30652   0.344435
 0.604436  2.78029   0.418516
 0.695867  0.693292  0.643644
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1282-L1304}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16869392479092224800}{} 
\hyperlink{16869392479092224800}{\texttt{Base.Random.randexp!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randexp!([rng=GLOBAL_RNG], A::AbstractArray) -> A
\end{lstlisting}

Fill the array \texttt{A} with random numbers following the exponential distribution (with scale 1).

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randexp!(rng, zeros(5))
5-element Array{Float64,1}:
 2.48351
 1.5167
 0.604436
 0.695867
 1.30652
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1347-L1365}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7925659177712248661}{} 
\hyperlink{7925659177712248661}{\texttt{Base.Random.randjump}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randjump(r::MersenneTwister, jumps::Integer, [jumppoly::AbstractString=dSFMT.JPOLY1e21]) -> Vector{MersenneTwister}
\end{lstlisting}

Create an array of the size \texttt{jumps} of initialized \texttt{MersenneTwister} RNG objects. The first RNG object given as a parameter and following \texttt{MersenneTwister} RNGs in the array are initialized such that a state of the RNG object in the array would be moved forward (without generating numbers) from a previous RNG object array element on a particular number of steps encoded by the jump polynomial \texttt{jumppoly}.

Default jump polynomial moves forward \texttt{MersenneTwister} RNG state by \texttt{10{\textasciicircum}20} steps.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L158-L168}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7104946044181754749}{}


\chapter{Cadenas}


\hypertarget{10635384680993060803}{} 
\hyperlink{10635384680993060803}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
length(s::AbstractString)
\end{lstlisting}

The number of characters in string \texttt{s}.

\textbf{Example}


\begin{minted}{jlcon}
julia> length("jμΛIα")
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L80-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1670208154575640673}{} 
\hyperlink{1670208154575640673}{\texttt{Base.sizeof}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sizeof(s::AbstractString)
\end{lstlisting}

The number of bytes in string \texttt{s}.

\textbf{Example}


\begin{minted}{jlcon}
julia> sizeof("❤")
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L44-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8486205126068439173}{} 
\hyperlink{8486205126068439173}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
*(x, y...)
\end{lstlisting}

Multiplication operator. \texttt{x*y*z*...} calls this function with all arguments, i.e. \texttt{*(x, y, z, ...)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1917-L1923}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5729367935110528960}{} 
\hyperlink{5729367935110528960}{\texttt{Base.:{\textasciicircum}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
^(s::AbstractString, n::Integer)
\end{lstlisting}

Repeat \texttt{n} times the string \texttt{s}. The \hyperlink{15426606278434194584}{\texttt{repeat}} function is an alias to this operator.


\begin{minted}{jlcon}
julia> "Test "^3
"Test Test Test "
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/types.jl#L143-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7919678712989769360}{} 
\hyperlink{7919678712989769360}{\texttt{Base.string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
string(xs...)
\end{lstlisting}

Create a string from any values using the \hyperlink{8248717042415202230}{\texttt{print}} function.


\begin{minted}{jlcon}
julia> string("a", 1, true)
"a1true"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L110-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8980238867920079536}{} 
\hyperlink{8980238867920079536}{\texttt{Base.repr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
repr(x)
\end{lstlisting}

Create a string from any value using the \hyperlink{16724886348217614039}{\texttt{showall}} function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L139-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2825695355940841177}{} 
\hyperlink{2825695355940841177}{\texttt{Core.String}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
String(s::AbstractString)
\end{lstlisting}

Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L13-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11147209877072452260}{} 
\hyperlink{11147209877072452260}{\texttt{Base.transcode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
transcode(T, src)
\end{lstlisting}

Convert string data between Unicode encodings. \texttt{src} is either a \texttt{String} or a \texttt{Vector\{UIntXX\}} of UTF-XX code units, where \texttt{XX} is 8, 16, or 32. \texttt{T} indicates the encoding of the return value: \texttt{String} to return a (UTF-8 encoded) \texttt{String} or \texttt{UIntXX} to return a \texttt{Vector\{UIntXX\}} of UTF-\texttt{XX} data.   (The alias \texttt{Cwchar\_t} can also be used as the integer type, for converting \texttt{wchar\_t*} strings used by external C libraries.)

The \texttt{transcode} function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.

Only conversion to/from UTF-8 is currently supported.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L159-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12370128473268209010}{} 
\hyperlink{12370128473268209010}{\texttt{Base.unsafe\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_string(p::Ptr{UInt8}, [length::Integer])
\end{lstlisting}

Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If \texttt{length} is specified (the length of the data in bytes), the string does not have to be NUL-terminated.

This function is labelled {\textquotedbl}unsafe{\textquotedbl} because it will crash if \texttt{p} is not a valid memory address to data of the requested length.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/string.jl#L24-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13116468520781826934}{} 
\hyperlink{13116468520781826934}{\texttt{Base.codeunit}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
codeunit(s::AbstractString, i::Integer)
\end{lstlisting}

Get the \texttt{i}th code unit of an encoded string. For example, returns the \texttt{i}th byte of the representation of a UTF-8 string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/string.jl#L56-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16934723397501354088}{} 
\hyperlink{16934723397501354088}{\texttt{Base.ascii}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ascii(s::AbstractString)
\end{lstlisting}

Convert a string to \texttt{String} type and check that it contains only ASCII data, otherwise throwing an \texttt{ArgumentError} indicating the position of the first non-ASCII byte.


\begin{minted}{jlcon}
julia> ascii("abcdeγfgh")
ERROR: ArgumentError: invalid ASCII at index 6 in "abcdeγfgh"
Stacktrace:
 [1] ascii(::String) at ./strings/util.jl:479

julia> ascii("abcdefgh")
"abcdefgh"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L484-L499}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8320574829780813411}{} 
\hyperlink{8320574829780813411}{\texttt{Base.@r\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@r_str -> Regex
\end{lstlisting}

Construct a regex, such as \texttt{r{\textquotedbl}{\textasciicircum}[a-z]*\${\textquotedbl}}. The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:

\begin{itemize}
\item \texttt{i} enables case-insensitive matching


\item \texttt{m} treats the \texttt{{\textasciicircum}} and \texttt{\$} tokens as matching the start and end of individual lines, as opposed to the whole string.


\item \texttt{s} allows the \texttt{.} modifier to match newlines.


\item \texttt{x} enables {\textquotedbl}comment mode{\textquotedbl}: whitespace is enabled except when escaped with \texttt{{\textbackslash}}, and \texttt{\#} is treated as starting a comment.

\end{itemize}
For example, this regex has all three flags enabled:


\begin{minted}{jlcon}
julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/regex.jl#L63-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3198534740077872140}{} 
\hyperlink{3198534740077872140}{\texttt{Base.Docs.@html\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@html_str -> Docs.HTML
\end{lstlisting}

Create an \texttt{HTML} object from a literal string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/utils.jl#L37-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4530478957610065001}{} 
\hyperlink{4530478957610065001}{\texttt{Base.Docs.@text\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@text_str -> Docs.Text
\end{lstlisting}

Create a \texttt{Text} object from a literal string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/utils.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17939206388416277411}{} 
\hyperlink{17939206388416277411}{\texttt{Base.UTF8proc.normalize\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
normalize_string(s::AbstractString, normalform::Symbol)
\end{lstlisting}

Normalize the string \texttt{s} according to one of the four {\textquotedbl}normal forms{\textquotedbl} of the Unicode standard: \texttt{normalform} can be \texttt{:NFC}, \texttt{:NFD}, \texttt{:NFKC}, or \texttt{:NFKD}.  Normal forms C (canonical composition) and D (canonical decomposition) convert different visually identical representations of the same abstract string into a single canonical form, with form C being more compact.  Normal forms KC and KD additionally canonicalize {\textquotedbl}compatibility equivalents{\textquotedbl}: they convert characters that are abstractly similar but visually distinct into a single canonical choice (e.g. they expand ligatures into the individual characters), with form KC being more compact.

Alternatively, finer control and additional transformations may be be obtained by calling \texttt{normalize\_string(s; keywords...)}, where any number of the following boolean keywords options (which all default to \texttt{false} except for \texttt{compose}) are specified:

\begin{itemize}
\item \texttt{compose=false}: do not perform canonical composition


\item \texttt{decompose=true}: do canonical decomposition instead of canonical composition (\texttt{compose=true} is ignored if present)


\item \texttt{compat=true}: compatibility equivalents are canonicalized


\item \texttt{casefold=true}: perform Unicode case folding, e.g. for case-insensitive string comparison


\item \texttt{newline2lf=true}, \texttt{newline2ls=true}, or \texttt{newline2ps=true}: convert various newline sequences (LF, CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character, respectively


\item \texttt{stripmark=true}: strip diacritical marks (e.g. accents)


\item \texttt{stripignore=true}: strip Unicode{\textquotesingle}s {\textquotedbl}default ignorable{\textquotedbl} characters (e.g. the soft hyphen or the left-to-right marker)


\item \texttt{stripcc=true}: strip control characters; horizontal tabs and form feeds are converted to spaces; newlines are also converted to spaces unless a newline-conversion flag was specified


\item \texttt{rejectna=true}: throw an error if unassigned code points are found


\item \texttt{stable=true}: enforce Unicode Versioning Stability

\end{itemize}
For example, NFKC corresponds to the options \texttt{compose=true, compat=true, stable=true}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L146-L180}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13702591434765172496}{} 
\hyperlink{13702591434765172496}{\texttt{Base.UTF8proc.graphemes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
graphemes(s::AbstractString) -> GraphemeIterator
\end{lstlisting}

Returns an iterator over substrings of \texttt{s} that correspond to the extended graphemes in the string, as defined by Unicode UAX \#29. (Roughly, these are what users would perceive as single characters, even though they may contain more than one codepoint; for example a letter combined with an accent mark is a single grapheme.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L346-L353}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9678448882095016755}{} 
\hyperlink{9678448882095016755}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isvalid(value) -> Bool
\end{lstlisting}

Returns \texttt{true} if the given value is valid for its type, which currently can be either \texttt{Char} or \texttt{String}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2403-L2408}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16014659773986219432}{} 
\hyperlink{16014659773986219432}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isvalid(T, value) -> Bool
\end{lstlisting}

Returns \texttt{true} if the given value is valid for that type. Types currently can be either \texttt{Char} or \texttt{String}. Values for \texttt{Char} can be of type \texttt{Char} or \hyperlink{8690996847580776341}{\texttt{UInt32}}. Values for \texttt{String} can be of that type, or \texttt{Vector\{UInt8\}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2411-L2417}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10276715660934277801}{} 
\hyperlink{10276715660934277801}{\texttt{Base.isvalid}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isvalid(str::AbstractString, i::Integer)
\end{lstlisting}

Tells whether index \texttt{i} is valid for the given string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> isvalid(str, 1)
true

julia> str[1]
'α': Unicode U+03b1 (category Ll: Letter, lowercase)

julia> isvalid(str, 2)
false

julia> str[2]
ERROR: UnicodeError: invalid character index
[...]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L142-L165}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14265600875872242300}{} 
\hyperlink{14265600875872242300}{\texttt{Base.UTF8proc.is\_assigned\_char}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_assigned_char(c) -> Bool
\end{lstlisting}

Returns \texttt{true} if the given char or integer is an assigned Unicode code point.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L213-L217}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12183734646641519159}{} 
\hyperlink{12183734646641519159}{\texttt{Base.ismatch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ismatch(r::Regex, s::AbstractString) -> Bool
\end{lstlisting}

Test whether a string contains a match of the given regular expression.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1933-L1937}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2695862412477105800}{} 
\hyperlink{2695862412477105800}{\texttt{Base.match}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])
\end{lstlisting}

Search for the first match of the regular expression \texttt{r} in \texttt{s} and return a \texttt{RegexMatch} object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing \texttt{m.match} and the captured sequences can be retrieved by accessing \texttt{m.captures} The optional \texttt{idx} argument specifies an index at which to start the search.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2102-L2109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2810316550892708557}{} 
\hyperlink{2810316550892708557}{\texttt{Base.eachmatch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eachmatch(r::Regex, s::AbstractString[, overlap::Bool=false])
\end{lstlisting}

Search for all matches of a the regular expression \texttt{r} in \texttt{s} and return a iterator over the matches. If overlap is \texttt{true}, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L593-L599}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5181495363849711239}{} 
\hyperlink{5181495363849711239}{\texttt{Base.matchall}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
matchall(r::Regex, s::AbstractString[, overlap::Bool=false]) -> Vector{AbstractString}
\end{lstlisting}

Return a vector of the matching substrings from \hyperlink{2810316550892708557}{\texttt{eachmatch}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1940-L1944}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3722145084740074291}{} 
\hyperlink{3722145084740074291}{\texttt{Base.lpad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lpad(s, n::Integer, p::AbstractString=" ")
\end{lstlisting}

Make a string at least \texttt{n} columns wide when printed by padding \texttt{s} on the left with copies of \texttt{p}.


\begin{minted}{jlcon}
julia> lpad("March",10)
"     March"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L224-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12508684325429723537}{} 
\hyperlink{12508684325429723537}{\texttt{Base.rpad}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rpad(s, n::Integer, p::AbstractString=" ")
\end{lstlisting}

Make a string at least \texttt{n} columns wide when printed by padding \texttt{s} on the right with copies of \texttt{p}.


\begin{minted}{jlcon}
julia> rpad("March",20)
"March               "
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L237-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10006050288379145945}{} 
\hyperlink{10006050288379145945}{\texttt{Base.search}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
search(string::AbstractString, chars::Chars, [start::Integer])
\end{lstlisting}

Search for the first occurrence of the given characters within the given string. The second argument may be a single character, a vector or a set of characters, a string, or a regular expression (though regular expressions are only allowed on contiguous strings, such as ASCII or UTF-8 strings). The third argument optionally specifies a starting index. The return value is a range of indexes where the matching sequence is found, such that \texttt{s[search(s,x)] == x}:

\texttt{search(string, {\textquotedbl}substring{\textquotedbl})} = \texttt{start:end} such that \texttt{string[start:end] == {\textquotedbl}substring{\textquotedbl}}, or \texttt{0:-1} if unmatched.

\texttt{search(string, {\textquotesingle}c{\textquotesingle})} = \texttt{index} such that \texttt{string[index] == {\textquotesingle}c{\textquotesingle}}, or \texttt{0} if unmatched.


\begin{minted}{jlcon}
julia> search("Hello to the world", "z")
0:-1

julia> search("JuliaLang","Julia")
1:5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L5-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3355355726219213290}{} 
\hyperlink{3355355726219213290}{\texttt{Base.rsearch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rsearch(s::AbstractString, chars::Chars, [start::Integer])
\end{lstlisting}

Similar to \hyperlink{10006050288379145945}{\texttt{search}}, but returning the last occurrence of the given characters within the given string, searching in reverse from \texttt{start}.


\begin{minted}{jlcon}
julia> rsearch("aaabbb","b")
6:6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L199-L209}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14183102834887354380}{} 
\hyperlink{14183102834887354380}{\texttt{Base.searchindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
searchindex(s::AbstractString, substring, [start::Integer])
\end{lstlisting}

Similar to \hyperlink{10006050288379145945}{\texttt{search}}, but return only the start index at which the substring is found, or \texttt{0} if it is not.


\begin{minted}{jlcon}
julia> searchindex("Hello to the world", "z")
0

julia> searchindex("JuliaLang","Julia")
1

julia> searchindex("JuliaLang","Lang")
6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L149-L165}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8139560711805016124}{} 
\hyperlink{8139560711805016124}{\texttt{Base.rsearchindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rsearchindex(s::AbstractString, substring, [start::Integer])
\end{lstlisting}

Similar to \hyperlink{3355355726219213290}{\texttt{rsearch}}, but return only the start index at which the substring is found, or \texttt{0} if it is not.


\begin{minted}{jlcon}
julia> rsearchindex("aaabbb","b")
6

julia> rsearchindex("aaabbb","a")
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L314-L326}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17633982666065151863}{} 
\hyperlink{17633982666065151863}{\texttt{Base.contains}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
contains(haystack::AbstractString, needle::AbstractString)
\end{lstlisting}

Determine whether the second argument is a substring of the first.


\begin{minted}{jlcon}
julia> contains("JuliaLang is pretty cool!", "Julia")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/search.jl#L368-L377}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17372290750646920644}{} 
\hyperlink{17372290750646920644}{\texttt{Base.reverse}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reverse(s::AbstractString) -> AbstractString
\end{lstlisting}

Reverses a string.


\begin{minted}{jlcon}
julia> reverse("JuliaLang")
"gnaLailuJ"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/types.jl#L116-L124}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1718748356383062256}{} 
\hyperlink{1718748356383062256}{\texttt{Base.replace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
replace(string::AbstractString, pat, r[, n::Integer=0])
\end{lstlisting}

Search for the given pattern \texttt{pat}, and replace each occurrence with \texttt{r}. If \texttt{n} is provided, replace at most \texttt{n} occurrences. As with search, the second argument may be a single character, a vector or a set of characters, a string, or a regular expression. If \texttt{r} is a function, each occurrence is replaced with \texttt{r(s)} where \texttt{s} is the matched substring. If \texttt{pat} is a regular expression and \texttt{r} is a \texttt{SubstitutionString}, then capture group references in \texttt{r} are replaced with the corresponding matched text.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L393-L402}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8368077469888537439}{} 
\hyperlink{8368077469888537439}{\texttt{Base.split}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
split(s::AbstractString, [chars]; limit::Integer=0, keep::Bool=true)
\end{lstlisting}

Return an array of substrings by splitting the given string on occurrences of the given character delimiters, which may be specified in any of the formats allowed by \texttt{search}{\textquotesingle}s second argument (i.e. a single character, collection of characters, string, or regular expression). If \texttt{chars} is omitted, it defaults to the set of all space characters, and \texttt{keep} is taken to be \texttt{false}. The two keyword arguments are optional: they are a maximum size for the result and a flag determining whether empty fields should be kept in the result.


\begin{minted}{jlcon}
julia> a = "Ma.rch"
"Ma.rch"

julia> split(a,".")
2-element Array{SubString{String},1}:
 "Ma"
 "rch"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L256-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15507349251888266905}{} 
\hyperlink{15507349251888266905}{\texttt{Base.rsplit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rsplit(s::AbstractString, [chars]; limit::Integer=0, keep::Bool=true)
\end{lstlisting}

Similar to \hyperlink{8368077469888537439}{\texttt{split}}, but starting from the end of the string.


\begin{minted}{jlcon}
julia> a = "M.a.r.c.h"
"M.a.r.c.h"

julia> rsplit(a,".")
5-element Array{SubString{String},1}:
 "M"
 "a"
 "r"
 "c"
 "h"

julia> rsplit(a,".";limit=1)
1-element Array{SubString{String},1}:
 "M.a.r.c.h"

julia> rsplit(a,".";limit=2)
2-element Array{SubString{String},1}:
 "M.a.r.c"
 "h"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L307-L333}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7002432768371197450}{} 
\hyperlink{7002432768371197450}{\texttt{Base.strip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strip(s::AbstractString, [chars::Chars])
\end{lstlisting}

Return \texttt{s} with any leading and trailing whitespace removed. If \texttt{chars} (a character, or vector or set of characters) is provided, instead remove characters contained in it.


\begin{minted}{jlcon}
julia> strip("{3, 5}\n", ['{', '}', '\n'])
"3, 5"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L181-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7433804272240772935}{} 
\hyperlink{7433804272240772935}{\texttt{Base.lstrip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lstrip(s::AbstractString[, chars::Chars])
\end{lstlisting}

Return \texttt{s} with any leading whitespace and delimiters removed. The default delimiters to remove are \texttt{{\textquotesingle} {\textquotesingle}}, \texttt{{\textbackslash}t}, \texttt{{\textbackslash}n}, \texttt{{\textbackslash}v}, \texttt{{\textbackslash}f}, and \texttt{{\textbackslash}r}. If \texttt{chars} (a character, or vector or set of characters) is provided, instead remove characters contained in it.


\begin{minted}{jlcon}
julia> a = lpad("March", 20)
"               March"

julia> lstrip(a)
"March"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L122-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8645844793440900923}{} 
\hyperlink{8645844793440900923}{\texttt{Base.rstrip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rstrip(s::AbstractString[, chars::Chars])
\end{lstlisting}

Return \texttt{s} with any trailing whitespace and delimiters removed. The default delimiters to remove are \texttt{{\textquotesingle} {\textquotesingle}}, \texttt{{\textbackslash}t}, \texttt{{\textbackslash}n}, \texttt{{\textbackslash}v}, \texttt{{\textbackslash}f}, and \texttt{{\textbackslash}r}. If \texttt{chars} (a character, or vector or set of characters) is provided, instead remove characters contained in it.


\begin{minted}{jlcon}
julia> a = rpad("March", 20)
"March               "

julia> rstrip(a)
"March"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L151-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3780640516028077129}{} 
\hyperlink{3780640516028077129}{\texttt{Base.startswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
startswith(s::AbstractString, prefix::AbstractString)
\end{lstlisting}

Returns \texttt{true} if \texttt{s} starts with \texttt{prefix}. If \texttt{prefix} is a vector or set of characters, tests whether the first character of \texttt{s} belongs to that set.

See also \hyperlink{7763134966257769023}{\texttt{endswith}}.


\begin{minted}{jlcon}
julia> startswith("JuliaLang", "Julia")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L5-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7763134966257769023}{} 
\hyperlink{7763134966257769023}{\texttt{Base.endswith}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
endswith(s::AbstractString, suffix::AbstractString)
\end{lstlisting}

Returns \texttt{true} if \texttt{s} ends with \texttt{suffix}. If \texttt{suffix} is a vector or set of characters, tests whether the last character of \texttt{s} belongs to that set.

See also \hyperlink{3780640516028077129}{\texttt{startswith}}.


\begin{minted}{jlcon}
julia> endswith("Sunday", "day")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L30-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12677983900410542972}{} 
\hyperlink{12677983900410542972}{\texttt{Base.uppercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
uppercase(s::AbstractString)
\end{lstlisting}

Returns \texttt{s} with all characters converted to uppercase.

\textbf{Example}


\begin{minted}{jlcon}
julia> uppercase("Julia")
"JULIA"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L389-L400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4639905932946362908}{} 
\hyperlink{4639905932946362908}{\texttt{Base.lowercase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowercase(s::AbstractString)
\end{lstlisting}

Returns \texttt{s} with all characters converted to lowercase.

\textbf{Example}


\begin{minted}{jlcon}
julia> lowercase("STRINGS AND THINGS")
"strings and things"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L403-L414}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10496416994709882234}{} 
\hyperlink{10496416994709882234}{\texttt{Base.titlecase}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
titlecase(s::AbstractString)
\end{lstlisting}

Capitalizes the first character of each word in \texttt{s}.

\textbf{Example}


\begin{minted}{jlcon}
julia> titlecase("the julia programming language")
"The Julia Programming Language"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L417-L428}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17129604125086518189}{} 
\hyperlink{17129604125086518189}{\texttt{Base.ucfirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ucfirst(s::AbstractString)
\end{lstlisting}

Returns \texttt{string} with the first character converted to uppercase.

\textbf{Example}


\begin{minted}{jlcon}
julia> ucfirst("python")
"Python"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L444-L455}{\texttt{source}}


\end{adjustwidth}
\hypertarget{596092241182068434}{} 
\hyperlink{596092241182068434}{\texttt{Base.lcfirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lcfirst(s::AbstractString)
\end{lstlisting}

Returns \texttt{string} with the first character converted to lowercase.

\textbf{Example}


\begin{minted}{jlcon}
julia> lcfirst("Julia")
"julia"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L460-L471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18064910688022011979}{} 
\hyperlink{18064910688022011979}{\texttt{Base.join}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
join(io::IO, strings, delim, [last])
\end{lstlisting}

Join an array of \texttt{strings} into a single string, inserting the given delimiter between adjacent strings. If \texttt{last} is given, it will be used instead of \texttt{delim} between the last two strings. For example,


\begin{minted}{jlcon}
julia> join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"
\end{minted}

\texttt{strings} can be any iterable over elements \texttt{x} which are convertible to strings via \texttt{print(io::IOBuffer, x)}. \texttt{strings} will be printed to \texttt{io}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L172-L186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18002354026785919806}{} 
\hyperlink{18002354026785919806}{\texttt{Base.chop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chop(s::AbstractString)
\end{lstlisting}

Remove the last character from \texttt{s}.


\begin{minted}{jlcon}
julia> a = "March"
"March"

julia> chop(a)
"Marc"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L66-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5360081372937794006}{} 
\hyperlink{5360081372937794006}{\texttt{Base.chomp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chomp(s::AbstractString)
\end{lstlisting}

Remove a single trailing newline from a string.


\begin{minted}{jlcon}
julia> chomp("Hello\n")
"Hello"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L81-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6392662344610705448}{} 
\hyperlink{6392662344610705448}{\texttt{Base.ind2chr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ind2chr(s::AbstractString, i::Integer)
\end{lstlisting}

Convert a byte index \texttt{i} to a character index with respect to string \texttt{s}.

See also \hyperlink{3998544168504071055}{\texttt{chr2ind}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> ind2chr(str, 3)
2

julia> chr2ind(str, 2)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L262-L281}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3998544168504071055}{} 
\hyperlink{3998544168504071055}{\texttt{Base.chr2ind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chr2ind(s::AbstractString, i::Integer)
\end{lstlisting}

Convert a character index \texttt{i} to a byte index.

See also \hyperlink{6392662344610705448}{\texttt{ind2chr}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> chr2ind(str, 2)
3

julia> ind2chr(str, 3)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L296-L314}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7455293228649070526}{} 
\hyperlink{7455293228649070526}{\texttt{Base.nextind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nextind(str::AbstractString, i::Integer)
\end{lstlisting}

Get the next valid string index after \texttt{i}. Returns a value greater than \texttt{endof(str)} at or after the end of the string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> str = "αβγdef";

julia> nextind(str, 1)
3

julia> endof(str)
9

julia> nextind(str, 9)
10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L215-L235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15871508897466976220}{} 
\hyperlink{15871508897466976220}{\texttt{Base.prevind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
prevind(str::AbstractString, i::Integer)
\end{lstlisting}

Get the previous valid string index before \texttt{i}. Returns a value less than \texttt{1} at the beginning of the string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> prevind("αβγdef", 3)
1

julia> prevind("αβγdef", 1)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L184-L199}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1835361053788807915}{} 
\hyperlink{1835361053788807915}{\texttt{Base.Random.randstring}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randstring([rng,] len=8)
\end{lstlisting}

Create a random ASCII string of length \texttt{len}, consisting of upper- and lower-case letters and the digits 0-9. The optional \texttt{rng} argument specifies a random number generator, see \hyperlink{4868036498049031913}{Random Numbers}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randstring(rng, 4)
"mbDd"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L907-L922}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10345820167929797351}{} 
\hyperlink{10345820167929797351}{\texttt{Base.UTF8proc.charwidth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
charwidth(c)
\end{lstlisting}

Gives the number of columns needed to print a character.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L193-L197}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10855865814348701897}{} 
\hyperlink{10855865814348701897}{\texttt{Base.strwidth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strwidth(s::AbstractString)
\end{lstlisting}

Gives the number of columns needed to print a string.

\textbf{Example}


\begin{minted}{jlcon}
julia> strwidth("March")
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L342-L353}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10617070106229701570}{} 
\hyperlink{10617070106229701570}{\texttt{Base.UTF8proc.isalnum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isalnum(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is alphanumeric. A character is classified as alphabetic if it belongs to the Unicode general category Letter or Number, i.e. a character whose category code begins with {\textquotesingle}L{\textquotesingle} or {\textquotesingle}N{\textquotesingle}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L270-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2733388318366578098}{} 
\hyperlink{2733388318366578098}{\texttt{Base.UTF8proc.isalpha}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isalpha(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is alphabetic. A character is classified as alphabetic if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with {\textquotesingle}L{\textquotesingle}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L252-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15093956188358440526}{} 
\hyperlink{15093956188358440526}{\texttt{Base.isascii}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isascii(c::Union{Char,AbstractString}) -> Bool
\end{lstlisting}

Tests whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L356-L361}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7046677780358712703}{} 
\hyperlink{7046677780358712703}{\texttt{Base.UTF8proc.iscntrl}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iscntrl(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L285-L290}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2445306399786549198}{} 
\hyperlink{2445306399786549198}{\texttt{Base.UTF8proc.isdigit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdigit(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is a numeric digit (0-9).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L245-L249}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7069613128428293368}{} 
\hyperlink{7069613128428293368}{\texttt{Base.UTF8proc.isgraph}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isgraph(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is printable, and not a space. Any character that would cause a printer to use ink should be classified with \texttt{isgraph(c)==true}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L321-L327}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7556055480265629046}{} 
\hyperlink{7556055480265629046}{\texttt{Base.UTF8proc.islower}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
islower(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L222-L228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18059155338281639030}{} 
\hyperlink{18059155338281639030}{\texttt{Base.UTF8proc.isnumber}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isnumber(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with {\textquotesingle}N{\textquotesingle}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L261-L267}{\texttt{source}}


\end{adjustwidth}
\hypertarget{797129785907717137}{} 
\hyperlink{797129785907717137}{\texttt{Base.UTF8proc.isprint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isprint(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is printable, including spaces, but not a control character.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L312-L316}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7720498622841455852}{} 
\hyperlink{7720498622841455852}{\texttt{Base.UTF8proc.ispunct}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ispunct(c::Char) -> Bool
\end{lstlisting}

Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with {\textquotesingle}P{\textquotesingle}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L293-L298}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17667628008481296406}{} 
\hyperlink{17667628008481296406}{\texttt{Base.UTF8proc.isspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isspace(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is any whitespace character. Includes ASCII characters {\textquotesingle}{\textbackslash}t{\textquotesingle}, {\textquotesingle}{\textbackslash}n{\textquotesingle}, {\textquotesingle}{\textbackslash}v{\textquotesingle}, {\textquotesingle}{\textbackslash}f{\textquotesingle}, {\textquotesingle}{\textbackslash}r{\textquotesingle}, and {\textquotesingle} {\textquotesingle}, Latin-1 character U+0085, and characters in Unicode category Zs.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L303-L309}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18233029693907037733}{} 
\hyperlink{18233029693907037733}{\texttt{Base.UTF8proc.isupper}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isupper(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/utf8proc.jl#L233-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16472559569885457655}{} 
\hyperlink{16472559569885457655}{\texttt{Base.isxdigit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isxdigit(c::Char) -> Bool
\end{lstlisting}

Tests whether a character is a valid hexadecimal digit. Note that this does not include \texttt{x} (as in the standard \texttt{0x} prefix).

\textbf{Example}


\begin{minted}{jlcon}
julia> isxdigit('a')
true

julia> isxdigit('x')
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/basic.jl#L369-L384}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18332791376992528422}{} 
\hyperlink{18332791376992528422}{\texttt{Core.Symbol}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Symbol(x...) -> Symbol
\end{lstlisting}

Create a \texttt{Symbol} by concatenating the string representations of the arguments together.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2396-L2400}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2720373307114882969}{} 
\hyperlink{2720373307114882969}{\texttt{Base.escape\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
escape_string([io,] str::AbstractString[, esc::AbstractString]) -> AbstractString
\end{lstlisting}

General escaping of traditional C and Unicode escape sequences. Any characters in \texttt{esc} are also escaped (with a backslash). See also \hyperlink{4382494947698149975}{\texttt{unescape\_string}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L225-L231}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4382494947698149975}{} 
\hyperlink{4382494947698149975}{\texttt{Base.unescape\_string}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unescape_string([io,] s::AbstractString) -> AbstractString
\end{lstlisting}

General unescaping of traditional C and Unicode escape sequences. Reverse of \hyperlink{2720373307114882969}{\texttt{escape\_string}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L278-L283}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14629781252390713372}{}


\chapter{Arrays}



\hypertarget{6164914096834691514}{}


\section{Constructores y Tipos}


\hypertarget{6514416309183787338}{} 
\hyperlink{6514416309183787338}{\texttt{Core.AbstractArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AbstractArray{T, N}
\end{lstlisting}

Abstract array supertype which arrays inherit from.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15492651498431872487}{} 
\hyperlink{15492651498431872487}{\texttt{Core.Array}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Array{T}(dims)
Array{T,N}(dims)
\end{lstlisting}

Construct an uninitialized \texttt{N}-dimensional dense array with element type \texttt{T}, where \texttt{N} is determined from the length or number of \texttt{dims}. \texttt{dims} may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank \texttt{N} is supplied explicitly as in \texttt{Array\{T,N\}(dims)}, then it must match the length or number of \texttt{dims}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = Array{Float64, 2}(2, 2);

julia> ndims(A)
2

julia> eltype(A)
Float64
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L51-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2839226020402435013}{} 
\hyperlink{2839226020402435013}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getindex(type[, elements...])
\end{lstlisting}

Construct a 1-d array of the specified type. This is usually called with the syntax \texttt{Type[]}. Element values can be specified using \texttt{Type[a,b,c,...]}.

\textbf{Example}


\begin{minted}{jlcon}
julia> Int8[1, 2, 3]
3-element Array{Int8,1}:
 1
 2
 3

julia> getindex(Int8, 1, 2, 3)
3-element Array{Int8,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L96-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13837674686090348619}{} 
\hyperlink{13837674686090348619}{\texttt{Base.zeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
zeros([A::AbstractArray,] [T=eltype(A)::Type,] [dims=size(A)::Tuple])
\end{lstlisting}

Create an array of all zeros with the same layout as \texttt{A}, element type \texttt{T} and size \texttt{dims}. The \texttt{A} argument can be skipped, which behaves like \texttt{Array\{Float64,0\}()} was passed. For convenience \texttt{dims} may also be passed in variadic form.

\textbf{Examples}


\begin{minted}{jlcon}
julia> zeros(1)
1-element Array{Float64,1}:
 0.0

julia> zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> zeros(A)
2×2 Array{Int64,2}:
 0  0
 0  0

julia> zeros(A, Float64)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia> zeros(A, Bool, (3,))
3-element Array{Bool,1}:
 false
 false
 false
\end{minted}

See also \hyperlink{5858390260510292771}{\texttt{ones}}, \hyperlink{18368531196314541873}{\texttt{similar}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2353-L2393}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5858390260510292771}{} 
\hyperlink{5858390260510292771}{\texttt{Base.ones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ones([A::AbstractArray,] [T=eltype(A)::Type,] [dims=size(A)::Tuple])
\end{lstlisting}

Create an array of all ones with the same layout as \texttt{A}, element type \texttt{T} and size \texttt{dims}. The \texttt{A} argument can be skipped, which behaves like \texttt{Array\{Float64,0\}()} was passed. For convenience \texttt{dims} may also be passed in variadic form.

\textbf{Examples}


\begin{minted}{jlcon}
julia> ones(Complex128, 2, 3)
2×3 Array{Complex{Float64},2}:
 1.0+0.0im  1.0+0.0im  1.0+0.0im
 1.0+0.0im  1.0+0.0im  1.0+0.0im

julia> ones(1,2)
1×2 Array{Float64,2}:
 1.0  1.0

julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> ones(A)
2×2 Array{Int64,2}:
 1  1
 1  1

julia> ones(A, Float64)
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  1.0

julia> ones(A, Bool, (3,))
3-element Array{Bool,1}:
 true
 true
 true
\end{minted}

See also \hyperlink{13837674686090348619}{\texttt{zeros}}, \hyperlink{18368531196314541873}{\texttt{similar}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L429-L469}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18015155802543401629}{} 
\hyperlink{18015155802543401629}{\texttt{Base.BitArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
BitArray(dims::Integer...)
BitArray{N}(dims::NTuple{N,Int})
\end{lstlisting}

Construct an uninitialized \texttt{BitArray} with the given dimensions. Behaves identically to the \hyperlink{15492651498431872487}{\texttt{Array}} constructor.


\begin{minted}{jlcon}
julia> BitArray(2, 2)
2×2 BitArray{2}:
 false  false
 false  true

julia> BitArray((3, 1))
3×1 BitArray{2}:
 false
 true
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L31-L50}{\texttt{source}}



\begin{lstlisting}
BitArray(itr)
\end{lstlisting}

Construct a \texttt{BitArray} generated by the given iterable object. The shape is inferred from the \texttt{itr} object.


\begin{minted}{jlcon}
julia> BitArray([1 0; 0 1])
2×2 BitArray{2}:
  true  false
 false   true

julia> BitArray(x+y == 3 for x = 1:2, y = 1:3)
2×3 BitArray{2}:
 false   true  false
  true  false  false

julia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)
6-element BitArray{1}:
 false
  true
 false
  true
 false
 false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L548-L574}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12844393578243965152}{} 
\hyperlink{12844393578243965152}{\texttt{Base.trues}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trues(dims)
\end{lstlisting}

Create a \texttt{BitArray} with all values set to \texttt{true}.


\begin{minted}{jlcon}
julia> trues(2,3)
2×3 BitArray{2}:
 true  true  true
 true  true  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L393-L404}{\texttt{source}}



\begin{lstlisting}
trues(A)
\end{lstlisting}

Create a \texttt{BitArray} with all values set to \texttt{true} of the same shape as \texttt{A}.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> trues(A)
2×2 BitArray{2}:
 true  true
 true  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L407-L423}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12518029339635756199}{} 
\hyperlink{12518029339635756199}{\texttt{Base.falses}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
falses(dims)
\end{lstlisting}

Create a \texttt{BitArray} with all values set to \texttt{false}.


\begin{minted}{jlcon}
julia> falses(2,3)
2×3 BitArray{2}:
 false  false  false
 false  false  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L360-L371}{\texttt{source}}



\begin{lstlisting}
falses(A)
\end{lstlisting}

Create a \texttt{BitArray} with all values set to \texttt{false} of the same shape as \texttt{A}.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> falses(A)
2×2 BitArray{2}:
 false  false
 false  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L374-L390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2836152204730819918}{} 
\hyperlink{2836152204730819918}{\texttt{Base.fill}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fill(x, dims)
\end{lstlisting}

Create an array filled with the value \texttt{x}. For example, \texttt{fill(1.0, (5,5))} returns a 5×5 array of floats, with each element initialized to \texttt{1.0}.


\begin{minted}{jlcon}
julia> fill(1.0, (5,5))
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
\end{minted}

If \texttt{x} is an object reference, all elements will refer to the same object. \texttt{fill(Foo(), dims)} will return an array filled with the result of evaluating \texttt{Foo()} once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L234-L252}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5162290739791026948}{} 
\hyperlink{5162290739791026948}{\texttt{Base.fill!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fill!(A, x)
\end{lstlisting}

Fill array \texttt{A} with the value \texttt{x}. If \texttt{x} is an object reference, all elements will refer to the same object. \texttt{fill!(A, Foo())} will return \texttt{A} filled with the result of evaluating \texttt{Foo()} once.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = zeros(2,3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia> fill!(A, 2.)
2×3 Array{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0

julia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(3), a); a[1] = 2; A
3-element Array{Array{Int64,1},1}:
 [2, 1, 1]
 [2, 1, 1]
 [2, 1, 1]

julia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(3), f())
3-element Array{Int64,1}:
 1
 1
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L5-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18368531196314541873}{} 
\hyperlink{18368531196314541873}{\texttt{Base.similar}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
similar(array, [element_type=eltype(array)], [dims=size(array)])
\end{lstlisting}

Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array{\textquotesingle}s \texttt{eltype} and \texttt{size}. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.

Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an \texttt{Array\{element\_type\}(dims...)}.

For example, \texttt{similar(1:10, 1, 4)} returns an uninitialized \texttt{Array\{Int,2\}} since ranges are neither mutable nor support 2 dimensions:


\begin{minted}{jlcon}
julia> similar(1:10, 1, 4)
1×4 Array{Int64,2}:
 4419743872  4374413872  4419743888  0
\end{minted}

Conversely, \texttt{similar(trues(10,10), 2)} returns an uninitialized \texttt{BitVector} with two elements since \texttt{BitArray}s are both mutable and can support 1-dimensional arrays:


\begin{minted}{jlcon}
julia> similar(trues(10,10), 2)
2-element BitArray{1}:
 false
 false
\end{minted}

Since \texttt{BitArray}s can only store elements of type \hyperlink{46725311238864537}{\texttt{Bool}}, however, if you request a different element type it will create a regular \texttt{Array} instead:


\begin{minted}{jlcon}
julia> similar(falses(10), Float64, 2, 4)
2×4 Array{Float64,2}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L478-L519}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2536022253284800887}{} 
\hyperlink{2536022253284800887}{\texttt{Base.similar}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
similar(storagetype, indices)
\end{lstlisting}

Create an uninitialized mutable array analogous to that specified by \texttt{storagetype}, but with \texttt{indices} specified by the last argument. \texttt{storagetype} might be a type or a function.

\textbf{Examples}:


\begin{lstlisting}
similar(Array{Int}, indices(A))
\end{lstlisting}

creates an array that {\textquotedbl}acts like{\textquotedbl} an \texttt{Array\{Int\}} (and might indeed be backed by one), but which is indexed identically to \texttt{A}. If \texttt{A} has conventional indexing, this will be identical to \texttt{Array\{Int\}(size(A))}, but if \texttt{A} has unconventional indexing then the indices of the result will match \texttt{A}.


\begin{lstlisting}
similar(BitArray, (indices(A, 2),))
\end{lstlisting}

would create a 1-dimensional logical array whose indices match those of the columns of \texttt{A}.


\begin{lstlisting}
similar(dims->zeros(Int, dims), indices(A))
\end{lstlisting}

would create an array of \texttt{Int}, initialized to zero, matching the indices of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L538-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{245874853049830800}{} 
\hyperlink{245874853049830800}{\texttt{Base.eye}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eye([T::Type=Float64,] m::Integer, n::Integer)
\end{lstlisting}

\texttt{m}-by-\texttt{n} identity matrix. The default element type is \hyperlink{5027751419500983000}{\texttt{Float64}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eye(3, 4)
3×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  1.0  0.0

julia> eye(2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia> eye(Int, 2, 2)
2×2 Array{Int64,2}:
 1  0
 0  1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L270-L295}{\texttt{source}}



\begin{lstlisting}
eye(m, n)
\end{lstlisting}

\texttt{m}-by-\texttt{n} identity matrix.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L304-L308}{\texttt{source}}



\begin{lstlisting}
eye([T::Type=Float64,] n::Integer)
\end{lstlisting}

\texttt{n}-by-\texttt{n} identity matrix. The default element type is \hyperlink{5027751419500983000}{\texttt{Float64}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> eye(Int, 2)
2×2 Array{Int64,2}:
 1  0
 0  1

julia> eye(2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L311-L329}{\texttt{source}}



\begin{lstlisting}
eye(A)
\end{lstlisting}

Constructs an identity matrix of the same dimensions and type as \texttt{A}.


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> eye(A)
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  1
\end{minted}

Note the difference from \hyperlink{5858390260510292771}{\texttt{ones}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L332-L352}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11519832570242386196}{} 
\hyperlink{11519832570242386196}{\texttt{Base.linspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
linspace(start, stop, n=50)
\end{lstlisting}

Construct a range of \texttt{n} linearly spaced elements from \texttt{start} to \texttt{stop}.


\begin{minted}{jlcon}
julia> linspace(1.3,2.9,9)
1.3:0.2:2.9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L230-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9346157980973735489}{} 
\hyperlink{9346157980973735489}{\texttt{Base.logspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logspace(start::Real, stop::Real, n::Integer=50)
\end{lstlisting}

Construct a vector of \texttt{n} logarithmically spaced numbers from \texttt{10{\textasciicircum}start} to \texttt{10{\textasciicircum}stop}.


\begin{minted}{jlcon}
julia> logspace(1.,10.,5)
5-element Array{Float64,1}:
   10.0
 1778.28
    3.16228e5
    5.62341e7
    1.0e10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L316-L330}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14988757249747540457}{} 
\hyperlink{14988757249747540457}{\texttt{Base.Random.randsubseq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randsubseq(A, p) -> Vector
\end{lstlisting}

Return a vector consisting of a random subsequence of the given array \texttt{A}, where each element of \texttt{A} is included (in order) with independent probability \texttt{p}. (Complexity is linear in \texttt{p*length(A)}, so this function is efficient even if \texttt{p} is small and \texttt{A} is large.) Technically, this process is known as {\textquotedbl}Bernoulli sampling{\textquotedbl} of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1571-L1578}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17159975656568461918}{} 
\hyperlink{17159975656568461918}{\texttt{Base.Random.randsubseq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randsubseq!(S, A, p)
\end{lstlisting}

Like \hyperlink{14988757249747540457}{\texttt{randsubseq}}, but the results are stored in \texttt{S} (which is resized as needed).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L472-L477}{\texttt{source}}


\end{adjustwidth}

\hypertarget{12405966813196017790}{}


\section{Funciones básicas}


\hypertarget{1688406579181746010}{} 
\hyperlink{1688406579181746010}{\texttt{Base.ndims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ndims(A::AbstractArray) -> Integer
\end{lstlisting}

Returns the number of dimensions of \texttt{A}.


\begin{minted}{jlcon}
julia> A = ones(3,4,5);

julia> ndims(A)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L103-L114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17888996102305087038}{} 
\hyperlink{17888996102305087038}{\texttt{Base.size}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
size(A::AbstractArray, [dim...])
\end{lstlisting}

Returns a tuple containing the dimensions of \texttt{A}. Optionally you can specify the dimension(s) you want the length of, and get the length of that dimension, or a tuple of the lengths of dimensions you asked for.


\begin{minted}{jlcon}
julia> A = ones(2,3,4);

julia> size(A, 2)
3

julia> size(A,3,2)
(4, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L12-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16112307926804387301}{} 
\hyperlink{16112307926804387301}{\texttt{Base.indices}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indices(A)
\end{lstlisting}

Returns the tuple of valid indices for array \texttt{A}.


\begin{minted}{jlcon}
julia> A = ones(5,6,7);

julia> indices(A)
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L50-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7894131722758489183}{} 
\hyperlink{7894131722758489183}{\texttt{Base.indices}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indices(A, d)
\end{lstlisting}

Returns the valid range of indices for array \texttt{A} along dimension \texttt{d}.


\begin{minted}{jlcon}
julia> A = ones(5,6,7);

julia> indices(A,2)
Base.OneTo(6)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L33-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3699181304419743826}{} 
\hyperlink{3699181304419743826}{\texttt{Base.length}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
length(A::AbstractArray) -> Integer
\end{lstlisting}

Returns the number of elements in \texttt{A}.


\begin{minted}{jlcon}
julia> A = ones(3,4,5);

julia> length(A)
60
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L119-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4701773772897287974}{} 
\hyperlink{4701773772897287974}{\texttt{Base.eachindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eachindex(A...)
\end{lstlisting}

Creates an iterable object for visiting each index of an AbstractArray \texttt{A} in an efficient manner. For array types that have opted into fast linear indexing (like \texttt{Array}), this is simply the range \texttt{1:length(A)}. For other array types, this returns a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, this returns an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).

Example for a sparse 2-d array:


\begin{minted}{jlcon}
julia> A = sparse([1, 1, 2], [1, 3, 1], [1, 2, -5])
2×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 1]  =  -5
  [1, 3]  =  2

julia> for iter in eachindex(A)
           @show iter.I[1], iter.I[2]
           @show A[iter]
       end
(iter.I[1], iter.I[2]) = (1, 1)
A[iter] = 1
(iter.I[1], iter.I[2]) = (2, 1)
A[iter] = -5
(iter.I[1], iter.I[2]) = (1, 2)
A[iter] = 0
(iter.I[1], iter.I[2]) = (2, 2)
A[iter] = 0
(iter.I[1], iter.I[2]) = (1, 3)
A[iter] = 2
(iter.I[1], iter.I[2]) = (2, 3)
A[iter] = 0
\end{minted}

If you supply more than one \texttt{AbstractArray} argument, \texttt{eachindex} will create an iterable object that is fast for all arguments (a \texttt{UnitRange} if all inputs have fast linear indexing, a \hyperlink{7200434320514039079}{\texttt{CartesianRange}} otherwise). If the arrays have different sizes and/or dimensionalities, \texttt{eachindex} returns an iterable that spans the largest range along each dimension.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L766-L809}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13300247299461209585}{} 
\hyperlink{13300247299461209585}{\texttt{Base.linearindices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
linearindices(A)
\end{lstlisting}

Returns a \texttt{UnitRange} specifying the valid range of indices for \texttt{A[i]} where \texttt{i} is an \texttt{Int}. For arrays with conventional indexing (indices start at 1), or any multidimensional array, this is \texttt{1:length(A)}; however, for one-dimensional arrays with unconventional indices, this is \texttt{indices(A, 1)}.

Calling this function is the {\textquotedbl}safe{\textquotedbl} way to write algorithms that exploit linear indexing.


\begin{minted}{jlcon}
julia> A = ones(5,6,7);

julia> b = linearindices(A);

julia> extrema(b)
(1, 210)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L77-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7782790551324367092}{} 
\hyperlink{7782790551324367092}{\texttt{Base.IndexStyle}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IndexStyle(A)
IndexStyle(typeof(A))
\end{lstlisting}

\texttt{IndexStyle} specifies the {\textquotedbl}native indexing style{\textquotedbl} for array \texttt{A}. When you define a new \texttt{AbstractArray} type, you can choose to implement either linear indexing or cartesian indexing.  If you decide to implement linear indexing, then you must set this trait for your array type:


\begin{lstlisting}
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()
\end{lstlisting}

The default is \texttt{IndexCartesian()}.

Julia{\textquotesingle}s internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style using \hyperlink{3802607582438455846}{\texttt{sub2ind}} or \hyperlink{15673022236027819944}{\texttt{ind2sub}}. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.

If you define both styles of indexing for your \texttt{AbstractArray}, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, \hyperlink{4701773772897287974}{\texttt{eachindex}} creates an iterator whose type depends on the setting of this trait.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L260-L286}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14756260737478660234}{} 
\hyperlink{14756260737478660234}{\texttt{Base.countnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
countnz(A) -> Integer
\end{lstlisting}

Counts the number of nonzero values in array \texttt{A} (dense or sparse). Note that this is not a constant-time operation. For sparse matrices, one should usually use \hyperlink{6318543341724753931}{\texttt{nnz}}, which returns the number of stored values.


\begin{minted}{jlcon}
julia> A = [1 2 4; 0 0 1; 1 1 0]
3×3 Array{Int64,2}:
 1  2  4
 0  0  1
 1  1  0

julia> countnz(A)
6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L705-L721}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17819607861919666057}{} 
\hyperlink{17819607861919666057}{\texttt{Base.conj!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
conj!(A)
\end{lstlisting}

Transform an array to its complex conjugate in-place.

See also \hyperlink{9940023991150673697}{\texttt{conj}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1+im 2-im; 2+2im 3+im]
2×2 Array{Complex{Int64},2}:
 1+1im  2-1im
 2+2im  3+1im

julia> conj!(A);

julia> A
2×2 Array{Complex{Int64},2}:
 1-1im  2+1im
 2-2im  3-1im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L5-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{97811245619734938}{} 
\hyperlink{97811245619734938}{\texttt{Base.stride}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stride(A, k::Integer)
\end{lstlisting}

Returns the distance in memory (in number of elements) between adjacent elements in dimension \texttt{k}.


\begin{minted}{jlcon}
julia> A = ones(3,4,5);

julia> stride(A,2)
3

julia> stride(A,3)
12
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L174-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13576557637670855932}{} 
\hyperlink{13576557637670855932}{\texttt{Base.strides}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strides(A)
\end{lstlisting}

Returns a tuple of the memory strides in each dimension.


\begin{minted}{jlcon}
julia> A = ones(3,4,5);

julia> strides(A)
(1, 3, 12)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L200-L211}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15673022236027819944}{} 
\hyperlink{15673022236027819944}{\texttt{Base.ind2sub}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ind2sub(a, index) -> subscripts
\end{lstlisting}

Returns a tuple of subscripts into array \texttt{a} corresponding to the linear index \texttt{index}.


\begin{minted}{jlcon}
julia> A = ones(5,6,7);

julia> ind2sub(A,35)
(5, 1, 2)

julia> ind2sub(A,70)
(5, 2, 3)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1542-L1556}{\texttt{source}}



\begin{lstlisting}
ind2sub(dims, index) -> subscripts
\end{lstlisting}

Returns a tuple of subscripts into an array with dimensions \texttt{dims}, corresponding to the linear index \texttt{index}.

\textbf{Example}:


\begin{lstlisting}
i, j, ... = ind2sub(size(A), indmax(A))
\end{lstlisting}

provides the indices of the maximum element.


\begin{minted}{jlcon}
julia> ind2sub((3,4),2)
(2, 1)

julia> ind2sub((3,4),3)
(3, 1)

julia> ind2sub((3,4),4)
(1, 2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1609-L1633}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3802607582438455846}{} 
\hyperlink{3802607582438455846}{\texttt{Base.sub2ind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sub2ind(dims, i, j, k...) -> index
\end{lstlisting}

The inverse of \hyperlink{15673022236027819944}{\texttt{ind2sub}}, returns the linear index corresponding to the provided subscripts.


\begin{minted}{jlcon}
julia> sub2ind((5,6,7),1,2,3)
66

julia> sub2ind((5,6,7),1,6,3)
86
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1569-L1581}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3824705473881088503}{} 
\hyperlink{3824705473881088503}{\texttt{Base.LinAlg.checksquare}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LinAlg.checksquare(A)
\end{lstlisting}

Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = ones(4,4); B = zeros(5,5);

julia> LinAlg.checksquare(A, B)
2-element Array{Int64,1}:
 4
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/linalg.jl#L198-L214}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7850493673639296018}{}


\section{Retransmisión y Vectorización}



Ver también la \hyperlink{13590013989415065742}{sintaxis de puntos para vectorizar funciones}; por ejemplo, \texttt{f. (args ...)} llama implícitamente a \texttt{broadcast(f, args...)}. En lugar de confiar en los métodos {\textquotedbl}vectorizados{\textquotedbl} de funciones como \texttt{sin} para operar en arrays, debe usar \texttt{sin.(A)} para vectorizar a través de \texttt{broadcast}.


\hypertarget{1261021074485016178}{} 
\hyperlink{1261021074485016178}{\texttt{Base.broadcast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
broadcast(f, As...)
\end{lstlisting}

Broadcasts the arrays, tuples, \texttt{Ref}s, nullables, and/or scalars \texttt{As} to a container of the appropriate type and dimensions. In this context, anything that is not a subtype of \texttt{AbstractArray}, \texttt{Ref} (except for \texttt{Ptr}s), \texttt{Tuple}, or \texttt{Nullable} is considered a scalar. The resulting container is established by the following rules:

\begin{itemize}
\item If all the arguments are scalars, it returns a scalar.


\item If the arguments are tuples and zero or more scalars, it returns a tuple.


\item If the arguments contain at least one array or \texttt{Ref}, it returns an array (expanding singleton dimensions), and treats \texttt{Ref}s as 0-dimensional arrays, and tuples as 1-dimensional arrays.

\end{itemize}
The following additional rule applies to \texttt{Nullable} arguments: If there is at least one \texttt{Nullable}, and all the arguments are scalars or \texttt{Nullable}, it returns a \texttt{Nullable} treating \texttt{Nullable}s as {\textquotedbl}containers{\textquotedbl}.

A special syntax exists for broadcasting: \texttt{f.(args...)} is equivalent to \texttt{broadcast(f, args...)}, and nested \texttt{f.(g.(args...))} calls are fused into a single broadcast loop.


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia> broadcast(+, A, B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia> parse.(Int, ["1", "2"])
2-element Array{Int64,1}:
 1
 2

julia> abs.((1, -2))
(1, 2)

julia> broadcast(+, 1.0, (0, -2.0))
(1.0, -1.0)

julia> broadcast(+, 1.0, (0, -2.0), Ref(1))
2-element Array{Float64,1}:
 2.0
 0.0

julia> (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))
2-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]

julia> string.(("one","two","three","four"), ": ", 1:4)
4-element Array{String,1}:
 "one: 1"
 "two: 2"
 "three: 3"
 "four: 4"

julia> Nullable("X") .* "Y"
Nullable{String}("XY")

julia> broadcast(/, 1.0, Nullable(2.0))
Nullable{Float64}(0.5)

julia> (1 + im) ./ Nullable{Int}()
Nullable{Complex{Float64}}()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L369-L454}{\texttt{source}}


\end{adjustwidth}
\hypertarget{501355550527574084}{} 
\hyperlink{501355550527574084}{\texttt{Base.broadcast!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
broadcast!(f, dest, As...)
\end{lstlisting}

Like \hyperlink{1261021074485016178}{\texttt{broadcast}}, but store the result of \texttt{broadcast(f, As...)} in the \texttt{dest} array. Note that \texttt{dest} is only used to store the result, and does not supply arguments to \texttt{f} unless it is also listed in the \texttt{As}, as in \texttt{broadcast!(f, A, A, B)} to perform \texttt{A[:] = broadcast(f, A, B)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L197-L205}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16688502228717894452}{} 
\hyperlink{16688502228717894452}{\texttt{Base.Broadcast.@\_\_dot\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@. expr
\end{lstlisting}

Convert every function call or operator in \texttt{expr} into a {\textquotedbl}dot call{\textquotedbl} (e.g. convert \texttt{f(x)} to \texttt{f.(x)}), and convert every assignment in \texttt{expr} to a {\textquotedbl}dot assignment{\textquotedbl} (e.g. convert \texttt{+=} to \texttt{.+=}).

If you want to \emph{avoid} adding dots for selected function calls in \texttt{expr}, splice those function calls in with \texttt{\$}.  For example, \texttt{@. sqrt(abs(\$sort(x)))} is equivalent to \texttt{sqrt.(abs.(sort(x)))} (no dot for \texttt{sort}).

(\texttt{@.} is equivalent to a call to \texttt{@\_\_dot\_\_}.)


\begin{minted}{jlcon}
julia> x = 1.0:3.0; y = similar(x);

julia> @. y = x + 3 * sin(x)
3-element Array{Float64,1}:
 3.52441
 4.72789
 3.42336
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L603-L626}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5896180186078332739}{} 
\hyperlink{5896180186078332739}{\texttt{Base.Broadcast.broadcast\_getindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
broadcast_getindex(A, inds...)
\end{lstlisting}

Broadcasts the \texttt{inds} arrays to a common size like \hyperlink{1261021074485016178}{\texttt{broadcast}} and returns an array of the results \texttt{A[ks...]}, where \texttt{ks} goes over the positions in the broadcast result \texttt{A}.


\begin{minted}{jlcon}
julia> A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia> C = broadcast(+,A,B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia> broadcast_getindex(C,[1,2,10])
3-element Array{Int64,1}:
  2
  5
 15
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L457-L495}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12782056467660082625}{} 
\hyperlink{12782056467660082625}{\texttt{Base.Broadcast.broadcast\_setindex!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
broadcast_setindex!(A, X, inds...)
\end{lstlisting}

Broadcasts the \texttt{X} and \texttt{inds} arrays to a common size and stores the value from each position in \texttt{X} at the indices in \texttt{A} given by the same positions in \texttt{inds}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/broadcast.jl#L513-L518}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14438080058911688735}{}


\section{Indexación y Asignación}


\hypertarget{70337294579126602}{} 
\hyperlink{70337294579126602}{\texttt{Base.getindex}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getindex(A, inds...)
\end{lstlisting}

Returns a subset of array \texttt{A} as specified by \texttt{inds}, where each \texttt{ind} may be an \texttt{Int}, a \texttt{Range}, or a \texttt{Vector}. See the manual section on \hyperlink{14469287548874312017}{array indexing} for details.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> getindex(A, 1)
1

julia> getindex(A, [2, 1])
2-element Array{Int64,1}:
 3
 1

julia> getindex(A, 2:4)
3-element Array{Int64,1}:
 3
 2
 4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L119-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17903591429492118749}{} 
\hyperlink{17903591429492118749}{\texttt{Base.setindex!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setindex!(A, X, inds...)
\end{lstlisting}

Store values from array \texttt{X} within some subset of \texttt{A} as specified by \texttt{inds}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2288-L2292}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17942425127136986264}{} 
\hyperlink{17942425127136986264}{\texttt{Base.copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copy!(dest, Rdest::CartesianRange, src, Rsrc::CartesianRange) -> dest
\end{lstlisting}

Copy the block of \texttt{src} in the range of \texttt{Rsrc} to the block of \texttt{dest} in the range of \texttt{Rdest}. The sizes of the two regions must match.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L887-L892}{\texttt{source}}


\end{adjustwidth}
\hypertarget{976355747478401147}{} 
\hyperlink{976355747478401147}{\texttt{Base.isassigned}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isassigned(array, i) -> Bool
\end{lstlisting}

Tests whether the given array has a value associated with index \texttt{i}. Returns \texttt{false} if the index is out of bounds, or has an undefined reference.


\begin{minted}{jlcon}
julia> isassigned(rand(3, 3), 5)
true

julia> isassigned(rand(3, 3), 3 * 3 + 1)
false

julia> mutable struct Foo end

julia> v = similar(rand(3), Foo)
3-element Array{Foo,1}:
 #undef
 #undef
 #undef

julia> isassigned(v, 1)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L278-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13649361117037263099}{} 
\hyperlink{13649361117037263099}{\texttt{Base.Colon}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Colon()
\end{lstlisting}

Colons (:) are used to signify indexing entire objects or dimensions at once.

Very few operations are defined on Colons directly; instead they are converted by \hyperlink{10027537986402266830}{\texttt{to\_indices}} to an internal vector type (\texttt{Base.Slice}) to represent the collection of indices they span before being used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/essentials.jl#L311-L319}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4571802376991525093}{} 
\hyperlink{4571802376991525093}{\texttt{Base.IteratorsMD.CartesianIndex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CartesianIndex(i, j, k...)   -> I
CartesianIndex((i, j, k...)) -> I
\end{lstlisting}

Create a multidimensional index \texttt{I}, which can be used for indexing a multidimensional array \texttt{A}.  In particular, \texttt{A[I]} is equivalent to \texttt{A[i,j,k...]}.  One can freely mix integer and \texttt{CartesianIndex} indices; for example, \texttt{A[Ipre, i, Ipost]} (where \texttt{Ipre} and \texttt{Ipost} are \texttt{CartesianIndex} indices and \texttt{i} is an \texttt{Int}) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.

A \texttt{CartesianIndex} is sometimes produced by \hyperlink{4701773772897287974}{\texttt{eachindex}}, and always when iterating with an explicit \hyperlink{7200434320514039079}{\texttt{CartesianRange}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = reshape(collect(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> A[CartesianIndex((1, 1, 1, 1))]
1

julia> A[CartesianIndex((1, 1, 1, 2))]
9

julia> A[CartesianIndex((1, 1, 2, 1))]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L15-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7200434320514039079}{} 
\hyperlink{7200434320514039079}{\texttt{Base.IteratorsMD.CartesianRange}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CartesianRange(Istart::CartesianIndex, Istop::CartesianIndex) -> R
CartesianRange(sz::Dims) -> R
CartesianRange(istart:istop, jstart:jstop, ...) -> R
\end{lstlisting}

Define a region \texttt{R} spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where \texttt{for I in R ... end} will return \hyperlink{4571802376991525093}{\texttt{CartesianIndex}} indices \texttt{I} equivalent to the nested loops


\begin{lstlisting}
for j = jstart:jstop
    for i = istart:istop
        ...
    end
end
\end{lstlisting}

Consequently these can be useful for writing algorithms that work in arbitrary dimensions.


\begin{minted}{jlcon}
julia> foreach(println, CartesianRange((2, 2, 2)))
CartesianIndex{3}((1, 1, 1))
CartesianIndex{3}((2, 1, 1))
CartesianIndex{3}((1, 2, 1))
CartesianIndex{3}((2, 2, 1))
CartesianIndex{3}((1, 1, 2))
CartesianIndex{3}((2, 1, 2))
CartesianIndex{3}((1, 2, 2))
CartesianIndex{3}((2, 2, 2))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L137-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10027537986402266830}{} 
\hyperlink{10027537986402266830}{\texttt{Base.to\_indices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
to_indices(A, I::Tuple)
\end{lstlisting}

Convert the tuple \texttt{I} to a tuple of indices for use in indexing into array \texttt{A}.

The returned tuple must only contain either \texttt{Int}s or \texttt{AbstractArray}s of scalar indices that are supported by array \texttt{A}. It will error upon encountering a novel index type that it does not know how to process.

For simple index types, it defers to the unexported \texttt{Base.to\_index(A, i)} to process each index \texttt{i}. While this internal function is not intended to be called directly, \texttt{Base.to\_index} may be extended by custom array or index types to provide custom indexing behaviors.

More complicated index types may require more context about the dimension into which they index. To support those cases, \texttt{to\_indices(A, I)} calls \texttt{to\_indices(A, indices(A), I)}, which then recursively walks through both the given tuple of indices and the dimensional indices of \texttt{A} in tandem. As such, not all index types are guaranteed to propagate to \texttt{Base.to\_index}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/indices.jl#L193-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6593895036014271495}{} 
\hyperlink{6593895036014271495}{\texttt{Base.checkbounds}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
checkbounds(Bool, A, I...)
\end{lstlisting}

Return \texttt{true} if the specified indices \texttt{I} are in bounds for the given array \texttt{A}. Subtypes of \texttt{AbstractArray} should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on \texttt{A}{\textquotesingle}s indices and \hyperlink{4607154172896664089}{\texttt{checkindex}}.

See also \hyperlink{4607154172896664089}{\texttt{checkindex}}.


\begin{minted}{jlcon}
julia> A = rand(3, 3);

julia> checkbounds(Bool, A, 2)
true

julia> checkbounds(Bool, A, 3, 4)
false

julia> checkbounds(Bool, A, 1:3)
true

julia> checkbounds(Bool, A, 1:3, 2:4)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L314-L339}{\texttt{source}}



\begin{lstlisting}
checkbounds(A, I...)
\end{lstlisting}

Throw an error if the specified indices \texttt{I} are not in bounds for the given array \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L355-L359}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4607154172896664089}{} 
\hyperlink{4607154172896664089}{\texttt{Base.checkindex}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
checkindex(Bool, inds::AbstractUnitRange, index)
\end{lstlisting}

Return \texttt{true} if the given \texttt{index} is within the bounds of \texttt{inds}. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.


\begin{minted}{jlcon}
julia> checkindex(Bool,1:20,8)
true

julia> checkindex(Bool,1:20,21)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L437-L452}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4877859157667011167}{}


\section{Vistas (SubArrays y otros tipos de vistas)}


\hypertarget{4861450464669906845}{} 
\hyperlink{4861450464669906845}{\texttt{Base.view}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
view(A, inds...)
\end{lstlisting}

Like \hyperlink{2839226020402435013}{\texttt{getindex}}, but returns a view into the parent array \texttt{A} with the given indices instead of making a copy.  Calling \hyperlink{2839226020402435013}{\texttt{getindex}} or \hyperlink{17903591429492118749}{\texttt{setindex!}} on the returned \texttt{SubArray} computes the indices to the parent array on the fly without checking bounds.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = view(A, :, 1)
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 1
 3

julia> fill!(b, 0)
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 0
 0

julia> A # Note A has changed even though we modified b
2×2 Array{Int64,2}:
 0  2
 0  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/subarray.jl#L80-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4916348678965327831}{} 
\hyperlink{4916348678965327831}{\texttt{Base.@view}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@view A[inds...]
\end{lstlisting}

Creates a \texttt{SubArray} from an indexing expression. This can only be applied directly to a reference expression (e.g. \texttt{@view A[1,2:end]}), and should \emph{not} be used as the target of an assignment (e.g. \texttt{@view(A[1,2:end]) = ...}).  See also \hyperlink{4544474300423667148}{\texttt{@views}} to switch an entire block of code to use views for slicing.


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = @view A[:, 1]
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 1
 3

julia> fill!(b, 0)
2-element SubArray{Int64,1,Array{Int64,2},Tuple{Base.Slice{Base.OneTo{Int64}},Int64},true}:
 0
 0

julia> A
2×2 Array{Int64,2}:
 0  2
 0  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/subarray.jl#L418-L447}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4544474300423667148}{} 
\hyperlink{4544474300423667148}{\texttt{Base.@views}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@views expression
\end{lstlisting}

Convert every array-slicing operation in the given expression (which may be a \texttt{begin}/\texttt{end} block, loop, function, etc.) to return a view.   Scalar indices, non-array types, and explicit \texttt{getindex} calls (as opposed to \texttt{array[...]}) are unaffected.

Note that the \texttt{@views} macro only affects \texttt{array[...]} expressions that appear explicitly in the given \texttt{expression}, not array slicing that occurs in functions called by that code.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/subarray.jl#L527-L539}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11732113189086969263}{} 
\hyperlink{11732113189086969263}{\texttt{Base.parent}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parent(A)
\end{lstlisting}

Returns the {\textquotedbl}parent array{\textquotedbl} of an array view type (e.g., \texttt{SubArray}), or the array itself if it is not a view.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1798-L1803}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16489373313987716520}{} 
\hyperlink{16489373313987716520}{\texttt{Base.parentindexes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
parentindexes(A)
\end{lstlisting}

From an array view \texttt{A}, returns the corresponding indexes in the parent.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/subarray.jl#L64-L68}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13345480578513845480}{} 
\hyperlink{13345480578513845480}{\texttt{Base.slicedim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
slicedim(A, d::Integer, i)
\end{lstlisting}

Return all the data of \texttt{A} where the index for dimension \texttt{d} equals \texttt{i}. Equivalent to \texttt{A[:,:,...,i,:,:,...]} where \texttt{i} is in position \texttt{d}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 5 6 7 8]
2×4 Array{Int64,2}:
 1  2  3  4
 5  6  7  8

julia> slicedim(A,2,3)
2-element Array{Int64,1}:
 3
 7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L100-L118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{293815781001952115}{} 
\hyperlink{293815781001952115}{\texttt{Base.reinterpret}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reinterpret(type, A)
\end{lstlisting}

Change the type-interpretation of a block of memory. For arrays, this constructs an array with the same binary data as the given array, but with the specified element type. For example, \texttt{reinterpret(Float32, UInt32(7))} interprets the 4 bytes corresponding to \texttt{UInt32(7)} as a \hyperlink{8101639384272933082}{\texttt{Float32}}.

\begin{quote}
\textbf{Warning}

It is not allowed to \texttt{reinterpret} an array to an element type with a larger alignment then the alignment of the array. For a normal \texttt{Array}, this is the alignment of its element type. For a reinterpreted array, this is the alignment of the \texttt{Array} it was reinterpreted from. For example, \texttt{reinterpret(UInt32, UInt8[0, 0, 0, 0])} is not allowed but \texttt{reinterpret(UInt32, reinterpret(UInt8, Float32[1.0]))} is allowed.

\end{quote}
\textbf{Examples}


\begin{minted}{jlcon}
julia> reinterpret(Float32, UInt32(7))
1.0f-44

julia> reinterpret(Float32, UInt32[1 2 3 4 5])
1×5 Array{Float32,2}:
 1.4013f-45  2.8026f-45  4.2039f-45  5.60519f-45  7.00649f-45
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1245-L1272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3388738163419525310}{} 
\hyperlink{3388738163419525310}{\texttt{Base.reshape}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reshape(A, dims...) -> R
reshape(A, dims) -> R
\end{lstlisting}

Return an array \texttt{R} with the same data as \texttt{A}, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that setting elements of \texttt{R} alters the values of \texttt{A} and vice versa.

The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a \texttt{:}, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array \texttt{A}. The total number of elements must not change.


\begin{minted}{jlcon}
julia> A = collect(1:16)
16-element Array{Int64,1}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16

julia> reshape(A, (4, 4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> reshape(A, 2, :)
2×8 Array{Int64,2}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reshapedarray.jl#L39-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8564653172595523279}{} 
\hyperlink{8564653172595523279}{\texttt{Base.squeeze}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
squeeze(A, dims)
\end{lstlisting}

Remove the dimensions specified by \texttt{dims} from array \texttt{A}. Elements of \texttt{dims} must be unique and within the range \texttt{1:ndims(A)}. \texttt{size(A,i)} must equal 1 for all \texttt{i} in \texttt{dims}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = reshape(collect(1:4),(2,2,1,1))
2×2×1×1 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

julia> squeeze(a,3)
2×2×1 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L45-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18435874855636770528}{} 
\hyperlink{18435874855636770528}{\texttt{Base.vec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
vec(a::AbstractArray) -> Vector
\end{lstlisting}

Reshape the array \texttt{a} as a one-dimensional column vector. The resulting array shares the same underlying data as \texttt{a}, so modifying one will also modify the other.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> vec(a)
6-element Array{Int64,1}:
 1
 4
 2
 5
 3
 6
\end{minted}

See also \hyperlink{3388738163419525310}{\texttt{reshape}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L12-L37}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9281849319508946150}{}


\section{Concatenación y permutación}


\hypertarget{9868138443525443234}{} 
\hyperlink{9868138443525443234}{\texttt{Base.cat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cat(dims, A...)
\end{lstlisting}

Concatenate the input arrays along the specified dimensions in the iterable \texttt{dims}. For dimensions not in \texttt{dims}, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in \texttt{dims}, the size of the output array is the sum of the sizes of the input arrays along that dimension. If \texttt{dims} is a single number, the different arrays are tightly stacked along that dimension. If \texttt{dims} is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, \texttt{cat([1,2], matrices...)} builds a block diagonal matrix, i.e. a block matrix with \texttt{matrices[1]}, \texttt{matrices[2]}, ... as diagonal blocks and matching zero blocks away from the diagonal.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1836-L1850}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14691815416955507876}{} 
\hyperlink{14691815416955507876}{\texttt{Base.vcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
vcat(A...)
\end{lstlisting}

Concatenate along dimension 1.


\begin{minted}{jlcon}
julia> a = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia> b = [6 7 8 9 10; 11 12 13 14 15]
2×5 Array{Int64,2}:
  6   7   8   9  10
 11  12  13  14  15

julia> vcat(a,b)
3×5 Array{Int64,2}:
  1   2   3   4   5
  6   7   8   9  10
 11  12  13  14  15

julia> c = ([1 2 3], [4 5 6])
([1 2 3], [4 5 6])

julia> vcat(c...)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1230-L1259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862791894748483563}{} 
\hyperlink{8862791894748483563}{\texttt{Base.hcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hcat(A...)
\end{lstlisting}

Concatenate along dimension 2.


\begin{minted}{jlcon}
julia> a = [1; 2; 3; 4; 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> b = [6 7; 8 9; 10 11; 12 13; 14 15]
5×2 Array{Int64,2}:
  6   7
  8   9
 10  11
 12  13
 14  15

julia> hcat(a,b)
5×3 Array{Int64,2}:
 1   6   7
 2   8   9
 3  10  11
 4  12  13
 5  14  15

julia> c = ([1; 2; 3], [4; 5; 6])
([1, 2, 3], [4, 5, 6])

julia> hcat(c...)
3×2 Array{Int64,2}:
 1  4
 2  5
 3  6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1261-L1300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16279083053557795116}{} 
\hyperlink{16279083053557795116}{\texttt{Base.hvcat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hvcat(rows::Tuple{Vararg{Int}}, values...)
\end{lstlisting}

Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.


\begin{minted}{jlcon}
julia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia> [a b c; d e f]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> hvcat((3,3), a,b,c,d,e,f)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> [a b;c d; e f]
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6

julia> hvcat((2,2,2), a,b,c,d,e,f)
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6
\end{minted}

If the first argument is a single integer \texttt{n}, then all block rows are assumed to have \texttt{n} block columns.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1335-L1371}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12703826416373665531}{} 
\hyperlink{12703826416373665531}{\texttt{Base.flipdim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flipdim(A, d::Integer)
\end{lstlisting}

Reverse \texttt{A} in dimension \texttt{d}.

\textbf{Example}


\begin{minted}{jlcon}
julia> b = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> flipdim(b,2)
2×2 Array{Int64,2}:
 2  1
 4  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L126-L143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15182910221850902862}{} 
\hyperlink{15182910221850902862}{\texttt{Base.circshift}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
circshift(A, shifts)
\end{lstlisting}

Circularly shift the data in an array. The second argument is a vector giving the amount to shift in each dimension.

\textbf{Example}


\begin{minted}{jlcon}
julia> b = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> circshift(b, (0,2))
4×4 Array{Int64,2}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia> circshift(b, (-1,0))
4×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13
\end{minted}

See also \hyperlink{5319002815154535997}{\texttt{circshift!}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L178-L209}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5319002815154535997}{} 
\hyperlink{5319002815154535997}{\texttt{Base.circshift!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
circshift!(dest, src, shifts)
\end{lstlisting}

Circularly shift the data in \texttt{src}, storing the result in \texttt{dest}. \texttt{shifts} specifies the amount to shift in each dimension.

The \texttt{dest} array must be distinct from the \texttt{src} array (they cannot alias each other).

See also \hyperlink{15182910221850902862}{\texttt{circshift}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L897-L907}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13256910868822648458}{} 
\hyperlink{13256910868822648458}{\texttt{Base.circcopy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
circcopy!(dest, src)
\end{lstlisting}

Copy \texttt{src} to \texttt{dest}, indexing each dimension modulo its length. \texttt{src} and \texttt{dest} must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap \texttt{dest} agrees with \texttt{src}.

\textbf{Example}


\begin{minted}{jlcon}
julia> src = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> dest = OffsetArray{Int}((0:3,2:5))

julia> circcopy!(dest, src)
OffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:
 8  12  16  4
 5   9  13  1
 6  10  14  2
 7  11  15  3

julia> dest[1:3,2:4] == src[1:3,2:4]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L950-L980}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16229508745643032859}{} 
\hyperlink{16229508745643032859}{\texttt{Base.contains}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
contains(fun, itr, x) -> Bool
\end{lstlisting}

Returns \texttt{true} if there is at least one element \texttt{y} in \texttt{itr} such that \texttt{fun(y,x)} is \texttt{true}.


\begin{minted}{jlcon}
julia> vec = [10, 100, 200]
3-element Array{Int64,1}:
  10
 100
 200

julia> contains(==, vec, 200)
true

julia> contains(==, vec, 300)
false

julia> contains(>, vec, 100)
true

julia> contains(>, vec, 200)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L638-L662}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13973031941728195278}{} 
\hyperlink{13973031941728195278}{\texttt{Base.find}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
find(A)
\end{lstlisting}

Return a vector of the linear indexes of the non-zeros in \texttt{A} (determined by \texttt{A[i]!=0}). A common use of this is to convert a boolean array to an array of indexes of the \texttt{true} elements. If there are no non-zero elements of \texttt{A}, \texttt{find} returns an empty array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [true false; false true]
2×2 Array{Bool,2}:
  true  false
 false   true

julia> find(A)
2-element Array{Int64,1}:
 1
 4

julia> find(zeros(3))
0-element Array{Int64,1}
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1532-L1554}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16634642403736312993}{} 
\hyperlink{16634642403736312993}{\texttt{Base.find}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
find(f::Function, A)
\end{lstlisting}

Return a vector \texttt{I} of the linear indexes of \texttt{A} where \texttt{f(A[I])} returns \texttt{true}. If there are no such elements of \texttt{A}, find returns an empty array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> find(isodd,A)
2-element Array{Int64,1}:
 1
 2

julia> find(isodd, [2, 4])
0-element Array{Int64,1}
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1493-L1514}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7762671957301951450}{} 
\hyperlink{7762671957301951450}{\texttt{Base.findn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findn(A)
\end{lstlisting}

Return a vector of indexes for each dimension giving the locations of the non-zeros in \texttt{A} (determined by \texttt{A[i]!=0}). If there are no non-zero elements of \texttt{A}, \texttt{findn} returns a 2-tuple of empty arrays.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2 0; 0 0 3; 0 4 0]
3×3 Array{Int64,2}:
 1  2  0
 0  0  3
 0  4  0

julia> findn(A)
([1, 1, 3, 2], [1, 2, 2, 3])

julia> A = zeros(2,2)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia> findn(A)
(Int64[], Int64[])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1574-L1600}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10811968090686169507}{} 
\hyperlink{10811968090686169507}{\texttt{Base.findnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findnz(A)
\end{lstlisting}

Return a tuple \texttt{(I, J, V)} where \texttt{I} and \texttt{J} are the row and column indexes of the non-zero values in matrix \texttt{A}, and \texttt{V} is a vector of the non-zero values.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 0; 0 0 3; 0 4 0]
3×3 Array{Int64,2}:
 1  2  0
 0  0  3
 0  4  0

julia> findnz(A)
([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1616-L1633}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13752961745140943082}{} 
\hyperlink{13752961745140943082}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findfirst(A)
\end{lstlisting}

Return the linear index of the first non-zero value in \texttt{A} (determined by \texttt{A[i]!=0}). Returns \texttt{0} if no such value is found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 0; 1 0]
2×2 Array{Int64,2}:
 0  0
 1  0

julia> findfirst(A)
2

julia> findfirst(zeros(3))
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1219-L1238}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15882391722029874929}{} 
\hyperlink{15882391722029874929}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findfirst(A, v)
\end{lstlisting}

Return the linear index of the first element equal to \texttt{v} in \texttt{A}. Returns \texttt{0} if \texttt{v} is not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 6; 2 2]
2×2 Array{Int64,2}:
 4  6
 2  2

julia> findfirst(A,2)
2

julia> findfirst(A,3)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1268-L1287}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10686327966799324598}{} 
\hyperlink{10686327966799324598}{\texttt{Base.findfirst}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findfirst(predicate::Function, A)
\end{lstlisting}

Return the linear index of the first element of \texttt{A} for which \texttt{predicate} returns \texttt{true}. Returns \texttt{0} if there is no such element.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia> findfirst(iseven, A)
2

julia> findfirst(x -> x>10, A)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1318-L1337}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16601358451866933976}{} 
\hyperlink{16601358451866933976}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findlast(A)
\end{lstlisting}

Return the linear index of the last non-zero value in \texttt{A} (determined by \texttt{A[i]!=0}). Returns \texttt{0} if there is no non-zero value in \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 0; 1 0]
2×2 Array{Int64,2}:
 1  0
 1  0

julia> findlast(A)
2

julia> A = zeros(2,2)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia> findlast(A)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1366-L1390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9642735754110648594}{} 
\hyperlink{9642735754110648594}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findlast(A, v)
\end{lstlisting}

Return the linear index of the last element equal to \texttt{v} in \texttt{A}. Returns \texttt{0} if there is no element of \texttt{A} equal to \texttt{v}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 2 1]
2×2 Array{Int64,2}:
 1  2
 2  1

julia> findlast(A,1)
4

julia> findlast(A,2)
3

julia> findlast(A,3)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1419-L1441}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13690191743392331122}{} 
\hyperlink{13690191743392331122}{\texttt{Base.findlast}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findlast(predicate::Function, A)
\end{lstlisting}

Return the linear index of the last element of \texttt{A} for which \texttt{predicate} returns \texttt{true}. Returns \texttt{0} if there is no such element.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> findlast(isodd, A)
2

julia> findlast(x -> x > 5, A)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1471-L1490}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9906000186778518011}{} 
\hyperlink{9906000186778518011}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findnext(A, i::Integer)
\end{lstlisting}

Find the next linear index >= \texttt{i} of a non-zero element of \texttt{A}, or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 0; 1 0]
2×2 Array{Int64,2}:
 0  0
 1  0

julia> findnext(A,1)
2

julia> findnext(A,3)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1191-L1209}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2433853860677249610}{} 
\hyperlink{2433853860677249610}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findnext(predicate::Function, A, i::Integer)
\end{lstlisting}

Find the next linear index >= \texttt{i} of an element of \texttt{A} for which \texttt{predicate} returns \texttt{true}, or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia> findnext(isodd, A, 1)
1

julia> findnext(isodd, A, 2)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1290-L1308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8856370662650438441}{} 
\hyperlink{8856370662650438441}{\texttt{Base.findnext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findnext(A, v, i::Integer)
\end{lstlisting}

Find the next linear index >= \texttt{i} of an element of \texttt{A} equal to \texttt{v} (using \texttt{==}), or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia> findnext(A,4,4)
0

julia> findnext(A,4,3)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1241-L1259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3864667477361062614}{} 
\hyperlink{3864667477361062614}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findprev(A, i::Integer)
\end{lstlisting}

Find the previous linear index <= \texttt{i} of a non-zero element of \texttt{A}, or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 0; 1 2]
2×2 Array{Int64,2}:
 0  0
 1  2

julia> findprev(A,2)
2

julia> findprev(A,1)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1340-L1358}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17827047449430918639}{} 
\hyperlink{17827047449430918639}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findprev(predicate::Function, A, i::Integer)
\end{lstlisting}

Find the previous linear index <= \texttt{i} of an element of \texttt{A} for which \texttt{predicate} returns \texttt{true}, or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 6; 1 2]
2×2 Array{Int64,2}:
 4  6
 1  2

julia> findprev(isodd, A, 1)
0

julia> findprev(isodd, A, 3)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1444-L1463}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1979671556370368619}{} 
\hyperlink{1979671556370368619}{\texttt{Base.findprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
findprev(A, v, i::Integer)
\end{lstlisting}

Find the previous linear index <= \texttt{i} of an element of \texttt{A} equal to \texttt{v} (using \texttt{==}), or \texttt{0} if not found.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [0 0; 1 2]
2×2 Array{Int64,2}:
 0  0
 1  2

julia> findprev(A, 1, 4)
2

julia> findprev(A, 1, 1)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1393-L1411}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10913801624539723467}{} 
\hyperlink{10913801624539723467}{\texttt{Base.permutedims}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permutedims(A, perm)
\end{lstlisting}

Permute the dimensions of array \texttt{A}. \texttt{perm} is a vector specifying a permutation of length \texttt{ndims(A)}. This is a generalization of transpose for multi-dimensional arrays. Transpose is equivalent to \texttt{permutedims(A, [2,1])}.

See also: \hyperlink{16936235724694909186}{\texttt{PermutedDimsArray}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = reshape(collect(1:8), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia> permutedims(A, [3, 2, 1])
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 5  7

[:, :, 2] =
 2  4
 6  8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/permuteddimsarray.jl#L83-L114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15299422200414360384}{} 
\hyperlink{15299422200414360384}{\texttt{Base.permutedims!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permutedims!(dest, src, perm)
\end{lstlisting}

Permute the dimensions of array \texttt{src} and store the result in the array \texttt{dest}. \texttt{perm} is a vector specifying a permutation of length \texttt{ndims(src)}. The preallocated array \texttt{dest} should have \texttt{size(dest) == size(src)[perm]} and is completely overwritten. No in-place permutation is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.

See also \hyperlink{10913801624539723467}{\texttt{permutedims}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/permuteddimsarray.jl#L120-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16936235724694909186}{} 
\hyperlink{16936235724694909186}{\texttt{Base.PermutedDimsArrays.PermutedDimsArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
PermutedDimsArray(A, perm) -> B
\end{lstlisting}

Given an AbstractArray \texttt{A}, create a view \texttt{B} such that the dimensions appear to be permuted. Similar to \texttt{permutedims}, except that no copying occurs (\texttt{B} shares storage with \texttt{A}).

See also: \hyperlink{10913801624539723467}{\texttt{permutedims}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = rand(3,5,4);

julia> B = PermutedDimsArray(A, (3,1,2));

julia> size(B)
(4, 3, 5)

julia> B[3,1,2] == A[1,2,3]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/permuteddimsarray.jl#L19-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16545078180547259725}{} 
\hyperlink{16545078180547259725}{\texttt{Base.promote\_shape}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
promote_shape(s1, s2)
\end{lstlisting}

Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.


\begin{minted}{jlcon}
julia> a = ones(3,4,1,1,1);

julia> b = ones(3,4);

julia> promote_shape(a,b)
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))
(2, 3, 1, 4, 1)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/indices.jl#L34-L51}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10164869372455466746}{}


\section{Funciones de Arrays}


\hypertarget{4708508974842578384}{} 
\hyperlink{4708508974842578384}{\texttt{Base.accumulate}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
accumulate(op, A, dim=1)
\end{lstlisting}

Cumulative operation \texttt{op} along a dimension \texttt{dim} (defaults to 1). See also \hyperlink{5431648933624159647}{\texttt{accumulate!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of \texttt{accumulate}, see: \hyperlink{6230751605647278302}{\texttt{cumsum}}, \hyperlink{9956198945051267091}{\texttt{cumprod}}


\begin{minted}{jlcon}
julia> accumulate(+, [1,2,3])
3-element Array{Int64,1}:
 1
 3
 6

julia> accumulate(*, [1,2,3])
3-element Array{Int64,1}:
 1
 2
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L710-L732}{\texttt{source}}



\begin{lstlisting}
accumulate(op, v0, A)
\end{lstlisting}

Like \texttt{accumulate}, but using a starting element \texttt{v0}. The first entry of the result will be \texttt{op(v0, first(A))}. For example:


\begin{minted}{jlcon}
julia> accumulate(+, 100, [1,2,3])
3-element Array{Int64,1}:
 101
 103
 106

julia> accumulate(min, 0, [1,2,-1])
3-element Array{Int64,1}:
  0
  0
 -1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L739-L758}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5431648933624159647}{} 
\hyperlink{5431648933624159647}{\texttt{Base.accumulate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
accumulate!(op, B, A, dim=1)
\end{lstlisting}

Cumulative operation \texttt{op} on \texttt{A} along a dimension, storing the result in \texttt{B}. The dimension defaults to 1. See also \hyperlink{4708508974842578384}{\texttt{accumulate}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L793-L798}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9956198945051267091}{} 
\hyperlink{9956198945051267091}{\texttt{Base.cumprod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumprod(A, dim=1)
\end{lstlisting}

Cumulative product along a dimension \texttt{dim} (defaults to 1). See also \hyperlink{17593173853905042752}{\texttt{cumprod!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> cumprod(a,1)
2×3 Array{Int64,2}:
 1   2   3
 4  10  18

julia> cumprod(a,2)
2×3 Array{Int64,2}:
 1   2    6
 4  20  120
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L676-L699}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17593173853905042752}{} 
\hyperlink{17593173853905042752}{\texttt{Base.cumprod!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumprod!(B, A, dim::Integer=1)
\end{lstlisting}

Cumulative product of \texttt{A} along a dimension, storing the result in \texttt{B}. The dimension defaults to 1. See also \hyperlink{9956198945051267091}{\texttt{cumprod}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L702-L707}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6230751605647278302}{} 
\hyperlink{6230751605647278302}{\texttt{Base.cumsum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumsum(A, dim=1)
\end{lstlisting}

Cumulative sum along a dimension \texttt{dim} (defaults to 1). See also \hyperlink{6880214806638058949}{\texttt{cumsum!}} to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).


\begin{minted}{jlcon}
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia> cumsum(a,1)
2×3 Array{Int64,2}:
 1  2  3
 5  7  9

julia> cumsum(a,2)
2×3 Array{Int64,2}:
 1  3   6
 4  9  15
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L639-L662}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6880214806638058949}{} 
\hyperlink{6880214806638058949}{\texttt{Base.cumsum!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumsum!(B, A, dim::Integer=1)
\end{lstlisting}

Cumulative sum of \texttt{A} along a dimension, storing the result in \texttt{B}. The dimension defaults to 1. See also \hyperlink{6230751605647278302}{\texttt{cumsum}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L668-L673}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3417346725052909886}{} 
\hyperlink{3417346725052909886}{\texttt{Base.cumsum\_kbn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cumsum_kbn(A, [dim::Integer=1])
\end{lstlisting}

Cumulative sum along a dimension, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy. The dimension defaults to 1.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L240-L245}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4556138751333447681}{} 
\hyperlink{4556138751333447681}{\texttt{Base.LinAlg.diff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diff(A, [dim::Integer=1])
\end{lstlisting}

Finite difference operator of matrix or vector \texttt{A}. If \texttt{A} is a matrix, compute the finite difference over a dimension \texttt{dim} (default \texttt{1}).

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [2 4; 6 16]
2×2 Array{Int64,2}:
 2   4
 6  16

julia> diff(a,2)
2×1 Array{Int64,2}:
  2
 10
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L251-L270}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2624058047704463332}{} 
\hyperlink{2624058047704463332}{\texttt{Base.LinAlg.gradient}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gradient(F::AbstractVector, [h::Real])
\end{lstlisting}

Compute differences along vector \texttt{F}, using \texttt{h} as the spacing between points. The default spacing is one.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [2,4,6,8];

julia> gradient(a)
4-element Array{Float64,1}:
 2.0
 2.0
 2.0
 2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L284-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12015243558136741941}{} 
\hyperlink{12015243558136741941}{\texttt{Base.rot180}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rot180(A)
\end{lstlisting}

Rotate matrix \texttt{A} 180 degrees.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rot180(a)
2×2 Array{Int64,2}:
 4  3
 2  1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L170-L187}{\texttt{source}}



\begin{lstlisting}
rot180(A, k)
\end{lstlisting}

Rotate matrix \texttt{A} 180 degrees an integer \texttt{k} number of times. If \texttt{k} is even, this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rot180(a,1)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rot180(a,2)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L272-L295}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3749585719821242612}{} 
\hyperlink{3749585719821242612}{\texttt{Base.rotl90}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rotl90(A)
\end{lstlisting}

Rotate matrix \texttt{A} left 90 degrees.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotl90(a)
2×2 Array{Int64,2}:
 2  4
 1  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L115-L132}{\texttt{source}}



\begin{lstlisting}
rotl90(A, k)
\end{lstlisting}

Rotate matrix \texttt{A} left 90 degrees an integer \texttt{k} number of times. If \texttt{k} is zero or a multiple of four, this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotl90(a,1)
2×2 Array{Int64,2}:
 2  4
 1  3

julia> rotl90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rotl90(a,3)
2×2 Array{Int64,2}:
 3  1
 4  2

julia> rotl90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L197-L230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4661209193738958579}{} 
\hyperlink{4661209193738958579}{\texttt{Base.rotr90}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rotr90(A)
\end{lstlisting}

Rotate matrix \texttt{A} right 90 degrees.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotr90(a)
2×2 Array{Int64,2}:
 3  1
 4  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L143-L160}{\texttt{source}}



\begin{lstlisting}
rotr90(A, k)
\end{lstlisting}

Rotate matrix \texttt{A} right 90 degrees an integer \texttt{k} number of times. If \texttt{k} is zero or a multiple of four, this is equivalent to a \texttt{copy}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> rotr90(a,1)
2×2 Array{Int64,2}:
 3  1
 4  2

julia> rotr90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia> rotr90(a,3)
2×2 Array{Int64,2}:
 2  4
 1  3

julia> rotr90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/arraymath.jl#L237-L270}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14026802499766415657}{} 
\hyperlink{14026802499766415657}{\texttt{Base.reducedim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reducedim(f, A, region[, v0])
\end{lstlisting}

Reduce 2-argument function \texttt{f} along dimensions of \texttt{A}. \texttt{region} is a vector specifying the dimensions to reduce, and \texttt{v0} is the initial value to use in the reductions. For \texttt{+}, \texttt{*}, \texttt{max} and \texttt{min} the \texttt{v0} argument is optional.

The associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop. See documentation for \hyperlink{2662613255229698805}{\texttt{reduce}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> reducedim(max, a, 2)
4×1 Array{Int64,2}:
 13
 14
 15
 16

julia> reducedim(max, a, 1)
1×4 Array{Int64,2}:
 4  8  12  16
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L245-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12702549823921106682}{} 
\hyperlink{12702549823921106682}{\texttt{Base.mapreducedim}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapreducedim(f, op, A, region[, v0])
\end{lstlisting}

Evaluates to the same as \texttt{reducedim(op, map(f, A), region, f(v0))}, but is generally faster because the intermediate array is avoided.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(collect(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia> mapreducedim(isodd, *, a, 1)
1×4 Array{Bool,2}:
 false  false  false  false

julia> mapreducedim(isodd, |, a, 1, true)
1×4 Array{Bool,2}:
 true  true  true  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L216-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8678396932318499078}{} 
\hyperlink{8678396932318499078}{\texttt{Base.mapslices}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mapslices(f, A, dims)
\end{lstlisting}

Transform the given dimensions of array \texttt{A} using function \texttt{f}. \texttt{f} is called on each slice of \texttt{A} of the form \texttt{A[...,:,...,:,...]}. \texttt{dims} is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if \texttt{dims} is \texttt{[1,2]} and \texttt{A} is 4-dimensional, \texttt{f} is called on \texttt{A[:,:,i,j]} for all \texttt{i} and \texttt{j}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = reshape(collect(1:16),(2,2,2,2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia> mapslices(sum, a, [1,2])
1×1×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 10

[:, :, 2, 1] =
 26

[:, :, 1, 2] =
 42

[:, :, 2, 2] =
 58
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1741-L1784}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16119876305082002277}{} 
\hyperlink{16119876305082002277}{\texttt{Base.sum\_kbn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sum_kbn(A)
\end{lstlisting}

Returns the sum of all elements of \texttt{A}, using the Kahan-Babuska-Neumaier compensated summation algorithm for additional accuracy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L366-L371}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5964028120097016418}{}


\section{Combinatoria}


\hypertarget{7064355899480154040}{} 
\hyperlink{7064355899480154040}{\texttt{Base.Random.randperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randperm([rng=GLOBAL_RNG,] n::Integer)
\end{lstlisting}

Construct a random permutation of length \texttt{n}. The optional \texttt{rng} argument specifies a random number generator (see \hyperlink{4868036498049031913}{Random Numbers}). To randomly permute a arbitrary vector, see \hyperlink{7824264039428535103}{\texttt{shuffle}} or \hyperlink{17024043041131293003}{\texttt{shuffle!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randperm(rng, 4)
4-element Array{Int64,1}:
 2
 1
 4
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1666-L1686}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1395642908979377386}{} 
\hyperlink{1395642908979377386}{\texttt{Base.invperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
invperm(v)
\end{lstlisting}

Return the inverse permutation of \texttt{v}. If \texttt{B = A[v]}, then \texttt{A == B[invperm(v)]}.

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [2; 4; 3; 1];

julia> invperm(v)
4-element Array{Int64,1}:
 4
 1
 3
 2

julia> A = ['a','b','c','d'];

julia> B = A[v]
4-element Array{Char,1}:
 'b'
 'd'
 'c'
 'a'

julia> B[invperm(v)]
4-element Array{Char,1}:
 'a'
 'b'
 'c'
 'd'
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L182-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11897566016863942320}{} 
\hyperlink{11897566016863942320}{\texttt{Base.isperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isperm(v) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{v} is a valid permutation.

\textbf{Examples}


\begin{minted}{jlcon}
julia> isperm([1; 2])
true

julia> isperm([1; 3])
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L59-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17157632988142440888}{} 
\hyperlink{17157632988142440888}{\texttt{Base.permute!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permute!(v, p)
\end{lstlisting}

Permute vector \texttt{v} in-place, according to permutation \texttt{p}. No checking is done to verify that \texttt{p} is a permutation.

To return a new permutation, use \texttt{v[p]}. Note that this is generally faster than \texttt{permute!(v,p)} for large vectors.

See also \hyperlink{9965226686125089381}{\texttt{ipermute!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1, 1, 3, 4];

julia> perm = [2, 4, 3, 1];

julia> permute!(A, perm);

julia> A
4-element Array{Int64,1}:
 1
 4
 3
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L107-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9965226686125089381}{} 
\hyperlink{9965226686125089381}{\texttt{Base.ipermute!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ipermute!(v, p)
\end{lstlisting}

Like \hyperlink{17157632988142440888}{\texttt{permute!}}, but the inverse of the given permutation is applied.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1, 1, 3, 4];

julia> perm = [2, 4, 3, 1];

julia> ipermute!(A, perm);

julia> A
4-element Array{Int64,1}:
 4
 1
 3
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L159-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10211237227429953257}{} 
\hyperlink{10211237227429953257}{\texttt{Base.Random.randcycle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
randcycle([rng=GLOBAL_RNG,] n::Integer)
\end{lstlisting}

Construct a random cyclic permutation of length \texttt{n}. The optional \texttt{rng} argument specifies a random number generator, see \hyperlink{4868036498049031913}{Random Numbers}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> randcycle(rng, 6)
6-element Array{Int64,1}:
 3
 5
 4
 6
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1707-L1727}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7824264039428535103}{} 
\hyperlink{7824264039428535103}{\texttt{Base.Random.shuffle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
shuffle([rng=GLOBAL_RNG,] v)
\end{lstlisting}

Return a randomly permuted copy of \texttt{v}. The optional \texttt{rng} argument specifies a random number generator (see \hyperlink{4868036498049031913}{Random Numbers}). To permute \texttt{v} in-place, see \hyperlink{17024043041131293003}{\texttt{shuffle!}}.  To obtain randomly permuted indices, see \hyperlink{7064355899480154040}{\texttt{randperm}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> shuffle(rng, collect(1:10))
10-element Array{Int64,1}:
  6
  1
 10
  2
  3
  9
  5
  7
  4
  8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1636-L1662}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17024043041131293003}{} 
\hyperlink{17024043041131293003}{\texttt{Base.Random.shuffle!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
shuffle!([rng=GLOBAL_RNG,] v)
\end{lstlisting}

In-place version of \hyperlink{7824264039428535103}{\texttt{shuffle}}: randomly permute the array \texttt{v} in-place, optionally supplying the random-number generator \texttt{rng}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> shuffle!(rng, collect(1:16))
16-element Array{Int64,1}:
  2
 15
  5
 14
  1
  9
 10
  6
 11
  3
 16
  7
  4
 12
  8
 13
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1591-L1621}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9938769063722328136}{} 
\hyperlink{9938769063722328136}{\texttt{Base.reverse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reverse(v [, start=1 [, stop=length(v) ]] )
\end{lstlisting}

Return a copy of \texttt{v} reversed from start to stop.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = collect(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia> reverse(A)
5-element Array{Int64,1}:
 5
 4
 3
 2
 1

julia> reverse(A, 1, 4)
5-element Array{Int64,1}:
 4
 3
 2
 1
 5

julia> reverse(A, 3, 5)
5-element Array{Int64,1}:
 1
 2
 5
 4
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L700-L739}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16812685153025781176}{} 
\hyperlink{16812685153025781176}{\texttt{Base.reverseind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reverseind(v, i)
\end{lstlisting}

Given an index \texttt{i} in \texttt{reverse(v)}, return the corresponding index in \texttt{v} so that \texttt{v[reverseind(v,i)] == reverse(v)[i]}. (This can be nontrivial in the case where \texttt{v} is a Unicode string.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2440-L2446}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9702108366803637048}{} 
\hyperlink{9702108366803637048}{\texttt{Base.reverse!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reverse!(v [, start=1 [, stop=length(v) ]]) -> v
\end{lstlisting}

In-place version of \hyperlink{9938769063722328136}{\texttt{reverse}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L742-L746}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11812832820787663359}{}


\section{BitArrays}



\texttt{BitArray}s son matrices booleanas {\textquotedbl}compactas{\textquotedbl} eficientes en el uso del espacio, que almacenan un bit por valor booleano. Se pueden usar de forma similar a los arrays \texttt{Array\{Bool\}} (que almacenan un byte por valor booleano), y se pueden convertir a/desde este último a través de \texttt{Array(bitarray)} y \texttt{BitArray(array)}, respectivamente.


\hypertarget{2954314498186399761}{} 
\hyperlink{2954314498186399761}{\texttt{Base.flipbits!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flipbits!(B::BitArray{N}) -> BitArray{N}
\end{lstlisting}

Performs a bitwise not operation on \texttt{B}. See \hyperlink{2433030275488323500}{\texttt{{\textasciitilde}}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = trues(2,2)
2×2 BitArray{2}:
 true  true
 true  true

julia> flipbits!(A)
2×2 BitArray{2}:
 false  false
 false  false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1143-L1160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8834180677602757313}{} 
\hyperlink{8834180677602757313}{\texttt{Base.rol!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rol!(dest::BitVector, src::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a left rotation operation on \texttt{src} and puts the result into \texttt{dest}. \texttt{i} controls how far to rotate the bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1468-L1473}{\texttt{source}}



\begin{lstlisting}
rol!(B::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a left rotation operation in-place on \texttt{B}. \texttt{i} controls how far to rotate the bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1486-L1491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5525630662564449940}{} 
\hyperlink{5525630662564449940}{\texttt{Base.rol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rol(B::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a left rotation operation, returning a new \texttt{BitVector}. \texttt{i} controls how far to rotate the bits. See also \hyperlink{8834180677602757313}{\texttt{rol!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = BitArray([true, true, false, false, true])
5-element BitArray{1}:
  true
  true
 false
 false
  true

julia> rol(A,1)
5-element BitArray{1}:
  true
 false
 false
  true
  true

julia> rol(A,2)
5-element BitArray{1}:
 false
 false
  true
  true
  true

julia> rol(A,5)
5-element BitArray{1}:
  true
  true
 false
 false
  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1494-L1535}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9497865068299389753}{} 
\hyperlink{9497865068299389753}{\texttt{Base.ror!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ror!(dest::BitVector, src::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a right rotation operation on \texttt{src} and puts the result into \texttt{dest}. \texttt{i} controls how far to rotate the bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1538-L1543}{\texttt{source}}



\begin{lstlisting}
ror!(B::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a right rotation operation in-place on \texttt{B}. \texttt{i} controls how far to rotate the bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1556-L1561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14416357953528155070}{} 
\hyperlink{14416357953528155070}{\texttt{Base.ror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ror(B::BitVector, i::Integer) -> BitVector
\end{lstlisting}

Performs a right rotation operation on \texttt{B}, returning a new \texttt{BitVector}. \texttt{i} controls how far to rotate the bits. See also \hyperlink{9497865068299389753}{\texttt{ror!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = BitArray([true, true, false, false, true])
5-element BitArray{1}:
  true
  true
 false
 false
  true

julia> ror(A,1)
5-element BitArray{1}:
  true
  true
  true
 false
 false

julia> ror(A,2)
5-element BitArray{1}:
 false
  true
  true
  true
 false

julia> ror(A,5)
5-element BitArray{1}:
  true
  true
 false
 false
  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1564-L1605}{\texttt{source}}


\end{adjustwidth}

\hypertarget{2402954669804328212}{}


\section{Matrices y Vectores \emph{Sparse}}



Los vectores y las matrices \emph{sparse} soportan ampliamente el mismo conjunto de operaciones que sus contrapartidas densas. Las siguientes funciones son específicas para arrays \emph{sparse}.


\hypertarget{17278185509996384677}{} 
\hyperlink{17278185509996384677}{\texttt{Base.SparseArrays.SparseVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SparseVector{Tv,Ti<:Integer} <: AbstractSparseVector{Tv,Ti}
\end{lstlisting}

Vector type for storing sparse vectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L12-L16}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14881587545161853413}{} 
\hyperlink{14881587545161853413}{\texttt{Base.SparseArrays.SparseMatrixCSC}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SparseMatrixCSC{Tv,Ti<:Integer} <: AbstractSparseMatrix{Tv,Ti}
\end{lstlisting}

Matrix type for storing sparse matrices in the \hyperlink{4438718230137239554}{Compressed Sparse Column} format.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L8-L13}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6442735913986985800}{} 
\hyperlink{6442735913986985800}{\texttt{Base.SparseArrays.sparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sparse(A)
\end{lstlisting}

Convert an AbstractMatrix \texttt{A} into a sparse matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = eye(3)
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia> sparse(A)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L386-L405}{\texttt{source}}



\begin{lstlisting}
sparse(I, J, V,[ m, n, combine])
\end{lstlisting}

Create a sparse matrix \texttt{S} of dimensions \texttt{m x n} such that \texttt{S[I[k], J[k]] = V[k]}. The \texttt{combine} function is used to combine duplicates. If \texttt{m} and \texttt{n} are not specified, they are set to \texttt{maximum(I)} and \texttt{maximum(J)} respectively. If the \texttt{combine} function is not supplied, \texttt{combine} defaults to \texttt{+} unless the elements of \texttt{V} are Booleans in which case \texttt{combine} defaults to \texttt{|}. All elements of \texttt{I} must satisfy \texttt{1 <= I[k] <= m}, and all elements of \texttt{J} must satisfy \texttt{1 <= J[k] <= n}. Numerical zeros in (\texttt{I}, \texttt{J}, \texttt{V}) are retained as structural nonzeros; to drop numerical zeros, use \hyperlink{4343590179532251994}{\texttt{dropzeros!}}.

For additional documentation and an expert driver, see \texttt{Base.SparseArrays.sparse!}.

\textbf{Example}


\begin{minted}{jlcon}
julia> Is = [1; 2; 3];

julia> Js = [1; 2; 3];

julia> Vs = [1; 2; 3];

julia> sparse(Is, Js, Vs)
3×3 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
  [1, 1]  =  1
  [2, 2]  =  2
  [3, 3]  =  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L459-L486}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18161940743946340171}{} 
\hyperlink{18161940743946340171}{\texttt{Base.SparseArrays.sparsevec}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sparsevec(I, V, [m, combine])
\end{lstlisting}

Create a sparse vector \texttt{S} of length \texttt{m} such that \texttt{S[I[k]] = V[k]}. Duplicates are combined using the \texttt{combine} function, which defaults to \texttt{+} if no \texttt{combine} argument is provided, unless the elements of \texttt{V} are Booleans in which case \texttt{combine} defaults to \texttt{|}.


\begin{minted}{jlcon}
julia> II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];

julia> sparsevec(II, V)
5-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  0.5
  [5]  =  0.2

julia> sparsevec(II, V, 8, -)
8-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  -0.1
  [5]  =  0.2

julia> sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])
3-element SparseVector{Bool,Int64} with 3 stored entries:
  [1]  =  true
  [2]  =  false
  [3]  =  true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L103-L132}{\texttt{source}}



\begin{lstlisting}
sparsevec(d::Dict, [m])
\end{lstlisting}

Create a sparse vector of length \texttt{m} where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.


\begin{minted}{jlcon}
julia> sparsevec(Dict(1 => 3, 2 => 2))
2-element SparseVector{Int64,Int64} with 2 stored entries:
  [1]  =  3
  [2]  =  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L178-L190}{\texttt{source}}



\begin{lstlisting}
sparsevec(A)
\end{lstlisting}

Convert a vector \texttt{A} into a sparse vector of length \texttt{m}.

\textbf{Example}


\begin{minted}{jlcon}
julia> sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])
6-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  2.0
  [5]  =  3.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L309-L322}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4718940244439103334}{} 
\hyperlink{4718940244439103334}{\texttt{Base.SparseArrays.issparse}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issparse(S)
\end{lstlisting}

Returns \texttt{true} if \texttt{S} is sparse, and \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/abstractsparse.jl#L8-L12}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6442668105237896007}{} 
\hyperlink{6442668105237896007}{\texttt{Base.full}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
full(S)
\end{lstlisting}

Convert a sparse matrix or vector \texttt{S} into a dense matrix or vector.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia> full(A)
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L355-L374}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6318543341724753931}{} 
\hyperlink{6318543341724753931}{\texttt{Base.SparseArrays.nnz}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nnz(A)
\end{lstlisting}

Returns the number of stored (filled) elements in a sparse array.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia> nnz(A)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L36-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7195216781795987163}{} 
\hyperlink{7195216781795987163}{\texttt{Base.SparseArrays.spzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
spzeros([type,]m[,n])
\end{lstlisting}

Create a sparse vector of length \texttt{m} or sparse matrix of size \texttt{m x n}. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to \hyperlink{5027751419500983000}{\texttt{Float64}} if not specified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> spzeros(3, 3)
3×3 SparseMatrixCSC{Float64,Int64} with 0 stored entries

julia> spzeros(Float32, 4)
4-element SparseVector{Float32,Int64} with 0 stored entries
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1435-L1451}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8792030753977135320}{} 
\hyperlink{8792030753977135320}{\texttt{Base.SparseArrays.spones}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
spones(S)
\end{lstlisting}

Create a sparse array with the same structure as that of \texttt{S}, but with every nonzero element having the value \texttt{1.0}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [4, 1]  =  2.0
  [1, 2]  =  5.0
  [3, 3]  =  3.0
  [2, 4]  =  4.0

julia> spones(A)
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [4, 1]  =  1.0
  [1, 2]  =  1.0
  [3, 3]  =  1.0
  [2, 4]  =  1.0
\end{minted}

Note the difference from \hyperlink{15336931858862742282}{\texttt{speye}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1407-L1431}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15336931858862742282}{} 
\hyperlink{15336931858862742282}{\texttt{Base.SparseArrays.speye}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
speye([type,]m[,n])
\end{lstlisting}

Create a sparse identity matrix of size \texttt{m x m}. When \texttt{n} is supplied, create a sparse identity matrix of size \texttt{m x n}. The type defaults to \hyperlink{5027751419500983000}{\texttt{Float64}} if not specified.

\texttt{sparse(I, m, n)} is equivalent to \texttt{speye(Int, m, n)}, and \texttt{sparse(α*I, m, n)} can be used to efficiently create a sparse multiple \texttt{α} of the identity matrix.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1494-L1504}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11934860426109731956}{} 
\hyperlink{11934860426109731956}{\texttt{Base.SparseArrays.speye}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
speye(S)
\end{lstlisting}

Create a sparse identity matrix with the same size as \texttt{S}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = sparse([1,2,3,4],[2,4,3,1],[5.,4.,3.,2.])
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [4, 1]  =  2.0
  [1, 2]  =  5.0
  [3, 3]  =  3.0
  [2, 4]  =  4.0

julia> speye(A)
4×4 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  1.0
\end{minted}

Note the difference from \hyperlink{8792030753977135320}{\texttt{spones}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1467-L1490}{\texttt{source}}



\begin{lstlisting}
speye([type,]m[,n])
\end{lstlisting}

Create a sparse identity matrix of size \texttt{m x m}. When \texttt{n} is supplied, create a sparse identity matrix of size \texttt{m x n}. The type defaults to \hyperlink{5027751419500983000}{\texttt{Float64}} if not specified.

\texttt{sparse(I, m, n)} is equivalent to \texttt{speye(Int, m, n)}, and \texttt{sparse(α*I, m, n)} can be used to efficiently create a sparse multiple \texttt{α} of the identity matrix.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1494-L1504}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1081045183735911932}{} 
\hyperlink{1081045183735911932}{\texttt{Base.SparseArrays.spdiagm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
spdiagm(B, d[, m, n])
\end{lstlisting}

Construct a sparse diagonal matrix. \texttt{B} is a tuple of vectors containing the diagonals and \texttt{d} is a tuple containing the positions of the diagonals. In the case the input contains only one diagonal, \texttt{B} can be a vector (instead of a tuple) and \texttt{d} can be the diagonal position (instead of a tuple), defaulting to 0 (diagonal). Optionally, \texttt{m} and \texttt{n} specify the size of the resulting sparse matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> spdiagm(([1,2,3,4],[4,3,2,1]),(-1,1))
5×5 SparseMatrixCSC{Int64,Int64} with 8 stored entries:
  [2, 1]  =  1
  [1, 2]  =  4
  [3, 2]  =  2
  [2, 3]  =  3
  [4, 3]  =  3
  [3, 4]  =  2
  [5, 4]  =  4
  [4, 5]  =  1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L3288-L3310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7938626005548874744}{} 
\hyperlink{7938626005548874744}{\texttt{Base.SparseArrays.sprand}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])
\end{lstlisting}

Create a random length \texttt{m} sparse vector or \texttt{m} by \texttt{n} sparse matrix, in which the probability of any element being nonzero is independently given by \texttt{p} (and hence the mean density of nonzeros is also exactly \texttt{p}). Nonzero values are sampled from the distribution specified by \texttt{rfn} and have the type \texttt{type}. The uniform distribution is used in case \texttt{rfn} is not specified. The optional \texttt{rng} argument specifies a random number generator, see \hyperlink{4868036498049031913}{Random Numbers}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> sprand(rng, Bool, 2, 2, 0.5)
2×2 SparseMatrixCSC{Bool,Int64} with 2 stored entries:
  [1, 1]  =  true
  [2, 1]  =  true

julia> sprand(rng, Float64, 3, 0.75)
3-element SparseVector{Float64,Int64} with 1 stored entry:
  [3]  =  0.298614
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1330-L1353}{\texttt{source}}


\end{adjustwidth}
\hypertarget{641245889672681934}{} 
\hyperlink{641245889672681934}{\texttt{Base.SparseArrays.sprandn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sprandn([rng], m[,n],p::AbstractFloat)
\end{lstlisting}

Create a random sparse vector of length \texttt{m} or sparse matrix of size \texttt{m} by \texttt{n} with the specified (independent) probability \texttt{p} of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional \texttt{rng} argument specifies a random number generator, see \hyperlink{4868036498049031913}{Random Numbers}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rng = MersenneTwister(1234);

julia> sprandn(rng, 2, 2, 0.75)
2×2 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  0.532813
  [2, 1]  =  -0.271735
  [2, 2]  =  0.502334
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1384-L1402}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15883692643401464977}{} 
\hyperlink{15883692643401464977}{\texttt{Base.SparseArrays.nonzeros}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nonzeros(A)
\end{lstlisting}

Return a vector of the structural nonzero values in sparse array \texttt{A}. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of \texttt{A}, and any modifications to the returned vector will mutate \texttt{A} as well. See \hyperlink{1153295106359630489}{\texttt{rowvals}} and \hyperlink{6394537172532841781}{\texttt{nzrange}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia> nonzeros(A)
3-element Array{Float64,1}:
 1.0
 1.0
 1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L57-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1153295106359630489}{} 
\hyperlink{1153295106359630489}{\texttt{Base.SparseArrays.rowvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rowvals(A::SparseMatrixCSC)
\end{lstlisting}

Return a vector of the row indices of \texttt{A}. Any modifications to the returned vector will mutate \texttt{A} as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also \hyperlink{15883692643401464977}{\texttt{nonzeros}} and \hyperlink{6394537172532841781}{\texttt{nzrange}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(3)
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0

julia> rowvals(A)
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L83-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6394537172532841781}{} 
\hyperlink{6394537172532841781}{\texttt{Base.SparseArrays.nzrange}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nzrange(A::SparseMatrixCSC, col::Integer)
\end{lstlisting}

Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with \hyperlink{15883692643401464977}{\texttt{nonzeros}} and \hyperlink{1153295106359630489}{\texttt{rowvals}}, this allows for convenient iterating over a sparse matrix :


\begin{lstlisting}
A = sparse(I,J,V)
rows = rowvals(A)
vals = nonzeros(A)
m, n = size(A)
for i = 1:n
   for j in nzrange(A, i)
      row = rows[j]
      val = vals[j]
      # perform sparse wizardry...
   end
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L108-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4343590179532251994}{} 
\hyperlink{4343590179532251994}{\texttt{Base.SparseArrays.dropzeros!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dropzeros!(A::SparseMatrixCSC, trim::Bool = true)
\end{lstlisting}

Removes stored numerical zeros from \texttt{A}, optionally trimming resulting excess space from \texttt{A.rowval} and \texttt{A.nzval} when \texttt{trim} is \texttt{true}.

For an out-of-place version, see \hyperlink{16980472205632865276}{\texttt{dropzeros}}. For algorithmic information, see \texttt{fkeep!}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1199-L1207}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16980472205632865276}{} 
\hyperlink{16980472205632865276}{\texttt{Base.SparseArrays.dropzeros}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dropzeros(A::SparseMatrixCSC, trim::Bool = true)
\end{lstlisting}

Generates a copy of \texttt{A} and removes stored numerical zeros from that copy, optionally trimming excess space from the result{\textquotesingle}s \texttt{rowval} and \texttt{nzval} arrays when \texttt{trim} is \texttt{true}.

For an in-place version and algorithmic information, see \hyperlink{4343590179532251994}{\texttt{dropzeros!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  0.0
  [3, 3]  =  1.0

julia> dropzeros(A)
3×3 SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  1.0
  [3, 3]  =  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1209-L1230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3702526137302924148}{} 
\hyperlink{3702526137302924148}{\texttt{Base.SparseArrays.dropzeros!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dropzeros!(x::SparseVector, trim::Bool = true)
\end{lstlisting}

Removes stored numerical zeros from \texttt{x}, optionally trimming resulting excess space from \texttt{x.nzind} and \texttt{x.nzval} when \texttt{trim} is \texttt{true}.

For an out-of-place version, see \hyperlink{16980472205632865276}{\texttt{dropzeros}}. For algorithmic information, see \texttt{fkeep!}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L1921-L1929}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18261178615862576834}{} 
\hyperlink{18261178615862576834}{\texttt{Base.SparseArrays.dropzeros}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dropzeros(x::SparseVector, trim::Bool = true)
\end{lstlisting}

Generates a copy of \texttt{x} and removes numerical zeros from that copy, optionally trimming excess space from the result{\textquotesingle}s \texttt{nzind} and \texttt{nzval} arrays when \texttt{trim} is \texttt{true}.

For an in-place version and algorithmic information, see \hyperlink{4343590179532251994}{\texttt{dropzeros!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])
3-element SparseVector{Float64,Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  0.0
  [3]  =  1.0

julia> dropzeros(A)
3-element SparseVector{Float64,Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsevector.jl#L1931-L1952}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1610845759689502707}{} 
\hyperlink{1610845759689502707}{\texttt{Base.SparseArrays.permute}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permute{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},
    q::AbstractVector{<:Integer})
\end{lstlisting}

Bilaterally permute \texttt{A}, returning \texttt{PAQ} (\texttt{A[p,q]}). Column-permutation \texttt{q}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s column count (\texttt{length(q) == A.n}). Row-permutation \texttt{p}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s row count (\texttt{length(p) == A.m}).

For expert drivers and additional information, see \hyperlink{17157632988142440888}{\texttt{permute!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = spdiagm([1, 2, 3, 4], 0, 4, 4) + spdiagm([5, 6, 7], 1, 4, 4)
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [1, 1]  =  1
  [1, 2]  =  5
  [2, 2]  =  2
  [2, 3]  =  6
  [3, 3]  =  3
  [3, 4]  =  7
  [4, 4]  =  4

julia> permute(A, [4, 3, 2, 1], [1, 2, 3, 4])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [4, 1]  =  1
  [3, 2]  =  2
  [4, 2]  =  5
  [2, 3]  =  3
  [3, 3]  =  6
  [1, 4]  =  4
  [2, 4]  =  7

julia> permute(A, [1, 2, 3, 4], [4, 3, 2, 1])
4×4 SparseMatrixCSC{Int64,Int64} with 7 stored entries:
  [3, 1]  =  7
  [4, 1]  =  4
  [2, 2]  =  6
  [3, 2]  =  3
  [1, 3]  =  5
  [2, 3]  =  2
  [1, 4]  =  1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L1060-L1102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16133978171333546819}{} 
\hyperlink{16133978171333546819}{\texttt{Base.permute!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
permute!{Tv,Ti}(X::SparseMatrixCSC{Tv,Ti}, A::SparseMatrixCSC{Tv,Ti},
    p::AbstractVector{<:Integer}, q::AbstractVector{<:Integer}[, C::SparseMatrixCSC{Tv,Ti}])
\end{lstlisting}

Bilaterally permute \texttt{A}, storing result \texttt{PAQ} (\texttt{A[p,q]}) in \texttt{X}. Stores intermediate result \texttt{(AQ){\textasciicircum}T} (\texttt{transpose(A[:,q])}) in optional argument \texttt{C} if present. Requires that none of \texttt{X}, \texttt{A}, and, if present, \texttt{C} alias each other; to store result \texttt{PAQ} back into \texttt{A}, use the following method lacking \texttt{X}:


\begin{lstlisting}
permute!{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},
    q::AbstractVector{<:Integer}[, C::SparseMatrixCSC{Tv,Ti}[, workcolptr::Vector{Ti}]])
\end{lstlisting}

\texttt{X}{\textquotesingle}s dimensions must match those of \texttt{A} (\texttt{X.m == A.m} and \texttt{X.n == A.n}), and \texttt{X} must have enough storage to accommodate all allocated entries in \texttt{A} (\texttt{length(X.rowval) >= nnz(A)} and \texttt{length(X.nzval) >= nnz(A)}). Column-permutation \texttt{q}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s column count (\texttt{length(q) == A.n}). Row-permutation \texttt{p}{\textquotesingle}s length must match \texttt{A}{\textquotesingle}s row count (\texttt{length(p) == A.m}).

\texttt{C}{\textquotesingle}s dimensions must match those of \texttt{transpose(A)} (\texttt{C.m == A.n} and \texttt{C.n == A.m}), and \texttt{C} must have enough storage to accommodate all allocated entries in \texttt{A} (\texttt{length(C.rowval) >= nnz(A)} and \texttt{length(C.nzval) >= nnz(A)}).

For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods \texttt{unchecked\_noalias\_permute!} and \texttt{unchecked\_aliasing\_permute!}.

See also: \hyperlink{1610845759689502707}{\texttt{permute}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L990-L1017}{\texttt{source}}


\end{adjustwidth}

\hypertarget{10924396624761136101}{}


\chapter{Tareas y Computación Paralela}



\hypertarget{4451024474180753529}{}


\section{Tareas}


\hypertarget{7131243650304654155}{} 
\hyperlink{7131243650304654155}{\texttt{Core.Task}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Task(func)
\end{lstlisting}

Create a \texttt{Task} (i.e. coroutine) to execute the given function (which must be callable with no arguments). The task exits when this function returns.

\textbf{Example}


\begin{minted}{jlcon}
julia> a() = det(rand(1000, 1000));

julia> b = Task(a);
\end{minted}

In this example, \texttt{b} is a runnable \texttt{Task} that hasn{\textquotesingle}t started yet.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1640-L1654}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12929971401717674174}{} 
\hyperlink{12929971401717674174}{\texttt{Base.current\_task}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
current_task()
\end{lstlisting}

Get the currently running \hyperlink{7131243650304654155}{\texttt{Task}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L83-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7432450399685996831}{} 
\hyperlink{7432450399685996831}{\texttt{Base.istaskdone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istaskdone(t::Task) -> Bool
\end{lstlisting}

Determine whether a task has exited.


\begin{minted}{jlcon}
julia> a2() = det(rand(1000, 1000));

julia> b = Task(a2);

julia> istaskdone(b)
false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L90-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{188637489024602838}{} 
\hyperlink{188637489024602838}{\texttt{Base.istaskstarted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istaskstarted(t::Task) -> Bool
\end{lstlisting}

Determine whether a task has started executing.


\begin{minted}{jlcon}
julia> a3() = det(rand(1000, 1000));

julia> b = Task(a3);

julia> istaskstarted(b)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L113-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13455314829114364187}{} 
\hyperlink{13455314829114364187}{\texttt{Base.yield}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
yield()
\end{lstlisting}

Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L143-L149}{\texttt{source}}



\begin{lstlisting}
yield(t::Task, arg = nothing)
\end{lstlisting}

A fast, unfair-scheduling version of \texttt{schedule(t, arg); yield()} which immediately yields to \texttt{t} before calling the scheduler.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L152-L157}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4920987536368477483}{} 
\hyperlink{4920987536368477483}{\texttt{Base.yieldto}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
yieldto(t::Task, arg = nothing)
\end{lstlisting}

Switch to the given task. The first time a task is switched to, the task{\textquotesingle}s function is called with no arguments. On subsequent switches, \texttt{arg} is returned from the task{\textquotesingle}s last call to \texttt{yieldto}. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L165-L172}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8292907206163344794}{} 
\hyperlink{8292907206163344794}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
task_local_storage(key)
\end{lstlisting}

Look up the value of a key in the current task{\textquotesingle}s task-local storage.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L141-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2485476355246980354}{} 
\hyperlink{2485476355246980354}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
task_local_storage(key, value)
\end{lstlisting}

Assign a value to a key in the current task{\textquotesingle}s task-local storage.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L148-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18380692261281200127}{} 
\hyperlink{18380692261281200127}{\texttt{Base.task\_local\_storage}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
task_local_storage(body, key, value)
\end{lstlisting}

Call the function \texttt{body} with a modified task-local storage, in which \texttt{value} is assigned to \texttt{key}; the previous value of \texttt{key}, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L155-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{286351753995469758}{} 
\hyperlink{286351753995469758}{\texttt{Base.Condition}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Condition()
\end{lstlisting}

Create an edge-triggered event source that tasks can wait for. Tasks that call \hyperlink{13761789780433862250}{\texttt{wait}} on a \texttt{Condition} are suspended and queued. Tasks are woken up when \hyperlink{2865179286002578885}{\texttt{notify}} is later called on the \texttt{Condition}. Edge triggering means that only tasks waiting at the time \hyperlink{2865179286002578885}{\texttt{notify}} is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The \hyperlink{12548845729684045604}{\texttt{Channel}} type does this, and so can be used for level-triggered events.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L5-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2865179286002578885}{} 
\hyperlink{2865179286002578885}{\texttt{Base.notify}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
notify(condition, val=nothing; all=true, error=false)
\end{lstlisting}

Wake up tasks waiting for a condition, passing them \texttt{val}. If \texttt{all} is \texttt{true} (the default), all waiting tasks are woken, otherwise only one is. If \texttt{error} is \texttt{true}, the passed value is raised as an exception in the woken tasks.

Returns the count of tasks woken up. Returns 0 if no tasks are waiting on \texttt{condition}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L34-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9185853093207176818}{} 
\hyperlink{9185853093207176818}{\texttt{Base.schedule}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
schedule(t::Task, [val]; error=false)
\end{lstlisting}

Add a \hyperlink{7131243650304654155}{\texttt{Task}} to the scheduler{\textquotesingle}s queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as \hyperlink{13761789780433862250}{\texttt{wait}}.

If a second argument \texttt{val} is provided, it will be passed to the task (via the return value of \hyperlink{4920987536368477483}{\texttt{yieldto}}) when it runs again. If \texttt{error} is \texttt{true}, the value is raised as an exception in the woken task.


\begin{minted}{jlcon}
julia> a5() = det(rand(1000, 1000));

julia> b = Task(a5);

julia> istaskstarted(b)
false

julia> schedule(b);

julia> yield();

julia> istaskstarted(b)
true

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L91-L119}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15186286520310132839}{} 
\hyperlink{15186286520310132839}{\texttt{Base.@schedule}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@schedule
\end{lstlisting}

Wrap an expression in a \hyperlink{7131243650304654155}{\texttt{Task}} and add it to the local machine{\textquotesingle}s scheduler queue. Similar to \hyperlink{10770947021537241619}{\texttt{@async}} except that an enclosing \texttt{@sync} does NOT wait for tasks started with an \texttt{@schedule}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L65-L71}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16142823989571622868}{} 
\hyperlink{16142823989571622868}{\texttt{Base.@task}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@task
\end{lstlisting}

Wrap an expression in a \hyperlink{7131243650304654155}{\texttt{Task}} without executing it, and return the \hyperlink{7131243650304654155}{\texttt{Task}}. This only creates a task, and does not run it.


\begin{minted}{jlcon}
julia> a1() = det(rand(1000, 1000));

julia> b = @task a1();

julia> istaskstarted(b)
false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L57-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3231475347583891391}{} 
\hyperlink{3231475347583891391}{\texttt{Base.sleep}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sleep(seconds)
\end{lstlisting}

Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of \texttt{0.001}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/event.jl#L403-L408}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12548845729684045604}{} 
\hyperlink{12548845729684045604}{\texttt{Base.Channel}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Channel{T}(sz::Int)
\end{lstlisting}

Constructs a \texttt{Channel} with an internal buffer that can hold a maximum of \texttt{sz} objects of type \texttt{T}. \hyperlink{12719543094136814100}{\texttt{put!}} calls on a full channel block until an object is removed with \hyperlink{4360129174058888556}{\texttt{take!}}.

\texttt{Channel(0)} constructs an unbuffered channel. \texttt{put!} blocks until a matching \texttt{take!} is called. And vice-versa.

Other constructors:

\begin{itemize}
\item \texttt{Channel(Inf)}: equivalent to \texttt{Channel\{Any\}(typemax(Int))}


\item \texttt{Channel(sz)}: equivalent to \texttt{Channel\{Any\}(sz)}

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L5-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12719543094136814100}{} 
\hyperlink{12719543094136814100}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
put!(c::Channel, v)
\end{lstlisting}

Appends an item \texttt{v} to the channel \texttt{c}. Blocks if the channel is full.

For unbuffered channels, blocks until a \hyperlink{4360129174058888556}{\texttt{take!}} is performed by a different task.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L252-L259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6608633734376348608}{} 
\hyperlink{6608633734376348608}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
take!(c::Channel)
\end{lstlisting}

Removes and returns a value from a \hyperlink{12548845729684045604}{\texttt{Channel}}. Blocks until data is available.

For unbuffered channels, blocks until a \hyperlink{12719543094136814100}{\texttt{put!}} is performed by a different task.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L309-L316}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15888554370655089980}{} 
\hyperlink{15888554370655089980}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isready(c::Channel)
\end{lstlisting}

Determine whether a \hyperlink{12548845729684045604}{\texttt{Channel}} has a value stored to it. Returns immediately, does not block.

For unbuffered channels returns \texttt{true} if there are tasks waiting on a \hyperlink{12719543094136814100}{\texttt{put!}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L348-L356}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7098010828229464277}{} 
\hyperlink{7098010828229464277}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch(c::Channel)
\end{lstlisting}

Waits for and gets the first available item from the channel. Does not remove the item. \texttt{fetch} is unsupported on an unbuffered (0-size) channel.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L295-L300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9979143087438478792}{} 
\hyperlink{9979143087438478792}{\texttt{Base.close}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
close(c::Channel)
\end{lstlisting}

Closes a channel. An exception is thrown by:

\begin{itemize}
\item \hyperlink{12719543094136814100}{\texttt{put!}} on a closed channel.


\item \hyperlink{4360129174058888556}{\texttt{take!}} and \hyperlink{7098010828229464277}{\texttt{fetch}} on an empty, closed channel.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L135-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6778875052923307054}{} 
\hyperlink{6778875052923307054}{\texttt{Base.bind}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bind(chnl::Channel, task::Task)
\end{lstlisting}

Associates the lifetime of \texttt{chnl} with a task. Channel \texttt{chnl} is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on \texttt{chnl}.

The \texttt{chnl} object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.

When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @schedule foreach(i->put!(c, i), 1:4);

julia> bind(c,task);

julia> for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia> isopen(c)
false
\end{minted}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @schedule (put!(c,1);error("foo"));

julia> bind(c,task);

julia> take!(c)
1

julia> put!(c,1);
ERROR: foo
Stacktrace:
 [1] check_channel_state(::Channel{Any}) at ./channels.jl:131
 [2] put!(::Channel{Any}, ::Int64) at ./channels.jl:261
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L151-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14148755671315265621}{} 
\hyperlink{14148755671315265621}{\texttt{Base.asyncmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asyncmap(f, c...; ntasks=0, batch_size=nothing)
\end{lstlisting}

Uses multiple concurrent tasks to map \texttt{f} over a collection (or multiple equal length collections). For multiple collection arguments, \texttt{f} is applied elementwise.

\texttt{ntasks} specifies the number of tasks to run concurrently. Depending on the length of the collections, if \texttt{ntasks} is unspecified, up to 100 tasks will be used for concurrent mapping.

\texttt{ntasks} can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of \texttt{ntasks\_func()} is less than the current number of tasks.

If \texttt{batch\_size} is specified, the collection is processed in batch mode. \texttt{f} must then be a function that must accept a \texttt{Vector} of argument tuples and must return a vector of results. The input vector will have a length of \texttt{batch\_size} or less.

The following examples highlight execution in different tasks by returning the \texttt{object\_id} of the tasks in which the mapping function is executed.

First, with \texttt{ntasks} undefined, each element is processed in a different task.


\begin{lstlisting}
julia> tskoid() = object_id(current_task());

julia> asyncmap(x->tskoid(), 1:5)
5-element Array{UInt64,1}:
 0x6e15e66c75c75853
 0x440f8819a1baa682
 0x9fb3eeadd0c83985
 0xebd3e35fe90d4050
 0x29efc93edce2b961

julia> length(unique(asyncmap(x->tskoid(), 1:5)))
5
\end{lstlisting}

With \texttt{ntasks=2} all elements are processed in 2 tasks.


\begin{lstlisting}
julia> asyncmap(x->tskoid(), 1:5; ntasks=2)
5-element Array{UInt64,1}:
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94

julia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))
2
\end{lstlisting}

With \texttt{batch\_size} defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. \texttt{map} is used in the modified mapping function to achieve this.


\begin{lstlisting}
julia> batch_func(input) = map(x->string("args_tuple: ", x, ", element_val: ", x[1], ", task: ", tskoid()), input)
batch_func (generic function with 1 method)

julia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)
5-element Array{String,1}:
 "args_tuple: (1,), element_val: 1, task: 9118321258196414413"
 "args_tuple: (2,), element_val: 2, task: 4904288162898683522"
 "args_tuple: (3,), element_val: 3, task: 9118321258196414413"
 "args_tuple: (4,), element_val: 4, task: 4904288162898683522"
 "args_tuple: (5,), element_val: 5, task: 9118321258196414413"
\end{lstlisting}

\begin{quote}
\textbf{Note}

Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, \texttt{ayncmap} is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/asyncmap.jl#L5-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16469851777080200085}{} 
\hyperlink{16469851777080200085}{\texttt{Base.asyncmap!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)
\end{lstlisting}

Like \hyperlink{14148755671315265621}{\texttt{asyncmap()}}, but stores output in \texttt{results} rather than returning a collection.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/asyncmap.jl#L415-L420}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9206699468753153912}{}


\section{Soporte General a la Computación Paralela}


\hypertarget{1448678099847390}{} 
\hyperlink{1448678099847390}{\texttt{Base.Distributed.addprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers
\end{lstlisting}

Launches worker processes via the specified cluster manager.

For example, Beowulf clusters are supported via a custom cluster manager implemented in the package \texttt{ClusterManagers.jl}.

The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable \texttt{JULIA\_WORKER\_TIMEOUT} in the worker process{\textquotesingle}s environment. Relevant only when using TCP/IP as transport.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L302-L313}{\texttt{source}}



\begin{lstlisting}
addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers
\end{lstlisting}

Add processes on remote machines via SSH. Requires \texttt{julia} to be installed in the same location on each node, or to be available via a shared file system.

\texttt{machines} is a vector of machine specifications. Workers are started for each specification.

A machine specification is either a string \texttt{machine\_spec} or a tuple - \texttt{(machine\_spec, count)}.

\texttt{machine\_spec} is a string of the form \texttt{[user@]host[:port] [bind\_addr[:port]]}. \texttt{user} defaults to current user, \texttt{port} to the standard ssh port. If \texttt{[bind\_addr[:port]]} is specified, other workers will connect to this worker at the specified \texttt{bind\_addr} and \texttt{port}.

\texttt{count} is the number of workers to be launched on the specified host. If specified as \texttt{:auto} it will launch as many workers as the number of cores on the specific host.

Keyword arguments:

\begin{itemize}
\item \texttt{tunnel}: if \texttt{true} then SSH tunneling will be used to connect to the worker from the master process. Default is \texttt{false}.


\item \texttt{sshflags}: specifies additional ssh options, e.g. \texttt{sshflags=`-i /home/foo/bar.pem}`


\item \texttt{max\_parallel}: specifies the maximum number of workers connected to in parallel at a host. Defaults to 10.


\item \texttt{dir}: specifies the working directory on the workers. Defaults to the host{\textquotesingle}s current directory (as found by \texttt{pwd()})


\item \texttt{enable\_threaded\_blas}: if \texttt{true} then  BLAS will run on multiple threads in added processes. Default is \texttt{false}.


\item \texttt{exename}: name of the \texttt{julia} executable. Defaults to \texttt{{\textquotedbl}\$JULIA\_HOME/julia{\textquotedbl}} or \texttt{{\textquotedbl}\$JULIA\_HOME/julia-debug{\textquotedbl}} as the case may be.


\item \texttt{exeflags}: additional flags passed to the worker processes.


\item \texttt{topology}: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.

\begin{itemize}
\item \texttt{topology=:all\_to\_all}: All processes are connected to each other. The default.


\item \texttt{topology=:master\_slave}: Only the driver process, i.e. \texttt{pid} 1 connects to the workers. The workers do not connect to each other.


\item \texttt{topology=:custom}: The \texttt{launch} method of the cluster manager specifies the connection topology via fields \texttt{ident} and \texttt{connect\_idents} in \texttt{WorkerConfig}. A worker with a cluster manager identity \texttt{ident} will connect to all workers specified in \texttt{connect\_idents}.

\end{itemize}
\end{itemize}
Environment variables :

If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable \texttt{JULIA\_WORKER\_TIMEOUT}. The value of \texttt{JULIA\_WORKER\_TIMEOUT} on the master process specifies the number of seconds a newly launched worker waits for connection establishment.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L51-L111}{\texttt{source}}



\begin{lstlisting}
addprocs(; kwargs...) -> List of process identifiers
\end{lstlisting}

Equivalent to \texttt{addprocs(Sys.CPU\_CORES; kwargs...)}

Note that workers do not run a \texttt{.juliarc.jl} startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L289-L297}{\texttt{source}}



\begin{lstlisting}
addprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers
\end{lstlisting}

Launches workers using the in-built \texttt{LocalManager} which only launches workers on the local host. This can be used to take advantage of multiple cores. \texttt{addprocs(4)} will add 4 processes on the local machine. If \texttt{restrict} is \texttt{true}, binding is restricted to \texttt{127.0.0.1}. Keyword args \texttt{dir}, \texttt{exename}, \texttt{exeflags}, \texttt{topology}, and \texttt{enable\_threaded\_blas} have the same effect as documented for \texttt{addprocs(machines)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L300-L308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12402227166111076109}{} 
\hyperlink{12402227166111076109}{\texttt{Base.Distributed.nprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nprocs()
\end{lstlisting}

Get the number of available processes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L649-L653}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7337972716564963880}{} 
\hyperlink{7337972716564963880}{\texttt{Base.Distributed.nworkers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nworkers()
\end{lstlisting}

Get the number of available worker processes. This is one less than \texttt{nprocs()}. Equal to \texttt{nprocs()} if \texttt{nprocs() == 1}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L669-L674}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17214181692567267057}{} 
\hyperlink{17214181692567267057}{\texttt{Base.Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
procs()
\end{lstlisting}

Returns a list of all process identifiers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L680-L684}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4820068502451115503}{} 
\hyperlink{4820068502451115503}{\texttt{Base.Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
procs(pid::Integer)
\end{lstlisting}

Returns a list of all process identifiers on the same physical node. Specifically all workers bound to the same ip-address as \texttt{pid} are returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L711-L716}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13629390137500792933}{} 
\hyperlink{13629390137500792933}{\texttt{Base.Distributed.workers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
workers()
\end{lstlisting}

Returns a list of all worker process identifiers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L731-L735}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10441166839192005456}{} 
\hyperlink{10441166839192005456}{\texttt{Base.Distributed.rmprocs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rmprocs(pids...; waitfor=typemax(Int))
\end{lstlisting}

Removes the specified workers. Note that only process 1 can add or remove workers.

Argument \texttt{waitfor} specifies how long to wait for the workers to shut down:     - If unspecified, \texttt{rmprocs} will wait until all requested \texttt{pids} are removed.     - An \texttt{ErrorException} is raised if all workers cannot be terminated before       the requested \texttt{waitfor} seconds.     - With a \texttt{waitfor} value of 0, the call returns immediately with the workers       scheduled for removal in a different task. The scheduled \texttt{Task} object is       returned. The user should call \texttt{wait} on the task before invoking any other       parallel calls.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L751-L765}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13784302834661046969}{} 
\hyperlink{13784302834661046969}{\texttt{Base.Distributed.interrupt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
interrupt(pids::Integer...)
\end{lstlisting}

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L936-L941}{\texttt{source}}



\begin{lstlisting}
interrupt(pids::AbstractVector=workers())
\end{lstlisting}

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L944-L949}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1193443008958371070}{} 
\hyperlink{1193443008958371070}{\texttt{Base.Distributed.myid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
myid()
\end{lstlisting}

Get the id of the current process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L642-L646}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3190941263759446411}{} 
\hyperlink{3190941263759446411}{\texttt{Base.Distributed.pmap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pmap([::AbstractWorkerPool], f, c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[]), retry_check=nothing) -> collection
\end{lstlisting}

Transform collection \texttt{c} by applying \texttt{f} to each element using available workers and tasks.

For multiple collection arguments, apply \texttt{f} elementwise.

Note that \texttt{f} must be made available to all worker processes; see \hyperlink{10930251041671662785}{Code Availability and Loading Packages} for details.

If a worker pool is not specified, all available workers, i.e., the default worker pool is used.

By default, \texttt{pmap} distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify \texttt{distributed=false}. This is equivalent to using \hyperlink{14148755671315265621}{\texttt{asyncmap}}. For example, \texttt{pmap(f, c; distributed=false)} is equivalent to \texttt{asyncmap(f,c; ntasks=()->nworkers())}

\texttt{pmap} can also use a mix of processes and tasks via the \texttt{batch\_size} argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length \texttt{batch\_size} or less. A batch is sent as a single request to a free worker, where a local \hyperlink{14148755671315265621}{\texttt{asyncmap}} processes elements from the batch using multiple concurrent tasks.

Any error stops \texttt{pmap} from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument \texttt{on\_error} which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.

Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:


\begin{minted}{jlcon}
julia> pmap(x->iseven(x) ? error("foo") : x, 1:4; on_error=identity)
4-element Array{Any,1}:
 1
  ErrorException("foo")
 3
  ErrorException("foo")

julia> pmap(x->iseven(x) ? error("foo") : x, 1:4; on_error=ex->0)
4-element Array{Int64,1}:
 1
 0
 3
 0
\end{minted}

Errors can also be handled by retrying failed computations. Keyword arguments \texttt{retry\_delays} and \texttt{retry\_check} are passed through to \hyperlink{13615447016541985376}{\texttt{retry}} as keyword arguments \texttt{delays} and \texttt{check} respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.

Note that if both \texttt{on\_error} and \texttt{retry\_delays} are specified, the \texttt{on\_error} hook is called before retrying. If \texttt{on\_error} does not throw (or rethrow) an exception, the element will not be retried.

Example: On errors, retry \texttt{f} on an element a maximum of 3 times without any delay between retries.


\begin{minted}{julia}
pmap(f, c; retry_delays = zeros(3))
\end{minted}

Example: Retry \texttt{f} only if the exception is not of type \texttt{InexactError}, with exponentially increasing delays up to 3 times. Return a \texttt{NaN} in place for all \texttt{InexactError} occurrences.


\begin{minted}{julia}
pmap(f, c; on_error = e->(isa(e, InexactError) ? NaN : rethrow(e)), retry_delays = ExponentialBackOff(n = 3))
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/pmap.jl#L32-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13592793980665725371}{} 
\hyperlink{13592793980665725371}{\texttt{Base.Distributed.RemoteException}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RemoteException(captured)
\end{lstlisting}

Exceptions on remote computations are captured and rethrown locally.  A \texttt{RemoteException} wraps the \texttt{pid} of the worker and a captured exception. A \texttt{CapturedException} captures the remote exception and a serializable form of the call stack when the exception was raised.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/process_messages.jl#L24-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11214097672600393233}{} 
\hyperlink{11214097672600393233}{\texttt{Base.Distributed.Future}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Future(pid::Integer=myid())
\end{lstlisting}

Create a \texttt{Future} on process \texttt{pid}. The default \texttt{pid} is the current process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L72-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18168838922212360925}{} 
\hyperlink{18168838922212360925}{\texttt{Base.Distributed.RemoteChannel}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RemoteChannel(pid::Integer=myid())
\end{lstlisting}

Make a reference to a \texttt{Channel\{Any\}(1)} on process \texttt{pid}. The default \texttt{pid} is the current process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L80-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5214781515071051930}{} 
\hyperlink{5214781515071051930}{\texttt{Base.Distributed.RemoteChannel}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RemoteChannel(f::Function, pid::Integer=myid())
\end{lstlisting}

Create references to remote channels of a specific size and type. \texttt{f()} is a function that when executed on \texttt{pid} must return an implementation of an \texttt{AbstractChannel}.

For example, \texttt{RemoteChannel(()->Channel\{Int\}(10), pid)}, will return a reference to a channel of type \texttt{Int} and size 10 on \texttt{pid}.

The default \texttt{pid} is the current process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L88-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13761789780433862250}{} 
\hyperlink{13761789780433862250}{\texttt{Base.wait}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
wait([x])
\end{lstlisting}

Block the current task until some event occurs, depending on the type of the argument:

\begin{itemize}
\item \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} : Wait for a value to become available on the specified remote channel.


\item \hyperlink{11214097672600393233}{\texttt{Future}} : Wait for a value to become available for the specified future.


\item \hyperlink{12548845729684045604}{\texttt{Channel}}: Wait for a value to be appended to the channel.


\item \hyperlink{286351753995469758}{\texttt{Condition}}: Wait for \hyperlink{2865179286002578885}{\texttt{notify}} on a condition.


\item \texttt{Process}: Wait for a process or process chain to exit. The \texttt{exitcode} field of a process can be used to determine success or failure.


\item \hyperlink{7131243650304654155}{\texttt{Task}}: Wait for a \texttt{Task} to finish, returning its result value. If the task fails with an exception, the exception is propagated (re-thrown in the task that called \texttt{wait}).


\item \texttt{RawFD}: Wait for changes on a file descriptor (see \hyperlink{3484187138285863365}{\texttt{poll\_fd}} for keyword arguments and return code)

\end{itemize}
If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to \hyperlink{9185853093207176818}{\texttt{schedule}} or \hyperlink{4920987536368477483}{\texttt{yieldto}}.

Often \texttt{wait} is called within a \texttt{while} loop to ensure a waited-for condition is met before proceeding.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1544-L1566}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5432507241688521880}{} 
\hyperlink{5432507241688521880}{\texttt{Base.fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch(x)
\end{lstlisting}

Waits and fetches a value from \texttt{x} depending on the type of \texttt{x}:

\begin{itemize}
\item \hyperlink{11214097672600393233}{\texttt{Future}}: Wait for and get the value of a \texttt{Future}. The fetched value is cached locally. Further calls to \texttt{fetch} on the same reference return the cached value. If the remote value is an exception, throws a \hyperlink{13592793980665725371}{\texttt{RemoteException}} which captures the remote exception and backtrace.


\item \hyperlink{18168838922212360925}{\texttt{RemoteChannel}}: Wait for and get the value of a remote reference. Exceptions raised are same as for a \texttt{Future} .

\end{itemize}
Does not remove the item fetched.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L469-L481}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1245601033905961947}{} 
\hyperlink{1245601033905961947}{\texttt{Base.Distributed.remotecall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall(f, id::Integer, args...; kwargs...) -> Future
\end{lstlisting}

Call a function \texttt{f} asynchronously on the given arguments on the specified process. Returns a \hyperlink{11214097672600393233}{\texttt{Future}}. Keyword arguments, if any, are passed through to \texttt{f}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L329-L335}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13031962431312635607}{} 
\hyperlink{13031962431312635607}{\texttt{Base.Distributed.remotecall\_wait}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall_wait(f, id::Integer, args...; kwargs...)
\end{lstlisting}

Perform a faster \texttt{wait(remotecall(...))} in one message on the \texttt{Worker} specified by worker id \texttt{id}. Keyword arguments, if any, are passed through to \texttt{f}.

See also \hyperlink{13761789780433862250}{\texttt{wait}} and \hyperlink{1245601033905961947}{\texttt{remotecall}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L386-L393}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16429337757386989414}{} 
\hyperlink{16429337757386989414}{\texttt{Base.Distributed.remotecall\_fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall_fetch(f, id::Integer, args...; kwargs...)
\end{lstlisting}

Perform \texttt{fetch(remotecall(...))} in one message. Keyword arguments, if any, are passed through to \texttt{f}. Any remote exceptions are captured in a \hyperlink{13592793980665725371}{\texttt{RemoteException}} and thrown.

See also \hyperlink{7098010828229464277}{\texttt{fetch}} and \hyperlink{1245601033905961947}{\texttt{remotecall}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L357-L366}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11257172697035768275}{} 
\hyperlink{11257172697035768275}{\texttt{Base.Distributed.remote\_do}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remote_do(f, id::Integer, args...; kwargs...) -> nothing
\end{lstlisting}

Executes \texttt{f} on worker \texttt{id} asynchronously. Unlike \hyperlink{1245601033905961947}{\texttt{remotecall}}, it does not store the result of computation, nor is there a way to wait for its completion.

A successful invocation indicates that the request has been accepted for execution on the remote node.

While consecutive \texttt{remotecall}s to the same worker are serialized in the order they are invoked, the order of executions on the remote worker is undetermined. For example, \texttt{remote\_do(f1, 2); remotecall(f2, 2); remote\_do(f3, 2)} will serialize the call to \texttt{f1}, followed by \texttt{f2} and \texttt{f3} in that order. However, it is not guaranteed that \texttt{f1} is executed before \texttt{f3} on worker 2.

Any exceptions thrown by \texttt{f} are printed to \hyperlink{4481879903628924306}{\texttt{STDERR}} on the remote worker.

Keyword arguments, if any, are passed through to \texttt{f}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L412-L431}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2834687666116026096}{} 
\hyperlink{2834687666116026096}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
put!(rr::RemoteChannel, args...)
\end{lstlisting}

Store a set of values to the \hyperlink{18168838922212360925}{\texttt{RemoteChannel}}. If the channel is full, blocks until space is available. Returns its first argument.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L514-L520}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4609812859110888236}{} 
\hyperlink{4609812859110888236}{\texttt{Base.put!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
put!(rr::Future, v)
\end{lstlisting}

Store a value to a \hyperlink{11214097672600393233}{\texttt{Future}} \texttt{rr}. \texttt{Future}s are write-once remote references. A \texttt{put!} on an already set \texttt{Future} throws an \texttt{Exception}. All asynchronous remote calls return \texttt{Future}s and set the value to the return value of the call upon completion.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L486-L494}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1891403764656916697}{} 
\hyperlink{1891403764656916697}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
take!(rr::RemoteChannel, args...)
\end{lstlisting}

Fetch value(s) from a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} \texttt{rr}, removing the value(s) in the processs.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L532-L537}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6980559591888438300}{} 
\hyperlink{6980559591888438300}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isready(rr::RemoteChannel, args...)
\end{lstlisting}

Determine whether a \hyperlink{18168838922212360925}{\texttt{RemoteChannel}} has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a \hyperlink{11214097672600393233}{\texttt{Future}} since they are assigned only once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L187-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10100315526321712686}{} 
\hyperlink{10100315526321712686}{\texttt{Base.isready}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isready(rr::Future)
\end{lstlisting}

Determine whether a \hyperlink{11214097672600393233}{\texttt{Future}} has a value stored to it.

If the argument \texttt{Future} is owned by a different node, this call will block to wait for the answer. It is recommended to wait for \texttt{rr} in a separate task instead or to use a local \hyperlink{12548845729684045604}{\texttt{Channel}} as a proxy:


\begin{lstlisting}
c = Channel(1)
@async put!(c, remotecall_fetch(long_computation, p))
isready(c)  # will not block
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L163-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8368170094868952623}{} 
\hyperlink{8368170094868952623}{\texttt{Base.Distributed.WorkerPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
WorkerPool(workers::Vector{Int})
\end{lstlisting}

Create a WorkerPool from a vector of worker ids.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L32-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8679930550166196253}{} 
\hyperlink{8679930550166196253}{\texttt{Base.Distributed.CachingPool}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CachingPool(workers::Vector{Int})
\end{lstlisting}

An implementation of an \texttt{AbstractWorkerPool}. \hyperlink{8380052638349282305}{\texttt{remote}}, \hyperlink{16429337757386989414}{\texttt{remotecall\_fetch}}, \hyperlink{3190941263759446411}{\texttt{pmap}} (and other remote calls which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker nodes, especially closures (which may capture large amounts of data).

The remote cache is maintained for the lifetime of the returned \texttt{CachingPool} object. To clear the cache earlier, use \texttt{clear!(pool)}.

For global variables, only the bindings are captured in a closure, not the data. \texttt{let} blocks can be used to capture global data.

For example:


\begin{lstlisting}
const foo=rand(10^8);
wp=CachingPool(workers())
let foo=foo
    pmap(wp, i->sum(foo)+i, 1:100);
end
\end{lstlisting}

The above would transfer \texttt{foo} only once to each worker.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L233-L259}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13200137723206461941}{} 
\hyperlink{13200137723206461941}{\texttt{Base.Distributed.default\_worker\_pool}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
default_worker_pool()
\end{lstlisting}

\texttt{WorkerPool} containing idle \texttt{workers()} - used by \texttt{remote(f)} and \hyperlink{3190941263759446411}{\texttt{pmap}} (by default).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L190-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16259780224935483802}{} 
\hyperlink{16259780224935483802}{\texttt{Base.Distributed.clear!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clear!(pool::CachingPool) -> pool
\end{lstlisting}

Removes all cached functions from all participating workers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L268-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8380052638349282305}{} 
\hyperlink{8380052638349282305}{\texttt{Base.Distributed.remote}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remote([::AbstractWorkerPool], f) -> Function
\end{lstlisting}

Returns an anonymous function that executes function \texttt{f} on an available worker using \hyperlink{16429337757386989414}{\texttt{remotecall\_fetch}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L208-L213}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6767221148230310505}{} 
\hyperlink{6767221148230310505}{\texttt{Base.Distributed.remotecall}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future
\end{lstlisting}

\texttt{WorkerPool} variant of \texttt{remotecall(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remotecall} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L155-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6787127768037432165}{} 
\hyperlink{6787127768037432165}{\texttt{Base.Distributed.remotecall\_wait}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future
\end{lstlisting}

\texttt{WorkerPool} variant of \texttt{remotecall\_wait(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remotecall\_wait} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L163-L168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6534665661235048702}{} 
\hyperlink{6534665661235048702}{\texttt{Base.Distributed.remotecall\_fetch}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -> result
\end{lstlisting}

\texttt{WorkerPool} variant of \texttt{remotecall\_fetch(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remotecall\_fetch} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L172-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17973648003664616521}{} 
\hyperlink{17973648003664616521}{\texttt{Base.Distributed.remote\_do}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -> nothing
\end{lstlisting}

\texttt{WorkerPool} variant of \texttt{remote\_do(f, pid, ....)}. Waits for and takes a free worker from \texttt{pool} and performs a \texttt{remote\_do} on it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/workerpool.jl#L180-L185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6677218100159857934}{} 
\hyperlink{6677218100159857934}{\texttt{Base.timedwait}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)
\end{lstlisting}

Waits until \texttt{testcb} returns \texttt{true} or for \texttt{secs} seconds, whichever is earlier. \texttt{testcb} is polled every \texttt{pollint} seconds.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L340-L345}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2703776722227867458}{} 
\hyperlink{2703776722227867458}{\texttt{Base.Distributed.@spawn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@spawn
\end{lstlisting}

Creates a closure around an expression and runs it on an automatically-chosen process, returning a \hyperlink{11214097672600393233}{\texttt{Future}} to the result.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2078-L2083}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13196020699522784599}{} 
\hyperlink{13196020699522784599}{\texttt{Base.Distributed.@spawnat}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@spawnat
\end{lstlisting}

Accepts two arguments, \texttt{p} and an expression. A closure is created around the expression and run asynchronously on process \texttt{p}. Returns a \hyperlink{11214097672600393233}{\texttt{Future}} to the result.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L564-L569}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1474997561197825789}{} 
\hyperlink{1474997561197825789}{\texttt{Base.Distributed.@fetch}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@fetch
\end{lstlisting}

Equivalent to \texttt{fetch(@spawn expr)}. See \hyperlink{7098010828229464277}{\texttt{fetch}} and \hyperlink{2703776722227867458}{\texttt{@spawn}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/macros.jl#L29-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8163637794457229182}{} 
\hyperlink{8163637794457229182}{\texttt{Base.Distributed.@fetchfrom}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@fetchfrom
\end{lstlisting}

Equivalent to \texttt{fetch(@spawnat p expr)}. See \hyperlink{7098010828229464277}{\texttt{fetch}} and \hyperlink{13196020699522784599}{\texttt{@spawnat}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/macros.jl#L40-L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10770947021537241619}{} 
\hyperlink{10770947021537241619}{\texttt{Base.@async}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@async
\end{lstlisting}

Like \texttt{@schedule}, \texttt{@async} wraps an expression in a \texttt{Task} and adds it to the local machine{\textquotesingle}s scheduler queue. Additionally it adds the task to the set of items that the nearest enclosing \texttt{@sync} waits for.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L327-L333}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7188613740509403855}{} 
\hyperlink{7188613740509403855}{\texttt{Base.@sync}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@sync
\end{lstlisting}

Wait until all dynamically-enclosed uses of \texttt{@async}, \texttt{@spawn}, \texttt{@spawnat} and \texttt{@parallel} are complete. All exceptions thrown by enclosed async operations are collected and thrown as a \texttt{CompositeException}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/task.jl#L292-L298}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11870389661093259741}{} 
\hyperlink{11870389661093259741}{\texttt{Base.Distributed.@parallel}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@parallel
\end{lstlisting}

A parallel for loop of the form :


\begin{lstlisting}
@parallel [reducer] for var = range
    body
end
\end{lstlisting}

The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, \texttt{@parallel} performs local reductions on each worker with a final reduction on the calling process.

Note that without a reducer function, \texttt{@parallel} executes asynchronously, i.e. it spawns independent tasks on all available workers and returns immediately without waiting for completion. To wait for completion, prefix the call with \hyperlink{7188613740509403855}{\texttt{@sync}}, like :


\begin{lstlisting}
@sync @parallel for var = range
    body
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/macros.jl#L180-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12473779098025967223}{} 
\hyperlink{12473779098025967223}{\texttt{Base.Distributed.@everywhere}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@everywhere expr
\end{lstlisting}

Execute an expression under \texttt{Main} everywhere. Equivalent to calling \texttt{eval(Main, expr)} on all processes. Errors on any of the processes are collected into a \texttt{CompositeException} and thrown. For example :


\begin{lstlisting}
@everywhere bar=1
\end{lstlisting}

will define \texttt{Main.bar} on all processes.

Unlike \hyperlink{2703776722227867458}{\texttt{@spawn}} and \hyperlink{13196020699522784599}{\texttt{@spawnat}}, \texttt{@everywhere} does not capture any local variables. Prefixing \texttt{@everywhere} with \hyperlink{12895501458291832858}{\texttt{@eval}} allows us to broadcast local variables using interpolation :


\begin{lstlisting}
foo = 1
@eval @everywhere bar=$foo
\end{lstlisting}

The expression is evaluated under \texttt{Main} irrespective of where \texttt{@everywhere} is called from. For example :


\begin{lstlisting}
module FooBar
    foo() = @everywhere bar()=myid()
end
FooBar.foo()
\end{lstlisting}

will result in \texttt{Main.bar} being defined on all processes and not \texttt{FooBar.bar}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/macros.jl#L67-L95}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1215353657448172824}{} 
\hyperlink{1215353657448172824}{\texttt{Base.Distributed.clear!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clear!(syms, pids=workers(); mod=Main)
\end{lstlisting}

Clears global bindings in modules by initializing them to \texttt{nothing}. \texttt{syms} should be of type \texttt{Symbol} or a collection of \texttt{Symbol}s . \texttt{pids} and \texttt{mod} identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under \texttt{mod} are cleared.

An exception is raised if a global constant is requested to be cleared.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/clusterserialize.jl#L228-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18395570731388646834}{} 
\hyperlink{18395570731388646834}{\texttt{Base.Distributed.remoteref\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.remoteref_id(r::AbstractRemoteRef) -> RRID
\end{lstlisting}

\texttt{Future}s and \texttt{RemoteChannel}s are identified by fields:

\begin{itemize}
\item \texttt{where} - refers to the node where the underlying object/storage referred to by the reference actually exists.


\item \texttt{whence} - refers to the node the remote reference was created from. Note that this is different from the node where the underlying object referred to actually exists. For example calling \texttt{RemoteChannel(2)} from the master process would result in a \texttt{where} value of 2 and a \texttt{whence} value of 1.


\item \texttt{id} is unique across all references created from the worker specified by \texttt{whence}.

\end{itemize}
Taken together,  \texttt{whence} and \texttt{id} uniquely identify a reference across all workers.

\texttt{Base.remoteref\_id} is a low-level API which returns a \texttt{Base.RRID} object that wraps \texttt{whence} and \texttt{id} values of a remote reference.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L109-L129}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8998573007654850595}{} 
\hyperlink{8998573007654850595}{\texttt{Base.Distributed.channel\_from\_id}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.channel_from_id(id) -> c
\end{lstlisting}

A low-level API which returns the backing \texttt{AbstractChannel} for an \texttt{id} returned by \hyperlink{18395570731388646834}{\texttt{remoteref\_id}}. The call is valid only on the node where the backing channel exists.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/remotecall.jl#L132-L138}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6860508881203693771}{} 
\hyperlink{6860508881203693771}{\texttt{Base.Distributed.worker\_id\_from\_socket}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.worker_id_from_socket(s) -> pid
\end{lstlisting}

A low-level API which given a \texttt{IO} connection or a \texttt{Worker}, returns the \texttt{pid} of the worker it is connected to. This is useful when writing custom \hyperlink{11136223858024612210}{\texttt{serialize}} methods for a type, which optimizes the data written out depending on the receiving process id.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L842-L849}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12027223643055649570}{} 
\hyperlink{12027223643055649570}{\texttt{Base.Distributed.cluster\_cookie}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.cluster_cookie() -> cookie
\end{lstlisting}

Returns the cluster cookie.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L569-L573}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14582041898079717841}{} 
\hyperlink{14582041898079717841}{\texttt{Base.Distributed.cluster\_cookie}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.cluster_cookie(cookie) -> cookie
\end{lstlisting}

Sets the passed cookie as the cluster cookie, then returns it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L576-L580}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8266562503080193386}{}


\section{Arrays Compartidos}


\hypertarget{7878126212965430667}{} 
\hyperlink{7878126212965430667}{\texttt{Base.SharedArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SharedArray{T}(dims::NTuple; init=false, pids=Int[])
SharedArray{T,N}(...)
\end{lstlisting}

Construct a \texttt{SharedArray} of a bits type \texttt{T} and size \texttt{dims} across the processes specified by \texttt{pids} - all of which have to be on the same host.  If \texttt{N} is specified by calling \texttt{SharedArray\{T,N\}(dims)}, then \texttt{N} must match the length of \texttt{dims}.

If \texttt{pids} is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, \texttt{localindexes} and \texttt{indexpids} will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.

If an \texttt{init} function of the type \texttt{initfn(S::SharedArray)} is specified, it is called on all the participating workers.

The shared array is valid as long as a reference to the \texttt{SharedArray} object exists on the node which created the mapping.


\begin{lstlisting}
SharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids=Int[])
SharedArray{T,N}(...)
\end{lstlisting}

Construct a \texttt{SharedArray} backed by the file \texttt{filename}, with element type \texttt{T} (must be a bits type) and size \texttt{dims}, across the processes specified by \texttt{pids} - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:

\begin{itemize}
\item The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)


\item Any changes you make to the array values (e.g., \texttt{A[3] = 0}) will also change the values on disk

\end{itemize}
If \texttt{pids} is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, \texttt{localindexes} and \texttt{indexpids} will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.

\texttt{mode} must be one of \texttt{{\textquotedbl}r{\textquotedbl}}, \texttt{{\textquotedbl}r+{\textquotedbl}}, \texttt{{\textquotedbl}w+{\textquotedbl}}, or \texttt{{\textquotedbl}a+{\textquotedbl}}, and defaults to \texttt{{\textquotedbl}r+{\textquotedbl}} if the file specified by \texttt{filename} already exists, or \texttt{{\textquotedbl}w+{\textquotedbl}} if not. If an \texttt{init} function of the type \texttt{initfn(S::SharedArray)} is specified, it is called on all the participating workers. You cannot specify an \texttt{init} function if the file is not writable.

\texttt{offset} allows you to skip the specified number of bytes at the beginning of the file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L37-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11406168328748369296}{} 
\hyperlink{11406168328748369296}{\texttt{Base.Distributed.procs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
procs(S::SharedArray)
\end{lstlisting}

Get the vector of processes mapping the shared array.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L288-L292}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12236070431744516222}{} 
\hyperlink{12236070431744516222}{\texttt{Base.sdata}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sdata(S::SharedArray)
\end{lstlisting}

Returns the actual \texttt{Array} object backing \texttt{S}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L304-L308}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7166338227826761370}{} 
\hyperlink{7166338227826761370}{\texttt{Base.indexpids}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
indexpids(S::SharedArray)
\end{lstlisting}

Returns the current worker{\textquotesingle}s index in the list of workers mapping the \texttt{SharedArray} (i.e. in the same list returned by \texttt{procs(S)}), or 0 if the \texttt{SharedArray} is not mapped locally.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L295-L301}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6459655385118725622}{} 
\hyperlink{6459655385118725622}{\texttt{Base.localindexes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
localindexes(S::SharedArray)
\end{lstlisting}

Returns a range describing the {\textquotedbl}default{\textquotedbl} indexes to be handled by the current process.  This range should be interpreted in the sense of linear indexing, i.e., as a sub-range of \texttt{1:length(S)}.  In multi-process contexts, returns an empty range in the parent process (or any process for which \hyperlink{7166338227826761370}{\texttt{indexpids}} returns 0).

It{\textquotesingle}s worth emphasizing that \texttt{localindexes} exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a \texttt{SharedArray}, all indexes should be equally fast for each worker process.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sharedarray.jl#L312-L325}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14381575188112169600}{}


\section{Multi-Hilo}



Este interfaz experimental soporta las capacidades multi-hilo de Julia. Los tipos y funciones descritos aquí pueden cambiar en el futuro (y probablemente lo harán).


\hypertarget{12668125807854133993}{} 
\hyperlink{12668125807854133993}{\texttt{Base.Threads.threadid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.threadid()
\end{lstlisting}

Get the ID number of the current thread of execution. The master thread has ID \texttt{1}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/threadingconstructs.jl#L5-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11061583461116144745}{} 
\hyperlink{11061583461116144745}{\texttt{Base.Threads.nthreads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.nthreads()
\end{lstlisting}

Get the number of threads available to the Julia process. This is the inclusive upper bound on \texttt{threadid()}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/threadingconstructs.jl#L13-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15582842999596899869}{} 
\hyperlink{15582842999596899869}{\texttt{Base.Threads.@threads}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.@threads
\end{lstlisting}

A macro to parallelize a for-loop to run with multiple threads. This spawns \texttt{nthreads()} number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/threadingconstructs.jl#L79-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1140117372581270616}{} 
\hyperlink{1140117372581270616}{\texttt{Base.Threads.Atomic}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.Atomic{T}
\end{lstlisting}

Holds a reference to an object of type \texttt{T}, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.

Only certain {\textquotedbl}simple{\textquotedbl} types can be used atomically, namely the primitive integer and float-point types. These are \texttt{Int8}...\texttt{Int128}, \texttt{UInt8}...\texttt{UInt128}, and \texttt{Float16}...\texttt{Float64}.

New atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.

Atomic objects can be accessed using the \texttt{[]} notation:


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> x[] = 1
1

julia> x[]
1
\end{minted}

Atomic operations use an \texttt{atomic\_} prefix, such as \texttt{atomic\_add!}, \texttt{atomic\_xchg!}, etc.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L35-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6924433775344145551}{} 
\hyperlink{6924433775344145551}{\texttt{Base.Threads.atomic\_cas!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_cas!{T}(x::Atomic{T}, cmp::T, newval::T)
\end{lstlisting}

Atomically compare-and-set \texttt{x}

Atomically compares the value in \texttt{x} with \texttt{cmp}. If equal, write \texttt{newval} to \texttt{x}. Otherwise, leaves \texttt{x} unmodified. Returns the old value in \texttt{x}. By comparing the returned value to \texttt{cmp} (via \texttt{===}) one knows whether \texttt{x} was modified and now holds the new value \texttt{newval}.

For further details, see LLVM{\textquotesingle}s \texttt{cmpxchg} instruction.

This function can be used to implement transactional semantics. Before the transaction, one records the value in \texttt{x}. After the transaction, the new value is stored only if \texttt{x} has not been modified in the mean time.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x, 4, 2);

julia> x
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x, 3, 2);

julia> x
Base.Threads.Atomic{Int64}(2)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L72-L103}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15583989732166753404}{} 
\hyperlink{15583989732166753404}{\texttt{Base.Threads.atomic\_xchg!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_xchg!{T}(x::Atomic{T}, newval::T)
\end{lstlisting}

Atomically exchange the value in \texttt{x}

Atomically exchanges the value in \texttt{x} with \texttt{newval}. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw xchg} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_xchg!(x, 2)
3

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L106-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4669846204248874730}{} 
\hyperlink{4669846204248874730}{\texttt{Base.Threads.atomic\_add!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_add!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically add \texttt{val} to \texttt{x}

Performs \texttt{x[] += val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw add} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_add!(x, 2)
3

julia> x[]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L129-L148}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17642173571521486894}{} 
\hyperlink{17642173571521486894}{\texttt{Base.Threads.atomic\_sub!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_sub!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically subtract \texttt{val} from \texttt{x}

Performs \texttt{x[] -= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw sub} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_sub!(x, 2)
3

julia> x[]
1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L151-L170}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17667453349907943193}{} 
\hyperlink{17667453349907943193}{\texttt{Base.Threads.atomic\_and!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_and!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically bitwise-and \texttt{x} with \texttt{val}

Performs \texttt{x[] \&= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw and} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_and!(x, 2)
3

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L173-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7585036809570134634}{} 
\hyperlink{7585036809570134634}{\texttt{Base.Threads.atomic\_nand!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_nand!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically bitwise-nand (not-and) \texttt{x} with \texttt{val}

Performs \texttt{x[] = {\textasciitilde}(x[] \& val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw nand} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_nand!(x, 2)
3

julia> x[]
-3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L195-L214}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13607043969188851947}{} 
\hyperlink{13607043969188851947}{\texttt{Base.Threads.atomic\_or!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_or!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically bitwise-or \texttt{x} with \texttt{val}

Performs \texttt{x[] |= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw or} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_or!(x, 7)
5

julia> x[]
7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L217-L236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5701145140539338563}{} 
\hyperlink{5701145140539338563}{\texttt{Base.Threads.atomic\_xor!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_xor!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically bitwise-xor (exclusive-or) \texttt{x} with \texttt{val}

Performs \texttt{x[] \$= val} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw xor} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_xor!(x, 7)
5

julia> x[]
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L239-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8102033568033818241}{} 
\hyperlink{8102033568033818241}{\texttt{Base.Threads.atomic\_max!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_max!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically store the maximum of \texttt{x} and \texttt{val} in \texttt{x}

Performs \texttt{x[] = max(x[], val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw max} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_max!(x, 7)
5

julia> x[]
7
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L261-L280}{\texttt{source}}


\end{adjustwidth}
\hypertarget{392667369563982661}{} 
\hyperlink{392667369563982661}{\texttt{Base.Threads.atomic\_min!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_min!{T}(x::Atomic{T}, val::T)
\end{lstlisting}

Atomically store the minimum of \texttt{x} and \texttt{val} in \texttt{x}

Performs \texttt{x[] = min(x[], val)} atomically. Returns the \textbf{old} value.

For further details, see LLVM{\textquotesingle}s \texttt{atomicrmw min} instruction.


\begin{minted}{jlcon}
julia> x = Threads.Atomic{Int}(7)
Base.Threads.Atomic{Int64}(7)

julia> Threads.atomic_min!(x, 5)
7

julia> x[]
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L283-L302}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6451121520734566874}{} 
\hyperlink{6451121520734566874}{\texttt{Base.Threads.atomic\_fence}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Threads.atomic_fence()
\end{lstlisting}

Insert a sequential-consistency memory fence

Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.

This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.

For further details, see LLVM{\textquotesingle}s \texttt{fence} instruction.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/atomics.jl#L464-L478}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4464458332611024554}{}


\section{ccall utilianzdo una threadpool (Experimental)}


\hypertarget{4118169676263419404}{} 
\hyperlink{4118169676263419404}{\texttt{Base.@threadcall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)
\end{lstlisting}

The \texttt{@threadcall} macro is called in the same way as \hyperlink{14245046751182637566}{\texttt{ccall}} but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main \texttt{julia} thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the \texttt{UV\_THREADPOOL\_SIZE} environment variable and restarting the \texttt{julia} process.

Note that the called function should never call back into Julia.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/threadcall.jl#L17-L28}{\texttt{source}}


\end{adjustwidth}

\hypertarget{253970398211302716}{}


\section{Primitivas de Sincronización}


\hypertarget{5123005454870250611}{} 
\hyperlink{5123005454870250611}{\texttt{Base.Threads.AbstractLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
AbstractLock
\end{lstlisting}

Abstract supertype describing types that implement the thread-safe synchronization primitives: \texttt{lock}, \texttt{trylock}, \texttt{unlock}, and \texttt{islocked}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/locks.jl#L13-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3013795445283337804}{} 
\hyperlink{3013795445283337804}{\texttt{Base.lock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lock(the_lock)
\end{lstlisting}

Acquires the lock when it becomes available. If the lock is already locked by a different task/thread, it waits for it to become available.

Each \texttt{lock} must be matched by an \texttt{unlock}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L54-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7477828718297215912}{} 
\hyperlink{7477828718297215912}{\texttt{Base.unlock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unlock(the_lock)
\end{lstlisting}

Releases ownership of the lock.

If this is a recursive lock which has been acquired before, it just decrements an internal counter and returns immediately.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L78-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8566561467185712956}{} 
\hyperlink{8566561467185712956}{\texttt{Base.trylock}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trylock(the_lock) -> Success (Boolean)
\end{lstlisting}

Acquires the lock if it is available, returning \texttt{true} if successful. If the lock is already locked by a different task/thread, returns \texttt{false}.

Each successful \texttt{trylock} must be matched by an \texttt{unlock}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L31-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8304067307715619600}{} 
\hyperlink{8304067307715619600}{\texttt{Base.islocked}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
islocked(the_lock) -> Status (Boolean)
\end{lstlisting}

Check whether the lock is held by any task/thread. This should not be used for synchronization (see instead \texttt{trylock}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L21-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7552896090133941635}{} 
\hyperlink{7552896090133941635}{\texttt{Base.ReentrantLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ReentrantLock()
\end{lstlisting}

Creates a reentrant lock for synchronizing Tasks. The same task can acquire the lock as many times as required. Each \texttt{lock} must be matched with an \texttt{unlock}.

This lock is NOT threadsafe. See \texttt{Threads.Mutex} for a threadsafe lock.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L4-L12}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5247432390476931037}{} 
\hyperlink{5247432390476931037}{\texttt{Base.Threads.Mutex}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mutex()
\end{lstlisting}

These are standard system mutexes for locking critical sections of logic.

On Windows, this is a critical section object, on pthreads, this is a \texttt{pthread\_mutex\_t}.

See also SpinLock for a lighter-weight lock.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/locks.jl#L172-L181}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16883834658935510339}{} 
\hyperlink{16883834658935510339}{\texttt{Base.Threads.SpinLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SpinLock()
\end{lstlisting}

Creates a non-reentrant lock. Recursive use will result in a deadlock. Each \texttt{lock} must be matched with an \texttt{unlock}.

Test-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, perhaps a lock is the wrong way to synchronize.

See also RecursiveSpinLock for a version that permits recursion.

See also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/locks.jl#L35-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13921760733857729411}{} 
\hyperlink{13921760733857729411}{\texttt{Base.Threads.RecursiveSpinLock}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RecursiveSpinLock()
\end{lstlisting}

Creates a reentrant lock. The same thread can acquire the lock as many times as required. Each \texttt{lock} must be matched with an \texttt{unlock}.

See also SpinLock for a slightly faster version.

See also Mutex for a more efficient version on one core or if the lock may be held for a considerable length of time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/locks.jl#L95-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014313312721841609}{} 
\hyperlink{11014313312721841609}{\texttt{Base.Semaphore}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Semaphore(sem_size)
\end{lstlisting}

Creates a counting semaphore that allows at most \texttt{sem\_size} acquires to be in use at any time. Each acquire must be mached with a release.

This construct is NOT threadsafe.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L118-L126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{733284340937899961}{} 
\hyperlink{733284340937899961}{\texttt{Base.acquire}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
acquire(s::Semaphore)
\end{lstlisting}

Wait for one of the \texttt{sem\_size} permits to be available, blocking until one can be acquired.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L134-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8274760602310731764}{} 
\hyperlink{8274760602310731764}{\texttt{Base.release}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
release(s::Semaphore)
\end{lstlisting}

Return one permit to the pool, possibly allowing another task to acquire it and resume execution.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/lock.jl#L151-L157}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11106394229907340888}{}


\section{Interfaz de Administración de Cluster}



Esta interfaz proporciona un mecanismo para lanzar y gestionar \emph{workers} Julia sobre diferentes entornos cluster. Hay dos tipos de administrafores presentes en Base: \texttt{LocalManager}, para lanzar \emph{workers} adicionales sobre el mismo host, y \texttt{SSHManager}, para lanzarlos sobre hosts remotos vía \texttt{ssh}. Para conectar y transportar mensajes entre procesos se usan los sockets TCP/IP. Es posible que los administradores de clusters proporcionen un transporte diferente.


\hypertarget{6239708201491318480}{} 
\hyperlink{6239708201491318480}{\texttt{Base.Distributed.launch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
launch(manager::ClusterManager, params::Dict, launched::Array, launch_ntfy::Condition)
\end{lstlisting}

Implemented by cluster managers. For every Julia worker launched by this function, it should append a \texttt{WorkerConfig} entry to \texttt{launched} and notify \texttt{launch\_ntfy}. The function MUST exit once all workers, requested by \texttt{manager} have been launched. \texttt{params} is a dictionary of all keyword arguments \hyperlink{1448678099847390}{\texttt{addprocs}} was called with.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L342-L349}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7891835938868853982}{} 
\hyperlink{7891835938868853982}{\texttt{Base.Distributed.manage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
manage(manager::ClusterManager, id::Integer, config::WorkerConfig. op::Symbol)
\end{lstlisting}

Implemented by cluster managers. It is called on the master process, during a worker{\textquotesingle}s lifetime, with appropriate \texttt{op} values:

\begin{itemize}
\item with \texttt{:register}/\texttt{:deregister} when a worker is added / removed from the Julia worker pool.


\item with \texttt{:interrupt} when \texttt{interrupt(workers)} is called. The \texttt{ClusterManager} should signal the appropriate worker with an interrupt signal.


\item with \texttt{:finalize} for cleanup purposes.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L352-L362}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17836284879339877528}{} 
\hyperlink{17836284879339877528}{\texttt{Base.kill}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
kill(manager::ClusterManager, pid::Int, config::WorkerConfig)
\end{lstlisting}

Implemented by cluster managers. It is called on the master process, by \hyperlink{10441166839192005456}{\texttt{rmprocs}}. It should cause the remote worker specified by \texttt{pid} to exit. \texttt{kill(manager::ClusterManager.....)} executes a remote \texttt{exit()} on \texttt{pid}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L517-L525}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7081869897278518002}{} 
\hyperlink{7081869897278518002}{\texttt{Base.Distributed.init\_worker}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
init_worker(cookie::AbstractString, manager::ClusterManager=DefaultClusterManager())
\end{lstlisting}

Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument \texttt{--worker} has the effect of initializing a process as a worker using TCP/IP sockets for transport. \texttt{cookie} is a \hyperlink{12027223643055649570}{\texttt{cluster\_cookie}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/cluster.jl#L265-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12692155096250099297}{} 
\hyperlink{12692155096250099297}{\texttt{Base.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
connect(manager::ClusterManager, pid::Int, config::WorkerConfig) -> (instrm::IO, outstrm::IO)
\end{lstlisting}

Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id \texttt{pid}, specified by \texttt{config} and return a pair of \texttt{IO} objects. Messages from \texttt{pid} to current process will be read off \texttt{instrm}, while messages to be sent to \texttt{pid} will be written to \texttt{outstrm}. The custom transport implementation must ensure that messages are delivered and received completely and in order. \texttt{connect(manager::ClusterManager.....)} sets up TCP/IP socket connections in-between workers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/managers.jl#L372-L382}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3520563658360039058}{} 
\hyperlink{3520563658360039058}{\texttt{Base.Distributed.process\_messages}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base.process_messages(r_stream::IO, w_stream::IO, incoming::Bool=true)
\end{lstlisting}

Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two \texttt{IO} objects, one for incoming messages and the other for messages addressed to the remote worker. If \texttt{incoming} is \texttt{true}, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.

See also \hyperlink{12027223643055649570}{\texttt{cluster\_cookie}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/distributed/process_messages.jl#L121-L134}{\texttt{source}}


\end{adjustwidth}

\hypertarget{2892037563719910727}{}


\chapter{Álgebra Lineal}



\hypertarget{13065370563019154145}{}


\section{Funciones Estándar}



Las funciones de álgebra lineal en Julia están ampliamente implementadas llamando a funciones de \href{http://www.netlib.org/lapack/}{LAPACK}. Las factorizaciones \emph{sparse} llaman a funciones de \href{http://faculty.cse.tamu.edu/davis/suitesparse.html}{SuiteSparse}


\hypertarget{8926068912300694608}{} 
\hyperlink{8926068912300694608}{\texttt{Base.:*}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
*(x, y...)
\end{lstlisting}

Multiplication operator. \texttt{x*y*z*...} calls this function with all arguments, i.e. \texttt{*(x, y, z, ...)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1917-L1923}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11203908042914658075}{} 
\hyperlink{11203908042914658075}{\texttt{Base.:{\textbackslash}}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
\(x, y)
\end{lstlisting}

Left division operator: multiplication of \texttt{y} by the inverse of \texttt{x} on the left. Gives floating-point results for integer arguments.


\begin{minted}{jlcon}
julia> 3 \ 6
2.0

julia> inv(3) * 6
2.0

julia> A = [1 2; 3 4]; x = [5, 6];

julia> A \ x
2-element Array{Float64,1}:
 -4.0
  4.5

julia> inv(A) * x
2-element Array{Float64,1}:
 -4.0
  4.5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L431-L456}{\texttt{source}}


\end{adjustwidth}
\hypertarget{697823138745516979}{} 
\hyperlink{697823138745516979}{\texttt{Base.LinAlg.dot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dot(n, X, incx, Y, incy)
\end{lstlisting}

Dot product of two vectors consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{Y} with stride \texttt{incy}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> dot(10, ones(10), 1, ones(20), 2)
10.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L213-L224}{\texttt{source}}


\end{adjustwidth}
\hypertarget{929868199641061171}{} 
\hyperlink{929868199641061171}{\texttt{Base.LinAlg.vecdot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
vecdot(x, y)
\end{lstlisting}

For any iterable containers \texttt{x} and \texttt{y} (including arrays of any dimension) of numbers (or any element type for which \texttt{dot} is defined), compute the Euclidean dot product (the sum of \texttt{dot(x[i],y[i])}) as if they were vectors.

\textbf{Examples}


\begin{minted}{jlcon}
julia> vecdot(1:5, 2:6)
70

julia> x = fill(2., (5,5));

julia> y = fill(3., (5,5));

julia> vecdot(x, y)
150.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L624-L643}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15390434108937215869}{} 
\hyperlink{15390434108937215869}{\texttt{Base.LinAlg.cross}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cross(x, y)
×(x,y)
\end{lstlisting}

Compute the cross product of two 3-vectors.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [0;1;0]
3-element Array{Int64,1}:
 0
 1
 0

julia> b = [0;0;1]
3-element Array{Int64,1}:
 0
 0
 1

julia> cross(a,b)
3-element Array{Int64,1}:
 1
 0
 0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L88-L115}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10363263068585650380}{} 
\hyperlink{10363263068585650380}{\texttt{Base.LinAlg.factorize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
factorize(A)
\end{lstlisting}

Compute a convenient factorization of \texttt{A}, based upon the type of the input matrix. \texttt{factorize} checks \texttt{A} to see if it is symmetric/triangular/etc. if \texttt{A} is passed as a generic matrix. \texttt{factorize} checks every element of \texttt{A} to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: \texttt{A=factorize(A); x=A{\textbackslash}b; y=A{\textbackslash}C}.


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Properties of \texttt{A} & type of factorization \\
\hline
Positive-definite & Cholesky (see \hyperlink{12805335348758675309}{\texttt{cholfact}}) \\
\hline
Dense Symmetric/Hermitian & Bunch-Kaufman (see \hyperlink{16689081380067534909}{\texttt{bkfact}}) \\
\hline
Sparse Symmetric/Hermitian & LDLt (see \hyperlink{17696382973019086267}{\texttt{ldltfact}}) \\
\hline
Triangular & Triangular \\
\hline
Diagonal & Diagonal \\
\hline
Bidiagonal & Bidiagonal \\
\hline
Tridiagonal & LU (see \hyperlink{2935598995290090141}{\texttt{lufact}}) \\
\hline
Symmetric real tridiagonal & LDLt (see \hyperlink{17696382973019086267}{\texttt{ldltfact}}) \\
\hline
General square & LU (see \hyperlink{2935598995290090141}{\texttt{lufact}}) \\
\hline
General non-square & QR (see \hyperlink{16170416021894488810}{\texttt{qrfact}}) \\
\hline
\end{tabulary}

\end{table}

If \texttt{factorize} is called on a Hermitian positive-definite matrix, for instance, then \texttt{factorize} will return a Cholesky factorization.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = Array(Bidiagonal(ones(5, 5), true))
5×5 Array{Float64,2}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia> factorize(A) # factorize will check to see that A is already factorized
5×5 Bidiagonal{Float64}:
 1.0  1.0   ⋅    ⋅    ⋅
  ⋅   1.0  1.0   ⋅    ⋅
  ⋅    ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅   1.0  1.0
  ⋅    ⋅    ⋅    ⋅   1.0
\end{minted}

This returns a \texttt{5×5 Bidiagonal\{Float64\}}, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for \texttt{Bidiagonal} types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L664-L711}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14932727513503167130}{} 
\hyperlink{14932727513503167130}{\texttt{Base.LinAlg.Diagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Diagonal(A::AbstractMatrix)
\end{lstlisting}

Constructs a matrix from the diagonal of \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> Diagonal(A)
3×3 Diagonal{Int64}:
 1  ⋅  ⋅
 ⋅  5  ⋅
 ⋅  ⋅  9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/diagonal.jl#L8-L28}{\texttt{source}}



\begin{lstlisting}
Diagonal(V::AbstractVector)
\end{lstlisting}

Constructs a matrix with \texttt{V} as its diagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> V = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia> Diagonal(V)
2×2 Diagonal{Int64}:
 1  ⋅
 ⋅  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/diagonal.jl#L30-L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3712437588055447942}{} 
\hyperlink{3712437588055447942}{\texttt{Base.LinAlg.Bidiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Bidiagonal(dv, ev, isupper::Bool)
\end{lstlisting}

Constructs an upper (\texttt{isupper=true}) or lower (\texttt{isupper=false}) bidiagonal matrix using the given diagonal (\texttt{dv}) and off-diagonal (\texttt{ev}) vectors.  The result is of type \texttt{Bidiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). \texttt{ev}{\textquotesingle}s length must be one less than the length of \texttt{dv}.

\textbf{Example}


\begin{minted}{jlcon}
julia> dv = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7; 8; 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> Bu = Bidiagonal(dv, ev, true) # ev is on the first superdiagonal
4×4 Bidiagonal{Int64}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia> Bl = Bidiagonal(dv, ev, false) # ev is on the first subdiagonal
4×4 Bidiagonal{Int64}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bidiag.jl#L15-L54}{\texttt{source}}



\begin{lstlisting}
Bidiagonal(dv, ev, uplo::Char)
\end{lstlisting}

Constructs an upper (\texttt{uplo={\textquotesingle}U{\textquotesingle}}) or lower (\texttt{uplo={\textquotesingle}L{\textquotesingle}}) bidiagonal matrix using the given diagonal (\texttt{dv}) and off-diagonal (\texttt{ev}) vectors.  The result is of type \texttt{Bidiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). \texttt{ev}{\textquotesingle}s length must be one less than the length of \texttt{dv}.

\textbf{Example}


\begin{minted}{jlcon}
julia> dv = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7; 8; 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> Bu = Bidiagonal(dv, ev, 'U') #e is on the first superdiagonal
4×4 Bidiagonal{Int64}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia> Bl = Bidiagonal(dv, ev, 'L') #e is on the first subdiagonal
4×4 Bidiagonal{Int64}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bidiag.jl#L58-L97}{\texttt{source}}



\begin{lstlisting}
Bidiagonal(A, isupper::Bool)
\end{lstlisting}

Construct a \texttt{Bidiagonal} matrix from the main diagonal of \texttt{A} and its first super- (if \texttt{isupper=true}) or sub-diagonal (if \texttt{isupper=false}).

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4×4 Array{Int64,2}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia> Bidiagonal(A, true) #contains the main diagonal and first superdiagonal of A
4×4 Bidiagonal{Int64}:
 1  1  ⋅  ⋅
 ⋅  2  2  ⋅
 ⋅  ⋅  3  3
 ⋅  ⋅  ⋅  4

julia> Bidiagonal(A, false) #contains the main diagonal and first subdiagonal of A
4×4 Bidiagonal{Int64}:
 1  ⋅  ⋅  ⋅
 2  2  ⋅  ⋅
 ⋅  3  3  ⋅
 ⋅  ⋅  4  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bidiag.jl#L114-L144}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14121197223449931750}{} 
\hyperlink{14121197223449931750}{\texttt{Base.LinAlg.SymTridiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
SymTridiagonal(dv, ev)
\end{lstlisting}

Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, respectively. The result is of type \texttt{SymTridiagonal} and provides efficient specialized eigensolvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short).

\textbf{Example}


\begin{minted}{jlcon}
julia> dv = [1; 2; 3; 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia> ev = [7; 8; 9]
3-element Array{Int64,1}:
 7
 8
 9

julia> SymTridiagonal(dv, ev)
4×4 SymTridiagonal{Int64}:
 1  7  ⋅  ⋅
 7  2  8  ⋅
 ⋅  8  3  9
 ⋅  ⋅  9  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/tridiag.jl#L17-L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10627817666628508033}{} 
\hyperlink{10627817666628508033}{\texttt{Base.LinAlg.Tridiagonal}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Tridiagonal(dl, d, du)
\end{lstlisting}

Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively.  The result is of type \texttt{Tridiagonal} and provides efficient specialized linear solvers, but may be converted into a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}} (or \texttt{Array(\_)} for short). The lengths of \texttt{dl} and \texttt{du} must be one less than the length of \texttt{d}.

\textbf{Example}


\begin{minted}{jlcon}
julia> dl = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia> du = [4; 5; 6]
3-element Array{Int64,1}:
 4
 5
 6

julia> d = [7; 8; 9; 0]
4-element Array{Int64,1}:
 7
 8
 9
 0

julia> Tridiagonal(dl, d, du)
4×4 Tridiagonal{Int64}:
 7  4  ⋅  ⋅
 1  8  5  ⋅
 ⋅  2  9  6
 ⋅  ⋅  3  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/tridiag.jl#L395-L433}{\texttt{source}}



\begin{lstlisting}
Tridiagonal(A)
\end{lstlisting}

returns a \texttt{Tridiagonal} array based on (abstract) matrix \texttt{A}, using its first lower diagonal, main diagonal, and first upper diagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4×4 Array{Int64,2}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia> Tridiagonal(A)
4×4 Tridiagonal{Int64}:
 1  2  ⋅  ⋅
 1  2  3  ⋅
 ⋅  2  3  4
 ⋅  ⋅  3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/tridiag.jl#L449-L472}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10155539409143226179}{} 
\hyperlink{10155539409143226179}{\texttt{Base.LinAlg.Symmetric}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Symmetric(A, uplo=:U)
\end{lstlisting}

Construct a \texttt{Symmetric} view of the upper (if \texttt{uplo = :U}) or lower (if \texttt{uplo = :L}) triangle of the matrix \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]
5×5 Array{Int64,2}:
 1  0  2  0  3
 0  4  0  5  0
 6  0  7  0  8
 0  9  0  1  0
 2  0  3  0  4

julia> Supper = Symmetric(A)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  2  0  3
 0  4  0  5  0
 2  0  7  0  8
 0  5  0  1  0
 3  0  8  0  4

julia> Slower = Symmetric(A, :L)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  6  0  2
 0  4  0  9  0
 6  0  7  0  3
 0  9  0  1  0
 2  0  3  0  4
\end{minted}

Note that \texttt{Supper} will not be equal to \texttt{Slower} unless \texttt{A} is itself symmetric (e.g. if \texttt{A == A.{\textquotesingle}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L8-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11943711269274284831}{} 
\hyperlink{11943711269274284831}{\texttt{Base.LinAlg.Hermitian}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Hermitian(A, uplo=:U)
\end{lstlisting}

Construct a \texttt{Hermitian} view of the upper (if \texttt{uplo = :U}) or lower (if \texttt{uplo = :L}) triangle of the matrix \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia> Hupper = Hermitian(A)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  2+2im  0+0im  3-3im
 0+0im  4+0im  0+0im  5+0im  0+0im
 2-2im  0+0im  7+0im  0+0im  8+8im
 0+0im  5+0im  0+0im  1+0im  0+0im
 3+3im  0+0im  8-8im  0+0im  4+0im

julia> Hlower = Hermitian(A, :L)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  6+6im  0+0im  2-2im
 0+0im  4+0im  0+0im  9+0im  0+0im
 6-6im  0+0im  7+0im  0+0im  3+3im
 0+0im  9+0im  0+0im  1+0im  0+0im
 2+2im  0+0im  3-3im  0+0im  4+0im
\end{minted}

Note that \texttt{Hupper} will not be equal to \texttt{Hlower} unless \texttt{A} is itself Hermitian (e.g. if \texttt{A == A{\textquotesingle}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L58-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17017578003271911360}{} 
\hyperlink{17017578003271911360}{\texttt{Base.LinAlg.LowerTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LowerTriangular(A::AbstractMatrix)
\end{lstlisting}

Construct a \texttt{LowerTriangular} view of the the matrix \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> LowerTriangular(A)
3×3 LowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  5.0   ⋅
 7.0  8.0  9.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/triangular.jl#L53-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1757421215459158076}{} 
\hyperlink{1757421215459158076}{\texttt{Base.LinAlg.UpperTriangular}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UpperTriangular(A::AbstractMatrix)
\end{lstlisting}

Construct an \texttt{UpperTriangular} view of the the matrix \texttt{A}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia> UpperTriangular(A)
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   5.0  6.0
  ⋅    ⋅   9.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/triangular.jl#L75-L95}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5641050131194212876}{} 
\hyperlink{5641050131194212876}{\texttt{Base.LinAlg.lu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lu(A, pivot=Val{true}) -> L, U, p
\end{lstlisting}

Compute the LU factorization of \texttt{A}, such that \texttt{A[p,:] = L*U}. By default, pivoting is used. This can be overridden by passing \texttt{Val\{false\}} for the second argument.

See also \hyperlink{2935598995290090141}{\texttt{lufact}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4. 3.; 6. 3.]
2×2 Array{Float64,2}:
 4.0  3.0
 6.0  3.0

julia> L, U, p = lu(A)
([1.0 0.0; 0.666667 1.0], [6.0 3.0; 0.0 1.0], [2, 1])

julia> A[p, :] == L * U
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lu.jl#L165-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2935598995290090141}{} 
\hyperlink{2935598995290090141}{\texttt{Base.LinAlg.lufact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lufact(A [,pivot=Val{true}]) -> F::LU
\end{lstlisting}

Compute the LU factorization of \texttt{A}.

In most cases, if \texttt{A} is a subtype \texttt{S} of \texttt{AbstractMatrix\{T\}} with an element type \texttt{T} supporting \texttt{+}, \texttt{-}, \texttt{*} and \texttt{/}, the return type is \texttt{LU\{T,S\{T\}\}}. If pivoting is chosen (default) the element type should also support \texttt{abs} and \texttt{<}.

The individual components of the factorization \texttt{F} can be accessed by indexing:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Component & Description \\
\hline
\texttt{F[:L]} & \texttt{L} (lower triangular) part of \texttt{LU} \\
\hline
\texttt{F[:U]} & \texttt{U} (upper triangular) part of \texttt{LU} \\
\hline
\texttt{F[:p]} & (right) permutation \texttt{Vector} \\
\hline
\texttt{F[:P]} & (right) permutation \texttt{Matrix} \\
\hline
\end{tabulary}

\end{table}

The relationship between \texttt{F} and \texttt{A} is

\texttt{F[:L]*F[:U] == A[F[:p], :]}

\texttt{F} further supports the following functions:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Supported function & \texttt{LU} & \texttt{LU\{T,Tridiagonal\{T\}\}} \\
\hline
\hyperlink{4103478871488785445}{\texttt{/}} & ✓ &  \\
\hline
\hyperlink{11203908042914658075}{\texttt{{\textbackslash}}} & ✓ & ✓ \\
\hline
\hyperlink{3226902477371958750}{\texttt{cond}} & ✓ &  \\
\hline
\hyperlink{9013378623280719296}{\texttt{inv}} & ✓ & ✓ \\
\hline
\hyperlink{1300265042345987014}{\texttt{det}} & ✓ & ✓ \\
\hline
\hyperlink{6649271058375699908}{\texttt{logdet}} & ✓ & ✓ \\
\hline
\hyperlink{17670285292397317614}{\texttt{logabsdet}} & ✓ & ✓ \\
\hline
\hyperlink{17888996102305087038}{\texttt{size}} & ✓ & ✓ \\
\hline
\end{tabulary}

\end{table}

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia> F = lufact(A)
Base.LinAlg.LU{Float64,Array{Float64,2}} with factors L and U:
[1.0 0.0; 1.5 1.0]
[4.0 3.0; 0.0 -1.5]

julia> F[:L] * F[:U] == A[F[:p], :]
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lu.jl#L86-L138}{\texttt{source}}



\begin{lstlisting}
lufact(A::SparseMatrixCSC) -> F::UmfpackLU
\end{lstlisting}

Compute the LU factorization of a sparse matrix \texttt{A}.

For sparse \texttt{A} with real or complex element type, the return type of \texttt{F} is \texttt{UmfpackLU\{Tv, Ti\}}, with \texttt{Tv} = \hyperlink{5027751419500983000}{\texttt{Float64}} or \texttt{Complex128} respectively and \texttt{Ti} is an integer type (\hyperlink{10103694114785108551}{\texttt{Int32}} or \hyperlink{7720564657383125058}{\texttt{Int64}}).

The individual components of the factorization \texttt{F} can be accessed by indexing:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Component & Description \\
\hline
\texttt{F[:L]} & \texttt{L} (lower triangular) part of \texttt{LU} \\
\hline
\texttt{F[:U]} & \texttt{U} (upper triangular) part of \texttt{LU} \\
\hline
\texttt{F[:p]} & right permutation \texttt{Vector} \\
\hline
\texttt{F[:q]} & left permutation \texttt{Vector} \\
\hline
\texttt{F[:Rs]} & \texttt{Vector} of scaling factors \\
\hline
\texttt{F[:(:)]} & \texttt{(L,U,p,q,Rs)} components \\
\hline
\end{tabulary}

\end{table}

The relation between \texttt{F} and \texttt{A} is

\texttt{F[:L]*F[:U] == (F[:Rs] .* A)[F[:p], F[:q]]}

\texttt{F} further supports the following functions:

\begin{itemize}
\item \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}


\item \hyperlink{3226902477371958750}{\texttt{cond}}


\item \hyperlink{1300265042345987014}{\texttt{det}}

\end{itemize}
\begin{quote}
\textbf{Note}

\texttt{lufact(A::SparseMatrixCSC)} uses the UMFPACK library that is part of SuiteSparse. As this library only supports sparse matrices with \hyperlink{5027751419500983000}{\texttt{Float64}} or \texttt{Complex128} elements, \texttt{lufact} converts \texttt{A} into a copy that is of type \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/umfpack.jl#L104-L139}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9520029296647984269}{} 
\hyperlink{9520029296647984269}{\texttt{Base.LinAlg.lufact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lufact!(A, pivot=Val{true}) -> LU
\end{lstlisting}

\texttt{lufact!} is the same as \hyperlink{2935598995290090141}{\texttt{lufact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lu.jl#L23-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10590134875878680645}{} 
\hyperlink{10590134875878680645}{\texttt{Base.LinAlg.chol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chol(A) -> U
\end{lstlisting}

Compute the Cholesky factorization of a positive definite matrix \texttt{A} and return the \hyperlink{1757421215459158076}{\texttt{UpperTriangular}} matrix \texttt{U} such that \texttt{A = U{\textquotesingle}U}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 2.; 2. 50.]
2×2 Array{Float64,2}:
 1.0   2.0
 2.0  50.0

julia> U = chol(A)
2×2 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0
  ⋅   6.78233

julia> U'U
2×2 Array{Float64,2}:
 1.0   2.0
 2.0  50.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L159-L183}{\texttt{source}}



\begin{lstlisting}
chol(x::Number) -> y
\end{lstlisting}

Compute the square root of a non-negative number \texttt{x}.

\textbf{Example}


\begin{minted}{jlcon}
julia> chol(16)
4.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L190-L201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12805335348758675309}{} 
\hyperlink{12805335348758675309}{\texttt{Base.LinAlg.cholfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cholfact(A, [uplo::Symbol,] Val{false}) -> Cholesky
\end{lstlisting}

Compute the Cholesky factorization of a dense symmetric positive definite matrix \texttt{A} and return a \texttt{Cholesky} factorization. The matrix \texttt{A} can either be a \hyperlink{10155539409143226179}{\texttt{Symmetric}} or \hyperlink{11943711269274284831}{\texttt{Hermitian}} \texttt{StridedMatrix} or a \emph{perfectly} symmetric or Hermitian \texttt{StridedMatrix}. In the latter case, the optional argument \texttt{uplo} may be \texttt{:L} for using the lower part or \texttt{:U} for the upper part of \texttt{A}. The default is to use \texttt{:U}. The triangular Cholesky factor can be obtained from the factorization \texttt{F} with: \texttt{F[:L]} and \texttt{F[:U]}. The following functions are available for \texttt{Cholesky} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}, \hyperlink{9013378623280719296}{\texttt{inv}}, and \hyperlink{1300265042345987014}{\texttt{det}}. A \texttt{PosDefException} exception is thrown in case the matrix is not positive definite.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia> C = cholfact(A)
Base.LinAlg.Cholesky{Float64,Array{Float64,2}} with factor:
[2.0 6.0 -8.0; 0.0 1.0 5.0; 0.0 0.0 3.0]

julia> C[:U]
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia> C[:L]
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia> C[:L] * C[:U] == A
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L297-L338}{\texttt{source}}



\begin{lstlisting}
cholfact(A, [uplo::Symbol,] Val{true}; tol = 0.0) -> CholeskyPivoted
\end{lstlisting}

Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix \texttt{A} and return a \texttt{CholeskyPivoted} factorization. The matrix \texttt{A} can either be a \hyperlink{10155539409143226179}{\texttt{Symmetric}} or \hyperlink{11943711269274284831}{\texttt{Hermitian}} \texttt{StridedMatrix} or a \emph{perfectly} symmetric or Hermitian \texttt{StridedMatrix}. In the latter case, the optional argument \texttt{uplo} may be \texttt{:L} for using the lower part or \texttt{:U} for the upper part of \texttt{A}. The default is to use \texttt{:U}. The triangular Cholesky factor can be obtained from the factorization \texttt{F} with: \texttt{F[:L]} and \texttt{F[:U]}. The following functions are available for \texttt{PivotedCholesky} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}, \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{2947138922560424828}{\texttt{rank}}. The argument \texttt{tol} determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L363-L376}{\texttt{source}}



\begin{lstlisting}
cholfact(A; shift = 0.0, perm = Int[]) -> CHOLMOD.Factor
\end{lstlisting}

Compute the Cholesky factorization of a sparse positive definite matrix \texttt{A}. \texttt{A} must be a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} or a \hyperlink{10155539409143226179}{\texttt{Symmetric}}/\hyperlink{11943711269274284831}{\texttt{Hermitian}} view of a \texttt{SparseMatrixCSC}. Note that even if \texttt{A} doesn{\textquotesingle}t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. \texttt{F = cholfact(A)} is most frequently used to solve systems of equations with \texttt{F{\textbackslash}b}, but also the methods \hyperlink{6899395651203530298}{\texttt{diag}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{6649271058375699908}{\texttt{logdet}} are defined for \texttt{F}. You can also extract individual factors from \texttt{F}, using \texttt{F[:L]}. However, since pivoting is on by default, the factorization is internally represented as \texttt{A == P{\textquotesingle}*L*L{\textquotesingle}*P} with a permutation matrix \texttt{P}; using just \texttt{L} without accounting for \texttt{P} will give incorrect answers. To include the effects of permutation, it{\textquotesingle}s typically preferable to extract {\textquotedbl}combined{\textquotedbl} factors like \texttt{PtL = F[:PtL]} (the equivalent of \texttt{P{\textquotesingle}*L}) and \texttt{LtP = F[:UP]} (the equivalent of \texttt{L{\textquotesingle}*P}).

Setting the optional \texttt{shift} keyword argument computes the factorization of \texttt{A+shift*I} instead of \texttt{A}. If the \texttt{perm} argument is nonempty, it should be a permutation of \texttt{1:size(A,1)} giving the ordering to use (instead of CHOLMOD{\textquotesingle}s default AMD ordering).

\begin{quote}
\textbf{Note}

This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

Many other functions from CHOLMOD are wrapped but not exported from the \texttt{Base.SparseArrays.CHOLMOD} module.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/cholmod.jl#L1405-L1437}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10240500374693163240}{} 
\hyperlink{10240500374693163240}{\texttt{Base.LinAlg.cholfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cholfact!(A, [uplo::Symbol,] Val{false}) -> Cholesky
\end{lstlisting}

The same as \hyperlink{12805335348758675309}{\texttt{cholfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia> cholfact!(A)
ERROR: InexactError()
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L225-L244}{\texttt{source}}



\begin{lstlisting}
cholfact!(A, [uplo::Symbol,] Val{true}; tol = 0.0) -> CholeskyPivoted
\end{lstlisting}

The same as \hyperlink{12805335348758675309}{\texttt{cholfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L275-L282}{\texttt{source}}



\begin{lstlisting}
cholfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor
\end{lstlisting}

Compute the Cholesky (\(LL'\)) factorization of \texttt{A}, reusing the symbolic factorization \texttt{F}. \texttt{A} must be a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} or a \hyperlink{10155539409143226179}{\texttt{Symmetric}}/ \hyperlink{11943711269274284831}{\texttt{Hermitian}} view of a \texttt{SparseMatrixCSC}. Note that even if \texttt{A} doesn{\textquotesingle}t have the type tag, it must still be symmetric or Hermitian.

See also \hyperlink{12805335348758675309}{\texttt{cholfact}}.

\begin{quote}
\textbf{Note}

This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/cholmod.jl#L1364-L1379}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3937825551363289459}{} 
\hyperlink{3937825551363289459}{\texttt{Base.LinAlg.lowrankupdate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowrankupdate(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{lstlisting}

Update a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C[:U]{\textquotesingle}C[:U]} then \texttt{CC = cholfact(C[:U]{\textquotesingle}C[:U] + v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L653-L659}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13865582258179933244}{} 
\hyperlink{13865582258179933244}{\texttt{Base.LinAlg.lowrankdowndate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowrankdowndate(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{lstlisting}

Downdate a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C[:U]{\textquotesingle}C[:U]} then \texttt{CC = cholfact(C[:U]{\textquotesingle}C[:U] - v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L662-L668}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11734178108783656905}{} 
\hyperlink{11734178108783656905}{\texttt{Base.LinAlg.lowrankupdate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowrankupdate!(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{lstlisting}

Update a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C[:U]{\textquotesingle}C[:U]} then \texttt{CC = cholfact(C[:U]{\textquotesingle}C[:U] + v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations. The input factorization \texttt{C} is updated in place such that on exit \texttt{C == CC}. The vector \texttt{v} is destroyed during the computation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L554-L561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1035472772477102672}{} 
\hyperlink{1035472772477102672}{\texttt{Base.LinAlg.lowrankdowndate!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lowrankdowndate!(C::Cholesky, v::StridedVector) -> CC::Cholesky
\end{lstlisting}

Downdate a Cholesky factorization \texttt{C} with the vector \texttt{v}. If \texttt{A = C[:U]{\textquotesingle}C[:U]} then \texttt{CC = cholfact(C[:U]{\textquotesingle}C[:U] - v*v{\textquotesingle})} but the computation of \texttt{CC} only uses \texttt{O(n{\textasciicircum}2)} operations. The input factorization \texttt{C} is updated in place such that on exit \texttt{C == CC}. The vector \texttt{v} is destroyed during the computation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/cholesky.jl#L600-L607}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17696382973019086267}{} 
\hyperlink{17696382973019086267}{\texttt{Base.LinAlg.ldltfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ldltfact(S::SymTridiagonal) -> LDLt
\end{lstlisting}

Compute an \texttt{LDLt} factorization of a real symmetric tridiagonal matrix such that \texttt{A = L*Diagonal(d)*L{\textquotesingle}} where \texttt{L} is a unit lower triangular matrix and \texttt{d} is a vector. The main use of an \texttt{LDLt} factorization \texttt{F = ldltfact(A)} is to solve the linear system of equations \texttt{Ax = b} with \texttt{F{\textbackslash}b}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/ldlt.jl#L35-L41}{\texttt{source}}



\begin{lstlisting}
ldltfact(A; shift = 0.0, perm=Int[]) -> CHOLMOD.Factor
\end{lstlisting}

Compute the \(LDL'\) factorization of a sparse matrix \texttt{A}. \texttt{A} must be a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} or a \hyperlink{10155539409143226179}{\texttt{Symmetric}}/\hyperlink{11943711269274284831}{\texttt{Hermitian}} view of a \texttt{SparseMatrixCSC}. Note that even if \texttt{A} doesn{\textquotesingle}t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. \texttt{F = ldltfact(A)} is most frequently used to solve systems of equations \texttt{A*x = b} with \texttt{F{\textbackslash}b}. The returned factorization object \texttt{F} also supports the methods \hyperlink{6899395651203530298}{\texttt{diag}}, \hyperlink{1300265042345987014}{\texttt{det}}, \hyperlink{6649271058375699908}{\texttt{logdet}}, and \hyperlink{9013378623280719296}{\texttt{inv}}. You can extract individual factors from \texttt{F} using \texttt{F[:L]}. However, since pivoting is on by default, the factorization is internally represented as \texttt{A == P{\textquotesingle}*L*D*L{\textquotesingle}*P} with a permutation matrix \texttt{P}; using just \texttt{L} without accounting for \texttt{P} will give incorrect answers. To include the effects of permutation, it is typically preferable to extract {\textquotedbl}combined{\textquotedbl} factors like \texttt{PtL = F[:PtL]} (the equivalent of \texttt{P{\textquotesingle}*L}) and \texttt{LtP = F[:UP]} (the equivalent of \texttt{L{\textquotesingle}*P}). The complete list of supported factors is \texttt{:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP}.

Setting the optional \texttt{shift} keyword argument computes the factorization of \texttt{A+shift*I} instead of \texttt{A}. If the \texttt{perm} argument is nonempty, it should be a permutation of \texttt{1:size(A,1)} giving the ordering to use (instead of CHOLMOD{\textquotesingle}s default AMD ordering).

\begin{quote}
\textbf{Note}

This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

Many other functions from CHOLMOD are wrapped but not exported from the \texttt{Base.SparseArrays.CHOLMOD} module.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/cholmod.jl#L1504-L1537}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6125312741908639126}{} 
\hyperlink{6125312741908639126}{\texttt{Base.LinAlg.ldltfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ldltfact!(S::SymTridiagonal) -> LDLt
\end{lstlisting}

Same as \hyperlink{17696382973019086267}{\texttt{ldltfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/ldlt.jl#L19-L23}{\texttt{source}}



\begin{lstlisting}
ldltfact!(F::Factor, A; shift = 0.0) -> CHOLMOD.Factor
\end{lstlisting}

Compute the \(LDL'\) factorization of \texttt{A}, reusing the symbolic factorization \texttt{F}. \texttt{A} must be a \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}} or a \hyperlink{10155539409143226179}{\texttt{Symmetric}}/\hyperlink{11943711269274284831}{\texttt{Hermitian}} view of a \texttt{SparseMatrixCSC}. Note that even if \texttt{A} doesn{\textquotesingle}t have the type tag, it must still be symmetric or Hermitian.

See also \hyperlink{17696382973019086267}{\texttt{ldltfact}}.

\begin{quote}
\textbf{Note}

This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to \texttt{SparseMatrixCSC\{Float64\}} or \texttt{SparseMatrixCSC\{Complex128\}} as appropriate.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/cholmod.jl#L1456-L1471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{557719280469347572}{} 
\hyperlink{557719280469347572}{\texttt{Base.LinAlg.qr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
qr(A, pivot=Val{false}; thin::Bool=true) -> Q, R, [p]
\end{lstlisting}

Compute the (pivoted) QR factorization of \texttt{A} such that either \texttt{A = Q*R} or \texttt{A[:,p] = Q*R}. Also see \hyperlink{16170416021894488810}{\texttt{qrfact}}. The default is to compute a thin factorization. Note that \texttt{R} is not extended with zeros when the full \texttt{Q} is requested.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L285-L292}{\texttt{source}}



\begin{lstlisting}
qr(v::AbstractVector) -> w, r
\end{lstlisting}

Computes the polar decomposition of a vector. Returns \texttt{w}, a unit vector in the direction of \texttt{v}, and \texttt{r}, the norm of \texttt{v}.

See also \hyperlink{10075112191110723412}{\texttt{normalize}}, \hyperlink{5105121074825158846}{\texttt{normalize!}}, and \hyperlink{18372997142167679564}{\texttt{LinAlg.qr!}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia> w, r = qr(v)
([0.447214, 0.894427], 2.23606797749979)

julia> w*r == v
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L304-L328}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18372997142167679564}{} 
\hyperlink{18372997142167679564}{\texttt{Base.LinAlg.qr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LinAlg.qr!(v::AbstractVector) -> w, r
\end{lstlisting}

Computes the polar decomposition of a vector. Instead of returning a new vector as \texttt{qr(v::AbstractVector)}, this function mutates the input vector \texttt{v} in place. Returns \texttt{w}, a unit vector in the direction of \texttt{v} (this is a mutation of \texttt{v}), and \texttt{r}, the norm of \texttt{v}.

See also \hyperlink{10075112191110723412}{\texttt{normalize}}, \hyperlink{5105121074825158846}{\texttt{normalize!}}, and \hyperlink{557719280469347572}{\texttt{qr}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L340-L350}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16170416021894488810}{} 
\hyperlink{16170416021894488810}{\texttt{Base.LinAlg.qrfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
qrfact(A, pivot=Val{false}) -> F
\end{lstlisting}

Compute the QR factorization of the matrix \texttt{A}: an orthogonal (or unitary if \texttt{A} is complex-valued) matrix \texttt{Q}, and an upper triangular matrix \texttt{R} such that

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
The returned object \texttt{F} stores the factorization in a packed format:

\begin{itemize}
\item if \texttt{pivot == Val\{true\}} then \texttt{F} is a \hyperlink{7934860800976993126}{\texttt{QRPivoted}} object,


\item otherwise if the element type of \texttt{A} is a BLAS type (\hyperlink{8101639384272933082}{\texttt{Float32}}, \hyperlink{5027751419500983000}{\texttt{Float64}}, \texttt{Complex64} or \texttt{Complex128}), then \texttt{F} is a \hyperlink{18189258812560098941}{\texttt{QRCompactWY}} object,


\item otherwise \texttt{F} is a \hyperlink{6169365281542139873}{\texttt{QR}} object.

\end{itemize}
The individual components of the factorization \texttt{F} can be accessed by indexing with a symbol:

\begin{itemize}
\item \texttt{F[:Q]}: the orthogonal/unitary matrix \texttt{Q}


\item \texttt{F[:R]}: the upper triangular matrix \texttt{R}


\item \texttt{F[:p]}: the permutation vector of the pivot (\hyperlink{7934860800976993126}{\texttt{QRPivoted}} only)


\item \texttt{F[:P]}: the permutation matrix of the pivot (\hyperlink{7934860800976993126}{\texttt{QRPivoted}} only)

\end{itemize}
The following functions are available for the \texttt{QR} objects: \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{17888996102305087038}{\texttt{size}}, and \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}. When \texttt{A} is rectangular, \texttt{{\textbackslash}} will return a least squares solution and if the solution is not unique, the one with smallest norm is returned.

Multiplication with respect to either thin or full \texttt{Q} is allowed, i.e. both \texttt{F[:Q]*F[:R]} and \texttt{F[:Q]*A} are supported. A \texttt{Q} matrix can be converted into a regular matrix with \hyperlink{6442668105237896007}{\texttt{full}} which has a named argument \texttt{thin}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia> F = qrfact(A)
Base.LinAlg.QRCompactWY{Float64,Array{Float64,2}} with factors Q and R:
[-0.6 0.0 0.8; -0.8 0.0 -0.6; 0.0 -1.0 0.0]
[-5.0 10.0; 0.0 -1.0]

julia> F[:Q] * F[:R] == A
true
\end{minted}

\begin{quote}
\textbf{Note}

\texttt{qrfact} returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the \texttt{Q} and \texttt{R} matrices can be stored compactly rather as two separate dense matrices.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L215-L272}{\texttt{source}}



\begin{lstlisting}
qrfact(A) -> SPQR.Factorization
\end{lstlisting}

Compute the \texttt{QR} factorization of a sparse matrix \texttt{A}. A fill-reducing permutation is used. The main application of this type is to solve least squares problems with \hyperlink{11203908042914658075}{\texttt{{\textbackslash}}}. The function calls the C library SPQR and a few additional functions from the library are wrapped but not exported.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/spqr.jl#L142-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17675636264317375637}{} 
\hyperlink{17675636264317375637}{\texttt{Base.LinAlg.qrfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
qrfact!(A, pivot=Val{false})
\end{lstlisting}

\texttt{qrfact!} is the same as \hyperlink{16170416021894488810}{\texttt{qrfact}} when \texttt{A} is a subtype of \texttt{StridedMatrix}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. An \hyperlink{5399118524830636312}{\texttt{InexactError}} exception is thrown if the factorization produces a number not representable by the element type of \texttt{A}, e.g. for integer types.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L203-L210}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6169365281542139873}{} 
\hyperlink{6169365281542139873}{\texttt{Base.LinAlg.QR}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
QR <: Factorization
\end{lstlisting}

A QR matrix factorization stored in a packed format, typically obtained from \hyperlink{16170416021894488810}{\texttt{qrfact}}. If \(A\) is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
where \(Q\) is an orthogonal/unitary matrix and \(R\) is upper triangular. The matrix \(Q\) is stored as a sequence of Householder reflectors \(v_i\) and coefficients \(\tau_i\) where:

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\end{split}\end{equation*}
The object has two fields:

\begin{itemize}
\item \texttt{factors} is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of \(R\), that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors \(v_i\) stored in a packed format where \(v_i\) is the \(i\)th column of the matrix \texttt{V = eye(m,n) + tril(F.factors,-1)}.

\end{itemize}

\item \texttt{τ} is a vector  of length \texttt{min(m,n)} containing the coefficients \(au_i\).

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L4-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18189258812560098941}{} 
\hyperlink{18189258812560098941}{\texttt{Base.LinAlg.QRCompactWY}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
QRCompactWY <: Factorization
\end{lstlisting}

A QR matrix factorization stored in a compact blocked format, typically obtained from \hyperlink{16170416021894488810}{\texttt{qrfact}}. If \(A\) is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A = Q R\end{split}\end{equation*}
where \(Q\) is an orthogonal/unitary matrix and \(R\) is upper triangular. It is similar to the \hyperlink{6169365281542139873}{\texttt{QR}} format except that the orthogonal/unitary matrix \(Q\) is stored in \emph{Compact WY} format \footnotemark[1], as a lower trapezoidal matrix \(V\) and an upper triangular matrix \(T\) where

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T) = I - V T V^T\end{split}\end{equation*}
such that \(v_i\) is the \(i\)th column of \(V\), and \(au_i\) is the \(i\)th diagonal element of \(T\).

The object has two fields:

\begin{itemize}
\item \texttt{factors}, as in the \hyperlink{6169365281542139873}{\texttt{QR}} type, is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of \(R\), that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors \(v_i\) stored in a packed format such that \texttt{V = eye(m,n) + tril(F.factors,-1)}.

\end{itemize}

\item \texttt{T} is a square matrix with \texttt{min(m,n)} columns, whose upper triangular part gives the matrix \(T\) above (the subdiagonal elements are ignored).

\end{itemize}
\begin{quote}
\textbf{Note}

This format should not to be confused with the older \emph{WY} representation \footnotemark[2].

\end{quote}
\footnotetext[2]{C Bischof and C Van Loan, {\textquotedbl}The WY representation for products of Householder matrices{\textquotedbl}, SIAM J Sci Stat Comput 8 (1987), s2-s13. \href{http://dx.doi.org/10.1137/0908009}{doi:10.1137/0908009}

}
\footnotetext[1]{R Schreiber and C Van Loan, {\textquotedbl}A storage-efficient WY representation for products of Householder transformations{\textquotedbl}, SIAM J Sci Stat Comput 10 (1989), 53-57. \href{http://dx.doi.org/10.1137/0910005}{doi:10.1137/0910005}

}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L43-L87}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7934860800976993126}{} 
\hyperlink{7934860800976993126}{\texttt{Base.LinAlg.QRPivoted}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
QRPivoted <: Factorization
\end{lstlisting}

A QR matrix factorization with column pivoting in a packed format, typically obtained from \hyperlink{16170416021894488810}{\texttt{qrfact}}. If \(A\) is an \texttt{m}×\texttt{n} matrix, then

\begin{equation*}
\begin{split}A P = Q R\end{split}\end{equation*}
where \(P\) is a permutation matrix, \(Q\) is an orthogonal/unitary matrix and \(R\) is upper triangular. The matrix \(Q\) is stored as a sequence of Householder reflectors:

\begin{equation*}
\begin{split}Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\end{split}\end{equation*}
The object has three fields:

\begin{itemize}
\item \texttt{factors} is an \texttt{m}×\texttt{n} matrix.

\begin{itemize}
\item The upper triangular part contains the elements of \(R\), that is \texttt{R = triu(F.factors)} for a \texttt{QR} object \texttt{F}.


\item The subdiagonal part contains the reflectors \(v_i\) stored in a packed format where \(v_i\) is the \(i\)th column of the matrix \texttt{V = eye(m,n) + tril(F.factors,-1)}.

\end{itemize}

\item \texttt{τ} is a vector of length \texttt{min(m,n)} containing the coefficients \(au_i\).


\item \texttt{jpvt} is an integer vector of length \texttt{n} corresponding to the permutation \(P\).

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/qr.jl#L95-L125}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11443624932714046641}{} 
\hyperlink{11443624932714046641}{\texttt{Base.LinAlg.lqfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lqfact!(A) -> LQ
\end{lstlisting}

Compute the LQ factorization of \texttt{A}, using the input matrix as a workspace. See also \hyperlink{8845557553836336789}{\texttt{lq}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lq.jl#L20-L25}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16205636631154816684}{} 
\hyperlink{16205636631154816684}{\texttt{Base.LinAlg.lqfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lqfact(A) -> LQ
\end{lstlisting}

Compute the LQ factorization of \texttt{A}. See also \hyperlink{8845557553836336789}{\texttt{lq}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lq.jl#L27-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8845557553836336789}{} 
\hyperlink{8845557553836336789}{\texttt{Base.LinAlg.lq}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lq(A; [thin=true]) -> L, Q
\end{lstlisting}

Perform an LQ factorization of \texttt{A} such that \texttt{A = L*Q}. The default is to compute a thin factorization. The LQ factorization is the QR factorization of \texttt{A.{\textquotesingle}}. \texttt{L} is not extended with zeros if the full \texttt{Q} is requested.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lq.jl#L35-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16689081380067534909}{} 
\hyperlink{16689081380067534909}{\texttt{Base.LinAlg.bkfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bkfact(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -> BunchKaufman
\end{lstlisting}

Compute the Bunch-Kaufman \footnotemark[3] factorization of a symmetric or Hermitian matrix \texttt{A} and return a \texttt{BunchKaufman} object. \texttt{uplo} indicates which triangle of matrix \texttt{A} to reference. If \texttt{symmetric} is \texttt{true}, \texttt{A} is assumed to be symmetric. If \texttt{symmetric} is \texttt{false}, \texttt{A} is assumed to be Hermitian. If \texttt{rook} is \texttt{true}, rook pivoting is used. If \texttt{rook} is false, rook pivoting is not used. The following functions are available for \texttt{BunchKaufman} objects: \hyperlink{17888996102305087038}{\texttt{size}}, \texttt{{\textbackslash}}, \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{16421003133250542616}{\texttt{issymmetric}}, \hyperlink{12800362927453768899}{\texttt{ishermitian}}.

\footnotetext[3]{J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. \href{http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/}{url}.

}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bunchkaufman.jl#L57-L71}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5215931628001847512}{} 
\hyperlink{5215931628001847512}{\texttt{Base.LinAlg.bkfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bkfact!(A, uplo::Symbol=:U, symmetric::Bool=issymmetric(A), rook::Bool=false) -> BunchKaufman
\end{lstlisting}

\texttt{bkfact!} is the same as \hyperlink{16689081380067534909}{\texttt{bkfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/bunchkaufman.jl#L19-L24}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14864609220164435086}{} 
\hyperlink{14864609220164435086}{\texttt{Base.LinAlg.eig}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eig(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> D, V
eig(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> D, V
eig(A, permute::Bool=true, scale::Bool=true) -> D, V
\end{lstlisting}

Computes eigenvalues (\texttt{D}) and eigenvectors (\texttt{V}) of \texttt{A}. See \hyperlink{18133897359296222402}{\texttt{eigfact}} for details on the \texttt{irange}, \texttt{vl}, and \texttt{vu} arguments (for \hyperlink{14121197223449931750}{\texttt{SymTridiagonal}}, \texttt{Hermitian}, and \texttt{Symmetric} matrices) and the \texttt{permute} and \texttt{scale} keyword arguments. The eigenvectors are returned columnwise.

\textbf{Example}


\begin{minted}{jlcon}
julia> eig([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
\end{minted}

\texttt{eig} is a wrapper around \hyperlink{18133897359296222402}{\texttt{eigfact}}, extracting all parts of the factorization to a tuple; where possible, using \hyperlink{18133897359296222402}{\texttt{eigfact}} is recommended.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L112-L134}{\texttt{source}}



\begin{lstlisting}
eig(A, B) -> D, V
\end{lstlisting}

Computes generalized eigenvalues (\texttt{D}) and vectors (\texttt{V}) of \texttt{A} with respect to \texttt{B}.

\texttt{eig} is a wrapper around \hyperlink{18133897359296222402}{\texttt{eigfact}}, extracting all parts of the factorization to a tuple; where possible, using \hyperlink{18133897359296222402}{\texttt{eigfact}} is recommended.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eig(A, B)
(Complex{Float64}[0.0+1.0im, 0.0-1.0im], Complex{Float64}[0.0-1.0im 0.0+1.0im; -1.0-0.0im -1.0+0.0im])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L333-L357}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3176364577236723896}{} 
\hyperlink{3176364577236723896}{\texttt{Base.LinAlg.eigvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigvals(A; permute::Bool=true, scale::Bool=true) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}.

For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is \texttt{true} for both options.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L181-L191}{\texttt{source}}



\begin{lstlisting}
eigvals(A, B) -> values
\end{lstlisting}

Computes the generalized eigenvalues of \texttt{A} and \texttt{B}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eigvals(A,B)
2-element Array{Complex{Float64},1}:
 0.0+1.0im
 0.0-1.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L383-L406}{\texttt{source}}



\begin{lstlisting}
eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}. It is possible to calculate only a subset of the eigenvalues by specifying a \texttt{UnitRange} \texttt{irange} covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A, 2:2)
1-element Array{Float64,1}:
 1.0

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.14005
  1.0
  5.14005
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L366-L390}{\texttt{source}}



\begin{lstlisting}
eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values
\end{lstlisting}

Returns the eigenvalues of \texttt{A}. It is possible to calculate only a subset of the eigenvalues by specifying a pair \texttt{vl} and \texttt{vu} for the lower and upper boundaries of the eigenvalues.


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A, -1, 2)
1-element Array{Float64,1}:
 1.0

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.14005
  1.0
  5.14005
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L406-L429}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3807894261210511240}{} 
\hyperlink{3807894261210511240}{\texttt{Base.LinAlg.eigvals!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigvals!(A; permute::Bool=true, scale::Bool=true) -> values
\end{lstlisting}

Same as \hyperlink{3176364577236723896}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L163-L170}{\texttt{source}}



\begin{lstlisting}
eigvals!(A, B) -> values
\end{lstlisting}

Same as \hyperlink{3176364577236723896}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A} (and \texttt{B}), instead of creating copies.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L367-L371}{\texttt{source}}



\begin{lstlisting}
eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values
\end{lstlisting}

Same as \hyperlink{3176364577236723896}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. \texttt{irange} is a range of eigenvalue \emph{indices} to search for - for instance, the 2nd to 8th eigenvalues.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L357-L362}{\texttt{source}}



\begin{lstlisting}
eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values
\end{lstlisting}

Same as \hyperlink{3176364577236723896}{\texttt{eigvals}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy. \texttt{vl} is the lower bound of the interval to search for eigenvalues, and \texttt{vu} is the upper bound.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L397-L402}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2002481541828933425}{} 
\hyperlink{2002481541828933425}{\texttt{Base.LinAlg.eigmax}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigmax(A; permute::Bool=true, scale::Bool=true)
\end{lstlisting}

Returns the largest eigenvalue of \texttt{A}. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of \texttt{A} are complex, this method will fail, since complex numbers cannot be sorted.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia> eigmax(A)
1.0

julia> A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia> eigmax(A)
ERROR: DomainError:
Stacktrace:
 [1] #eigmax#46(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:238
 [2] eigmax(::Array{Complex{Int64},2}) at ./linalg/eigen.jl:236
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L201-L234}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3000514364430926525}{} 
\hyperlink{3000514364430926525}{\texttt{Base.LinAlg.eigmin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigmin(A; permute::Bool=true, scale::Bool=true)
\end{lstlisting}

Returns the smallest eigenvalue of \texttt{A}. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of \texttt{A} are complex, this method will fail, since complex numbers cannot be sorted.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia> eigmin(A)
-1.0

julia> A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia> eigmin(A)
ERROR: DomainError:
Stacktrace:
 [1] #eigmin#47(::Bool, ::Bool, ::Function, ::Array{Complex{Int64},2}) at ./linalg/eigen.jl:280
 [2] eigmin(::Array{Complex{Int64},2}) at ./linalg/eigen.jl:278
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L243-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13341009863130381110}{} 
\hyperlink{13341009863130381110}{\texttt{Base.LinAlg.eigvecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigvecs(A::SymTridiagonal[, eigvals]) -> Matrix
\end{lstlisting}

Returns a matrix \texttt{M} whose columns are the eigenvectors of \texttt{A}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.)

If the optional vector of eigenvalues \texttt{eigvals} is specified, \texttt{eigvecs} returns the specific corresponding eigenvectors.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia> eigvals(A)
3-element Array{Float64,1}:
 -2.14005
  1.0
  5.14005

julia> eigvecs(A)
3×3 Array{Float64,2}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia> eigvecs(A, [1.])
3×1 Array{Float64,2}:
  0.83205
  4.26351e-17
 -0.5547
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/tridiag.jl#L212-L248}{\texttt{source}}



\begin{lstlisting}
eigvecs(A; permute::Bool=true, scale::Bool=true) -> Matrix
\end{lstlisting}

Returns a matrix \texttt{M} whose columns are the eigenvectors of \texttt{A}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.) The \texttt{permute} and \texttt{scale} keywords are the same as for \hyperlink{18133897359296222402}{\texttt{eigfact}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L140-L156}{\texttt{source}}



\begin{lstlisting}
eigvecs(A, B) -> Matrix
\end{lstlisting}

Returns a matrix \texttt{M} whose columns are the generalized eigenvectors of \texttt{A} and \texttt{B}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{M[:, k]}.)

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia> B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia> eigvecs(A, B)
2×2 Array{Complex{Float64},2}:
  0.0-1.0im   0.0+1.0im
 -1.0-0.0im  -1.0+0.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L412-L436}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18133897359296222402}{} 
\hyperlink{18133897359296222402}{\texttt{Base.LinAlg.eigfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigfact(A; permute::Bool=true, scale::Bool=true) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F[:values]} and the eigenvectors in the columns of the matrix \texttt{F[:vectors]}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F[:vectors][:, k]}.)

The following functions are available for \texttt{Eigen} objects: \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{10141753772895527781}{\texttt{isposdef}}.

For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option \texttt{permute=true} permutes the matrix to become closer to upper triangular, and \texttt{scale=true} scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is \texttt{true} for both options.

\textbf{Example}


\begin{minted}{jlcon}
julia> F = eigfact([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Base.LinAlg.Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}([1.0, 3.0, 18.0], [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia> F[:values]
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia> F[:vectors]
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L68-L100}{\texttt{source}}



\begin{lstlisting}
eigfact(A, B) -> GeneralizedEigen
\end{lstlisting}

Computes the generalized eigenvalue decomposition of \texttt{A} and \texttt{B}, returning a \texttt{GeneralizedEigen} factorization object \texttt{F} which contains the generalized eigenvalues in \texttt{F[:values]} and the generalized eigenvectors in the columns of the matrix \texttt{F[:vectors]}. (The \texttt{k}th generalized eigenvector can be obtained from the slice \texttt{F[:vectors][:, k]}.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L318-L325}{\texttt{source}}



\begin{lstlisting}
eigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F[:values]} and the eigenvectors in the columns of the matrix \texttt{F[:vectors]}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F[:vectors][:, k]}.)

The following functions are available for \texttt{Eigen} objects: \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{10141753772895527781}{\texttt{isposdef}}.

The \texttt{UnitRange} \texttt{irange} specifies indices of the sorted eigenvalues to search for.

\begin{quote}
\textbf{Note}

If \texttt{irange} is not \texttt{1:n}, where \texttt{n} is the dimension of \texttt{A}, then the returned factorization will be a \emph{truncated} factorization.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L303-L317}{\texttt{source}}



\begin{lstlisting}
eigfact(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen
\end{lstlisting}

Computes the eigenvalue decomposition of \texttt{A}, returning an \texttt{Eigen} factorization object \texttt{F} which contains the eigenvalues in \texttt{F[:values]} and the eigenvectors in the columns of the matrix \texttt{F[:vectors]}. (The \texttt{k}th eigenvector can be obtained from the slice \texttt{F[:vectors][:, k]}.)

The following functions are available for \texttt{Eigen} objects: \hyperlink{9013378623280719296}{\texttt{inv}}, \hyperlink{1300265042345987014}{\texttt{det}}, and \hyperlink{10141753772895527781}{\texttt{isposdef}}.

\texttt{vl} is the lower bound of the window of eigenvalues to search for, and \texttt{vu} is the upper bound.

\begin{quote}
\textbf{Note}

If [\texttt{vl}, \texttt{vu}] does not contain all eigenvalues of \texttt{A}, then the returned factorization will be a \emph{truncated} factorization.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/symmetric.jl#L327-L341}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14613994766560843660}{} 
\hyperlink{14613994766560843660}{\texttt{Base.LinAlg.eigfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigfact!(A, [B])
\end{lstlisting}

Same as \hyperlink{18133897359296222402}{\texttt{eigfact}}, but saves space by overwriting the input \texttt{A} (and \texttt{B}), instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/eigen.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12358799216183401879}{} 
\hyperlink{12358799216183401879}{\texttt{Base.LinAlg.hessfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hessfact(A) -> Hessenberg
\end{lstlisting}

Compute the Hessenberg decomposition of \texttt{A} and return a \texttt{Hessenberg} object. If \texttt{F} is the factorization object, the unitary matrix can be accessed with \texttt{F[:Q]} and the Hessenberg matrix with \texttt{F[:H]}. When \texttt{Q} is extracted, the resulting type is the \texttt{HessenbergQ} object, and may be converted to a regular matrix with \hyperlink{1846942650946171605}{\texttt{convert(Array, \_)}}  (or \texttt{Array(\_)} for short).

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia> F = hessfact(A);

julia> F[:Q] * F[:H] * F[:Q]'
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/hessenberg.jl#L24-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10307666610329965165}{} 
\hyperlink{10307666610329965165}{\texttt{Base.LinAlg.hessfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hessfact!(A) -> Hessenberg
\end{lstlisting}

\texttt{hessfact!} is the same as \hyperlink{12358799216183401879}{\texttt{hessfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/hessenberg.jl#L14-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8161465521668732847}{} 
\hyperlink{8161465521668732847}{\texttt{Base.LinAlg.schurfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
schurfact(A::StridedMatrix) -> F::Schur
\end{lstlisting}

Computes the Schur factorization of the matrix \texttt{A}. The (quasi) triangular Schur factor can be obtained from the \texttt{Schur} object \texttt{F} with either \texttt{F[:Schur]} or \texttt{F[:T]} and the orthogonal/unitary Schur vectors can be obtained with \texttt{F[:vectors]} or \texttt{F[:Z]} such that \texttt{A = F[:vectors]*F[:Schur]*F[:vectors]{\textquotesingle}}. The eigenvalues of \texttt{A} can be obtained with \texttt{F[:values]}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [-2. 1. 3.; 2. 1. -1.; -7. 2. 7.]
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0

julia> F = schurfact(A)
Base.LinAlg.Schur{Float64,Array{Float64,2}} with factors T and Z:
[2.0 0.801792 6.63509; -8.55988e-11 2.0 8.08286; 0.0 0.0 1.99999]
[0.577351 0.154299 -0.801784; 0.577346 -0.77152 0.267262; 0.577354 0.617211 0.534522]
and values:
Complex{Float64}[2.0+8.28447e-6im, 2.0-8.28447e-6im, 1.99999+0.0im]

julia> F[:vectors] * F[:Schur] * F[:vectors]'
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L19-L49}{\texttt{source}}



\begin{lstlisting}
schurfact(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur
\end{lstlisting}

Computes the Generalized Schur (or QZ) factorization of the matrices \texttt{A} and \texttt{B}. The (quasi) triangular Schur factors can be obtained from the \texttt{Schur} object \texttt{F} with \texttt{F[:S]} and \texttt{F[:T]}, the left unitary/orthogonal Schur vectors can be obtained with \texttt{F[:left]} or \texttt{F[:Q]} and the right unitary/orthogonal Schur vectors can be obtained with \texttt{F[:right]} or \texttt{F[:Z]} such that \texttt{A=F[:left]*F[:S]*F[:right]{\textquotesingle}} and \texttt{B=F[:left]*F[:T]*F[:right]{\textquotesingle}}. The generalized eigenvalues of \texttt{A} and \texttt{B} can be obtained with \texttt{F[:alpha]./F[:beta]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L187-L196}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1502600911105385632}{} 
\hyperlink{1502600911105385632}{\texttt{Base.LinAlg.schurfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
schurfact!(A::StridedMatrix) -> F::Schur
\end{lstlisting}

Same as \hyperlink{8161465521668732847}{\texttt{schurfact}} but uses the input argument as workspace.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L12-L16}{\texttt{source}}



\begin{lstlisting}
schurfact!(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur
\end{lstlisting}

Same as \hyperlink{8161465521668732847}{\texttt{schurfact}} but uses the input matrices \texttt{A} and \texttt{B} as workspace.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L179-L183}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5448411964655904748}{} 
\hyperlink{5448411964655904748}{\texttt{Base.LinAlg.schur}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
schur(A::StridedMatrix) -> T::Matrix, Z::Matrix, λ::Vector
\end{lstlisting}

Computes the Schur factorization of the matrix \texttt{A}. The methods return the (quasi) triangular Schur factor \texttt{T} and the orthogonal/unitary Schur vectors \texttt{Z} such that \texttt{A = Z*T*Z{\textquotesingle}}. The eigenvalues of \texttt{A} are returned in the vector \texttt{λ}.

See \hyperlink{8161465521668732847}{\texttt{schurfact}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [-2. 1. 3.; 2. 1. -1.; -7. 2. 7.]
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0

julia> T, Z, lambda = schur(A)
([2.0 0.801792 6.63509; -8.55988e-11 2.0 8.08286; 0.0 0.0 1.99999], [0.577351 0.154299 -0.801784; 0.577346 -0.77152 0.267262; 0.577354 0.617211 0.534522], Complex{Float64}[2.0+8.28447e-6im, 2.0-8.28447e-6im, 1.99999+0.0im])

julia> Z * T * Z'
3×3 Array{Float64,2}:
 -2.0  1.0   3.0
  2.0  1.0  -1.0
 -7.0  2.0   7.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L78-L105}{\texttt{source}}



\begin{lstlisting}
schur(A::StridedMatrix, B::StridedMatrix) -> S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector
\end{lstlisting}

See \hyperlink{8161465521668732847}{\texttt{schurfact}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L271-L275}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8963710124171619666}{} 
\hyperlink{8963710124171619666}{\texttt{Base.LinAlg.ordschur}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur
\end{lstlisting}

Reorders the Schur factorization \texttt{F} of a matrix \texttt{A = Z*T*Z{\textquotesingle}} according to the logical array \texttt{select} returning the reordered factorization \texttt{F} object. The selected eigenvalues appear in the leading diagonal of \texttt{F[:Schur]} and the corresponding leading columns of \texttt{F[:vectors]} form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via \texttt{select}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L128-L137}{\texttt{source}}



\begin{lstlisting}
ordschur(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -> T::StridedMatrix, Z::StridedMatrix, λ::Vector
\end{lstlisting}

Reorders the Schur factorization of a real matrix \texttt{A = Z*T*Z{\textquotesingle}} according to the logical array \texttt{select} returning the reordered matrices \texttt{T} and \texttt{Z} as well as the vector of eigenvalues \texttt{λ}. The selected eigenvalues appear in the leading diagonal of \texttt{T} and the corresponding leading columns of \texttt{Z} form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via \texttt{select}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L149-L158}{\texttt{source}}



\begin{lstlisting}
ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur
\end{lstlisting}

Reorders the Generalized Schur factorization \texttt{F} of a matrix pair \texttt{(A, B) = (Q*S*Z{\textquotesingle}, Q*T*Z{\textquotesingle})} according to the logical array \texttt{select} and returns a GeneralizedSchur object \texttt{F}. The selected eigenvalues appear in the leading diagonal of both \texttt{F[:S]} and \texttt{F[:T]}, and the left and right orthogonal/unitary Schur vectors are also reordered such that \texttt{(A, B) = F[:Q]*(F[:S], F[:T])*F[:Z]{\textquotesingle}} still holds and the generalized eigenvalues of \texttt{A} and \texttt{B} can still be obtained with \texttt{F[:alpha]./F[:beta]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L215-L224}{\texttt{source}}



\begin{lstlisting}
ordschur(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -> S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector
\end{lstlisting}

Reorders the Generalized Schur factorization of a matrix pair \texttt{(A, B) = (Q*S*Z{\textquotesingle}, Q*T*Z{\textquotesingle})} according to the logical array \texttt{select} and returns the matrices \texttt{S}, \texttt{T}, \texttt{Q}, \texttt{Z} and vectors \texttt{α} and \texttt{β}.  The selected eigenvalues appear in the leading diagonal of both \texttt{S} and \texttt{T}, and the left and right unitary/orthogonal Schur vectors are also reordered such that \texttt{(A, B) = Q*(S, T)*Z{\textquotesingle}} still holds and the generalized eigenvalues of \texttt{A} and \texttt{B} can still be obtained with \texttt{α./β}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L237-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6787239091599290339}{} 
\hyperlink{6787239091599290339}{\texttt{Base.LinAlg.ordschur!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -> F::Schur
\end{lstlisting}

Same as \hyperlink{8963710124171619666}{\texttt{ordschur}} but overwrites the factorization \texttt{F}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L117-L121}{\texttt{source}}



\begin{lstlisting}
ordschur!(T::StridedMatrix, Z::StridedMatrix, select::Union{Vector{Bool},BitVector}) -> T::StridedMatrix, Z::StridedMatrix, λ::Vector
\end{lstlisting}

Same as \hyperlink{8963710124171619666}{\texttt{ordschur}} but overwrites the input arguments.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L141-L145}{\texttt{source}}



\begin{lstlisting}
ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur
\end{lstlisting}

Same as \texttt{ordschur} but overwrites the factorization \texttt{F}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L203-L207}{\texttt{source}}



\begin{lstlisting}
ordschur!(S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, select) -> S::StridedMatrix, T::StridedMatrix, Q::StridedMatrix, Z::StridedMatrix, α::Vector, β::Vector
\end{lstlisting}

Same as \hyperlink{8963710124171619666}{\texttt{ordschur}} but overwrites the factorization the input arguments.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/schur.jl#L228-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1135051488165556244}{} 
\hyperlink{1135051488165556244}{\texttt{Base.LinAlg.svdfact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svdfact(A; thin::Bool=true) -> SVD
\end{lstlisting}

Compute the singular value decomposition (SVD) of \texttt{A} and return an \texttt{SVD} object.

\texttt{U}, \texttt{S}, \texttt{V} and \texttt{Vt} can be obtained from the factorization \texttt{F} with \texttt{F[:U]}, \texttt{F[:S]}, \texttt{F[:V]} and \texttt{F[:Vt]}, such that \texttt{A = U*diagm(S)*Vt}. The algorithm produces \texttt{Vt} and hence \texttt{Vt} is more efficient to extract than \texttt{V}. The singular values in \texttt{S} are sorted in descending order.

If \texttt{thin=true} (default), a thin SVD is returned. For a \(M \times N\) matrix \texttt{A}, \texttt{U} is \(M \times M\) for a full SVD (\texttt{thin=false}) and \(M \times \min(M, N)\) for a thin SVD.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> F = svdfact(A)
Base.LinAlg.SVD{Float64,Float64,Array{Float64,2}}([0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0; 0.0 0.0 1.0 0.0], [3.0, 2.23607, 2.0, 0.0], [-0.0 0.0 … -0.0 0.0; 0.447214 0.0 … 0.0 0.894427; -0.0 1.0 … -0.0 0.0; 0.0 0.0 … 1.0 0.0])

julia> F[:U] * diagm(F[:S]) * F[:Vt]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L29-L62}{\texttt{source}}



\begin{lstlisting}
svdfact(A, B) -> GeneralizedSVD
\end{lstlisting}

Compute the generalized SVD of \texttt{A} and \texttt{B}, returning a \texttt{GeneralizedSVD} factorization object \texttt{F}, such that \texttt{A = F[:U]*F[:D1]*F[:R0]*F[:Q]{\textquotesingle}} and \texttt{B = F[:V]*F[:D2]*F[:R0]*F[:Q]{\textquotesingle}}.

For an M-by-N matrix \texttt{A} and P-by-N matrix \texttt{B},

\begin{itemize}
\item \texttt{F[:U]} is a M-by-M orthogonal matrix,


\item \texttt{F[:V]} is a P-by-P orthogonal matrix,


\item \texttt{F[:Q]} is a N-by-N orthogonal matrix,


\item \texttt{F[:R0]} is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is          nonsingular upper block triangular,


\item \texttt{F[:D1]} is a M-by-(K+L) diagonal matrix with 1s in the first K entries,


\item \texttt{F[:D2]} is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,

\end{itemize}
\texttt{K+L} is the effective numerical rank of the matrix \texttt{[A; B]}.

The entries of \texttt{F[:D1]} and \texttt{F[:D2]} are related, as explained in the LAPACK documentation for the \href{http://www.netlib.org/lapack/lug/node36.html}{generalized SVD} and the \href{http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3\_8f.html}{xGGSVD3} routine which is called underneath (in LAPACK 3.6.0 and newer).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L206-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14902952530454090437}{} 
\hyperlink{14902952530454090437}{\texttt{Base.LinAlg.svdfact!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svdfact!(A, thin::Bool=true) -> SVD
\end{lstlisting}

\texttt{svdfact!} is the same as \hyperlink{1135051488165556244}{\texttt{svdfact}}, but saves space by overwriting the input \texttt{A}, instead of creating a copy.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L13-L18}{\texttt{source}}



\begin{lstlisting}
svdfact!(A, B) -> GeneralizedSVD
\end{lstlisting}

\texttt{svdfact!} is the same as \hyperlink{1135051488165556244}{\texttt{svdfact}}, but modifies the arguments \texttt{A} and \texttt{B} in-place, instead of making copies.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L189-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14775973623414930183}{} 
\hyperlink{14775973623414930183}{\texttt{Base.LinAlg.svd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svd(A; thin::Bool=true) -> U, S, V
\end{lstlisting}

Computes the SVD of \texttt{A}, returning \texttt{U}, vector \texttt{S}, and \texttt{V} such that \texttt{A == U*diagm(S)*V{\textquotesingle}}. The singular values in \texttt{S} are sorted in descending order.

If \texttt{thin=true} (default), a thin SVD is returned. For a \(M \times N\) matrix \texttt{A}, \texttt{U} is \(M \times M\) for a full SVD (\texttt{thin=false}) and \(M \times \min(M, N)\) for a thin SVD.

\texttt{svd} is a wrapper around \hyperlink{1135051488165556244}{\texttt{svdfact}}, extracting all parts of the \texttt{SVD} factorization to a tuple. Direct use of \texttt{svdfact} is therefore more efficient.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> U, S, V = svd(A)
([0.0 1.0 0.0 0.0; 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0; 0.0 0.0 1.0 0.0], [3.0, 2.23607, 2.0, 0.0], [-0.0 0.447214 -0.0 0.0; 0.0 0.0 1.0 0.0; … ; -0.0 0.0 -0.0 1.0; 0.0 0.894427 0.0 0.0])

julia> U*diagm(S)*V'
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L70-L104}{\texttt{source}}



\begin{lstlisting}
svd(A, B) -> U, V, Q, D1, D2, R0
\end{lstlisting}

Wrapper around \hyperlink{1135051488165556244}{\texttt{svdfact}} extracting all parts of the factorization to a tuple. Direct use of \texttt{svdfact} is therefore generally more efficient. The function returns the generalized SVD of \texttt{A} and \texttt{B}, returning \texttt{U}, \texttt{V}, \texttt{Q}, \texttt{D1}, \texttt{D2}, and \texttt{R0} such that \texttt{A = U*D1*R0*Q{\textquotesingle}} and \texttt{B = V*D2*R0*Q{\textquotesingle}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L235-L243}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15097149969632009300}{} 
\hyperlink{15097149969632009300}{\texttt{Base.LinAlg.svdvals}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svdvals(A)
\end{lstlisting}

Returns the singular values of \texttt{A} in descending order.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia> svdvals(A)
4-element Array{Float64,1}:
 3.0
 2.23607
 2.0
 0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L133-L155}{\texttt{source}}



\begin{lstlisting}
svdvals(A, B)
\end{lstlisting}

Return the generalized singular values from the generalized singular value decomposition of \texttt{A} and \texttt{B}. See also \hyperlink{1135051488165556244}{\texttt{svdfact}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/svd.jl#L298-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1185041991470936816}{} 
\hyperlink{1185041991470936816}{\texttt{Base.LinAlg.Givens}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LinAlg.Givens(i1,i2,c,s) -> G
\end{lstlisting}

A Givens rotation linear operator. The fields \texttt{c} and \texttt{s} represent the cosine and sine of the rotation angle, respectively. The \texttt{Givens} type supports left multiplication \texttt{G*A} and conjugated transpose right multiplication \texttt{A*G{\textquotesingle}}. The type doesn{\textquotesingle}t have a \texttt{size} and can therefore be multiplied with matrices of arbitrary size as long as \texttt{i2<=size(A,2)} for \texttt{G*A} or \texttt{i2<=size(A,1)} for \texttt{A*G{\textquotesingle}}.

See also: \hyperlink{2236842301743600111}{\texttt{givens}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/givens.jl#L16-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2236842301743600111}{} 
\hyperlink{2236842301743600111}{\texttt{Base.LinAlg.givens}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
givens{T}(f::T, g::T, i1::Integer, i2::Integer) -> (G::Givens, r::T)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that for any vector \texttt{x} where


\begin{lstlisting}
x[i1] = f
x[i2] = g
\end{lstlisting}

the result of the multiplication


\begin{lstlisting}
y = G*x
\end{lstlisting}

has the property that


\begin{lstlisting}
y[i1] = r
y[i2] = 0
\end{lstlisting}

See also: \hyperlink{1185041991470936816}{\texttt{LinAlg.Givens}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/givens.jl#L234-L254}{\texttt{source}}



\begin{lstlisting}
givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -> (G::Givens, r)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that the result of the multiplication


\begin{lstlisting}
B = G*A
\end{lstlisting}

has the property that


\begin{lstlisting}
B[i1,j] = r
B[i2,j] = 0
\end{lstlisting}

See also: \hyperlink{1185041991470936816}{\texttt{LinAlg.Givens}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/givens.jl#L266-L280}{\texttt{source}}



\begin{lstlisting}
givens(x::AbstractVector, i1::Integer, i2::Integer) -> (G::Givens, r)
\end{lstlisting}

Computes the Givens rotation \texttt{G} and scalar \texttt{r} such that the result of the multiplication


\begin{lstlisting}
B = G*x
\end{lstlisting}

has the property that


\begin{lstlisting}
B[i1] = r
B[i2] = 0
\end{lstlisting}

See also: \hyperlink{1185041991470936816}{\texttt{LinAlg.Givens}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/givens.jl#L285-L299}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8330662115675783329}{} 
\hyperlink{8330662115675783329}{\texttt{Base.LinAlg.triu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
triu(M)
\end{lstlisting}

Upper triangle of a matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> triu(a)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L119-L141}{\texttt{source}}



\begin{lstlisting}
triu(M, k::Integer)
\end{lstlisting}

Returns the upper triangle of \texttt{M} starting from the \texttt{k}th superdiagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> triu(a,3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia> triu(a,-3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L169-L198}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9921408020349989976}{} 
\hyperlink{9921408020349989976}{\texttt{Base.LinAlg.triu!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
triu!(M)
\end{lstlisting}

Upper triangle of a matrix, overwriting \texttt{M} in the process. See also \hyperlink{8330662115675783329}{\texttt{triu}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L233-L238}{\texttt{source}}



\begin{lstlisting}
triu!(M, k::Integer)
\end{lstlisting}

Returns the upper triangle of \texttt{M} starting from the \texttt{k}th superdiagonal, overwriting \texttt{M} in the process.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia> triu!(M, 1)
5×5 Array{Int64,2}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L99-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1728419844431457454}{} 
\hyperlink{1728419844431457454}{\texttt{Base.LinAlg.tril}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tril(M)
\end{lstlisting}

Lower triangle of a matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a)
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L144-L166}{\texttt{source}}



\begin{lstlisting}
tril(M, k::Integer)
\end{lstlisting}

Returns the lower triangle of \texttt{M} starting from the \texttt{k}th superdiagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ones(4,4)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a,3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia> tril(a,-3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L201-L230}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11302024164043301055}{} 
\hyperlink{11302024164043301055}{\texttt{Base.LinAlg.tril!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tril!(M)
\end{lstlisting}

Lower triangle of a matrix, overwriting \texttt{M} in the process. See also \hyperlink{1728419844431457454}{\texttt{tril}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L241-L246}{\texttt{source}}



\begin{lstlisting}
tril!(M, k::Integer)
\end{lstlisting}

Returns the lower triangle of \texttt{M} starting from the \texttt{k}th superdiagonal, overwriting \texttt{M} in the process.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia> tril!(M, 2)
5×5 Array{Int64,2}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L142-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17382904583164206880}{} 
\hyperlink{17382904583164206880}{\texttt{Base.LinAlg.diagind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diagind(M, k::Integer=0)
\end{lstlisting}

A \texttt{Range} giving the indices of the \texttt{k}th diagonal of the matrix \texttt{M}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> diagind(A,-1)
2:4:6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L209-L226}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6899395651203530298}{} 
\hyperlink{6899395651203530298}{\texttt{Base.LinAlg.diag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diag(M, k::Integer=0)
\end{lstlisting}

The \texttt{k}th diagonal of a matrix, as a vector. Use \hyperlink{8563936900334873682}{\texttt{diagm}} to construct a diagonal matrix.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> diag(A,1)
2-element Array{Int64,1}:
 2
 6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L229-L249}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8563936900334873682}{} 
\hyperlink{8563936900334873682}{\texttt{Base.LinAlg.diagm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diagm(v, k::Integer=0)
\end{lstlisting}

Construct a matrix by placing \texttt{v} on the \texttt{k}th diagonal.

\textbf{Example}


\begin{minted}{jlcon}
julia> diagm([1,2,3],1)
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L252-L267}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11656874809199876602}{} 
\hyperlink{11656874809199876602}{\texttt{Base.LinAlg.scale!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
scale!(A, b)
scale!(b, A)
\end{lstlisting}

Scale an array \texttt{A} by a scalar \texttt{b} overwriting \texttt{A} in-place.

If \texttt{A} is a matrix and \texttt{b} is a vector, then \texttt{scale!(A,b)} scales each column \texttt{i} of \texttt{A} by \texttt{b[i]} (similar to \texttt{A*Diagonal(b)}), while \texttt{scale!(b,A)} scales each row \texttt{i} of \texttt{A} by \texttt{b[i]} (similar to \texttt{Diagonal(b)*A}), again operating in-place on \texttt{A}. An \texttt{InexactError} exception is thrown if the scaling produces a number not representable by the element type of \texttt{A}, e.g. for integer types.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> b = [1; 2]
2-element Array{Int64,1}:
 1
 2

julia> scale!(a,b)
2×2 Array{Int64,2}:
 1  4
 3  8

julia> a = [1 2; 3 4];

julia> b = [1; 2];

julia> scale!(b,a)
2×2 Array{Int64,2}:
 1  2
 6  8
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L45-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2947138922560424828}{} 
\hyperlink{2947138922560424828}{\texttt{Base.LinAlg.rank}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rank(M[, tol::Real])
\end{lstlisting}

Compute the rank of a matrix by counting how many singular values of \texttt{M} have magnitude greater than \texttt{tol}. By default, the value of \texttt{tol} is the largest dimension of \texttt{M} multiplied by the \hyperlink{4594213520310841636}{\texttt{eps}} of the \hyperlink{6396209842929672718}{\texttt{eltype}} of \texttt{M}.

\textbf{Example}


\begin{minted}{jlcon}
julia> rank(eye(3))
3

julia> rank(diagm([1, 0, 2]))
2

julia> rank(diagm([1, 0.001, 2]), 0.1)
2

julia> rank(diagm([1, 0.001, 2]), 0.00001)
3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L697-L720}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4070774273873411828}{} 
\hyperlink{4070774273873411828}{\texttt{Base.LinAlg.norm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
norm(A::AbstractArray, p::Real=2)
\end{lstlisting}

Compute the \texttt{p}-norm of a vector or the operator norm of a matrix \texttt{A}, defaulting to the 2-norm.


\begin{lstlisting}
norm(A::AbstractVector, p::Real=2)
\end{lstlisting}

For vectors, this is equivalent to \hyperlink{9000973936098681781}{\texttt{vecnorm}} and equal to:

\begin{equation*}
\begin{split}\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\end{split}\end{equation*}
with \(a_i\) the entries of \(A\) and \(n\) its length.

\texttt{p} can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, \texttt{norm(A, Inf)} returns the largest value in \texttt{abs(A)}, whereas \texttt{norm(A, -Inf)} returns the smallest.

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [3, -2, 6]
3-element Array{Int64,1}:
  3
 -2
  6

julia> norm(v)
7.0

julia> norm(v, Inf)
6.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L506-L539}{\texttt{source}}



\begin{lstlisting}
norm(A::AbstractMatrix, p::Real=2)
\end{lstlisting}

For matrices, the matrix norm induced by the vector \texttt{p}-norm is used, where valid values of \texttt{p} are \texttt{1}, \texttt{2}, or \texttt{Inf}. (Note that for sparse matrices, \texttt{p=2} is currently not implemented.) Use \hyperlink{9000973936098681781}{\texttt{vecnorm}} to compute the Frobenius norm.

When \texttt{p=1}, the matrix norm is the maximum absolute column sum of \texttt{A}:

\begin{equation*}
\begin{split}\|A\|_1 = \max_{1 ≤ j ≤ n} \sum_{i=1}^m | a_{ij} |\end{split}\end{equation*}
with \(a_{ij}\) the entries of \(A\), and \(m\) and \(n\) its dimensions.

When \texttt{p=2}, the matrix norm is the spectral norm, equal to the largest singular value of \texttt{A}.

When \texttt{p=Inf}, the matrix norm is the maximum absolute row sum of \texttt{A}:

\begin{equation*}
\begin{split}\|A\|_\infty = \max_{1 ≤ i ≤ m} \sum _{j=1}^n | a_{ij} |\end{split}\end{equation*}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 -2 -3; 2 3 -1]
2×3 Array{Int64,2}:
 1  -2  -3
 2   3  -1

julia> norm(A, Inf)
6.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L542-L574}{\texttt{source}}



\begin{lstlisting}
norm(x::Number, p::Real=2)
\end{lstlisting}

For numbers, return \(\left( |x|^p \right)^{1/p}\). This is equivalent to \hyperlink{9000973936098681781}{\texttt{vecnorm}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L587-L592}{\texttt{source}}



\begin{lstlisting}
norm(A::RowVector, q::Real=2)
\end{lstlisting}

For row vectors, return the \(q\)-norm of \texttt{A}, which is equivalent to the p-norm with value \texttt{p = q/(q-1)}. They coincide at \texttt{p = q = 2}.

The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the inner product, and the result is consistent with the p-norm of \texttt{1 × n} matrix.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L597-L606}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9000973936098681781}{} 
\hyperlink{9000973936098681781}{\texttt{Base.LinAlg.vecnorm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
vecnorm(A, p::Real=2)
\end{lstlisting}

For any iterable container \texttt{A} (including arrays of any dimension) of numbers (or any element type for which \texttt{norm} is defined), compute the \texttt{p}-norm (defaulting to \texttt{p=2}) as if \texttt{A} were a vector of the corresponding length.

The \texttt{p}-norm is defined as:

\begin{equation*}
\begin{split}\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\end{split}\end{equation*}
with \(a_i\) the entries of \(A\) and \(n\) its length.

\texttt{p} can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, \texttt{vecnorm(A, Inf)} returns the largest value in \texttt{abs(A)}, whereas \texttt{vecnorm(A, -Inf)} returns the smallest. If \texttt{A} is a matrix and \texttt{p=2}, then this is equivalent to the Frobenius norm.

\textbf{Example}


\begin{minted}{jlcon}
julia> vecnorm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia> vecnorm([1 2 3 4 5 6 7 8 9])
16.881943016134134
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L414-L441}{\texttt{source}}



\begin{lstlisting}
vecnorm(x::Number, p::Real=2)
\end{lstlisting}

For numbers, return \(\left( |x|^p \right) ^{1/p}\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L460-L464}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5105121074825158846}{} 
\hyperlink{5105121074825158846}{\texttt{Base.LinAlg.normalize!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
normalize!(v::AbstractVector, p::Real=2)
\end{lstlisting}

Normalize the vector \texttt{v} in-place so that its \texttt{p}-norm equals unity, i.e. \texttt{norm(v, p) == 1}. See also \hyperlink{10075112191110723412}{\texttt{normalize}} and \hyperlink{9000973936098681781}{\texttt{vecnorm}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1306-L1312}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10075112191110723412}{} 
\hyperlink{10075112191110723412}{\texttt{Base.LinAlg.normalize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
normalize(v::AbstractVector, p::Real=2)
\end{lstlisting}

Normalize the vector \texttt{v} so that its \texttt{p}-norm equals unity, i.e. \texttt{norm(v, p) == vecnorm(v, p) == 1}. See also \hyperlink{5105121074825158846}{\texttt{normalize!}} and \hyperlink{9000973936098681781}{\texttt{vecnorm}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1,2,4];

julia> b = normalize(a)
3-element Array{Float64,1}:
 0.218218
 0.436436
 0.872872

julia> norm(b)
1.0

julia> c = normalize(a, 1)
3-element Array{Float64,1}:
 0.142857
 0.285714
 0.571429

julia> norm(c, 1)
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1335-L1365}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3226902477371958750}{} 
\hyperlink{3226902477371958750}{\texttt{Base.LinAlg.cond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cond(M, p::Real=2)
\end{lstlisting}

Condition number of the matrix \texttt{M}, computed using the operator \texttt{p}-norm. Valid values for \texttt{p} are \texttt{1}, \texttt{2} (default), or \texttt{Inf}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L904-L909}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12763865937954037560}{} 
\hyperlink{12763865937954037560}{\texttt{Base.LinAlg.condskeel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
condskeel(M, [x, p::Real=Inf])
\end{lstlisting}

\begin{equation*}
\begin{split}\kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \\
\kappa_S(M, x, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p\end{split}\end{equation*}
Skeel condition number \(\kappa_S\) of the matrix \texttt{M}, optionally with respect to the vector \texttt{x}, as computed using the operator \texttt{p}-norm. \(\left\vert M \right\vert\) denotes the matrix of (entry wise) absolute values of \(M\); \(\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert\). Valid values for \texttt{p} are \texttt{1}, \texttt{2} and \texttt{Inf} (default).

This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L848-L864}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4723994450949629907}{} 
\hyperlink{4723994450949629907}{\texttt{Base.LinAlg.trace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trace(M)
\end{lstlisting}

Matrix trace. Sums the diagonal elements of \texttt{M}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> trace(A)
5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L730-L746}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1300265042345987014}{} 
\hyperlink{1300265042345987014}{\texttt{Base.LinAlg.det}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
det(M)
\end{lstlisting}

Matrix determinant.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia> det(M)
2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1204-L1220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6649271058375699908}{} 
\hyperlink{6649271058375699908}{\texttt{Base.LinAlg.logdet}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logdet(M)
\end{lstlisting}

Log of matrix determinant. Equivalent to \texttt{log(det(M))}, but may provide increased accuracy and/or speed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia> logdet(M)
0.6931471805599453

julia> logdet(eye(3))
0.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1238-L1258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17670285292397317614}{} 
\hyperlink{17670285292397317614}{\texttt{Base.LinAlg.logabsdet}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logabsdet(M)
\end{lstlisting}

Log of absolute value of matrix determinant. Equivalent to \texttt{(log(abs(det(M))), sign(det(M)))}, but may provide increased accuracy and/or speed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1230-L1235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9013378623280719296}{} 
\hyperlink{9013378623280719296}{\texttt{Base.inv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
inv(M)
\end{lstlisting}

Matrix inverse. Computes matrix \texttt{N} such that \texttt{M * N = I}, where \texttt{I} is the identity matrix. Computed by solving the left-division \texttt{N = M {\textbackslash} I}.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [2 5; 1 3]
2×2 Array{Int64,2}:
 2  5
 1  3

julia> N = inv(M)
2×2 Array{Float64,2}:
  3.0  -5.0
 -1.0   2.0

julia> M*N == N*M == eye(2)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L758-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10021362295634933964}{} 
\hyperlink{10021362295634933964}{\texttt{Base.LinAlg.pinv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pinv(M[, tol::Real])
\end{lstlisting}

Computes the Moore-Penrose pseudoinverse.

For matrices \texttt{M} with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values above a given threshold, \texttt{tol}.

The optimal choice of \texttt{tol} varies both with the value of \texttt{M} and the intended application of the pseudoinverse. The default value of \texttt{tol} is \texttt{eps(real(float(one(eltype(M)))))*maximum(size(A))}, which is essentially machine epsilon for the real part of a matrix element multiplied by the larger matrix dimension. For inverting dense ill-conditioned matrices in a least-squares sense, \texttt{tol = sqrt(eps(real(float(one(eltype(M))))))} is recommended.

For more information, see \footnotemark[4], \footnotemark[5], \footnotemark[6], \footnotemark[7].

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1.5 1.3; 1.2 1.9]
2×2 Array{Float64,2}:
 1.5  1.3
 1.2  1.9

julia> N = pinv(M)
2×2 Array{Float64,2}:
  1.47287   -1.00775
 -0.930233   1.16279

julia> M * N
2×2 Array{Float64,2}:
 1.0          -2.22045e-16
 4.44089e-16   1.0
\end{minted}

\footnotetext[4]{Issue 8859, {\textquotedbl}Fix least squares{\textquotedbl}, https://github.com/JuliaLang/julia/pull/8859

}
\footnotetext[5]{Åke Björck, {\textquotedbl}Numerical Methods for Least Squares Problems{\textquotedbl},  SIAM Press, Philadelphia, 1996, {\textquotedbl}Other Titles in Applied Mathematics{\textquotedbl}, Vol. 51. \href{http://epubs.siam.org/doi/book/10.1137/1.9781611971484}{doi:10.1137/1.9781611971484}

}
\footnotetext[6]{G. W. Stewart, {\textquotedbl}Rank Degeneracy{\textquotedbl}, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. \href{http://epubs.siam.org/doi/abs/10.1137/0905030}{doi:10.1137/0905030}

}
\footnotetext[7]{Konstantinos Konstantinides and Kung Yao, {\textquotedbl}Statistical analysis of effective singular values in matrix rank determination{\textquotedbl}, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. \href{http://dx.doi.org/10.1109/29.1585}{doi:10.1109/29.1585}

}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L788-L832}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14766516449068242362}{} 
\hyperlink{14766516449068242362}{\texttt{Base.LinAlg.nullspace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nullspace(M)
\end{lstlisting}

Basis for nullspace of \texttt{M}.

\textbf{Example}


\begin{minted}{jlcon}
julia> M = [1 0 0; 0 1 0; 0 0 0]
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  0

julia> nullspace(M)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L874-L894}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7643954538117657889}{} 
\hyperlink{7643954538117657889}{\texttt{Base.repmat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
repmat(A, m::Integer, n::Integer=1)
\end{lstlisting}

Construct a matrix by repeating the given matrix (or vector) \texttt{m} times in dimension 1 and \texttt{n} times in dimension 2.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repmat([1, 2, 3], 2)
6-element Array{Int64,1}:
 1
 2
 3
 1
 2
 3

julia> repmat([1, 2, 3], 2, 3)
6×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L283-L309}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15426606278434194584}{} 
\hyperlink{15426606278434194584}{\texttt{Base.repeat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
repeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))
\end{lstlisting}

Construct an array by repeating the entries of \texttt{A}. The i-th element of \texttt{inner} specifies the number of times that the individual entries of the i-th dimension of \texttt{A} should be repeated. The i-th element of \texttt{outer} specifies the number of times that a slice along the i-th dimension of \texttt{A} should be repeated. If \texttt{inner} or \texttt{outer} are omitted, no repetition is performed.

\textbf{Examples}


\begin{minted}{jlcon}
julia> repeat(1:2, inner=2)
4-element Array{Int64,1}:
 1
 1
 2
 2

julia> repeat(1:2, outer=2)
4-element Array{Int64,1}:
 1
 2
 1
 2

julia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))
4×6 Array{Int64,2}:
 1  2  1  2  1  2
 1  2  1  2  1  2
 3  4  3  4  3  4
 3  4  3  4  3  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarraymath.jl#L337-L369}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14153417388267953812}{} 
\hyperlink{14153417388267953812}{\texttt{Base.kron}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
kron(A, B)
\end{lstlisting}

Kronecker tensor product of two vectors or two matrices.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia> B = [im 1; 1 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im

julia> kron(A, B)
4×4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L286-L311}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5571046194962336745}{} 
\hyperlink{5571046194962336745}{\texttt{Base.SparseArrays.blkdiag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
blkdiag(A...)
\end{lstlisting}

Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.

\textbf{Example}


\begin{minted}{jlcon}
julia> blkdiag(speye(3), 2*speye(2))
5×5 SparseMatrixCSC{Float64,Int64} with 5 stored entries:
  [1, 1]  =  1.0
  [2, 2]  =  1.0
  [3, 3]  =  1.0
  [4, 4]  =  2.0
  [5, 5]  =  2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sparse/sparsematrix.jl#L3083-L3098}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13181813568854970573}{} 
\hyperlink{13181813568854970573}{\texttt{Base.LinAlg.linreg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
linreg(x, y)
\end{lstlisting}

Perform simple linear regression using Ordinary Least Squares. Returns \texttt{a} and \texttt{b} such that \texttt{a + b*x} is the closest straight line to the given points \texttt{(x, y)}, i.e., such that the squared error between \texttt{y} and \texttt{a + b*x} is minimized.

\textbf{Examples:}


\begin{lstlisting}
using PyPlot
x = 1.0:12.0
y = [5.5, 6.3, 7.6, 8.8, 10.9, 11.79, 13.48, 15.02, 17.77, 20.81, 22.0, 22.99]
a, b = linreg(x, y)          # Linear regression
plot(x, y, "o")              # Plot (x, y) points
plot(x, a + b*x)             # Plot line determined by linear regression
\end{lstlisting}

See also:

\texttt{{\textbackslash}}, \hyperlink{17277490353628239858}{\texttt{cov}}, \hyperlink{8821409723106968118}{\texttt{std}}, \hyperlink{2002825322838319654}{\texttt{mean}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1048-L1068}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13066189226307440587}{} 
\hyperlink{13066189226307440587}{\texttt{Base.LinAlg.expm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
expm(A)
\end{lstlisting}

Compute the matrix exponential of \texttt{A}, defined by

\begin{equation*}
\begin{split}e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\end{split}\end{equation*}
For symmetric or Hermitian \texttt{A}, an eigendecomposition (\hyperlink{18133897359296222402}{\texttt{eigfact}}) is used, otherwise the scaling and squaring algorithm (see \footnotemark[8]) is chosen.

\footnotetext[8]{Nicholas J. Higham, {\textquotedbl}The squaring and scaling method for the matrix exponential revisited{\textquotedbl}, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. \href{http://dx.doi.org/10.1137/090768539}{doi:10.1137/090768539}

}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = eye(2, 2)
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0

julia> expm(A)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L395-L422}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11595351670694268933}{} 
\hyperlink{11595351670694268933}{\texttt{Base.LinAlg.logm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logm(A{T}::StridedMatrix{T})
\end{lstlisting}

If \texttt{A} has no negative real eigenvalue, compute the principal matrix logarithm of \texttt{A}, i.e. the unique matrix \(X\) such that \(e^X = A\) and \(-\pi < Im(\lambda) < \pi\) for all the eigenvalues \(\lambda\) of \(X\). If \texttt{A} has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{18133897359296222402}{\texttt{eigfact}}) is used, if \texttt{A} is triangular an improved version of the inverse scaling and squaring method is employed (see \footnotemark[9] and \footnotemark[10]). For general matrices, the complex Schur form (\hyperlink{5448411964655904748}{\texttt{schur}}) is computed and the triangular algorithm is used on the triangular factor.

\footnotetext[9]{Awad H. Al-Mohy and Nicholas J. Higham, {\textquotedbl}Improved inverse  scaling and squaring algorithms for the matrix logarithm{\textquotedbl}, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. \href{http://dx.doi.org/10.1137/110852553}{doi:10.1137/110852553}

}
\footnotetext[10]{Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, {\textquotedbl}Computing the Fréchet derivative of the matrix logarithm and estimating the condition number{\textquotedbl}, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. \href{http://dx.doi.org/10.1137/120885991}{doi:10.1137/120885991}

}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = 2.7182818 * eye(2)
2×2 Array{Float64,2}:
 2.71828  0.0
 0.0      2.71828

julia> logm(A)
2×2 Symmetric{Float64,Array{Float64,2}}:
 1.0  0.0
 0.0  1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L522-L553}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16982789562347489346}{} 
\hyperlink{16982789562347489346}{\texttt{Base.LinAlg.sqrtm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sqrtm(A)
\end{lstlisting}

If \texttt{A} has no negative real eigenvalues, compute the principal matrix square root of \texttt{A}, that is the unique matrix \(X\) with eigenvalues having positive real part such that \(X^2 = A\). Otherwise, a nonprincipal square root is returned.

If \texttt{A} is symmetric or Hermitian, its eigendecomposition (\hyperlink{18133897359296222402}{\texttt{eigfact}}) is used to compute the square root. Otherwise, the square root is determined by means of the Björck-Hammarling method \footnotemark[11], which computes the complex Schur form (\hyperlink{5448411964655904748}{\texttt{schur}}) and then the complex square root of the triangular factor.

\footnotetext[11]{Åke Björck and Sven Hammarling, {\textquotedbl}A Schur method for the square root of a matrix{\textquotedbl}, Linear Algebra and its Applications, 52-53, 1983, 127-140. \href{http://dx.doi.org/10.1016/0024-3795(83)80010-X}{doi:10.1016/0024-3795(83)80010-X}

}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = [4 0; 0 4]
2×2 Array{Int64,2}:
 4  0
 0  4

julia> sqrtm(A)
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L589-L620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3402540698228000668}{} 
\hyperlink{3402540698228000668}{\texttt{Base.LinAlg.lyap}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lyap(A, C)
\end{lstlisting}

Computes the solution \texttt{X} to the continuous Lyapunov equation \texttt{AX + XA{\textquotesingle} + C = 0}, where no eigenvalue of \texttt{A} has a zero real part and no two eigenvalues are negative complex conjugates of each other.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L946-L952}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4391412007091353668}{} 
\hyperlink{4391412007091353668}{\texttt{Base.LinAlg.sylvester}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sylvester(A, B, C)
\end{lstlisting}

Computes the solution \texttt{X} to the Sylvester equation \texttt{AX + XB + C = 0}, where \texttt{A}, \texttt{B} and \texttt{C} have compatible dimensions and \texttt{A} and \texttt{-B} have no eigenvalues with equal real part.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L926-L931}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16421003133250542616}{} 
\hyperlink{16421003133250542616}{\texttt{Base.LinAlg.issymmetric}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issymmetric(A) -> Bool
\end{lstlisting}

Test whether a matrix is symmetric.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> issymmetric(a)
true

julia> b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia> issymmetric(b)
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L867-L891}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10141753772895527781}{} 
\hyperlink{10141753772895527781}{\texttt{Base.LinAlg.isposdef}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isposdef(A) -> Bool
\end{lstlisting}

Test whether a matrix is positive definite.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia> isposdef(A)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L60-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8559510279500369522}{} 
\hyperlink{8559510279500369522}{\texttt{Base.LinAlg.isposdef!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isposdef!(A) -> Bool
\end{lstlisting}

Test whether a matrix is positive definite, overwriting \texttt{A} in the process.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1. 2.; 2. 50.];

julia> isposdef!(A)
true

julia> A
2×2 Array{Float64,2}:
 1.0  2.0
 2.0  6.78233
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/dense.jl#L35-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7162781971755030893}{} 
\hyperlink{7162781971755030893}{\texttt{Base.LinAlg.istril}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istril(A) -> Bool
\end{lstlisting}

Test whether a matrix is lower triangular.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> istril(a)
false

julia> b = [1 0; -im -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+0im
 0-1im  -1+0im

julia> istril(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L982-L1006}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8482220121253669068}{} 
\hyperlink{8482220121253669068}{\texttt{Base.LinAlg.istriu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istriu(A) -> Bool
\end{lstlisting}

Test whether a matrix is upper triangular.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> istriu(a)
false

julia> b = [1 im; 0 -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+1im
 0+0im  -1+0im

julia> istriu(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L947-L971}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15753182127953060317}{} 
\hyperlink{15753182127953060317}{\texttt{Base.LinAlg.isdiag}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdiag(A) -> Bool
\end{lstlisting}

Test whether a matrix is diagonal.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> isdiag(a)
false

julia> b = [im 0; 0 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  0+0im
 0+0im  0-1im

julia> isdiag(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1017-L1041}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12800362927453768899}{} 
\hyperlink{12800362927453768899}{\texttt{Base.LinAlg.ishermitian}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ishermitian(A) -> Bool
\end{lstlisting}

Test whether a matrix is Hermitian.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia> ishermitian(a)
true

julia> b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia> ishermitian(b)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L907-L931}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16991298248158657849}{} 
\hyperlink{16991298248158657849}{\texttt{Base.LinAlg.RowVector}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RowVector(vector)
\end{lstlisting}

A lazy-view wrapper of an \texttt{AbstractVector}, which turns a length-\texttt{n} vector into a \texttt{1×n} shaped row vector and represents the transpose of a vector (the elements are also transposed recursively). This type is usually constructed (and unwrapped) via the \hyperlink{12700837529519091997}{\texttt{transpose}} function or \texttt{.{\textquotesingle}} operator (or related \hyperlink{5848887074375173050}{\texttt{ctranspose}} or \texttt{{\textquotesingle}} operator).

By convention, a vector can be multiplied by a matrix on its left (\texttt{A * v}) whereas a row vector can be multiplied by a matrix on its right (such that \texttt{v.{\textquotesingle} * A = (A.{\textquotesingle} * v).{\textquotesingle}}). It differs from a \texttt{1×n}-sized matrix by the facts that its transpose returns a vector and the inner product \texttt{v1.{\textquotesingle} * v2} returns a scalar, but will otherwise behave similarly.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/rowvector.jl#L3-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5185144354217809072}{} 
\hyperlink{5185144354217809072}{\texttt{Base.LinAlg.ConjArray}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ConjArray(array)
\end{lstlisting}

A lazy-view wrapper of an \texttt{AbstractArray}, taking the elementwise complex conjugate. This type is usually constructed (and unwrapped) via the \hyperlink{9940023991150673697}{\texttt{conj}} function (or related \hyperlink{5848887074375173050}{\texttt{ctranspose}}), but currently this is the default behavior for \texttt{RowVector} only. For other arrays, the \texttt{ConjArray} constructor can be used directly.

\textbf{Examples}


\begin{minted}{jlcon}
julia> [1+im, 1-im]'
1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:
 1-1im  1+1im

julia> ConjArray([1+im 0; 0 1-im])
2×2 ConjArray{Complex{Int64},2,Array{Complex{Int64},2}}:
 1-1im  0+0im
 0+0im  1+1im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/conjarray.jl#L3-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12700837529519091997}{} 
\hyperlink{12700837529519091997}{\texttt{Base.transpose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
transpose(A::AbstractMatrix)
\end{lstlisting}

The transposition operator (\texttt{.{\textquotesingle}}).

\textbf{Example}


\begin{minted}{jlcon}
julia> A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia> transpose(A)
3×3 Array{Int64,2}:
 1  4  7
 2  5  8
 3  6  9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/transpose.jl#L97-L117}{\texttt{source}}



\begin{lstlisting}
transpose(v::AbstractVector)
\end{lstlisting}

The transposition operator (\texttt{.{\textquotesingle}}).

\textbf{Example}


\begin{minted}{jlcon}
julia> v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia> transpose(v)
1×3 RowVector{Int64,Array{Int64,1}}:
 1  2  3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/rowvector.jl#L59-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11995796242466841038}{} 
\hyperlink{11995796242466841038}{\texttt{Base.LinAlg.transpose!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
transpose!(dest,src)
\end{lstlisting}

Transpose array \texttt{src} and store the result in the preallocated array \texttt{dest}, which should have a size corresponding to \texttt{(size(src,2),size(src,1))}. No in-place transposition is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/transpose.jl#L8-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5848887074375173050}{} 
\hyperlink{5848887074375173050}{\texttt{Base.ctranspose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ctranspose(A)
\end{lstlisting}

The conjugate transposition operator (\texttt{{\textquotesingle}}).

\textbf{Example}


\begin{minted}{jlcon}
julia> A =  [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia> ctranspose(A)
2×2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L689-L707}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7273872285269730754}{} 
\hyperlink{7273872285269730754}{\texttt{Base.LinAlg.ctranspose!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ctranspose!(dest,src)
\end{lstlisting}

Conjugate transpose array \texttt{src} and store the result in the preallocated array \texttt{dest}, which should have a size corresponding to \texttt{(size(src,2),size(src,1))}. No in-place transposition is supported and unexpected results will happen if \texttt{src} and \texttt{dest} have overlapping memory regions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/transpose.jl#L18-L25}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2661699301071873867}{} 
\hyperlink{2661699301071873867}{\texttt{Base.LinAlg.eigs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigs(A; nev=6, ncv=max(20,2*nev+1), which=:LM, tol=0.0, maxiter=300, sigma=nothing, ritzvec=true, v0=zeros((0,))) -> (d,[v,],nconv,niter,nmult,resid)
\end{lstlisting}

Computes eigenvalues \texttt{d} of \texttt{A} using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.

The following keyword arguments are supported:

\begin{itemize}
\item \texttt{nev}: Number of eigenvalues


\item \texttt{ncv}: Number of Krylov vectors used in the computation; should satisfy \texttt{nev+1 <= ncv <= n} for real symmetric problems and \texttt{nev+2 <= ncv <= n} for other problems, where \texttt{n} is the size of the input matrix \texttt{A}. The default is \texttt{ncv = max(20,2*nev+1)}. Note that these restrictions limit the input matrix \texttt{A} to be of dimension at least 2.


\item \texttt{which}: type of eigenvalues to compute. See the note below.

\end{itemize}

\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{which} & type of eigenvalues \\
\hline
\texttt{:LM} & eigenvalues of largest magnitude (default) \\
\hline
\texttt{:SM} & eigenvalues of smallest magnitude \\
\hline
\texttt{:LR} & eigenvalues of largest real part \\
\hline
\texttt{:SR} & eigenvalues of smallest real part \\
\hline
\texttt{:LI} & eigenvalues of largest imaginary part (nonsymmetric or complex \texttt{A} only) \\
\hline
\texttt{:SI} & eigenvalues of smallest imaginary part (nonsymmetric or complex \texttt{A} only) \\
\hline
\texttt{:BE} & compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric \texttt{A} only) \\
\hline
\end{tabulary}

\end{table}

\begin{itemize}
\item \texttt{tol}: parameter defining the relative tolerance for convergence of Ritz values (eigenvalue estimates).    A Ritz value \(θ\) is considered converged when its associated residual    is less than or equal to the product of \texttt{tol} and \(max(ɛ^{2/3}, |θ|)\),    where \texttt{ɛ = eps(real(eltype(A)))/2} is LAPACK{\textquotesingle}s machine epsilon.    The residual associated with \(θ\) and its corresponding Ritz vector \(v\)    is defined as the norm \(||Av - vθ||\).    The specified value of \texttt{tol} should be positive; otherwise, it is ignored    and \(ɛ\) is used instead.    Default: \(ɛ\).


\item \texttt{maxiter}: Maximum number of iterations (default = 300)


\item \texttt{sigma}: Specifies the level shift used in inverse iteration. If \texttt{nothing} (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to \texttt{sigma} using shift and invert iterations.


\item \texttt{ritzvec}: Returns the Ritz vectors \texttt{v} (eigenvectors) if \texttt{true}


\item \texttt{v0}: starting vector from which to start the iterations

\end{itemize}
\texttt{eigs} returns the \texttt{nev} requested eigenvalues in \texttt{d}, the corresponding Ritz vectors \texttt{v} (only if \texttt{ritzvec=true}), the number of converged eigenvalues \texttt{nconv}, the number of iterations \texttt{niter} and the number of matrix vector multiplications \texttt{nmult}, as well as the final residual vector \texttt{resid}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = spdiagm(1:4);

julia> λ, ϕ = eigs(A, nev = 2);

julia> λ
2-element Array{Float64,1}:
 4.0
 3.0
\end{minted}

\begin{quote}
\textbf{Note}

The \texttt{sigma} and \texttt{which} keywords interact: the description of eigenvalues searched for by \texttt{which} do \emph{not} necessarily refer to the eigenvalues of \texttt{A}, but rather the linear operator constructed by the specification of the iteration mode implied by \texttt{sigma}.


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\texttt{sigma} & iteration mode & \texttt{which} refers to eigenvalues of \\
\hline
\texttt{nothing} & ordinary (forward) & \(A\) \\
\hline
real or complex & inverse with level shift \texttt{sigma} & \((A - \sigma I )^{-1}\) \\
\hline
\end{tabulary}

\end{table}

\end{quote}
\begin{quote}
\textbf{Note}

Although \texttt{tol} has a default value, the best choice depends strongly on the matrix \texttt{A}. We recommend that users \_always\_ specify a value for \texttt{tol} which suits their specific needs.

For details of how the errors in the computed eigenvalues are estimated, see:

\begin{itemize}
\item B. N. Parlett, {\textquotedbl}The Symmetric Eigenvalue Problem{\textquotedbl}, SIAM: Philadelphia, 2/e (1998), Ch. 13.2, {\textquotedbl}Accessing Accuracy in Lanczos Problems{\textquotedbl}, pp. 290-292 ff.


\item R. B. Lehoucq and D. C. Sorensen, {\textquotedbl}Deflation Techniques for an Implicitly Restarted Arnoldi Iteration{\textquotedbl}, SIAM Journal on Matrix Analysis and Applications (1996), 17(4), 789–821.  doi:10.1137/S0895479895281484

\end{itemize}
\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/arnoldi.jl#L6-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7995348975812558417}{} 
\hyperlink{7995348975812558417}{\texttt{Base.LinAlg.eigs}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eigs(A, B; nev=6, ncv=max(20,2*nev+1), which=:LM, tol=0.0, maxiter=300, sigma=nothing, ritzvec=true, v0=zeros((0,))) -> (d,[v,],nconv,niter,nmult,resid)
\end{lstlisting}

Computes generalized eigenvalues \texttt{d} of \texttt{A} and \texttt{B} using implicitly restarted Lanczos or Arnoldi iterations for real symmetric or general nonsymmetric matrices respectively.

The following keyword arguments are supported:

\begin{itemize}
\item \texttt{nev}: Number of eigenvalues


\item \texttt{ncv}: Number of Krylov vectors used in the computation; should satisfy \texttt{nev+1 <= ncv <= n} for real symmetric problems and \texttt{nev+2 <= ncv <= n} for other problems, where \texttt{n} is the size of the input matrices \texttt{A} and \texttt{B}. The default is \texttt{ncv = max(20,2*nev+1)}. Note that these restrictions limit the input matrix \texttt{A} to be of dimension at least 2.


\item \texttt{which}: type of eigenvalues to compute. See the note below.

\end{itemize}

\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{which} & type of eigenvalues \\
\hline
\texttt{:LM} & eigenvalues of largest magnitude (default) \\
\hline
\texttt{:SM} & eigenvalues of smallest magnitude \\
\hline
\texttt{:LR} & eigenvalues of largest real part \\
\hline
\texttt{:SR} & eigenvalues of smallest real part \\
\hline
\texttt{:LI} & eigenvalues of largest imaginary part (nonsymmetric or complex \texttt{A} only) \\
\hline
\texttt{:SI} & eigenvalues of smallest imaginary part (nonsymmetric or complex \texttt{A} only) \\
\hline
\texttt{:BE} & compute half of the eigenvalues from each end of the spectrum, biased in favor of the high end. (real symmetric \texttt{A} only) \\
\hline
\end{tabulary}

\end{table}

\begin{itemize}
\item \texttt{tol}: relative tolerance used in the convergence criterion for eigenvalues, similar to    \texttt{tol} in the \hyperlink{2661699301071873867}{\texttt{eigs(A)}} method for the ordinary eigenvalue    problem, but effectively for the eigenvalues of \(B^{-1} A\) instead of \(A\).    See the documentation for the ordinary eigenvalue problem in    \hyperlink{2661699301071873867}{\texttt{eigs(A)}} and the accompanying note about \texttt{tol}.


\item \texttt{maxiter}: Maximum number of iterations (default = 300)


\item \texttt{sigma}: Specifies the level shift used in inverse iteration. If \texttt{nothing} (default), defaults to ordinary (forward) iterations. Otherwise, find eigenvalues close to \texttt{sigma} using shift and invert iterations.


\item \texttt{ritzvec}: Returns the Ritz vectors \texttt{v} (eigenvectors) if \texttt{true}


\item \texttt{v0}: starting vector from which to start the iterations

\end{itemize}
\texttt{eigs} returns the \texttt{nev} requested eigenvalues in \texttt{d}, the corresponding Ritz vectors \texttt{v} (only if \texttt{ritzvec=true}), the number of converged eigenvalues \texttt{nconv}, the number of iterations \texttt{niter} and the number of matrix vector multiplications \texttt{nmult}, as well as the final residual vector \texttt{resid}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A = speye(4, 4); B = spdiagm(1:4);

julia> λ, ϕ = eigs(A, B, nev = 2);

julia> λ
2-element Array{Float64,1}:
 1.0
 0.5
\end{minted}

\begin{quote}
\textbf{Note}

The \texttt{sigma} and \texttt{which} keywords interact: the description of eigenvalues searched for by \texttt{which} do \emph{not} necessarily refer to the eigenvalue problem \(Av = Bv\lambda\), but rather the linear operator constructed by the specification of the iteration mode implied by \texttt{sigma}.


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\texttt{sigma} & iteration mode & \texttt{which} refers to the problem \\
\hline
\texttt{nothing} & ordinary (forward) & \(Av = Bv\lambda\) \\
\hline
real or complex & inverse with level shift \texttt{sigma} & \((A - \sigma B )^{-1}B = v\nu\) \\
\hline
\end{tabulary}

\end{table}

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/arnoldi.jl#L105-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5570081548278801160}{} 
\hyperlink{5570081548278801160}{\texttt{Base.LinAlg.svds}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
svds(A; nsv=6, ritzvec=true, tol=0.0, maxiter=1000, ncv=2*nsv, u0=zeros((0,)), v0=zeros((0,))) -> (SVD([left_sv,] s, [right_sv,]), nconv, niter, nmult, resid)
\end{lstlisting}

Computes the largest singular values \texttt{s} of \texttt{A} using implicitly restarted Lanczos iterations derived from \hyperlink{2661699301071873867}{\texttt{eigs}}.

\textbf{Inputs}

\begin{itemize}
\item \texttt{A}: Linear operator whose singular values are desired. \texttt{A} may be represented as a subtype of \texttt{AbstractArray}, e.g., a sparse matrix, or any other type supporting the four methods \texttt{size(A)}, \texttt{eltype(A)}, \texttt{A * vector}, and \texttt{A{\textquotesingle} * vector}.


\item \texttt{nsv}: Number of singular values. Default: 6.


\item \texttt{ritzvec}: If \texttt{true}, return the left and right singular vectors \texttt{left\_sv} and \texttt{right\_sv}.  If \texttt{false}, omit the singular vectors. Default: \texttt{true}.


\item \texttt{tol}: tolerance, see \hyperlink{2661699301071873867}{\texttt{eigs}}.


\item \texttt{maxiter}: Maximum number of iterations, see \hyperlink{2661699301071873867}{\texttt{eigs}}. Default: 1000.


\item \texttt{ncv}: Maximum size of the Krylov subspace, see \hyperlink{2661699301071873867}{\texttt{eigs}} (there called \texttt{nev}). Default: \texttt{2*nsv}.


\item \texttt{u0}: Initial guess for the first left Krylov vector. It may have length \texttt{m} (the first dimension of \texttt{A}), or 0.


\item \texttt{v0}: Initial guess for the first right Krylov vector. It may have length \texttt{n} (the second dimension of \texttt{A}), or 0.

\end{itemize}
\textbf{Outputs}

\begin{itemize}
\item \texttt{svd}: An \texttt{SVD} object containing the left singular vectors, the requested values, and the right singular vectors. If \texttt{ritzvec = false}, the left and right singular vectors will be empty.


\item \texttt{nconv}: Number of converged singular values.


\item \texttt{niter}: Number of iterations.


\item \texttt{nmult}: Number of matrix–vector products used.


\item \texttt{resid}: Final residual vector.

\end{itemize}
\textbf{Example}


\begin{minted}{jlcon}
julia> A = spdiagm(1:4);

julia> s = svds(A, nsv = 2)[1];

julia> s[:S]
2-element Array{Float64,1}:
 4.0
 3.0
\end{minted}

\begin{quote}
\textbf{Implementation}

\texttt{svds(A)} is formally equivalent to calling \hyperlink{2661699301071873867}{\texttt{eigs}} to perform implicitly restarted Lanczos tridiagonalization on the Hermitian matrix \(\begin{pmatrix} 0 & A^\prime \\ A & 0 \end{pmatrix}\), whose eigenvalues are plus and minus the singular values of \(A\).

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/arnoldi.jl#L333-L381}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16557051226459637517}{} 
\hyperlink{16557051226459637517}{\texttt{Base.LinAlg.peakflops}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
peakflops(n::Integer=2000; parallel::Bool=false)
\end{lstlisting}

\texttt{peakflops} computes the peak flop rate of the computer by using double precision \hyperlink{17677151106024314777}{\texttt{gemm!}}. By default, if no arguments are specified, it multiplies a matrix of size \texttt{n x n}, where \texttt{n = 2000}. If the underlying BLAS is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with \hyperlink{3656432689516664548}{\texttt{BLAS.set\_num\_threads(n)}}.

If the keyword argument \texttt{parallel} is set to \texttt{true}, \texttt{peakflops} is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument \texttt{n} still refers to the size of the problem that is solved on each processor.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/generic.jl#L1103-L1116}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9786923620103438283}{}


\section{Operaciones matriciales de bajo nivel}



Las operaciones de matrices que involucran operaciones de transposición como \texttt{A{\textquotesingle} {\textbackslash} B} son convertidas por el analizador de Julia en llamadas a funciones especialmente nombradas como \hyperlink{9966202373988898888}{\texttt{Ac\_ldiv\_B}}. Si desea sobrecargar estas operaciones para sus propios tipos, le será útil conocer los nombres de estas funciones.



Además, en muchos casos, hay versiones in situ de operaciones matriciales que le permiten suministrar un vector o matriz de salida preasignada. Esto es útil cuando se optimiza código crítico para evitar la sobrecarga de las asignaciones repetidas. Estas operaciones in situ tienen el sufijo \texttt{!} a continuación (por ejemplo, \hyperlink{8969873939925166343}{\texttt{A\_mul\_B!}}) de acuerdo con la convención habitual de Julia.


\hypertarget{16784809286794154433}{} 
\hyperlink{16784809286794154433}{\texttt{Base.LinAlg.A\_ldiv\_B!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_ldiv_B!([Y,] A, B) -> Y
\end{lstlisting}

Compute \texttt{A {\textbackslash} B} in-place and store the result in \texttt{Y}, returning the result. If only two arguments are passed, then \texttt{A\_ldiv\_B!(A, B)} overwrites \texttt{B} with the result.

The argument \texttt{A} should \emph{not} be a matrix.  Rather, instead of matrices it should be a factorization object (e.g. produced by \hyperlink{10363263068585650380}{\texttt{factorize}} or \hyperlink{12805335348758675309}{\texttt{cholfact}}). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., \hyperlink{9520029296647984269}{\texttt{lufact!}}), and performance-critical situations requiring \texttt{A\_ldiv\_B!} usually also require fine-grained control over the factorization of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/factorization.jl#L63-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2226896762091701133}{} 
\hyperlink{2226896762091701133}{\texttt{Base.A\_ldiv\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_ldiv_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A\) {\textbackslash} \(Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16902725147803109549}{} 
\hyperlink{16902725147803109549}{\texttt{Base.A\_ldiv\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_ldiv_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A\) {\textbackslash} \(Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L827-L831}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8969873939925166343}{} 
\hyperlink{8969873939925166343}{\texttt{Base.LinAlg.A\_mul\_B!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_mul_B!(Y, A, B) -> Y
\end{lstlisting}

Calculates the matrix-matrix or matrix-vector product \(A⋅B\) and stores the result in \texttt{Y}, overwriting the existing value of \texttt{Y}. Note that \texttt{Y} must not be aliased with either \texttt{A} or \texttt{B}.

\textbf{Example}


\begin{minted}{jlcon}
julia> A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); A_mul_B!(Y, A, B);

julia> Y
2×2 Array{Float64,2}:
 3.0  3.0
 7.0  7.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/matmul.jl#L160-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16703425411548835564}{} 
\hyperlink{16703425411548835564}{\texttt{Base.A\_mul\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_mul_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A⋅Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L720-L724}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15013997067712207576}{} 
\hyperlink{15013997067712207576}{\texttt{Base.A\_mul\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_mul_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A⋅Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L741-L745}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6739172293198726371}{} 
\hyperlink{6739172293198726371}{\texttt{Base.A\_rdiv\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_rdiv_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A / Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L764-L768}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13605500069324358113}{} 
\hyperlink{13605500069324358113}{\texttt{Base.A\_rdiv\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
A_rdiv_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(A / Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L785-L789}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9966202373988898888}{} 
\hyperlink{9966202373988898888}{\texttt{Base.Ac\_ldiv\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_ldiv_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ\) {\textbackslash} \(B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L799-L803}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12173417613583933911}{} 
\hyperlink{12173417613583933911}{\texttt{Base.LinAlg.Ac\_ldiv\_B!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_ldiv_B!([Y,] A, B) -> Y
\end{lstlisting}

Similar to \hyperlink{16784809286794154433}{\texttt{A\_ldiv\_B!}}, but return \(Aᴴ\) {\textbackslash} \(B\), computing the result in-place in \texttt{Y} (or overwriting \texttt{B} if \texttt{Y} is not supplied).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/factorization.jl#L79-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17063845040932531598}{} 
\hyperlink{17063845040932531598}{\texttt{Base.Ac\_ldiv\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_ldiv_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ\) {\textbackslash} \(Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L813-L817}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12228791725837368547}{} 
\hyperlink{12228791725837368547}{\texttt{Base.Ac\_mul\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_mul_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ⋅B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L713-L717}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8302093914811646736}{} 
\hyperlink{8302093914811646736}{\texttt{Base.Ac\_mul\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_mul_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L727-L731}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9268374614432165456}{} 
\hyperlink{9268374614432165456}{\texttt{Base.Ac\_rdiv\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_rdiv_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ / B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L757-L761}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3522638395450403535}{} 
\hyperlink{3522638395450403535}{\texttt{Base.Ac\_rdiv\_Bc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ac_rdiv_Bc(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᴴ / Bᴴ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L771-L775}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9545826193986876343}{} 
\hyperlink{9545826193986876343}{\texttt{Base.At\_ldiv\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_ldiv_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ\) {\textbackslash} \(B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L820-L824}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5857267823705719337}{} 
\hyperlink{5857267823705719337}{\texttt{Base.LinAlg.At\_ldiv\_B!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_ldiv_B!([Y,] A, B) -> Y
\end{lstlisting}

Similar to \hyperlink{16784809286794154433}{\texttt{A\_ldiv\_B!}}, but return \(Aᵀ\) {\textbackslash} \(B\), computing the result in-place in \texttt{Y} (or overwriting \texttt{B} if \texttt{Y} is not supplied).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/factorization.jl#L87-L92}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13563153742436501281}{} 
\hyperlink{13563153742436501281}{\texttt{Base.At\_ldiv\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_ldiv_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ\) {\textbackslash} \(Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L834-L838}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9448174319368400769}{} 
\hyperlink{9448174319368400769}{\texttt{Base.At\_mul\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_mul_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ⋅B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L734-L738}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15605965573818503001}{} 
\hyperlink{15605965573818503001}{\texttt{Base.At\_mul\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_mul_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ⋅Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L748-L752}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16681540278405777694}{} 
\hyperlink{16681540278405777694}{\texttt{Base.At\_rdiv\_B}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_rdiv_B(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ / B\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L778-L782}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4109140714102921823}{} 
\hyperlink{4109140714102921823}{\texttt{Base.At\_rdiv\_Bt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
At_rdiv_Bt(A, B)
\end{lstlisting}

For matrices or vectors \(A\) and \(B\), calculates \(Aᵀ / Bᵀ\).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L792-L796}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5866228393923359741}{}


\section{Funciones BLAS}



En Julia (como en gran parte de la computación científica), las operaciones de álgebra lineal densa se basan en la \href{http://www.netlib.org/lapack/}{biblioteca LAPACK}, que a su vez se construye sobre bloques de construcción básicos de álgebra lineal conocidos como \href{http://www.netlib.org/blas/}{BLAS}. Hay implementaciones altamente optimizadas de BLAS disponibles para cada arquitectura de computadora, y algunas veces en rutinas de álgebra lineal de alto rendimiento, es útil llamar directamente a las funciones de BLAS.



\texttt{Base.LinAlg.BLAS} proporciona envoltorios para algunas de las funciones de BLAS. Esas funciones de BLAS que sobrescriben una de las matrices de entrada tienen nombres que terminan en \texttt{{\textquotesingle}!{\textquotesingle}}. Normalmente, una función BLAS tiene cuatro métodos definidos, para los arrays \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \texttt{Complex128} y\texttt{Complex64}.



\hypertarget{11073177327200670825}{}


\subsection{Argumentos de tipo carácter en BLAS}



Muchas funciones BLAS aceptan argumentos que determinan si se debe transponer un argumento (\texttt{trans}), qué triángulo de una matriz referenciar (\texttt{uplo} o \texttt{ul}), si se puede suponer que la diagonal de una matriz triangular está formada por unos (\texttt{dA}) o a qué lado de una multiplicación de matrices pertenece el argumento de entrada (\texttt{side}). Las posibilidades son:



\hypertarget{1714685266370616361}{}


\subsubsection{Orden de Multiplicación}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{side} & Significado \\
\hline
\texttt{{\textquotesingle}L{\textquotesingle}} & El argumento va al lado \emph{izquierdo} de una operación matriz-matriz. \\
\hline
\texttt{{\textquotesingle}R{\textquotesingle}} & El argumento va al lado \emph{derecho} de una operación matriz-matriz. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{5558887752259302145}{}


\subsubsection{Referencia sobre el Triángulo}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{uplo}/\texttt{ul} & Significado \\
\hline
\texttt{{\textquotesingle}U{\textquotesingle}}       & Solo se usará el triángulo \emph{superior} de la matriz. \\
\hline
\texttt{{\textquotesingle}L{\textquotesingle}} & Solo se usará el triángulo \emph{inferior} de la matriz. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{13285421231458545876}{}


\subsubsection{Operación de Transposición}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{trans}/\texttt{tX} & Significado \\
\hline
\texttt{{\textquotesingle}N{\textquotesingle}} & La matriz de entrada \texttt{X} no es transpuesta ni conjugada. \\
\hline
\texttt{{\textquotesingle}T{\textquotesingle}}       & La matriz de entrada \texttt{X} será transpuesta.              \\
\hline
\texttt{{\textquotesingle}C{\textquotesingle}}       & La matriz de entrada \texttt{X} será conjugada y transpuesta. \\
\hline
\end{tabulary}

\end{table}



\hypertarget{11643333471578083521}{}


\subsubsection{Unidades en la Diagonal}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\texttt{diag}/\texttt{dX} & Significado \\
\hline
\texttt{{\textquotesingle}N{\textquotesingle}}       & Los valores diagonales de la matriz \texttt{X} serán leídos. \\
\hline
\texttt{{\textquotesingle}U{\textquotesingle}} & Se supone que los elementos de la diagonal de la matriz \texttt{X} son todos unos. \\
\hline
\end{tabulary}

\end{table}


\hypertarget{11889274140090253372}{} 
\hyperlink{11889274140090253372}{\texttt{Base.LinAlg.BLAS.dotu}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dotu(n, X, incx, Y, incy)
\end{lstlisting}

Dot function for two complex vectors consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{Y} with stride \texttt{incy}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> Base.BLAS.dotu(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)
-10.0 + 10.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L242-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1117830083282379909}{} 
\hyperlink{1117830083282379909}{\texttt{Base.LinAlg.BLAS.dotc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dotc(n, X, incx, U, incy)
\end{lstlisting}

Dot function for two complex vectors, consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx} and \texttt{n} elements of array \texttt{U} with stride \texttt{incy}, conjugating the first vector.

\textbf{Example:}


\begin{minted}{jlcon}
julia> Base.BLAS.dotc(10, im*ones(10), 1, complex.(ones(20), ones(20)), 2)
10.0 - 10.0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L227-L239}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2147220473907622621}{} 
\hyperlink{2147220473907622621}{\texttt{Base.LinAlg.BLAS.blascopy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
blascopy!(n, X, incx, Y, incy)
\end{lstlisting}

Copy \texttt{n} elements of array \texttt{X} with stride \texttt{incx} to array \texttt{Y} with stride \texttt{incy}. Returns \texttt{Y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L157-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14459800598483653560}{} 
\hyperlink{14459800598483653560}{\texttt{Base.LinAlg.BLAS.nrm2}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nrm2(n, X, incx)
\end{lstlisting}

2-norm of a vector consisting of \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> Base.BLAS.nrm2(4, ones(8), 2)
2.0

julia> Base.BLAS.nrm2(1, ones(8), 2)
1.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L335-L348}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13029615432404336289}{} 
\hyperlink{13029615432404336289}{\texttt{Base.LinAlg.BLAS.asum}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
asum(n, X, incx)
\end{lstlisting}

Sum of the absolute values of the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> Base.BLAS.asum(5, im*ones(10), 2)
5.0

julia> Base.BLAS.asum(2, im*ones(10), 5)
2.0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L368-L381}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7655786041748989730}{} 
\hyperlink{7655786041748989730}{\texttt{Base.LinAlg.axpy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
axpy!(a, X, Y)
\end{lstlisting}

Overwrite \texttt{Y} with \texttt{a*X + Y}, where \texttt{a} is a scalar. Returns \texttt{Y}.

\textbf{Example:}


\begin{minted}{jlcon}
julia> x = [1; 2; 3];

julia> y = [4; 5; 6];

julia> Base.BLAS.axpy!(2, x, y)
3-element Array{Int64,1}:
  6
  9
 12
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L401-L418}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8034221977708289638}{} 
\hyperlink{8034221977708289638}{\texttt{Base.LinAlg.BLAS.scal!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
scal!(n, a, X, incx)
\end{lstlisting}

Overwrite \texttt{X} with \texttt{a*X} for the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}. Returns \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L181-L185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5238599898608873752}{} 
\hyperlink{5238599898608873752}{\texttt{Base.LinAlg.BLAS.scal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
scal(n, a, X, incx)
\end{lstlisting}

Returns \texttt{X} scaled by \texttt{a} for the first \texttt{n} elements of array \texttt{X} with stride \texttt{incx}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L188-L192}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15135255339747177789}{} 
\hyperlink{15135255339747177789}{\texttt{Base.LinAlg.BLAS.ger!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ger!(alpha, x, y, A)
\end{lstlisting}

Rank-1 update of the matrix \texttt{A} with vectors \texttt{x} and \texttt{y} as \texttt{alpha*x*y{\textquotesingle} + A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L904-L908}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12883861850425780126}{} 
\hyperlink{12883861850425780126}{\texttt{Base.LinAlg.BLAS.syr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syr!(uplo, alpha, x, A)
\end{lstlisting}

Rank-1 update of the symmetric matrix \texttt{A} with vector \texttt{x} as \texttt{alpha*x*x.{\textquotesingle} + A}. \hyperlink{5558887752259302145}{\texttt{uplo}} controls which triangle of \texttt{A} is updated. Returns \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L935-L940}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2548146220821159778}{} 
\hyperlink{2548146220821159778}{\texttt{Base.LinAlg.BLAS.syrk!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syrk!(uplo, trans, alpha, A, beta, C)
\end{lstlisting}

Rank-k update of the symmetric matrix \texttt{C} as \texttt{alpha*A*A.{\textquotesingle} + beta*C} or \texttt{alpha*A.{\textquotesingle}*A + beta*C} according to \hyperlink{13285421231458545876}{\texttt{trans}}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{C} is used. Returns \texttt{C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1169-L1175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13379346712428626149}{} 
\hyperlink{13379346712428626149}{\texttt{Base.LinAlg.BLAS.syrk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syrk(uplo, trans, alpha, A)
\end{lstlisting}

Returns either the upper triangle or the lower triangle of \texttt{A}, according to \hyperlink{5558887752259302145}{\texttt{uplo}}, of \texttt{alpha*A*A.{\textquotesingle}} or \texttt{alpha*A.{\textquotesingle}*A}, according to \hyperlink{13285421231458545876}{\texttt{trans}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1178-L1185}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4035484492260995504}{} 
\hyperlink{4035484492260995504}{\texttt{Base.LinAlg.BLAS.her!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
her!(uplo, alpha, x, A)
\end{lstlisting}

Methods for complex arrays only. Rank-1 update of the Hermitian matrix \texttt{A} with vector \texttt{x} as \texttt{alpha*x*x{\textquotesingle} + A}. \hyperlink{5558887752259302145}{\texttt{uplo}} controls which triangle of \texttt{A} is updated. Returns \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L965-L971}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9755412184209766372}{} 
\hyperlink{9755412184209766372}{\texttt{Base.LinAlg.BLAS.herk!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
herk!(uplo, trans, alpha, A, beta, C)
\end{lstlisting}

Methods for complex arrays only. Rank-k update of the Hermitian matrix \texttt{C} as \texttt{alpha*A*A{\textquotesingle} + beta*C} or \texttt{alpha*A{\textquotesingle}*A + beta*C} according to \hyperlink{13285421231458545876}{\texttt{trans}}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{C} is updated. Returns \texttt{C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1225-L1232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12918577395560718283}{} 
\hyperlink{12918577395560718283}{\texttt{Base.LinAlg.BLAS.herk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
herk(uplo, trans, alpha, A)
\end{lstlisting}

Methods for complex arrays only. Returns the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{alpha*A*A{\textquotesingle}} or \texttt{alpha*A{\textquotesingle}*A}, according to \hyperlink{13285421231458545876}{\texttt{trans}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1235-L1241}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18085399308967465076}{} 
\hyperlink{18085399308967465076}{\texttt{Base.LinAlg.BLAS.gbmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)
\end{lstlisting}

Update vector \texttt{y} as \texttt{alpha*A*x + beta*y} or \texttt{alpha*A{\textquotesingle}*x + beta*y} according to \hyperlink{13285421231458545876}{\texttt{trans}}. The matrix \texttt{A} is a general band matrix of dimension \texttt{m} by \texttt{size(A,2)} with \texttt{kl} sub-diagonals and \texttt{ku} super-diagonals. \texttt{alpha} and \texttt{beta} are scalars. Returns the updated \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L547-L553}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4457861111732227628}{} 
\hyperlink{4457861111732227628}{\texttt{Base.LinAlg.BLAS.gbmv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gbmv(trans, m, kl, ku, alpha, A, x)
\end{lstlisting}

Returns \texttt{alpha*A*x} or \texttt{alpha*A{\textquotesingle}*x} according to \hyperlink{13285421231458545876}{\texttt{trans}}. The matrix \texttt{A} is a general band matrix of dimension \texttt{m} by \texttt{size(A,2)} with \texttt{kl} sub-diagonals and \texttt{ku} super-diagonals, and \texttt{alpha} is a scalar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L556-L562}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7105836662435355100}{} 
\hyperlink{7105836662435355100}{\texttt{Base.LinAlg.BLAS.sbmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sbmv!(uplo, k, alpha, A, x, beta, y)
\end{lstlisting}

Update vector \texttt{y} as \texttt{alpha*A*x + beta*y} where \texttt{A} is a a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. The storage layout for \texttt{A} is described the reference BLAS module, level-2 BLAS at \href{http://www.netlib.org/lapack/explore-html/}{http://www.netlib.org/lapack/explore-html/}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{A} is used.

Returns the updated \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L754-L764}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14656835492454293190}{} 
\hyperlink{14656835492454293190}{\texttt{Base.LinAlg.BLAS.sbmv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sbmv(uplo, k, alpha, A, x)
\end{lstlisting}

Returns \texttt{alpha*A*x} where \texttt{A} is a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L736-L742}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3096938461244060610}{} 
\hyperlink{3096938461244060610}{\texttt{Base.LinAlg.BLAS.sbmv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sbmv(uplo, k, A, x)
\end{lstlisting}

Returns \texttt{A*x} where \texttt{A} is a symmetric band matrix of order \texttt{size(A,2)} with \texttt{k} super-diagonals stored in the argument \texttt{A}. Only the \hyperlink{5558887752259302145}{\texttt{uplo}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L745-L751}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17677151106024314777}{} 
\hyperlink{17677151106024314777}{\texttt{Base.LinAlg.BLAS.gemm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemm!(tA, tB, alpha, A, B, beta, C)
\end{lstlisting}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or the other three variants according to \hyperlink{13285421231458545876}{\texttt{tA}} and \texttt{tB}. Returns the updated \texttt{C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L995-L1000}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9806047320196917327}{} 
\hyperlink{9806047320196917327}{\texttt{Base.LinAlg.BLAS.gemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemm(tA, tB, alpha, A, B)
\end{lstlisting}

Returns \texttt{alpha*A*B} or the other three variants according to \hyperlink{13285421231458545876}{\texttt{tA}} and \texttt{tB}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1047-L1051}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12613348301316395147}{} 
\hyperlink{12613348301316395147}{\texttt{Base.LinAlg.BLAS.gemm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemm(tA, tB, A, B)
\end{lstlisting}

Returns \texttt{A*B} or the other three variants according to \hyperlink{13285421231458545876}{\texttt{tA}} and \texttt{tB}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1054-L1058}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15736921977878661892}{} 
\hyperlink{15736921977878661892}{\texttt{Base.LinAlg.BLAS.gemv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemv!(tA, alpha, A, x, beta, y)
\end{lstlisting}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y} or \texttt{alpha*A{\textquotesingle}x + beta*y} according to \hyperlink{13285421231458545876}{\texttt{tA}}. \texttt{alpha} and \texttt{beta} are scalars. Returns the updated \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L521-L527}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8862317315303978311}{} 
\hyperlink{8862317315303978311}{\texttt{Base.LinAlg.BLAS.gemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemv(tA, alpha, A, x)
\end{lstlisting}

Returns \texttt{alpha*A*x} or \texttt{alpha*A{\textquotesingle}x} according to \hyperlink{13285421231458545876}{\texttt{tA}}. \texttt{alpha} is a scalar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L530-L535}{\texttt{source}}


\end{adjustwidth}
\hypertarget{918742973862313004}{} 
\hyperlink{918742973862313004}{\texttt{Base.LinAlg.BLAS.gemv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemv(tA, A, x)
\end{lstlisting}

Returns \texttt{A*x} or \texttt{A{\textquotesingle}x} according to \hyperlink{13285421231458545876}{\texttt{tA}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L538-L542}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11740755051464065516}{} 
\hyperlink{11740755051464065516}{\texttt{Base.LinAlg.BLAS.symm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symm!(side, ul, alpha, A, B, beta, C)
\end{lstlisting}

Update \texttt{C} as \texttt{alpha*A*B + beta*C} or \texttt{alpha*B*A + beta*C} according to \hyperlink{1714685266370616361}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. Returns the updated \texttt{C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1120-L1126}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10057539686574772151}{} 
\hyperlink{10057539686574772151}{\texttt{Base.LinAlg.BLAS.symm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symm(side, ul, alpha, A, B)
\end{lstlisting}

Returns \texttt{alpha*A*B} or \texttt{alpha*B*A} according to \hyperlink{1714685266370616361}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1102-L1108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6490716086535561768}{} 
\hyperlink{6490716086535561768}{\texttt{Base.LinAlg.BLAS.symm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symm(side, ul, A, B)
\end{lstlisting}

Returns \texttt{A*B} or \texttt{B*A} according to \hyperlink{1714685266370616361}{\texttt{side}}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1111-L1117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17354973722854633644}{} 
\hyperlink{17354973722854633644}{\texttt{Base.LinAlg.BLAS.symv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symv!(ul, alpha, A, x, beta, y)
\end{lstlisting}

Update the vector \texttt{y} as \texttt{alpha*A*x + beta*y}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} and \texttt{beta} are scalars. Returns the updated \texttt{y}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L601-L607}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1810587260758706176}{} 
\hyperlink{1810587260758706176}{\texttt{Base.LinAlg.BLAS.symv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symv(ul, alpha, A, x)
\end{lstlisting}

Returns \texttt{alpha*A*x}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \texttt{alpha} is a scalar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L652-L658}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11472950060043351908}{} 
\hyperlink{11472950060043351908}{\texttt{Base.LinAlg.BLAS.symv}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symv(ul, A, x)
\end{lstlisting}

Returns \texttt{A*x}. \texttt{A} is assumed to be symmetric. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L661-L666}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8221607203586908061}{} 
\hyperlink{8221607203586908061}{\texttt{Base.LinAlg.BLAS.trmm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trmm!(side, ul, tA, dA, alpha, A, B)
\end{lstlisting}

Update \texttt{B} as \texttt{alpha*A*B} or one of the other three variants determined by \hyperlink{1714685266370616361}{\texttt{side}} and \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{B}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1358-L1367}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3965394372558143122}{} 
\hyperlink{3965394372558143122}{\texttt{Base.LinAlg.BLAS.trmm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trmm(side, ul, tA, dA, alpha, A, B)
\end{lstlisting}

Returns \texttt{alpha*A*B} or one of the other three variants determined by \hyperlink{1714685266370616361}{\texttt{side}} and \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1370-L1378}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6978592120332459126}{} 
\hyperlink{6978592120332459126}{\texttt{Base.LinAlg.BLAS.trsm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsm!(side, ul, tA, dA, alpha, A, B)
\end{lstlisting}

Overwrite \texttt{B} with the solution to \texttt{A*X = alpha*B} or one of the other three variants determined by \hyperlink{1714685266370616361}{\texttt{side}} and \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{B}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1381-L1390}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2754002660974992741}{} 
\hyperlink{2754002660974992741}{\texttt{Base.LinAlg.BLAS.trsm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsm(side, ul, tA, dA, alpha, A, B)
\end{lstlisting}

Returns the solution to \texttt{A*X = alpha*B} or one of the other three variants determined by determined by \hyperlink{1714685266370616361}{\texttt{side}} and \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L1393-L1401}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12134943925780536161}{} 
\hyperlink{12134943925780536161}{\texttt{Base.LinAlg.BLAS.trmv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trmv!(ul, tA, dA, A, b)
\end{lstlisting}

Returns \texttt{op(A)*b}, where \texttt{op} is determined by \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. The multiplication occurs in-place on \texttt{b}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L810-L818}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9978918795033628060}{} 
\hyperlink{9978918795033628060}{\texttt{Base.LinAlg.BLAS.trmv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trmv(ul, tA, dA, A, b)
\end{lstlisting}

Returns \texttt{op(A)*b}, where \texttt{op} is determined by \hyperlink{13285421231458545876}{\texttt{tA}}. Only the \hyperlink{5558887752259302145}{\texttt{ul}} triangle of \texttt{A} is used. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L800-L807}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5394944235299548168}{} 
\hyperlink{5394944235299548168}{\texttt{Base.LinAlg.BLAS.trsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsv!(ul, tA, dA, A, b)
\end{lstlisting}

Overwrite \texttt{b} with the solution to \texttt{A*x = b} or one of the other two variants determined by \hyperlink{13285421231458545876}{\texttt{tA}} and \hyperlink{5558887752259302145}{\texttt{ul}}. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones. Returns the updated \texttt{b}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L852-L860}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17554193298347663786}{} 
\hyperlink{17554193298347663786}{\texttt{Base.LinAlg.BLAS.trsv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsv(ul, tA, dA, A, b)
\end{lstlisting}

Returns the solution to \texttt{A*x = b} or one of the other two variants determined by \hyperlink{13285421231458545876}{\texttt{tA}} and \hyperlink{5558887752259302145}{\texttt{ul}}. \hyperlink{11643333471578083521}{\texttt{dA}} determines if the diagonal values are read or are assumed to be all ones.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L863-L870}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3656432689516664548}{} 
\hyperlink{3656432689516664548}{\texttt{Base.LinAlg.BLAS.set\_num\_threads}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
set_num_threads(n)
\end{lstlisting}

Set the number of threads the BLAS library should use.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/blas.jl#L89-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9063715718865527930}{} 
\hyperlink{9063715718865527930}{\texttt{Base.LinAlg.I}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
I
\end{lstlisting}

An object of type \texttt{UniformScaling}, representing an identity matrix of any size.

\textbf{Example}


\begin{minted}{jlcon}
julia> ones(5, 6) * I == ones(5, 6)
true

julia> [1 2im 3; 1im 2 3] * I
2×3 Array{Complex{Int64},2}:
 1+0im  0+2im  3+0im
 0+1im  2+0im  3+0im
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/uniformscaling.jl#L11-L27}{\texttt{source}}


\end{adjustwidth}

\hypertarget{435081460865951048}{}


\section{Funciones LAPACK}



\texttt{Base.LinAlg.LAPACK} proporciona \emph{wrappers} para algunas de las funciones LAPACK para álgebra lineal. Las funciones que sobrescriben una de las matrices de entrada tienen nombres que terminan en \texttt{{\textquotesingle}!{\textquotesingle}}.



Por lo general, una función tiene 4 métodos definidos, uno para los arrays \hyperlink{5027751419500983000}{\texttt{Float64}}, \hyperlink{8101639384272933082}{\texttt{Float32}}, \texttt{Complex128} y \texttt{Complex64}.



Tenga en cuenta que la API LAPACK proporcionada por Julia puede y va a cambiar en el futuro. Dado que esta API no está orientada al usuario, no existe el compromiso de admitir/desaprobar este conjunto específico de funciones en futuras versiones.


\hypertarget{13382327346146829732}{} 
\hyperlink{13382327346146829732}{\texttt{Base.LinAlg.LAPACK.gbtrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gbtrf!(kl, ku, m, AB) -> (AB, ipiv)
\end{lstlisting}

Compute the LU factorization of a banded matrix \texttt{AB}. \texttt{kl} is the first subdiagonal containing a nonzero band, \texttt{ku} is the last superdiagonal containing one, and \texttt{m} is the first dimension of the matrix \texttt{AB}. Returns the LU factorization in-place and \texttt{ipiv}, the vector of pivots used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L161-L168}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2900186876933432673}{} 
\hyperlink{2900186876933432673}{\texttt{Base.LinAlg.LAPACK.gbtrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gbtrs!(trans, kl, ku, m, AB, ipiv, B)
\end{lstlisting}

Solve the equation \texttt{AB * X = B}. \texttt{trans} determines the orientation of \texttt{AB}. It may be \texttt{N} (no transpose), \texttt{T} (transpose), or \texttt{C} (conjugate transpose). \texttt{kl} is the first subdiagonal containing a nonzero band, \texttt{ku} is the last superdiagonal containing one, and \texttt{m} is the first dimension of the matrix \texttt{AB}. \texttt{ipiv} is the vector of pivots returned from \texttt{gbtrf!}. Returns the vector or matrix \texttt{X}, overwriting \texttt{B} in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L171-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7129013550098860641}{} 
\hyperlink{7129013550098860641}{\texttt{Base.LinAlg.LAPACK.gebal!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gebal!(job, A) -> (ilo, ihi, scale)
\end{lstlisting}

Balance the matrix \texttt{A} before computing its eigensystem or Schur factorization. \texttt{job} can be one of \texttt{N} (\texttt{A} will not be permuted or scaled), \texttt{P} (\texttt{A} will only be permuted), \texttt{S} (\texttt{A} will only be scaled), or \texttt{B} (\texttt{A} will be both permuted and scaled). Modifies \texttt{A} in-place and returns \texttt{ilo}, \texttt{ihi}, and \texttt{scale}. If permuting was turned on, \texttt{A[i,j] = 0} if \texttt{j > i} and \texttt{1 < j < ilo} or \texttt{j > ihi}. \texttt{scale} contains information about the scaling/permutations performed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L235-L244}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12235933743122843113}{} 
\hyperlink{12235933743122843113}{\texttt{Base.LinAlg.LAPACK.gebak!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gebak!(job, side, ilo, ihi, scale, V)
\end{lstlisting}

Transform the eigenvectors \texttt{V} of a matrix balanced using \texttt{gebal!} to the unscaled/unpermuted eigenvectors of the original matrix. Modifies \texttt{V} in-place. \texttt{side} can be \texttt{L} (left eigenvectors are transformed) or \texttt{R} (right eigenvectors are transformed).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L247-L254}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5206402605985603637}{} 
\hyperlink{5206402605985603637}{\texttt{Base.LinAlg.LAPACK.gebrd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gebrd!(A) -> (A, d, e, tauq, taup)
\end{lstlisting}

Reduce \texttt{A} in-place to bidiagonal form \texttt{A = QBP{\textquotesingle}}. Returns \texttt{A}, containing the bidiagonal matrix \texttt{B}; \texttt{d}, containing the diagonal elements of \texttt{B}; \texttt{e}, containing the off-diagonal elements of \texttt{B}; \texttt{tauq}, containing the elementary reflectors representing \texttt{Q}; and \texttt{taup}, containing the elementary reflectors representing \texttt{P}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L544-L552}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6564335010672307185}{} 
\hyperlink{6564335010672307185}{\texttt{Base.LinAlg.LAPACK.gelqf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gelqf!(A, tau)
\end{lstlisting}

Compute the \texttt{LQ} factorization of \texttt{A}, \texttt{A = LQ}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L555-L564}{\texttt{source}}



\begin{lstlisting}
gelqf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{LQ} factorization of \texttt{A}, \texttt{A = LQ}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L650-L657}{\texttt{source}}


\end{adjustwidth}
\hypertarget{33314455129248297}{} 
\hyperlink{33314455129248297}{\texttt{Base.LinAlg.LAPACK.geqlf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqlf!(A, tau)
\end{lstlisting}

Compute the \texttt{QL} factorization of \texttt{A}, \texttt{A = QL}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L567-L575}{\texttt{source}}



\begin{lstlisting}
geqlf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{QL} factorization of \texttt{A}, \texttt{A = QL}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L660-L667}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15835472245352366559}{} 
\hyperlink{15835472245352366559}{\texttt{Base.LinAlg.LAPACK.geqrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqrf!(A, tau)
\end{lstlisting}

Compute the \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L617-L625}{\texttt{source}}



\begin{lstlisting}
geqrf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L692-L699}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2514050749741159031}{} 
\hyperlink{2514050749741159031}{\texttt{Base.LinAlg.LAPACK.geqp3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqp3!(A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3. \texttt{P} is a pivoting matrix, represented by \texttt{jpvt}. \texttt{tau} stores the elementary reflectors. \texttt{jpvt} must have length length greater than or equal to \texttt{n} if \texttt{A} is an \texttt{(m x n)} matrix. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

\texttt{A}, \texttt{jpvt}, and \texttt{tau} are modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L578-L588}{\texttt{source}}



\begin{lstlisting}
geqp3!(A, jpvt) -> (A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3. \texttt{P} is a pivoting matrix, represented by \texttt{jpvt}. \texttt{jpvt} must have length greater than or equal to \texttt{n} if \texttt{A} is an \texttt{(m x n)} matrix.

Returns \texttt{A} and \texttt{jpvt}, modified in-place, and \texttt{tau}, which stores the elementary reflectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L712-L721}{\texttt{source}}



\begin{lstlisting}
geqp3!(A) -> (A, jpvt, tau)
\end{lstlisting}

Compute the pivoted \texttt{QR} factorization of \texttt{A}, \texttt{AP = QR} using BLAS level 3.

Returns \texttt{A}, modified in-place, \texttt{jpvt}, which represents the pivoting matrix \texttt{P}, and \texttt{tau}, which stores the elementary reflectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L727-L734}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17144300602065123789}{} 
\hyperlink{17144300602065123789}{\texttt{Base.LinAlg.LAPACK.gerqf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gerqf!(A, tau)
\end{lstlisting}

Compute the \texttt{RQ} factorization of \texttt{A}, \texttt{A = RQ}. \texttt{tau} contains scalars which parameterize the elementary reflectors of the factorization. \texttt{tau} must have length greater than or equal to the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{tau} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L628-L636}{\texttt{source}}



\begin{lstlisting}
gerqf!(A) -> (A, tau)
\end{lstlisting}

Compute the \texttt{RQ} factorization of \texttt{A}, \texttt{A = RQ}.

Returns \texttt{A}, modified in-place, and \texttt{tau}, which contains scalars which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L702-L709}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13356609639322528365}{} 
\hyperlink{13356609639322528365}{\texttt{Base.LinAlg.LAPACK.geqrt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqrt!(A, T)
\end{lstlisting}

Compute the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{T} contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of \texttt{T} sets the block size and it must be between 1 and \texttt{n}. The second dimension of \texttt{T} must equal the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{T} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L591-L601}{\texttt{source}}



\begin{lstlisting}
geqrt!(A, nb) -> (A, T)
\end{lstlisting}

Compute the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{nb} sets the block size and it must be between 1 and \texttt{n}, the second dimension of \texttt{A}.

Returns \texttt{A}, modified in-place, and \texttt{T}, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L670-L679}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16820445343879057799}{} 
\hyperlink{16820445343879057799}{\texttt{Base.LinAlg.LAPACK.geqrt3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geqrt3!(A, T)
\end{lstlisting}

Recursively computes the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}. \texttt{T} contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.  The first dimension of \texttt{T} sets the block size and it must be between 1 and \texttt{n}. The second dimension of \texttt{T} must equal the smallest dimension of \texttt{A}.

Returns \texttt{A} and \texttt{T} modified in-place.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L604-L614}{\texttt{source}}



\begin{lstlisting}
geqrt3!(A) -> (A, T)
\end{lstlisting}

Recursively computes the blocked \texttt{QR} factorization of \texttt{A}, \texttt{A = QR}.

Returns \texttt{A}, modified in-place, and \texttt{T}, which contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L682-L689}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3745186706780328621}{} 
\hyperlink{3745186706780328621}{\texttt{Base.LinAlg.LAPACK.getrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getrf!(A) -> (A, ipiv, info)
\end{lstlisting}

Compute the pivoted \texttt{LU} factorization of \texttt{A}, \texttt{A = LU}.

Returns \texttt{A}, modified in-place, \texttt{ipiv}, the pivoting information, and an \texttt{info} code which indicates success (\texttt{info = 0}), a singular value in \texttt{U} (\texttt{info = i}, in which case \texttt{U[i,i]} is singular), or an error code (\texttt{info < 0}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L639-L647}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16652933518028418584}{} 
\hyperlink{16652933518028418584}{\texttt{Base.LinAlg.LAPACK.tzrzf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tzrzf!(A) -> (A, tau)
\end{lstlisting}

Transforms the upper trapezoidal matrix \texttt{A} to upper triangular form in-place. Returns \texttt{A} and \texttt{tau}, the scalar parameters for the elementary reflectors of the transformation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L834-L840}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12172653101378533786}{} 
\hyperlink{12172653101378533786}{\texttt{Base.LinAlg.LAPACK.ormrz!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormrz!(side, trans, A, tau, C)
\end{lstlisting}

Multiplies the matrix \texttt{C} by \texttt{Q} from the transformation supplied by \texttt{tzrzf!}. Depending on \texttt{side} or \texttt{trans} the multiplication can be left-sided (\texttt{side = L, Q*C}) or right-sided (\texttt{side = R, C*Q}) and \texttt{Q} can be unmodified (\texttt{trans = N}), transposed (\texttt{trans = T}), or conjugate transposed (\texttt{trans = C}). Returns matrix \texttt{C} which is modified in-place with the result of the multiplication.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L822-L831}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2557507265223459634}{} 
\hyperlink{2557507265223459634}{\texttt{Base.LinAlg.LAPACK.gels!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gels!(trans, A, B) -> (F, B, ssr)
\end{lstlisting}

Solves the linear equation \texttt{A * X = B}, \texttt{A.{\textquotesingle} * X =B}, or \texttt{A{\textquotesingle} * X = B} using a QR or LQ factorization. Modifies the matrix/vector \texttt{B} in place with the solution. \texttt{A} is overwritten with its \texttt{QR} or \texttt{LQ} factorization. \texttt{trans} may be one of \texttt{N} (no modification), \texttt{T} (transpose), or \texttt{C} (conjugate transpose). \texttt{gels!} searches for the minimum norm/least squares solution. \texttt{A} may be under or over determined. The solution is returned in \texttt{B}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L970-L979}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6382187281601335905}{} 
\hyperlink{6382187281601335905}{\texttt{Base.LinAlg.LAPACK.gesv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gesv!(A, B) -> (B, A, ipiv)
\end{lstlisting}

Solves the linear equation \texttt{A * X = B} where \texttt{A} is a square matrix using the \texttt{LU} factorization of \texttt{A}. \texttt{A} is overwritten with its \texttt{LU} factorization and \texttt{B} is overwritten with the solution \texttt{X}. \texttt{ipiv} contains the pivoting information for the \texttt{LU} factorization of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L982-L989}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11163778566912090029}{} 
\hyperlink{11163778566912090029}{\texttt{Base.LinAlg.LAPACK.getrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getrs!(trans, A, ipiv, B)
\end{lstlisting}

Solves the linear equation \texttt{A * X = B}, \texttt{A.{\textquotesingle} * X =B}, or \texttt{A{\textquotesingle} * X = B} for square \texttt{A}. Modifies the matrix/vector \texttt{B} in place with the solution. \texttt{A} is the \texttt{LU} factorization from \texttt{getrf!}, with \texttt{ipiv} the pivoting information. \texttt{trans} may be one of \texttt{N} (no modification), \texttt{T} (transpose), or \texttt{C} (conjugate transpose).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L992-L1000}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15848231100569895059}{} 
\hyperlink{15848231100569895059}{\texttt{Base.LinAlg.LAPACK.getri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getri!(A, ipiv)
\end{lstlisting}

Computes the inverse of \texttt{A}, using its \texttt{LU} factorization found by \texttt{getrf!}. \texttt{ipiv} is the pivot information output and \texttt{A} contains the \texttt{LU} factorization of \texttt{getrf!}. \texttt{A} is overwritten with its inverse.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1003-L1010}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14386545452297721776}{} 
\hyperlink{14386545452297721776}{\texttt{Base.LinAlg.LAPACK.gesvx!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -> (X, equed, R, C, B, rcond, ferr, berr, work)
\end{lstlisting}

Solves the linear equation \texttt{A * X = B} (\texttt{trans = N}), \texttt{A.{\textquotesingle} * X =B} (\texttt{trans = T}), or \texttt{A{\textquotesingle} * X = B} (\texttt{trans = C}) using the \texttt{LU} factorization of \texttt{A}. \texttt{fact} may be \texttt{E}, in which case \texttt{A} will be equilibrated and copied to \texttt{AF}; \texttt{F}, in which case \texttt{AF} and \texttt{ipiv} from a previous \texttt{LU} factorization are inputs; or \texttt{N}, in which case \texttt{A} will be copied to \texttt{AF} and then factored. If \texttt{fact = F}, \texttt{equed} may be \texttt{N}, meaning \texttt{A} has not been equilibrated; \texttt{R}, meaning \texttt{A} was multiplied by \texttt{diagm(R)} from the left; \texttt{C}, meaning \texttt{A} was multiplied by \texttt{diagm(C)} from the right; or \texttt{B}, meaning \texttt{A} was multiplied by \texttt{diagm(R)} from the left and \texttt{diagm(C)} from the right. If \texttt{fact = F} and \texttt{equed = R} or \texttt{B} the elements of \texttt{R} must all be positive. If \texttt{fact = F} and \texttt{equed = C} or \texttt{B} the elements of \texttt{C} must all be positive.

Returns the solution \texttt{X}; \texttt{equed}, which is an output if \texttt{fact} is not \texttt{N}, and describes the equilibration that was performed; \texttt{R}, the row equilibration diagonal; \texttt{C}, the column equilibration diagonal; \texttt{B}, which may be overwritten with its equilibrated form \texttt{diagm(R)*B} (if \texttt{trans = N} and \texttt{equed = R,B}) or \texttt{diagm(C)*B} (if \texttt{trans = T,C} and \texttt{equed = C,B}); \texttt{rcond}, the reciprocal condition number of \texttt{A} after equilbrating; \texttt{ferr}, the forward error bound for each solution vector in \texttt{X}; \texttt{berr}, the forward error bound for each solution vector in \texttt{X}; and \texttt{work}, the reciprocal pivot growth factor.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1153-L1176}{\texttt{source}}



\begin{lstlisting}
gesvx!(A, B)
\end{lstlisting}

The no-equilibration, no-transpose simplification of \texttt{gesvx!}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1180-L1184}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12295012331561474310}{} 
\hyperlink{12295012331561474310}{\texttt{Base.LinAlg.LAPACK.gelsd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gelsd!(A, B, rcond) -> (B, rnk)
\end{lstlisting}

Computes the least norm solution of \texttt{A * X = B} by finding the \texttt{SVD} factorization of \texttt{A}, then dividing-and-conquering the problem. \texttt{B} is overwritten with the solution \texttt{X}. Singular values below \texttt{rcond} will be treated as zero. Returns the solution in \texttt{B} and the effective rank of \texttt{A} in \texttt{rnk}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1375-L1383}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2116984319227560409}{} 
\hyperlink{2116984319227560409}{\texttt{Base.LinAlg.LAPACK.gelsy!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gelsy!(A, B, rcond) -> (B, rnk)
\end{lstlisting}

Computes the least norm solution of \texttt{A * X = B} by finding the full \texttt{QR} factorization of \texttt{A}, then dividing-and-conquering the problem. \texttt{B} is overwritten with the solution \texttt{X}. Singular values below \texttt{rcond} will be treated as zero. Returns the solution in \texttt{B} and the effective rank of \texttt{A} in \texttt{rnk}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1386-L1394}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17718650948605150276}{} 
\hyperlink{17718650948605150276}{\texttt{Base.LinAlg.LAPACK.gglse!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gglse!(A, c, B, d) -> (X,res)
\end{lstlisting}

Solves the equation \texttt{A * x = c} where \texttt{x} is subject to the equality constraint \texttt{B * x = d}. Uses the formula \texttt{||c - A*x||{\textasciicircum}2 = 0} to solve. Returns \texttt{X} and the residual sum-of-squares.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1447-L1453}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6857267594160515035}{} 
\hyperlink{6857267594160515035}{\texttt{Base.LinAlg.LAPACK.geev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geev!(jobvl, jobvr, A) -> (W, VL, VR)
\end{lstlisting}

Finds the eigensystem of \texttt{A}. If \texttt{jobvl = N}, the left eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed. Returns the eigenvalues in \texttt{W}, the right eigenvectors in \texttt{VR}, and the left eigenvectors in \texttt{VL}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1742-L1750}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15953579614147759298}{} 
\hyperlink{15953579614147759298}{\texttt{Base.LinAlg.LAPACK.gesdd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gesdd!(job, A) -> (U, S, VT)
\end{lstlisting}

Finds the singular value decomposition of \texttt{A}, \texttt{A = U * S * V{\textquotesingle}}, using a divide and conquer approach. If \texttt{job = A}, all the columns of \texttt{U} and the rows of \texttt{V{\textquotesingle}} are computed. If \texttt{job = N}, no columns of \texttt{U} or rows of \texttt{V{\textquotesingle}} are computed. If \texttt{job = O}, \texttt{A} is overwritten with the columns of (thin) \texttt{U} and the rows of (thin) \texttt{V{\textquotesingle}}. If \texttt{job = S}, the columns of (thin) \texttt{U} and the rows of (thin) \texttt{V{\textquotesingle}} are computed and returned separately.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1753-L1762}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10873609947280646096}{} 
\hyperlink{10873609947280646096}{\texttt{Base.LinAlg.LAPACK.gesvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gesvd!(jobu, jobvt, A) -> (U, S, VT)
\end{lstlisting}

Finds the singular value decomposition of \texttt{A}, \texttt{A = U * S * V{\textquotesingle}}. If \texttt{jobu = A}, all the columns of \texttt{U} are computed. If \texttt{jobvt = A} all the rows of \texttt{V{\textquotesingle}} are computed. If \texttt{jobu = N}, no columns of \texttt{U} are computed. If \texttt{jobvt = N} no rows of \texttt{V{\textquotesingle}} are computed. If \texttt{jobu = O}, \texttt{A} is overwritten with the columns of (thin) \texttt{U}. If \texttt{jobvt = O}, \texttt{A} is overwritten with the rows of (thin) \texttt{V{\textquotesingle}}. If \texttt{jobu = S}, the columns of (thin) \texttt{U} are computed and returned separately. If \texttt{jobvt = S} the rows of (thin) \texttt{V{\textquotesingle}} are computed and returned separately. \texttt{jobu} and \texttt{jobvt} can{\textquotesingle}t both be \texttt{O}.

Returns \texttt{U}, \texttt{S}, and \texttt{Vt}, where \texttt{S} are the singular values of \texttt{A}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1765-L1778}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16049037685351559706}{} 
\hyperlink{16049037685351559706}{\texttt{Base.LinAlg.LAPACK.ggsvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ggsvd!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)
\end{lstlisting}

Finds the generalized singular value decomposition of \texttt{A} and \texttt{B}, \texttt{U{\textquotesingle}*A*Q = D1*R} and \texttt{V{\textquotesingle}*B*Q = D2*R}. \texttt{D1} has \texttt{alpha} on its diagonal and \texttt{D2} has \texttt{beta} on its diagonal. If \texttt{jobu = U}, the orthogonal/unitary matrix \texttt{U} is computed. If \texttt{jobv = V} the orthogonal/unitary matrix \texttt{V} is computed. If \texttt{jobq = Q}, the orthogonal/unitary matrix \texttt{Q} is computed. If \texttt{jobu}, \texttt{jobv} or \texttt{jobq} is \texttt{N}, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1781-L1791}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1004634299534576501}{} 
\hyperlink{1004634299534576501}{\texttt{Base.LinAlg.LAPACK.ggsvd3!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ggsvd3!(jobu, jobv, jobq, A, B) -> (U, V, Q, alpha, beta, k, l, R)
\end{lstlisting}

Finds the generalized singular value decomposition of \texttt{A} and \texttt{B}, \texttt{U{\textquotesingle}*A*Q = D1*R} and \texttt{V{\textquotesingle}*B*Q = D2*R}. \texttt{D1} has \texttt{alpha} on its diagonal and \texttt{D2} has \texttt{beta} on its diagonal. If \texttt{jobu = U}, the orthogonal/unitary matrix \texttt{U} is computed. If \texttt{jobv = V} the orthogonal/unitary matrix \texttt{V} is computed. If \texttt{jobq = Q}, the orthogonal/unitary matrix \texttt{Q} is computed. If \texttt{jobu}, \texttt{jobv}, or \texttt{jobq} is \texttt{N}, that matrix is not computed. This function requires LAPACK 3.6.0.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L1910-L1919}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5080871124512586132}{} 
\hyperlink{5080871124512586132}{\texttt{Base.LinAlg.LAPACK.geevx!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
geevx!(balanc, jobvl, jobvr, sense, A) -> (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)
\end{lstlisting}

Finds the eigensystem of \texttt{A} with matrix balancing. If \texttt{jobvl = N}, the left eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors of \texttt{A} aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed. If \texttt{balanc = N}, no balancing is performed. If \texttt{balanc = P}, \texttt{A} is permuted but not scaled. If \texttt{balanc = S}, \texttt{A} is scaled but not permuted. If \texttt{balanc = B}, \texttt{A} is permuted and scaled. If \texttt{sense = N}, no reciprocal condition numbers are computed. If \texttt{sense = E}, reciprocal condition numbers are computed for the eigenvalues only. If \texttt{sense = V}, reciprocal condition numbers are computed for the right eigenvectors only. If \texttt{sense = B}, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If \texttt{sense = E,B}, the right and left eigenvectors must be computed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2220-L2236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8207476271745139}{} 
\hyperlink{8207476271745139}{\texttt{Base.LinAlg.LAPACK.ggev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ggev!(jobvl, jobvr, A, B) -> (alpha, beta, vl, vr)
\end{lstlisting}

Finds the generalized eigendecomposition of \texttt{A} and \texttt{B}. If \texttt{jobvl = N}, the left eigenvectors aren{\textquotesingle}t computed. If \texttt{jobvr = N}, the right eigenvectors aren{\textquotesingle}t computed. If \texttt{jobvl = V} or \texttt{jobvr = V}, the corresponding eigenvectors are computed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2239-L2246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18443359303182750902}{} 
\hyperlink{18443359303182750902}{\texttt{Base.LinAlg.LAPACK.gtsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gtsv!(dl, d, du, B)
\end{lstlisting}

Solves the equation \texttt{A * X = B} where \texttt{A} is a tridiagonal matrix with \texttt{dl} on the subdiagonal, \texttt{d} on the diagonal, and \texttt{du} on the superdiagonal.

Overwrites \texttt{B} with the solution \texttt{X} and returns it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2413-L2421}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8852711688651638758}{} 
\hyperlink{8852711688651638758}{\texttt{Base.LinAlg.LAPACK.gttrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gttrf!(dl, d, du) -> (dl, d, du, du2, ipiv)
\end{lstlisting}

Finds the \texttt{LU} factorization of a tridiagonal matrix with \texttt{dl} on the subdiagonal, \texttt{d} on the diagonal, and \texttt{du} on the superdiagonal.

Modifies \texttt{dl}, \texttt{d}, and \texttt{du} in-place and returns them and the second superdiagonal \texttt{du2} and the pivoting vector \texttt{ipiv}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2424-L2432}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4530759117811213169}{} 
\hyperlink{4530759117811213169}{\texttt{Base.LinAlg.LAPACK.gttrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gttrs!(trans, dl, d, du, du2, ipiv, B)
\end{lstlisting}

Solves the equation \texttt{A * X = B} (\texttt{trans = N}), \texttt{A.{\textquotesingle} * X = B} (\texttt{trans = T}), or \texttt{A{\textquotesingle} * X = B} (\texttt{trans = C}) using the \texttt{LU} factorization computed by \texttt{gttrf!}. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2435-L2441}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4035457320125964281}{} 
\hyperlink{4035457320125964281}{\texttt{Base.LinAlg.LAPACK.orglq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orglq!(A, tau, k = length(tau))
\end{lstlisting}

Explicitly finds the matrix \texttt{Q} of a \texttt{LQ} factorization after calling \texttt{gelqf!} on \texttt{A}. Uses the output of \texttt{gelqf!}. \texttt{A} is overwritten by \texttt{Q}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2835-L2840}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3164127450970882180}{} 
\hyperlink{3164127450970882180}{\texttt{Base.LinAlg.LAPACK.orgqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orgqr!(A, tau, k = length(tau))
\end{lstlisting}

Explicitly finds the matrix \texttt{Q} of a \texttt{QR} factorization after calling \texttt{geqrf!} on \texttt{A}. Uses the output of \texttt{geqrf!}. \texttt{A} is overwritten by \texttt{Q}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2843-L2848}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10774109014374486854}{} 
\hyperlink{10774109014374486854}{\texttt{Base.LinAlg.LAPACK.orgql!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orgql!(A, tau, k = length(tau))
\end{lstlisting}

Explicitly finds the matrix \texttt{Q} of a \texttt{QL} factorization after calling \texttt{geqlf!} on \texttt{A}. Uses the output of \texttt{geqlf!}. \texttt{A} is overwritten by \texttt{Q}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2851-L2856}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11757217016830816757}{} 
\hyperlink{11757217016830816757}{\texttt{Base.LinAlg.LAPACK.orgrq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orgrq!(A, tau, k = length(tau))
\end{lstlisting}

Explicitly finds the matrix \texttt{Q} of a \texttt{RQ} factorization after calling \texttt{gerqf!} on \texttt{A}. Uses the output of \texttt{gerqf!}. \texttt{A} is overwritten by \texttt{Q}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2859-L2864}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1467921841608803290}{} 
\hyperlink{1467921841608803290}{\texttt{Base.LinAlg.LAPACK.ormlq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormlq!(side, trans, A, tau, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{LQ} factorization of \texttt{A} computed using \texttt{gelqf!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2867-L2874}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9717935803686995697}{} 
\hyperlink{9717935803686995697}{\texttt{Base.LinAlg.LAPACK.ormqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormqr!(side, trans, A, tau, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QR} factorization of \texttt{A} computed using \texttt{geqrf!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2877-L2884}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5040775879556201882}{} 
\hyperlink{5040775879556201882}{\texttt{Base.LinAlg.LAPACK.ormql!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormql!(side, trans, A, tau, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QL} factorization of \texttt{A} computed using \texttt{geqlf!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2887-L2894}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6079643517217636753}{} 
\hyperlink{6079643517217636753}{\texttt{Base.LinAlg.LAPACK.ormrq!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ormrq!(side, trans, A, tau, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{RQ} factorization of \texttt{A} computed using \texttt{gerqf!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2897-L2904}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4923525906529176288}{} 
\hyperlink{4923525906529176288}{\texttt{Base.LinAlg.LAPACK.gemqrt!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gemqrt!(side, trans, V, T, C)
\end{lstlisting}

Computes \texttt{Q * C} (\texttt{trans = N}), \texttt{Q.{\textquotesingle} * C} (\texttt{trans = T}), \texttt{Q{\textquotesingle} * C} (\texttt{trans = C}) for \texttt{side = L} or the equivalent right-sided multiplication for \texttt{side = R} using \texttt{Q} from a \texttt{QR} factorization of \texttt{A} computed using \texttt{geqrt!}. \texttt{C} is overwritten.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L2907-L2914}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7933076029998675408}{} 
\hyperlink{7933076029998675408}{\texttt{Base.LinAlg.LAPACK.posv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
posv!(uplo, A, B) -> (A, B)
\end{lstlisting}

Finds the solution to \texttt{A * X = B} where \texttt{A} is a symmetric or Hermitian positive definite matrix. If \texttt{uplo = U} the upper Cholesky decomposition of \texttt{A} is computed. If \texttt{uplo = L} the lower Cholesky decomposition of \texttt{A} is computed. \texttt{A} is overwritten by its Cholesky decomposition. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3045-L3053}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2675600524587319013}{} 
\hyperlink{2675600524587319013}{\texttt{Base.LinAlg.LAPACK.potrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
potrf!(uplo, A)
\end{lstlisting}

Computes the Cholesky (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) decomposition of positive-definite matrix \texttt{A}. \texttt{A} is overwritten and returned with an info code.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3056-L3062}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6335546978791941473}{} 
\hyperlink{6335546978791941473}{\texttt{Base.LinAlg.LAPACK.potri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
potri!(uplo, A)
\end{lstlisting}

Computes the inverse of positive-definite matrix \texttt{A} after calling \texttt{potrf!} to find its (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) Cholesky decomposition.

\texttt{A} is overwritten by its inverse and returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3065-L3073}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7150839328756297092}{} 
\hyperlink{7150839328756297092}{\texttt{Base.LinAlg.LAPACK.potrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
potrs!(uplo, A, B)
\end{lstlisting}

Finds the solution to \texttt{A * X = B} where \texttt{A} is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by \texttt{potrf!}. If \texttt{uplo = U} the upper Cholesky decomposition of \texttt{A} was computed. If \texttt{uplo = L} the lower Cholesky decomposition of \texttt{A} was computed. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3076-L3084}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16513636141865548042}{} 
\hyperlink{16513636141865548042}{\texttt{Base.LinAlg.LAPACK.pstrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pstrf!(uplo, A, tol) -> (A, piv, rank, info)
\end{lstlisting}

Computes the (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) pivoted Cholesky decomposition of positive-definite matrix \texttt{A} with a user-set tolerance \texttt{tol}. \texttt{A} is overwritten by its Cholesky decomposition.

Returns \texttt{A}, the pivots \texttt{piv}, the rank of \texttt{A}, and an \texttt{info} code. If \texttt{info = 0}, the factorization succeeded. If \texttt{info = i > 0}, then \texttt{A} is indefinite or rank-deficient.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3087-L3097}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5267267229624237648}{} 
\hyperlink{5267267229624237648}{\texttt{Base.LinAlg.LAPACK.ptsv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ptsv!(D, E, B)
\end{lstlisting}

Solves \texttt{A * X = B} for positive-definite tridiagonal \texttt{A}. \texttt{D} is the diagonal of \texttt{A} and \texttt{E} is the off-diagonal. \texttt{B} is overwritten with the solution \texttt{X} and returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3152-L3158}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1357748730724903659}{} 
\hyperlink{1357748730724903659}{\texttt{Base.LinAlg.LAPACK.pttrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pttrf!(D, E)
\end{lstlisting}

Computes the LDLt factorization of a positive-definite tridiagonal matrix with \texttt{D} as diagonal and \texttt{E} as off-diagonal. \texttt{D} and \texttt{E} are overwritten and returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3161-L3167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11162461964270014949}{} 
\hyperlink{11162461964270014949}{\texttt{Base.LinAlg.LAPACK.pttrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pttrs!(D, E, B)
\end{lstlisting}

Solves \texttt{A * X = B} for positive-definite tridiagonal \texttt{A} with diagonal \texttt{D} and off-diagonal \texttt{E} after computing \texttt{A}{\textquotesingle}s LDLt factorization using \texttt{pttrf!}. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3232-L3238}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11243311595705981759}{} 
\hyperlink{11243311595705981759}{\texttt{Base.LinAlg.LAPACK.trtri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trtri!(uplo, diag, A)
\end{lstlisting}

Finds the inverse of (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{A} is overwritten with its inverse.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3297-L3304}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14919351476976495770}{} 
\hyperlink{14919351476976495770}{\texttt{Base.LinAlg.LAPACK.trtrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trtrs!(uplo, trans, diag, A, B)
\end{lstlisting}

Solves \texttt{A * X = B} (\texttt{trans = N}), \texttt{A.{\textquotesingle} * X = B} (\texttt{trans = T}), or \texttt{A{\textquotesingle} * X = B} (\texttt{trans = C}) for (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{B} is overwritten with the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3307-L3315}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6868800184560636920}{} 
\hyperlink{6868800184560636920}{\texttt{Base.LinAlg.LAPACK.trcon!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trcon!(norm, uplo, diag, A)
\end{lstlisting}

Finds the reciprocal condition number of (upper if \texttt{uplo = U}, lower if \texttt{uplo = L}) triangular matrix \texttt{A}. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. If \texttt{norm = I}, the condition number is found in the infinity norm. If \texttt{norm = O} or \texttt{1}, the condition number is found in the one norm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3576-L3584}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1085452937331644402}{} 
\hyperlink{1085452937331644402}{\texttt{Base.LinAlg.LAPACK.trevc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))
\end{lstlisting}

Finds the eigensystem of an upper triangular matrix \texttt{T}. If \texttt{side = R}, the right eigenvectors are computed. If \texttt{side = L}, the left eigenvectors are computed. If \texttt{side = B}, both sets are computed. If \texttt{howmny = A}, all eigenvectors are found. If \texttt{howmny = B}, all eigenvectors are found and backtransformed using \texttt{VL} and \texttt{VR}. If \texttt{howmny = S}, only the eigenvectors corresponding to the values in \texttt{select} are computed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3587-L3597}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2844162264144144079}{} 
\hyperlink{2844162264144144079}{\texttt{Base.LinAlg.LAPACK.trrfs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -> (Ferr, Berr)
\end{lstlisting}

Estimates the error in the solution to \texttt{A * X = B} (\texttt{trans = N}), \texttt{A.{\textquotesingle} * X = B} (\texttt{trans = T}), \texttt{A{\textquotesingle} * X = B} (\texttt{trans = C}) for \texttt{side = L}, or the equivalent equations a right-handed \texttt{side = R} \texttt{X * A} after computing \texttt{X} using \texttt{trtrs!}. If \texttt{uplo = U}, \texttt{A} is upper triangular. If \texttt{uplo = L}, \texttt{A} is lower triangular. If \texttt{diag = N}, \texttt{A} has non-unit diagonal elements. If \texttt{diag = U}, all diagonal elements of \texttt{A} are one. \texttt{Ferr} and \texttt{Berr} are optional inputs. \texttt{Ferr} is the forward error and \texttt{Berr} is the backward error, each component-wise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3601-L3612}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1043772728109330061}{} 
\hyperlink{1043772728109330061}{\texttt{Base.LinAlg.LAPACK.stev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stev!(job, dv, ev) -> (dv, Zmat)
\end{lstlisting}

Computes the eigensystem for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{job = N} only the eigenvalues are found and returned in \texttt{dv}. If \texttt{job = V} then the eigenvectors are also found and returned in \texttt{Zmat}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3773-L3780}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4313264135687966731}{} 
\hyperlink{4313264135687966731}{\texttt{Base.LinAlg.LAPACK.stebz!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -> (dv, iblock, isplit)
\end{lstlisting}

Computes the eigenvalues for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. If \texttt{order = B}, eigvalues are ordered within a block. If \texttt{order = E}, they are ordered across all the blocks. \texttt{abstol} can be set as a tolerance for convergence.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3783-L3793}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18264060661441624867}{} 
\hyperlink{18264060661441624867}{\texttt{Base.LinAlg.LAPACK.stegr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stegr!(jobz, range, dv, ev, vl, vu, il, iu) -> (w, Z)
\end{lstlisting}

Computes the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev} as off-diagonal. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. The eigenvalues are returned in \texttt{w} and the eigenvectors in \texttt{Z}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3796-L3806}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8214743586040698527}{} 
\hyperlink{8214743586040698527}{\texttt{Base.LinAlg.LAPACK.stein!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stein!(dv, ev_in, w_in, iblock_in, isplit_in)
\end{lstlisting}

Computes the eigenvectors for a symmetric tridiagonal matrix with \texttt{dv} as diagonal and \texttt{ev\_in} as off-diagonal. \texttt{w\_in} specifies the input eigenvalues for which to find corresponding eigenvectors. \texttt{iblock\_in} specifies the submatrices corresponding to the eigenvalues in \texttt{w\_in}. \texttt{isplit\_in} specifies the splitting points between the submatrix blocks.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L3809-L3817}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2236040521224580683}{} 
\hyperlink{2236040521224580683}{\texttt{Base.LinAlg.LAPACK.syconv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syconv!(uplo, A, ipiv) -> (A, work)
\end{lstlisting}

Converts a symmetric matrix \texttt{A} (which has been factorized into a triangular matrix) into two matrices \texttt{L} and \texttt{D}. If \texttt{uplo = U}, \texttt{A} is upper triangular. If \texttt{uplo = L}, it is lower triangular. \texttt{ipiv} is the pivot vector from the triangular factorization. \texttt{A} is overwritten by \texttt{L} and \texttt{D}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4673-L4681}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7843986404244808539}{} 
\hyperlink{7843986404244808539}{\texttt{Base.LinAlg.LAPACK.sysv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sysv!(uplo, A, B) -> (B, A, ipiv)
\end{lstlisting}

Finds the solution to \texttt{A * X = B} for symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}. \texttt{A} is overwritten by its Bunch-Kaufman factorization. \texttt{ipiv} contains pivoting information about the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4684-L4692}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5785135406907595036}{} 
\hyperlink{5785135406907595036}{\texttt{Base.LinAlg.LAPACK.sytrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sytrf!(uplo, A) -> (A, ipiv, info)
\end{lstlisting}

Computes the Bunch-Kaufman factorization of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored.

Returns \texttt{A}, overwritten by the factorization, a pivot vector \texttt{ipiv}, and the error code \texttt{info} which is a non-negative integer. If \texttt{info} is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position \texttt{info}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4695-L4706}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16804210591865514013}{} 
\hyperlink{16804210591865514013}{\texttt{Base.LinAlg.LAPACK.sytri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sytri!(uplo, A, ipiv)
\end{lstlisting}

Computes the inverse of a symmetric matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{A} is overwritten by its inverse.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4709-L4715}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12379871855752390599}{} 
\hyperlink{12379871855752390599}{\texttt{Base.LinAlg.LAPACK.sytrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sytrs!(uplo, A, ipiv, B)
\end{lstlisting}

Solves the equation \texttt{A * X = B} for a symmetric matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4718-L4725}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15891292855935989899}{} 
\hyperlink{15891292855935989899}{\texttt{Base.LinAlg.LAPACK.hesv!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hesv!(uplo, A, B) -> (B, A, ipiv)
\end{lstlisting}

Finds the solution to \texttt{A * X = B} for Hermitian matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}. \texttt{A} is overwritten by its Bunch-Kaufman factorization. \texttt{ipiv} contains pivoting information about the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4729-L4737}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15396067459248463}{} 
\hyperlink{15396067459248463}{\texttt{Base.LinAlg.LAPACK.hetrf!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hetrf!(uplo, A) -> (A, ipiv, info)
\end{lstlisting}

Computes the Bunch-Kaufman factorization of a Hermitian matrix \texttt{A}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored.

Returns \texttt{A}, overwritten by the factorization, a pivot vector \texttt{ipiv}, and the error code \texttt{info} which is a non-negative integer. If \texttt{info} is positive the matrix is singular and the diagonal part of the factorization is exactly zero at position \texttt{info}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4740-L4751}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9905060158086392271}{} 
\hyperlink{9905060158086392271}{\texttt{Base.LinAlg.LAPACK.hetri!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hetri!(uplo, A, ipiv)
\end{lstlisting}

Computes the inverse of a Hermitian matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{A} is overwritten by its inverse.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4754-L4760}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6292228243520363864}{} 
\hyperlink{6292228243520363864}{\texttt{Base.LinAlg.LAPACK.hetrs!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hetrs!(uplo, A, ipiv, B)
\end{lstlisting}

Solves the equation \texttt{A * X = B} for a Hermitian matrix \texttt{A} using the results of \texttt{sytrf!}. If \texttt{uplo = U}, the upper half of \texttt{A} is stored. If \texttt{uplo = L}, the lower half is stored. \texttt{B} is overwritten by the solution \texttt{X}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L4763-L4770}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3513320235373309950}{} 
\hyperlink{3513320235373309950}{\texttt{Base.LinAlg.LAPACK.syev!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syev!(jobz, uplo, A)
\end{lstlisting}

Finds the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper triangle of \texttt{A} is used. If \texttt{uplo = L}, the lower triangle of \texttt{A} is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5072-L5078}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15410150289254004118}{} 
\hyperlink{15410150289254004118}{\texttt{Base.LinAlg.LAPACK.syevr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -> (W, Z)
\end{lstlisting}

Finds the eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A}. If \texttt{uplo = U}, the upper triangle of \texttt{A} is used. If \texttt{uplo = L}, the lower triangle of \texttt{A} is used. If \texttt{range = A}, all the eigenvalues are found. If \texttt{range = V}, the eigenvalues in the half-open interval \texttt{(vl, vu]} are found. If \texttt{range = I}, the eigenvalues with indices between \texttt{il} and \texttt{iu} are found. \texttt{abstol} can be set as a tolerance for convergence.

The eigenvalues are returned in \texttt{W} and the eigenvectors in \texttt{Z}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5081-L5093}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2852991601665604457}{} 
\hyperlink{2852991601665604457}{\texttt{Base.LinAlg.LAPACK.sygvd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sygvd!(itype, jobz, uplo, A, B) -> (w, A, B)
\end{lstlisting}

Finds the generalized eigenvalues (\texttt{jobz = N}) or eigenvalues and eigenvectors (\texttt{jobz = V}) of a symmetric matrix \texttt{A} and symmetric positive-definite matrix \texttt{B}. If \texttt{uplo = U}, the upper triangles of \texttt{A} and \texttt{B} are used. If \texttt{uplo = L}, the lower triangles of \texttt{A} and \texttt{B} are used. If \texttt{itype = 1}, the problem to solve is \texttt{A * x = lambda * B * x}. If \texttt{itype = 2}, the problem to solve is \texttt{A * B * x = lambda * x}. If \texttt{itype = 3}, the problem to solve is \texttt{B * A * x = lambda * x}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5097-L5108}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5036448080004866989}{} 
\hyperlink{5036448080004866989}{\texttt{Base.LinAlg.LAPACK.bdsqr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bdsqr!(uplo, d, e_, Vt, U, C) -> (d, Vt, U, C)
\end{lstlisting}

Computes the singular value decomposition of a bidiagonal matrix with \texttt{d} on the diagonal and \texttt{e\_} on the off-diagonal. If \texttt{uplo = U}, \texttt{e\_} is the superdiagonal. If \texttt{uplo = L}, \texttt{e\_} is the subdiagonal. Can optionally also compute the product \texttt{Q{\textquotesingle} * C}.

Returns the singular values in \texttt{d}, and the matrix \texttt{C} overwritten with \texttt{Q{\textquotesingle} * C}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5160-L5169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15016094268647319816}{} 
\hyperlink{15016094268647319816}{\texttt{Base.LinAlg.LAPACK.bdsdc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bdsdc!(uplo, compq, d, e_) -> (d, e, u, vt, q, iq)
\end{lstlisting}

Computes the singular value decomposition of a bidiagonal matrix with \texttt{d} on the diagonal and \texttt{e\_} on the off-diagonal using a divide and conqueq method. If \texttt{uplo = U}, \texttt{e\_} is the superdiagonal. If \texttt{uplo = L}, \texttt{e\_} is the subdiagonal. If \texttt{compq = N}, only the singular values are found. If \texttt{compq = I}, the singular values and vectors are found. If \texttt{compq = P}, the singular values and vectors are found in compact form. Only works for real types.

Returns the singular values in \texttt{d}, and if \texttt{compq = P}, the compact singular vectors in \texttt{iq}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5228-L5240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5267068886550523397}{} 
\hyperlink{5267068886550523397}{\texttt{Base.LinAlg.LAPACK.gecon!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gecon!(normtype, A, anorm)
\end{lstlisting}

Finds the reciprocal condition number of matrix \texttt{A}. If \texttt{normtype = I}, the condition number is found in the infinity norm. If \texttt{normtype = O} or \texttt{1}, the condition number is found in the one norm. \texttt{A} must be the result of \texttt{getrf!} and \texttt{anorm} is the norm of \texttt{A} in the relevant norm.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5311-L5318}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17999493126378954334}{} 
\hyperlink{17999493126378954334}{\texttt{Base.LinAlg.LAPACK.gehrd!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gehrd!(ilo, ihi, A) -> (A, tau)
\end{lstlisting}

Converts a matrix \texttt{A} to Hessenberg form. If \texttt{A} is balanced with \texttt{gebal!} then \texttt{ilo} and \texttt{ihi} are the outputs of \texttt{gebal!}. Otherwise they should be \texttt{ilo = 1} and \texttt{ihi = size(A,2)}. \texttt{tau} contains the elementary reflectors of the factorization.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5361-L5368}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4988949518942718103}{} 
\hyperlink{4988949518942718103}{\texttt{Base.LinAlg.LAPACK.orghr!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
orghr!(ilo, ihi, A, tau)
\end{lstlisting}

Explicitly finds \texttt{Q}, the orthogonal/unitary matrix from \texttt{gehrd!}. \texttt{ilo}, \texttt{ihi}, \texttt{A}, and \texttt{tau} must correspond to the input/output to \texttt{gehrd!}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5410-L5415}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1711655311938243223}{} 
\hyperlink{1711655311938243223}{\texttt{Base.LinAlg.LAPACK.gees!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gees!(jobvs, A) -> (A, vs, w)
\end{lstlisting}

Computes the eigenvalues (\texttt{jobvs = N}) or the eigenvalues and Schur vectors (\texttt{jobvs = V}) of matrix \texttt{A}. \texttt{A} is overwritten by its Schur form.

Returns \texttt{A}, \texttt{vs} containing the Schur vectors, and \texttt{w}, containing the eigenvalues.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5656-L5664}{\texttt{source}}


\end{adjustwidth}
\hypertarget{839810087458822727}{} 
\hyperlink{839810087458822727}{\texttt{Base.LinAlg.LAPACK.gges!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gges!(jobvsl, jobvsr, A, B) -> (A, B, alpha, beta, vsl, vsr)
\end{lstlisting}

Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (\texttt{jobsvl = V}), or right Schur vectors (\texttt{jobvsr = V}) of \texttt{A} and \texttt{B}.

The generalized eigenvalues are returned in \texttt{alpha} and \texttt{beta}. The left Schur vectors are returned in \texttt{vsl} and the right Schur vectors are returned in \texttt{vsr}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5668-L5677}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17908599480286718410}{} 
\hyperlink{17908599480286718410}{\texttt{Base.LinAlg.LAPACK.trexc!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trexc!(compq, ifst, ilst, T, Q) -> (T, Q)
\end{lstlisting}

Reorder the Schur factorization of a matrix. If \texttt{compq = V}, the Schur vectors \texttt{Q} are reordered. If \texttt{compq = N} they are not modified. \texttt{ifst} and \texttt{ilst} specify the reordering of the vectors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5972-L5978}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1707883259747849093}{} 
\hyperlink{1707883259747849093}{\texttt{Base.LinAlg.LAPACK.trsen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsen!(compq, job, select, T, Q) -> (T, Q, w)
\end{lstlisting}

Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. If \texttt{job = N}, no condition numbers are found. If \texttt{job = E}, only the condition number for this cluster of eigenvalues is found. If \texttt{job = V}, only the condition number for the invariant subspace is found. If \texttt{job = B} then the condition numbers for the cluster and subspace are found. If \texttt{compq = V} the Schur vectors \texttt{Q} are updated. If \texttt{compq = N} the Schur vectors are not modified. \texttt{select} determines which eigenvalues are in the cluster.

Returns \texttt{T}, \texttt{Q}, and reordered eigenvalues in \texttt{w}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5981-L5994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17096834433503066270}{} 
\hyperlink{17096834433503066270}{\texttt{Base.LinAlg.LAPACK.tgsen!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tgsen!(select, S, T, Q, Z) -> (S, T, alpha, beta, Q, Z)
\end{lstlisting}

Reorders the vectors of a generalized Schur decomposition. \texttt{select} specifices the eigenvalues in each cluster.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L5997-L6002}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10259061194288213349}{} 
\hyperlink{10259061194288213349}{\texttt{Base.LinAlg.LAPACK.trsyl!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trsyl!(transa, transb, A, B, C, isgn=1) -> (C, scale)
\end{lstlisting}

Solves the Sylvester matrix equation \texttt{A * X +/- X * B = scale*C} where \texttt{A} and \texttt{B} are both quasi-upper triangular. If \texttt{transa = N}, \texttt{A} is not modified. If \texttt{transa = T}, \texttt{A} is transposed. If \texttt{transa = C}, \texttt{A} is conjugate transposed. Similarly for \texttt{transb} and \texttt{B}. If \texttt{isgn = 1}, the equation \texttt{A * X + X * B = scale * C} is solved. If \texttt{isgn = -1}, the equation \texttt{A * X - X * B = scale * C} is solved.

Returns \texttt{X} (overwriting \texttt{C}) and \texttt{scale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/lapack.jl#L6036-L6047}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4380185033557519432}{}


\chapter{Constantes}


\hypertarget{9331422207248206047}{} 
\hyperlink{9331422207248206047}{\texttt{Core.nothing}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nothing
\end{lstlisting}

The singleton instance of type \texttt{Void}, used by convention when there is no value to return (as in a C \texttt{void} function). Can be converted to an empty \texttt{Nullable} value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L691-L696}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9054270179006636705}{} 
\hyperlink{9054270179006636705}{\texttt{Base.PROGRAM\_FILE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
PROGRAM_FILE
\end{lstlisting}

A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see \hyperlink{1518763743618824993}{\texttt{@\_\_FILE\_\_}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/initdefs.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2567473177880607455}{} 
\hyperlink{2567473177880607455}{\texttt{Base.ARGS}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ARGS
\end{lstlisting}

An array of the command line arguments passed to Julia, as strings.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/initdefs.jl#L14-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11444309529550205492}{} 
\hyperlink{11444309529550205492}{\texttt{Base.C\_NULL}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
C_NULL
\end{lstlisting}

The C null pointer constant, sometimes used when calling external code.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L13-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12605722316331458198}{} 
\hyperlink{12605722316331458198}{\texttt{Base.VERSION}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
VERSION
\end{lstlisting}

A \texttt{VersionNumber} object describing which version of Julia is in use. For details see \hyperlink{10038787961375920908}{Version Number Literals}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/version.jl#L220-L225}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17914149694871263675}{} 
\hyperlink{17914149694871263675}{\texttt{Base.LOAD\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LOAD_PATH
\end{lstlisting}

An array of paths as strings or custom loader objects for the \texttt{require} function and \texttt{using} and \texttt{import} statements to consider when loading code. To create a custom loader type, define the type and then add appropriate methods to the \texttt{Base.load\_hook} function with the following signature:


\begin{lstlisting}
Base.load_hook(loader::Loader, name::String, found::Any)
\end{lstlisting}

The \texttt{loader} argument is the current value in \texttt{LOAD\_PATH}, \texttt{name} is the name of the module to load, and \texttt{found} is the path of any previously found code to provide \texttt{name}. If no provider has been found earlier in \texttt{LOAD\_PATH} then the value of \texttt{found} will be \texttt{nothing}. Custom loader functionality is experimental and may break or change in Julia 1.0.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/initdefs.jl#L30-L46}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15863123579738922895}{} 
\hyperlink{15863123579738922895}{\texttt{Base.JULIA\_HOME}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
JULIA_HOME
\end{lstlisting}

A string containing the full path to the directory containing the \texttt{julia} executable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/initdefs.jl#L71-L75}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2025151930480900450}{} 
\hyperlink{2025151930480900450}{\texttt{Core.ANY}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ANY
\end{lstlisting}

Equivalent to \texttt{Any} for dispatch purposes, but signals the compiler to skip code generation specialization for that field.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L699-L704}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8935415573697237606}{} 
\hyperlink{8935415573697237606}{\texttt{Base.Sys.CPU\_CORES}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.CPU_CORES
\end{lstlisting}

The number of logical CPU cores available in the system.

See the Hwloc.jl package for extended information, including number of physical cores.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L22-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6553323097149877235}{} 
\hyperlink{6553323097149877235}{\texttt{Base.Sys.WORD\_SIZE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.WORD_SIZE
\end{lstlisting}

Standard word size on the current machine, in bits.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L53-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9866627704997689218}{} 
\hyperlink{9866627704997689218}{\texttt{Base.Sys.KERNEL}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.KERNEL
\end{lstlisting}

A symbol representing the name of the operating system, as returned by \texttt{uname} of the build configuration.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L39-L43}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10411677719248532228}{} 
\hyperlink{10411677719248532228}{\texttt{Base.Sys.ARCH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.ARCH
\end{lstlisting}

A symbol representing the architecture of the build configuration.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L31-L35}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14835867711534070832}{} 
\hyperlink{14835867711534070832}{\texttt{Base.Sys.MACHINE}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Sys.MACHINE
\end{lstlisting}

A string containing the build triple.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sysinfo.jl#L46-L50}{\texttt{source}}


\end{adjustwidth}

Ver también:



\begin{itemize}
\item \hyperlink{13806523663202420575}{\texttt{STDIN}}


\item \hyperlink{2784333101804678420}{\texttt{STDOUT}}


\item \hyperlink{4481879903628924306}{\texttt{STDERR}}


\item \hyperlink{196658496437650743}{\texttt{ENV}}


\item \hyperlink{15528013539058180213}{\texttt{ENDIAN\_BOM}}


\item \texttt{Libc.MS\_ASYNC}


\item \texttt{Libc.MS\_INVALIDATE}


\item \texttt{Libc.MS\_SYNC}


\item \hyperlink{17268797014804593519}{\texttt{Libdl.DL\_LOAD\_PATH}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_DEEPBIND}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_LOCAL}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_NOLOAD}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_LAZY}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_NOW}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_GLOBAL}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_NODELETE}}


\item \hyperlink{9396575996390240710}{\texttt{Libdl.RTLD\_FIRST}}

\end{itemize}


\hypertarget{2712977310167057511}{}


\chapter{Sistema de Ficheros}


\hypertarget{16313884780490629439}{} 
\hyperlink{16313884780490629439}{\texttt{Base.Filesystem.pwd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pwd() -> AbstractString
\end{lstlisting}

Get the current working directory.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L32-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2737128667296781766}{} 
\hyperlink{2737128667296781766}{\texttt{Base.Filesystem.cd}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cd(dir::AbstractString=homedir())
\end{lstlisting}

Set the current working directory.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L44-L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5425414028590761114}{} 
\hyperlink{5425414028590761114}{\texttt{Base.Filesystem.cd}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cd(f::Function, dir::AbstractString=homedir())
\end{lstlisting}

Temporarily changes the current working directory and applies function \texttt{f} before returning.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L77-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3860759521350595217}{} 
\hyperlink{3860759521350595217}{\texttt{Base.Filesystem.readdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdir(dir::AbstractString=".") -> Vector{String}
\end{lstlisting}

Returns the files and directories in the directory \texttt{dir} (or the current working directory if not given).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L403-L407}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6143720268840384551}{} 
\hyperlink{6143720268840384551}{\texttt{Base.Filesystem.walkdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
walkdir(dir; topdown=true, follow_symlinks=false, onerror=throw)
\end{lstlisting}

The \texttt{walkdir} method returns an iterator that walks the directory tree of a directory. The iterator returns a tuple containing \texttt{(rootpath, dirs, files)}. The directory tree can be traversed top-down or bottom-up. If \texttt{walkdir} encounters a \hyperlink{16303515589950241655}{\texttt{SystemError}} it will rethrow the error by default. A custom error handling function can be provided through \texttt{onerror} keyword argument. \texttt{onerror} is called with a \texttt{SystemError} as argument.


\begin{lstlisting}
for (root, dirs, files) in walkdir(".")
    println("Directories in $root")
    for dir in dirs
        println(joinpath(root, dir)) # path to directories
    end
    println("Files in $root")
    for file in files
        println(joinpath(root, file)) # path to files
    end
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L433-L455}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17495480510333417689}{} 
\hyperlink{17495480510333417689}{\texttt{Base.Filesystem.mkdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mkdir(path::AbstractString, mode::Unsigned=0o777)
\end{lstlisting}

Make a new directory with name \texttt{path} and permissions \texttt{mode}. \texttt{mode} defaults to \texttt{0o777}, modified by the current file creation mask. This function never creates more than one directory. If the directory already exists, or some intermediate directories do not exist, this function throws an error. See \hyperlink{12505165128372133919}{\texttt{mkpath}} for a function which creates all required intermediate directories.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L84-L92}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12505165128372133919}{} 
\hyperlink{12505165128372133919}{\texttt{Base.Filesystem.mkpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mkpath(path::AbstractString, mode::Unsigned=0o777)
\end{lstlisting}

Create all directories in the given \texttt{path}, with permissions \texttt{mode}. \texttt{mode} defaults to \texttt{0o777}, modified by the current file creation mask.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L102-L107}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2547536134326433103}{} 
\hyperlink{2547536134326433103}{\texttt{Base.Filesystem.symlink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
symlink(target::AbstractString, link::AbstractString)
\end{lstlisting}

Creates a symbolic link to \texttt{target} with the name \texttt{link}.

\begin{quote}
\textbf{Note}

This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L543-L551}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17144805426178555631}{} 
\hyperlink{17144805426178555631}{\texttt{Base.Filesystem.readlink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readlink(path::AbstractString) -> AbstractString
\end{lstlisting}

Returns the target location a symbolic link \texttt{path} points to.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L574-L578}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11345760495317535206}{} 
\hyperlink{11345760495317535206}{\texttt{Base.Filesystem.chmod}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chmod(path::AbstractString, mode::Integer; recursive::Bool=false)
\end{lstlisting}

Change the permissions mode of \texttt{path} to \texttt{mode}. Only integer \texttt{mode}s (e.g. \texttt{0o777}) are currently supported. If \texttt{recursive=true} and the path is a directory all permissions in that directory will be recursively changed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L598-L604}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11782125422345839965}{} 
\hyperlink{11782125422345839965}{\texttt{Base.Filesystem.chown}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
chown(path::AbstractString, owner::Integer, group::Integer=-1)
\end{lstlisting}

Change the owner and/or group of \texttt{path} to \texttt{owner} and/or \texttt{group}. If the value entered for \texttt{owner} or \texttt{group} is \texttt{-1} the corresponding ID will not change. Only integer \texttt{owner}s and \texttt{group}s are currently supported.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L618-L623}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10861694406169986183}{} 
\hyperlink{10861694406169986183}{\texttt{Base.stat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stat(file)
\end{lstlisting}

Returns a structure whose fields contain information about the file. The fields of the structure are:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Name & Description \\
\hline
size & The size (in bytes) of the file \\
\hline
device & ID of the device that contains the file \\
\hline
inode & The inode number of the file \\
\hline
mode & The protection mode of the file \\
\hline
nlink & The number of hard links to the file \\
\hline
uid & The user id of the owner of the file \\
\hline
gid & The group id of the file owner \\
\hline
rdev & If this file refers to a device, the ID of the device it refers to \\
\hline
blksize & The file-system preferred block size for the file \\
\hline
blocks & The number of such blocks allocated \\
\hline
mtime & Unix timestamp of when the file was last modified \\
\hline
ctime & Unix timestamp of when the file was created \\
\hline
\end{tabulary}

\end{table}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L83-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14136422515630953157}{} 
\hyperlink{14136422515630953157}{\texttt{Base.Filesystem.lstat}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lstat(file)
\end{lstlisting}

Like \hyperlink{10861694406169986183}{\texttt{stat}}, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L107-L114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12867604313294084336}{} 
\hyperlink{12867604313294084336}{\texttt{Base.Filesystem.ctime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ctime(file)
\end{lstlisting}

Equivalent to \texttt{stat(file).ctime}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L140-L144}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6000535741376632237}{} 
\hyperlink{6000535741376632237}{\texttt{Base.Filesystem.mtime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mtime(file)
\end{lstlisting}

Equivalent to \texttt{stat(file).mtime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L133-L137}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13483994185565548500}{} 
\hyperlink{13483994185565548500}{\texttt{Base.Filesystem.filemode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filemode(file)
\end{lstlisting}

Equivalent to \texttt{stat(file).mode}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L119-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7772513328501904656}{} 
\hyperlink{7772513328501904656}{\texttt{Base.Filesystem.filesize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
filesize(path...)
\end{lstlisting}

Equivalent to \texttt{stat(file).size}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L126-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1627468638377378187}{} 
\hyperlink{1627468638377378187}{\texttt{Base.Filesystem.uperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
uperm(file)
\end{lstlisting}

Gets the permissions of the owner of the file as a bitfield of


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Value & Description \\
\hline
01 & Execute Permission \\
\hline
02 & Write Permission \\
\hline
04 & Read Permission \\
\hline
\end{tabulary}

\end{table}

For allowed arguments, see \hyperlink{10861694406169986183}{\texttt{stat}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L228-L240}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7004818904788863313}{} 
\hyperlink{7004818904788863313}{\texttt{Base.Filesystem.gperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
gperm(file)
\end{lstlisting}

Like \hyperlink{1627468638377378187}{\texttt{uperm}} but gets the permissions of the group owning the file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L243-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5276829438522229212}{} 
\hyperlink{5276829438522229212}{\texttt{Base.Filesystem.operm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
operm(file)
\end{lstlisting}

Like \hyperlink{1627468638377378187}{\texttt{uperm}} but gets the permissions for people who neither own the file nor are a member of the group owning the file



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L250-L255}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5101460505107133606}{} 
\hyperlink{5101460505107133606}{\texttt{Base.Filesystem.cp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cp(src::AbstractString, dst::AbstractString; remove_destination::Bool=false, follow_symlinks::Bool=false)
\end{lstlisting}

Copy the file, link, or directory from \texttt{src} to \texttt{dest}. \texttt{remove\_destination=true} will first remove an existing \texttt{dst}.

If \texttt{follow\_symlinks=false}, and \texttt{src} is a symbolic link, \texttt{dst} will be created as a symbolic link. If \texttt{follow\_symlinks=true} and \texttt{src} is a symbolic link, \texttt{dst} will be a copy of the file or directory \texttt{src} refers to.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L209-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3963309772903794843}{} 
\hyperlink{3963309772903794843}{\texttt{Base.download}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
download(url::AbstractString, [localfile::AbstractString])
\end{lstlisting}

Download a file from the given url, optionally renaming it to the given local file name. Note that this function relies on the availability of external tools such as \texttt{curl}, \texttt{wget} or \texttt{fetch} to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L635-L643}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5817011497347557360}{} 
\hyperlink{5817011497347557360}{\texttt{Base.Filesystem.mv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mv(src::AbstractString, dst::AbstractString; remove_destination::Bool=false)
\end{lstlisting}

Move the file, link, or directory from \texttt{src} to \texttt{dst}. \texttt{remove\_destination=true} will first remove an existing \texttt{dst}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L231-L236}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9379238926612566029}{} 
\hyperlink{9379238926612566029}{\texttt{Base.Filesystem.rm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rm(path::AbstractString; force::Bool=false, recursive::Bool=false)
\end{lstlisting}

Delete the file, link, or empty directory at the given path. If \texttt{force=true} is passed, a non-existing path is not treated as error. If \texttt{recursive=true} is passed and the path is a directory, then all contents are removed recursively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L129-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12527826024259193863}{} 
\hyperlink{12527826024259193863}{\texttt{Base.Filesystem.touch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
touch(path::AbstractString)
\end{lstlisting}

Update the last-modified timestamp on a file to the current time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L242-L246}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14845808124082506604}{} 
\hyperlink{14845808124082506604}{\texttt{Base.Filesystem.tempname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tempname()
\end{lstlisting}

Generate a unique temporary file path.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L343-L347}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9014859942851246694}{} 
\hyperlink{9014859942851246694}{\texttt{Base.Filesystem.tempdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tempdir()
\end{lstlisting}

Obtain the path of a temporary directory (possibly shared with other processes).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L336-L340}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2973920645063648749}{} 
\hyperlink{2973920645063648749}{\texttt{Base.Filesystem.mktemp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mktemp(parent=tempdir())
\end{lstlisting}

Returns \texttt{(path, io)}, where \texttt{path} is the path of a new temporary file in \texttt{parent} and \texttt{io} is an open file object for this path.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L350-L355}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17153527788740684124}{} 
\hyperlink{17153527788740684124}{\texttt{Base.Filesystem.mktemp}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mktemp(f::Function, parent=tempdir())
\end{lstlisting}

Apply the function \texttt{f} to the result of \hyperlink{2973920645063648749}{\texttt{mktemp(parent)}} and remove the temporary file upon completion.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L367-L372}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9834152207629649521}{} 
\hyperlink{9834152207629649521}{\texttt{Base.Filesystem.mktempdir}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mktempdir(parent=tempdir())
\end{lstlisting}

Create a temporary directory in the \texttt{parent} directory and return its path. If \texttt{parent} does not exist, throw an error.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L358-L363}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3895619673373952463}{} 
\hyperlink{3895619673373952463}{\texttt{Base.Filesystem.mktempdir}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mktempdir(f::Function, parent=tempdir())
\end{lstlisting}

Apply the function \texttt{f} to the result of \hyperlink{9834152207629649521}{\texttt{mktempdir(parent)}} and remove the temporary directory upon completion.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/file.jl#L383-L388}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12165280569414957484}{} 
\hyperlink{12165280569414957484}{\texttt{Base.Filesystem.isblockdev}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isblockdev(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a block device, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L177-L181}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16977107907382267368}{} 
\hyperlink{16977107907382267368}{\texttt{Base.Filesystem.ischardev}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ischardev(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a character device, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L163-L167}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3518595943652428720}{} 
\hyperlink{3518595943652428720}{\texttt{Base.Filesystem.isdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdir(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a directory, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L170-L174}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5085310894552406152}{} 
\hyperlink{5085310894552406152}{\texttt{Base.Filesystem.isfifo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isfifo(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a FIFO, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L156-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7436789928697285849}{} 
\hyperlink{7436789928697285849}{\texttt{Base.Filesystem.isfile}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isfile(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a regular file, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L184-L188}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4451336630382958860}{} 
\hyperlink{4451336630382958860}{\texttt{Base.Filesystem.islink}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
islink(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a symbolic link, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L191-L195}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5555615057884788946}{} 
\hyperlink{5555615057884788946}{\texttt{Base.Filesystem.ismount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ismount(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a mount point, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L296-L300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14301659288222317301}{} 
\hyperlink{14301659288222317301}{\texttt{Base.Filesystem.ispath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ispath(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a valid filesystem path, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L149-L153}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13653840348451879213}{} 
\hyperlink{13653840348451879213}{\texttt{Base.Filesystem.issetgid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issetgid(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} has the setgid flag set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L214-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16213917845195501776}{} 
\hyperlink{16213917845195501776}{\texttt{Base.Filesystem.issetuid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issetuid(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} has the setuid flag set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L207-L211}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17017605444718674714}{} 
\hyperlink{17017605444718674714}{\texttt{Base.Filesystem.issocket}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issocket(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} is a socket, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L198-L202}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5099487162005794677}{} 
\hyperlink{5099487162005794677}{\texttt{Base.Filesystem.issticky}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issticky(path) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{path} has the sticky bit set, \texttt{false} otherwise.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stat.jl#L221-L225}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10630566360559889134}{} 
\hyperlink{10630566360559889134}{\texttt{Base.Filesystem.homedir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
homedir() -> AbstractString
\end{lstlisting}

Return the current user{\textquotesingle}s home directory.

\begin{quote}
\textbf{Note}

\texttt{homedir} determines the home directory via \texttt{libuv}{\textquotesingle}s \texttt{uv\_os\_homedir}. For details (for example on how to specify the home directory via environment variables), see the \href{http://docs.libuv.org/en/v1.x/misc.html\#c.uv\_os\_homedir}{\texttt{uv\_os\_homedir} documentation}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L52-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10993431289442855643}{} 
\hyperlink{10993431289442855643}{\texttt{Base.Filesystem.dirname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dirname(path::AbstractString) -> AbstractString
\end{lstlisting}

Get the directory part of a path.


\begin{minted}{jlcon}
julia> dirname("/home/myuser")
"/home"
\end{minted}

See also: \hyperlink{16452154606861459390}{\texttt{basename}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L134-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16452154606861459390}{} 
\hyperlink{16452154606861459390}{\texttt{Base.Filesystem.basename}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
basename(path::AbstractString) -> AbstractString
\end{lstlisting}

Get the file name part of a path.


\begin{minted}{jlcon}
julia> basename("/home/myuser/example.jl")
"example.jl"
\end{minted}

See also: \hyperlink{10993431289442855643}{\texttt{dirname}}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L148-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1518763743618824993}{} 
\hyperlink{1518763743618824993}{\texttt{Base.@\_\_FILE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@__FILE__ -> AbstractString
\end{lstlisting}

\texttt{@\_\_FILE\_\_} expands to a string with the absolute file path of the file containing the macro. Returns \texttt{nothing} if run from a REPL or an empty string if evaluated by \texttt{julia -e <expr>}. Alternatively see \hyperlink{9054270179006636705}{\texttt{PROGRAM\_FILE}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L548-L554}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12719499456415901450}{} 
\hyperlink{12719499456415901450}{\texttt{Base.@\_\_DIR\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@__DIR__ -> AbstractString
\end{lstlisting}

\texttt{@\_\_DIR\_\_} expands to a string with the directory part of the absolute path of the file containing the macro. Returns \texttt{nothing} if run from a REPL or an empty string if evaluated by \texttt{julia -e <expr>}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/loading.jl#L557-L563}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12003659955179127885}{} 
\hyperlink{12003659955179127885}{\texttt{@\_\_LINE\_\_}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@__LINE__ -> Int
\end{lstlisting}

\texttt{@\_\_LINE\_\_} expands to the line number of the call-site.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L647-L651}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13394819469005127600}{} 
\hyperlink{13394819469005127600}{\texttt{Base.Filesystem.isabspath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isabspath(path::AbstractString) -> Bool
\end{lstlisting}

Determines whether a path is absolute (begins at the root directory).


\begin{minted}{jlcon}
julia> isabspath("/home")
true

julia> isabspath("home")
false
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L86-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7293742883276660783}{} 
\hyperlink{7293742883276660783}{\texttt{Base.Filesystem.isdirpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isdirpath(path::AbstractString) -> Bool
\end{lstlisting}

Determines whether a path refers to a directory (for example, ends with a path separator).


\begin{minted}{jlcon}
julia> isdirpath("/home")
false

julia> isdirpath("/home/")
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L101-L113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12470257079932202886}{} 
\hyperlink{12470257079932202886}{\texttt{Base.Filesystem.joinpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
joinpath(parts...) -> AbstractString
\end{lstlisting}

Join path components into a full path. If some argument is an absolute path, then prior components are dropped.


\begin{minted}{jlcon}
julia> joinpath("/home/myuser","example.jl")
"/home/myuser/example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L194-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4673100532388501717}{} 
\hyperlink{4673100532388501717}{\texttt{Base.Filesystem.abspath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
abspath(path::AbstractString) -> AbstractString
\end{lstlisting}

Convert a path to an absolute path by adding the current directory if necessary.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L264-L268}{\texttt{source}}



\begin{lstlisting}
abspath(path::AbstractString, paths::AbstractString...) -> AbstractString
\end{lstlisting}

Convert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to \texttt{abspath(joinpath(path, paths...))}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L271-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5019859018770545283}{} 
\hyperlink{5019859018770545283}{\texttt{Base.Filesystem.normpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
normpath(path::AbstractString) -> AbstractString
\end{lstlisting}

Normalize a path, removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries.


\begin{minted}{jlcon}
julia> normpath("/home/myuser/../example.jl")
"/home/example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L219-L228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6055776470592315771}{} 
\hyperlink{6055776470592315771}{\texttt{Base.Filesystem.realpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
realpath(path::AbstractString) -> AbstractString
\end{lstlisting}

Canonicalize a path by expanding symbolic links and removing {\textquotedbl}.{\textquotedbl} and {\textquotedbl}..{\textquotedbl} entries.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L319-L323}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16322454670651695984}{} 
\hyperlink{16322454670651695984}{\texttt{Base.Filesystem.relpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
relpath(path::AbstractString, startpath::AbstractString = ".") -> AbstractString
\end{lstlisting}

Return a relative filepath to \texttt{path} either from the current directory or from an optional start directory. This is a path computation: the filesystem is not accessed to confirm the existence or nature of \texttt{path} or \texttt{startpath}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L350-L356}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10521892386506791258}{} 
\hyperlink{10521892386506791258}{\texttt{Base.Filesystem.expanduser}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
expanduser(path::AbstractString) -> AbstractString
\end{lstlisting}

On Unix systems, replace a tilde character at the start of a path with the current user{\textquotesingle}s home directory.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L342-L346}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8483950538709909733}{} 
\hyperlink{8483950538709909733}{\texttt{Base.Filesystem.splitdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
splitdir(path::AbstractString) -> (AbstractString, AbstractString)
\end{lstlisting}

Split a path into a tuple of the directory name and file name.


\begin{minted}{jlcon}
julia> splitdir("/home/myuser")
("/home", "myuser")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L116-L125}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14253131097250488223}{} 
\hyperlink{14253131097250488223}{\texttt{Base.Filesystem.splitdrive}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
splitdrive(path::AbstractString) -> (AbstractString, AbstractString)
\end{lstlisting}

On Windows, split a path into the drive letter part and the path part. On Unix systems, the first component is always the empty string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L44-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4740094249280549542}{} 
\hyperlink{4740094249280549542}{\texttt{Base.Filesystem.splitext}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
splitext(path::AbstractString) -> (AbstractString, AbstractString)
\end{lstlisting}

If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.


\begin{minted}{jlcon}
julia> splitext("/home/myuser/example.jl")
("/home/myuser/example", ".jl")

julia> splitext("/home/myuser/example")
("/home/myuser/example", "")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/path.jl#L162-L176}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4334683019621329817}{}


\chapter{E/S y Redes}



\hypertarget{17923260793180482441}{}


\section{E/S General}


\hypertarget{2784333101804678420}{} 
\hyperlink{2784333101804678420}{\texttt{Base.STDOUT}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
STDOUT
\end{lstlisting}

Global variable referring to the standard out stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libuv.jl#L114-L118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4481879903628924306}{} 
\hyperlink{4481879903628924306}{\texttt{Base.STDERR}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
STDERR
\end{lstlisting}

Global variable referring to the standard error stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libuv.jl#L121-L125}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13806523663202420575}{} 
\hyperlink{13806523663202420575}{\texttt{Base.STDIN}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
STDIN
\end{lstlisting}

Global variable referring to the standard input stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libuv.jl#L107-L111}{\texttt{source}}


\end{adjustwidth}
\hypertarget{300818094931158296}{} 
\hyperlink{300818094931158296}{\texttt{Base.open}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
open(filename::AbstractString, [read::Bool, write::Bool, create::Bool, truncate::Bool, append::Bool]) -> IOStream
\end{lstlisting}

Open a file in a mode specified by five boolean arguments. The default is to open files for reading only. Returns a stream for accessing the file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L96-L101}{\texttt{source}}



\begin{lstlisting}
open(filename::AbstractString, [mode::AbstractString]) -> IOStream
\end{lstlisting}

Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of \texttt{mode} correspond to those from \texttt{fopen(3)} or Perl \texttt{open}, and are equivalent to setting the following boolean groups:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Mode & Description \\
\hline
r & read \\
\hline
r+ & read, write \\
\hline
w & write, create, truncate \\
\hline
w+ & read, write, create, truncate \\
\hline
a & write, create, append \\
\hline
a+ & read, write, create, append \\
\hline
\end{tabulary}

\end{table}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L115-L130}{\texttt{source}}



\begin{lstlisting}
open(f::Function, args...)
\end{lstlisting}

Apply the function \texttt{f} to the result of \texttt{open(args...)} and close the resulting file descriptor upon completion.

\textbf{Example}: \texttt{open(readstring, {\textquotedbl}file.txt{\textquotedbl})}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L141-L148}{\texttt{source}}



\begin{lstlisting}
open(command, mode::AbstractString="r", stdio=DevNull)
\end{lstlisting}

Start running \texttt{command} asynchronously, and return a tuple \texttt{(stream,process)}.  If \texttt{mode} is \texttt{{\textquotedbl}r{\textquotedbl}}, then \texttt{stream} reads from the process{\textquotesingle}s standard output and \texttt{stdio} optionally specifies the process{\textquotesingle}s standard input stream.  If \texttt{mode} is \texttt{{\textquotedbl}w{\textquotedbl}}, then \texttt{stream} writes to the process{\textquotesingle}s standard input and \texttt{stdio} optionally specifies the process{\textquotesingle}s standard output stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L565-L573}{\texttt{source}}



\begin{lstlisting}
open(f::Function, command, mode::AbstractString="r", stdio=DevNull)
\end{lstlisting}

Similar to \texttt{open(command, mode, stdio)}, but calls \texttt{f(stream)} on the resulting read or write stream, then closes the stream and waits for the process to complete.  Returns the value returned by \texttt{f}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/process.jl#L591-L597}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15789326112236459498}{} 
\hyperlink{15789326112236459498}{\texttt{Base.IOBuffer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IOBuffer([data,],[readable::Bool=true, writable::Bool=true, [maxsize::Int=typemax(Int)]])
\end{lstlisting}

Create an \texttt{IOBuffer}, which may optionally operate on a pre-existing array. If the readable/writable arguments are given, they restrict whether or not the buffer may be read from or written to respectively. The last argument optionally specifies a size beyond which the buffer may not be grown.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L34-L41}{\texttt{source}}



\begin{lstlisting}
IOBuffer() -> IOBuffer
\end{lstlisting}

Create an in-memory I/O stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L51-L55}{\texttt{source}}



\begin{lstlisting}
IOBuffer(size::Int)
\end{lstlisting}

Create a fixed size IOBuffer. The buffer will not grow dynamically.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L58-L62}{\texttt{source}}



\begin{lstlisting}
IOBuffer(string::String)
\end{lstlisting}

Create a read-only \texttt{IOBuffer} on the data underlying the given string.


\begin{minted}{jlcon}
julia> io = IOBuffer("Haho");

julia> String(take!(io))
"Haho"

julia> String(take!(io))
"Haho"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L152-L166}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4360129174058888556}{} 
\hyperlink{4360129174058888556}{\texttt{Base.take!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
take!(b::IOBuffer)
\end{lstlisting}

Obtain the contents of an \texttt{IOBuffer} as an array, without copying. Afterwards, the \texttt{IOBuffer} is reset to its initial state.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L266-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4200832604380534486}{} 
\hyperlink{4200832604380534486}{\texttt{Base.fdio}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -> IOStream
\end{lstlisting}

Create an \texttt{IOStream} object from an integer file descriptor. If \texttt{own} is \texttt{true}, closing this object will close the underlying descriptor. By default, an \texttt{IOStream} is closed when it is garbage collected. \texttt{name} allows you to associate the descriptor with a named file.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L80-L86}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4551926523947041107}{} 
\hyperlink{4551926523947041107}{\texttt{Base.flush}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flush(stream)
\end{lstlisting}

Commit all currently buffered writes to the given stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L641-L645}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5331333469799487255}{} 
\hyperlink{5331333469799487255}{\texttt{Base.close}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
close(stream)
\end{lstlisting}

Close an I/O stream. Performs a \hyperlink{4551926523947041107}{\texttt{flush}} first.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L22-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16947913578760238729}{} 
\hyperlink{16947913578760238729}{\texttt{Base.write}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
write(stream::IO, x)
write(filename::AbstractString, x)
\end{lstlisting}

Write the canonical binary representation of a value to the given I/O stream or file. Returns the number of bytes written into the stream.

You can write multiple values with the same \texttt{write} call. i.e. the following are equivalent:


\begin{lstlisting}
write(stream, x, y...)
write(stream, x) + write(stream, y...)
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L52-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8104134490906192097}{} 
\hyperlink{8104134490906192097}{\texttt{Base.read}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
read(filename::AbstractString, args...)
\end{lstlisting}

Open a file and read its contents. \texttt{args} is passed to \texttt{read}: this is equivalent to \texttt{open(io->read(io, args...), filename)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L154-L159}{\texttt{source}}



\begin{lstlisting}
read(stream::IO, T, dims)
\end{lstlisting}

Read a series of values of type \texttt{T} from \texttt{stream}, in canonical binary representation. \texttt{dims} is either a tuple or a series of integer arguments specifying the size of the \texttt{Array\{T\}} to return.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L377-L383}{\texttt{source}}



\begin{lstlisting}
read(s::IO, nb=typemax(Int))
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{s}, returning a \texttt{Vector\{UInt8\}} of the bytes read.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L520-L524}{\texttt{source}}



\begin{lstlisting}
read(s::IOStream, nb::Integer; all=true)
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{s}, returning a \texttt{Vector\{UInt8\}} of the bytes read.

If \texttt{all} is \texttt{true} (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If \texttt{all} is \texttt{false}, at most one \texttt{read} call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the \texttt{all} option.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L295-L304}{\texttt{source}}



\begin{lstlisting}
read(stream::IO, T)
\end{lstlisting}

Read a single value of type \texttt{T} from \texttt{stream}, in canonical binary representation.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1482-L1486}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7305890466159196010}{} 
\hyperlink{7305890466159196010}{\texttt{Base.read!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
read!(stream::IO, array::Union{Array, BitArray})
read!(filename::AbstractString, array::Union{Array, BitArray})
\end{lstlisting}

Read binary data from an I/O stream or file, filling in \texttt{array}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L39-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14376170011353973168}{} 
\hyperlink{14376170011353973168}{\texttt{Base.readbytes!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{stream} into \texttt{b}, returning the number of bytes read. The size of \texttt{b} will be increased if needed (i.e. if \texttt{nb} is greater than \texttt{length(b)} and enough bytes could be read), but it will never be decreased.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L495-L501}{\texttt{source}}



\begin{lstlisting}
readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)
\end{lstlisting}

Read at most \texttt{nb} bytes from \texttt{stream} into \texttt{b}, returning the number of bytes read. The size of \texttt{b} will be increased if needed (i.e. if \texttt{nb} is greater than \texttt{length(b)} and enough bytes could be read), but it will never be decreased.

See \hyperlink{8104134490906192097}{\texttt{read}} for a description of the \texttt{all} option.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iostream.jl#L268-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14873825528169247088}{} 
\hyperlink{14873825528169247088}{\texttt{Base.unsafe\_read}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_read(io::IO, ref, nbytes::UInt)
\end{lstlisting}

Copy \texttt{nbytes} from the \texttt{IO} stream object into \texttt{ref} (converted to a pointer).

It is recommended that subtypes \texttt{T<:IO} override the following method signature to provide more efficient implementations: \texttt{unsafe\_read(s::T, p::Ptr\{UInt8\}, n::UInt)}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L86-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7085957152663564741}{} 
\hyperlink{7085957152663564741}{\texttt{Base.unsafe\_write}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_write(io::IO, ref, nbytes::UInt)
\end{lstlisting}

Copy \texttt{nbytes} from \texttt{ref} (converted to a pointer) into the \texttt{IO} object.

It is recommended that subtypes \texttt{T<:IO} override the following method signature to provide more efficient implementations: \texttt{unsafe\_write(s::T, p::Ptr\{UInt8\}, n::UInt)}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L69-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14999933350742523048}{} 
\hyperlink{14999933350742523048}{\texttt{Base.position}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
position(s)
\end{lstlisting}

Get the current position of a stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1224-L1228}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11269748483301652100}{} 
\hyperlink{11269748483301652100}{\texttt{Base.seek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
seek(s, pos)
\end{lstlisting}

Seek a stream to the given position.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1057-L1061}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17809695755202491288}{} 
\hyperlink{17809695755202491288}{\texttt{Base.seekstart}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
seekstart(s)
\end{lstlisting}

Seek a stream to its beginning.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1691-L1695}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7051129712452805515}{} 
\hyperlink{7051129712452805515}{\texttt{Base.seekend}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
seekend(s)
\end{lstlisting}

Seek a stream to its end.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2654-L2658}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3828582500400083834}{} 
\hyperlink{3828582500400083834}{\texttt{Base.skip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
skip(s, offset)
\end{lstlisting}

Seek a stream relative to the current position.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L785-L789}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12695720152576749628}{} 
\hyperlink{12695720152576749628}{\texttt{Base.mark}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mark(s)
\end{lstlisting}

Add a mark at the current position of stream \texttt{s}. Returns the marked position.

See also \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{17642823092929127210}{\texttt{reset}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L589-L595}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1677829146244042320}{} 
\hyperlink{1677829146244042320}{\texttt{Base.unmark}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unmark(s)
\end{lstlisting}

Remove a mark from stream \texttt{s}. Returns \texttt{true} if the stream was marked, \texttt{false} otherwise.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{17642823092929127210}{\texttt{reset}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L600-L606}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17642823092929127210}{} 
\hyperlink{17642823092929127210}{\texttt{Base.reset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reset(s)
\end{lstlisting}

Reset a stream \texttt{s} to a previously marked position, and remove the mark. Returns the previously marked position. Throws an error if the stream is not marked.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{5764088774799520350}{\texttt{ismarked}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L613-L620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5764088774799520350}{} 
\hyperlink{5764088774799520350}{\texttt{Base.ismarked}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ismarked(s)
\end{lstlisting}

Returns \texttt{true} if stream \texttt{s} is marked.

See also \hyperlink{12695720152576749628}{\texttt{mark}}, \hyperlink{1677829146244042320}{\texttt{unmark}}, \hyperlink{17642823092929127210}{\texttt{reset}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L629-L635}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1214745596749163873}{} 
\hyperlink{1214745596749163873}{\texttt{Base.eof}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eof(stream) -> Bool
\end{lstlisting}

Tests whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return \texttt{false}. Therefore it is always safe to read one byte after seeing \texttt{eof} return \texttt{false}. \texttt{eof} will return \texttt{false} as long as buffered data is still available, even if the remote end of a connection is closed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L137-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3535270730162763546}{} 
\hyperlink{3535270730162763546}{\texttt{Base.isreadonly}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isreadonly(stream) -> Bool
\end{lstlisting}

Determine whether a stream is read-only.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L275-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5354682531169079914}{} 
\hyperlink{5354682531169079914}{\texttt{Base.iswritable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iswritable(io) -> Bool
\end{lstlisting}

Returns \texttt{true} if the specified IO object is writable (if that can be determined).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L43-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7695515320845284530}{} 
\hyperlink{7695515320845284530}{\texttt{Base.isreadable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isreadable(io) -> Bool
\end{lstlisting}

Returns \texttt{true} if the specified IO object is readable (if that can be determined).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L36-L40}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12411519405593851135}{} 
\hyperlink{12411519405593851135}{\texttt{Base.isopen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isopen(object) -> Bool
\end{lstlisting}

Determine whether an object - such as a stream, timer, or mmap – is not yet closed. Once an object is closed, it will never produce a new event. However, a closed stream may still have data to read in its buffer, use \hyperlink{1214745596749163873}{\texttt{eof}} to check for the ability to read data. Use \hyperlink{3484187138285863365}{\texttt{poll\_fd}} to be notified when a stream might be writable or readable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L12-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11136223858024612210}{} 
\hyperlink{11136223858024612210}{\texttt{Base.Serializer.serialize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
serialize(stream, value)
\end{lstlisting}

Write an arbitrary value to a stream in an opaque format, such that it can be read back by \hyperlink{9415765884989850449}{\texttt{deserialize}}. The read-back value will be as identical as possible to the original. In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image. \texttt{Ptr} values are serialized as all-zero bit patterns (\texttt{NULL}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L990-L998}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9415765884989850449}{} 
\hyperlink{9415765884989850449}{\texttt{Base.Serializer.deserialize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
deserialize(stream)
\end{lstlisting}

Read a value written by \hyperlink{11136223858024612210}{\texttt{serialize}}. \texttt{deserialize} assumes the binary data read from \texttt{stream} is correct and has been serialized by a compatible implementation of \hyperlink{11136223858024612210}{\texttt{serialize}}. It has been designed with simplicity and performance as a goal and does not validate the data read. Malformed data can result in process termination. The caller has to ensure the integrity and correctness of data read from \texttt{stream}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1997-L2005}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13482565886944504957}{} 
\hyperlink{13482565886944504957}{\texttt{Base.Grisu.print\_shortest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
print_shortest(io, x)
\end{lstlisting}

Print the shortest possible representation, with the minimum number of consecutive non-zero digits, of number \texttt{x}, ensuring that it would parse to the exact same number.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L572-L577}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4096210142404798505}{} 
\hyperlink{4096210142404798505}{\texttt{Base.fd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fd(stream)
\end{lstlisting}

Returns the file descriptor backing the stream or file. Note that this function only applies to synchronous \texttt{File}{\textquotesingle}s and \texttt{IOStream}{\textquotesingle}s not to any of the asynchronous streams.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L420-L425}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1112291265677833393}{} 
\hyperlink{1112291265677833393}{\texttt{Base.redirect\_stdout}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stdout([stream]) -> (rd, wr)
\end{lstlisting}

Create a pipe to which all C and Julia level \hyperlink{2784333101804678420}{\texttt{STDOUT}} output will be redirected. Returns a tuple \texttt{(rd, wr)} representing the pipe ends. Data written to \hyperlink{2784333101804678420}{\texttt{STDOUT}} may now be read from the \texttt{rd} end of the pipe. The \texttt{wr} end is given for convenience in case the old \hyperlink{2784333101804678420}{\texttt{STDOUT}} object was cached by the user and needs to be replaced elsewhere.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1042-L1055}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12923908242336925438}{} 
\hyperlink{12923908242336925438}{\texttt{Base.redirect\_stdout}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stdout(f::Function, stream)
\end{lstlisting}

Run the function \texttt{f} while redirecting \hyperlink{2784333101804678420}{\texttt{STDOUT}} to \texttt{stream}. Upon completion, \hyperlink{2784333101804678420}{\texttt{STDOUT}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1094-L1102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17653990356642003163}{} 
\hyperlink{17653990356642003163}{\texttt{Base.redirect\_stderr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stderr([stream]) -> (rd, wr)
\end{lstlisting}

Like \hyperlink{1112291265677833393}{\texttt{redirect\_stdout}}, but for \hyperlink{4481879903628924306}{\texttt{STDERR}}.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1058-L1065}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4630317800478362301}{} 
\hyperlink{4630317800478362301}{\texttt{Base.redirect\_stderr}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stderr(f::Function, stream)
\end{lstlisting}

Run the function \texttt{f} while redirecting \hyperlink{4481879903628924306}{\texttt{STDERR}} to \texttt{stream}. Upon completion, \hyperlink{4481879903628924306}{\texttt{STDERR}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1105-L1113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17751303507361009787}{} 
\hyperlink{17751303507361009787}{\texttt{Base.redirect\_stdin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stdin([stream]) -> (rd, wr)
\end{lstlisting}

Like \hyperlink{1112291265677833393}{\texttt{redirect\_stdout}}, but for \hyperlink{13806523663202420575}{\texttt{STDIN}}. Note that the order of the return tuple is still \texttt{(rd, wr)}, i.e. data to be read from \hyperlink{13806523663202420575}{\texttt{STDIN}} may be written to \texttt{wr}.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1068-L1077}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17205945783347532140}{} 
\hyperlink{17205945783347532140}{\texttt{Base.redirect\_stdin}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redirect_stdin(f::Function, stream)
\end{lstlisting}

Run the function \texttt{f} while redirecting \hyperlink{13806523663202420575}{\texttt{STDIN}} to \texttt{stream}. Upon completion, \hyperlink{13806523663202420575}{\texttt{STDIN}} is restored to its prior setting.

\begin{quote}
\textbf{Note}

\texttt{stream} must be a \texttt{TTY}, a \texttt{Pipe}, or a \texttt{TCPSocket}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L1116-L1124}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1622401395685476756}{} 
\hyperlink{1622401395685476756}{\texttt{Base.readchomp}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readchomp(x)
\end{lstlisting}

Read the entirety of \texttt{x} as a string and remove a single trailing newline. Equivalent to \texttt{chomp!(readstring(x))}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L485-L490}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16572122454613115528}{} 
\hyperlink{16572122454613115528}{\texttt{Base.truncate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
truncate(file,n)
\end{lstlisting}

Resize the file or buffer given by the first argument to exactly \texttt{n} bytes, filling previously unallocated space with {\textquotesingle}{\textbackslash}0{\textquotesingle} if the file or buffer is grown.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L615-L620}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6177395059245061697}{} 
\hyperlink{6177395059245061697}{\texttt{Base.skipchars}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
skipchars(stream, predicate; linecomment::Char)
\end{lstlisting}

Advance the stream until before the first character for which \texttt{predicate} returns \texttt{false}. For example \texttt{skipchars(stream, isspace)} will skip all whitespace. If keyword argument \texttt{linecomment} is specified, characters from that character through the end of a line will also be skipped.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2494-L2501}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5045242378447855641}{} 
\hyperlink{5045242378447855641}{\texttt{Base.DataFmt.countlines}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
countlines(io::IO, eol::Char='\n')
\end{lstlisting}

Read \texttt{io} until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than \texttt{{\textquotesingle}{\textbackslash}n{\textquotesingle}} are supported by passing them as the second argument.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L20-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959584405141637900}{} 
\hyperlink{16959584405141637900}{\texttt{Base.PipeBuffer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
PipeBuffer(data::Vector{UInt8}=UInt8[],[maxsize::Int=typemax(Int)])
\end{lstlisting}

An \hyperlink{15789326112236459498}{\texttt{IOBuffer}} that allows reading and performs writes by appending. Seeking and truncating are not supported. See \hyperlink{15789326112236459498}{\texttt{IOBuffer}} for the available constructors. If \texttt{data} is given, creates a \texttt{PipeBuffer} to operate on a data vector, optionally specifying a size beyond which the underlying \texttt{Array} may not be grown.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iobuffer.jl#L67-L75}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11079438348370067557}{} 
\hyperlink{11079438348370067557}{\texttt{Base.readavailable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readavailable(stream)
\end{lstlisting}

Read all available data on the stream, blocking the task only if no data is available. The result is a \texttt{Vector\{UInt8,1\}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2138-L2143}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13454403377667762339}{} 
\hyperlink{13454403377667762339}{\texttt{Base.IOContext}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IOContext
\end{lstlisting}

\texttt{IOContext} provides a mechanism for passing output configuration settings among \hyperlink{14071376285304310153}{\texttt{show}} methods.

In short, it is an immutable dictionary that is a subclass of \texttt{IO}. It supports standard dictionary operations such as \hyperlink{2839226020402435013}{\texttt{getindex}}, and can also be used as an I/O stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/show.jl#L5-L12}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15316695504427164836}{} 
\hyperlink{15316695504427164836}{\texttt{Base.IOContext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IOContext(io::IO, KV::Pair)
\end{lstlisting}

Create an \texttt{IOContext} that wraps a given stream, adding the specified \texttt{key=>value} pair to the properties of that stream (note that \texttt{io} can itself be an \texttt{IOContext}).

\begin{itemize}
\item use \texttt{(key => value) in dict} to see if this particular combination is in the properties set


\item use \texttt{get(dict, key, default)} to retrieve the most recent value for a particular key

\end{itemize}
The following properties are in common use:

\begin{itemize}
\item \texttt{:compact}: Boolean specifying that small values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements.


\item \texttt{:limit}: Boolean specifying that containers should be truncated, e.g. showing \texttt{…} in place of most elements.


\item \texttt{:displaysize}: A \texttt{Tuple\{Int,Int\}} giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the \texttt{displaysize} function.

\end{itemize}

\begin{minted}{jlcon}
julia> function f(io::IO)
           if get(io, :short, false)
               print(io, "short")
           else
               print(io, "loooooong")
           end
       end
f (generic function with 1 method)

julia> f(STDOUT)
loooooong
julia> f(IOContext(STDOUT, :short => true))
short
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/show.jl#L54-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9657846139399432866}{} 
\hyperlink{9657846139399432866}{\texttt{Base.IOContext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IOContext(io::IO, context::IOContext)
\end{lstlisting}

Create an \texttt{IOContext} that wraps an alternate \texttt{IO} but inherits the properties of \texttt{context}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/show.jl#L47-L51}{\texttt{source}}


\end{adjustwidth}

\hypertarget{3938862926454188721}{}


\section{E/S Texto}


\hypertarget{14071376285304310153}{} 
\hyperlink{14071376285304310153}{\texttt{Base.show}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
show(x)
\end{lstlisting}

Write an informative text representation of a value to the current output stream. New types should overload \texttt{show(io, x)} where the first argument is a stream. The representation used by \texttt{show} generally includes Julia-specific formatting and type information.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1853-L1859}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5384438952883464143}{} 
\hyperlink{5384438952883464143}{\texttt{Base.showcompact}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
showcompact(x)
\end{lstlisting}

Show a compact representation of a value.

This is used for printing array elements without repeating type information (which would be redundant with that printed once for the whole array), and without line breaks inside the representation of an element.

To offer a compact representation different from its standard one, a custom type should test \texttt{get(io, :compact, false)} in its normal \texttt{show} method.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L822-L833}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16724886348217614039}{} 
\hyperlink{16724886348217614039}{\texttt{Base.showall}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
showall(x)
\end{lstlisting}

Similar to \hyperlink{14071376285304310153}{\texttt{show}}, except shows all elements of arrays.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2095-L2099}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17506338626525391609}{} 
\hyperlink{17506338626525391609}{\texttt{Base.summary}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
summary(x)
\end{lstlisting}

Return a string giving a brief description of a value. By default returns \texttt{string(typeof(x))}, e.g. \hyperlink{7720564657383125058}{\texttt{Int64}}.

For arrays, returns a string of size and type info, e.g. \texttt{10-element Array\{Int64,1\}}.


\begin{minted}{jlcon}
julia> summary(1)
"Int64"

julia> summary(zeros(2))
"2-element Array{Float64,1}"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/show.jl#L1544-L1560}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8248717042415202230}{} 
\hyperlink{8248717042415202230}{\texttt{Base.print}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
print(io::IO, x)
\end{lstlisting}

Write to \texttt{io} (or to the default output stream \hyperlink{2784333101804678420}{\texttt{STDOUT}} if \texttt{io} is not given) a canonical (un-decorated) text representation of a value if there is one, otherwise call \hyperlink{14071376285304310153}{\texttt{show}}. The representation used by \texttt{print} includes minimal formatting and tries to avoid Julia-specific details.


\begin{minted}{jlcon}
julia> print("Hello World!")
Hello World!
julia> io = IOBuffer();

julia> print(io, "Hello World!")

julia> String(take!(io))
"Hello World!"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L6-L25}{\texttt{source}}


\end{adjustwidth}
\hypertarget{783803254548423222}{} 
\hyperlink{783803254548423222}{\texttt{Base.println}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
println(io::IO, xs...)
\end{lstlisting}

Print (using \hyperlink{8248717042415202230}{\texttt{print}}) \texttt{xs} followed by a newline. If \texttt{io} is not supplied, prints to \hyperlink{2784333101804678420}{\texttt{STDOUT}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L48-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16954147589040544738}{} 
\hyperlink{16954147589040544738}{\texttt{Base.print\_with\_color}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
print_with_color(color::Union{Symbol, Int}, [io], xs...; bold::Bool = false)
\end{lstlisting}

Print \texttt{xs} in a color specified as a symbol.

\texttt{color} may take any of the values \texttt{:normal}, \texttt{:default}, \texttt{:bold}, \texttt{:black}, \texttt{:blue}, \texttt{:cyan}, \texttt{:green}, \texttt{:light\_black}, \texttt{:light\_blue}, \texttt{:light\_cyan}, \texttt{:light\_green}, \texttt{:light\_magenta}, \texttt{:light\_red}, \texttt{:light\_yellow}, \texttt{:magenta}, \texttt{:nothing}, \texttt{:red}, \texttt{:white}, or  \texttt{:yellow} or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword \texttt{bold} is given as \texttt{true}, the result will be printed in bold.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L408-L416}{\texttt{source}}


\end{adjustwidth}
\hypertarget{356857067498015374}{} 
\hyperlink{356857067498015374}{\texttt{Base.info}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
info([io, ] msg..., [prefix="INFO: "])
\end{lstlisting}

Display an informational message. Argument \texttt{msg} is a string describing the information to be displayed. The \texttt{prefix} keyword argument can be used to override the default prepending of \texttt{msg}.


\begin{minted}{jlcon}
julia> info("hello world")
INFO: hello world

julia> info("hello world"; prefix="MY INFO: ")
MY INFO: hello world
\end{minted}

See also \hyperlink{4663706027956713409}{\texttt{logging}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L508-L525}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9965317267326412304}{} 
\hyperlink{9965317267326412304}{\texttt{Base.warn}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
warn([io, ] msg..., [prefix="WARNING: ", once=false, key=nothing, bt=nothing, filename=nothing, lineno::Int=0])
\end{lstlisting}

Display a warning. Argument \texttt{msg} is a string describing the warning to be displayed.  Set \texttt{once} to true and specify a \texttt{key} to only display \texttt{msg} the first time \texttt{warn} is called.  If \texttt{bt} is not \texttt{nothing} a backtrace is displayed. If \texttt{filename} is not \texttt{nothing} both it and \texttt{lineno} are displayed.

See also \hyperlink{4663706027956713409}{\texttt{logging}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L543-L552}{\texttt{source}}



\begin{lstlisting}
warn(msg)
\end{lstlisting}

Display a warning. Argument \texttt{msg} is a string describing the warning to be displayed.


\begin{minted}{jlcon}
julia> warn("Beep Beep")
WARNING: Beep Beep
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L579-L588}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4663706027956713409}{} 
\hyperlink{4663706027956713409}{\texttt{Base.logging}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
logging(io [, m [, f]][; kind=:all])
logging([; kind=:all])
\end{lstlisting}

Stream output of informational, warning, and/or error messages to \texttt{io}, overriding what was otherwise specified.  Optionally, divert stream only for module \texttt{m}, or specifically function \texttt{f} within \texttt{m}.  \texttt{kind} can be \texttt{:all} (the default), \texttt{:info}, \texttt{:warn}, or \texttt{:error}.  See \texttt{Base.log\_\{info,warn,error\}\_to} for the current set of redirections.  Call \texttt{logging} with no arguments (or just the \texttt{kind}) to reset everything.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/util.jl#L482-L492}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4087473154660177488}{} 
\hyperlink{4087473154660177488}{\texttt{Base.Printf.@printf}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@printf([io::IOStream], "%Fmt", args...)
\end{lstlisting}

Print \texttt{args} using C \texttt{printf()} style format specification string, with some caveats: \texttt{Inf} and \texttt{NaN} are printed consistently as \texttt{Inf} and \texttt{NaN} for flags \texttt{\%a}, \texttt{\%A}, \texttt{\%e}, \texttt{\%E}, \texttt{\%f}, \texttt{\%F}, \texttt{\%g}, and \texttt{\%G}. Furthermore, if a floating point number is equally close to the numeric values of two possible output strings, the output string further away from zero is chosen.

Optionally, an \texttt{IOStream} may be passed as the first argument to redirect output.

\textbf{Examples}


\begin{minted}{jlcon}
julia> @printf("%f %F %f %F\n", Inf, Inf, NaN, NaN)
Inf Inf NaN NaN


julia> @printf "%.0f %.1f %f\n" 0.5 0.025 -0.0078125
1 0.0 -0.007813
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/printf.jl#L1196-L1218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17601282773395979269}{} 
\hyperlink{17601282773395979269}{\texttt{Base.Printf.@sprintf}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@sprintf("%Fmt", args...)
\end{lstlisting}

Return \texttt{@printf} formatted output as string.

\textbf{Examples}


\begin{minted}{jlcon}
julia> s = @sprintf "this is a %s %15.1f" "test" 34.567;

julia> println(s)
this is a test            34.6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/printf.jl#L1229-L1242}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6652981552509545835}{} 
\hyperlink{6652981552509545835}{\texttt{Base.sprint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sprint(f::Function, args...)
\end{lstlisting}

Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string.


\begin{minted}{jlcon}
julia> sprint(showcompact, 66.66666)
"66.6667"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/io.jl#L71-L81}{\texttt{source}}


\end{adjustwidth}
\hypertarget{991925725019765935}{} 
\hyperlink{991925725019765935}{\texttt{Base.showerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
showerror(io, e)
\end{lstlisting}

Show a descriptive representation of an exception object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1754-L1758}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15981569052160951906}{} 
\hyperlink{15981569052160951906}{\texttt{Base.dump}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dump(x)
\end{lstlisting}

Show every part of the representation of a value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L530-L534}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6219586633767848672}{} 
\hyperlink{6219586633767848672}{\texttt{Base.readstring}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readstring(stream::IO)
readstring(filename::AbstractString)
\end{lstlisting}

Read the entire contents of an I/O stream or a file as a string. The text is assumed to be encoded in UTF-8.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L533-L539}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14199256323314707596}{} 
\hyperlink{14199256323314707596}{\texttt{Base.readline}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readline(stream::IO=STDIN; chomp::Bool=true)
readline(filename::AbstractString; chomp::Bool=true)
\end{lstlisting}

Read a single line of text from the given I/O stream or file (defaults to \texttt{STDIN}). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with \texttt{{\textquotesingle}{\textbackslash}n{\textquotesingle}} or \texttt{{\textquotedbl}{\textbackslash}r{\textbackslash}n{\textquotedbl}} or the end of an input stream. When \texttt{chomp} is true (as it is by default), these trailing newline characters are removed from the line before it is returned. When \texttt{chomp} is false, they are returned as part of the line.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L172-L182}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16924445721840905654}{} 
\hyperlink{16924445721840905654}{\texttt{Base.readuntil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readuntil(stream::IO, delim)
readuntil(filename::AbstractString, delim)
\end{lstlisting}

Read a string from an I/O stream or a file, up to and including the given delimiter byte. The text is assumed to be encoded in UTF-8.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L163-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2102076388448706590}{} 
\hyperlink{2102076388448706590}{\texttt{Base.readlines}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readlines(stream::IO=STDIN; chomp::Bool=true)
readlines(filename::AbstractString; chomp::Bool=true)
\end{lstlisting}

Read all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading \texttt{readline} repeatedly with the same arguments and saving the resulting lines as a vector of strings.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L201-L208}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3474649815265066504}{} 
\hyperlink{3474649815265066504}{\texttt{Base.eachline}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eachline(stream::IO=STDIN; chomp::Bool=true)
eachline(filename::AbstractString; chomp::Bool=true)
\end{lstlisting}

Create an iterable \texttt{EachLine} object that will yield each line from an I/O stream or a file. Iteration calls \texttt{readline} on the stream argument repeatedly with \texttt{chomp} passed through, determining whether trailing end-of-line characters are removed. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the \texttt{EachLine} object is garbage collected.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L554-L564}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9382495003440185140}{} 
\hyperlink{9382495003440185140}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, delim::Char, T::Type, eol::Char; header=false, skipstart=0, skipblanks=true, use_mmap, quotes=true, dims, comments=true, comment_char='#')
\end{lstlisting}

Read a matrix from the source where each line (separated by \texttt{eol}) gives one row, with elements separated by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be used by passing the byte array representation of the mapped segment as source.

If \texttt{T} is a numeric type, the result is an array of that type, with any non-numeric elements as \texttt{NaN} for floating-point types, or zero. Other useful values of \texttt{T} include \texttt{String}, \texttt{AbstractString}, and \texttt{Any}.

If \texttt{header} is \texttt{true}, the first row of data will be read as header and the tuple \texttt{(data\_cells, header\_cells)} is returned instead of only \texttt{data\_cells}.

Specifying \texttt{skipstart} will ignore the corresponding number of initial lines from the input.

If \texttt{skipblanks} is \texttt{true}, blank lines in the input will be ignored.

If \texttt{use\_mmap} is \texttt{true}, the file specified by \texttt{source} is memory mapped for potential speedups. Default is \texttt{true} except on Windows. On Windows, you may want to specify \texttt{true} if the file is large, and is only read once and not written to.

If \texttt{quotes} is \texttt{true}, columns enclosed within double-quote ({\textquotedbl}) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote.  Specifying \texttt{dims} as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files.  If \texttt{comments} is \texttt{true}, lines beginning with \texttt{comment\_char} and text following \texttt{comment\_char} in any line are ignored.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L84-L113}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2430245096432163029}{} 
\hyperlink{2430245096432163029}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, delim::Char, eol::Char; options...)
\end{lstlisting}

If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L75-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13737782927171831895}{} 
\hyperlink{13737782927171831895}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, delim::Char, T::Type; options...)
\end{lstlisting}

The end of line delimiter is taken as \texttt{{\textbackslash}n}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L49-L53}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16397506814949064411}{} 
\hyperlink{16397506814949064411}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, delim::Char; options...)
\end{lstlisting}

The end of line delimiter is taken as \texttt{{\textbackslash}n}. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L66-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8065367939876398829}{} 
\hyperlink{8065367939876398829}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source, T::Type; options...)
\end{lstlisting}

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \texttt{{\textbackslash}n}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L41-L46}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13577128997343551591}{} 
\hyperlink{13577128997343551591}{\texttt{Base.DataFmt.readdlm}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readdlm(source; options...)
\end{lstlisting}

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as \texttt{{\textbackslash}n}. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L56-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3228819019064430057}{} 
\hyperlink{3228819019064430057}{\texttt{Base.DataFmt.writedlm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
writedlm(f, A, delim='\t'; opts)
\end{lstlisting}

Write \texttt{A} (a vector, matrix, or an iterable collection of iterable rows) as text to \texttt{f} (either a filename string or an \texttt{IO} stream) using the given delimiter \texttt{delim} (which defaults to tab, but can be any printable Julia object, typically a \texttt{Char} or \texttt{AbstractString}).

For example, two vectors \texttt{x} and \texttt{y} of the same length can be written as two columns of tab-delimited text to \texttt{f} by either \texttt{writedlm(f, [x y])} or by \texttt{writedlm(f, zip(x, y))}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L687-L697}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8771248700292165260}{} 
\hyperlink{8771248700292165260}{\texttt{Base.DataFmt.readcsv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
readcsv(source, [T::Type]; options...)
\end{lstlisting}

Equivalent to \hyperlink{9382495003440185140}{\texttt{readdlm}} with \texttt{delim} set to comma, and type optionally defined by \texttt{T}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1768-L1772}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1579565529432627071}{} 
\hyperlink{1579565529432627071}{\texttt{Base.DataFmt.writecsv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
writecsv(filename, A; opts)
\end{lstlisting}

Equivalent to \hyperlink{3228819019064430057}{\texttt{writedlm}} with \texttt{delim} set to comma.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/datafmt.jl#L700-L704}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3188538343315807377}{} 
\hyperlink{3188538343315807377}{\texttt{Base.Base64.Base64EncodePipe}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base64EncodePipe(ostream)
\end{lstlisting}

Returns a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes written to \texttt{ostream}. Calling \hyperlink{5331333469799487255}{\texttt{close}} on the \texttt{Base64EncodePipe} stream is necessary to complete the encoding (but does not close \texttt{ostream}).


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> iob64_encode = Base64EncodePipe(io);

julia> write(iob64_encode, "Hello!")
6

julia> close(iob64_encode);

julia> str = String(take!(io))
"SGVsbG8h"

julia> String(base64decode(str))
"Hello!"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base64.jl#L17-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3574609743667104023}{} 
\hyperlink{3574609743667104023}{\texttt{Base.Base64.Base64DecodePipe}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Base64DecodePipe(istream)
\end{lstlisting}

Returns a new read-only I/O stream, which decodes base64-encoded data read from \texttt{istream}.


\begin{minted}{jlcon}
julia> io = IOBuffer();

julia> iob64_decode = Base64DecodePipe(io);

julia> write(io, "SGVsbG8h")
8

julia> seekstart(io);

julia> String(read(iob64_decode))
"Hello!"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base64.jl#L205-L223}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13087986527599604968}{} 
\hyperlink{13087986527599604968}{\texttt{Base.Base64.base64encode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
base64encode(writefunc, args...)
base64encode(args...)
\end{lstlisting}

Given a \hyperlink{16947913578760238729}{\texttt{write}}-like function \texttt{writefunc}, which takes an I/O stream as its first argument, \texttt{base64encode(writefunc, args...)} calls \texttt{writefunc} to write \texttt{args...} to a base64-encoded string, and returns the string. \texttt{base64encode(args...)} is equivalent to \texttt{base64encode(write, args...)}: it converts its arguments into bytes using the standard \hyperlink{16947913578760238729}{\texttt{write}} functions and returns the base64-encoded string.

See also \hyperlink{16416907859759611603}{\texttt{base64decode}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base64.jl#L182-L193}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16416907859759611603}{} 
\hyperlink{16416907859759611603}{\texttt{Base.Base64.base64decode}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
base64decode(string)
\end{lstlisting}

Decodes the base64-encoded \texttt{string} and returns a \texttt{Vector\{UInt8\}} of the decoded bytes.

See also \hyperlink{13087986527599604968}{\texttt{base64encode}}


\begin{minted}{jlcon}
julia> b = base64decode("SGVsbG8h")
6-element Array{UInt8,1}:
 0x48
 0x65
 0x6c
 0x6c
 0x6f
 0x21

julia> String(b)
"Hello!"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/base64.jl#L257-L277}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1969380123003883060}{} 
\hyperlink{1969380123003883060}{\texttt{Base.displaysize}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
displaysize(io) -> (lines, columns)
\end{lstlisting}

Return the nominal size of the screen that may be used for rendering output to this io object



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L351-L353}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7442676307456961159}{}


\section{E/S Multimedia}



Del mismo modo que la salida de texto se realiza mediante \hyperlink{8248717042415202230}{\texttt{print}} y los tipos definidos por el usuario pueden indicar su representación textual sobrecargando \hyperlink{14071376285304310153}{\texttt{show}}, Julia proporciona un mecanismo estandarizado para una salida multimedia enriquecida (como imágenes, texto formateado, o incluso audio y video), que consta de tres partes:



\begin{itemize}
\item Una función \hyperlink{12073120410747960438}{\texttt{display(x)}} para solicitar la visualización multimedia más completa disponible de un objeto Julia \texttt{x} (con una reserva de texto sin formato).


\item Sobrecargar \hyperlink{14071376285304310153}{\texttt{show}} permite indicar representaciones multimedia arbitrarias (codificadas mediante tipos MIME estándar) de tipos definidos por el usuario.


\item Pueden registrarse backends de visualización con capacidad multimedia subclasificando un tipo genérico de \texttt{Display} y poniéndolos en una pila de backends de visualización mediante \hyperlink{13142233867690107090}{\texttt{pushdisplay}}.

\end{itemize}


El tiempo de ejecución base de Julia solo proporciona visualización de texto sin formato, pero las pantallas más ricas pueden habilitarse cargando módulos externos o utilizando entornos gráficos de Julia (como el \emph{notebook} IJulia, basado en IPython).


\hypertarget{12073120410747960438}{} 
\hyperlink{12073120410747960438}{\texttt{Base.Multimedia.display}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
display(x)
display(d::Display, x)
display(mime, x)
display(d::Display, mime, x)
\end{lstlisting}

Display \texttt{x} using the topmost applicable display in the display stack, typically using the richest supported multimedia output for \texttt{x}, with plain-text \hyperlink{2784333101804678420}{\texttt{STDOUT}} output as a fallback. The \texttt{display(d, x)} variant attempts to display \texttt{x} on the given display \texttt{d} only, throwing a \texttt{MethodError} if \texttt{d} cannot display objects of this type.

There are also two variants with a \texttt{mime} argument (a MIME type string, such as \texttt{{\textquotedbl}image/png{\textquotedbl}}), which attempt to display \texttt{x} using the requested MIME type \emph{only}, throwing a \texttt{MethodError} if this type is not supported by either the display(s) or by \texttt{x}. With these variants, one can also supply the {\textquotedbl}raw{\textquotedbl} data in the requested MIME type by passing \texttt{x::AbstractString} (for MIME types with text-based storage, such as text/html or application/postscript) or \texttt{x::Vector\{UInt8\}} (for binary MIME types).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L544-L561}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3747338623378176831}{} 
\hyperlink{3747338623378176831}{\texttt{Base.Multimedia.redisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
redisplay(x)
redisplay(d::Display, x)
redisplay(mime, x)
redisplay(d::Display, mime, x)
\end{lstlisting}

By default, the \texttt{redisplay} functions simply call \hyperlink{12073120410747960438}{\texttt{display}}. However, some display backends may override \texttt{redisplay} to modify an existing display of \texttt{x} (if any). Using \texttt{redisplay} is also a hint to the backend that \texttt{x} may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L480-L492}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18261911967873698059}{} 
\hyperlink{18261911967873698059}{\texttt{Base.Multimedia.displayable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
displayable(mime) -> Bool
displayable(d::Display, mime) -> Bool
\end{lstlisting}

Returns a boolean value indicating whether the given \texttt{mime} type (string) is displayable by any of the displays in the current display stack, or specifically by the display \texttt{d} in the second variant.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L128-L135}{\texttt{source}}


\end{adjustwidth}
\hypertarget{552201489544217829}{} 
\hyperlink{552201489544217829}{\texttt{Base.show}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
show(stream, mime, x)
\end{lstlisting}

The \texttt{display} functions ultimately call \texttt{show} in order to write an object \texttt{x} as a given \texttt{mime} type to a given I/O \texttt{stream} (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type \texttt{T}, it is only necessary to define a new \texttt{show} method for \texttt{T}, via: \texttt{show(stream, ::MIME{\textquotedbl}mime{\textquotedbl}, x::T) = ...}, where \texttt{mime} is a MIME-type string and the function body calls \texttt{write} (or similar) to write that representation of \texttt{x} to \texttt{stream}. (Note that the \texttt{MIME{\textquotedbl}{\textquotedbl}} notation only supports literal strings; to construct \texttt{MIME} types in a more flexible manner use \texttt{MIME\{Symbol({\textquotedbl}{\textquotedbl})\}}.)

For example, if you define a \texttt{MyImage} type and know how to write it to a PNG file, you could define a function \texttt{show(stream, ::MIME{\textquotedbl}image/png{\textquotedbl}, x::MyImage) = ...} to allow your images to be displayed on any PNG-capable \texttt{Display} (such as IJulia). As usual, be sure to \texttt{import Base.show} in order to add new methods to the built-in Julia function \texttt{show}.

The default MIME type is \texttt{MIME{\textquotedbl}text/plain{\textquotedbl}}. There is a fallback definition for \texttt{text/plain} output that calls \texttt{show} with 2 arguments. Therefore, this case should be handled by defining a 2-argument \texttt{show(stream::IO, x::MyType)} method.

Technically, the \texttt{MIME{\textquotedbl}mime{\textquotedbl}} macro defines a singleton type for the given \texttt{mime} string, which allows us to exploit Julia{\textquotesingle}s dispatch mechanisms in determining how to display objects of any given type.

The first argument to \texttt{show} can be an \hyperlink{13454403377667762339}{\texttt{IOContext}} specifying output format properties. See \hyperlink{13454403377667762339}{\texttt{IOContext}} for details.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1705-L1733}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12716323487860336005}{} 
\hyperlink{12716323487860336005}{\texttt{Base.Multimedia.mimewritable}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
mimewritable(mime, x)
\end{lstlisting}

Returns a boolean value indicating whether or not the object \texttt{x} can be written as the given \texttt{mime} type. (By default, this is determined automatically by the existence of the corresponding \hyperlink{14071376285304310153}{\texttt{show}} method for \texttt{typeof(x)}.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L28-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18010164488978074745}{} 
\hyperlink{18010164488978074745}{\texttt{Base.Multimedia.reprmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reprmime(mime, x)
\end{lstlisting}

Returns an \texttt{AbstractString} or \texttt{Vector\{UInt8\}} containing the representation of \texttt{x} in the requested \texttt{mime} type, as written by \texttt{show} (throwing a \texttt{MethodError} if no appropriate \texttt{show} is available). An \texttt{AbstractString} is returned for MIME types with textual representations (such as \texttt{{\textquotedbl}text/html{\textquotedbl}} or \texttt{{\textquotedbl}application/postscript{\textquotedbl}}), whereas binary data is returned as \texttt{Vector\{UInt8\}}. (The function \texttt{istextmime(mime)} returns whether or not Julia treats a given \texttt{mime} type as text.)

As a special case, if \texttt{x} is an \texttt{AbstractString} (for textual MIME types) or a \texttt{Vector\{UInt8\}} (for binary MIME types), the \texttt{reprmime} function assumes that \texttt{x} is already in the requested \texttt{mime} format and simply returns \texttt{x}. This special case does not apply to the \texttt{{\textquotedbl}text/plain{\textquotedbl}} MIME type. This is useful so that raw data can be passed to \texttt{display(m::MIME, x)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L44-L60}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11286854929227524690}{} 
\hyperlink{11286854929227524690}{\texttt{Base.Multimedia.stringmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stringmime(mime, x)
\end{lstlisting}

Returns an \texttt{AbstractString} containing the representation of \texttt{x} in the requested \texttt{mime} type. This is similar to \hyperlink{18010164488978074745}{\texttt{reprmime}} except that binary data is base64-encoded as an ASCII string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L76-L82}{\texttt{source}}


\end{adjustwidth}

Como se mencionó anteriormente, también se pueden definir nuevos backends de pantalla. Por ejemplo, un módulo que puede mostrar imágenes PNG en una ventana puede registrar esta capacidad con Julia, de modo que al llamar a \hyperlink{12073120410747960438}{\texttt{display(x)}} en tipos con representaciones PNG, se mostrará automáticamente la imagen usando la ventana del módulo.



Para definir un nuevo backend de pantalla, primero se debe crear un subtipo \texttt{D} de la clase abstracta \texttt{Display}. Luego, para cada tipo MIME (cadena \texttt{mime}) que se puede mostrar en \texttt{D}, se debe definir una función \texttt{display(d::D, ::MIME{\textquotedbl}mime{\textquotedbl}, x) = ...} que muestra \texttt{x} como ese tipo MIME, generalmente llamando a \hyperlink{18010164488978074745}{\texttt{reprmime(mime, x)}}. Se debe lanzar un \texttt{MethodError} si \texttt{x} no se puede mostrar como ese tipo MIME; esto es automático si se llama a \hyperlink{18010164488978074745}{\texttt{reprmime}}. Finalmente, se debe definir una función \texttt{display(d::D, x)} que consulte \hyperlink{12716323487860336005}{\texttt{mimewritable(mime,x)}} para los tipos \texttt{mime} soportados por \texttt{D} y muestre el {\textquotedbl}mejor{\textquotedbl}; debe lanzarse un \texttt{MethodError} si no se encuentran tipos MIME soportados para \texttt{x}. Del mismo modo, algunos subtipos pueden sobreescribir \hyperlink{3747338623378176831}{\texttt{redisplay(d::D, ...)}}. (De nuevo, se debe hacer \texttt{import Base.display} para agregar nuevos métodos a \texttt{display}.) Los valores de retorno de estas funciones dependen de la implementación (ya que en algunos casos puede ser útil devolver un {\textquotedbl}manejador{\textquotedbl} \emph{handle} de visualización de algún tipo). Las funciones de visualización para \texttt{D} se pueden llamar directamente, pero también se pueden invocar automáticamente desde \hyperlink{12073120410747960438}{\texttt{display(x)}} simplemente presionando una nueva pantalla en la pila display-backend con:


\hypertarget{13142233867690107090}{} 
\hyperlink{13142233867690107090}{\texttt{Base.Multimedia.pushdisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pushdisplay(d::Display)
\end{lstlisting}

Pushes a new display \texttt{d} on top of the global display-backend stack. Calling \texttt{display(x)} or \texttt{display(mime, x)} will display \texttt{x} on the topmost compatible backend in the stack (i.e., the topmost backend that does not throw a \texttt{MethodError}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1657-L1663}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8186818521201126118}{} 
\hyperlink{8186818521201126118}{\texttt{Base.Multimedia.popdisplay}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
popdisplay()
popdisplay(d::Display)
\end{lstlisting}

Pop the topmost backend off of the display-backend stack, or the topmost copy of \texttt{d} in the second variant.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1064-L1070}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15269032442876270904}{} 
\hyperlink{15269032442876270904}{\texttt{Base.Multimedia.TextDisplay}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
TextDisplay(io::IO)
\end{lstlisting}

Returns a \texttt{TextDisplay <: Display}, which displays any object as the text/plain MIME type (by default), writing the text representation to the given I/O stream. (This is how objects are printed in the Julia REPL.)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L141-L147}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14215879795817507566}{} 
\hyperlink{14215879795817507566}{\texttt{Base.Multimedia.istextmime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
istextmime(m::MIME)
\end{lstlisting}

Determine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multimedia.jl#L88-L93}{\texttt{source}}


\end{adjustwidth}

\hypertarget{1564933839463822836}{}


\section{E/S Mapeada en Memoria}


\hypertarget{9383012227778120639}{} 
\hyperlink{9383012227778120639}{\texttt{Base.Mmap.Anonymous}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mmap.Anonymous(name, readonly, create)
\end{lstlisting}

Create an \texttt{IO}-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in \texttt{Mmap.mmap}. Used by \texttt{SharedArray} for creating shared memory arrays.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L672-L677}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4658285737360128506}{} 
\hyperlink{4658285737360128506}{\texttt{Base.Mmap.mmap}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mmap.mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)
       Mmap.mmap(type::Type{Array{T,N}}, dims)
\end{lstlisting}

Create an \texttt{Array} whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer{\textquotesingle}s memory.

The type is an \texttt{Array\{T,N\}} with a bits-type element of \texttt{T} and dimension \texttt{N} that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).

\texttt{dims} is a tuple or single \hyperlink{8469131683393450448}{\texttt{Integer}} specifying the size or length of the array.

The file is passed via the stream argument, either as an open \texttt{IOStream} or filename string. When you initialize the stream, use \texttt{{\textquotedbl}r{\textquotedbl}} for a {\textquotedbl}read-only{\textquotedbl} array, and \texttt{{\textquotedbl}w+{\textquotedbl}} to create a new array used to write values to disk.

If no \texttt{type} argument is specified, the default is \texttt{Vector\{UInt8\}}.

Optionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file. The default value for the offset is the current stream position for an \texttt{IOStream}.

The \texttt{grow} keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is < requested array size). Write privileges are required to grow the file.

The \texttt{shared} keyword argument specifies whether the resulting \texttt{Array} and changes made to it will be visible to other processes mapping the same file.

For example, the following code


\begin{minted}{julia}
# Create a file for mmapping
# (you could alternatively use mmap to do this step, too)
A = rand(1:20, 5, 30)
s = open("/tmp/mmap.bin", "w+")
# We'll write the dimensions of the array as the first two Ints in the file
write(s, size(A,1))
write(s, size(A,2))
# Now write the data
write(s, A)
close(s)

# Test by reading it back in
s = open("/tmp/mmap.bin")   # default is read-only
m = read(s, Int)
n = read(s, Int)
A2 = Mmap.mmap(s, Matrix{Int}, (m,n))
\end{minted}

creates a \texttt{m}-by-\texttt{n} \texttt{Matrix\{Int\}}, linked to the file associated with stream \texttt{s}.

A more portable file would need to encode the word size – 32 bit or 64 bit – and endianness information in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be used with memory-mapping).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L240-L297}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17132422346626139321}{} 
\hyperlink{17132422346626139321}{\texttt{Base.Mmap.mmap}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mmap.mmap(io, BitArray, [dims, offset])
\end{lstlisting}

Create a \texttt{BitArray} whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as \hyperlink{4658285737360128506}{\texttt{mmap}}, but the byte representation is different.

\textbf{Example}: \texttt{B = Mmap.mmap(s, BitArray, (25,30000))}

This would create a 25-by-30000 \texttt{BitArray}, linked to the file associated with stream \texttt{s}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L300-L310}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4141078992819732828}{} 
\hyperlink{4141078992819732828}{\texttt{Base.Mmap.sync!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Mmap.sync!(array)
\end{lstlisting}

Forces synchronization between the in-memory version of a memory-mapped \texttt{Array} or \texttt{BitArray} and the on-disk version.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1454-L1459}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4209570105021842946}{}


\section{E/S por Red}


\hypertarget{9152037818560122293}{} 
\hyperlink{9152037818560122293}{\texttt{Base.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
connect([host], port::Integer) -> TCPSocket
\end{lstlisting}

Connect to the host \texttt{host} on port \texttt{port}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L732-L736}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1353346423333598473}{} 
\hyperlink{1353346423333598473}{\texttt{Base.connect}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
connect(path::AbstractString) -> PipeEndpoint
\end{lstlisting}

Connect to the named pipe / UNIX domain socket at \texttt{path}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L990-L994}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10380677384505520251}{} 
\hyperlink{10380677384505520251}{\texttt{Base.listen}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
listen([addr, ]port::Integer; backlog::Integer=BACKLOG_DEFAULT) -> TCPServer
\end{lstlisting}

Listen on port on the address specified by \texttt{addr}. By default this listens on \texttt{localhost} only. To listen on all interfaces pass \texttt{IPv4(0)} or \texttt{IPv6(0)} as appropriate. \texttt{backlog} determines how many connections can be pending (not having called \hyperlink{7162820662735004343}{\texttt{accept}}) before the server will begin to reject them. The default value of \texttt{backlog} is 511.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L760-L769}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14347492126759386648}{} 
\hyperlink{14347492126759386648}{\texttt{Base.listen}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
listen(path::AbstractString) -> PipeServer
\end{lstlisting}

Create and listen on a named pipe / UNIX domain socket.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stream.jl#L961-L965}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8137893525760517927}{} 
\hyperlink{8137893525760517927}{\texttt{Base.getaddrinfo}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getaddrinfo(host::AbstractString) -> IPAddr
\end{lstlisting}

Gets the IP address of the \texttt{host} (may have to do a DNS lookup)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L634-L638}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14708587739545871216}{} 
\hyperlink{14708587739545871216}{\texttt{Base.getsockname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
getsockname(sock::Union{TCPServer, TCPSocket}) -> (IPAddr, UInt16)
\end{lstlisting}

Get the IP address and the port that the given \texttt{TCPSocket} is connected to (or bound to, in the case of \texttt{TCPServer}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L845-L850}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5743057836324524757}{} 
\hyperlink{5743057836324524757}{\texttt{Base.IPv4}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IPv4(host::Integer) -> IPv4
\end{lstlisting}

Returns an IPv4 object from ip address \texttt{host} formatted as an \hyperlink{8469131683393450448}{\texttt{Integer}}.


\begin{minted}{jlcon}
julia> IPv4(3223256218)
ip"192.30.252.154"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L24-L33}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5798078005905633860}{} 
\hyperlink{5798078005905633860}{\texttt{Base.IPv6}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
IPv6(host::Integer) -> IPv6
\end{lstlisting}

Returns an IPv6 object from ip address \texttt{host} formatted as an \hyperlink{8469131683393450448}{\texttt{Integer}}.


\begin{minted}{jlcon}
julia> IPv6(3223256218)
ip"::c01e:fc9a"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L76-L85}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12266333145421576763}{} 
\hyperlink{12266333145421576763}{\texttt{Base.nb\_available}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nb_available(stream)
\end{lstlisting}

Returns the number of bytes available for reading before a read from this stream or buffer will block.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L130-L134}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7162820662735004343}{} 
\hyperlink{7162820662735004343}{\texttt{Base.accept}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
accept(server[,client])
\end{lstlisting}

Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L663-L669}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7883192476116766616}{} 
\hyperlink{7883192476116766616}{\texttt{Base.listenany}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
listenany([host::IPAddr,] port_hint) -> (UInt16, TCPServer)
\end{lstlisting}

Create a \texttt{TCPServer} on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L818-L823}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3484187138285863365}{} 
\hyperlink{3484187138285863365}{\texttt{Base.Filesystem.poll\_fd}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
poll_fd(fd, timeout_s::Real=-1; readable=false, writable=false)
\end{lstlisting}

Monitor a file descriptor \texttt{fd} for changes in the read or write availability, and with a timeout given by \texttt{timeout\_s} seconds.

The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to \texttt{true}.

The returned value is an object with boolean fields \texttt{readable}, \texttt{writable}, and \texttt{timedout}, giving the result of the polling.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/poll.jl#L434-L445}{\texttt{source}}


\end{adjustwidth}
\hypertarget{929081692282555917}{} 
\hyperlink{929081692282555917}{\texttt{Base.Filesystem.poll\_file}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
poll_file(path::AbstractString, interval_s::Real=5.007, timeout_s::Real=-1) -> (previous::StatStruct, current::StatStruct)
\end{lstlisting}

Monitor a file for changes by polling every \texttt{interval\_s} seconds until a change occurs or \texttt{timeout\_s} seconds have elapsed. The \texttt{interval\_s} should be a long period; the default is 5.007 seconds.

Returns a pair of \texttt{StatStruct} objects \texttt{(previous, current)} when a change is detected.

To determine when a file was modified, compare \texttt{mtime(prev) != mtime(current)} to detect notification of changes. However, using \hyperlink{11014074322803760052}{\texttt{watch\_file}} for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/poll.jl#L514-L526}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11014074322803760052}{} 
\hyperlink{11014074322803760052}{\texttt{Base.Filesystem.watch\_file}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
watch_file(path::AbstractString, timeout_s::Real=-1)
\end{lstlisting}

Watch file or directory \texttt{path} for changes until a change occurs or \texttt{timeout\_s} seconds have elapsed.

The returned value is an object with boolean fields \texttt{changed}, \texttt{renamed}, and \texttt{timedout}, giving the result of watching the file.

This behavior of this function varies slightly across platforms. See \href{https://nodejs.org/api/fs.html\#fs\_caveats}{https://nodejs.org/api/fs.html\#fs\_caveats} for more detailed information.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/poll.jl#L474-L485}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13811388816704022260}{} 
\hyperlink{13811388816704022260}{\texttt{Base.bind}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
bind(socket::Union{UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false, reuseaddr=false, kws...)
\end{lstlisting}

Bind \texttt{socket} to the given \texttt{host:port}. Note that \texttt{0.0.0.0} will listen on all devices.

\begin{itemize}
\item The \texttt{ipv6only} parameter disables dual stack mode. If \texttt{ipv6only=true}, only an IPv6 stack is created.


\item If \texttt{reuseaddr=true}, multiple threads or processes can bind to the same address without error if they all set \texttt{reuseaddr=true}, but only the last to bind will receive any traffic.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L415-L423}{\texttt{source}}



\begin{lstlisting}
bind(chnl::Channel, task::Task)
\end{lstlisting}

Associates the lifetime of \texttt{chnl} with a task. Channel \texttt{chnl} is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on \texttt{chnl}.

The \texttt{chnl} object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.

When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @schedule foreach(i->put!(c, i), 1:4);

julia> bind(c,task);

julia> for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia> isopen(c)
false
\end{minted}


\begin{minted}{jlcon}
julia> c = Channel(0);

julia> task = @schedule (put!(c,1);error("foo"));

julia> bind(c,task);

julia> take!(c)
1

julia> put!(c,1);
ERROR: foo
Stacktrace:
 [1] check_channel_state(::Channel{Any}) at ./channels.jl:131
 [2] put!(::Channel{Any}, ::Int64) at ./channels.jl:261
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/channels.jl#L151-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12578302244914335012}{} 
\hyperlink{12578302244914335012}{\texttt{Base.send}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
send(socket::UDPSocket, host, port::Integer, msg)
\end{lstlisting}

Send \texttt{msg} over \texttt{socket} to \texttt{host:port}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L551-L555}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10601222310551867735}{} 
\hyperlink{10601222310551867735}{\texttt{Base.recv}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
recv(socket::UDPSocket)
\end{lstlisting}

Read a UDP packet from the specified socket, and return the bytes received. This call blocks.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L480-L484}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9185179791660962548}{} 
\hyperlink{9185179791660962548}{\texttt{Base.recvfrom}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
recvfrom(socket::UDPSocket) -> (address, data)
\end{lstlisting}

Read a UDP packet from the specified socket, returning a tuple of \texttt{(address, data)}, where \texttt{address} will be either IPv4 or IPv6 as appropriate.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L490-L495}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3917638683513443755}{} 
\hyperlink{3917638683513443755}{\texttt{Base.setopt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setopt(sock::UDPSocket; multicast_loop = nothing, multicast_ttl=nothing, enable_broadcast=nothing, ttl=nothing)
\end{lstlisting}

Set UDP socket options.

\begin{itemize}
\item \texttt{multicast\_loop}: loopback for multicast packets (default: \texttt{true}).


\item \texttt{multicast\_ttl}: TTL for multicast packets (default: \texttt{nothing}).


\item \texttt{enable\_broadcast}: flag must be set to \texttt{true} if socket will be used for broadcast messages, or else the UDP system will return an access error (default: \texttt{false}).


\item \texttt{ttl}: Time-to-live of packets sent on the socket (default: \texttt{nothing}).

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/socket.jl#L451-L461}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17463337378549787661}{} 
\hyperlink{17463337378549787661}{\texttt{Base.ntoh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ntoh(x)
\end{lstlisting}

Converts the endianness of a value from Network byte order (big-endian) to that used by the Host.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L246-L250}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17749829108559566344}{} 
\hyperlink{17749829108559566344}{\texttt{Base.hton}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hton(x)
\end{lstlisting}

Converts the endianness of a value from that used by the Host to Network byte order (big-endian).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L253-L257}{\texttt{source}}


\end{adjustwidth}
\hypertarget{931615445303306874}{} 
\hyperlink{931615445303306874}{\texttt{Base.ltoh}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ltoh(x)
\end{lstlisting}

Converts the endianness of a value from Little-endian to that used by the Host.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L260-L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6797011189807622497}{} 
\hyperlink{6797011189807622497}{\texttt{Base.htol}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
htol(x)
\end{lstlisting}

Converts the endianness of a value from that used by the Host to Little-endian.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L267-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15528013539058180213}{} 
\hyperlink{15528013539058180213}{\texttt{Base.ENDIAN\_BOM}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ENDIAN_BOM
\end{lstlisting}

The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value \texttt{0x04030201}. Big-endian machines will contain the value \texttt{0x01020304}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/io.jl#L237-L243}{\texttt{source}}


\end{adjustwidth}

\hypertarget{15930311186113323480}{}


\chapter{Puntuación}



Puede encontrar documentación extendida sobre símbolos y funciones matemáticas \hyperlink{15714690155437633961}{aquí}.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Símbolo & Significado \\
\hline
\texttt{@m} & Invoca la macro \texttt{m}; seguido de expresiones separadas por espacios \\
\hline
\texttt{!} & Operador {\textquotedbl}not{\textquotedbl} prefijo \\
\hline
\texttt{a!( )}     & Al final de un nombre de función, \texttt{!} indica que la función modifica su(s) argumento(s)     \\
\hline
\texttt{\#}         & Inicio de un comentario de una sola línea                                                  \\
\hline
\texttt{\#=} & Inicio de un comentario multilínea (pueden ser anidados) \\
\hline
\texttt{=\#} & Final de un comentario multilínea \\
\hline
\texttt{\$}         & Interpolación de cadena y expresión                                                        \\
\hline
\texttt{\%} & Operador resto \\
\hline
\texttt{{\textasciicircum}} & Operador exponenente \\
\hline
\texttt{\&}         & Operador and bit-a-bit                                                                      \\
\hline
\texttt{\&\&} & Operador and booleano (en corto-circuito) \\
\hline
\texttt{|} & Operador or bit-a-bit \\
\hline
\texttt{||} & Operador or booleano (en corto-circuito) \\
\hline
\texttt{⊻} & Operador xor bit-a-bit \\
\hline
\texttt{*}         & Multiplicación o producto matricial                                                          \\
\hline
\texttt{()}       & Tupla vacía                                                                             \\
\hline
\texttt{{\textasciitilde}} & Operador not bit-a-bit \\
\hline
\texttt{{\textbackslash}} & Operador backslash \\
\hline
\texttt{{\textquotesingle}} & Operador transpuesto complejo Aᴴ \\
\hline
\texttt{a[]}       & Indexación de array                                                                        \\
\hline
\texttt{[,]}       & Concatenación vertical                                                                     \\
\hline
\texttt{[;]}       & Concatenación vertical (también)                                                           \\
\hline
\texttt{[    ]}   & Con expresiones separadas por espacios, concatenación horizontal                           \\
\hline
\texttt{T\{ \}}     & Instanciación de tipo paramétrico                                                           \\
\hline
\texttt{;} & Separador de instrucciones \\
\hline
\texttt{,}         & Separador de argumentos de función o de componentes de una tupla                           \\
\hline
\texttt{?} & Operador condicional ternario (conditional ? if\_true : if\_false) \\
\hline
\texttt{{\textquotedbl}{\textquotedbl}} & Delimitador de literales cadena \\
\hline
\texttt{{\textquotesingle}{\textquotesingle}}       & Delimitador de literales carácter                                                           \\
\hline
\texttt{` `} & Delimitador de especificaciones de proceso externo (mandato) \\
\hline
\texttt{...} & Une argumentos en una llamada a función o declara una función o tipo varargs \\
\hline
\texttt{.}         & Acceso nombrado a campos en objectos/módulos, también llamadas a operadores/funciones vectorizadas \\
\hline
\texttt{a:b} & Rango a, a+1, a+2, ..., b \\
\hline
\texttt{a:s:b} & Rango a, a+s, a+2s, ..., b \\
\hline
\texttt{:}         & Indexa una dimensión entera (1:final)                                                       \\
\hline
\texttt{::}       & Anotación de tipo, dependiendo del contexto                                                 \\
\hline
\texttt{:( )}     & Expresión citada                                                                           \\
\hline
\texttt{:a}       & Símbolo a                                                                                  \\
\hline
\texttt{<:} & \hyperlink{10973847109239228196}{\texttt{subtype operator}} \\
\hline
\texttt{>:} & \hyperlink{13074915255343859584}{\texttt{supertype operator}} (contrario al anterior) \\
\hline
\texttt{===} & \hyperlink{7974744969331231272}{\texttt{egal comparison operator}} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{7484837696332142133}{}


\chapter{Ordenación y Funciones Relacionadas}



Julia tiene una API amplia y flexible para ordenar e interactuar con matrices de valores ya ordenados. Por defecto, Julia selecciona algoritmos y ordenaciones razonables en orden ascendente estándar:




\begin{minted}{jlcon}
julia> sort([2,3,1])
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



También se puede ordenar en orden inverso:




\begin{minted}{jlcon}
julia> sort([2,3,1], rev=true)
3-element Array{Int64,1}:
 3
 2
 1
\end{minted}



Para ordenar un array sobre sí mismo, use la versión con admiración de la función de ordenación:




\begin{minted}{jlcon}
julia> a = [2,3,1];

julia> sort!(a);

julia> a
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



En lugar de ordenar un array directamente, podemos computar una permutación de los índices del array que ponen el array en un orden determinado:




\begin{minted}{jlcon}
julia> v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia> p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia> v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396
\end{minted}



Los arrays pueden ser ordenados fácilmente de acuerdo a una transformación arbitraria de sus valores:




\begin{minted}{jlcon}
julia> sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027
\end{minted}



O en orden reverso mediante una transformación:




\begin{minted}{jlcon}
julia> sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452
\end{minted}



Si es necesario, puede elegirse el algoritmo de ordenación:




\begin{minted}{jlcon}
julia> sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396
\end{minted}



Todas las funciones de ordenación y relacionadas con el orden se basan en una relación {\textquotedbl}menor que{\textquotedbl} que define un orden total sobre los valores que van a manipularse. La función \texttt{isless} es la invocada por defecto, pero la relación puede ser especificada mediante la palabra clave \texttt{lt}.



\hypertarget{5870863367801341187}{}


\section{Funciones de Ordenación}


\hypertarget{12296873681374954808}{} 
\hyperlink{12296873681374954808}{\texttt{Base.sort!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort the vector \texttt{v} in place. \texttt{QuickSort} is used by default for numeric arrays while \texttt{MergeSort} is used for other arrays. You can specify an algorithm to use via the \texttt{alg} keyword (see Sorting Algorithms for available algorithms). The \texttt{by} keyword lets you provide a function that will be applied to each element before comparison; the \texttt{lt} keyword allows providing a custom {\textquotedbl}less than{\textquotedbl} function; use \texttt{rev=true} to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both \texttt{by} and \texttt{lt} are specified, the \texttt{lt} function is applied to the result of the \texttt{by} function; \texttt{rev=true} reverses whatever ordering specified via the \texttt{by} and \texttt{lt} keywords.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2]; sort!(v); v
3-element Array{Int64,1}:
 1
 2
 3

julia> v = [3, 1, 2]; sort!(v, rev = true); v
3-element Array{Int64,1}:
 3
 2
 1

julia> v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -> x[1]); v
3-element Array{Tuple{Int64,String},1}:
 (1, "c")
 (2, "b")
 (3, "a")

julia> v = [(1, "c"), (3, "a"), (2, "b")]; sort!(v, by = x -> x[2]); v
3-element Array{Tuple{Int64,String},1}:
 (3, "a")
 (2, "b")
 (1, "c")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L439-L478}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8473525809131227606}{} 
\hyperlink{8473525809131227606}{\texttt{Base.sort}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Variant of \hyperlink{12296873681374954808}{\texttt{sort!}} that returns a sorted copy of \texttt{v} leaving \texttt{v} itself unmodified.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2];

julia> sort(v)
3-element Array{Int64,1}:
 1
 2
 3

julia> v
3-element Array{Int64,1}:
 3
 1
 2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L523-L545}{\texttt{source}}



\begin{lstlisting}
sort(A, dim::Integer; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)
\end{lstlisting}

Sort a multidimensional array \texttt{A} along the given dimension. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = [4 3; 1 2]
2×2 Array{Int64,2}:
 4  3
 1  2

julia> sort(A, 1)
2×2 Array{Int64,2}:
 1  2
 4  3

julia> sort(A, 2)
2×2 Array{Int64,2}:
 3  4
 1  2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L696-L721}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17035770587913381438}{} 
\hyperlink{17035770587913381438}{\texttt{Base.sortperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Return a permutation vector of indices of \texttt{v} that puts it in sorted order. Specify \texttt{alg} to choose a particular sorting algorithm (see Sorting Algorithms). \texttt{MergeSort} is used by default, and since it is stable, the resulting permutation will be the lexicographically first one that puts the input array into sorted order – i.e. indices of equal elements appear in ascending order. If you choose a non-stable sorting algorithm such as \texttt{QuickSort}, a different permutation that puts the array into order may be returned. The order is specified using the same keywords as \texttt{sort!}.

See also \hyperlink{9803303601105416895}{\texttt{sortperm!}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2];

julia> p = sortperm(v)
3-element Array{Int64,1}:
 2
 3
 1

julia> v[p]
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L573-L603}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9803303601105416895}{} 
\hyperlink{9803303601105416895}{\texttt{Base.Sort.sortperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)
\end{lstlisting}

Like \hyperlink{17035770587913381438}{\texttt{sortperm}}, but accepts a preallocated index vector \texttt{ix}.  If \texttt{initialized} is \texttt{false} (the default), \texttt{ix} is initialized to contain the values \texttt{1:length(v)}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> v = [3, 1, 2]; p = zeros(Int, 3);

julia> sortperm!(p, v); p
3-element Array{Int64,1}:
 2
 3
 1

julia> v[p]
3-element Array{Int64,1}:
 1
 2
 3
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L630-L653}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13424247807563071005}{} 
\hyperlink{13424247807563071005}{\texttt{Base.Sort.sortrows}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sortrows(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort the rows of matrix \texttt{A} lexicographically. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sortrows([7 3 5; -1 6 4; 9 -2 8])
3×3 Array{Int64,2}:
 -1   6  4
  7   3  5
  9  -2  8

julia> sortrows([7 3 5; -1 6 4; 9 -2 8], lt=(x,y)->isless(x[2],y[2]))
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4

julia> sortrows([7 3 5; -1 6 4; 9 -2 8], rev=true)
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L753-L781}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8489789932053339936}{} 
\hyperlink{8489789932053339936}{\texttt{Base.Sort.sortcols}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
sortcols(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)
\end{lstlisting}

Sort the columns of matrix \texttt{A} lexicographically. See \hyperlink{12296873681374954808}{\texttt{sort!}} for a description of possible keyword arguments.

\textbf{Examples}


\begin{minted}{jlcon}
julia> sortcols([7 3 5; 6 -1 -4; 9 -2 8])
3×3 Array{Int64,2}:
  3   5  7
 -1  -4  6
 -2   8  9

julia> sortcols([7 3 5; 6 -1 -4; 9 -2 8], alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))
3×3 Array{Int64,2}:
  5   3  7
 -4  -1  6
  8  -2  9

julia> sortcols([7 3 5; 6 -1 -4; 9 -2 8], rev=true)
3×3 Array{Int64,2}:
 7   5   3
 6  -4  -1
 9   8  -2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L793-L821}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8203536556923862950}{}


\section{Funciones Relacionadas con Orden}


\hypertarget{16696594531893143583}{} 
\hyperlink{16696594531893143583}{\texttt{Base.issorted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
issorted(v, lt=isless, by=identity, rev:Bool=false, order::Ordering=Forward)
\end{lstlisting}

Test whether a vector is in sorted order. The \texttt{lt}, \texttt{by} and \texttt{rev} keywords modify what order is considered to be sorted just as they do for \hyperlink{8473525809131227606}{\texttt{sort}}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> issorted([1, 2, 3])
true

julia> issorted([(1, "b"), (2, "a")], by = x -> x[1])
true

julia> issorted([(1, "b"), (2, "a")], by = x -> x[2])
false

julia> issorted([(1, "b"), (2, "a")], by = x -> x[2], rev=true)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L60-L80}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17287969759719368562}{} 
\hyperlink{17287969759719368562}{\texttt{Base.Sort.searchsorted}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
searchsorted(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Returns the range of indices of \texttt{a} which compare as equal to \texttt{x} (using binary search) according to the order specified by the \texttt{by}, \texttt{lt} and \texttt{rev} keywords, assuming that \texttt{a} is already sorted in that order. Returns an empty range located at the insertion point if \texttt{a} does not contain values equal to \texttt{x}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [4, 3, 2, 1]
4-element Array{Int64,1}:
 4
 3
 2
 1

julia> searchsorted(a, 4)
5:4

julia> searchsorted(a, 4, rev=true)
1:1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L495-L519}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12786822915971523090}{} 
\hyperlink{12786822915971523090}{\texttt{Base.Sort.searchsortedfirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
searchsortedfirst(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Returns the index of the first value in \texttt{a} greater than or equal to \texttt{x}, according to the specified order. Returns \texttt{length(a)+1} if \texttt{x} is greater than all values in \texttt{a}. \texttt{a} is assumed to be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsortedfirst([1, 2, 4, 5, 14], 4)
3

julia> searchsortedfirst([1, 2, 4, 5, 14], 4, rev=true)
1

julia> searchsortedfirst([1, 2, 4, 5, 14], 15)
6
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1351-L1370}{\texttt{source}}


\end{adjustwidth}
\hypertarget{572230519808649943}{} 
\hyperlink{572230519808649943}{\texttt{Base.Sort.searchsortedlast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
searchsortedlast(a, x, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Returns the index of the last value in \texttt{a} less than or equal to \texttt{x}, according to the specified order. Returns \texttt{0} if \texttt{x} is less than all values in \texttt{a}. \texttt{a} is assumed to be sorted.

\textbf{Examples}


\begin{minted}{jlcon}
julia> searchsortedlast([1, 2, 4, 5, 14], 4)
3

julia> searchsortedlast([1, 2, 4, 5, 14], 4, rev=true)
5

julia> searchsortedlast([1, 2, 4, 5, 14], -1)
0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2026-L2045}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16241414476213573420}{} 
\hyperlink{16241414476213573420}{\texttt{Base.Sort.select!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
select!(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Partially sort the vector \texttt{v} in place, according to the order specified by \texttt{by}, \texttt{lt} and \texttt{rev} so that the value at index \texttt{k} (or range of adjacent values if \texttt{k} is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If \texttt{k} is a single index, that value is returned; if \texttt{k} is a range, an array of values at those indices is returned. Note that \texttt{select!} does not fully sort the input array.

\textbf{Examples}


\begin{minted}{jlcon}
julia> a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia> select!(a, 4)
4

julia> a
5-element Array{Int64,1}:
 1
 2
 3
 4
 4

julia> a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia> select!(a, 4, rev=true)
2

julia> a
5-element Array{Int64,1}:
 4
 4
 3
 2
 1
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L853-L904}{\texttt{source}}


\end{adjustwidth}
\hypertarget{420570680150584220}{} 
\hyperlink{420570680150584220}{\texttt{Base.Sort.select}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
select(v, k, [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Variant of \hyperlink{16241414476213573420}{\texttt{select!}} which copies \texttt{v} before partially sorting it, thereby returning the same thing as \texttt{select!} but leaving \texttt{v} unmodified.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L655-L660}{\texttt{source}}


\end{adjustwidth}
\hypertarget{913507832734228523}{} 
\hyperlink{913507832734228523}{\texttt{Base.Sort.selectperm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
selectperm(v, k, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false])
\end{lstlisting}

Return a partial permutation of the vector \texttt{v}, according to the order specified by \texttt{by}, \texttt{lt} and \texttt{rev}, so that \texttt{v[output]} returns the first \texttt{k} (or range of adjacent values if \texttt{k} is a range) values of a fully sorted version of \texttt{v}. If \texttt{k} is a single index (Integer), an array of the first \texttt{k} indices is returned; if \texttt{k} is a range, an array of those indices is returned. Note that the handling of integer values for \texttt{k} is different from \hyperlink{420570680150584220}{\texttt{select}} in that it returns a vector of \texttt{k} elements instead of just the \texttt{k} th element. Also note that this is equivalent to, but more efficient than, calling \texttt{sortperm(...)[k]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1231-L1242}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14333533851382646700}{} 
\hyperlink{14333533851382646700}{\texttt{Base.Sort.selectperm!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
selectperm!(ix, v, k, [alg=<algorithm>,] [by=<transform>,] [lt=<comparison>,] [rev=false,] [initialized=false])
\end{lstlisting}

Like \hyperlink{913507832734228523}{\texttt{selectperm}}, but accepts a preallocated index vector \texttt{ix}. If \texttt{initialized} is \texttt{false} (the default), ix is initialized to contain the values \texttt{1:length(ix)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1396-L1401}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9249877028219934557}{}


\section{Algoritmos de Ordenación}



Actualmente hay cuatro algoritmos de ordenación disponibles en Julia base:



\begin{itemize}
\item \texttt{InsertionSort}


\item \texttt{QuickSort}


\item \texttt{PartialQuickSort(k)}


\item \texttt{MergeSort}

\end{itemize}


\texttt{InsertionSort} es un algoritmo de ordenación estable cuyo coste es O(n{\textasciicircum}2). Es eficiente para \texttt{n} muy pequeños, y es usado internamente por \texttt{QuickSort}.



\texttt{QuickSort} es un algoritmo de ordenación que es \emph{in-place} muy rápido pero no estable (es decir, los elementos que son considerados iguales no permanecerán en el mismo orden en que se encontraban originalmente en el array antes de ser ordenados). Su coste computacional es O(n log n). \texttt{QuickSort} es el algoritmo por defecto para valores numéricos, incluyendo enteros y punto flotante.



\texttt{PartialQuickSort(k)} es similar a \texttt{QuickSort}, pero el array de salida es sólo ordenado hasta el índice  \texttt{k} si \texttt{k} es un entero, o en el rango de \texttt{k} si \texttt{k} es un \texttt{OrdinalRange}. Por ejemplo:




\begin{minted}{julia}
x = rand(1:500, 100)
k = 50
k2 = 50:100
s = sort(x; alg=QuickSort)
ps = sort(x; alg=PartialQuickSort(k))
qs = sort(x; alg=PartialQuickSort(k2))
map(issorted, (s, ps, qs))             # => (true, false, false)
map(x->issorted(x[1:k]), (s, ps, qs))  # => (true, true, false)
map(x->issorted(x[k2]), (s, ps, qs))   # => (true, false, true)
s[1:k] == ps[1:k]                      # => true
s[k2] == qs[k2]                        # => true
\end{minted}



\texttt{MergeSort} es un algoritmo de ordenación estable, pero no \emph{in-place} (requiere un array temporal de la mitad del tamaño del array de entrada), de coste O(n log n) y no suele ser tan rapido como \texttt{QuickSort}. Es el algoritmo por defecto para datos no numéricos.



Los algoritmos de ordenación por defecto se eligen sobre la base de que son rápidos y estables, o \emph{parezcan} serlo. Para los tipos numéricos, de hecho, se selecciona \texttt{QuickSort} ya que es más rápido e indistinguible en este caso de un tipo estable (a menos que la matriz registre sus mutaciones de alguna manera). La propiedad de estabilidad tiene un coste no despreciable, por lo que si no la necesita, puede especificar explícitamente su algoritmo preferido, p. \texttt{sort!(v, alg=QuickSort)}.



El mecanismo por el cual Julia selecciona los algoritmos de ordenación predeterminados se implementa a través de la función \texttt{Base.Sort.defalg}. Permite que un algoritmo particular se registre como el predeterminado en todas las funciones de ordenación para arrays específicos. Por ejemplo, aquí están los dos métodos predeterminados de \href{https://github.com/JuliaLang/julia/blob/master/base/sort.jl}{\texttt{sort.jl}}:




\begin{minted}{julia}
defalg(v::AbstractArray) = MergeSort
defalg{T<:Number}(v::AbstractArray{T}) = QuickSort
\end{minted}



En cuanto a los arrays numéricos, la elección de un algoritmo predeterminado no estable para los tipos de array para los cuales la noción de ordenación estable no tiene sentido (es decir, cuando dos valores que comparan iguales no se pueden distinguir) puede tener sentido.



\hypertarget{4492327721069002863}{}


\chapter{Funciones del Administrador de Paquetes}



Todas las funciones del administrador de paquetes están definidas en el módulo \texttt{Pkg}. Ninguna de las funciones del módulo \texttt{Pkg} están exportadas. Por tanto, para usarlas, necesitamos prefijar cada llamada a función con un \texttt{Pkg.} explícito, por ejemplo \hyperlink{7389584356782450249}{\texttt{Pkg.status()}} o \hyperlink{4800223299836980046}{\texttt{Pkg.dir()}}.



Las funciones para el desarrollo de paquetes (por ejemplo, \texttt{tag}, \texttt{publish}, etc.) se han movido al paquete \href{https://github.com/JuliaLang/PkgDev.jl}{PkgDev}. Ver \href{https://github.com/JuliaLang/PkgDev.jl/blob/master/README.md}{PkgDev README} para la documentación de estas funciones.


\hypertarget{4800223299836980046}{} 
\hyperlink{4800223299836980046}{\texttt{Base.Pkg.dir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dir() -> AbstractString
\end{lstlisting}

Returns the absolute path of the package directory. This defaults to \texttt{joinpath(homedir(),{\textquotedbl}.julia{\textquotedbl},{\textquotedbl}v\$(VERSION.major).\$(VERSION.minor){\textquotedbl})} on all platforms (i.e. \texttt{{\textasciitilde}/.julia/v0.6} in UNIX shell syntax). If the \texttt{JULIA\_PKGDIR} environment variable is set, then that path is used in the returned value as \texttt{joinpath(ENV[{\textquotedbl}JULIA\_PKGDIR{\textquotedbl}],{\textquotedbl}v\$(VERSION.major).\$(VERSION.minor){\textquotedbl})}. If \texttt{JULIA\_PKGDIR} is a relative path, it is interpreted relative to whatever the current working directory is.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L55-L64}{\texttt{source}}



\begin{lstlisting}
dir(names...) -> AbstractString
\end{lstlisting}

Equivalent to \texttt{normpath(Pkg.dir(),names...)} – i.e. it appends path components to the package directory and normalizes the resulting path. In particular, \texttt{Pkg.dir(pkg)} returns the path to the package \texttt{pkg}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L67-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8591360307072003924}{} 
\hyperlink{8591360307072003924}{\texttt{Base.Pkg.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
init(meta::AbstractString=DEFAULT_META, branch::AbstractString=META_BRANCH)
\end{lstlisting}

Initialize \texttt{Pkg.dir()} as a package directory. This will be done automatically when the \texttt{JULIA\_PKGDIR} is not set and \texttt{Pkg.dir()} uses its default value. As part of this process, clones a local METADATA git repository from the site and branch specified by its arguments, which are typically not provided. Explicit (non-default) arguments can be used to support a custom METADATA setup.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L76-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{246440786291582695}{} 
\hyperlink{246440786291582695}{\texttt{Base.Pkg.resolve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
resolve()
\end{lstlisting}

Determines an optimal, consistent set of package versions to install or upgrade to. The optimal set of package versions is based on the contents of \texttt{Pkg.dir({\textquotedbl}REQUIRE{\textquotedbl})} and the state of installed packages in \texttt{Pkg.dir()}, Packages that are no longer required are moved into \texttt{Pkg.dir({\textquotedbl}.trash{\textquotedbl})}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L230-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3124493295760422384}{} 
\hyperlink{3124493295760422384}{\texttt{Base.Pkg.edit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
edit()
\end{lstlisting}

Opens \texttt{Pkg.dir({\textquotedbl}REQUIRE{\textquotedbl})} in the editor specified by the \texttt{VISUAL} or \texttt{EDITOR} environment variables; when the editor command returns, it runs \texttt{Pkg.resolve()} to determine and install a new optimal set of installed package versions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L94-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10284711283997279340}{} 
\hyperlink{10284711283997279340}{\texttt{Base.Pkg.add}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
add(pkg, vers...)
\end{lstlisting}

Add a requirement entry for \texttt{pkg} to \texttt{Pkg.dir({\textquotedbl}REQUIRE{\textquotedbl})} and call \texttt{Pkg.resolve()}. If \texttt{vers} are given, they must be \texttt{VersionNumber} objects and they specify acceptable version intervals for \texttt{pkg}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L110-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13989694063022152176}{} 
\hyperlink{13989694063022152176}{\texttt{Base.Pkg.rm}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rm(pkg)
\end{lstlisting}

Remove all requirement entries for \texttt{pkg} from \texttt{Pkg.dir({\textquotedbl}REQUIRE{\textquotedbl})} and call \texttt{Pkg.resolve()}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L103-L107}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12404258328199389568}{} 
\hyperlink{12404258328199389568}{\texttt{Base.Pkg.clone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clone(pkg)
\end{lstlisting}

If \texttt{pkg} has a URL registered in \texttt{Pkg.dir({\textquotedbl}METADATA{\textquotedbl})}, clone it from that URL on the default branch. The package does not need to have any registered versions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L163-L168}{\texttt{source}}



\begin{lstlisting}
clone(url, [pkg])
\end{lstlisting}

Clone a package directly from the git URL \texttt{url}. The package does not need to be registered in \texttt{Pkg.dir({\textquotedbl}METADATA{\textquotedbl})}. The package repo is cloned by the name \texttt{pkg} if provided; if not provided, \texttt{pkg} is determined automatically from \texttt{url}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L171-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16637824229915276013}{} 
\hyperlink{16637824229915276013}{\texttt{Base.Pkg.setprotocol!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
setprotocol!(proto)
\end{lstlisting}

Set the protocol used to access GitHub-hosted packages. Defaults to {\textquotesingle}https{\textquotesingle}, with a blank \texttt{proto} delegating the choice to the package developer.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L285-L290}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1262148946763636093}{} 
\hyperlink{1262148946763636093}{\texttt{Base.Pkg.available}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
available() -> Vector{String}
\end{lstlisting}

Returns the names of available packages.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L119-L123}{\texttt{source}}



\begin{lstlisting}
available(pkg) -> Vector{VersionNumber}
\end{lstlisting}

Returns the version numbers available for package \texttt{pkg}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L126-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10971725533820181631}{} 
\hyperlink{10971725533820181631}{\texttt{Base.Pkg.installed}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
installed() -> Dict{String,VersionNumber}
\end{lstlisting}

Returns a dictionary mapping installed package names to the installed version number of each package.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L133-L138}{\texttt{source}}



\begin{lstlisting}
installed(pkg) -> Void | VersionNumber
\end{lstlisting}

If \texttt{pkg} is installed, return the installed version number. If \texttt{pkg} is registered, but not installed, return \texttt{nothing}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L141-L146}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7389584356782450249}{} 
\hyperlink{7389584356782450249}{\texttt{Base.Pkg.status}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
status()
\end{lstlisting}

Prints out a summary of what packages are installed and what version and state they{\textquotesingle}re in.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L149-L153}{\texttt{source}}



\begin{lstlisting}
status(pkg)
\end{lstlisting}

Prints out a summary of what version and state \texttt{pkg}, specifically, is in.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L156-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14197801802374863313}{} 
\hyperlink{14197801802374863313}{\texttt{Base.Pkg.update}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
update(pkgs...)
\end{lstlisting}

Update the metadata repo – kept in \texttt{Pkg.dir({\textquotedbl}METADATA{\textquotedbl})} – then update any fixed packages that can safely be pulled from their origin; then call \texttt{Pkg.resolve()} to determine a new optimal set of packages versions.

Without arguments, updates all installed packages. When one or more package names are provided as arguments, only those packages and their dependencies are updated.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L218-L227}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13289698592044275412}{} 
\hyperlink{13289698592044275412}{\texttt{Base.Pkg.checkout}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
checkout(pkg, [branch="master"]; merge=true, pull=true)
\end{lstlisting}

Checkout the \texttt{Pkg.dir(pkg)} repo to the branch \texttt{branch}. Defaults to checking out the {\textquotedbl}master{\textquotedbl} branch. To go back to using the newest compatible released version, use \texttt{Pkg.free(pkg)}. Changes are merged (fast-forward only) if the keyword argument \texttt{merge == true}, and the latest version is pulled from the upstream repo if \texttt{pull == true}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L180-L187}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5411776221154476292}{} 
\hyperlink{5411776221154476292}{\texttt{Base.Pkg.pin}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pin(pkg)
\end{lstlisting}

Pin \texttt{pkg} at the current version. To go back to using the newest compatible released version, use \texttt{Pkg.free(pkg)}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L203-L208}{\texttt{source}}



\begin{lstlisting}
pin(pkg, version)
\end{lstlisting}

Pin \texttt{pkg} at registered version \texttt{version}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L211-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17638373134027476185}{} 
\hyperlink{17638373134027476185}{\texttt{Base.Pkg.free}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
free(pkg)
\end{lstlisting}

Free the package \texttt{pkg} to be managed by the package manager again. It calls \texttt{Pkg.resolve()} to determine optimal package versions after. This is an inverse for both \texttt{Pkg.checkout} and \texttt{Pkg.pin}.

You can also supply an iterable collection of package names, e.g., \texttt{Pkg.free(({\textquotedbl}Pkg1{\textquotedbl}, {\textquotedbl}Pkg2{\textquotedbl}))} to free multiple packages at once.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L191-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8295561239210722937}{} 
\hyperlink{8295561239210722937}{\texttt{Base.Pkg.build}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
build()
\end{lstlisting}

Run the build scripts for all installed packages in depth-first recursive order.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L240-L244}{\texttt{source}}



\begin{lstlisting}
build(pkgs...)
\end{lstlisting}

Run the build script in \texttt{deps/build.jl} for each package in \texttt{pkgs} and all of their dependencies in depth-first recursive order. This is called automatically by \texttt{Pkg.resolve()} on all installed or updated packages.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L247-L253}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9222688485458908711}{} 
\hyperlink{9222688485458908711}{\texttt{Base.Pkg.test}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
test(; coverage=false)
\end{lstlisting}

Run the tests for all installed packages ensuring that each package{\textquotesingle}s test dependencies are installed for the duration of the test. A package is tested by running its \texttt{test/runtests.jl} file and test dependencies are specified in \texttt{test/REQUIRE}. Coverage statistics for the packages may be generated by passing \texttt{coverage=true}. The default behavior is not to run coverage.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L256-L264}{\texttt{source}}



\begin{lstlisting}
test(pkgs...; coverage=false)
\end{lstlisting}

Run the tests for each package in \texttt{pkgs} ensuring that each package{\textquotesingle}s test dependencies are installed for the duration of the test. A package is tested by running its \texttt{test/runtests.jl} file and test dependencies are specified in \texttt{test/REQUIRE}. Coverage statistics for the packages may be generated by passing \texttt{coverage=true}. The default behavior is not to run coverage.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L267-L275}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12831812093472061922}{} 
\hyperlink{12831812093472061922}{\texttt{Base.Pkg.dependents}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dependents(pkg)
\end{lstlisting}

List the packages that have \texttt{pkg} as a dependency.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pkg/pkg.jl#L278-L282}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11995623453970199783}{}


\chapter{Fechas y  Tiempo}



\hypertarget{6139252078076525667}{}


\section{Tipos para Fechas y Tiempo}


\hypertarget{14377501606406826094}{} 
\hyperlink{14377501606406826094}{\texttt{Base.Dates.Period}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Period
Year
Month
Week
Day
Hour
Minute
Second
Millisecond
Microsecond
Nanosecond
\end{lstlisting}

\texttt{Period} types represent discrete, human representations of time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L5-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{525765720148561137}{} 
\hyperlink{525765720148561137}{\texttt{Base.Dates.CompoundPeriod}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CompoundPeriod
\end{lstlisting}

A \texttt{CompoundPeriod} is useful for expressing time periods that are not a fixed multiple of smaller periods. For example, {\textquotedbl}a year and a  day{\textquotedbl} is not a fixed number of days, but can be expressed using a \texttt{CompoundPeriod}. In fact, a \texttt{CompoundPeriod} is automatically generated by addition of different period types, e.g. \texttt{Year(1) + Day(1)} produces a \texttt{CompoundPeriod} result.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L152-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14059711765239501159}{} 
\hyperlink{14059711765239501159}{\texttt{Base.Dates.Instant}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Instant
\end{lstlisting}

\texttt{Instant} types represent integer-based, machine representations of time as continuous timelines starting from an epoch.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L54-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1207098327812555174}{} 
\hyperlink{1207098327812555174}{\texttt{Base.Dates.UTInstant}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
UTInstant{T}
\end{lstlisting}

The \texttt{UTInstant} represents a machine timeline based on UT time (1 day = one revolution of the earth). The \texttt{T} is a \texttt{Period} parameter that indicates the resolution or precision of the instant.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L62-L68}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10402032810188745271}{} 
\hyperlink{10402032810188745271}{\texttt{Base.Dates.TimeType}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
TimeType
\end{lstlisting}

\texttt{TimeType} types wrap \texttt{Instant} machine instances to provide human representations of the machine instant. \texttt{Time}, \texttt{DateTime} and \texttt{Date} are subtypes of \texttt{TimeType}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L89-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8865912400344885633}{} 
\hyperlink{8865912400344885633}{\texttt{Base.Dates.DateTime}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime
\end{lstlisting}

\texttt{DateTime} wraps a \texttt{UTInstant\{Millisecond\}} and interprets it according to the proleptic Gregorian calendar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L97-L102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5911165232663997394}{} 
\hyperlink{5911165232663997394}{\texttt{Base.Dates.Date}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date
\end{lstlisting}

\texttt{Date} wraps a \texttt{UTInstant\{Day\}} and interprets it according to the proleptic Gregorian calendar.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L108-L112}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6364266857375791956}{} 
\hyperlink{6364266857375791956}{\texttt{Base.Dates.Time}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time
\end{lstlisting}

\texttt{Time} wraps a \texttt{Nanosecond} and represents a specific moment in a 24-hour day.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L118-L122}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5800310548398482816}{}


\section{Funciones para Fechas}



Todas las funciones para fechas están definidas en el módulo \texttt{Dates}; nótese que solo se han exportado las funciones \texttt{Date}, \texttt{DateTime} y \texttt{now}; para usar el resto de funciones de \texttt{Dates}, es necesario prefijar cada llamada a función con \texttt{Dates.}, por ejemplo,\texttt{Dates.dayofweek(dt)}. Alternativamente, se puede escribir \texttt{using Base.Dates} para llevar todas las funciones exportadas a \texttt{Main} y que sean usadas sin el prefijo \texttt{Dates.}


\hypertarget{17770402903533631921}{} 
\hyperlink{17770402903533631921}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(y, [m, d, h, mi, s, ms]) -> DateTime
\end{lstlisting}

Construct a \texttt{DateTime} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L173-L177}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10280796272064741669}{} 
\hyperlink{10280796272064741669}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(periods::Period...) -> DateTime
\end{lstlisting}

Construct a \texttt{DateTime} type by \texttt{Period} type parts. Arguments may be in any order. DateTime parts not provided will default to the value of \texttt{Dates.default(period)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L253-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8150038898794109881}{} 
\hyperlink{8150038898794109881}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(f::Function, y[, m, d, h, mi, s]; step=Day(1), limit=10000) -> DateTime
\end{lstlisting}

Create a \texttt{DateTime} through the adjuster API. The starting point will be constructed from the provided \texttt{y, m, d...} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that \texttt{f::Function} is never satisfied).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L167-L175}{\texttt{source}}


\end{adjustwidth}
\hypertarget{406652776419399630}{} 
\hyperlink{406652776419399630}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(dt::Date) -> DateTime
\end{lstlisting}

Converts a \texttt{Date} to a \texttt{DateTime}. The hour, minute, second, and millisecond parts of the new \texttt{DateTime} are assumed to be zero.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L14-L19}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8065462912440099163}{} 
\hyperlink{8065462912440099163}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(dt::AbstractString, format::AbstractString; locale="english") -> DateTime
\end{lstlisting}

Construct a \texttt{DateTime} by parsing the \texttt{dt} date string following the pattern given in the \texttt{format} string.

This method creates a \texttt{DateFormat} object each time it is called. If you are parsing many date strings of the same format, consider creating a \hyperlink{18366440545577280750}{\texttt{DateFormat}} object once and using that as the second argument instead.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L400-L409}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15700128179736045337}{} 
\hyperlink{15700128179736045337}{\texttt{Base.Dates.format}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
format(dt::TimeType, format::AbstractString; locale="english") -> AbstractString
\end{lstlisting}

Construct a string by using a \texttt{TimeType} object and applying the provided \texttt{format}. The following character codes can be used to construct the \texttt{format} string:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Code & Examples & Comment \\
\hline
\texttt{y} & 6 & Numeric year with a fixed width \\
\hline
\texttt{Y} & 1996 & Numeric year with a minimum width \\
\hline
\texttt{m} & 1, 12 & Numeric month with a minimum width \\
\hline
\texttt{u} & Jan & Month name shortened to 3-chars according to the \texttt{locale} \\
\hline
\texttt{U} & January & Full month name according to the \texttt{locale} keyword \\
\hline
\texttt{d} & 1, 31 & Day of the month with a minimum width \\
\hline
\texttt{H} & 0, 23 & Hour (24-hour clock) with a minimum width \\
\hline
\texttt{M} & 0, 59 & Minute with a minimum width \\
\hline
\texttt{S} & 0, 59 & Second with a minimum width \\
\hline
\texttt{s} & 000, 500 & Millisecond with a minimum width of 3 \\
\hline
\texttt{e} & Mon, Tue & Abbreviated days of the week \\
\hline
\texttt{E} & Monday & Full day of week name \\
\hline
\end{tabulary}

\end{table}

The number of sequential code characters indicate the width of the code. A format of \texttt{yyyy-mm} specifies that the code \texttt{y} should have a width of four while \texttt{m} a width of two. Codes that yield numeric digits have an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros when it is shorter than the specified width and truncates the value when longer. Minimum-width mode works the same as fixed-width except that it does not truncate values longer than the width.

When creating a \texttt{format} you can use any non-code characters as a separator. For example to generate the string {\textquotedbl}1996-01-15T00:00:00{\textquotedbl} you could use \texttt{format}: {\textquotedbl}yyyy-mm-ddTHH:MM:SS{\textquotedbl}. Note that if you need to use a code character as a literal you can use the escape character backslash. The string {\textquotedbl}1996y01m{\textquotedbl} can be produced with the format {\textquotedbl}yyyy{\textbackslash}ymm{\textbackslash}m{\textquotedbl}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L459-L491}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18366440545577280750}{} 
\hyperlink{18366440545577280750}{\texttt{Base.Dates.DateFormat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateFormat(format::AbstractString, locale="english") -> DateFormat
\end{lstlisting}

Construct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the \texttt{format} string:


\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Code & Matches & Comment \\
\hline
\texttt{y} & 1996, 96 & Returns year of 1996, 0096 \\
\hline
\texttt{Y} & 1996, 96 & Returns year of 1996, 0096. Equivalent to \texttt{y} \\
\hline
\texttt{m} & 1, 01 & Matches 1 or 2-digit months \\
\hline
\texttt{u} & Jan & Matches abbreviated months according to the \texttt{locale} keyword \\
\hline
\texttt{U} & January & Matches full month names according to the \texttt{locale} keyword \\
\hline
\texttt{d} & 1, 01 & Matches 1 or 2-digit days \\
\hline
\texttt{H} & 00 & Matches hours \\
\hline
\texttt{M} & 00 & Matches minutes \\
\hline
\texttt{S} & 00 & Matches seconds \\
\hline
\texttt{s} & .500 & Matches milliseconds \\
\hline
\texttt{e} & Mon, Tues & Matches abbreviated days of the week \\
\hline
\texttt{E} & Monday & Matches full name days of the week \\
\hline
\texttt{yyyymmdd} & 19960101 & Matches fixed-width year, month, and day \\
\hline
\end{tabulary}

\end{table}

Characters not listed above are normally treated as delimiters between date and time slots. For example a \texttt{dt} string of {\textquotedbl}1996-01-15T00:00:00.0{\textquotedbl} would have a \texttt{format} string like {\textquotedbl}y-m-dTH:M:S.s{\textquotedbl}. If you need to use a code character as a delimiter you can escape it using backslash. The date {\textquotedbl}1995y01m{\textquotedbl} would have the format {\textquotedbl}y{\textbackslash}ym{\textbackslash}m{\textquotedbl}.

Creating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the \texttt{dateformat{\textquotedbl}{\textquotedbl}} string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see \hyperlink{11988130329055928757}{\texttt{@dateformat\_str}}.

See \hyperlink{8865912400344885633}{\texttt{DateTime}} and \hyperlink{15700128179736045337}{\texttt{format}} for how to use a DateFormat object to parse and write Date strings respectively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L285-L319}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11988130329055928757}{} 
\hyperlink{11988130329055928757}{\texttt{Base.Dates.@dateformat\_str}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dateformat"Y-m-d H:M:S"
\end{lstlisting}

Create a \hyperlink{18366440545577280750}{\texttt{DateFormat}} object. Similar to \texttt{DateFormat({\textquotedbl}Y-m-d H:M:S{\textquotedbl})} but creates the DateFormat object once during macro expansion.

See \hyperlink{18366440545577280750}{\texttt{DateFormat}} for details about format specifiers.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L376-L383}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3378067936515397516}{} 
\hyperlink{3378067936515397516}{\texttt{Base.Dates.DateTime}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DateTime(dt::AbstractString, df::DateFormat) -> DateTime
\end{lstlisting}

Construct a \texttt{DateTime} by parsing the \texttt{dt} date string following the pattern given in the \hyperlink{18366440545577280750}{\texttt{DateFormat}} object. Similar to \texttt{DateTime(::AbstractString, ::AbstractString)} but more efficient when repeatedly parsing similarly formatted date strings with a pre-created \texttt{DateFormat} object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L414-L421}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5212786329612133584}{} 
\hyperlink{5212786329612133584}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(y, [m, d]) -> Date
\end{lstlisting}

Construct a \texttt{Date} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L197-L201}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7589388345185303552}{} 
\hyperlink{7589388345185303552}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(period::Period...) -> Date
\end{lstlisting}

Construct a \texttt{Date} type by \texttt{Period} type parts. Arguments may be in any order. \texttt{Date} parts not provided will default to the value of \texttt{Dates.default(period)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L274-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16815838716805629389}{} 
\hyperlink{16815838716805629389}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(f::Function, y[, m, d]; step=Day(1), limit=10000) -> Date
\end{lstlisting}

Create a \texttt{Date} through the adjuster API. The starting point will be constructed from the provided \texttt{y, m, d} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that \texttt{f::Function} is never satisfied).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L153-L161}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15615328746995105772}{} 
\hyperlink{15615328746995105772}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(dt::DateTime) -> Date
\end{lstlisting}

Converts a \texttt{DateTime} to a \texttt{Date}. The hour, minute, second, and millisecond parts of the \texttt{DateTime} are truncated, so only the year, month and day parts are used in construction.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L5-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3304153513123620085}{} 
\hyperlink{3304153513123620085}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(dt::AbstractString, format::AbstractString; locale="english") -> Date
\end{lstlisting}

Construct a \texttt{Date} object by parsing a \texttt{dt} date string following the pattern given in the \texttt{format} string. Follows the same conventions as \texttt{DateTime(::AbstractString, ::AbstractString)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L424-L430}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16265569307671841495}{} 
\hyperlink{16265569307671841495}{\texttt{Base.Dates.Date}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Date(dt::AbstractString, df::DateFormat) -> Date
\end{lstlisting}

Parse a date from a date string \texttt{dt} using a \texttt{DateFormat} object \texttt{df}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/io.jl#L435-L439}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8041094645691458686}{} 
\hyperlink{8041094645691458686}{\texttt{Base.Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time(h, [mi, s, ms, us, ns]) -> Time
\end{lstlisting}

Construct a \texttt{Time} type by parts. Arguments must be convertible to \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L214-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16214757854325020955}{} 
\hyperlink{16214757854325020955}{\texttt{Base.Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time(period::TimePeriod...) -> Time
\end{lstlisting}

Construct a \texttt{Time} type by \texttt{Period} type parts. Arguments may be in any order. \texttt{Time} parts not provided will default to the value of \texttt{Dates.default(period)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L290-L295}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10387496882065780352}{} 
\hyperlink{10387496882065780352}{\texttt{Base.Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time(f::Function, h, mi=0; step::Period=Second(1), limit::Int=10000)
Time(f::Function, h, mi, s; step::Period=Millisecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms; step::Period=Microsecond(1), limit::Int=10000)
Time(f::Function, h, mi, s, ms, us; step::Period=Nanosecond(1), limit::Int=10000)
\end{lstlisting}

Create a \texttt{Time} through the adjuster API. The starting point will be constructed from the provided \texttt{h, mi, s, ms, us} arguments, and will be adjusted until \texttt{f::Function} returns \texttt{true}. The step size in adjusting can be provided manually through the \texttt{step} keyword. \texttt{limit} provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that \texttt{f::Function} is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be \texttt{Millisecond(1)} instead of \texttt{Second(1)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L199-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8591728813232129299}{} 
\hyperlink{8591728813232129299}{\texttt{Base.Dates.Time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Time(dt::DateTime) -> Time
\end{lstlisting}

Converts a \texttt{DateTime} to a \texttt{Time}. The hour, minute, second, and millisecond parts of the \texttt{DateTime} are used to create the new \texttt{Time}. Microsecond and nanoseconds are zero by default.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L22-L27}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2058673973833808993}{} 
\hyperlink{2058673973833808993}{\texttt{Base.Dates.now}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
now() -> DateTime
\end{lstlisting}

Returns a \texttt{DateTime} corresponding to the user{\textquotesingle}s system time including the system timezone locale.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L60-L65}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11897165750197598573}{} 
\hyperlink{11897165750197598573}{\texttt{Base.Dates.now}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
now(::Type{UTC}) -> DateTime
\end{lstlisting}

Returns a \texttt{DateTime} corresponding to the user{\textquotesingle}s system time as UTC/GMT.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L79-L83}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4594213520310841636}{} 
\hyperlink{4594213520310841636}{\texttt{Base.eps}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
eps(::DateTime) -> Millisecond
eps(::Date) -> Day
eps(::Time) -> Nanosecond
\end{lstlisting}

Returns \texttt{Millisecond(1)} for \texttt{DateTime} values, \texttt{Day(1)} for \texttt{Date} values, and \texttt{Nanosecond(1)} for \texttt{Time} values.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L320-L326}{\texttt{source}}


\end{adjustwidth}

\hypertarget{17891828773228022381}{}


\subsection{Funciones de Acceso}


\hypertarget{15622323911053998761}{} 
\hyperlink{15622323911053998761}{\texttt{Base.Dates.year}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
year(dt::TimeType) -> Int64
\end{lstlisting}

The year of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L74-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15592512904688731243}{} 
\hyperlink{15592512904688731243}{\texttt{Base.Dates.month}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
month(dt::TimeType) -> Int64
\end{lstlisting}

The month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L74-L78}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11882200678350221197}{} 
\hyperlink{11882200678350221197}{\texttt{Base.Dates.week}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
week(dt::TimeType) -> Int64
\end{lstlisting}

Return the \href{https://en.wikipedia.org/wiki/ISO\_week\_date}{ISO week date} of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}. Note that the first week of a year is the week that contains the first Thursday of the year which can result in dates prior to January 4th being in the last week of the previous year. For example \texttt{week(Date(2005,1,1))} is the 53rd week of 2004.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L82-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10628053109262927268}{} 
\hyperlink{10628053109262927268}{\texttt{Base.Dates.day}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
day(dt::TimeType) -> Int64
\end{lstlisting}

The day of month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L96-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8147665261575125823}{} 
\hyperlink{8147665261575125823}{\texttt{Base.Dates.hour}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
hour(dt::DateTime) -> Int64
\end{lstlisting}

The hour of day of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L104-L108}{\texttt{source}}



\begin{lstlisting}
hour(t::Time) -> Int64
\end{lstlisting}

The hour of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{200178754136690053}{} 
\hyperlink{200178754136690053}{\texttt{Base.Dates.minute}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
minute(dt::DateTime) -> Int64
\end{lstlisting}

The minute of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L114-L118}{\texttt{source}}



\begin{lstlisting}
minute(t::Time) -> Int64
\end{lstlisting}

The minute of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11526418270822848975}{} 
\hyperlink{11526418270822848975}{\texttt{Base.Dates.second}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
second(dt::DateTime) -> Int64
\end{lstlisting}

The second of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L114-L118}{\texttt{source}}



\begin{lstlisting}
second(t::Time) -> Int64
\end{lstlisting}

The second of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5543798764014787808}{} 
\hyperlink{5543798764014787808}{\texttt{Base.Dates.millisecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
millisecond(dt::DateTime) -> Int64
\end{lstlisting}

The millisecond of a \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L114-L118}{\texttt{source}}



\begin{lstlisting}
millisecond(t::Time) -> Int64
\end{lstlisting}

The millisecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14946427435154419045}{} 
\hyperlink{14946427435154419045}{\texttt{Base.Dates.microsecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
microsecond(t::Time) -> Int64
\end{lstlisting}

The microsecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11331076397425122225}{} 
\hyperlink{11331076397425122225}{\texttt{Base.Dates.nanosecond}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
nanosecond(t::Time) -> Int64
\end{lstlisting}

The nanosecond of a \texttt{Time} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L138-L142}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16126769327257486686}{} 
\hyperlink{16126769327257486686}{\texttt{Base.Dates.Year}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Year(v)
\end{lstlisting}

Construct a \texttt{Year} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4856456945508687644}{} 
\hyperlink{4856456945508687644}{\texttt{Base.Dates.Month}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Month(v)
\end{lstlisting}

Construct a \texttt{Month} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10126535084488311230}{} 
\hyperlink{10126535084488311230}{\texttt{Base.Dates.Week}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Week(v)
\end{lstlisting}

Construct a \texttt{Week} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5199769942291019025}{} 
\hyperlink{5199769942291019025}{\texttt{Base.Dates.Day}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Day(v)
\end{lstlisting}

Construct a \texttt{Day} object with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L32-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9687487618909219374}{} 
\hyperlink{9687487618909219374}{\texttt{Base.Dates.Hour}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Hour(dt::DateTime) -> Hour
\end{lstlisting}

The hour part of a DateTime as a \texttt{Hour}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4572058418581891227}{} 
\hyperlink{4572058418581891227}{\texttt{Base.Dates.Minute}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Minute(dt::DateTime) -> Minute
\end{lstlisting}

The minute part of a DateTime as a \texttt{Minute}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16463935583134096940}{} 
\hyperlink{16463935583134096940}{\texttt{Base.Dates.Second}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Second(dt::DateTime) -> Second
\end{lstlisting}

The second part of a DateTime as a \texttt{Second}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2512115765177421351}{} 
\hyperlink{2512115765177421351}{\texttt{Base.Dates.Millisecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Millisecond(dt::DateTime) -> Millisecond
\end{lstlisting}

The millisecond part of a DateTime as a \texttt{Millisecond}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5798823481721317707}{} 
\hyperlink{5798823481721317707}{\texttt{Base.Dates.Microsecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Microsecond(dt::Time) -> Microsecond
\end{lstlisting}

The microsecond part of a Time as a \texttt{Microsecond}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1602344562458791149}{} 
\hyperlink{1602344562458791149}{\texttt{Base.Dates.Nanosecond}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Nanosecond(dt::Time) -> Nanosecond
\end{lstlisting}

The nanosecond part of a Time as a \texttt{Nanosecond}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L24-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18273306122630602024}{} 
\hyperlink{18273306122630602024}{\texttt{Base.Dates.yearmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
yearmonth(dt::TimeType) -> (Int64, Int64)
\end{lstlisting}

Simultaneously return the year and month parts of a \texttt{Date} or \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12711217240943655827}{} 
\hyperlink{12711217240943655827}{\texttt{Base.Dates.monthday}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
monthday(dt::TimeType) -> (Int64, Int64)
\end{lstlisting}

Simultaneously return the month and day parts of a \texttt{Date} or \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4035909562939951459}{} 
\hyperlink{4035909562939951459}{\texttt{Base.Dates.yearmonthday}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
yearmonthday(dt::TimeType) -> (Int64, Int64, Int64)
\end{lstlisting}

Simultaneously return the year, month and day parts of a \texttt{Date} or \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11292476491957707950}{}


\subsection{Funciones de Consulta}


\hypertarget{3340143850480916413}{} 
\hyperlink{3340143850480916413}{\texttt{Base.Dates.dayname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayname(dt::TimeType; locale="english") -> AbstractString
\end{lstlisting}

Return the full day name corresponding to the day of the week of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L116-L121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2563884892429498349}{} 
\hyperlink{2563884892429498349}{\texttt{Base.Dates.dayabbr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayabbr(dt::TimeType; locale="english") -> AbstractString
\end{lstlisting}

Return the abbreviated name corresponding to the day of the week of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L126-L131}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8726616416233686609}{} 
\hyperlink{8726616416233686609}{\texttt{Base.Dates.dayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofweek(dt::TimeType) -> Int64
\end{lstlisting}

Returns the day of the week as an \hyperlink{7720564657383125058}{\texttt{Int64}} with \texttt{1 = Monday, 2 = Tuesday, etc.}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L101-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16365330124585758379}{} 
\hyperlink{16365330124585758379}{\texttt{Base.Dates.dayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofmonth(dt::TimeType) -> Int64
\end{lstlisting}

The day of month of a \texttt{Date} or \texttt{DateTime} as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/accessors.jl#L96-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{292232568750400127}{} 
\hyperlink{292232568750400127}{\texttt{Base.Dates.dayofweekofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofweekofmonth(dt::TimeType) -> Int
\end{lstlisting}

For the day of week of \texttt{dt}, returns which number it is in \texttt{dt}{\textquotesingle}s month. So if the day of the week of \texttt{dt} is Monday, then \texttt{1 = First Monday of the month, 2 = Second Monday of the month, etc.} In the range 1:5.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L146-L152}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5674966841159569212}{} 
\hyperlink{5674966841159569212}{\texttt{Base.Dates.daysofweekinmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
daysofweekinmonth(dt::TimeType) -> Int
\end{lstlisting}

For the day of week of \texttt{dt}, returns the total number of that day of the week in \texttt{dt}{\textquotesingle}s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including \texttt{dayofweekofmonth(dt) == daysofweekinmonth(dt)} in the adjuster function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L164-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12803026364514696452}{} 
\hyperlink{12803026364514696452}{\texttt{Base.Dates.monthname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
monthname(dt::TimeType; locale="english") -> AbstractString
\end{lstlisting}

Return the full name of the month of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L190-L194}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1979988737860589713}{} 
\hyperlink{1979988737860589713}{\texttt{Base.Dates.monthabbr}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
monthabbr(dt::TimeType; locale="english") -> AbstractString
\end{lstlisting}

Return the abbreviated month name of the \texttt{Date} or \texttt{DateTime} in the given \texttt{locale}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L199-L203}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15503119946294889402}{} 
\hyperlink{15503119946294889402}{\texttt{Base.Dates.daysinmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
daysinmonth(dt::TimeType) -> Int
\end{lstlisting}

Returns the number of days in the month of \texttt{dt}. Value will be 28, 29, 30, or 31.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L208-L212}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18025935327355387493}{} 
\hyperlink{18025935327355387493}{\texttt{Base.Dates.isleapyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
isleapyear(dt::TimeType) -> Bool
\end{lstlisting}

Returns \texttt{true} if the year of \texttt{dt} is a leap year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L216-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15283021054811681483}{} 
\hyperlink{15283021054811681483}{\texttt{Base.Dates.dayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofyear(dt::TimeType) -> Int
\end{lstlisting}

Returns the day of the year for \texttt{dt} with January 1st being day 1.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L223-L227}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2148579310409606490}{} 
\hyperlink{2148579310409606490}{\texttt{Base.Dates.daysinyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
daysinyear(dt::TimeType) -> Int
\end{lstlisting}

Returns 366 if the year of \texttt{dt} is a leap year, otherwise returns 365.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L89-L93}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13950511459712943725}{} 
\hyperlink{13950511459712943725}{\texttt{Base.Dates.quarterofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
quarterofyear(dt::TimeType) -> Int
\end{lstlisting}

Returns the quarter that \texttt{dt} resides in. Range of value is 1:4.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L233-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15988019016584368016}{} 
\hyperlink{15988019016584368016}{\texttt{Base.Dates.dayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dayofquarter(dt::TimeType) -> Int
\end{lstlisting}

Returns the day of the current quarter of \texttt{dt}. Range of value is 1:92.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/query.jl#L244-L248}{\texttt{source}}


\end{adjustwidth}

\hypertarget{17953834571670340959}{}


\subsection{Funciones de Ajuste}


\hypertarget{7412479111462927551}{} 
\hyperlink{7412479111462927551}{\texttt{Base.trunc}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
trunc(dt::TimeType, ::Type{Period}) -> TimeType
\end{lstlisting}

Truncates the value of \texttt{dt} according to the provided \texttt{Period} type. E.g. if \texttt{dt} is \texttt{1996-01-01T12:30:00}, then \texttt{trunc(dt,Day) == 1996-01-01T00:00:00}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L23-L28}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15677981373530139727}{} 
\hyperlink{15677981373530139727}{\texttt{Base.Dates.firstdayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
firstdayofweek(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the Monday of its week.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L32-L36}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8038953726514452417}{} 
\hyperlink{8038953726514452417}{\texttt{Base.Dates.lastdayofweek}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lastdayofweek(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the Sunday of its week.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L42-L46}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12743214730484566774}{} 
\hyperlink{12743214730484566774}{\texttt{Base.Dates.firstdayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
firstdayofmonth(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the first day of its month.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L52-L56}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6275133620700325946}{} 
\hyperlink{6275133620700325946}{\texttt{Base.Dates.lastdayofmonth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lastdayofmonth(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the last day of its month.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5871349443949523716}{} 
\hyperlink{5871349443949523716}{\texttt{Base.Dates.firstdayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
firstdayofyear(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the first day of its year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L75-L79}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5562822772348873155}{} 
\hyperlink{5562822772348873155}{\texttt{Base.Dates.lastdayofyear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lastdayofyear(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the last day of its year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L85-L89}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2063104864586136689}{} 
\hyperlink{2063104864586136689}{\texttt{Base.Dates.firstdayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
firstdayofquarter(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the first day of its quarter.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L98-L102}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5146789007163617957}{} 
\hyperlink{5146789007163617957}{\texttt{Base.Dates.lastdayofquarter}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lastdayofquarter(dt::TimeType) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the last day of its quarter.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L112-L116}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17409471999654347609}{} 
\hyperlink{17409471999654347609}{\texttt{Base.Dates.tonext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tonext(dt::TimeType, dow::Int; same::Bool=false) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the next day of week corresponding to \texttt{dow} with \texttt{1 = Monday, 2 = Tuesday, etc}. Setting \texttt{same=true} allows the current \texttt{dt} to be considered as the next \texttt{dow}, allowing for no adjustment to occur.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L242-L248}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7599972091906648015}{} 
\hyperlink{7599972091906648015}{\texttt{Base.Dates.toprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
toprev(dt::TimeType, dow::Int; same::Bool=false) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the previous day of week corresponding to \texttt{dow} with \texttt{1 = Monday, 2 = Tuesday, etc}. Setting \texttt{same=true} allows the current \texttt{dt} to be considered as the previous \texttt{dow}, allowing for no adjustment to occur.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L264-L270}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15320794192333426258}{} 
\hyperlink{15320794192333426258}{\texttt{Base.Dates.tofirst}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tofirst(dt::TimeType, dow::Int; of=Month) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the first \texttt{dow} of its month. Alternatively, \texttt{of=Year} will adjust to the first \texttt{dow} of the year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L286-L291}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5463466470080435101}{} 
\hyperlink{5463466470080435101}{\texttt{Base.Dates.tolast}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tolast(dt::TimeType, dow::Int; of=Month) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} to the last \texttt{dow} of its month. Alternatively, \texttt{of=Year} will adjust to the last \texttt{dow} of the year.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L298-L303}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2273056547445243157}{} 
\hyperlink{2273056547445243157}{\texttt{Base.Dates.tonext}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
tonext(func::Function, dt::TimeType; step=Day(1), limit=10000, same=false) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} by iterating at most \texttt{limit} iterations by \texttt{step} increments until \texttt{func} returns \texttt{true}. \texttt{func} must take a single \texttt{TimeType} argument and return a \hyperlink{46725311238864537}{\texttt{Bool}}. \texttt{same} allows \texttt{dt} to be considered in satisfying \texttt{func}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L252-L258}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12275775027934528278}{} 
\hyperlink{12275775027934528278}{\texttt{Base.Dates.toprev}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
toprev(func::Function, dt::TimeType; step=Day(-1), limit=10000, same=false) -> TimeType
\end{lstlisting}

Adjusts \texttt{dt} by iterating at most \texttt{limit} iterations by \texttt{step} increments until \texttt{func} returns \texttt{true}. \texttt{func} must take a single \texttt{TimeType} argument and return a \hyperlink{46725311238864537}{\texttt{Bool}}. \texttt{same} allows \texttt{dt} to be considered in satisfying \texttt{func}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/adjusters.jl#L273-L279}{\texttt{source}}


\end{adjustwidth}

\hypertarget{14503642401874149528}{}


\subsection{Períodos}


\hypertarget{3700773990165642536}{} 
\hyperlink{3700773990165642536}{\texttt{Base.Dates.Period}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Year(v)
Month(v)
Week(v)
Day(v)
Hour(v)
Minute(v)
Second(v)
Millisecond(v)
Microsecond(v)
Nanosecond(v)
\end{lstlisting}

Construct a \texttt{Period} type with the given \texttt{v} value. Input must be losslessly convertible to an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/types.jl#L37-L51}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3038089337323869002}{} 
\hyperlink{3038089337323869002}{\texttt{Base.Dates.CompoundPeriod}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
CompoundPeriod(periods) -> CompoundPeriod
\end{lstlisting}

Construct a \texttt{CompoundPeriod} from a \texttt{Vector} of \texttt{Period}s. All \texttt{Period}s of the same type will be added together.

\textbf{Examples}


\begin{minted}{jlcon}
julia> Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))
25 hours

julia> Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))
-1 hour, 1 minute

julia> Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))
1 month, -2 weeks

julia> Dates.CompoundPeriod(Dates.Minute(50000))
50000 minutes
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L195-L215}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3502963607865297667}{} 
\hyperlink{3502963607865297667}{\texttt{Base.Dates.default}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
default(p::Period) -> Period
\end{lstlisting}

Returns a sensible {\textquotedbl}default{\textquotedbl} value for the input Period by returning \texttt{T(1)} for Year, Month, and Day, and \texttt{T(0)} for Hour, Minute, Second, and Millisecond.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/periods.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4298099884550062611}{}


\subsection{Funciones de Redondeo}



Los valores \texttt{Date} y \texttt{DateTime} pueden ser redondeados a una precisión especificada (por ejemplo, 1 mes o 15 minutos) con \texttt{floor}, \texttt{ceil}, o \texttt{round}.


\hypertarget{13948277906659863497}{} 
\hyperlink{13948277906659863497}{\texttt{Base.floor}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
floor(dt::TimeType, p::Period) -> TimeType
\end{lstlisting}

Returns the nearest \texttt{Date} or \texttt{DateTime} less than or equal to \texttt{dt} at resolution \texttt{p}.

For convenience, \texttt{p} may be a type instead of a value: \texttt{floor(dt, Dates.Hour)} is a shortcut for \texttt{floor(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> floor(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> floor(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia> floor(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-06T00:00:00
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L79-L97}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11509984064218511874}{} 
\hyperlink{11509984064218511874}{\texttt{Base.ceil}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ceil(dt::TimeType, p::Period) -> TimeType
\end{lstlisting}

Returns the nearest \texttt{Date} or \texttt{DateTime} greater than or equal to \texttt{dt} at resolution \texttt{p}.

For convenience, \texttt{p} may be a type instead of a value: \texttt{ceil(dt, Dates.Hour)} is a shortcut for \texttt{ceil(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> ceil(Date(1985, 8, 16), Dates.Month)
1985-09-01

julia> ceil(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:45:00

julia> ceil(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L100-L118}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7894166454005036294}{} 
\hyperlink{7894166454005036294}{\texttt{Base.round}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
round(dt::TimeType, p::Period, [r::RoundingMode]) -> TimeType
\end{lstlisting}

Returns the \texttt{Date} or \texttt{DateTime} nearest to \texttt{dt} at resolution \texttt{p}. By default (\texttt{RoundNearestTiesUp}), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.

For convenience, \texttt{p} may be a type instead of a value: \texttt{round(dt, Dates.Hour)} is a shortcut for \texttt{round(dt, Dates.Hour(1))}.


\begin{minted}{jlcon}
julia> round(Date(1985, 8, 16), Dates.Month)
1985-08-01

julia> round(DateTime(2013, 2, 13, 0, 31, 20), Dates.Minute(15))
2013-02-13T00:30:00

julia> round(DateTime(2016, 8, 6, 12, 0, 0), Dates.Day)
2016-08-07T00:00:00
\end{minted}

Valid rounding modes for \texttt{round(::TimeType, ::Period, ::RoundingMode)} are \texttt{RoundNearestTiesUp} (default), \texttt{RoundDown} (\texttt{floor}), and \texttt{RoundUp} (\texttt{ceil}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L135-L157}{\texttt{source}}


\end{adjustwidth}

Las siguientes funciones no están exportadas:


\hypertarget{8367348060461430078}{} 
\hyperlink{8367348060461430078}{\texttt{Base.Dates.floorceil}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
floorceil(dt::TimeType, p::Period) -> (TimeType, TimeType)
\end{lstlisting}

Simultaneously return the \texttt{floor} and \texttt{ceil} of a \texttt{Date} or \texttt{DateTime} at resolution \texttt{p}. More efficient than calling both \texttt{floor} and \texttt{ceil} individually.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L124-L129}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3684978517923462707}{} 
\hyperlink{3684978517923462707}{\texttt{Base.Dates.epochdays2date}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
epochdays2date(days) -> Date
\end{lstlisting}

Takes the number of days since the rounding epoch (\texttt{0000-01-01T00:00:00}) and returns the corresponding \texttt{Date}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L10-L15}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1628469795535599119}{} 
\hyperlink{1628469795535599119}{\texttt{Base.Dates.epochms2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
epochms2datetime(milliseconds) -> DateTime
\end{lstlisting}

Takes the number of milliseconds since the rounding epoch (\texttt{0000-01-01T00:00:00}) and returns the corresponding \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L18-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4956356462973552427}{} 
\hyperlink{4956356462973552427}{\texttt{Base.Dates.date2epochdays}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
date2epochdays(dt::Date) -> Int64
\end{lstlisting}

Takes the given \texttt{Date} and returns the number of days since the rounding epoch (\texttt{0000-01-01T00:00:00}) as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L26-L31}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10434598411550666131}{} 
\hyperlink{10434598411550666131}{\texttt{Base.Dates.datetime2epochms}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
datetime2epochms(dt::DateTime) -> Int64
\end{lstlisting}

Takes the given \texttt{DateTime} and returns the number of milliseconds since the rounding epoch (\texttt{0000-01-01T00:00:00}) as an \hyperlink{7720564657383125058}{\texttt{Int64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/rounding.jl#L34-L39}{\texttt{source}}


\end{adjustwidth}

\hypertarget{8333681668355342874}{}


\subsection{Funciones de Conversión}


\hypertarget{14794617941716137009}{} 
\hyperlink{14794617941716137009}{\texttt{Base.Dates.today}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
today() -> Date
\end{lstlisting}

Returns the date portion of \texttt{now()}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L72-L76}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16290614891006602028}{} 
\hyperlink{16290614891006602028}{\texttt{Base.Dates.unix2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unix2datetime(x) -> DateTime
\end{lstlisting}

Takes the number of seconds since unix epoch \texttt{1970-01-01T00:00:00} and converts to the corresponding \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L42-L47}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8673051370538450902}{} 
\hyperlink{8673051370538450902}{\texttt{Base.Dates.datetime2unix}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
datetime2unix(dt::DateTime) -> Float64
\end{lstlisting}

Takes the given \texttt{DateTime} and returns the number of seconds since the unix epoch \texttt{1970-01-01T00:00:00} as a \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L52-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1836114976869278679}{} 
\hyperlink{1836114976869278679}{\texttt{Base.Dates.julian2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
julian2datetime(julian_days) -> DateTime
\end{lstlisting}

Takes the number of Julian calendar days since epoch \texttt{-4713-11-24T12:00:00} and returns the corresponding \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L104-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10255972529610617723}{} 
\hyperlink{10255972529610617723}{\texttt{Base.Dates.datetime2julian}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
datetime2julian(dt::DateTime) -> Float64
\end{lstlisting}

Takes the given \texttt{DateTime} and returns the number of Julian calendar days since the julian epoch \texttt{-4713-11-24T12:00:00} as a \hyperlink{5027751419500983000}{\texttt{Float64}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L115-L120}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16685934354883098672}{} 
\hyperlink{16685934354883098672}{\texttt{Base.Dates.rata2datetime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rata2datetime(days) -> DateTime
\end{lstlisting}

Takes the number of Rata Die days since epoch \texttt{0000-12-31T00:00:00} and returns the corresponding \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L86-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12986995780671236226}{} 
\hyperlink{12986995780671236226}{\texttt{Base.Dates.datetime2rata}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
datetime2rata(dt::TimeType) -> Int64
\end{lstlisting}

Returns the number of Rata Die days since epoch from the given \texttt{Date} or \texttt{DateTime}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dates/conversions.jl#L94-L98}{\texttt{source}}


\end{adjustwidth}

\hypertarget{9218040371144180833}{}


\subsection{Constantes}



Días de la Semana:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Variable & Abbr. & Value (Int) \\
\hline
\texttt{Monday} & \texttt{Mon} & 1 \\
\hline
\texttt{Tuesday} & \texttt{Tue} & 2 \\
\hline
\texttt{Wednesday} & \texttt{Wed} & 3 \\
\hline
\texttt{Thursday} & \texttt{Thu} & 4 \\
\hline
\texttt{Friday} & \texttt{Fri} & 5 \\
\hline
\texttt{Saturday} & \texttt{Sat} & 6 \\
\hline
\texttt{Sunday} & \texttt{Sun} & 7 \\
\hline
\end{tabulary}

\end{table}



Meses del Año:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Variable & Abbr. & Value (Int) \\
\hline
\texttt{January} & \texttt{Jan} & 1 \\
\hline
\texttt{February} & \texttt{Feb} & 2 \\
\hline
\texttt{March} & \texttt{Mar} & 3 \\
\hline
\texttt{April} & \texttt{Apr} & 4 \\
\hline
\texttt{May} & \texttt{May} & 5 \\
\hline
\texttt{June} & \texttt{Jun} & 6 \\
\hline
\texttt{July} & \texttt{Jul} & 7 \\
\hline
\texttt{August} & \texttt{Aug} & 8 \\
\hline
\texttt{September} & \texttt{Sep} & 9 \\
\hline
\texttt{October} & \texttt{Oct} & 10 \\
\hline
\texttt{November} & \texttt{Nov} & 11 \\
\hline
\texttt{December} & \texttt{Dec} & 12 \\
\hline
\end{tabulary}

\end{table}



\hypertarget{2381796939793458375}{}


\chapter{Utilidades para Iteración}


\hypertarget{11836366300100000234}{} 
\hyperlink{11836366300100000234}{\texttt{Base.Iterators.zip}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
zip(iters...)
\end{lstlisting}

For a set of iterable objects, returns an iterable of tuples, where the \texttt{i}th tuple contains the \texttt{i}th component of each input iterable.

Note that \hyperlink{11836366300100000234}{\texttt{zip}} is its own inverse: \texttt{collect(zip(zip(a...)...)) == collect(a)}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1:5
1:5

julia> b = ["e","d","b","c","a"]
5-element Array{String,1}:
 "e"
 "d"
 "b"
 "c"
 "a"

julia> c = zip(a,b)
Base.Iterators.Zip2{UnitRange{Int64},Array{String,1}}(1:5, String["e", "d", "b", "c", "a"])

julia> length(c)
5

julia> first(c)
(1, "e")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L201-L232}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2184606349967262519}{} 
\hyperlink{2184606349967262519}{\texttt{Base.Iterators.enumerate}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
enumerate(iter)
\end{lstlisting}

An iterator that yields \texttt{(i, x)} where \texttt{i} is a counter starting at 1, and \texttt{x} is the \texttt{i}th value from the given iterator. It{\textquotesingle}s useful when you need not only the values \texttt{x} over which you are iterating, but also the number of iterations so far. Note that \texttt{i} may not be valid for indexing \texttt{iter}; it{\textquotesingle}s also possible that \texttt{x != iter[i]}, if \texttt{iter} has indices that do not start at 1. See the \texttt{enumerate(IndexLinear(), iter)} method if you want to ensure that \texttt{i} is an index.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = ["a", "b", "c"];

julia> for (index, value) in enumerate(a)
           println("$index $value")
       end
1 a
2 b
3 c
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L35-L58}{\texttt{source}}



\begin{lstlisting}
enumerate(IndexLinear(), A)
enumerate(IndexCartesian(), A)
enumerate(IndexStyle(A), A)
\end{lstlisting}

An iterator that accesses each element of the array \texttt{A}, returning \texttt{(i, x)}, where \texttt{i} is the index for the element and \texttt{x = A[i]}.  This is similar to \texttt{enumerate(A)}, except \texttt{i} will always be a valid index for \texttt{A}.

Specifying \texttt{IndexLinear()} ensures that \texttt{i} will be an integer; specifying \texttt{IndexCartesian()} ensures that \texttt{i} will be a \texttt{CartesianIndex}; specifying \texttt{IndexStyle(A)} chooses whichever has been defined as the native indexing style for array \texttt{A}.

\textbf{Examples}


\begin{minted}{jlcon}
julia> A = ["a" "d"; "b" "e"; "c" "f"];

julia> for (index, value) in enumerate(IndexStyle(A), A)
           println("$index $value")
       end
1 a
2 b
3 c
4 d
5 e
6 f

julia> S = view(A, 1:2, :);

julia> for (index, value) in enumerate(IndexStyle(S), S)
           println("$index $value")
       end
CartesianIndex{2}((1, 1)) a
CartesianIndex{2}((2, 1)) b
CartesianIndex{2}((1, 2)) d
CartesianIndex{2}((2, 2)) e
\end{minted}

Note that \texttt{enumerate(A)} returns \texttt{i} as a \emph{counter} (always starting at 1), whereas \texttt{enumerate(IndexLinear(), A)} returns \texttt{i} as an \emph{index} (starting at the first linear index of \texttt{A}, which may or may not be 1).

See also: \hyperlink{7782790551324367092}{\texttt{IndexStyle}}, \hyperlink{16112307926804387301}{\texttt{indices}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L80-L127}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3784260484755044695}{} 
\hyperlink{3784260484755044695}{\texttt{Base.Iterators.rest}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
rest(iter, state)
\end{lstlisting}

An iterator that yields the same elements as \texttt{iter}, but starting at the given \texttt{state}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L312-L316}{\texttt{source}}


\end{adjustwidth}
\hypertarget{218851424586263192}{} 
\hyperlink{218851424586263192}{\texttt{Base.Iterators.countfrom}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
countfrom(start=1, step=1)
\end{lstlisting}

An iterator that counts forever, starting at \texttt{start} and incrementing by \texttt{step}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L337-L341}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7844855039511634473}{} 
\hyperlink{7844855039511634473}{\texttt{Base.Iterators.take}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
take(iter, n)
\end{lstlisting}

An iterator that generates at most the first \texttt{n} elements of \texttt{iter}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1:2:11
1:2:11

julia> collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia> collect(Iterators.take(a,3))
3-element Array{Int64,1}:
 1
 3
 5
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L361-L387}{\texttt{source}}


\end{adjustwidth}
\hypertarget{744681231854455039}{} 
\hyperlink{744681231854455039}{\texttt{Base.Iterators.drop}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
drop(iter, n)
\end{lstlisting}

An iterator that generates all but the first \texttt{n} elements of \texttt{iter}.

\textbf{Example}


\begin{minted}{jlcon}
julia> a = 1:2:11
1:2:11

julia> collect(a)
6-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11

julia> collect(Iterators.drop(a,4))
2-element Array{Int64,1}:
  9
 11
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L418-L443}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13881904186147539554}{} 
\hyperlink{13881904186147539554}{\texttt{Base.Iterators.cycle}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cycle(iter)
\end{lstlisting}

An iterator that cycles through \texttt{iter} forever.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L477-L481}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16149631071727159175}{} 
\hyperlink{16149631071727159175}{\texttt{Base.Iterators.repeated}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
repeated(x[, n::Int])
\end{lstlisting}

An iterator that generates the value \texttt{x} forever. If \texttt{n} is specified, generates \texttt{x} that many times (equivalent to \texttt{take(repeated(x), n)}).

\textbf{Example}


\begin{minted}{jlcon}
julia> a = Iterators.repeated([1 2], 4);

julia> collect(a)
4-element Array{Array{Int64,2},1}:
 [1 2]
 [1 2]
 [1 2]
 [1 2]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L512-L530}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12093738197940348056}{} 
\hyperlink{12093738197940348056}{\texttt{Base.Iterators.product}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
product(iters...)
\end{lstlisting}

Returns an iterator over the product of several iterators. Each generated element is a tuple whose \texttt{i}th element comes from the \texttt{i}th argument iterator. The first iterator changes the fastest. Example:

\textbf{Example}


\begin{minted}{jlcon}
julia> collect(Iterators.product(1:2,3:5))
2×3 Array{Tuple{Int64,Int64},2}:
 (1, 3)  (1, 4)  (1, 5)
 (2, 3)  (2, 4)  (2, 5)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L602-L617}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6994420133663892005}{} 
\hyperlink{6994420133663892005}{\texttt{Base.Iterators.flatten}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flatten(iter)
\end{lstlisting}

Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.

\textbf{Example}


\begin{minted}{jlcon}
julia> collect(Iterators.flatten((1:2, 8:9)))
4-element Array{Int64,1}:
 1
 2
 8
 9
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L681-L698}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16897863122939587148}{} 
\hyperlink{16897863122939587148}{\texttt{Base.Iterators.partition}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
partition(collection, n)
\end{lstlisting}

Iterate over a collection \texttt{n} elements at a time.

\textbf{Example}


\begin{minted}{jlcon}
julia> collect(Iterators.partition([1,2,3,4,5], 2))
3-element Array{Array{Int64,1},1}:
 [1, 2]
 [3, 4]
 [5]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/iterators.jl#L738-L752}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6239948001455396291}{}


\chapter{Haciendo Pruebas Unitarias}





\hypertarget{16317129480609991656}{}


\section{Probando Julia Base}



Julia está en rápido desarrollo y cuenta con un amplio conjunto de pruebas para verificar su funcionalidad en múltiples plataformas. Si compila Julia desde el origen, puede ejecutar este conjunto de pruebas con \texttt{make test}. En una instalación binaria, puede ejecutar el conjunto de pruebas utilizando \texttt{Base.runtests()}.


\hypertarget{2272377293323848310}{} 
\hyperlink{2272377293323848310}{\texttt{Base.runtests}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
runtests([tests=["all"] [, numcores=ceil(Int, Sys.CPU_CORES / 2) ]])
\end{lstlisting}

Run the Julia unit tests listed in \texttt{tests}, which can be either a string or an array of strings, using \texttt{numcores} processors. (not exported)



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L673-L678}{\texttt{source}}


\end{adjustwidth}

\hypertarget{6291549838053465149}{}


\section{Pruebas Unitarias Básicas}



El módulo \texttt{Base.Test} proporciona una funcionalidad simple de \emph{realización de pruebas unitarias}. Las pruebas unitarias son una forma de ver si su código es correcto al verificar que los resultados sean los esperados. Puede ser útil asegurarse de que su código aún funcione después de realizar los cambios, y se puede usar al desarrollar como una forma de especificar los comportamientos que su código debería tener cuando se complete.



Se pueden realizar pruebas unitarias simples con las macros \texttt{@test ()} y \texttt{@test\_throws ()}:


\hypertarget{15457707572980302311}{} 
\hyperlink{15457707572980302311}{\texttt{Base.Test.@test}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test ex
@test f(args...) key=val ...
\end{lstlisting}

Tests that the expression \texttt{ex} evaluates to \texttt{true}. Returns a \texttt{Pass} \texttt{Result} if it does, a \texttt{Fail} \texttt{Result} if it is \texttt{false}, and an \texttt{Error} \texttt{Result} if it could not be evaluated.

The \texttt{@test f(args...) key=val...} form is equivalent to writing \texttt{@test f(args..., key=val...)} which can be useful when the expression is a call using infix syntax such as approximate comparisons:


\begin{lstlisting}
@test a ≈ b atol=ε
\end{lstlisting}

This is equivalent to the uglier test \texttt{@test ≈(a, b, atol=ε)}. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (\texttt{k=v}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L230-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17077004034353018115}{} 
\hyperlink{17077004034353018115}{\texttt{Base.Test.@test\_throws}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_throws extype ex
\end{lstlisting}

Tests that the expression \texttt{ex} throws an exception of type \texttt{extype}. Note that \texttt{@test\_throws} does not support a trailing keyword form.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L369-L374}{\texttt{source}}


\end{adjustwidth}

Por ejemplo, supongamos que queremos comprobar que nuestra nueva función \texttt{foo(x)} funciona como se esperaba:




\begin{lstlisting}
julia> using Base.Test

julia> foo(x) = length(x)^2
foo (función genérica con 1 método)
\end{lstlisting}



Si la condición es cierta, se devuelve un \texttt{Pass}:




\begin{lstlisting}
julia> @test foo("bar") == 9
Test Passed

julia> @test foo("fizz") >= 10
Test Passed
\end{lstlisting}



Si la condición es falsa, se devuelve un \texttt{Fail} y se lanza una excepción:




\begin{lstlisting}
julia> @test foo("f") == 20
Test Failed
  Expression: foo("f") == 20
   Evaluated: 1 == 20
ERROR: There was an error during testing
\end{lstlisting}



Si la condición no pudo ser evaluada porque se lanzó una excepción, lo que ocurre en este caso porque \texttt{length()} no está definido para símbolos, se devuelve un objeto \texttt{Error} y se lanza una excepción:




\begin{minted}{jlcon}
julia> @test foo(:cat) == 1
Error During Test
  Test threw an exception of type MethodError
  Expression: foo(:cat) == 1
  MethodError: no method matching length(::Symbol)
  Closest candidates are:
    length(::SimpleVector) at essentials.jl:256
    length(::Base.MethodList) at reflection.jl:521
    length(::MethodTable) at reflection.jl:597
    ...
  Stacktrace:
   [...]
ERROR: There was an error during testing
\end{minted}



Si esperamos que al evaluar una expresión \emph{debería} lanzarse una excepción, entonces podemos usar \texttt{@test\_throws()} para comprobar que esto es lo que ocurre:




\begin{lstlisting}
julia> @test_throws MethodError foo(:cat)
Test Passed
      Thrown: MethodError
\end{lstlisting}



\hypertarget{16413745763416488393}{}


\section{Trabajando con Conjuntos de Test}



Normalmente, se utiliza una gran cantidad de pruebas para garantizar que las funciones trabajan correctamente sobre distintas entradas. En el caso de que una prueba falle, el comportamiento predeterminado es lanzar una excepción de inmediato. Sin embargo, normalmente es preferible ejecutar el resto de las pruebas primero para obtener una mejor idea de cuántos errores hay en el código que se prueba.



La macro \texttt{@testset()} se puede usar para agrupar las pruebas en \emph{conjuntos}. En un conjunto de pruebas, se ejecutarán varias y al final de su realización se imprimirá un resumen. Si alguna de las pruebas falla o no se puede evaluar debido a un error, el conjunto de prueba arrojará una \texttt{TestSetException}.


\hypertarget{340190871613779559}{} 
\hyperlink{340190871613779559}{\texttt{Base.Test.@testset}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@testset [CustomTestSet] [option=val  ...] ["description"] begin ... end
@testset [CustomTestSet] [option=val  ...] ["description $v"] for v in (...) ... end
@testset [CustomTestSet] [option=val  ...] ["description $v, $w"] for v in (...), w in (...) ... end
\end{lstlisting}

Starts a new test set, or multiple test sets if a \texttt{for} loop is provided.

If no custom testset type is given it defaults to creating a \texttt{DefaultTestSet}. \texttt{DefaultTestSet} records all the results and, if there are any \texttt{Fail}s or \texttt{Error}s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.

Any custom testset type (subtype of \texttt{AbstractTestSet}) can be given and it will also be used for any nested \texttt{@testset} invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.

The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.

By default the \texttt{@testset} macro will return the testset object itself, though this behavior can be customized in other testset types. If a \texttt{for} loop is used then the macro collects and returns a list of the return values of the \texttt{finish} method, which by default will return a list of the testset objects used in each iteration.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L792-L817}{\texttt{source}}


\end{adjustwidth}

Podemos poner nuestras pruebas para la función \texttt{foo(x)} en un conjuntos de pruebas:




\begin{lstlisting}
julia> @testset "Foo Tests" begin
           @test foo("a")   == 1
           @test foo("ab")  == 4
           @test foo("abc") == 9
       end;
Test Summary: | Pass  Total
Foo Tests     |    3      3
\end{lstlisting}



Los conjuntos de pruebas también pueden anidarse:




\begin{lstlisting}
julia> @testset "Foo Tests" begin
           @testset "Animals" begin
               @test foo("cat") == 9
               @test foo("dog") == foo("cat")
           end
           @testset "Arrays $i" for i in 1:3
               @test foo(zeros(i)) == i^2
               @test foo(ones(i)) == i^2
           end
       end;
Test Summary: | Pass  Total
Foo Tests     |    8      8
\end{lstlisting}



En el caso de que un conjunto de pruebas anidado no tenga fallos, como pasa aquí, se ocultará en el resumen. Si tenemos una prueba que falle, sólo se mostrarán los detalles para este conjunto de pruebas que ha fallado:




\begin{minted}{jlcon}
julia> @testset "Foo Tests" begin
           @testset "Animals" begin
               @testset "Felines" begin
                   @test foo("cat") == 9
               end
               @testset "Canines" begin
                   @test foo("dog") == 9
               end
           end
           @testset "Arrays" begin
               @test foo(zeros(2)) == 4
               @test foo(ones(4)) == 15
           end
       end

Arrays: Test Failed
  Expression: foo(ones(4)) == 15
   Evaluated: 16 == 15
Stacktrace:
    [...]
Test Summary: | Pass  Fail  Total
Foo Tests     |    3     1      4
  Animals     |    2            2
  Arrays      |    1     1      2
ERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.
\end{minted}



\hypertarget{16050810456292448662}{}


\section{Otras Macros para Pruebas}



Como los cálculos sobre valores en punto flotane pueden ser imprecisos, podemos realizar comprobaciones de igualdad aproximada usando \texttt{@test a ≈ b} (donde \texttt{≈}, se obtiene mediante terminación con tabulador de \texttt{{\textbackslash}approx}, es la función \hyperlink{12499503887608197213}{\texttt{isapprox()}}) o usar directamente \hyperlink{12499503887608197213}{\texttt{isapprox()}}.




\begin{minted}{jlcon}
julia> @test 1 ≈ 0.999999999
Test Passed

julia> @test 1 ≈ 0.999999
Test Failed
  Expression: 1 ≈ 0.999999
   Evaluated: 1 ≈ 0.999999
ERROR: There was an error during testing
\end{minted}


\hypertarget{6965726194489549353}{} 
\hyperlink{6965726194489549353}{\texttt{Base.Test.@inferred}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@inferred f(x)
\end{lstlisting}

Tests that the call expression \texttt{f(x)} returns a value of the same type inferred by the compiler. It is useful to check for type stability.

\texttt{f(x)} can be any call expression. Returns the result of \texttt{f(x)} if the types match, and an \texttt{Error} \texttt{Result} if it finds different types.


\begin{minted}{jlcon}
julia> using Base.Test

julia> f(a,b,c) = b > 1 ? 1 : 1.0
f (generic function with 1 method)

julia> typeof(f(1,2,3))
Int64

julia> @code_warntype f(1,2,3)
Variables:
  #self# <optimized out>
  a <optimized out>
  b::Int64
  c <optimized out>

Body:
  begin
      unless (Base.slt_int)(1, b::Int64)::Bool goto 3
      return 1
      3:
      return 1.0
  end::UNION{FLOAT64, INT64}

julia> @inferred f(1,2,3)
ERROR: return type Int64 does not match inferred return type Union{Float64, Int64}
Stacktrace:
 [1] error(::String) at ./error.jl:21

julia> @inferred max(1,2)
2
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L1023-L1065}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10915695400018210103}{} 
\hyperlink{10915695400018210103}{\texttt{Base.Test.@test\_warn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_warn msg expr
\end{lstlisting}

Test whether evaluating \texttt{expr} results in \hyperlink{4481879903628924306}{\texttt{STDERR}} output that contains the \texttt{msg} string or matches the \texttt{msg} regular expression.  If \texttt{msg} is a boolean function, tests whether \texttt{msg(output)} returns \texttt{true}.  If \texttt{msg} is a tuple or array, checks that the error output contains/matches each item in \texttt{msg}. Returns the result of evaluating \texttt{expr}.

See also \hyperlink{589147025836585250}{\texttt{@test\_nowarn}} to check for the absence of error output.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L412-L422}{\texttt{source}}


\end{adjustwidth}
\hypertarget{589147025836585250}{} 
\hyperlink{589147025836585250}{\texttt{Base.Test.@test\_nowarn}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_nowarn expr
\end{lstlisting}

Test whether evaluating \texttt{expr} results in empty \hyperlink{4481879903628924306}{\texttt{STDERR}} output (no warnings or other messages).  Returns the result of evaluating \texttt{expr}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L443-L448}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13964946710286203957}{}


\section{Pruebas Rotas}



Si una prueba falla consistentemente, puede ser cambiada para utilizar la macro \texttt{@test\_broken()}. Esto denotará la prueba como Rota (\texttt{Broken}) si la prueba continúa fallando y alerta al usuario a través de un \texttt{Error} si la prueba tiene éxito.


\hypertarget{641859080742533604}{} 
\hyperlink{641859080742533604}{\texttt{Base.Test.@test\_broken}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_broken ex
@test_broken f(args...) key=val ...
\end{lstlisting}

Indicates a test that should pass but currently consistently fails. Tests that the expression \texttt{ex} evaluates to \texttt{false} or causes an exception. Returns a \texttt{Broken} \texttt{Result} if it does, or an \texttt{Error} \texttt{Result} if the expression evaluates to \texttt{true}.

The \texttt{@test\_broken f(args...) key=val...} form works as for the \texttt{@test} macro.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L255-L265}{\texttt{source}}


\end{adjustwidth}

\texttt{@test\_skip()} está también disponible para obviar una prueba sin evaluación, pero contabilizarla en el informe del conjunto de pruebas. La prueba no se ejecutará pero dará un \texttt{Broken} \texttt{Result}.


\hypertarget{14114707839034633381}{} 
\hyperlink{14114707839034633381}{\texttt{Base.Test.@test\_skip}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@test_skip ex
@test_skip f(args...) key=val ...
\end{lstlisting}

Marks a test that should not be executed but should be included in test summary reporting as \texttt{Broken}. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.

The \texttt{@test\_skip f(args...) key=val...} form works as for the \texttt{@test} macro.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L274-L283}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5039756121682966765}{}


\section{Creando Tipos \texttt{AbstractTestSet} Personalizados}



Los paquetes pueden crear sus propios subtipos \texttt{AbstractTestSet} implementando los métodos \texttt{record} y \texttt{finish}. El subtipo debe tener un constructor de un argumento que tome una cadena de descripción, con todas las opciones pasadas como argumentos de tipo keyword.


\hypertarget{17372569521044333819}{} 
\hyperlink{17372569521044333819}{\texttt{Base.Test.record}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
record(ts::AbstractTestSet, res::Result)
\end{lstlisting}

Record a result to a testset. This function is called by the \texttt{@testset} infrastructure each time a contained \texttt{@test} macro completes, and is given the test result (which could be an \texttt{Error}). This will also be called with an \texttt{Error} if an exception is thrown inside the test block but outside of a \texttt{@test} context.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L464-L471}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14177851825850418080}{} 
\hyperlink{14177851825850418080}{\texttt{Base.Test.finish}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
finish(ts::AbstractTestSet)
\end{lstlisting}

Do any final processing necessary for the given testset. This is called by the \texttt{@testset} infrastructure after a test block executes. One common use for this function is to record the testset to the parent{\textquotesingle}s results list, using \texttt{get\_testset}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L474-L481}{\texttt{source}}


\end{adjustwidth}

\texttt{Base.Test} asume la responsabilidad de mantener una pila de conjuntos de pruebas anidados a medida que se ejecutan, pero cualquier acumulación de resultados es responsabilidad del subtipo\texttt{AbstractTestSet}. Puede acceder a esta pila con los métodos \texttt{get\_testset} y\texttt{get\_testset\_depth}. Tenga en cuenta que estas funciones no se exportan.


\hypertarget{13301674573280065084}{} 
\hyperlink{13301674573280065084}{\texttt{Base.Test.get\_testset}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get_testset()
\end{lstlisting}

Retrieve the active test set from the task{\textquotesingle}s local storage. If no test set is active, use the fallback default test set.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L977-L982}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14902980053573349810}{} 
\hyperlink{14902980053573349810}{\texttt{Base.Test.get\_testset\_depth}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
get_testset_depth()
\end{lstlisting}

Returns the number of active test sets, not including the defaut test set



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L1012-L1016}{\texttt{source}}


\end{adjustwidth}

\texttt{Base.Test} también se asegura de que las invocaciones \texttt{@testset} anidadas utilicen el mismo subtipo \texttt{AbstractTestSet} que sus padres, a menos que se establezca explícitamente. No propaga ninguna propiedad del conjunto de pruebas. El comportamiento de herencia de opciones se puede implementar mediante paquetes que usan la infraestructura de pila que proporciona \texttt{Base.Test}.



La definición de un subtipo básico de {\textquotesingle}AbstractTestSet` podría verse así:




\begin{minted}{julia}
import Base.Test: record, finish
using Base.Test: AbstractTestSet, Result, Pass, Fail, Error
using Base.Test: get_testset_depth, get_testset
struct CustomTestSet <: Base.Test.AbstractTestSet
    description::AbstractString
    foo::Int
    results::Vector
    # constructor takes a description string and options keyword arguments
    CustomTestSet(desc; foo=1) = new(desc, foo, [])
end

record(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)
record(ts::CustomTestSet, res::Result) = push!(ts.results, res)
function finish(ts::CustomTestSet)
    # just record if we're not the top-level parent
    if get_testset_depth() > 0
        record(get_testset(), ts)
    end
    ts
end
\end{minted}



Y usar este conjunto de prueba tiene el siguiente aspecto:




\begin{minted}{julia}
@testset CustomTestSet foo=4 "custom testset inner 2" begin
    # this testset should inherit the type, but not the argument.
    @testset "custom testset inner" begin
        @test true
    end
end
\end{minted}





\hypertarget{6196042923468033404}{}


\chapter{Interfaz C}


\hypertarget{14245046751182637566}{} 
\hyperlink{14245046751182637566}{\texttt{ccall}}  -- {Keyword.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
ccall((symbol, library) or function_pointer, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
\end{lstlisting}

Call function in C-exported shared library, specified by \texttt{(function name, library)} tuple, where each component is a string or symbol.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression. Alternatively, \texttt{ccall} may also be used to call a function pointer, such as one returned by \texttt{dlsym}.

Each \texttt{ArgumentValue} to the \texttt{ccall} will be converted to the corresponding \texttt{ArgumentType}, by automatic insertion of calls to \texttt{unsafe\_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))}. (See also the documentation for each of these functions for further details.) In most cases, this simply results in a call to \texttt{convert(ArgumentType, ArgumentValue)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L557-L572}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2746947069730856184}{} 
\hyperlink{2746947069730856184}{\texttt{Core.Intrinsics.cglobal}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cglobal((symbol, library) [, type=Void])
\end{lstlisting}

Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in \hyperlink{14245046751182637566}{\texttt{ccall}}. Returns a \texttt{Ptr\{Type\}}, defaulting to \texttt{Ptr\{Void\}} if no \texttt{Type} argument is supplied. The values can be read or written by \hyperlink{13744149973765810952}{\texttt{unsafe\_load}} or \hyperlink{4579672834750013041}{\texttt{unsafe\_store!}}, respectively.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1073-L1082}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13392697678913949769}{} 
\hyperlink{13392697678913949769}{\texttt{Base.cfunction}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cfunction(function::Function, ReturnType::Type, ArgumentTypes::Type)
\end{lstlisting}

Generate C-callable function pointer from Julia function. Type annotation of the return value in the callback function is a must for situations where Julia cannot infer the return type automatically.

\textbf{Examples}


\begin{minted}{jlcon}
julia> function foo(x::Int, y::Int)
           return x + y
       end

julia> cfunction(foo, Int, Tuple{Int,Int})
Ptr{Void} @0x000000001b82fcd0
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L7-L23}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6011318385865707029}{} 
\hyperlink{6011318385865707029}{\texttt{Base.unsafe\_convert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_convert(T,x)
\end{lstlisting}

Convert \texttt{x} to a value of type \texttt{T}

In cases where \hyperlink{1846942650946171605}{\texttt{convert}} would need to take a Julia object and turn it into a \texttt{Ptr}, this function should be used to define and perform that conversion.

Be careful to ensure that a Julia reference to \texttt{x} exists as long as the result of this function will be used. Accordingly, the argument \texttt{x} to this function should never be an expression, only a variable name or field reference. For example, \texttt{x=a.b.c} is acceptable, but \texttt{x=[a,b,c]} is not.

The \texttt{unsafe} prefix on this function indicates that using the result of this function after the \texttt{x} argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1037-L1054}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16487788729383051927}{} 
\hyperlink{16487788729383051927}{\texttt{Base.cconvert}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
cconvert(T,x)
\end{lstlisting}

Convert \texttt{x} to a value of type \texttt{T}, typically by calling \texttt{convert(T,x)}

In cases where \texttt{x} cannot be safely converted to \texttt{T}, unlike \hyperlink{1846942650946171605}{\texttt{convert}}, \texttt{cconvert} may return an object of a type different from \texttt{T}, which however is suitable for \hyperlink{6011318385865707029}{\texttt{unsafe\_convert}} to handle.

Neither \texttt{convert} nor \texttt{cconvert} should take a Julia object and turn it into a \texttt{Ptr}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L169-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13744149973765810952}{} 
\hyperlink{13744149973765810952}{\texttt{Base.unsafe\_load}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_load(p::Ptr{T}, i::Integer=1)
\end{lstlisting}

Load a value of type \texttt{T} from the address of the \texttt{i}th element (1-indexed) starting at \texttt{p}. This is equivalent to the C expression \texttt{p[i-1]}.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointer \texttt{p} to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L73-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4579672834750013041}{} 
\hyperlink{4579672834750013041}{\texttt{Base.unsafe\_store!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_store!(p::Ptr{T}, x, i::Integer=1)
\end{lstlisting}

Store a value of type \texttt{T} to the address of the \texttt{i}th element (1-indexed) starting at \texttt{p}. This is equivalent to the C expression \texttt{p[i-1] = x}.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointer \texttt{p} to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L85-L94}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13418364045170663433}{} 
\hyperlink{13418364045170663433}{\texttt{Base.unsafe\_copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_copy!(dest::Ptr{T}, src::Ptr{T}, N)
\end{lstlisting}

Copy \texttt{N} elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.

The \texttt{unsafe} prefix on this function indicates that no validation is performed on the pointers \texttt{dest} and \texttt{src} to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L197-L206}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9665289950359655955}{} 
\hyperlink{9665289950359655955}{\texttt{Base.unsafe\_copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_copy!(dest::Array, do, src::Array, so, N)
\end{lstlisting}

Copy \texttt{N} elements from a source array to a destination, starting at offset \texttt{so} in the source and \texttt{do} in the destination (1-indexed).

The \texttt{unsafe} prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L209-L218}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17572907101789489045}{} 
\hyperlink{17572907101789489045}{\texttt{Base.copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copy!(dest, src) -> dest
\end{lstlisting}

Copy all elements from collection \texttt{src} to array \texttt{dest}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L848-L852}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9273029318280862570}{} 
\hyperlink{9273029318280862570}{\texttt{Base.copy!}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
copy!(dest, do, src, so, N)
\end{lstlisting}

Copy \texttt{N} elements from collection \texttt{src} starting at offset \texttt{so}, to array \texttt{dest} starting at offset \texttt{do}. Returns \texttt{dest}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2273-L2278}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8901246211940014300}{} 
\hyperlink{8901246211940014300}{\texttt{Base.pointer}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pointer(array [, index])
\end{lstlisting}

Get the native address of an array or string element. Be careful to ensure that a Julia reference to \texttt{a} exists as long as this pointer will be used. This function is {\textquotedbl}unsafe{\textquotedbl} like \texttt{unsafe\_convert}.

Calling \texttt{Ref(array[, index])} is generally preferable to this function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L47-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14566494858943689253}{} 
\hyperlink{14566494858943689253}{\texttt{Base.unsafe\_wrap}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_wrap(Array, pointer::Ptr{T}, dims, own=false)
\end{lstlisting}

Wrap a Julia \texttt{Array} object around the data at the address given by \texttt{pointer}, without making a copy.  The pointer element type \texttt{T} determines the array element type. \texttt{dims} is either an integer (for a 1d array) or a tuple of the array dimensions. \texttt{own} optionally specifies whether Julia should take ownership of the memory, calling \texttt{free} on the pointer when the array is no longer referenced.

This function is labelled {\textquotedbl}unsafe{\textquotedbl} because it will crash if \texttt{pointer} is not a valid memory address to data of the requested length.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L48-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9366554937543398846}{} 
\hyperlink{9366554937543398846}{\texttt{Base.pointer\_from\_objref}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
pointer_from_objref(x)
\end{lstlisting}

Get the memory address of a Julia object as a \texttt{Ptr}. The existence of the resulting \texttt{Ptr} will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the \texttt{Ptr} will be used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L108-L114}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10812596548944930674}{} 
\hyperlink{10812596548944930674}{\texttt{Base.unsafe\_pointer\_to\_objref}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
unsafe_pointer_to_objref(p::Ptr)
\end{lstlisting}

Convert a \texttt{Ptr} to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered {\textquotedbl}unsafe{\textquotedbl} and should be used with care.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L99-L105}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15284219011001573060}{} 
\hyperlink{15284219011001573060}{\texttt{Base.disable\_sigint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
disable_sigint(f::Function)
\end{lstlisting}

Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using \texttt{do} block syntax as follows:


\begin{lstlisting}
disable_sigint() do
    # interrupt-unsafe code
    ...
end
\end{lstlisting}

This is not needed on worker threads (\texttt{Threads.threadid() != 1}) since the \texttt{InterruptException} will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L321-L337}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1880405387924190637}{} 
\hyperlink{1880405387924190637}{\texttt{Base.reenable\_sigint}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
reenable_sigint(f::Function)
\end{lstlisting}

Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of \texttt{disable\_sigint}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L346-L351}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16566861134678143754}{} 
\hyperlink{16566861134678143754}{\texttt{Base.systemerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
systemerror(sysfunc, iftrue)
\end{lstlisting}

Raises a \texttt{SystemError} for \texttt{errno} with the descriptive string \texttt{sysfunc} if \texttt{iftrue} is \texttt{true}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/error.jl#L59-L63}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10630331440513004826}{} 
\hyperlink{10630331440513004826}{\texttt{Core.Ptr}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ptr{T}
\end{lstlisting}

A memory address referring to data of type \texttt{T}.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/pointer.jl#L3-L8}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7936024700322877457}{} 
\hyperlink{7936024700322877457}{\texttt{Core.Ref}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Ref{T}
\end{lstlisting}

An object that safely references data of type \texttt{T}. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the \texttt{Ref} itself is referenced.

When passed as a \texttt{ccall} argument (either as a \texttt{Ptr} or \texttt{Ref} type), a \texttt{Ref} object will be converted to a native pointer to the data it references.

There is no invalid (NULL) \texttt{Ref}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/refpointer.jl#L3-L14}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1445070667463182719}{} 
\hyperlink{1445070667463182719}{\texttt{Base.Cchar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cchar
\end{lstlisting}

Equivalent to the native \texttt{char} c-type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L31-L35}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8681597464447377029}{} 
\hyperlink{8681597464447377029}{\texttt{Base.Cuchar}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cuchar
\end{lstlisting}

Equivalent to the native \texttt{unsigned char} c-type (\hyperlink{6609065134969660118}{\texttt{UInt8}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L6-L10}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15152042474889311053}{} 
\hyperlink{15152042474889311053}{\texttt{Base.Cshort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cshort
\end{lstlisting}

Equivalent to the native \texttt{signed short} c-type (\hyperlink{6667287249103968645}{\texttt{Int16}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L14-L18}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12769525139115944472}{} 
\hyperlink{12769525139115944472}{\texttt{Base.Cushort}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cushort
\end{lstlisting}

Equivalent to the native \texttt{unsigned short} c-type (\hyperlink{7018610346698168012}{\texttt{UInt16}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L22-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4506686204672235089}{} 
\hyperlink{4506686204672235089}{\texttt{Base.Cint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cint
\end{lstlisting}

Equivalent to the native \texttt{signed int} c-type (\hyperlink{10103694114785108551}{\texttt{Int32}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L30-L34}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11551219982691686969}{} 
\hyperlink{11551219982691686969}{\texttt{Base.Cuint}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cuint
\end{lstlisting}

Equivalent to the native \texttt{unsigned int} c-type (\hyperlink{8690996847580776341}{\texttt{UInt32}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L38-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{634246884863419146}{} 
\hyperlink{634246884863419146}{\texttt{Base.Clong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Clong
\end{lstlisting}

Equivalent to the native \texttt{signed long} c-type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L48-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1371835691073233846}{} 
\hyperlink{1371835691073233846}{\texttt{Base.Culong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Culong
\end{lstlisting}

Equivalent to the native \texttt{unsigned long} c-type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L55-L59}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11934627959417709350}{} 
\hyperlink{11934627959417709350}{\texttt{Base.Clonglong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Clonglong
\end{lstlisting}

Equivalent to the native \texttt{signed long long} c-type (\hyperlink{7720564657383125058}{\texttt{Int64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L86-L90}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12084952472844229160}{} 
\hyperlink{12084952472844229160}{\texttt{Base.Culonglong}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Culonglong
\end{lstlisting}

Equivalent to the native \texttt{unsigned long long} c-type (\hyperlink{5500998675195555601}{\texttt{UInt64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L94-L98}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13457418202407416700}{} 
\hyperlink{13457418202407416700}{\texttt{Base.Cintmax\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cintmax_t
\end{lstlisting}

Equivalent to the native \texttt{intmax\_t} c-type (\hyperlink{7720564657383125058}{\texttt{Int64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L70-L74}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11180754709564572253}{} 
\hyperlink{11180754709564572253}{\texttt{Base.Cuintmax\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cuintmax_t
\end{lstlisting}

Equivalent to the native \texttt{uintmax\_t} c-type (\hyperlink{5500998675195555601}{\texttt{UInt64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L78-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12059505362233183406}{} 
\hyperlink{12059505362233183406}{\texttt{Base.Csize\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Csize_t
\end{lstlisting}

Equivalent to the native \texttt{size\_t} c-type (\texttt{UInt}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{395962290360403795}{} 
\hyperlink{395962290360403795}{\texttt{Base.Cssize\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cssize_t
\end{lstlisting}

Equivalent to the native \texttt{ssize\_t} c-type.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9258508309302754837}{} 
\hyperlink{9258508309302754837}{\texttt{Base.Cptrdiff\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cptrdiff_t
\end{lstlisting}

Equivalent to the native \texttt{ptrdiff\_t} c-type (\texttt{Int}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L46-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2619479148155454993}{} 
\hyperlink{2619479148155454993}{\texttt{Base.Cwchar\_t}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cwchar_t
\end{lstlisting}

Equivalent to the native \texttt{wchar\_t} c-type (\hyperlink{10103694114785108551}{\texttt{Int32}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/c.jl#L62-L66}{\texttt{source}}


\end{adjustwidth}
\hypertarget{899076182665625215}{} 
\hyperlink{899076182665625215}{\texttt{Base.Cfloat}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cfloat
\end{lstlisting}

Equivalent to the native \texttt{float} c-type (\hyperlink{8101639384272933082}{\texttt{Float32}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L102-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5889169829041130899}{} 
\hyperlink{5889169829041130899}{\texttt{Base.Cdouble}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
Cdouble
\end{lstlisting}

Equivalent to the native \texttt{double} c-type (\hyperlink{5027751419500983000}{\texttt{Float64}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/ctypes.jl#L110-L114}{\texttt{source}}


\end{adjustwidth}

\hypertarget{7895252095502479171}{}


\chapter{Interfaz LLVM}


\hypertarget{12406828992589210838}{} 
\hyperlink{12406828992589210838}{\texttt{Core.Intrinsics.llvmcall}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
llvmcall(IR::String, ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
llvmcall((declarations::String, IR::String), ReturnType, (ArgumentType1, ...), ArgumentValue1, ...)
\end{lstlisting}

Call LLVM IR string in the first argument. Similar to an LLVM function \texttt{define} block, arguments are available as consecutive unnamed SSA variables (\%0, \%1, etc.).

The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.

Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.

Each \texttt{ArgumentValue} to \texttt{llvmcall} will be converted to the corresponding \texttt{ArgumentType}, by automatic insertion of calls to \texttt{unsafe\_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))}. (see also the documentation for each of these functions for further details). In most cases, this simply results in a call to \texttt{convert(ArgumentType, ArgumentValue)}.

See \texttt{test/llvmcall.jl} for usage examples.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L575-L596}{\texttt{source}}


\end{adjustwidth}

\hypertarget{346568585257401697}{}


\chapter{Librería Estándar C}


\hypertarget{6469711430097433314}{} 
\hyperlink{6469711430097433314}{\texttt{Base.Libc.malloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
malloc(size::Integer) -> Ptr{Void}
\end{lstlisting}

Call \texttt{malloc} from the C standard library.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L323-L327}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13715091851486420318}{} 
\hyperlink{13715091851486420318}{\texttt{Base.Libc.calloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
calloc(num::Integer, size::Integer) -> Ptr{Void}
\end{lstlisting}

Call \texttt{calloc} from the C standard library.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L340-L344}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1243276183164334610}{} 
\hyperlink{1243276183164334610}{\texttt{Base.Libc.realloc}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
realloc(addr::Ptr, size::Integer) -> Ptr{Void}
\end{lstlisting}

Call \texttt{realloc} from the C standard library.

See warning in the documentation for \texttt{free} regarding only using this on memory originally obtained from \texttt{malloc}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L330-L337}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1633533624062187737}{} 
\hyperlink{1633533624062187737}{\texttt{Base.Libc.free}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
free(addr::Ptr)
\end{lstlisting}

Call \texttt{free} from the C standard library. Only use this on memory obtained from \texttt{malloc}, not on pointers retrieved from other C libraries. \texttt{Ptr} objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple \texttt{libc} libraries exist on the system.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L313-L320}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6265587084343794273}{} 
\hyperlink{6265587084343794273}{\texttt{Base.Libc.errno}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
errno([code])
\end{lstlisting}

Get the value of the C library{\textquotesingle}s \texttt{errno}. If an argument is specified, it is used to set the value of \texttt{errno}.

The value of \texttt{errno} is only valid immediately after a \texttt{ccall} to a C library routine that sets it. Specifically, you cannot call \texttt{errno} at the next prompt in a REPL, because lots of code is executed between prompts.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L254-L263}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5310873199456377483}{} 
\hyperlink{5310873199456377483}{\texttt{Base.Libc.strerror}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strerror(n=errno())
\end{lstlisting}

Convert a system call error code to a descriptive string



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L267-L271}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5383660591411020262}{} 
\hyperlink{5383660591411020262}{\texttt{Base.Libc.GetLastError}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GetLastError()
\end{lstlisting}

Call the Win32 \texttt{GetLastError} function [only available on Windows].



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L275-L279}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14255728048411856987}{} 
\hyperlink{14255728048411856987}{\texttt{Base.Libc.FormatMessage}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
FormatMessage(n=GetLastError())
\end{lstlisting}

Convert a Win32 system call error code to a descriptive string [only available on Windows].



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L282-L286}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2367147567483563544}{} 
\hyperlink{2367147567483563544}{\texttt{Base.Libc.time}}  -- {Method.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
time(t::TmStruct)
\end{lstlisting}

Converts a \texttt{TmStruct} struct to a number of seconds since the epoch.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L217-L221}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14018638426810725597}{} 
\hyperlink{14018638426810725597}{\texttt{Base.Libc.strftime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strftime([format], time)
\end{lstlisting}

Convert time, given as a number of seconds since the epoch or a \texttt{TmStruct}, to a formatted string using the given format. Supported formats are the same as those in the standard C library.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L163-L169}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16724851840034148355}{} 
\hyperlink{16724851840034148355}{\texttt{Base.Libc.strptime}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
strptime([format], timestr)
\end{lstlisting}

Parse a formatted time string into a \texttt{TmStruct} giving the seconds, minute, hour, date, etc. Supported formats are the same as those in the standard C library. On some platforms, timezones will not be parsed correctly. If the result of this function will be passed to \texttt{time} to convert it to seconds since the epoch, the \texttt{isdst} field should be filled in manually. Setting it to \texttt{-1} will tell the C library to use the current system settings to determine the timezone.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L182-L191}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12094049763760222314}{} 
\hyperlink{12094049763760222314}{\texttt{Base.Libc.TmStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
TmStruct([seconds])
\end{lstlisting}

Convert a number of seconds since the epoch to broken-down format, with fields \texttt{sec}, \texttt{min}, \texttt{hour}, \texttt{mday}, \texttt{month}, \texttt{year}, \texttt{wday}, \texttt{yday}, and \texttt{isdst}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L128-L133}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17297724195103628361}{} 
\hyperlink{17297724195103628361}{\texttt{Base.Libc.flush\_cstdio}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
flush_cstdio()
\end{lstlisting}

Flushes the C \texttt{stdout} and \texttt{stderr} streams (which may have been written to by external C code).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libc.jl#L95-L99}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13427841325685013289}{}


\chapter{Enlazador Dinámico}



Los nombres en \texttt{Base.Libdl} no son exportados y necesitan ser llamados como, por ejemplo, \texttt{Libdl.dlopen()}.


\hypertarget{6943450904282580385}{} 
\hyperlink{6943450904282580385}{\texttt{Base.Libdl.dlopen}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlopen(libfile::AbstractString [, flags::Integer])
\end{lstlisting}

Load a shared library, returning an opaque handle.

The extension given by the constant \texttt{dlext} (\texttt{.so}, \texttt{.dll}, or \texttt{.dylib}) can be omitted from the \texttt{libfile} string, as it is automatically appended if needed.   If \texttt{libfile} is not an absolute path name, then the paths in the array \texttt{DL\_LOAD\_PATH} are searched for \texttt{libfile}, followed by the system load path.

The optional flags argument is a bitwise-or of zero or more of \texttt{RTLD\_LOCAL}, \texttt{RTLD\_GLOBAL}, \texttt{RTLD\_LAZY}, \texttt{RTLD\_NOW}, \texttt{RTLD\_NODELETE}, \texttt{RTLD\_NOLOAD}, \texttt{RTLD\_DEEPBIND}, and \texttt{RTLD\_FIRST}. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default \texttt{dlopen} flags are \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_GLOBAL} while on other platforms the defaults are \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_LOCAL}. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance \texttt{RTLD\_LAZY|RTLD\_DEEPBIND|RTLD\_GLOBAL} allows the library{\textquotesingle}s symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L68-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5991700987653656651}{} 
\hyperlink{5991700987653656651}{\texttt{Base.Libdl.dlopen\_e}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlopen_e(libfile::AbstractString [, flags::Integer])
\end{lstlisting}

Similar to \hyperlink{6943450904282580385}{\texttt{dlopen}}, except returns a \texttt{NULL} pointer instead of raising errors.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L100-L104}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9396575996390240710}{} 
\hyperlink{9396575996390240710}{\texttt{Base.Libdl.RTLD\_NOW}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
RTLD_DEEPBIND
RTLD_FIRST
RTLD_GLOBAL
RTLD_LAZY
RTLD_LOCAL
RTLD_NODELETE
RTLD_NOLOAD
RTLD_NOW
\end{lstlisting}

Enum constant for \hyperlink{6943450904282580385}{\texttt{dlopen}}. See your platform man page for details, if applicable.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L32-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10678331493920544551}{} 
\hyperlink{10678331493920544551}{\texttt{Base.Libdl.dlsym}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlsym(handle, sym)
\end{lstlisting}

Look up a symbol from a shared library handle, return callable function pointer on success.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L48-L52}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9015772327101222088}{} 
\hyperlink{9015772327101222088}{\texttt{Base.Libdl.dlsym\_e}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlsym_e(handle, sym)
\end{lstlisting}

Look up a symbol from a shared library handle, silently return \texttt{NULL} pointer on lookup failure.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L58-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10922755106166135872}{} 
\hyperlink{10922755106166135872}{\texttt{Base.Libdl.dlclose}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlclose(handle)
\end{lstlisting}

Close shared library referenced by handle.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L113-L117}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1158768347711175706}{} 
\hyperlink{1158768347711175706}{\texttt{Base.Libdl.dlext}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
dlext
\end{lstlisting}

File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L175-L179}{\texttt{source}}


\end{adjustwidth}
\hypertarget{227774243348950736}{} 
\hyperlink{227774243348950736}{\texttt{Base.Libdl.find\_library}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
find_library(names, locations)
\end{lstlisting}

Searches for the first library in \texttt{names} in the paths in the \texttt{locations} list, \texttt{DL\_LOAD\_PATH}, or system library paths (in that order) which can successfully be dlopen{\textquotesingle}d. On success, the return value will be one of the names (potentially prefixed by one of the paths in locations). This string can be assigned to a \texttt{global const} and used as the library name in future \texttt{ccall}{\textquotesingle}s. On failure, it returns the empty string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L122-L130}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17268797014804593519}{} 
\hyperlink{17268797014804593519}{\texttt{Base.Libdl.DL\_LOAD\_PATH}}  -- {Constant.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
DL_LOAD_PATH
\end{lstlisting}

When calling \hyperlink{6943450904282580385}{\texttt{dlopen}}, the paths in this list will be searched first, in order, before searching the system locations for a valid library handle.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libdl.jl#L9-L14}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13446659783021526147}{}


\chapter{Profiling}


\hypertarget{2219312293287618200}{} 
\hyperlink{2219312293287618200}{\texttt{Base.Profile.@profile}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@profile
\end{lstlisting}

\texttt{@profile <expression>} runs your expression while taking periodic backtraces. These are appended to an internal buffer of backtraces.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L10-L15}{\texttt{source}}


\end{adjustwidth}

Los métodos en \texttt{Base.Profile} no son exportados y necesitan ser llamados como, por ejemplo, \texttt{Profile.print()}.


\hypertarget{11632425935156818951}{} 
\hyperlink{11632425935156818951}{\texttt{Base.Profile.clear}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clear()
\end{lstlisting}

Clear any existing backtraces from the internal buffer.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L69-L73}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15011226253236705098}{} 
\hyperlink{15011226253236705098}{\texttt{Base.Profile.print}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
print([io::IO = STDOUT,] [data::Vector]; kwargs...)
\end{lstlisting}

Prints profiling results to \texttt{io} (by default, \texttt{STDOUT}). If you do not supply a \texttt{data} vector, the internal buffer of accumulated backtraces will be used.

The keyword arguments can be any combination of:

\begin{itemize}
\item \texttt{format} – Determines whether backtraces are printed with (default, \texttt{:tree}) or without (\texttt{:flat}) indentation indicating tree structure.


\item \texttt{C} – If \texttt{true}, backtraces from C and Fortran code are shown (normally they are excluded).


\item \texttt{combine} – If \texttt{true} (default), instruction pointers are merged that correspond to the same line of code.


\item \texttt{maxdepth} – Limits the depth higher than \texttt{maxdepth} in the \texttt{:tree} format.


\item \texttt{sortedby} – Controls the order in \texttt{:flat} format. \texttt{:filefuncline} (default) sorts by the source  line, whereas \texttt{:count} sorts in order of number of collected samples.


\item \texttt{noisefloor} – Limits frames that exceed the heuristic noise floor of the sample (only applies to format \texttt{:tree}).  A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which \texttt{n <= noisefloor * √N},  where \texttt{n} is the number of samples on this line, and \texttt{N} is the number of samples for the callee.


\item \texttt{mincount} – Limits the printout to only those lines with at least \texttt{mincount} occurrences.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L97-L123}{\texttt{source}}



\begin{lstlisting}
print([io::IO = STDOUT,] data::Vector, lidict::LineInfoDict; kwargs...)
\end{lstlisting}

Prints profiling results to \texttt{io}. This variant is used to examine results exported by a previous call to \hyperlink{15769908906720781097}{\texttt{retrieve}}. Supply the vector \texttt{data} of backtraces and a dictionary \texttt{lidict} of line information.

See \texttt{Profile.print([io], data)} for an explanation of the valid keyword arguments.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L152-L160}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18079022569292406711}{} 
\hyperlink{18079022569292406711}{\texttt{Base.Profile.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
init(; n::Integer, delay::Float64)
\end{lstlisting}

Configure the \texttt{delay} between backtraces (measured in seconds), and the number \texttt{n} of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order \texttt{(n, delay)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L34-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9770463724510220682}{} 
\hyperlink{9770463724510220682}{\texttt{Base.Profile.fetch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch() -> data
\end{lstlisting}

Returns a reference to the internal buffer of backtraces. Note that subsequent operations, like \hyperlink{11632425935156818951}{\texttt{clear}}, can affect \texttt{data} unless you first make a copy. Note that the values in \texttt{data} have meaning only on this machine in the current session, because it depends on the exact memory addresses used in JIT-compiling. This function is primarily for internal use; \hyperlink{15769908906720781097}{\texttt{retrieve}} may be a better choice for most users.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L292-L300}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15769908906720781097}{} 
\hyperlink{15769908906720781097}{\texttt{Base.Profile.retrieve}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
retrieve() -> data, lidict
\end{lstlisting}

{\textquotedbl}Exports{\textquotedbl} profiling results in a portable format, returning the set of all backtraces (\texttt{data}) and a dictionary that maps the (session-specific) instruction pointers in \texttt{data} to \texttt{LineInfo} values that store the file name, function name, and line number. This function allows you to save profiling results for future analysis.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L164-L171}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17877106531089533686}{} 
\hyperlink{17877106531089533686}{\texttt{Base.Profile.callers}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
callers(funcname, [data, lidict], [filename=<filename>], [linerange=<start:stop>]) -> Vector{Tuple{count, lineinfo}}
\end{lstlisting}

Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace \texttt{data} obtained from \hyperlink{15769908906720781097}{\texttt{retrieve}}; otherwise, the current internal profile buffer is used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L226-L235}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12267785385121896224}{} 
\hyperlink{12267785385121896224}{\texttt{Base.Profile.clear\_malloc\_data}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clear_malloc_data()
\end{lstlisting}

Clears any stored memory allocation data when running julia with \texttt{--track-allocation}. Execute the command(s) you want to test (to force JIT-compilation), then call \hyperlink{12267785385121896224}{\texttt{clear\_malloc\_data}}. Then execute your command(s) again, quit Julia, and examine the resulting \texttt{*.mem} files.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/profile.jl#L262-L269}{\texttt{source}}


\end{adjustwidth}

\hypertarget{5903382401809839120}{}


\chapter{\emph{StackTraces}}


\hypertarget{16824886840215699957}{} 
\hyperlink{16824886840215699957}{\texttt{Base.StackTraces.StackFrame}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
StackFrame
\end{lstlisting}

Stack information representing execution context, with the following fields:

\begin{itemize}
\item \texttt{func::Symbol}

The name of the function containing the execution context.


\item \texttt{linfo::Nullable\{Core.MethodInstance\}}

The MethodInstance containing the execution context (if it could be found).


\item \texttt{file::Symbol}

The path to the file containing the execution context.


\item \texttt{line::Int}

The line number in the file containing the execution context.


\item \texttt{from\_c::Bool}

True if the code is from C.


\item \texttt{inlined::Bool}

True if the code is from an inlined frame.


\item \texttt{pointer::UInt64}

Representation of the pointer to the execution context as returned by \texttt{backtrace}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L11-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12289172590874430030}{} 
\hyperlink{12289172590874430030}{\texttt{Base.StackTraces.StackTrace}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
StackTrace
\end{lstlisting}

An alias for \texttt{Vector\{StackFrame\}} provided for convenience; returned by calls to \texttt{stacktrace} and \texttt{catch\_stacktrace}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L64-L69}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11964270650763140298}{} 
\hyperlink{11964270650763140298}{\texttt{Base.StackTraces.stacktrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
stacktrace([trace::Vector{Ptr{Void}},] [c_funcs::Bool=false]) -> StackTrace
\end{lstlisting}

Returns a stack trace in the form of a vector of \texttt{StackFrame}s. (By default stacktrace doesn{\textquotesingle}t return C functions, but this can be enabled.) When called without specifying a trace, \texttt{stacktrace} first calls \texttt{backtrace}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L143-L149}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16506728660892665673}{} 
\hyperlink{16506728660892665673}{\texttt{Base.StackTraces.catch\_stacktrace}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
catch_stacktrace([c_funcs::Bool=false]) -> StackTrace
\end{lstlisting}

Returns the stack trace for the most recent error thrown, rather than the current execution context.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L171-L176}{\texttt{source}}


\end{adjustwidth}

Los siguientes métodos y tipos de \texttt{Base.StackTraces} no son exportados y, por tanto, deben ser prefijados en sus invocaciones. Por ejemplo, \texttt{StackTraces.lookup(ptr)}.


\hypertarget{1451426077045795515}{} 
\hyperlink{1451426077045795515}{\texttt{Base.StackTraces.lookup}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lookup(pointer::Union{Ptr{Void}, UInt}) -> Vector{StackFrame}
\end{lstlisting}

Given a pointer to an execution context (usually generated by a call to \texttt{backtrace}), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L117-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11320665145957459671}{} 
\hyperlink{11320665145957459671}{\texttt{Base.StackTraces.remove\_frames!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
remove_frames!(stack::StackTrace, name::Symbol)
\end{lstlisting}

Takes a \texttt{StackTrace} (a vector of \texttt{StackFrames}) and a function name (a \texttt{Symbol}) and removes the \texttt{StackFrame} specified by the function name from the \texttt{StackTrace} (also removing all frames above the specified function). Primarily used to remove \texttt{StackTraces} functions from the \texttt{StackTrace} prior to returning it.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L179-L186}{\texttt{source}}



\begin{lstlisting}
remove_frames!(stack::StackTrace, m::Module)
\end{lstlisting}

Returns the \texttt{StackTrace} with all \texttt{StackFrame}s from the provided \texttt{Module} removed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/stacktraces.jl#L197-L201}{\texttt{source}}


\end{adjustwidth}

\hypertarget{13586267588072234536}{}


\chapter{Soporte SIMD}



El tipo \texttt{VecElement\{T\}} está pensado para construir librerías de operaciones SIMD. Su uso práctico requiere usar \texttt{llvmcall}. El tipo está definido como:




\begin{minted}{julia}
struct VecElement{T}
    value::T
end
\end{minted}



Tiene una regla de compilación especial: una tupla homogénea de \texttt{VecElement\{T\}} se corresponde con un tipo \texttt{vector} LLVM cuando \texttt{T} es un tipo de bits primitivo y la longitud de la tupla está en el conjunto \{2-6,8-10,16\}.



En \texttt{-O3}, el compilador \emph{podría} vectorizar operaciones sobre tales tuplas automáticamente. Por ejemplo, el siguiente programa, cuando se compila con \texttt{julia -O3} genera dos instrucciones de adición SIMD (\texttt{addps}) sobre los sistemas x86:




\begin{minted}{julia}
const m128 = NTuple{4,VecElement{Float32}}

function add(a::m128, b::m128)
    (VecElement(a[1].value+b[1].value),
     VecElement(a[2].value+b[2].value),
     VecElement(a[3].value+b[3].value),
     VecElement(a[4].value+b[4].value))
end

triple(c::m128) = add(add(c,c),c)

code_native(triple,(m128,))
\end{minted}



Sin embargo, dado que no se puede confiar en la vectorización automática, el uso futuro se realizará principalmente a través de bibliotecas que usen \texttt{llvmcall}.



\part{Developer Documentation}


\hypertarget{6456620051738632536}{}


\chapter{Reflection and introspection}



Julia provides a variety of runtime reflection capabilities.



\hypertarget{17771187696170422072}{}


\section{Module bindings}



The exported names for a \texttt{Module} are available using \hyperlink{6473328671144201991}{\texttt{names(m::Module)}}, which will return an array of \hyperlink{18332791376992528422}{\texttt{Symbol}} elements representing the exported bindings. \texttt{names(m::Module, true)} returns symbols for all bindings in \texttt{m}, regardless of export status.



\hypertarget{14774754942140904122}{}


\section{DataType fields}



The names of \texttt{DataType} fields may be interrogated using \hyperlink{17481253338332315021}{\texttt{fieldnames()}}. For example, given the following type, \texttt{fieldnames(Point)} returns an arrays of \hyperlink{18332791376992528422}{\texttt{Symbol}} elements representing the field names:




\begin{lstlisting}
julia> struct Point
           x::Int
           y
       end

julia> fieldnames(Point)
2-element Array{Symbol,1}:
 :x
 :y
\end{lstlisting}



The type of each field in a \texttt{Point} object is stored in the \texttt{types} field of the \texttt{Point} variable itself:




\begin{lstlisting}
julia> Point.types
svec(Int64, Any)
\end{lstlisting}



While \texttt{x} is annotated as an \texttt{Int}, \texttt{y} was unannotated in the type definition, therefore \texttt{y} defaults to the \texttt{Any} type.



Types are themselves represented as a structure called \texttt{DataType}:




\begin{lstlisting}
julia> typeof(Point)
DataType
\end{lstlisting}



Note that \texttt{fieldnames(DataType)} gives the names for each field of \texttt{DataType} itself, and one of these fields is the \texttt{types} field observed in the example above.



\hypertarget{11371291537025953368}{}


\section{Subtypes}



The \emph{direct} subtypes of any \texttt{DataType} may be listed using \hyperlink{18325429904830593994}{\texttt{subtypes()}}. For example, the abstract \texttt{DataType} \hyperlink{11465394427882483091}{\texttt{AbstractFloat}} has four (concrete) subtypes:




\begin{minted}{jlcon}
julia> subtypes(AbstractFloat)
4-element Array{Union{DataType, UnionAll},1}:
 BigFloat
 Float16
 Float32
 Float64
\end{minted}



Any abstract subtype will also be included in this list, but further subtypes thereof will not; recursive application of \hyperlink{18325429904830593994}{\texttt{subtypes()}} may be used to inspect the full type tree.



\hypertarget{11957448814310282424}{}


\section{DataType layout}



The internal representation of a \texttt{DataType} is critically important when interfacing with C code and several functions are available to inspect these details. \hyperlink{12980593021531333073}{\texttt{isbits(T::DataType)}} returns true if \texttt{T} is stored with C-compatible alignment. \hyperlink{6956980533195055227}{\texttt{fieldoffset(T::DataType, i::Integer)}} returns the (byte) offset for field \emph{i} relative to the start of the type.



\hypertarget{9741782790992203943}{}


\section{Function methods}



The methods of any generic function may be listed using \hyperlink{3025953302266245919}{\texttt{methods()}}. The method dispatch table may be searched for methods accepting a given type using \hyperlink{12860964732831752396}{\texttt{methodswith()}}.



\hypertarget{10529563115945815287}{}


\section{Expansion and lowering}



As discussed in the \hyperlink{15444528597476882531}{Metaprogramming} section, the \hyperlink{8018172489611994488}{\texttt{macroexpand()}} function gives the unquoted and interpolated expression (\texttt{Expr}) form for a given macro. To use \texttt{macroexpand}, \texttt{quote} the expression block itself (otherwise, the macro will be evaluated and the result will be passed instead!). For example:




\begin{minted}{jlcon}
julia> macroexpand( :(@edit println("")) )
:((Base.edit)(println, (Base.typesof)("")))
\end{minted}



The functions \texttt{Base.Meta.show\_sexpr()} and \hyperlink{15981569052160951906}{\texttt{dump()}} are used to display S-expr style views and depth-nested detail views for any expression.



Finally, the \hyperlink{14846157655101111909}{\texttt{expand()}} function gives the \texttt{lowered} form of any expression and is of particular interest for understanding both macros and top-level statements such as function declarations and variable assignments:




\begin{minted}{jlcon}
julia> expand( :(f() = 1) )
:(begin
        $(Expr(:method, :f))
        $(Expr(:method, :f, :((Core.svec)((Core.svec)((Core.Typeof)(f)), (Core.svec)())), CodeInfo(:(begin  # none, line 1:
        return 1
    end)), false))
        return f
    end)
\end{minted}



\hypertarget{5101839880113461479}{}


\section{Intermediate and compiled representations}



Inspecting the lowered form for functions requires selection of the specific method to display, because generic functions may have many methods with different type signatures. For this purpose, method-specific code-lowering is available using \hyperlink{18235967286596219009}{\texttt{code\_lowered(f::Function, (Argtypes...))}}, and the type-inferred form is available using \hyperlink{14801595959157535515}{\texttt{code\_typed(f::Function, (Argtypes...))}}. \hyperlink{16883039507765569860}{\texttt{code\_warntype(f::Function, (Argtypes...))}} adds highlighting to the output of \hyperlink{14801595959157535515}{\texttt{code\_typed()}} (see \hyperlink{7509450972834198661}{\texttt{@code\_warntype}}).



Closer to the machine, the LLVM intermediate representation of a function may be printed using by \hyperlink{17587317969597936788}{\texttt{code\_llvm(f::Function, (Argtypes...))}}, and finally the compiled machine code is available using \hyperlink{1731537926898979255}{\texttt{code\_native(f::Function, (Argtypes...))}} (this will trigger JIT compilation/code generation for any function which has not previously been called).



For convenience, there are macro versions of the above functions which take standard function calls and expand argument types automatically:




\begin{minted}{jlcon}
julia> @code_llvm +(1,1)

; Function Attrs: sspreq
define i64 @"julia_+_130862"(i64, i64) #0 {
top:
    %2 = add i64 %1, %0, !dbg !8
    ret i64 %2, !dbg !8
}
\end{minted}



(likewise \texttt{@code\_typed}, \texttt{@code\_warntype}, \texttt{@code\_lowered}, and \texttt{@code\_native})



\chapter{Documentation of Julia's Internals}


\hypertarget{1567551262556259173}{}


\section{Initialization of the Julia runtime}



How does the Julia runtime execute \texttt{julia -e {\textquotesingle}println({\textquotedbl}Hello World!{\textquotedbl}){\textquotesingle}} ?



\hypertarget{6651980781302015874}{}


\subsection{main()}



Execution starts at \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{main()} in \texttt{ui/repl.c}}.



\texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/support/libsupportinit.c}{\texttt{libsupport\_init()}} to set the C library locale and to initialize the {\textquotedbl}ios{\textquotedbl} library (see \href{https://github.com/JuliaLang/julia/blob/master/src/support/ios.c}{\texttt{ios\_init\_stdstreams()}} and \hyperlink{15406109399506022628}{Legacy \texttt{ios.c} library}).



Next \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{parse\_opts()}} is called to process command line options. Note that \texttt{parse\_opts()} only deals with options that affect code generation or early initialization. Other options are handled later by \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{process\_options()} in \texttt{base/client.jl}}.



\texttt{parse\_opts()} stores command line options in the \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{global \texttt{jl\_options} struct}.



\hypertarget{10951200599627901176}{}


\subsection{julia\_init()}



\href{https://github.com/JuliaLang/julia/blob/master/src/task.c}{\texttt{julia\_init()} in \texttt{task.c}} is called by \texttt{main()} and calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{\_julia\_init()} in \texttt{init.c}}.



\texttt{\_julia\_init()} begins by calling \texttt{libsupport\_init()} again (it does nothing the second time).



\href{https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c}{\texttt{restore\_signals()}} is called to zero the signal handler mask.



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_resolve\_sysimg\_location()}} searches configured paths for the base system image. See \hyperlink{13880852207471486494}{Building the Julia system image}.



\href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{\texttt{jl\_gc\_init()}} sets up allocation pools and lists for weak refs, preserved values and finalization.



\href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_init\_frontend()}} loads and initializes a pre-compiled femtolisp image containing the scanner/parser.



\href{https://github.com/JuliaLang/julia/blob/master/src/jltypes.c}{\texttt{jl\_init\_types()}} creates \texttt{jl\_datatype\_t} type description objects for the \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{built-in types defined in \texttt{julia.h}}. e.g.




\begin{lstlisting}
jl_any_type = jl_new_abstracttype(jl_symbol("Any"), NULL, jl_null);
jl_any_type->super = jl_any_type;

jl_type_type = jl_new_abstracttype(jl_symbol("Type"), jl_any_type, jl_null);

jl_int32_type = jl_new_bitstype(jl_symbol("Int32"),
                                jl_any_type, jl_null, 32);
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/master/src/task.c}{\texttt{jl\_init\_tasks()}} creates the \texttt{jl\_datatype\_t* jl\_task\_type} object; initializes the global \texttt{jl\_root\_task} struct; and sets \texttt{jl\_current\_task} to the root task.



\href{https://github.com/JuliaLang/julia/blob/master/src/codegen.cpp}{\texttt{jl\_init\_codegen()}} initializes the \href{http://llvm.org}{LLVM library}.



\href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_init\_serializer()}} initializes 8-bit serialization tags for 256 frequently used \texttt{jl\_value\_t} values. The serialization mechanism uses these tags as shorthand (in lieu of storing whole objects) to save storage space.



If there is no sysimg file (\texttt{!jl\_options.image\_file}) then the \texttt{Core} and \texttt{Main} modules are created and \texttt{boot.jl} is evaluated:



\texttt{jl\_core\_module = jl\_new\_module(jl\_symbol({\textquotedbl}Core{\textquotedbl}))} creates the Julia \texttt{Core} module.



\href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{\texttt{jl\_init\_intrinsic\_functions()}} creates a new Julia module \texttt{Intrinsics} containing constant \texttt{jl\_intrinsic\_type} symbols. These define an integer code for each \href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{intrinsic function}. \href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{\texttt{emit\_intrinsic()}} translates these symbols into LLVM instructions during code generation.



\href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_init\_primitives()}} hooks C functions up to Julia function symbols. e.g. the symbol \texttt{Base.is()} is bound to C function pointer \texttt{jl\_f\_is()} by calling \texttt{add\_builtin\_func({\textquotedbl}eval{\textquotedbl}, jl\_f\_top\_eval)}.



\href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_new\_main\_module()}} creates the global {\textquotedbl}Main{\textquotedbl} module and sets \texttt{jl\_current\_task->current\_module = jl\_main\_module}.



Note: \texttt{\_julia\_init()} \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{then sets} \texttt{jl\_root\_task->current\_module = jl\_core\_module}. \texttt{jl\_root\_task} is an alias of \texttt{jl\_current\_task} at this point, so the \texttt{current\_module} set by \texttt{jl\_new\_main\_module()} above is overwritten.



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_load({\textquotedbl}boot.jl{\textquotedbl}, sizeof({\textquotedbl}boot.jl{\textquotedbl}))}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_parse\_eval\_all}} which repeatedly calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}} to execute \href{https://github.com/JuliaLang/julia/blob/master/base/boot.jl}{\texttt{boot.jl}}. <!– TODO – drill down into eval? –>



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_get\_builtin\_hooks()}} initializes global C pointers to Julia globals defined in \texttt{boot.jl}.



\href{https://github.com/JuliaLang/julia/blob/master/src/datatype.c}{\texttt{jl\_init\_box\_caches()}} pre-allocates global boxed integer value objects for values up to 1024. This speeds up allocation of boxed ints later on. e.g.:




\begin{lstlisting}
jl_value_t *jl_box_uint8(uint32_t x)
{
    return boxed_uint8_cache[(uint8_t)x];
}
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{\_julia\_init()} iterates} over the \texttt{jl\_core\_module->bindings.table} looking for \texttt{jl\_datatype\_t} values and sets the type name{\textquotesingle}s module prefix to \texttt{jl\_core\_module}.



\href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_add\_standard\_imports(jl\_main\_module)}} does {\textquotedbl}using Base{\textquotedbl} in the {\textquotedbl}Main{\textquotedbl} module.



Note: \texttt{\_julia\_init()} now reverts to \texttt{jl\_root\_task->current\_module = jl\_main\_module} as it was before being set to \texttt{jl\_core\_module} above.



Platform specific signal handlers are initialized for \texttt{SIGSEGV} (OSX, Linux), and \texttt{SIGFPE} (Windows).



Other signals (\texttt{SIGINFO, SIGBUS, SIGILL, SIGTERM, SIGABRT, SIGQUIT, SIGSYS} and \texttt{SIGPIPE}) are hooked up to \href{https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c}{\texttt{sigdie\_handler()}} which prints a backtrace.



\href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_init\_restored\_modules()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/module.c}{\texttt{jl\_module\_run\_initializer()}} for each deserialized module to run the \texttt{\_\_init\_\_()} function.



Finally \href{https://github.com/JuliaLang/julia/blob/master/src/signals-unix.c}{\texttt{sigint\_handler()}} is hooked up to \texttt{SIGINT} and calls \texttt{jl\_throw(jl\_interrupt\_exception)}.



\texttt{\_julia\_init()} then returns \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{back to \texttt{main()} in \texttt{ui/repl.c}} and \texttt{main()} calls \texttt{true\_main(argc, (char**)argv)}.



\begin{quote}
\textbf{sysimg}

If there is a sysimg file, it contains a pre-cooked image of the \texttt{Core} and \texttt{Main} modules (and whatever else is created by \texttt{boot.jl}). See \hyperlink{13880852207471486494}{Building the Julia system image}.

\href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_restore\_system\_image()}} deserializes the saved sysimg into the current Julia runtime environment and initialization continues after \texttt{jl\_init\_box\_caches()} below...

Note: \href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_restore\_system\_image()} (and \texttt{dump.c} in general)} uses the \hyperlink{15406109399506022628}{Legacy \texttt{ios.c} library}.

\end{quote}


\hypertarget{8052465870854670365}{}


\subsection{true\_main()}



\href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{true\_main()}} loads the contents of \texttt{argv[]} into \hyperlink{2567473177880607455}{\texttt{Base.ARGS}}.



If a \texttt{.jl} {\textquotedbl}program{\textquotedbl} file was supplied on the command line, then \href{https://github.com/JuliaLang/julia/blob/master/ui/repl.c}{\texttt{exec\_program()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_load(program,len)}} which calls \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_parse\_eval\_all}} which repeatedly calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}} to execute the program.



However, in our example (\texttt{julia -e {\textquotesingle}println({\textquotedbl}Hello World!{\textquotedbl}){\textquotesingle}}), \href{https://github.com/JuliaLang/julia/blob/master/src/module.c}{\texttt{jl\_get\_global(jl\_base\_module, jl\_symbol({\textquotedbl}\_start{\textquotedbl}))}} looks up \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.\_start}} and \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{\texttt{jl\_apply()}} executes it.



\hypertarget{12561163861893339364}{}


\subsection{Base.\_start}



\href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.\_start}} calls \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.process\_options}} which calls \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{jl\_parse\_input\_line({\textquotedbl}println({\textquotedbl}Hello World!{\textquotedbl}){\textquotedbl})}} to create an expression object and \hyperlink{2565512592221324751}{\texttt{Base.eval()}} to execute it.



\hypertarget{5161519074100035363}{}


\subsection{Base.eval}



\hyperlink{2565512592221324751}{\texttt{Base.eval()}} was \href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{mapped to \texttt{jl\_f\_top\_eval}} by \texttt{jl\_init\_primitives()}.



\href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_f\_top\_eval()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_toplevel\_eval\_in(jl\_main\_module, ex)}}, where \texttt{ex} is the parsed expression \texttt{println({\textquotedbl}Hello World!{\textquotedbl})}.



\href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{jl\_toplevel\_eval\_in()}} calls \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}} which calls \href{https://github.com/JuliaLang/julia/blob/master/src/interpreter.c}{\texttt{eval()} in \texttt{interpreter.c}}.



The stack dump below shows how the interpreter works its way through various methods of \hyperlink{783803254548423222}{\texttt{Base.println()}} and \hyperlink{8248717042415202230}{\texttt{Base.print()}} before arriving at \href{https://github.com/JuliaLang/julia/blob/master/base/stream.jl}{\texttt{write(s::IO, a::Array\{T\}) where T}}  which does \texttt{ccall(jl\_uv\_write())}.



\href{https://github.com/JuliaLang/julia/blob/master/src/jl\_uv.c}{\texttt{jl\_uv\_write()}} calls \texttt{uv\_write()} to write {\textquotedbl}Hello World!{\textquotedbl} to \texttt{JL\_STDOUT}. See \hyperlink{11306377068338291950}{Libuv wrappers for stdio}.:




\begin{lstlisting}
Hello World!
\end{lstlisting}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Stack frame & Source code & Notes \\
\hline
\texttt{jl\_uv\_write()} & \texttt{jl\_uv.c} & called though \hyperlink{14245046751182637566}{\texttt{ccall}} \\
\hline
\texttt{julia\_write\_282942} & \texttt{stream.jl} & function \texttt{write!(s::IO, a::Array\{T\}) where T} \\
\hline
\texttt{julia\_print\_284639} & \texttt{ascii.jl} & \texttt{print(io::IO, s::String) = (write(io, s); nothing)} \\
\hline
\texttt{jlcall\_print\_284639} &   &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.print(Base.TTY, String)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.print(Base.TTY, String, Char, Char...)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_f\_apply()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.println(Base.TTY, String, String...)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_trampoline()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{jl\_apply\_generic()} & \texttt{gf.c} & \texttt{Base.println(String,)} \\
\hline
\texttt{jl\_apply()} & \texttt{julia.h} &   \\
\hline
\texttt{do\_call()} & \texttt{interpreter.c} &   \\
\hline
\texttt{eval()} & \texttt{interpreter.c} &   \\
\hline
\texttt{jl\_interpret\_toplevel\_expr()} & \texttt{interpreter.c} &   \\
\hline
\texttt{jl\_toplevel\_eval\_flex()} & \texttt{toplevel.c} &   \\
\hline
\texttt{jl\_toplevel\_eval()} & \texttt{toplevel.c} &   \\
\hline
\texttt{jl\_toplevel\_eval\_in()} & \texttt{builtins.c} &   \\
\hline
\texttt{jl\_f\_top\_eval()} & \texttt{builtins.c} &   \\
\hline
\end{tabulary}

\end{table}



Since our example has just one function call, which has done its job of printing {\textquotedbl}Hello World!{\textquotedbl}, the stack now rapidly unwinds back to \texttt{main()}.



\hypertarget{8766302654766843311}{}


\subsection{jl\_atexit\_hook()}



\texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_atexit\_hook()}}. This calls \texttt{\_atexit} for each module, then calls \href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{\texttt{jl\_gc\_run\_all\_finalizers()}} and cleans up libuv handles.



\hypertarget{6367994784846959684}{}


\subsection{julia\_save()}



Finally, \texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{julia\_save()}}, which if requested on the command line, saves the runtime state to a new system image. See \href{https://github.com/JuliaLang/julia/blob/master/src/gf.c}{\texttt{jl\_compile\_all()}} and \href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_save\_system\_image()}}.



\hypertarget{92289363194562983}{}


\section{Julia ASTs}



Julia has two representations of code. First there is a surface syntax AST returned by the parser (e.g. the \hyperlink{13108503824143481717}{\texttt{parse()}} function), and manipulated by macros. It is a structured representation of code as it is written, constructed by \texttt{julia-parser.scm} from a character stream. Next there is a lowered form, or IR (intermediate representation), which is used by type inference and code generation. In the lowered form there are fewer types of nodes, all macros are expanded, and all control flow is converted to explicit branches and sequences of statements. The lowered form is constructed by \texttt{julia-syntax.scm}.



First we will focus on the lowered form, since it is more important to the compiler. It is also less obvious to the human, since it results from a significant rearrangement of the input syntax.



\hypertarget{16818744617880081407}{}


\subsection{Lowered form}



The following data types exist in lowered form:



\begin{itemize}
\item \texttt{Expr}

Has a node type indicated by the \texttt{head} field, and an \texttt{args} field which is a \texttt{Vector\{Any\}} of subexpressions.


\item \texttt{Slot}

Identifies arguments and local variables by consecutive numbering. \texttt{Slot} is an abstract type with subtypes \texttt{SlotNumber} and \texttt{TypedSlot}. Both types have an integer-valued \texttt{id} field giving the slot index. Most slots have the same type at all uses, and so are represented with \texttt{SlotNumber}. The types of these slots are found in the \texttt{slottypes} field of their \texttt{MethodInstance} object. Slots that require per-use type annotations are represented with \texttt{TypedSlot}, which has a \texttt{typ} field.


\item \texttt{CodeInfo}

Wraps the IR of a method.


\item \texttt{LineNumberNode}

Contains a single number, specifying the line number the next statement came from.


\item \texttt{LabelNode}

Branch target, a consecutively-numbered integer starting at 0.


\item \texttt{GotoNode}

Unconditional branch.


\item \texttt{QuoteNode}

Wraps an arbitrary value to reference as data. For example, the function \texttt{f() = :a} contains a \texttt{QuoteNode} whose \texttt{value} field is the symbol \texttt{a}, in order to return the symbol itself instead of evaluating it.


\item \texttt{GlobalRef}

Refers to global variable \texttt{name} in module \texttt{mod}.


\item \texttt{SSAValue}

Refers to a consecutively-numbered (starting at 0) static single assignment (SSA) variable inserted by the compiler.


\item \texttt{NewvarNode}

Marks a point where a variable is created. This has the effect of resetting a variable to undefined.

\end{itemize}


\hypertarget{15302433068188215381}{}


\subsubsection{Expr types}



These symbols appear in the \texttt{head} field of \texttt{Expr}s in lowered form.



\begin{itemize}
\item \texttt{call}

Function call (dynamic dispatch). \texttt{args[1]} is the function to call, \texttt{args[2:end]} are the arguments.


\item \texttt{invoke}

Function call (static dispatch). \texttt{args[1]} is the MethodInstance to call, \texttt{args[2:end]} are the arguments (including the function that is being called, at \texttt{args[2]}).


\item \texttt{static\_parameter}

Reference a static parameter by index.


\item \texttt{line}

Line number and file name metadata. Unlike a \texttt{LineNumberNode}, can also contain a file name.


\item \texttt{gotoifnot}

Conditional branch. If \texttt{args[1]} is false, goes to label identified in \texttt{args[2]}.


\item \texttt{=}

Assignment.


\item \texttt{method}

Adds a method to a generic function and assigns the result if necessary.

Has a 1-argument form and a 4-argument form. The 1-argument form arises from the syntax \texttt{function foo end}. In the 1-argument form, the argument is a symbol. If this symbol already names a function in the current scope, nothing happens. If the symbol is undefined, a new function is created and assigned to the identifier specified by the symbol. If the symbol is defined but names a non-function, an error is raised. The definition of {\textquotedbl}names a function{\textquotedbl} is that the binding is constant, and refers to an object of singleton type. The rationale for this is that an instance of a singleton type uniquely identifies the type to add the method to. When the type has fields, it wouldn{\textquotesingle}t be clear whether the method was being added to the instance or its type.

The 4-argument form has the following arguments:

\begin{itemize}
\item \texttt{args[1]}

A function name, or \texttt{false} if unknown. If a symbol, then the expression first behaves like the 1-argument form above. This argument is ignored from then on. When this is \texttt{false}, it means a method is being added strictly by type, \texttt{(::T)(x) = x}.


\item \texttt{args[2]}

A \texttt{SimpleVector} of argument type data. \texttt{args[2][1]} is a \texttt{SimpleVector} of the argument types, and \texttt{args[2][2]} is a \texttt{SimpleVector} of type variables corresponding to the method{\textquotesingle}s static parameters.


\item \texttt{args[3]}

A \texttt{CodeInfo} of the method itself. For {\textquotedbl}out of scope{\textquotedbl} method definitions (adding a method to a function that also has methods defined in different scopes) this is an expression that evaluates to a \texttt{:lambda} expression.


\item \texttt{args[4]}

\texttt{true} or \texttt{false}, identifying whether the method is staged (\texttt{@generated function}).

\end{itemize}

\item \texttt{const}

Declares a (global) variable as constant.


\item \texttt{null}

Has no arguments; simply yields the value \texttt{nothing}.


\item \texttt{new}

Allocates a new struct-like object. First argument is the type. The \texttt{new} pseudo-function is lowered to this, and the type is always inserted by the compiler.  This is very much an internal-only feature, and does no checking. Evaluating arbitrary \texttt{new} expressions can easily segfault.


\item \texttt{return}

Returns its argument as the value of the enclosing function.


\item \texttt{the\_exception}

Yields the caught exception inside a \texttt{catch} block. This is the value of the run time system variable \texttt{jl\_exception\_in\_transit}.


\item \texttt{enter}

Enters an exception handler (\texttt{setjmp}). \texttt{args[1]} is the label of the catch block to jump to on error.


\item \texttt{leave}

Pop exception handlers. \texttt{args[1]} is the number of handlers to pop.


\item \texttt{inbounds}

Controls turning bounds checks on or off. A stack is maintained; if the first argument of this expression is true or false (\texttt{true} means bounds checks are disabled), it is pushed onto the stack. If the first argument is \texttt{:pop}, the stack is popped.


\item \texttt{boundscheck}

Indicates the beginning or end of a section of code that performs a bounds check. Like \texttt{inbounds}, a stack is maintained, and the second argument can be one of: \texttt{true}, \texttt{false}, or \texttt{:pop}.


\item \texttt{copyast}

Part of the implementation of quasi-quote. The argument is a surface syntax AST that is simply copied recursively and returned at run time.


\item \texttt{meta}

Metadata. \texttt{args[1]} is typically a symbol specifying the kind of metadata, and the rest of the arguments are free-form. The following kinds of metadata are commonly used:

\begin{itemize}
\item \texttt{:inline} and \texttt{:noinline}: Inlining hints.


\item \texttt{:push\_loc}: enters a sequence of statements from a specified source location.

\begin{itemize}
\item \texttt{args[2]} specifies a filename, as a symbol.


\item \texttt{args[3]} optionally specifies the name of an (inlined) function that originally contained the code.

\end{itemize}

\item \texttt{:pop\_loc}: returns to the source location before the matching \texttt{:push\_loc}.

\end{itemize}
\end{itemize}


\hypertarget{11059186909242156655}{}


\subsubsection{Method}



A unique{\textquotesingle}d container describing the shared metadata for a single method.



\begin{itemize}
\item \texttt{name}, \texttt{module}, \texttt{file}, \texttt{line}, \texttt{sig}

Metadata to uniquely identify the method for the computer and the human.


\item \texttt{ambig}

Cache of other methods that may be ambiguous with this one.


\item \texttt{specializations}

Cache of all MethodInstance ever created for this Method, used to ensure uniqueness. Uniqueness is required for efficiency, especially for incremental precompile and tracking of method invalidation.


\item \texttt{source}

The original source code (usually compressed).


\item \texttt{roots}

Pointers to non-AST things that have been interpolated into the AST, required by compression of the AST, type-inference, or the generation of native code.


\item \texttt{nargs}, \texttt{isva}, \texttt{called}, \texttt{isstaged}, \texttt{pure}

Descriptive bit-fields for the source code of this Method.


\item \texttt{min\_world} / \texttt{max\_world}

The range of world ages for which this method is visible to dispatch.

\end{itemize}


\hypertarget{2584833319372808594}{}


\subsubsection{MethodInstance}



A unique{\textquotesingle}d container describing a single callable signature for a Method. See especially \hyperlink{16029610522337323518}{Proper maintenance and care of multi-threading locks} for important details on how to modify these fields safely.



\begin{itemize}
\item \texttt{specTypes}

The primary key for this MethodInstance. Uniqueness is guaranteed through a \texttt{def.specializations} lookup.


\item \texttt{def}

The \texttt{Method} that this function describes a specialization of. Or \texttt{\#undef}, if this is a top-level Lambda that is not part of a Method.


\item \texttt{sparam\_vals}

The values of the static parameters in \texttt{specTypes} indexed by \texttt{def.sparam\_syms}. For the \texttt{MethodInstance} at \texttt{Method.unspecialized}, this is the empty \texttt{SimpleVector}. But for a runtime \texttt{MethodInstance} from the \texttt{MethodTable} cache, this will always be defined and indexable.


\item \texttt{rettype}

The inferred return type for the \texttt{specFunctionObject} field, which (in most cases) is also the computed return type for the function in general.


\item \texttt{inferred}

May contain a cache of the inferred source for this function, or other information about the inference result such as a constant return value may be put here (if \texttt{jlcall\_api == 2}), or it could be set to \texttt{nothing} to just indicate \texttt{rettype} is inferred.


\item \texttt{ftpr}

The generic jlcall entry point.


\item \texttt{jlcall\_api}

The ABI to use when calling \texttt{fptr}. Some significant ones include:

\begin{itemize}
\item 0 - Not compiled yet


\item 1 - JL\_CALLABLE \texttt{jl\_value\_t *(*)(jl\_function\_t *f, jl\_value\_t *args[nargs], uint32\_t nargs)}


\item 2 - Constant (value stored in \texttt{inferred})


\item 3 - With Static-parameters forwarded \texttt{jl\_value\_t *(*)(jl\_svec\_t *sparams, jl\_function\_t *f, jl\_value\_t *args[nargs], uint32\_t nargs)}


\item 4 - Run in interpreter \texttt{jl\_value\_t *(*)(jl\_method\_instance\_t *meth, jl\_function\_t *f, jl\_value\_t *args[nargs], uint32\_t nargs)}

\end{itemize}

\item \texttt{min\_world} / \texttt{max\_world}

The range of world ages for which this method instance is valid to be called.

\end{itemize}


\hypertarget{15595975163128328315}{}


\subsubsection{CodeInfo}



A temporary container for holding lowered source code.



\begin{itemize}
\item \texttt{code}

An \texttt{Any} array of statements


\item \texttt{slotnames}

An array of symbols giving the name of each slot (argument or local variable).


\item \texttt{slottypes}

An array of types for the slots.


\item \texttt{slotflags}

A \texttt{UInt8} array of slot properties, represented as bit flags:

\begin{itemize}
\item 2  - assigned (only false if there are \emph{no} assignment statements with this var on the left)


\item 8  - const (currently unused for local variables)


\item 16 - statically assigned once


\item 32 - might be used before assigned. This flag is only valid after type inference.

\end{itemize}

\item \texttt{ssavaluetypes}

Either an array or an \texttt{Int}.

If an \texttt{Int}, it gives the number of compiler-inserted temporary locations in the function. If an array, specifies a type for each location.

\end{itemize}


Boolean properties:



\begin{itemize}
\item \texttt{inferred}

Whether this has been produced by type inference.


\item \texttt{inlineable}

Whether this should be inlined.


\item \texttt{propagate\_inbounds}

Whether this should should propagate \texttt{@inbounds} when inlined for the purpose of eliding \texttt{@boundscheck} blocks.


\item \texttt{pure}

Whether this is known to be a pure function of its arguments, without respect to the state of the method caches or other mutable global state.

\end{itemize}


\hypertarget{6198433338459689204}{}


\subsection{Surface syntax AST}



Front end ASTs consist entirely of \texttt{Expr}s and atoms (e.g. symbols, numbers). There is generally a different expression head for each visually distinct syntactic form. Examples will be given in s-expression syntax. Each parenthesized list corresponds to an Expr, where the first element is the head. For example \texttt{(call f x)} corresponds to \texttt{Expr(:call, :f, :x)} in Julia.



\hypertarget{13191950853363974893}{}


\subsubsection{Calls}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{f(x)} & \texttt{(call f x)} \\
\hline
\texttt{f(x, y=1, z=2)} & \texttt{(call f x (kw y 1) (kw z 2))} \\
\hline
\texttt{f(x; y=1)} & \texttt{(call f (parameters (kw y 1)) x)} \\
\hline
\texttt{f(x...)} & \texttt{(call f (... x))} \\
\hline
\end{tabulary}

\end{table}



\texttt{do} syntax:




\begin{minted}{julia}
f(x) do a,b
    body
end
\end{minted}



parses as \texttt{(call f (-> (tuple a b) (block body)) x)}.



\hypertarget{16991843071018324380}{}


\subsubsection{Operators}



Most uses of operators are just function calls, so they are parsed with the head \texttt{call}. However some operators are special forms (not necessarily function calls), and in those cases the operator itself is the expression head. In julia-parser.scm these are referred to as {\textquotedbl}syntactic operators{\textquotedbl}. Some operators (\texttt{+} and \texttt{*}) use N-ary parsing; chained calls are parsed as a single N-argument call. Finally, chains of comparisons have their own special expression structure.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{x+y} & \texttt{(call + x y)} \\
\hline
\texttt{a+b+c+d} & \texttt{(call + a b c d)} \\
\hline
\texttt{2x} & \texttt{(call * 2 x)} \\
\hline
\texttt{a\&\&b} & \texttt{(\&\& a b)} \\
\hline
\texttt{x += 1} & \texttt{(+= x 1)} \\
\hline
\texttt{a ? 1 : 2} & \texttt{(if a 1 2)} \\
\hline
\texttt{a:b} & \texttt{(: a b)} \\
\hline
\texttt{a:b:c} & \texttt{(: a b c)} \\
\hline
\texttt{a,b} & \texttt{(tuple a b)} \\
\hline
\texttt{a==b} & \texttt{(call == a b)} \\
\hline
\texttt{1<i<=n} & \texttt{(comparison 1 < i <= n)} \\
\hline
\texttt{a.b} & \texttt{(. a (quote b))} \\
\hline
\texttt{a.(b)} & \texttt{(. a b)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{15884526073773577025}{}


\subsubsection{Bracketed forms}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{a[i]} & \texttt{(ref a i)} \\
\hline
\texttt{t[i;j]} & \texttt{(typed\_vcat t i j)} \\
\hline
\texttt{t[i j]} & \texttt{(typed\_hcat t i j)} \\
\hline
\texttt{t[a b; c d]} & \texttt{(typed\_vcat t (row a b) (row c d))} \\
\hline
\texttt{a\{b\}} & \texttt{(curly a b)} \\
\hline
\texttt{a\{b;c\}} & \texttt{(curly a (parameters c) b)} \\
\hline
\texttt{[x]} & \texttt{(vect x)} \\
\hline
\texttt{[x,y]} & \texttt{(vect x y)} \\
\hline
\texttt{[x;y]} & \texttt{(vcat x y)} \\
\hline
\texttt{[x y]} & \texttt{(hcat x y)} \\
\hline
\texttt{[x y; z t]} & \texttt{(vcat (row x y) (row z t))} \\
\hline
\texttt{[x for y in z, a in b]} & \texttt{(comprehension x (= y z) (= a b))} \\
\hline
\texttt{T[x for y in z]} & \texttt{(typed\_comprehension T x (= y z))} \\
\hline
\texttt{(a, b, c)} & \texttt{(tuple a b c)} \\
\hline
\texttt{(a; b; c)} & \texttt{(block a (block b c))} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{7735912728489467540}{}


\subsubsection{Macros}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{@m x y} & \texttt{(macrocall @m x y)} \\
\hline
\texttt{Base.@m x y} & \texttt{(macrocall (. Base (quote @m)) x y)} \\
\hline
\texttt{@Base.m x y} & \texttt{(macrocall (. Base (quote @m)) x y)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{5278796056388981234}{}


\subsubsection{Strings}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{{\textquotedbl}a{\textquotedbl}} & \texttt{{\textquotedbl}a{\textquotedbl}} \\
\hline
\texttt{x{\textquotedbl}y{\textquotedbl}} & \texttt{(macrocall @x\_str {\textquotedbl}y{\textquotedbl})} \\
\hline
\texttt{x{\textquotedbl}y{\textquotedbl}z} & \texttt{(macrocall @x\_str {\textquotedbl}y{\textquotedbl} {\textquotedbl}z{\textquotedbl})} \\
\hline
\texttt{{\textquotedbl}x = \$x{\textquotedbl}} & \texttt{(string {\textquotedbl}x = {\textquotedbl} x)} \\
\hline
\texttt{`a b c`} & \texttt{(macrocall @cmd {\textquotedbl}a b c{\textquotedbl})} \\
\hline
\end{tabulary}

\end{table}



Doc string syntax:




\begin{minted}{julia}
"some docs"
f(x) = x
\end{minted}



parses as \texttt{(macrocall (|.| Core {\textquotesingle}@doc) {\textquotedbl}some docs{\textquotedbl} (= (call f x) (block x)))}.



\hypertarget{13863161852089184826}{}


\subsubsection{Imports and such}




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{import a} & \texttt{(import a)} \\
\hline
\texttt{import a.b.c} & \texttt{(import a b c)} \\
\hline
\texttt{import ...a} & \texttt{(import . . . a)} \\
\hline
\texttt{import a.b, c.d} & \texttt{(toplevel (import a b) (import c d))} \\
\hline
\texttt{import Base: x} & \texttt{(import Base x)} \\
\hline
\texttt{import Base: x, y} & \texttt{(toplevel (import Base x) (import Base y))} \\
\hline
\texttt{export a, b} & \texttt{(export a b)} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{13439801024488074381}{}


\subsubsection{Numbers}



Julia supports more number types than many scheme implementations, so not all numbers are represented directly as scheme numbers in the AST.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
Input & AST \\
\hline
\texttt{11111111111111111111} & \texttt{(macrocall @int128\_str {\textquotedbl}11111111111111111111{\textquotedbl})} \\
\hline
\texttt{0xfffffffffffffffff} & \texttt{(macrocall @uint128\_str {\textquotedbl}0xfffffffffffffffff{\textquotedbl})} \\
\hline
\texttt{1111...many digits...} & \texttt{(macrocall @big\_str {\textquotedbl}1111....{\textquotedbl})} \\
\hline
\end{tabulary}

\end{table}



\hypertarget{12573206411049142153}{}


\subsubsection{Block forms}



A block of statements is parsed as \texttt{(block stmt1 stmt2 ...)}.



If statement:




\begin{minted}{julia}
if a
    b
elseif c
    d
else e
    f
end
\end{minted}



parses as:




\begin{lstlisting}
(if a (block (line 2) b)
    (block (line 3) (if c (block (line 4) d)
                        (block (line 5) e (line 6) f))))
\end{lstlisting}



A \texttt{while} loop parses as \texttt{(while condition body)}.



A \texttt{for} loop parses as \texttt{(for (= var iter) body)}. If there is more than one iteration specification, they are parsed as a block: \texttt{(for (block (= v1 iter1) (= v2 iter2)) body)}.



\texttt{break} and \texttt{continue} are parsed as 0-argument expressions \texttt{(break)} and \texttt{(continue)}.



\texttt{let} is parsed as \texttt{(let body (= var1 val1) (= var2 val2) ...)}.



A basic function definition is parsed as \texttt{(function (call f x) body)}. A more complex example:




\begin{minted}{julia}
function f{T}(x::T; k = 1)
    return x+1
end
\end{minted}



parses as:




\begin{lstlisting}
(function (call (curly f T) (parameters (kw k 1))
                (:: x T))
          (block (line 2 file.jl) (return (call + x 1))))
\end{lstlisting}



Type definition:




\begin{minted}{julia}
mutable struct Foo{T<:S}
    x::T
end
\end{minted}



parses as:




\begin{lstlisting}
(type #t (curly Foo (<: T S))
      (block (line 2 none) (:: x T)))
\end{lstlisting}



The first argument is a boolean telling whether the type is mutable.



\texttt{try} blocks parse as \texttt{(try try\_block var catch\_block finally\_block)}. If no variable is present after \texttt{catch}, \texttt{var} is \texttt{\#f}. If there is no \texttt{finally} clause, then the last argument is not present.



\hypertarget{7872161424372847354}{}


\section{Más sobre tipos}



Si ha usado Julia durante un tiempo, comprenderá el papel fundamental que juegan los tipos. Aquí intentamos meternos debajo del capó, centrándonos fundamentalmente en los \hyperlink{15542027490314302254}{Tipos Paramétricos}.



\hypertarget{13235606386613972466}{}


\subsection{Tipos y conjuntos (y \texttt{Any} y \texttt{Union\{\}}/\texttt{Bottom})}



Tal vez sea ms sencillo concebir el sistema de tipos de Julia en términos de conjuntos. Aunque los programas pueden manipular los valores individuales, un tipo se refiere a un conjunto de valores. Esto no es la misma cosa que una colección; por ejemplo, un \texttt{Set} de valores es en sí mismo un solo valor de tipo \texttt{Set}. En lugar de ello, un tipo describe un conjunto de  \emph{posible} valores, expresando incertidumbre sobre qué valor tenemos.



Un tipo \emph{concreto} \texttt{T} describe el conjunto de valores cuya etiqueta directa, tal y como es obtenida por la función \texttt{typeof} es \texttt{T}. Un tipo \emph{abstracto} describe un conjunto de valores posiblemente más grande.



\texttt{Any} describe el universo completo de valores posibles. \hyperlink{8469131683393450448}{\texttt{Integer}} es un subconjunto de \texttt{Any} que incluye \texttt{Int}, \hyperlink{5857518405103968275}{\texttt{Int8}}, y otros tipos concretos. Internamente, Julia también hace un uso intensivo de otro tipo conocido como  \texttt{Bottom}, que puede también ser escrito como \texttt{Union\{\}}. Esto corresponde al conjunto vacío.



Los tipos de Julia soportan las operaciones estándar de la teora de conjuntos: uno puede preguntar si \texttt{T1} es un {\textquotedbl}subconjunto{\textquotedbl} de \texttt{T2} con \texttt{T1 <: T2}. Análogamente, uno intersecta dos tipos usando \texttt{typeintersect}, realiza su unión con \texttt{Union}, y calcula un tipo que contiene su unión con \texttt{typejoin}:




\begin{minted}{jlcon}
julia> typeintersect(Int, Float64)
Union{}

julia> Union{Int, Float64}
Union{Float64, Int64}

julia> typejoin(Int, Float64)
Real

julia> typeintersect(Signed, Union{UInt8, Int8})
Int8

julia> Union{Signed, Union{UInt8, Int8}}
Union{Signed, UInt8}

julia> typejoin(Signed, Union{UInt8, Int8})
Integer

julia> typeintersect(Tuple{Integer,Float64}, Tuple{Int,Real})
Tuple{Int64,Float64}

julia> Union{Tuple{Integer,Float64}, Tuple{Int,Real}}
Union{Tuple{Int64,Real}, Tuple{Integer,Float64}}

julia> typejoin(Tuple{Integer,Float64}, Tuple{Int,Real})
Tuple{Integer,Real}
\end{minted}



While these operations may seem abstract, they lie at the heart of Julia.  For example, method dispatch is implemented by stepping through the items in a method list until reaching one for which the type of the argument tuple is a subtype of the method signature. For this algorithm to work, it{\textquotesingle}s important that methods be sorted by their specificity, and that the search begins with the most specific methods. Consequently, Julia also implements a partial order on types; this is achieved by functionality that is similar to \texttt{<:}, but with differences that will be discussed below.



\hypertarget{11911810306869937851}{}


\subsection{UnionAll types}



Julia{\textquotesingle}s type system can also express an \emph{iterated union} of types: a union of types over all values of some variable. This is needed to describe parametric types where the values of some parameters are not known.



For example, :obj:\texttt{Array} has two parameters as in \texttt{Array\{Int,2\}}. If we did not know the element type, we could write \texttt{Array\{T,2\} where T}, which is the union of \texttt{Array\{T,2\}} for all values of \texttt{T}: \texttt{Union\{Array\{Int8,2\}, Array\{Int16,2\}, ...\}}.



Such a type is represented by a \texttt{UnionAll} object, which contains a variable (\texttt{T} in this example, of type \texttt{TypeVar}), and a wrapped type (\texttt{Array\{T,2\}} in this example).



Consider the following methods:




\begin{minted}{julia}
f1(A::Array) = 1
f2(A::Array{Int}) = 2
f3(A::Array{T}) where {T<:Any} = 3
f4(A::Array{Any}) = 4
\end{minted}



The signature of \texttt{f3} is a \texttt{UnionAll} type wrapping a tuple type. All but \texttt{f4} can be called with \texttt{a = [1,2]}; all but \texttt{f2} can be called with \texttt{b = Any[1,2]}.



Let{\textquotesingle}s look at these types a little more closely:




\begin{minted}{jlcon}
julia> dump(Array)
UnionAll
  var: TypeVar
    name: Symbol T
    lb: Core.TypeofBottom Union{}
    ub: Any
  body: UnionAll
    var: TypeVar
      name: Symbol N
      lb: Core.TypeofBottom Union{}
      ub: Any
    body: Array{T,N} <: DenseArray{T,N}
\end{minted}



This indicates that \texttt{Array} actually names a \texttt{UnionAll} type. There is one \texttt{UnionAll} type for each parameter, nested. The syntax \texttt{Array\{Int,2\}} is equivalent to \texttt{Array\{Int\}\{2\}}; internally each \texttt{UnionAll} is instantiated with a particular variable value, one at a time, outermost-first. This gives a natural meaning to the omission of trailing type parameters; \texttt{Array\{Int\}} gives a type equivalent to \texttt{Array\{Int,N\} where N}.



A \texttt{TypeVar} is not itself a type, but rather should be considered part of the structure of a \texttt{UnionAll} type. Type variables have lower and upper bounds on their values (in the fields \texttt{lb} and \texttt{ub}). The symbol \texttt{name} is purely cosmetic. Internally, \texttt{TypeVar}s are compared by address, so they are defined as mutable types to ensure that {\textquotedbl}different{\textquotedbl} type variables can be distinguished. However, by convention they should not be mutated.



One can construct \texttt{TypeVar}s manually:




\begin{minted}{jlcon}
julia> TypeVar(:V, Signed, Real)
Signed<:V<:Real
\end{minted}



There are convenience versions that allow you to omit any of these arguments except the \texttt{name} symbol.



The syntax \texttt{Array\{T\} where T<:Integer} is lowered to




\begin{minted}{julia}
let T = TypeVar(:T,Integer)
    UnionAll(T, Array{T})
end
\end{minted}



so it is seldom necessary to construct a \texttt{TypeVar} manually (indeed, this is to be avoided).



\hypertarget{10862279169779752699}{}


\subsection{Free variables}



The concept of a \emph{free} type variable is extremely important in the type system. We say that a variable \texttt{V} is free in type \texttt{T} if \texttt{T} does not contain the \texttt{UnionAll} that introduces variable \texttt{V}. For example, the type \texttt{Array\{Array\{V\} where V<:Integer\}} has no free variables, but the \texttt{Array\{V\}} part inside of it does have a free variable, \texttt{V}.



A type with free variables is, in some sense, not really a type at all. Consider the type \texttt{Array\{Array\{T\}\} where T}, which refers to all homogeneous arrays of arrays. The inner type \texttt{Array\{T\}}, seen by itself, might seem to refer to any kind of array. However, every element of the outer array must have the \emph{same} array type, so \texttt{Array\{T\}} cannot refer to just any old array. One could say that \texttt{Array\{T\}} effectively {\textquotedbl}occurs{\textquotedbl} multiple times, and \texttt{T} must have the same value each {\textquotedbl}time{\textquotedbl}.



For this reason, the function \texttt{jl\_has\_free\_typevars} in the C API is very important. Types for which it returns true will not give meaningful answers in subtyping and other type functions.



\hypertarget{9475610527503799038}{}


\subsection{TypeNames}



The following two \hyperlink{15492651498431872487}{\texttt{Array}} types are functionally equivalent, yet print differently:




\begin{minted}{jlcon}
julia> TV, NV = TypeVar(:T), TypeVar(:N)
(T, N)

julia> Array
Array

julia> Array{TV,NV}
Array{T,N}
\end{minted}



These can be distinguished by examining the \texttt{name} field of the type, which is an object of type \texttt{TypeName}:




\begin{minted}{jlcon}
julia> dump(Array{Int,1}.name)
TypeName
  name: Symbol Array
  module: Module Core
  names: empty SimpleVector
  wrapper: UnionAll
    var: TypeVar
      name: Symbol T
      lb: Core.TypeofBottom Union{}
      ub: Any
    body: UnionAll
      var: TypeVar
        name: Symbol N
        lb: Core.TypeofBottom Union{}
        ub: Any
      body: Array{T,N} <: DenseArray{T,N}
  cache: SimpleVector
    ...

  linearcache: SimpleVector
    ...

  hash: Int64 -7900426068641098781
  mt: MethodTable
    name: Symbol Array
    defs: Void nothing
    cache: Void nothing
    max_args: Int64 0
    kwsorter: #undef
    module: Module Core
    : Int64 0
    : Int64 0
\end{minted}



In this case, the relevant field is \texttt{wrapper}, which holds a reference to the top-level type used to make new \texttt{Array} types.




\begin{minted}{jlcon}
julia> pointer_from_objref(Array)
Ptr{Void} @0x00007fcc7de64850

julia> pointer_from_objref(Array.body.body.name.wrapper)
Ptr{Void} @0x00007fcc7de64850

julia> pointer_from_objref(Array{TV,NV})
Ptr{Void} @0x00007fcc80c4d930

julia> pointer_from_objref(Array{TV,NV}.name.wrapper)
Ptr{Void} @0x00007fcc7de64850
\end{minted}



The \texttt{wrapper} field of \hyperlink{15492651498431872487}{\texttt{Array}} points to itself, but for \texttt{Array\{TV,NV\}} it points back to the original definition of the type.



What about the other fields? \texttt{hash} assigns an integer to each type.  To examine the \texttt{cache} field, it{\textquotesingle}s helpful to pick a type that is less heavily used than Array. Let{\textquotesingle}s first create our own type:




\begin{minted}{jlcon}
julia> struct MyType{T,N} end

julia> MyType{Int,2}
MyType{Int64,2}

julia> MyType{Float32, 5}
MyType{Float32,5}

julia> MyType.body.body.name.cache
svec(MyType{Float32,5}, MyType{Int64,2}, #undef, #undef, #undef, #undef, #undef, #undef)
\end{minted}



(The cache is pre-allocated to have length 8, but only the first two entries are populated.) Consequently, when you instantiate a parametric type, each concrete type gets saved in a type cache.  However, instances containing free type variables are not cached.



\hypertarget{15137612054834825471}{}


\subsection{Tuple types}



Tuple types constitute an interesting special case.  For dispatch to work on declarations like \texttt{x::Tuple}, the type has to be able to accommodate any tuple.  Let{\textquotesingle}s check the parameters:




\begin{minted}{jlcon}
julia> Tuple
Tuple

julia> Tuple.parameters
svec(Vararg{Any,N} where N)
\end{minted}



Unlike other types, tuple types are covariant in their parameters, so this definition permits \texttt{Tuple} to match any type of tuple:




\begin{minted}{jlcon}
julia> typeintersect(Tuple, Tuple{Int,Float64})
Tuple{Int64,Float64}

julia> typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})
Tuple{Int64,Float64}
\end{minted}



However, if a variadic (\texttt{Vararg}) tuple type has free variables it can describe different kinds of tuples:




\begin{minted}{jlcon}
julia> typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})
Tuple{Int64,Float64}

julia> typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})
Union{}
\end{minted}



Notice that when \texttt{T} is free with respect to the \texttt{Tuple} type (i.e. its binding \texttt{UnionAll} type is outside the \texttt{Tuple} type), only one \texttt{T} value must work over the whole type. Therefore a heterogeneous tuple does not match.



Finally, it{\textquotesingle}s worth noting that \texttt{Tuple\{\}} is distinct:




\begin{minted}{jlcon}
julia> Tuple{}
Tuple{}

julia> Tuple{}.parameters
svec()

julia> typeintersect(Tuple{}, Tuple{Int})
Union{}
\end{minted}



What is the {\textquotedbl}primary{\textquotedbl} tuple-type?




\begin{minted}{jlcon}
julia> pointer_from_objref(Tuple)
Ptr{Void} @0x00007f5998a04370

julia> pointer_from_objref(Tuple{})
Ptr{Void} @0x00007f5998a570d0

julia> pointer_from_objref(Tuple.name.wrapper)
Ptr{Void} @0x00007f5998a04370

julia> pointer_from_objref(Tuple{}.name.wrapper)
Ptr{Void} @0x00007f5998a04370
\end{minted}



so \texttt{Tuple == Tuple\{Vararg\{Any\}\}} is indeed the primary type.



\hypertarget{5206945150982308765}{}


\subsection{Diagonal types}



Consider the type \texttt{Tuple\{T,T\} where T}. A method with this signature would look like:




\begin{minted}{julia}
f(x::T, y::T) where {T} = ...
\end{minted}



According to the usual interpretation of a \texttt{UnionAll} type, this \texttt{T} ranges over all types, including \texttt{Any}, so this type should be equivalent to \texttt{Tuple\{Any,Any\}}. However, this interpretation causes some practical problems.



First, a value of \texttt{T} needs to be available inside the method definition. For a call like \texttt{f(1, 1.0)}, it{\textquotesingle}s not clear what \texttt{T} should be. It could be \texttt{Union\{Int,Float64\}}, or perhaps \hyperlink{6175959395021454412}{\texttt{Real}}. Intuitively, we expect the declaration \texttt{x::T} to mean \texttt{T === typeof(x)}. To make sure that invariant holds, we need \texttt{typeof(x) === typeof(y) === T} in this method. That implies the method should only be called for arguments of the exact same type.



It turns out that being able to dispatch on whether two values have the same type is very useful (this is used by the promotion system for example), so we have multiple reasons to want a different interpretation of \texttt{Tuple\{T,T\} where T}. To make this work we add the following rule to subtyping: if a variable occurs more than once in covariant position, it is restricted to ranging over only concrete types. ({\textquotedbl}Covariant position{\textquotedbl} means that only \texttt{Tuple} and \texttt{Union} types occur between an occurrence of a variable and the \texttt{UnionAll} type that introduces it.) Such variables are called {\textquotedbl}diagonal variables{\textquotedbl} or {\textquotedbl}concrete variables{\textquotedbl}.



So for example, \texttt{Tuple\{T,T\} where T} can be seen as \texttt{Union\{Tuple\{Int8,Int8\}, Tuple\{Int16,Int16\}, ...\}}, where \texttt{T} ranges over all concrete types. This gives rise to some interesting subtyping results. For example \texttt{Tuple\{Real,Real\}} is not a subtype of \texttt{Tuple\{T,T\} where T}, because it includes some types like \texttt{Tuple\{Int8,Int16\}} where the two elements have different types. \texttt{Tuple\{Real,Real\}} and \texttt{Tuple\{T,T\} where T} have the non-trivial intersection \texttt{Tuple\{T,T\} where T<:Real}. However, \texttt{Tuple\{Real\}} \emph{is} a subtype of \texttt{Tuple\{T\} where T}, because in that case \texttt{T} occurs only once and so is not diagonal.



Next consider a signature like the following:




\begin{minted}{julia}
f(a::Array{T}, x::T, y::T) where {T} = ...
\end{minted}



In this case, \texttt{T} occurs in invariant position inside \texttt{Array\{T\}}. That means whatever type of array is passed unambiguously determines the value of \texttt{T} –- we say \texttt{T} has an \emph{equality constraint} on it. Therefore in this case the diagonal rule is not really necessary, since the array determines \texttt{T} and we can then allow \texttt{x} and \texttt{y} to be of any subtypes of \texttt{T}. So variables that occur in invariant position are never considered diagonal. This choice of behavior is slightly controversial –- some feel this definition should be written as




\begin{minted}{julia}
f(a::Array{T}, x::S, y::S) where {T, S<:T} = ...
\end{minted}



to clarify whether \texttt{x} and \texttt{y} need to have the same type. In this version of the signature they would, or we could introduce a third variable for the type of \texttt{y} if \texttt{x} and \texttt{y} can have different types.



The next complication is the interaction of unions and diagonal variables, e.g.




\begin{minted}{julia}
f(x::Union{Void,T}, y::T) where {T} = ...
\end{minted}



Consider what this declaration means. \texttt{y} has type \texttt{T}. \texttt{x} then can have either the same type \texttt{T}, or else be of type \texttt{Void}. So all of the following calls should match:




\begin{minted}{julia}
f(1, 1)
f("", "")
f(2.0, 2.0)
f(nothing, 1)
f(nothing, "")
f(nothing, 2.0)
\end{minted}



These examples are telling us something: when \texttt{x} is \texttt{nothing::Void}, there are no extra constraints on \texttt{y}. It is as if the method signature had \texttt{y::Any}. This means that whether a variable is diagonal is not a static property based on where it appears in a type. Rather, it depends on where a variable appears when the subtyping algorithm \emph{uses} it. When \texttt{x} has type \texttt{Void}, we don{\textquotesingle}t need to use the \texttt{T} in \texttt{Union\{Void,T\}}, so \texttt{T} does not {\textquotedbl}occur{\textquotedbl}. Indeed, we have the following type equivalence:




\begin{minted}{julia}
(Tuple{Union{Void,T},T} where T) == Union{Tuple{Void,Any}, Tuple{T,T} where T}
\end{minted}



\hypertarget{12600482412457091491}{}


\subsection{Subtyping diagonal variables}



The subtyping algorithm for diagonal variables has two components: (1) identifying variable occurrences, and (2) ensuring that diagonal variables range over concrete types only.



The first task is accomplished by keeping counters \texttt{occurs\_inv} and \texttt{occurs\_cov} (in \texttt{src/subtype.c}) for each variable in the environment, tracking the number of invariant and covariant occurrences, respectively. A variable is diagonal when \texttt{occurs\_inv == 0 \&\& occurs\_cov > 1}.



The second task is accomplished by imposing a condition on a variable{\textquotesingle}s lower bound. As the subtyping algorithm runs, it narrows the bounds of each variable (raising lower bounds and lowering upper bounds) to keep track of the range of variable values for which the subtype relation would hold. When we are done evaluating the body of a \texttt{UnionAll} type whose variable is diagonal, we look at the final values of the bounds. Since the variable must be concrete, a contradiction occurs if its lower bound could not be a subtype of a concrete type. For example, an abstract type like \hyperlink{6514416309183787338}{\texttt{AbstractArray}} cannot be a subtype of a concrete type, but a concrete type like \texttt{Int} can be, and the empty type \texttt{Bottom} can be as well. If a lower bound fails this test the algorithm stops with the answer \texttt{false}.



For example, in the problem \texttt{Tuple\{Int,String\} <: Tuple\{T,T\} where T}, we derive that this would be true if \texttt{T} were a supertype of \texttt{Union\{Int,String\}}. However, \texttt{Union\{Int,String\}} is an abstract type, so the relation does not hold.



This concreteness test is done by the function \texttt{is\_leaf\_bound}. Note that this test is slightly different from \texttt{jl\_is\_leaf\_type}, since it also returns \texttt{true} for \texttt{Bottom}. Currently this function is heuristic, and does not catch all possible concrete types. The difficulty is that whether a lower bound is concrete might depend on the values of other type variable bounds. For example, \texttt{Vector\{T\}} is equivalent to the concrete type \texttt{Vector\{Int\}} only if both the upper and lower bounds of \texttt{T} equal \texttt{Int}. We have not yet worked out a complete algorithm for this.



\hypertarget{37604590457653524}{}


\subsection{Introduction to the internal machinery}



Most operations for dealing with types are found in the files \texttt{jltypes.c} and \texttt{subtype.c}. A good way to start is to watch subtyping in action. Build Julia with \texttt{make debug} and fire up Julia within a debugger. \hyperlink{10298426124440583682}{gdb debugging tips} has some tips which may be useful.



Because the subtyping code is used heavily in the REPL itself–and hence breakpoints in this code get triggered often–it will be easiest if you make the following definition:




\begin{minted}{jlcon}
julia> function mysubtype(a,b)
           ccall(:jl_breakpoint, Void, (Any,), nothing)
           issubtype(a, b)
       end
\end{minted}



and then set a breakpoint in \texttt{jl\_breakpoint}.  Once this breakpoint gets triggered, you can set breakpoints in other functions.



As a warm-up, try the following:




\begin{minted}{julia}
mysubtype(Tuple{Int,Float64}, Tuple{Integer,Real})
\end{minted}



We can make it more interesting by trying a more complex case:




\begin{minted}{julia}
mysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)
\end{minted}



\hypertarget{9271541181781970079}{}


\subsection{Subtyping and method sorting}



The \texttt{type\_morespecific} functions are used for imposing a partial order on functions in method tables (from most-to-least specific). Specificity is strict; if \texttt{a} is more specific than \texttt{b}, then \texttt{a} does not equal \texttt{b} and \texttt{b} is not more specific than \texttt{a}.



If \texttt{a} is a strict subtype of \texttt{b}, then it is automatically considered more specific. From there, \texttt{type\_morespecific} employs some less formal rules. For example, \texttt{subtype} is sensitive to the number of arguments, but \texttt{type\_morespecific} may not be. In particular, \texttt{Tuple\{Int,AbstractFloat\}} is more specific than \texttt{Tuple\{Integer\}}, even though it is not a subtype.  (Of \texttt{Tuple\{Int,AbstractFloat\}} and \texttt{Tuple\{Integer,Float64\}}, neither is more specific than the other.)  Likewise, \texttt{Tuple\{Int,Vararg\{Int\}\}} is not a subtype of \texttt{Tuple\{Integer\}}, but it is considered more specific. However, \texttt{morespecific} does get a bonus for length: in particular, \texttt{Tuple\{Int,Int\}} is more specific than \texttt{Tuple\{Int,Vararg\{Int\}\}}.



If you{\textquotesingle}re debugging how methods get sorted, it can be convenient to define the function:




\begin{minted}{julia}
type_morespecific(a, b) = ccall(:jl_type_morespecific, Cint, (Any,Any), a, b)
\end{minted}



which allows you to test whether tuple type \texttt{a} is more specific than tuple type \texttt{b}.



\hypertarget{11666441878855849549}{}


\section{Memory layout of Julia Objects}



\hypertarget{9050896398576860708}{}


\subsection{Object layout (jl\_value\_t)}



The \texttt{jl\_value\_t} struct is the name for a block of memory owned by the Julia Garbage Collector, representing the data associated with a Julia object in memory. Absent any type information, it is simply an opaque pointer:




\begin{lstlisting}
typedef struct jl_value_t* jl_pvalue_t;
\end{lstlisting}



Each \texttt{jl\_value\_t} struct is contained in a \texttt{jl\_typetag\_t} struct that contains metadata information about the Julia object, such as its type and garbage collector (gc) reachability:




\begin{lstlisting}
typedef struct {
    opaque metadata;
    jl_value_t value;
} jl_typetag_t;
\end{lstlisting}



The type of any Julia object is an instance of a leaf \texttt{jl\_datatype\_t} object. The \texttt{jl\_typeof()} function can be used to query for it:




\begin{lstlisting}
jl_value_t *jl_typeof(jl_value_t *v);
\end{lstlisting}



The layout of the object depends on its type. Reflection methods can be used to inspect that layout. A field can be accessed by calling one of the get-field methods:




\begin{lstlisting}
jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);
jl_value_t *jl_get_field(jl_value_t *o, char *fld);
\end{lstlisting}



If the field types are known, a priori, to be all pointers, the values can also be extracted directly as an array access:




\begin{lstlisting}
jl_value_t *v = value->fieldptr[n];
\end{lstlisting}



As an example, a {\textquotedbl}boxed{\textquotedbl} \texttt{uint16\_t} is stored as follows:




\begin{lstlisting}
struct {
    opaque metadata;
    struct {
        uint16_t data;        // -- 2 bytes
    } jl_value_t;
};
\end{lstlisting}



This object is created by \texttt{jl\_box\_uint16()}. Note that the \texttt{jl\_value\_t} pointer references the data portion, not the metadata at the top of the struct.



A value may be stored {\textquotedbl}unboxed{\textquotedbl} in many circumstances (just the data, without the metadata, and possibly not even stored but just kept in registers), so it is unsafe to assume that the address of a box is a unique identifier. The {\textquotedbl}egal{\textquotedbl} test (corresponding to the \texttt{===} function in Julia), should instead be used to compare two unknown objects for equivalence:




\begin{lstlisting}
int jl_egal(jl_value_t *a, jl_value_t *b);
\end{lstlisting}



This optimization should be relatively transparent to the API, since the object will be {\textquotedbl}boxed{\textquotedbl} on-demand, whenever a \texttt{jl\_value\_t} pointer is needed.



Note that modification of a \texttt{jl\_value\_t} pointer in memory is permitted only if the object is mutable. Otherwise, modification of the value may corrupt the program and the result will be undefined. The mutability property of a value can be queried for with:




\begin{lstlisting}
int jl_is_mutable(jl_value_t *v);
\end{lstlisting}



If the object being stored is a \texttt{jl\_value\_t}, the Julia garbage collector must be notified also:




\begin{lstlisting}
void jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);
\end{lstlisting}



However, the \hyperlink{7688715278401899796}{Embedding Julia} section of the manual is also required reading at this point, for covering other details of boxing and unboxing various types, and understanding the gc interactions.



Mirror structs for some of the built-in types are \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{defined in \texttt{julia.h}}. The corresponding global \texttt{jl\_datatype\_t} objects are created by \href{https://github.com/JuliaLang/julia/blob/master/src/jltypes.c}{\texttt{jl\_init\_types} in \texttt{jltypes.c}}.



\hypertarget{660883080955975432}{}


\subsection{Garbage collector mark bits}



The garbage collector uses several bits from the metadata portion of the \texttt{jl\_typetag\_t} to track each object in the system. Further details about this algorithm can be found in the comments of the \href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{garbage collector implementation in \texttt{gc.c}}.



\hypertarget{14420252243983980472}{}


\subsection{Object allocation}



Most new objects are allocated by \texttt{jl\_new\_structv()}:




\begin{lstlisting}
jl_value_t *jl_new_struct(jl_datatype_t *type, ...);
jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);
\end{lstlisting}



Although, \hyperlink{12980593021531333073}{\texttt{isbits}} objects can be also constructed directly from memory:




\begin{lstlisting}
jl_value_t *jl_new_bits(jl_value_t *bt, void *data)
\end{lstlisting}



And some objects have special constructors that must be used instead of the above functions:



Types:




\begin{lstlisting}
jl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);
jl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);
jl_uniontype_t *jl_new_uniontype(jl_tuple_t *types);
\end{lstlisting}



While these are the most commonly used options, there are more low-level constructors too, which you can find declared in \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{\texttt{julia.h}}. These are used in \texttt{jl\_init\_types()} to create the initial types needed to bootstrap the creation of the Julia system image.



Tuples:




\begin{lstlisting}
jl_tuple_t *jl_tuple(size_t n, ...);
jl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);
jl_tuple_t *jl_alloc_tuple(size_t n);
\end{lstlisting}



The representation of tuples is highly unique in the Julia object representation ecosystem. In some cases, a \hyperlink{12342862450082530092}{\texttt{Base.tuple()}} object may be an array of pointers to the objects contained by the tuple equivalent to:




\begin{lstlisting}
typedef struct {
    size_t length;
    jl_value_t *data[length];
} jl_tuple_t;
\end{lstlisting}



However, in other cases, the tuple may be converted to an anonymous \hyperlink{12980593021531333073}{\texttt{isbits}} type and stored unboxed, or it may not stored at all (if it is not being used in a generic context as a \texttt{jl\_value\_t*}).



Symbols:




\begin{lstlisting}
jl_sym_t *jl_symbol(const char *str);
\end{lstlisting}



Functions and MethodInstance:




\begin{lstlisting}
jl_function_t *jl_new_generic_function(jl_sym_t *name);
jl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);
\end{lstlisting}



Arrays:




\begin{lstlisting}
jl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);
jl_array_t *jl_new_arrayv(jl_value_t *atype, ...);
jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);
jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr, size_t nc);
jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr, size_t nc, size_t z);
jl_array_t *jl_alloc_vec_any(size_t n);
\end{lstlisting}



Note that many of these have alternative allocation functions for various special-purposes. The list here reflects the more common usages, but a more complete list can be found by reading the \href{https://github.com/JuliaLang/julia/blob/master/src/julia.h}{\texttt{julia.h} header file}.



Internal to Julia, storage is typically allocated by \texttt{newstruct()} (or \texttt{newobj()} for the special types):




\begin{lstlisting}
jl_value_t *newstruct(jl_value_t *type);
jl_value_t *newobj(jl_value_t *type, size_t nfields);
\end{lstlisting}



And at the lowest level, memory is getting allocated by a call to the garbage collector (in \texttt{gc.c}), then tagged with its type:




\begin{lstlisting}
jl_value_t *jl_gc_allocobj(size_t nbytes);
void jl_set_typeof(jl_value_t *v, jl_datatype_t *type);
\end{lstlisting}



Note that all objects are allocated in multiples of 4 bytes and aligned to the platform pointer size. Memory is allocated from a pool for smaller objects, or directly with \texttt{malloc()} for large objects.



\begin{quote}
\textbf{Singleton Types}

Singleton types have only one instance and no data fields. Singleton instances have a size of 0 bytes, and consist only of their metadata. e.g. \texttt{nothing::Void}.

See \hyperlink{647919389478144252}{Singleton Types} and \hyperlink{259296306383383012}{Nothingness and missing values}

\end{quote}


\hypertarget{2565512592221324751}{}


\section{Eval of Julia code}



One of the hardest parts about learning how the Julia Language runs code is learning how all of the pieces work together to execute a block of code.



Each chunk of code typically makes a trip through many steps with potentially unfamiliar names, such as (in no particular order): flisp, AST, C++, LLVM, \texttt{eval}, \texttt{typeinf}, \texttt{macroexpand}, sysimg (or system image), bootstrapping, compile, parse, execute, JIT, interpret, box, unbox, intrinsic function, and primitive function, before turning into the desired result (hopefully).



\begin{quote}
\textbf{Definitions}

\begin{itemize}
\item REPL

REPL stands for Read-Eval-Print Loop. It{\textquotesingle}s just what we call the command line environment for short.


\item AST

Abstract Syntax Tree The AST is the digital representation of the code structure. In this form the code has been tokenized for meaning so that it is more suitable for manipulation and execution.

\end{itemize}
\end{quote}


\hypertarget{12349293482799060845}{}


\subsection{Julia Execution}



The 10,000 foot view of the whole process is as follows:



\begin{itemize}
\item[1.  ] The user starts \texttt{julia}.


\item[2.  ] The C function \texttt{main()} from \texttt{ui/repl.c} gets called. This function processes the command line arguments, filling in the \texttt{jl\_options} struct and setting the variable \texttt{ARGS}. It then initializes Julia (by calling \href{https://github.com/JuliaLang/julia/blob/master/src/task.c}{\texttt{julia\_init} in \texttt{task.c}}, which may load a previously compiled \hyperlink{9959120445934014648}{sysimg}). Finally, it passes off control to Julia by calling \href{https://github.com/JuliaLang/julia/blob/master/base/client.jl}{\texttt{Base.\_start()}}.


\item[3.  ] When \texttt{\_start()} takes over control, the subsequent sequence of commands depends on the command line arguments given. For example, if a filename was supplied, it will proceed to execute that file. Otherwise, it will start an interactive REPL.


\item[4.  ] Skipping the details about how the REPL interacts with the user, let{\textquotesingle}s just say the program ends up with a block of code that it wants to run.


\item[5.  ] If the block of code to run is in a file, \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_load(char *filename)}} gets invoked to load the file and \hyperlink{6801832859572424777}{parse} it. Each fragment of code is then passed to \texttt{eval} to execute.


\item[6.  ] Each fragment of code (or AST), is handed off to \hyperlink{2345597220715550879}{\texttt{eval()}} to turn into results.


\item[7.  ] \hyperlink{2345597220715550879}{\texttt{eval()}} takes each code fragment and tries to run it in \href{https://github.com/JuliaLang/julia/blob/master/src/toplevel.c}{\texttt{jl\_toplevel\_eval\_flex()}}.


\item[8.  ] \texttt{jl\_toplevel\_eval\_flex()} decides whether the code is a {\textquotedbl}toplevel{\textquotedbl} action (such as \texttt{using} or \texttt{module}), which would be invalid inside a function. If so, it passes off the code to the toplevel interpreter.


\item[9.  ] \texttt{jl\_toplevel\_eval\_flex()} then \hyperlink{13925460440315781353}{expands} the code to eliminate any macros and to {\textquotedbl}lower{\textquotedbl} the AST to make it simpler to execute.


\item[10. ] \texttt{jl\_toplevel\_eval\_flex()} then uses some simple heuristics to decide whether to JIT compiler the  AST or to interpret it directly.


\item[11. ] The bulk of the work to interpret code is handled by \href{https://github.com/JuliaLang/julia/blob/master/src/interpreter.c}{\texttt{eval} in \texttt{interpreter.c}}.


\item[12. ] If instead, the code is compiled, the bulk of the work is handled by \texttt{codegen.cpp}. Whenever a  Julia function is called for the first time with a given set of argument types, \hyperlink{5553247398724394157}{type inference}  will be run on that function. This information is used by the \hyperlink{16251221274618963128}{codegen} step to generate  faster code.


\item[13. ] Eventually, the user quits the REPL, or the end of the program is reached, and the \texttt{\_start()}  method returns.


\item[14. ] Just before exiting, \texttt{main()} calls \href{https://github.com/JuliaLang/julia/blob/master/src/init.c}{\texttt{jl\_atexit\_hook(exit\_code)}}.  This calls \texttt{Base.\_atexit()} (which calls any functions registered to \hyperlink{17479944696971324992}{\texttt{atexit()}} inside  Julia). Then it calls \href{https://github.com/JuliaLang/julia/blob/master/src/gc.c}{\texttt{jl\_gc\_run\_all\_finalizers()}}.  Finally, it gracefully cleans up all \texttt{libuv} handles and waits for them to flush and close.

\end{itemize}


\hypertarget{6801832859572424777}{}


\subsection{Parsing}



The Julia parser is a small lisp program written in femtolisp, the source-code for which is distributed inside Julia in \href{https://github.com/JuliaLang/julia/tree/master/src/flisp}{src/flisp}.



The interface functions for this are primarily defined in \href{https://github.com/JuliaLang/julia/blob/master/src/jlfrontend.scm}{\texttt{jlfrontend.scm}}. The code in \href{https://github.com/JuliaLang/julia/blob/master/src/ast.c}{\texttt{ast.c}} handles this handoff on the Julia side.



The other relevant files at this stage are \href{https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm}{\texttt{julia-parser.scm}}, which handles tokenizing Julia code and turning it into an AST, and \href{https://github.com/JuliaLang/julia/blob/master/src/julia-syntax.scm}{\texttt{julia-syntax.scm}}, which handles transforming complex AST representations into simpler, {\textquotedbl}lowered{\textquotedbl} AST representations which are more suitable for analysis and execution.



\hypertarget{13925460440315781353}{}


\subsection{Macro Expansion}



When \hyperlink{2345597220715550879}{\texttt{eval()}} encounters a macro, it expands that AST node before attempting to evaluate the expression. Macro expansion involves a handoff from \hyperlink{2345597220715550879}{\texttt{eval()}} (in Julia), to the parser function \texttt{jl\_macroexpand()} (written in \texttt{flisp}) to the Julia macro itself (written in - what else - Julia) via \texttt{fl\_invoke\_julia\_macro()}, and back.



Typically, macro expansion is invoked as a first step during a call to \hyperlink{14846157655101111909}{\texttt{expand()}}/\texttt{jl\_expand()}, although it can also be invoked directly by a call to \hyperlink{8018172489611994488}{\texttt{macroexpand()}}/\texttt{jl\_macroexpand()}.



\hypertarget{5553247398724394157}{}


\subsection{Type Inference}



Type inference is implemented in Julia by \href{https://github.com/JuliaLang/julia/blob/master/base/inference.jl}{\texttt{typeinf()} in \texttt{inference.jl}}. Type inference is the process of examining a Julia function and determining bounds for the types of each of its variables, as well as bounds on the type of the return value from the function. This enables many future optimizations, such as unboxing of known immutable values, and compile-time hoisting of various run-time operations such as computing field offsets and function pointers. Type inference may also include other steps such as constant propagation and inlining.



\begin{quote}
\textbf{More Definitions}

\begin{itemize}
\item JIT

Just-In-Time Compilation The process of generating native-machine code into memory right when it is needed.


\item LLVM

Low-Level Virtual Machine (a compiler) The Julia JIT compiler is a program/library called libLLVM. Codegen in Julia refers both to the process of taking a Julia AST and turning it into LLVM instructions, and the process of LLVM optimizing that and turning it into native assembly instructions.


\item C++

The programming language that LLVM is implemented in, which means that codegen is also implemented in this language. The rest of Julia{\textquotesingle}s library is implemented in C, in part because its smaller feature set makes it more usable as a cross-language interface layer.


\item box

This term is used to describe the process of taking a value and allocating a wrapper around the data that is tracked by the garbage collector (gc) and is tagged with the object{\textquotesingle}s type.


\item unbox

The reverse of boxing a value. This operation enables more efficient manipulation of data when the type of that data is fully known at compile-time (through type inference).


\item generic function

A Julia function composed of multiple {\textquotedbl}methods{\textquotedbl} that are selected for dynamic dispatch based on the argument type-signature


\item anonymous function or {\textquotedbl}method{\textquotedbl}

A Julia function without a name and without type-dispatch capabilities


\item primitive function

A function implemented in C but exposed in Julia as a named function {\textquotedbl}method{\textquotedbl} (albeit without generic function dispatch capabilities, similar to a anonymous function)


\item intrinsic function

A low-level operation exposed as a function in Julia. These pseudo-functions implement operations on raw bits such as add and sign extend that cannot be expressed directly in any other way. Since they operate on bits directly, they must be compiled into a function and surrounded by a call to \texttt{Core.Intrinsics.box(T, ...)} to reassign type information to the value.

\end{itemize}
\end{quote}


\hypertarget{16251221274618963128}{}


\subsection{JIT Code Generation}



Codegen is the process of turning a Julia AST into native machine code.



The JIT environment is initialized by an early call to \href{https://github.com/JuliaLang/julia/blob/master/src/codegen.cpp}{\texttt{jl\_init\_codegen} in \texttt{codegen.cpp}}.



On demand, a Julia method is converted into a native function by the function \texttt{emit\_function(jl\_method\_instance\_t*)}. (note, when using the MCJIT (in LLVM v3.4+), each function must be JIT into a new module.) This function recursively calls \texttt{emit\_expr()} until the entire function has been emitted.



Much of the remaining bulk of this file is devoted to various manual optimizations of specific code patterns. For example, \texttt{emit\_known\_call()} knows how to inline many of the primitive functions (defined in \href{https://github.com/JuliaLang/julia/blob/master/src/builtins.c}{\texttt{builtins.c}}) for various combinations of argument types.



Other parts of codegen are handled by various helper files:



\begin{itemize}
\item \href{https://github.com/JuliaLang/julia/blob/master/src/debuginfo.cpp}{\texttt{debuginfo.cpp}}

Handles backtraces for JIT functions


\item \href{https://github.com/JuliaLang/julia/blob/master/src/ccall.cpp}{\texttt{ccall.cpp}}

Handles the ccall and llvmcall FFI, along with various \texttt{abi\_*.cpp} files


\item \href{https://github.com/JuliaLang/julia/blob/master/src/intrinsics.cpp}{\texttt{intrinsics.cpp}}

Handles the emission of various low-level intrinsic functions

\end{itemize}


\begin{quote}
\textbf{Bootstrapping}

The process of creating a new system image is called {\textquotedbl}bootstrapping{\textquotedbl}.

The etymology of this word comes from the phrase {\textquotedbl}pulling oneself up by the bootstraps{\textquotedbl}, and refers to the idea of starting from a very limited set of available functions and definitions and ending with the creation of a full-featured environment.

\end{quote}


\hypertarget{9959120445934014648}{}


\subsection{System Image}



The system image is a precompiled archive of a set of Julia files. The \texttt{sys.ji} file distributed with Julia is one such system image, generated by executing the file \href{https://github.com/JuliaLang/julia/blob/master/base/sysimg.jl}{\texttt{sysimg.jl}}, and serializing the resulting environment (including Types, Functions, Modules, and all other defined values) into a file. Therefore, it contains a frozen version of the \texttt{Main}, \texttt{Core}, and \texttt{Base} modules (and whatever else was in the environment at the end of bootstrapping). This serializer/deserializer is implemented by \href{https://github.com/JuliaLang/julia/blob/master/src/dump.c}{\texttt{jl\_save\_system\_image}/\texttt{jl\_restore\_system\_image} in \texttt{dump.c}}.



If there is no sysimg file (\texttt{jl\_options.image\_file == NULL}), this also implies that \texttt{--build} was given on the command line, so the final result should be a new sysimg file. During Julia initialization, minimal \texttt{Core} and \texttt{Main} modules are created. Then a file named \texttt{boot.jl} is evaluated from the current directory. Julia then evaluates any file given as a command line argument until it reaches the end. Finally, it saves the resulting environment to a {\textquotedbl}sysimg{\textquotedbl} file for use as a starting point for a future Julia run.



\hypertarget{3417049897160160290}{}


\section{Calling Conventions}



Julia uses three calling conventions for four distinct purposes:




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
Name & Prefix & Purpose \\
\hline
Native & \texttt{julia\_} & Speed via specialized signatures \\
\hline
JL Call & \texttt{jlcall\_} & Wrapper for generic calls \\
\hline
JL Call & \texttt{jl\_} & Builtins \\
\hline
C ABI & \texttt{jlcapi\_} & Wrapper callable from C \\
\hline
\end{tabulary}

\end{table}



\hypertarget{4788166660204734834}{}


\subsection{Julia Native Calling Convention}



The native calling convention is designed for fast non-generic calls. It usually uses a specialized signature.



\begin{itemize}
\item LLVM ghosts (zero-length types) are omitted.


\item LLVM scalars and vectors are passed by value.


\item LLVM aggregates (arrays and structs) are passed by reference.

\end{itemize}


A small return values is returned as LLVM return values. A large return values is returned via the {\textquotedbl}structure return{\textquotedbl} (\texttt{sret}) convention, where the caller provides a pointer to a return slot.



An argument or return values thta is a homogeneous tuple is sometimes represented as an LLVM vector instead of an LLVM array.



\hypertarget{10962628785392118342}{}


\subsection{JL Call Convention}



The JL Call convention is for builtins and generic dispatch. Hand-written functions using this convention are declared via the macro \texttt{JL\_CALLABLE}. The convention uses exactly 3 parameters:



\begin{itemize}
\item \texttt{F}  - Julia representation of function that is being applied


\item \texttt{args} - pointer to array of pointers to boxes


\item \texttt{nargs} - length of the array

\end{itemize}


The return value is a pointer to a box.



\hypertarget{16764615067045412370}{}


\subsection{C ABI}



C ABI wrappers enable calling Julia from C. The wrapper calls a function using the native calling convention.



Tuples are always represented as C arrays.



\hypertarget{2265182675689203812}{}


\section{High-level Overview of the Native-Code Generation Process}



\hypertarget{6164157073495091365}{}


\subsection{Representation of Pointers}



When emitting code to an object file, pointers will be emitted as relocations. The deserialization code will ensure any object that pointed to one of these constants gets recreated and contains the right runtime pointer.



Otherwise, they will be emitted as literal constants.



To emit one of these objects, call \texttt{literal\_pointer\_val}. It{\textquotesingle}ll handle tracking the Julia value and the LLVM global, ensuring they are valid both for the current runtime and after deserialization.



When emitted into the object file, these globals are stored as references in a large \texttt{gvals} table. This allows the deserializer to reference them by index, and implement a custom manual mechanism similar to a Global Offset Table (GOT) to restore them.



Function pointers are handled similarly. They are stored as values in a large \texttt{fvals} table. Like globals, this allows the deserializer to reference them by index.



Note that \texttt{extern} functions are handled separately, with names, via the usual symbol resolution mechanism in the linker.



Note too that \texttt{ccall} functions are also handled separately, via a manual GOT and Procedure Linkage Table (PLT).



\hypertarget{9352283582715079729}{}


\subsection{Representation of Intermediate Values}



Values are passed around in a \texttt{jl\_cgval\_t} struct. This represents an R-value, and includes enough information to determine how to assign or pass it somewhere.



They are created via one of the helper constructors, usually: \texttt{mark\_julia\_type} (for immediate values) and \texttt{mark\_julia\_slot} (for pointers to values).



The function \texttt{convert\_julia\_type} can transform between any two types. It returns an R-value with \texttt{cgval.typ} set to \texttt{typ}. It{\textquotesingle}ll cast the object to the requested representation, making heap boxes, allocating stack copies, and computing tagged unions as needed to change the representation.



By contrast \texttt{update\_julia\_type} will change \texttt{cgval.typ} to \texttt{typ}, only if it can be done at zero-cost (i.e. without emitting any code).



\hypertarget{3738811278233217209}{}


\subsection{Union representation}



Inferred union types may be stack allocated via a tagged type representation.



The primitive routines that need to be able to handle tagged unions are:



\begin{itemize}
\item mark-type


\item load-local


\item store-local


\item isa


\item is


\item emit\_typeof


\item emit\_sizeof


\item boxed


\item unbox


\item specialized cc-ret

\end{itemize}


Everything else should be possible to handle in inference by using these primitives to implement union-splitting.



The representation of the tagged-union is as a pair of \texttt{< void* union, byte selector >}. The selector is fixed-size as \texttt{byte \& 0x7f}, and will union-tag the first 126 isbits. It records the one-based depth-first count into the type-union of the isbits objects inside. An index of zero indicates that the \texttt{union*} is actually a tagged heap-allocated \texttt{jl\_value\_t*}, and needs to be treated as normal for a boxed object rather than as a tagged union.



The high bit of the selector (\texttt{byte \& 0x80}) can be tested to determine if the \texttt{void*} is actually a heap-allocated (\texttt{jl\_value\_t*}) box, thus avoiding the cost of re-allocating a box, while maintaining the ability to efficiently handle union-splitting based on the low bits.



It is guaranteed that \texttt{byte \& 0x7f} is an exact test for the type, if the value can be represented by a tag – it will never be marked \texttt{byte = 0x80}. It is not necessary to also test the type-tag when testing \texttt{isa}.



The \texttt{union*} memory region may be allocated at \emph{any} size. The only constraint is that it is big enough to contain the data currently specified by \texttt{selector}. It might not be big enough to contain the union of all types that could be stored there according to the associated Union type field. Use appropriate care when copying.



\hypertarget{5801902447580234191}{}


\subsection{Specialized Calling Convention Signature Representation}



A \texttt{jl\_returninfo\_t} object describes the calling convention details of any callable.



If any of the arguments or return type of a method can be represented unboxed, and the method is not varargs, it{\textquotesingle}ll be given an optimized calling convention signature based on its \texttt{specTypes} and \texttt{rettype} fields.



The general principles are that:



\begin{itemize}
\item Primitive types get passed in int/float registers.


\item Tuples of VecElement types get passed in vector registers.


\item Structs get passed on the stack.


\item Return values are handle similarly to arguments, with a size-cutoff at which they will instead be returned via a hidden sret argument.

\end{itemize}


The total logic for this is implemented by \texttt{get\_specsig\_function} and \texttt{deserves\_sret}.



Additionally, if the return type is a union, it may be returned as a pair of values (a pointer and a tag). If the union values can be stack-allocated, then sufficient space to store them will also be passed as a hidden first argument. It is up to the callee whether the returned pointer will point to this space, a boxed object, or even other constant memory.



\hypertarget{10295868153719623313}{}


\section{Julia Functions}



This document will explain how functions, method definitions, and method tables work.



\hypertarget{791619394702824269}{}


\subsection{Method Tables}



Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of many definitions, or methods. The methods of a generic function are stored in a method table. Method tables (type \texttt{MethodTable}) are associated with \texttt{TypeName}s. A \texttt{TypeName} describes a family of parameterized types. For example \texttt{Complex\{Float32\}} and \texttt{Complex\{Float64\}} share the same \texttt{Complex} type name object.



All objects in Julia are potentially callable, because every object has a type, which in turn has a \texttt{TypeName}.



\hypertarget{5677321158644388515}{}


\subsection{Function calls}



Given the call \texttt{f(x,y)}, the following steps are performed: first, the method table to use is accessed as \texttt{typeof(f).name.mt}. Second, an argument tuple type is formed, \texttt{Tuple\{typeof(f), typeof(x), typeof(y)\}}. Note that the type of the function itself is the first element. This is because the type might have parameters, and so needs to take part in dispatch. This tuple type is looked up in the method table.



This dispatch process is performed by \texttt{jl\_apply\_generic}, which takes two arguments: a pointer to an array of the values f, x, and y, and the number of values (in this case 3).



Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept the function and arguments separately, and those that accept a single argument structure. In the first kind of API, the {\textquotedbl}arguments{\textquotedbl} part does \emph{not} contain information about the function, since that is passed separately. In the second kind of API, the function is the first element of the argument structure.



For example, the following function for performing a call accepts just an \texttt{args} pointer, so the first element of the args array will be the function to call:




\begin{lstlisting}
jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)
\end{lstlisting}



This entry point for the same functionality accepts the function separately, so the \texttt{args} array does not contain the function:




\begin{lstlisting}
jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);
\end{lstlisting}



\hypertarget{17618724806250544535}{}


\subsection{Adding methods}



Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the method. \texttt{jl\_method\_def} implements this operation. \texttt{jl\_first\_argument\_datatype} is called to extract the relevant method table from what would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument tuple type might be abstract. For example, we can define:




\begin{minted}{julia}
(::Union{Foo{Int},Foo{Int8}})(x) = 0
\end{minted}



which works since all possible matching methods would belong to the same method table.



\hypertarget{16014622082824674579}{}


\subsection{Creating generic functions}



Since every object is callable, nothing special is needed to create a generic function. Therefore \texttt{jl\_new\_generic\_function} simply creates a new singleton (0 size) subtype of \texttt{Function} and returns its instance. A function can have a mnemonic {\textquotedbl}display name{\textquotedbl} which is used in debug info and when printing objects. For example the name of \texttt{Base.sin} is \texttt{sin}. By convention, the name of the created \emph{type} is the same as the function name, with a \texttt{\#} prepended. So \texttt{typeof(sin)} is \texttt{Base.\#sin}.



\hypertarget{5087486620251640638}{}


\subsection{Closures}



A closure is simply a callable object with field names corresponding to captured variables. For example, the following code:




\begin{minted}{julia}
function adder(x)
    return y->x+y
end
\end{minted}



is lowered to (roughly):




\begin{minted}{julia}
struct ##1{T}
    x::T
end

(_::##1)(y) = _.x + y

function adder(x)
    return ##1(x)
end
\end{minted}



\hypertarget{3597362352537600414}{}


\subsection{Constructors}



A constructor call is just a call to a type. The type of most types is \texttt{DataType}, so the method table for \texttt{DataType} contains most constructor definitions. One wrinkle is the fallback definition that makes all types callable via \texttt{convert}:




\begin{minted}{julia}
(::Type{T}){T}(args...) = convert(T, args...)::T
\end{minted}



In this definition the function type is abstract, which is not normally supported. To make this work, all subtypes of \texttt{Type} (\texttt{Type}, \texttt{UnionAll}, \texttt{Union}, and \texttt{DataType}) currently share a method table via special arrangement.



\hypertarget{4994602509934264781}{}


\subsection{Builtins}



The {\textquotedbl}builtin{\textquotedbl} functions, defined in the \texttt{Core} module, are:




\begin{lstlisting}
=== typeof sizeof issubtype isa typeassert throw tuple getfield setfield! fieldtype
nfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply
_expr svec
\end{lstlisting}



These are all singleton objects whose types are subtypes of \texttt{Builtin}, which is a subtype of \texttt{Function}. Their purpose is to expose entry points in the run time that use the {\textquotedbl}jlcall{\textquotedbl} calling convention:




\begin{lstlisting}
jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)
\end{lstlisting}



The method tables of builtins are empty. Instead, they have a single catch-all method cache entry (\texttt{Tuple\{Vararg\{Any\}\}}) whose jlcall fptr points to the correct function. This is kind of a hack but works reasonably well.



\hypertarget{51534660369225743}{}


\subsection{Keyword arguments}



Keyword arguments work by associating a special, hidden function object with each method table that has definitions with keyword arguments. This function is called the {\textquotedbl}keyword argument sorter{\textquotedbl} or {\textquotedbl}keyword sorter{\textquotedbl}, or {\textquotedbl}kwsorter{\textquotedbl}, and is stored in the \texttt{kwsorter} field of \texttt{MethodTable} objects. Every definition in the kwsorter function has the same arguments as some definition in the normal method table, except with a single \texttt{Array} argument prepended. This array contains alternating symbols and values that represent the passed keyword arguments. The kwsorter{\textquotesingle}s job is to move keyword arguments into their canonical positions based on name, plus evaluate and substite any needed default value expressions. The result is a normal positional argument list, which is then passed to yet another function.



The easiest way to understand the process is to look at how a keyword argument method definition is lowered. The code:




\begin{minted}{julia}
function circle(center, radius; color = black, fill::Bool = true, options...)
    # draw
end
\end{minted}



actually produces \emph{three} method definitions. The first is a function that accepts all arguments (including keywords) as positional arguments, and includes the code for the method body. It has an auto-generated name:




\begin{minted}{julia}
function #circle#1(color, fill::Bool, options, circle, center, radius)
    # draw
end
\end{minted}



The second method is an ordinary definition for the original \texttt{circle} function, which handles the case where no keyword arguments are passed:




\begin{minted}{julia}
function circle(center, radius)
    #circle#1(black, true, Any[], circle, center, radius)
end
\end{minted}



This simply dispatches to the first method, passing along default values. Finally there is the kwsorter definition:




\begin{lstlisting}
function (::Core.kwftype(typeof(circle)))(kw::Array, circle, center, radius)
    options = Any[]
    color = arg associated with :color, or black if not found
    fill = arg associated with :fill, or true if not found
    # push remaining elements of kw into options array
    #circle#1(color, fill, options, circle, center, radius)
end
\end{lstlisting}



The front end generates code to loop over the \texttt{kw} array and pick out arguments in the right order, evaluating default expressions when an argument is not found.



The function \texttt{Core.kwftype(t)} fetches (and creates, if necessary) the field \texttt{t.name.mt.kwsorter}.



This design has the feature that call sites that don{\textquotesingle}t use keyword arguments require no special handling; everything works as if they were not part of the language at all. Call sites that do use keyword arguments are dispatched directly to the called function{\textquotesingle}s kwsorter. For example the call:




\begin{minted}{julia}
circle((0,0), 1.0, color = red; other...)
\end{minted}



is lowered to:




\begin{minted}{julia}
kwfunc(circle)(Any[:color,red,other...], circle, (0,0), 1.0)
\end{minted}



The unpacking procedure represented here as \texttt{other...} actually further unpacks each \emph{element} of \texttt{other}, expecting each one to contain two values (a symbol and a value). \texttt{kwfunc} (also in \texttt{Core}) fetches the kwsorter for the called function. Notice that the original \texttt{circle} function is passed through, to handle closures.



\hypertarget{13873351321632979877}{}


\subsection{Compiler efficiency issues}



Generating a new type for every function has potentially serious consequences for compiler resource use when combined with Julia{\textquotesingle}s {\textquotedbl}specialize on all arguments by default{\textquotedbl} design. Indeed, the initial implementation of this design suffered from much longer build and test times, higher memory use, and a system image nearly 2x larger than the baseline. In a naive implementation, the problem is bad enough to make the system nearly unusable. Several significant optimizations were needed to make the design practical.



The first issue is excessive specialization of functions for different values of function-valued arguments. Many functions simply {\textquotedbl}pass through{\textquotedbl} an argument to somewhere else, e.g. to another function or to a storage location. Such functions do not need to be specialized for every closure that might be passed in. Fortunately this case is easy to distinguish by simply considering whether a function \emph{calls} one of its arguments (i.e. the argument appears in {\textquotedbl}head position{\textquotedbl} somewhere). Performance-critical higher-order functions like \texttt{map} certainly call their argument function and so will still be specialized as expected. This optimization is implemented by recording which arguments are called during the \texttt{analyze-variables} pass in the front end. When \texttt{cache\_method} sees an argument in the \texttt{Function} type hierarchy passed to a slot declared as \texttt{Any} or \texttt{Function}, it pretends the slot was declared as \texttt{ANY} (the {\textquotedbl}don{\textquotesingle}t specialize{\textquotedbl} hint). This heuristic seems to be extremely effective in practice.



The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast majority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases can be resolved by considering only the first argument. (Aside: proponents of single dispatch would not be surprised by this at all. However, this argument means {\textquotedbl}multiple dispatch is easy to optimize in practice{\textquotedbl}, and that we should therefore use it, \emph{not} {\textquotedbl}we should use single dispatch{\textquotedbl}!) So the method cache uses the type of the first argument as its primary key. Note, however, that this corresponds to the \emph{second} element of the tuple type for a function call (the first element being the type of the function itself). Typically, type variation in head position is extremely low – indeed, the majority of functions belong to singleton types with no parameters. However, this is not the case for constructors, where a single method table holds constructors for every type. Therefore the \texttt{Type} method table is special-cased to use the \emph{first} tuple type element instead of the second.



The front end generates type declarations for all closures. Initially, this was implemented by generating normal type declarations. However, this produced an extremely large number of constructors, all of which were trivial (simply passing all arguments through to \texttt{new}). Since methods are partially ordered, inserting all of these methods is O(n{\textasciicircum}2), plus there are just too many of them to keep around. This was optimized by generating \texttt{composite\_type} expressions directly (bypassing default constructor generation), and using \texttt{new} directly to create closure instances. Not the prettiest thing ever, but you do what you gotta do.



The next problem was the \texttt{@test} macro, which generated a 0-argument closure for each test case. This is not really necessary, since each test case is simply run once in place. Therefore I modified \texttt{@test} to expand to a try-catch block that records the test result (true, false, or exception raised) and calls the test suite handler on it.



However this caused a new problem. When many tests are grouped together in a single function, e.g. a single top level expression, or some other test grouping function, that function could have a very large number of exception handlers. This triggered a kind of dataflow analysis worst case, where type inference spun around for minutes enumerating possible paths through the forest of handlers. This was fixed by simply bailing out of type inference when it encounters more than some number of handlers (currently 25). Presumably no performance-critical function will have more than 25 exception handlers. If one ever does, I{\textquotesingle}m willing to raise the limit to 26.



A minor issue occurs during the bootstrap process due to storing all constructors in a single method table. In the second bootstrap step, where \texttt{inference.ji} is compiled using \texttt{inference0.ji}, constructors for \texttt{inference0}{\textquotesingle}s types remain in the table, so there are still references to the old inference module and \texttt{inference.ji} is 2x the size it should be. This was fixed in \texttt{dump.c} by filtering definitions from {\textquotedbl}replaced modules{\textquotedbl} out of method tables and caches before saving a system image. A {\textquotedbl}replaced module{\textquotedbl} is one that satisfies the condition \texttt{m != jl\_get\_global(m->parent, m->name)} – in other words, some newer module has taken its name and place.



Another type inference worst case was triggered by the following code from the \href{https://github.com/JuliaMath/QuadGK.jl}{QuadGK.jl package}, formerly part of Base:




\begin{minted}{julia}
function do_quadgk(f, s, n, ::Type{Tw}, abstol, reltol, maxevals, nrm) where Tw
    if eltype(s) <: Real # check for infinite or semi-infinite intervals
        s1 = s[1]; s2 = s[end]; inf1 = isinf(s1); inf2 = isinf(s2)
        if inf1 || inf2
            if inf1 && inf2 # x = t/(1-t^2) coordinate transformation
                return do_quadgk(t -> begin t2 = t*t; den = 1 / (1 - t2);
                                            f(t*den) * (1+t2)*den*den; end,
                                 map(x -> isinf(x) ? copysign(one(x), x) : 2x / (1+hypot(1,2x)), s),
                                 n, Tw, abstol, reltol, maxevals, nrm)
            end
            s0,si = inf1 ? (s2,s1) : (s1,s2)
            if si < 0 # x = s0 - t/(1-t)
                return do_quadgk(t -> begin den = 1 / (1 - t);
                                            f(s0 - t*den) * den*den; end,
                                 reverse!(map(x -> 1 / (1 + 1 / (s0 - x)), s)),
                                 n, Tw, abstol, reltol, maxevals, nrm)
            else # x = s0 + t/(1-t)
                return do_quadgk(t -> begin den = 1 / (1 - t);
                                            f(s0 + t*den) * den*den; end,
                                 map(x -> 1 / (1 + 1 / (x - s0)), s),
                                 n, Tw, abstol, reltol, maxevals, nrm)
            end
        end
    end
\end{minted}



This code has a 3-way tail recursion, where each call wraps the current function argument \texttt{f} in a different new closure. Inference must consider 3{\textasciicircum}n (where n is the call depth) possible signatures. This blows up way too quickly, so logic was added to \texttt{typeinf\_uncached} to immediately widen any argument that is a subtype of \texttt{Function} and that grows in depth down the stack.



\hypertarget{10117343183210038440}{}


\section{Base.Cartesian}



El módulo \texttt{Cartesian} (no exportado) proporciona macros que facilitan escribir algoritmos multidimensionales. Es deseable que, a largo plazo, este módulo \texttt{Cartesian} no sea necesario; sin embargo, en la actualidad es una de las pocas formas de escribir código multidimensional compacto y con rendimiento.



\hypertarget{15280008707083756492}{}


\subsection{Principios de uso}



Un ejemplo de uso simple podría ser:




\begin{minted}{julia}
@nloops 3 i A begin
    s += @nref 3 A i
end
\end{minted}



que genera el siguiente código:




\begin{minted}{julia}
for i_3 = 1:size(A,3)
    for i_2 = 1:size(A,2)
        for i_1 = 1:size(A,1)
            s += A[i_1,i_2,i_3]
        end
    end
end
\end{minted}



En general, \texttt{Cartesian} permitirá escribir código que contiene elementos repetitivos, como los bucles anidados de este ejemplo. Otras aplicaciones incluyen expresiones repetidas (por ejemplo, desenrollado de bucles) o crear llamadas a función con números variables de argumentos sin usar la construcción {\textquotedbl}\emph{splat}{\textquotedbl} (\texttt{i...}).



\hypertarget{1420361062452440412}{}


\subsection{Sintaxis Básica}



La sintaxis básica de \texttt{@nloops} es la siguiente:



 * El primer argumento debe ser un entero (\emph{no} una variable) que especifica el número de bucles.   * El segundo argumento es el prefijo simbólico que se utilizará para la variable iteradora. De este modo, en el ejemplo anterior usamos \texttt{i}, y se generaron las variables  \texttt{i\_1, i\_2, i\_3}.   * El tercer argumento especifica el rango para cada variable iteradora. Si se usa una variable (símbolo) aquí, es considerado como \texttt{1:size(A,dim)}. De forma más flexible, se puede usar la sintaxis de expresiones basadas en funciones anónimas que se decribe más adelante.   * El último argumento es el cuerpo del bucle. En el ejemplo anterior, lo que aparece entre \texttt{begin...end}.



Hay otras características adicionales de \texttt{@nloops} descritas en la \hyperlink{908996570436533510}{sección de referencia}.



\texttt{@nref} sigue un patrn similar, generando \texttt{A[i\_1,i\_2,i\_3]} a partir de \texttt{@nref 3 A i}. La práctica general es leer de izquierda a derecha, por lo que \texttt{@nloops} es \texttt{@nloops 3 i A expr} (como en el bucle \texttt{for i\_2 = 1:size(A,2)}, donde \texttt{i\_2} está a la izquierda y el rango a la derecha) mientras que \texttt{@nref} es \texttt{@nref 3 A i} (como en \texttt{A[i\_1,i\_2,i\_3]}, donde el array va primero).



Si ests desarrollando código con Cartesian, puedes encontrar que depurar es más sencillo cuando examinas el código generado, usando \texttt{macroexpand}:






\begin{minted}{jlcon}
julia> macroexpand(:(@nref 2 A i))
:(A[i_1, i_2])
\end{minted}





\hypertarget{18123024058319139620}{}


\subsubsection{Proporcionando el número de expresiones}



El primer argumentos de estas dos macros es el número de expresiones, que debe ser un entero. Cuando estás escribiendo una funcin que pretendes que trabaje en múltiples dimensiones, esto puede no ser algo que desees codificar. Si estás escribiendo código que necesitas que trabaje con versiones antiguas de Julia, deberías usar la macro \texttt{@ngenerate} descrita en \href{https://docs.julialang.org/en/release-0.3/devdocs/cartesian/\#supplying-the-number-of-expressions}{una versión más antigua de esta documentación}.



Empezando en Julia 0.4-pre, el enfoque recomendado es usar una \texttt{@generated function}.  He aquí un ejemplo:




\begin{minted}{julia}
@generated function mysum(A::Array{T,N}) where {T,N}
    quote
        s = zero(T)
        @nloops $N i A begin
            s += @nref $N A i
        end
        s
    end
end
\end{minted}



Naturalmente, también podemos preparar expresiones o realizar cálculos antes del bloque \texttt{quote}.



\hypertarget{14061868401232608428}{}


\subsubsection{Expresiones función anónima como argumentos de macros}



Quizás la característica más potente de \texttt{Cartesian} es la capacidad de proporcionar expresiones función-anónima que son evaluadas en tiempo de análisis sintáctico. Consideremos un ejemplo sencillo:




\begin{minted}{julia}
@nexprs 2 j->(i_j = 1)
\end{minted}



\texttt{@nexprs} genera \texttt{n} expresiones que siguen un patrón. Este código generaría las siguientes instrucciones:




\begin{minted}{julia}
i_1 = 1
i_2 = 1
\end{minted}



En cada instrucción generada un \texttt{j} aislado (la variable de la función anónima) es reemplazada por valores en el rango \texttt{1:2}. Hablando de forma general, Cartesian emplea una sintaxis parecida a LaTeX. Esto te permite hacer operaciones sobre el índice \texttt{j}.  He aquí un ejemplo que calcula los pasos de un array:




\begin{minted}{julia}
s_1 = 1
@nexprs 3 j->(s_{j+1} = s_j * size(A, j))
\end{minted}



generará las expresiones




\begin{minted}{julia}
s_1 = 1
s_2 = s_1 * size(A, 1)
s_3 = s_2 * size(A, 2)
s_4 = s_3 * size(A, 3)
\end{minted}



Las expresiones función anónima tienen muchos usos en la práctica.



\hypertarget{908996570436533510}{}


\paragraph{Referencia de las Macros}


\hypertarget{4938945836201444124}{} 
\hyperlink{4938945836201444124}{\texttt{Base.Cartesian.@nloops}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nloops N itersym rangeexpr bodyexpr
@nloops N itersym rangeexpr preexpr bodyexpr
@nloops N itersym rangeexpr preexpr postexpr bodyexpr
\end{lstlisting}

Generate \texttt{N} nested loops, using \texttt{itersym} as the prefix for the iteration variables. \texttt{rangeexpr} may be an anonymous-function expression, or a simple symbol \texttt{var} in which case the range is \texttt{indices(var, d)} for dimension \texttt{d}.

Optionally, you can provide {\textquotedbl}pre{\textquotedbl} and {\textquotedbl}post{\textquotedbl} expressions. These get executed first and last, respectively, in the body of each loop. For example:


\begin{lstlisting}
@nloops 2 i A d -> j_d = min(i_d, 5) begin
    s += @nref 2 A j
end
\end{lstlisting}

would generate:


\begin{lstlisting}
for i_2 = indices(A, 2)
    j_2 = min(i_2, 5)
    for i_1 = indices(A, 1)
        j_1 = min(i_1, 5)
        s += A[j_1, j_2]
    end
end
\end{lstlisting}

If you want just a post-expression, supply \texttt{nothing} for the pre-expression. Using parentheses and semicolons, you can supply multi-statement expressions.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L9-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5318613607184308860}{} 
\hyperlink{5318613607184308860}{\texttt{Base.Cartesian.@nref}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nref N A indexexpr
\end{lstlisting}

Generate expressions like \texttt{A[i\_1, i\_2, ...]}. \texttt{indexexpr} can either be an iteration-symbol prefix, or an anonymous-function expression.


\begin{minted}{jlcon}
julia> @macroexpand Base.Cartesian.@nref 3 A i
:(A[i_1, i_2, i_3])
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L72-L82}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5592996802344748158}{} 
\hyperlink{5592996802344748158}{\texttt{Base.Cartesian.@nextract}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nextract N esym isym
\end{lstlisting}

Generate \texttt{N} variables \texttt{esym\_1}, \texttt{esym\_2}, ..., \texttt{esym\_N} to extract values from \texttt{isym}. \texttt{isym} can be either a \texttt{Symbol} or anonymous-function expression.

\texttt{@nextract 2 x y} would generate


\begin{lstlisting}
x_1 = y[1]
x_2 = y[2]
\end{lstlisting}

while \texttt{@nextract 3 x d->y[2d-1]} yields


\begin{lstlisting}
x_1 = y[1]
x_2 = y[3]
x_3 = y[5]
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L142-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17386123129446980507}{} 
\hyperlink{17386123129446980507}{\texttt{Base.Cartesian.@nexprs}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nexprs N expr
\end{lstlisting}

Generate \texttt{N} expressions. \texttt{expr} should be an anonymous-function expression.


\begin{minted}{jlcon}
julia> @macroexpand Base.Cartesian.@nexprs 4 i -> y[i] = A[i+j]
quote
    y[1] = A[1 + j]
    y[2] = A[2 + j]
    y[3] = A[3 + j]
    y[4] = A[4 + j]
end
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L118-L132}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16431416314224139891}{} 
\hyperlink{16431416314224139891}{\texttt{Base.Cartesian.@ncall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@ncall N f sym...
\end{lstlisting}

Generate a function call expression. \texttt{sym} represents any number of function arguments, the last of which may be an anonymous-function expression and is expanded into \texttt{N} arguments.

For example \texttt{@ncall 3 func a} generates


\begin{lstlisting}
func(a_1, a_2, a_3)
\end{lstlisting}

while \texttt{@ncall 2 func a b i->c[i]} yields


\begin{lstlisting}
func(a, b, c[1], c[2])
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L92-L106}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4425932542618492714}{} 
\hyperlink{4425932542618492714}{\texttt{Base.Cartesian.@ntuple}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@ntuple N expr
\end{lstlisting}

Generates an \texttt{N}-tuple. \texttt{@ntuple 2 i} would generate \texttt{(i\_1, i\_2)}, and \texttt{@ntuple 2 k->k+1} would generate \texttt{(2,3)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L215-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5463798602076286002}{} 
\hyperlink{5463798602076286002}{\texttt{Base.Cartesian.@nall}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nall N expr
\end{lstlisting}

Check whether all of the expressions generated by the anonymous-function expression \texttt{expr} evaluate to \texttt{true}.

\texttt{@nall 3 d->(i\_d > 1)} would generate the expression \texttt{(i\_1 > 1 \&\& i\_2 > 1 \&\& i\_3 > 1)}. This can be convenient for bounds-checking.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L174-L182}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11114957141394185901}{} 
\hyperlink{11114957141394185901}{\texttt{Base.Cartesian.@nany}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nany N expr
\end{lstlisting}

Check whether any of the expressions generated by the anonymous-function expression \texttt{expr} evaluate to \texttt{true}.

\texttt{@nany 3 d->(i\_d > 1)} would generate the expression \texttt{(i\_1 > 1 || i\_2 > 1 || i\_3 > 1)}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L195-L202}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2428714678347040919}{} 
\hyperlink{2428714678347040919}{\texttt{Base.Cartesian.@nif}}  -- {Macro.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
@nif N conditionexpr expr
@nif N conditionexpr expr elseexpr
\end{lstlisting}

Generates a sequence of \texttt{if ... elseif ... else ... end} statements. For example:


\begin{lstlisting}
@nif 3 d->(i_d >= size(A,d)) d->(error("Dimension ", d, " too big")) d->println("All OK")
\end{lstlisting}

would generate:


\begin{lstlisting}
if i_1 > size(A, 1)
    error("Dimension ", 1, " too big")
elseif i_2 > size(A, 2)
    error("Dimension ", 2, " too big")
else
    println("All OK")
end
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L230-L247}{\texttt{source}}


\end{adjustwidth}

\hypertarget{11367980138716686905}{}


\section{Talking to the compiler (the \texttt{:meta} mechanism)}



In some circumstances, one might wish to provide hints or instructions that a given block of code has special properties: you might always want to inline it, or you might want to turn on special compiler optimization passes.  Starting with version 0.4, Julia has a convention that these instructions can be placed inside a \texttt{:meta} expression, which is typically (but not necessarily) the first expression in the body of a function.



\texttt{:meta} expressions are created with macros. As an example, consider the implementation of the \texttt{@inline} macro:




\begin{minted}{julia}
macro inline(ex)
    esc(isa(ex, Expr) ? pushmeta!(ex, :inline) : ex)
end
\end{minted}



Here, \texttt{ex} is expected to be an expression defining a function. A statement like this:




\begin{minted}{julia}
@inline function myfunction(x)
    x*(x+3)
end
\end{minted}



gets turned into an expression like this:




\begin{minted}{julia}
quote
    function myfunction(x)
        Expr(:meta, :inline)
        x*(x+3)
    end
end
\end{minted}



\texttt{Base.pushmeta!(ex, :symbol, args...)} appends \texttt{:symbol} to the end of the \texttt{:meta} expression, creating a new \texttt{:meta} expression if necessary. If \texttt{args} is specified, a nested expression containing \texttt{:symbol} and these arguments is appended instead, which can be used to specify additional information.



To use the metadata, you have to parse these \texttt{:meta} expressions. If your implementation can be performed within Julia, \texttt{Base.popmeta!} is very handy: \texttt{Base.popmeta!(body, :symbol)} will scan a function \emph{body} expression (one without the function signature) for the first \texttt{:meta} expression containing \texttt{:symbol}, extract any arguments, and return a tuple \texttt{(found::Bool, args::Array\{Any\})}. If the metadata did not have any arguments, or \texttt{:symbol} was not found, the \texttt{args} array will be empty.



Not yet provided is a convenient infrastructure for parsing \texttt{:meta} expressions from C++.



\hypertarget{2417900207528599820}{}


\section{SubArrays}



El tipo \texttt{SubArray} de Julia es un contenedor que codifica una {\textquotedbl}vista{\textquotedbl} de un \hyperlink{6514416309183787338}{\texttt{AbstractArray}} padre.  Esta pagina documenta algunos de los principios de diseño e implementación de \texttt{SubArray}.



\hypertarget{15623661382317001704}{}


\subsection{Indexación: indexación cartesiana vs. lineal}



Ampliamente hablando, hay dos formas principales de acceder a los datos en un array. La primera, frecuentemente llamada indexación cartesiana, usa \texttt{N} índices para un \texttt{AbstractArray} \texttt{N} -dimensional. Por ejemlo, una matriz \texttt{A} (bidimensional) puede ser indexada en estilo cartesiano como \texttt{A[i,j]}. El segundo método de indexación, denominado indexación lineal, usa un solo índice incluso para objetos de mayor dimensión. Por ejemplo si \texttt{A = reshape(1:12, 3, 4)}, la expresión \texttt{A[5]} devuelve el valor 5. Julia nos permite combinar estos estilos de indexación: por ejemplo, un array 3d \texttt{A3} puede ser indexado como \texttt{A3[i,j]}, en cuyo caso \texttt{i} es interpretado como un índice cartesiano para la primera dimensión, y \texttt{j} es un índice lineal sobre las dimensiones 2 y 3.



Para los \texttt{Array}s, la indexación lineal apela al formato subyacente de almacenamiento: un array se presenta como un bloque contiguo de memoria, y por tanto el índice lineal es justo el desplazamiento (+1) de la correspondiente entrada relativa al principio del array. Sin embargo, esto no es cierto para muchos otros tipos \texttt{AbstractArray}: ejemplos de ello incluyen \hyperlink{14881587545161853413}{\texttt{SparseMatrixCSC}}, unos arrays que requieren alguna clase de cálculo (tal como interpolación), y el tipo bajo discusión aquí, \texttt{SubArray}. Para estos tipos, la información subyacente es descrita más naturalmente en términos de índices cartesianos. 



Uno puede convertir manualmente un índice cartesiano a uno lineal con \texttt{sub2ind}, y viceversa usando ìnd2sub\texttt{. Las funciones}getindex\texttt{and}setindex!\texttt{de los tipos}AbstractArray` puden incluir operaciones similares.



Aunque convertir de un índice cartesiano a uno lineal es rápido (es justo una multiplicación y una suma), convertir de un índice lineal a uno cartesiano es muy lento: se basa en la operación \texttt{div}, que es una de las operacions de bajo nivel más lentas que uno puede realizar con una CPU. Por esta razón, cualquier código que trate con tipos \texttt{AbstractArray} está mejor diseñado en términos de indexación cartesiana en lugar de lineal.



\hypertarget{17220314819735693845}{}


\subsection{Reemplazo de Índices}



Considere hacer rebanadas bidimensionales de un array tridimensional:




\begin{minted}{julia}
S1 = view(A, :, 5, 2:6)
S2 = view(A, 5, :, 2:6)
\end{minted}



\texttt{view} elimina las dimensiones {\textquotedbl}singleton{\textquotedbl} (las que están especificadas por un \texttt{Int}), por lo que tanto \texttt{S1} como \texttt{S2} son \texttt{SubArray}s bidimensionales. En consecuencia, el camino natural para indexar esto es con \texttt{S1[i,j]}. Para extraer el valor del array padre \texttt{A}, el enfoque natural es reemplazar \texttt{S1[i,j]} con \texttt{A[i,5,(2:6)[j]]} y \texttt{S2[i,j]} con \texttt{A[5,i,(2:6)[j]]}.



La característica clave del diseño de SubArrays es que este reemplazo de índices puede realizarse sin ninguna sobrecarga en tiempo de ejecución.



\hypertarget{18249743152079865904}{}


\subsection{Diseño de SubArray{\textquotesingle}s}



\hypertarget{14792009757059672765}{}


\subsubsection{Parámetros de Tipo y Campos}



La estrategia adoptada está expresada en la definición del tipo:




\begin{minted}{julia}
struct SubArray{T,N,P,I,L} <: AbstractArray{T,N}
    parent::P
    indexes::I
    offset1::Int       # for linear indexing and pointer, only valid when L==true
    stride1::Int       # used only for linear indexing
    ...
end
\end{minted}



\texttt{SubArray} tiene cinco parámetros de tipo. Los dos primeros son el tipo de elemento estándar y la dimensionalidad. La siguiente es el tipo del \texttt{AbstractArray} padre. El usado más intensamente es el cuarto parámetro, una \texttt{Tuple} de los tipos de los índices para cada dimensión. El final, \texttt{L},  es sólo proporcionado como una conveniencia para el despacho; es un valor booleano que representa si los tipos del índice soportan indexacion lineal rápida. Más sobre este tema después.  



Si en nuestro ejemplo de arriba \texttt{A} es un \texttt{Array\{Float64, 3\}}, nuestro caso \texttt{S1} sería un  \texttt{SubArray\{Int64,2,Array\{Int64,3\},Tuple\{Colon,Int64,UnitRange\{Int64\}\},false\}}. Note en particular el parámetro tupla, que almacena los tipos de los índices usados para crear \texttt{S1}.  Igualmente,




\begin{minted}{jlcon}
julia> S1.indexes
(Colon(),5,2:6)
\end{minted}



Almacenar estos valores permite el reemplzao de índices, y tener los tipos codificados como parámetros permite a uno despachar a eficientes algoritmos.



\hypertarget{17922439712142437324}{}


\subsubsection{Traducción de Índices}



Realizar la traducción de índices requiere que uno haga diferentes cosas para diferentes tipos concretos de \texttt{SubArray}. Por ejemplo, para \texttt{S1} uno necesita aplicar los índices \texttt{i,j} a las dimensiones primera y tercera del array padre, mientras que para \texttt{S2} uno necesita aplicarlas a la segunda y la tercera. El enfoque más sencillo a indexar sería hacer el análisis de tipos en tiempo de ejecución:




\begin{minted}{julia}
parentindexes = Array{Any}(0)
for thisindex in S.indexes
    ...
    if isa(thisindex, Int)
        # Don't consume one of the input indexes
        push!(parentindexes, thisindex)
    elseif isa(thisindex, AbstractVector)
        # Consume an input index
        push!(parentindexes, thisindex[inputindex[j]])
        j += 1
    elseif isa(thisindex, AbstractMatrix)
        # Consume two input indices
        push!(parentindexes, thisindex[inputindex[j], inputindex[j+1]])
        j += 2
    elseif ...
end
S.parent[parentindexes...]
\end{minted}



Desgraciadamente, esto sería desastroso en términos de rendimiento: cada acceso a elemento asignaría memoria, e implicaría la ejecución de un montón de código pobremente tipado.



El mejor enfoque es despachar a métodos específicos para manejar cada tipo de índice almacenado. Esto es lo que hace \texttt{reindex}: él despacha sobre el tipo del primer índice almacenado y consume el número apropiado de índices de entrada, y entonces recurre sobre los índices restantes. En el caso de \texttt{S1}, esto expande a




\begin{minted}{julia}
Base.reindex(S1, S1.indexes, (i, j)) == (i, S1.indexes[2], S1.indexes[3][j])
\end{minted}



para cualquier par de índices \texttt{(i,j)} (excepto \texttt{CartesianIndex}s and arrays de este tipo, ver abajo).



Este es el núcleo de un \texttt{SubArray}; los métodos de indexación se basan en \texttt{reindex} para hacer esta traducción de índices. Sin embargo, algunas veces, podemos evitar la indirección y hacerlo incluso más rápido.



\hypertarget{1218543499264087968}{}


\subsubsection{Indexación Lineal}



La indexación lineal puede implementarse de forma eficiente cuando el array completo tiene un solo paso que separe elementos sucesivos, empezando desde cierto desplazamiento. Esto significa que nosotros pre-computamos estos valores y representamos la indexación lineal simplemente como una adición y multiplicación, evitando la indirección de \texttt{reindex} y (lo que es más importante) la computación lenta de las coordenadas cartesianas por completo.



Para los tipos \texttt{SubArray}, la disponibilidad de una indexación lineal eficiente está basada puramente en los tipos de los índices, y no depende de valores como el tamaño de array padre. Uno puede preguntar si un cnjunto de índices dado soporta indexación lineal rápida con la función interna \texttt{Base.viewindexing}:




\begin{minted}{jlcon}
julia> Base.viewindexing(S1.indexes)
IndexCartesian()

julia> Base.viewindexing(S2.indexes)
IndexLinear()
\end{minted}



Esto se calcula durante la construcción del \texttt{SubArray} y se almacena en el parámetro de tipo \texttt{L} como un boolean que codifica soporte de indexación lineal rápido. Aunque n oes estrictamente necesario, esto significa qeu podemos definir despacho directamente sobre \texttt{SubArray\{T,N,A,I,true\}} sin intermediarios.



Como esta computación no depende de valores en tiempo de ejecución, puede perder algunos casos en los que el paso sea uniforme:




\begin{minted}{jlcon}
julia> A = reshape(1:4*2, 4, 2)
4×2 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5
 2  6
 3  7
 4  8

julia> diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 2
 2
\end{minted}



Una vista construída como \texttt{view(A, 2:2:4, :)} tiene un paso uniforme y, por tanto la indexación lineal podría llevarse a cabo eficientemente. Sin embargo, el éxito en este caso depende del tamaño del array: Si, a diferencia del caso anterior, la primera dimensión fuera impar,




\begin{minted}{jlcon}
julia> A = reshape(1:5*2, 5, 2)
5×2 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1   6
 2   7
 3   8
 4   9
 5  10

julia> diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 3
 2
\end{minted}



entonces \texttt{A[2:2:4,:]} no tiene un paso uniforme, por lo que no podemos garantizar indexación lineal eficiente. Como tenemos que basar esta decisión puramente en los tipos codificados en los parámetros del \texttt{SubArray}, \texttt{S = view(A, 2:2:4, :)} no puede implementar una indexación lienal eficiente.



\hypertarget{17772741150475392067}{}


\subsubsection{Unos pocos detalles}



\begin{itemize}
\item Note que la función \texttt{Base.reindex} es agnóstica a los tipos de los índices de entrada; ella simplemente determina como y donde deberían reindexarse los indices almacenados. Ella no solo soporta indices enteros,

\end{itemize}


 sino que también soporta indexación no escalar. Esto significa que las vistas de vistas no necesitan dos    niveles de indirección; ellas pueden simplemente recomputar los índices en el array padre original.  



\begin{itemize}
\item Es de esperar que a estas alturas esté bastante claro que soportar rebanadas en arrays significa que la dimensionalidad, dada por el parámetro \texttt{N}, no es necesariamente igual a la dimensionalidad del array padre o la longitud de la tupla \texttt{indexes}. Tampoco los índices proporcionados por el usuario se alinean necesariamente con las entradas en la tupla \texttt{indexes} (por ejemplo, el segundo índice proporcionado por el usuario puede corresponder a la tercera dimensión de la matriz padre, y el tercer elemento en la tupla \texttt{indexes}).

Lo que podría ser menos obvio es que la dimensionalidad del array padre almacenado sea igual al número de  índices efectivos en la tupla \texttt{indexes}. Algunos ejemplos:


\begin{minted}{julia}
A = reshape(1:35, 5, 7) # A 2d parent Array
S = view(A, 2:7)         # A 1d view created by linear indexing
S = view(A, :, :, 1:1)   # Appending extra indices is supported
\end{minted}

Ingenuamente, uno pensaría que podría simplemente establecer \texttt{S.parent = A} y\texttt{S.indexes = (:,:, 1: 1)},  pero el hecho de soportar esto complica dramáticamente el proceso de reindexación, especialmente para  vistas de vistas. No solo se necesita despachar los tipos de los índices almacenados, sino que se debe  examinar si un índice dado es el último y {\textquotedbl}fusionar{\textquotedbl} los índices almacenados restantes. Esto no es una  tarea fácil, y aún peor: es lenta ya que depende implícitamente de la indexación lineal.

Afortunadamente, este es precisamente el cálculo que {\textquotesingle}ReshapedArray{\textquotesingle} realiza, y lo hace linealmente si es posible. En consecuencia, \texttt{view} asegura que el array padre es la dimensionalidad adecuada para los  índices dados mediante reformateo (\emph{reshaping}) si es necesario. El constructor interno \texttt{SubArray}  asegura que este invariante esté satisfecha.


\item \texttt{CartesianIndex} y sus matrices retuercen de una forma desagradable el esquema \texttt{reindex}. Recuerde  que \texttt{reindex} simplemente despacha sobre el tipo de índices almacenados para determinar cuántos  índices pasados deberían usarse y a dónde deberían ir. Pero con \texttt{CartesianIndex}, ya no hay una  correspondencia uno a uno entre la cantidad de argumentos pasados y la cantidad de dimensiones en  las que indexan. Si volvemos al ejemplo anterior de \texttt{Base.reindex(S1, S1.indexes, (i, j))}, puede  ver que la expansión es incorrecta para \texttt{i, j = CartesianIndex (), CartesianIndex (2,1 )}. Él  debería \emph{salta} el \texttt{CartesianIndex()} por completo y devolver:


\begin{minted}{julia}
(CartesianIndex(2,1)[1], S1.indexes[2], S1.indexes[3][CartesianIndex(2,1)[2]])
\end{minted}

Y si embargo, lo que devuelve es:


\begin{minted}{julia}
(CartesianIndex(), S1.indexes[2], S1.indexes[3][CartesianIndex(2,1)])
\end{minted}

Hacer esto correctamente requeriría el envío \emph{combinado} en los índices almacenados y pasados en  todas las combinaciones de dimensionalidades de una manera intratable. Como tal, \texttt{reindex} nunca  debe invocarse con índices \texttt{CartesianIndex}. Afortunadamente, el caso escalar se maneja fácilmente  aplanando primero los argumentos \texttt{CartesianIndex} a enteros simples. Sin embargo, las matrices de  \texttt{CartesianIndex} no se pueden dividir en piezas ortogonales tan fácilmente. Antes de intentar usar  \texttt{reindex},\texttt{view} debe garantizar que no haya matrices de \texttt{CartesianIndex} en la lista de argumentos.  Si los hay, simplemente puede {\textquotedbl}puntualizar{\textquotedbl} evitando por completo el cálculo de {\textquotesingle}reindex{\textquotesingle}, construyendo  un \texttt{SubArray} anidado con dos niveles de indirección en su lugar.

\end{itemize}


\hypertarget{4435767086673027446}{}


\section{System Image Building}



\hypertarget{13880852207471486494}{}


\subsection{Building the Julia system image}



Julia ships with a preparsed system image containing the contents of the \texttt{Base} module, named \texttt{sys.ji}.  This file is also precompiled into a shared library called \texttt{sys.\{so,dll,dylib\}} on as many platforms as possible, so as to give vastly improved startup times.  On systems that do not ship with a precompiled system image file, one can be generated from the source files shipped in Julia{\textquotesingle}s \texttt{DATAROOTDIR/julia/base} folder.



This operation is useful for multiple reasons.  A user may:



\begin{itemize}
\item Build a precompiled shared library system image on a platform that did not ship with one, thereby improving startup times.


\item Modify \texttt{Base}, rebuild the system image and use the new \texttt{Base} next time Julia is started.


\item Include a \texttt{userimg.jl} file that includes packages into the system image, thereby creating a system image that has packages embedded into the startup environment.

\end{itemize}


Julia now ships with a script that automates the tasks of building the system image, wittingly named \texttt{build\_sysimg.jl} that lives in \texttt{DATAROOTDIR/julia/}.  That is, to include it into a current Julia session, type:




\begin{minted}{julia}
include(joinpath(JULIA_HOME, Base.DATAROOTDIR, "julia", "build_sysimg.jl"))
\end{minted}



This will include a \texttt{build\_sysimg()} function:


\hypertarget{6550638812051289176}{} 
\hyperlink{6550638812051289176}{\texttt{BuildSysImg.build\_sysimg}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
build_sysimg(sysimg_path=default_sysimg_path(), cpu_target="native", userimg_path=nothing; force=false)
\end{lstlisting}

Rebuild the system image. Store it in \texttt{sysimg\_path}, which defaults to a file named \texttt{sys.ji} that sits in the same folder as \texttt{libjulia.\{so,dylib\}}, except on Windows where it defaults to \texttt{JULIA\_HOME/../lib/julia/sys.ji}.  Use the cpu instruction set given by \texttt{cpu\_target}. Valid CPU targets are the same as for the \texttt{-C} option to \texttt{julia}, or the \texttt{-march} option to \texttt{gcc}.  Defaults to \texttt{native}, which means to use all CPU instructions available on the current processor. Include the user image file given by \texttt{userimg\_path}, which should contain directives such as \texttt{using MyPackage} to include that package in the new system image. New system image will not replace an older image unless \texttt{force} is set to true.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/../contrib/build_sysimg.jl#L15-L26}{\texttt{source}}


\end{adjustwidth}

Note that this file can also be run as a script itself, with command line arguments taking the place of arguments passed to the \texttt{build\_sysimg} function.  For example, to build a system image in \texttt{/tmp/sys.\{so,dll,dylib\}}, with the \texttt{core2} CPU instruction set, a user image of \texttt{{\textasciitilde}/userimg.jl} and \texttt{force} set to \texttt{true}, one would execute:




\begin{lstlisting}
julia build_sysimg.jl /tmp/sys core2 ~/userimg.jl --force
\end{lstlisting}



\hypertarget{15676237889045834434}{}


\section{Working with LLVM}



This is not a replacement for the LLVM documentation, but a collection of tips for working on LLVM for Julia.



\hypertarget{8956364453365125987}{}


\subsection{Overview of Julia to LLVM Interface}



Julia statically links in LLVM by default. Build with \texttt{USE\_LLVM\_SHLIB=1} to link dynamically.



The code for lowering Julia AST to LLVM IR or interpreting it directly is in directory \texttt{src/}.




\begin{table}[h]

\begin{tabulary}{\linewidth}{|L|L|}
\hline
File & Description \\
\hline
\texttt{builtins.c} & Builtin functions \\
\hline
\texttt{ccall.cpp} & Lowering \texttt{ccall} \\
\hline
\texttt{cgutils.cpp} & Lowering utilities, notably for array and tuple accesses \\
\hline
\texttt{codegen.cpp} & Top-level of code generation, pass list, lowering builtins \\
\hline
\texttt{debuginfo.cpp} & Tracks debug information for JIT code \\
\hline
\texttt{disasm.cpp} & Handles native object file and JIT code diassembly \\
\hline
\texttt{gf.c} & Generic functions \\
\hline
\texttt{intrinsics.cpp} & Lowering intrinsics \\
\hline
\texttt{llvm-simdloop.cpp} & Custom LLVM pass for \texttt{@simd} \\
\hline
\texttt{sys.c} & I/O and operating system utility functions \\
\hline
\end{tabulary}

\end{table}



Some of the \texttt{.cpp} files form a group that compile to a single object.



The difference between an intrinsic and a builtin is that a builtin is a first class function that can be used like any other Julia function.  An intrinsic can operate only on unboxed data, and therefore its arguments must be statically typed.



\hypertarget{8366324567299313031}{}


\subsubsection{Alias Analysis}



Julia currently uses LLVM{\textquotesingle}s \href{http://llvm.org/docs/LangRef.html\#tbaa-metadata}{Type Based Alias Analysis}. To find the comments that document the inclusion relationships, look for \texttt{static MDNode*} in \texttt{src/codegen.cpp}.



The \texttt{-O} option enables LLVM{\textquotesingle}s \href{http://llvm.org/docs/AliasAnalysis.html\#the-basicaa-pass}{Basic Alias Analysis}.



\hypertarget{13120458447023898074}{}


\subsection{Building Julia with a different version of LLVM}



The default version of LLVM is specified in \texttt{deps/Versions.make}. You can override it by creating a file called \texttt{Make.user} in the top-level directory and adding a line to it such as:




\begin{lstlisting}
LLVM_VER = 3.5.0
\end{lstlisting}



Besides the LLVM release numerals, you can also use \texttt{LLVM\_VER = svn} to bulid against the latest development version of LLVM.



\hypertarget{3429896864083237221}{}


\subsection{Passing options to LLVM}



You can pass options to LLVM using \emph{debug} builds of Julia.  To create a debug build, run \texttt{make debug}.  The resulting executable is \texttt{usr/bin/julia-debug}. You can pass LLVM options to this executable via the environment variable \texttt{JULIA\_LLVM\_ARGS}. Here are example settings using \texttt{bash} syntax:



\begin{itemize}
\item \texttt{export JULIA\_LLVM\_ARGS = -print-after-all} dumps IR after each pass.


\item \texttt{export JULIA\_LLVM\_ARGS = -debug-only=loop-vectorize} dumps LLVM \texttt{DEBUG(...)} diagnostics for loop vectorizer \emph{if} you built Julia with \texttt{LLVM\_ASSERTIONS=1}. Otherwise you will get warnings about {\textquotedbl}Unknown command line argument{\textquotedbl}. Counter-intuitively, building Julia with \texttt{LLVM\_DEBUG=1} is \emph{not} enough to dump \texttt{DEBUG} diagnostics from a pass.

\end{itemize}


\hypertarget{18346154193244616171}{}


\subsection{Improving LLVM optimizations for Julia}



Improving LLVM code generation usually involves either changing Julia lowering to be more friendly to LLVM{\textquotesingle}s passes, or improving a pass.



If you are planning to improve a pass, be sure to read the \href{http://llvm.org/docs/DeveloperPolicy.html}{LLVM developer policy}. The best strategy is to create a code example in a form where you can use LLVM{\textquotesingle}s \texttt{opt} tool to study it and the pass of interest in isolation.



\begin{itemize}
\item[1. ] Create an example Julia code of interest.


\item[2. ] Use \texttt{JULIA\_LLVM\_ARGS = -print-after-all} to dump the IR.


\item[3. ] Pick out the IR at the point just before the pass of interest runs.


\item[4. ] Strip the debug metadata and fix up the TBAA metadata by hand.

\end{itemize}


The last step is labor intensive.  Suggestions on a better way would be appreciated.



\hypertarget{15255383527079538908}{}


\section{printf() and stdio in the Julia runtime}



\hypertarget{11306377068338291950}{}


\subsection{Libuv wrappers for stdio}



\texttt{julia.h} defines \href{http://docs.libuv.org}{libuv} wrappers for the \texttt{stdio.h} streams:




\begin{lstlisting}
uv_stream_t *JL_STDIN;
uv_stream_t *JL_STDOUT;
uv_stream_t *JL_STDERR;
\end{lstlisting}



... and corresponding output functions:




\begin{lstlisting}
int jl_printf(uv_stream_t *s, const char *format, ...);
int jl_vprintf(uv_stream_t *s, const char *format, va_list args);
\end{lstlisting}



These \texttt{printf} functions are used by the \texttt{.c} files in the \texttt{src/} and \texttt{ui/} directories wherever stdio is needed to ensure that output buffering is handled in a unified way.



In special cases, like signal handlers, where the full libuv infrastructure is too heavy, \texttt{jl\_safe\_printf()} can be used to \hyperlink{16947913578760238729}{\texttt{write(2)}} directly to \texttt{STDERR\_FILENO}:




\begin{lstlisting}
void jl_safe_printf(const char *str, ...);
\end{lstlisting}



\hypertarget{9919396910097555458}{}


\subsection{Interface between JL\_STD* and Julia code}



\hyperlink{13806523663202420575}{\texttt{Base.STDIN}}, \hyperlink{2784333101804678420}{\texttt{Base.STDOUT}} and \hyperlink{4481879903628924306}{\texttt{Base.STDERR}} are bound to the \texttt{JL\_STD*} libuv streams defined in the runtime.



Julia{\textquotesingle}s \texttt{\_\_init\_\_()} function (in \texttt{base/sysimg.jl}) calls \texttt{reinit\_stdio()} (in \texttt{base/stream.jl}) to create Julia objects for \hyperlink{13806523663202420575}{\texttt{Base.STDIN}}, \hyperlink{2784333101804678420}{\texttt{Base.STDOUT}} and \hyperlink{4481879903628924306}{\texttt{Base.STDERR}}.



\texttt{reinit\_stdio()} uses \hyperlink{14245046751182637566}{\texttt{ccall}} to retrieve pointers to \texttt{JL\_STD*} and calls \texttt{jl\_uv\_handle\_type()} to inspect the type of each stream.  It then creates a Julia \texttt{Base.IOStream}, \texttt{Base.TTY} or \texttt{Base.PipeEndpoint} object to represent each stream, e.g.:




\begin{lstlisting}
$ julia -e 'println(typeof((STDIN, STDOUT, STDERR)))'
Tuple{Base.TTY,Base.TTY,Base.TTY}

$ julia -e 'println(typeof((STDIN, STDOUT, STDERR)))' < /dev/null 2>/dev/null
Tuple{IOStream,Base.TTY,IOStream}

$ echo hello | julia -e 'println(typeof((STDIN, STDOUT, STDERR)))' | cat
Tuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}
\end{lstlisting}



The \hyperlink{8104134490906192097}{\texttt{Base.read()}} and \hyperlink{16947913578760238729}{\texttt{Base.write()}} methods for these streams use \hyperlink{14245046751182637566}{\texttt{ccall}} to call libuv wrappers in \texttt{src/jl\_uv.c}, e.g.:




\begin{lstlisting}
stream.jl: function write(s::IO, p::Ptr, nb::Integer)
               -> ccall(:jl_uv_write, ...)
  jl_uv.c:          -> int jl_uv_write(uv_stream_t *stream, ...)
                        -> uv_write(uvw, stream, buf, ...)
\end{lstlisting}



\hypertarget{10878739879441287330}{}


\subsection{printf() during initialization}



The libuv streams relied upon by \texttt{jl\_printf()} etc., are not available until midway through initialization of the runtime (see \texttt{init.c}, \texttt{init\_stdio()}).  Error messages or warnings that need to be printed before this are routed to the standard C library \texttt{fwrite()} function by the following mechanism:



In \texttt{sys.c}, the \texttt{JL\_STD*} stream pointers are statically initialized to integer constants: \texttt{STD*\_FILENO (0, 1 and 2)}. In \texttt{jl\_uv.c} the \texttt{jl\_uv\_puts()} function checks its \texttt{uv\_stream\_t* stream} argument and calls \texttt{fwrite()} if stream is set to \texttt{STDOUT\_FILENO} or \texttt{STDERR\_FILENO}.



This allows for uniform use of \texttt{jl\_printf()} throughout the runtime regardless of whether or not any particular piece of code is reachable before initialization is complete.



\hypertarget{15406109399506022628}{}


\subsection{Legacy \texttt{ios.c} library}



The \texttt{src/support/ios.c} library is inherited from \href{https://github.com/JeffBezanson/femtolisp}{femtolisp}. It provides cross-platform buffered file IO and in-memory temporary buffers.



\texttt{ios.c} is still used by:



\begin{itemize}
\item \texttt{src/flisp/*.c}


\item \texttt{src/dump.c} – for serialization file IO and for memory buffers.


\item \texttt{base/iostream.jl} – for file IO (see \texttt{base/fs.jl} for libuv equivalent).

\end{itemize}


Use of \texttt{ios.c} in these modules is mostly self-contained and separated from the libuv I/O system. However, there is \href{https://github.com/JuliaLang/julia/blob/master/src/flisp/print.c\#L654}{one place} where femtolisp calls through to \texttt{jl\_printf()} with a legacy \texttt{ios\_t} stream.



There is a hack in \texttt{ios.h} that makes the \texttt{ios\_t.bm} field line up with the \texttt{uv\_stream\_t.type} and ensures that the values used for \texttt{ios\_t.bm} to not overlap with valid \texttt{UV\_HANDLE\_TYPE} values.  This allows \texttt{uv\_stream\_t} pointers to point to \texttt{ios\_t} streams.



This is needed because \texttt{jl\_printf()} caller \texttt{jl\_static\_show()} is passed an \texttt{ios\_t} stream by femtolisp{\textquotesingle}s \texttt{fl\_print()} function. Julia{\textquotesingle}s \texttt{jl\_uv\_puts()} function has special handling for this:




\begin{lstlisting}
if (stream->type > UV_HANDLE_TYPE_MAX) {
    return ios_write((ios_t*)stream, str, n);
}
\end{lstlisting}



\hypertarget{15203641602433735164}{}


\section{Bounds checking}



Like many modern programming languages, Julia uses bounds checking to ensure program safety when accessing arrays. In tight inner loops or other performance critical situations, you may wish to skip these bounds checks to improve runtime performance. For instance, in order to emit vectorized (SIMD) instructions, your loop body cannot contain branches, and thus cannot contain bounds checks. Consequently, Julia includes an \texttt{@inbounds(...)} macro to tell the compiler to skip such bounds checks within the given block. For the built-in \texttt{Array} type, the magic happens inside the \texttt{arrayref} and \texttt{arrayset} intrinsics. User-defined array types instead use the \texttt{@boundscheck(...)} macro to achieve context-sensitive code selection.



\hypertarget{15977328606651213476}{}


\subsection{Eliding bounds checks}



The \texttt{@boundscheck(...)} macro marks blocks of code that perform bounds checking. When such blocks appear inside of an \texttt{@inbounds(...)} block, the compiler removes these blocks. When the \texttt{@boundscheck(...)} is nested inside of a calling function containing an \texttt{@inbounds(...)}, the compiler will remove the \texttt{@boundscheck} block \emph{only if it is inlined} into the calling function. For example, you might write the method \texttt{sum} as:




\begin{minted}{julia}
function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end
\end{minted}



With a custom array-like type \texttt{MyArray} having:




\begin{minted}{julia}
@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A,i); A.data[to_index(i)])
\end{minted}



Then when \texttt{getindex} is inlined into \texttt{sum}, the call to \texttt{checkbounds(A,i)} will be elided. If your function contains multiple layers of inlining, only \texttt{@boundscheck} blocks at most one level of inlining deeper are eliminated. The rule prevents unintended changes in program behavior from code further up the stack.



\hypertarget{10208484018202603417}{}


\subsection{Propagating inbounds}



There may be certain scenarios where for code-organization reasons you want more than one layer between the \texttt{@inbounds} and \texttt{@boundscheck} declarations. For instance, the default \texttt{getindex} methods have the chain \texttt{getindex(A::AbstractArray, i::Real)} calls \texttt{getindex(IndexStyle(A), A, i)} calls \texttt{\_getindex(::IndexLinear, A, i)}.



To override the {\textquotedbl}one layer of inlining{\textquotedbl} rule, a function may be marked with \texttt{@propagate\_inbounds} to propagate an inbounds context (or out of bounds context) through one additional layer of inlining.



\hypertarget{17261866997775737461}{}


\subsection{The bounds checking call hierarchy}



The overall hierarchy is:



\begin{itemize}
\item \texttt{checkbounds(A, I...)} which calls

\begin{itemize}
\item \texttt{checkbounds(Bool, A, I...)} which calls

\begin{itemize}
\item \texttt{checkbounds\_indices(Bool, indices(A), I)} which recursively calls

\begin{itemize}
\item \texttt{checkindex} for each dimension

\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}


Here \texttt{A} is the array, and \texttt{I} contains the {\textquotedbl}requested{\textquotedbl} indices. \texttt{indices(A)} returns a tuple of {\textquotedbl}permitted{\textquotedbl} indices of \texttt{A}.



\texttt{checkbounds(A, I...)} throws an error if the indices are invalid, whereas \texttt{checkbounds(Bool, A, I...)} returns \texttt{false} in that circumstance.  \texttt{checkbounds\_indices} discards any information about the array other than its \texttt{indices} tuple, and performs a pure indices-vs-indices comparison: this allows relatively few compiled methods to serve a huge variety of array types. Indices are specified as tuples, and are usually compared in a 1-1 fashion with individual dimensions handled by calling another important function, \texttt{checkindex}: typically,




\begin{minted}{julia}
checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &
                                                      checkbounds_indices(Bool, IA, I)
\end{minted}



so \texttt{checkindex} checks a single dimension.  All of these functions, including the unexported \texttt{checkbounds\_indices} have docstrings accessible with \texttt{?} .



If you have to customize bounds checking for a specific array type, you should specialize \texttt{checkbounds(Bool, A, I...)}. However, in most cases you should be able to rely on \texttt{checkbounds\_indices} as long as you supply useful \texttt{indices} for your array type.



If you have novel index types, first consider specializing \texttt{checkindex}, which handles a single index for a particular dimension of an array.  If you have a custom multidimensional index type (similar to \texttt{CartesianIndex}), then you may have to consider specializing \texttt{checkbounds\_indices}.



Note this hierarchy has been designed to reduce the likelihood of method ambiguities.  We try to make \texttt{checkbounds} the place to specialize on array type, and try to avoid specializations on index types; conversely, \texttt{checkindex} is intended to be specialized only on index type (especially, the last argument).



\hypertarget{16029610522337323518}{}


\section{Proper maintenance and care of multi-threading locks}



The following strategies are used to ensure that the code is dead-lock free (generally by addressing the 4th Coffman condition: circular wait).



\begin{quote}
\begin{itemize}
\item[1. ] structure code such that only one lock will need to be acquired at a time


\item[2. ] always acquire shared locks in the same order, as given by the table below


\item[3. ] avoid constructs that expect to need unrestricted recursion

\end{itemize}
\end{quote}


\hypertarget{13071695811965191352}{}


\subsection{Locks}



Below are all of the locks that exist in the system and the mechanisms for using them that avoid the potential for deadlocks (no Ostrich algorithm allowed here):



The following are definitely leaf locks (level 1), and must not try to acquire any other lock:



\begin{quote}
\begin{itemize}
\item safepoint

\begin{quote}
Note that this lock is acquired implicitly by \texttt{JL\_LOCK} and \texttt{JL\_UNLOCK}. use the \texttt{\_NOGC} variants to avoid that for level 1 locks.

While holding this lock, the code must not do any allocation or hit any safepoints. Note that there are safepoints when doing allocation, enabling / disabling GC, entering / restoring exception frames, and taking / releasing locks.

\end{quote}

\item shared\_map


\item finalizers


\item pagealloc


\item gc\_perm\_lock


\item flisp

\begin{quote}
flisp itself is already threadsafe, this lock only protects the \texttt{jl\_ast\_context\_list\_t} pool

\end{quote}
\end{itemize}
\end{quote}


The following is a leaf lock (level 2), and only acquires level 1 locks (safepoint) internally:



\begin{quote}
\begin{itemize}
\item typecache

\end{itemize}
\end{quote}


The following is a level 3 lock, which can only acquire level 1 or level 2 locks internally:



\begin{quote}
\begin{itemize}
\item Method->writelock

\end{itemize}
\end{quote}


The following is a level 4 lock, which can only recurse to acquire level 1, 2, or 3 locks:



\begin{quote}
\begin{itemize}
\item MethodTable->writelock

\end{itemize}
\end{quote}


No Julia code may be called while holding a lock above this point.



The following is a level 6 lock, which can only recurse to acquire locks at lower levels:



\begin{quote}
\begin{itemize}
\item codegen

\end{itemize}
\end{quote}


The following is an almost root lock (level end-1), meaning only the root look may be held when trying to acquire it:



\begin{quote}
\begin{itemize}
\item typeinf

\begin{quote}
this one is perhaps one of the most tricky ones, since type-inference can be invoked from many points

currently the lock is merged with the codegen lock, since they call each other recursively

\end{quote}
\end{itemize}
\end{quote}


The following is the root lock, meaning no other lock shall be held when trying to acquire it:



\begin{quote}
\begin{itemize}
\item toplevel

\begin{quote}
this should be held while attempting a top-level action (such as making a new type or defining a new method): trying to obtain this lock inside a staged function will cause a deadlock condition!

additionally, it{\textquotesingle}s unclear if \emph{any} code can safely run in parallel with an arbitrary toplevel expression, so it may require all threads to get to a safepoint first

\end{quote}
\end{itemize}
\end{quote}


\hypertarget{9065842407229995149}{}


\subsection{Broken Locks}



The following locks are broken:



\begin{itemize}
\item toplevel

\begin{quote}
doesn{\textquotesingle}t exist right now

fix: create it

\end{quote}
\end{itemize}


\hypertarget{1067922422509615580}{}


\subsection{Shared Global Data Structures}



These data structures each need locks due to being shared mutable global state. It is the inverse list for the above lock priority list. This list does not include level 1 leaf resources due to their simplicity.



MethodTable modifications (def, cache, kwsorter type) : MethodTable->writelock



Type declarations : toplevel lock



Type application : typecache lock



Module serializer : toplevel lock



JIT \& type-inference : codegen lock



MethodInstance updates : codegen lock



\begin{quote}
\begin{itemize}
\item These fields are generally lazy initialized, using the test-and-test-and-set pattern.


\item These are set at construction and immutable:

\begin{itemize}
\item specTypes


\item sparam\_vals


\item def

\end{itemize}

\item These are set by \texttt{jl\_type\_infer} (while holding codegen lock):

\begin{itemize}
\item rettype


\item inferred


\item these can also be reset, see \texttt{jl\_set\_lambda\_rettype} for that logic as it needs to keep \texttt{functionObjectsDecls} in sync

\end{itemize}

\item \texttt{inInference} flag:

\begin{itemize}
\item optimization to quickly avoid recurring into \texttt{jl\_type\_infer} while it is already running


\item actual state (of setting \texttt{inferred}, then \texttt{fptr}) is protected by codegen lock

\end{itemize}

\item Function pointers (\texttt{jlcall\_api} and \texttt{fptr}, \texttt{unspecialized\_ducttape}):

\begin{itemize}
\item these transition once, from \texttt{NULL} to a value, while the codegen lock is held

\end{itemize}

\item Code-generator cache (the contents of \texttt{functionObjectsDecls}):

\begin{itemize}
\item these can transition multiple times, but only while the codegen lock is held


\item it is valid to use old version of this, or block for new versions of this, so races are benign, as long as the code is careful not to reference other data in the method instance (such as \texttt{rettype}) and assume it is coordinated, unless also holding the codegen lock

\end{itemize}

\item \texttt{compile\_traced} flag:

\begin{itemize}
\item unknown

\end{itemize}
\end{itemize}
\end{quote}


LLVMContext : codegen lock



Method : Method->writelock



\begin{itemize}
\item roots array (serializer and codegen)


\item invoke / specializations / tfunc modifications

\end{itemize}


\hypertarget{12792533311031776054}{}


\section{Arrays with custom indices}



Julia 0.5 adds experimental support for arrays with arbitrary indices. Conventionally, Julia{\textquotesingle}s arrays are indexed starting at 1, whereas some other languages start numbering at 0, and yet others (e.g., Fortran) allow you to specify arbitrary starting indices.  While there is much merit in picking a standard (i.e., 1 for Julia), there are some algorithms which simplify considerably if you can index outside the range \texttt{1:size(A,d)} (and not just \texttt{0:size(A,d)-1}, either). Such array types are expected to be supplied through packages.



The purpose of this page is to address the question, {\textquotedbl}what do I have to do to support such arrays in my own code?{\textquotedbl}  First, let{\textquotesingle}s address the simplest case: if you know that your code will never need to handle arrays with unconventional indexing, hopefully the answer is {\textquotedbl}nothing.{\textquotedbl} Old code, on conventional arrays, should function essentially without alteration as long as it was using the exported interfaces of Julia.



\hypertarget{12133789893433293548}{}


\subsection{Generalizing existing code}



As an overview, the steps are:



\begin{itemize}
\item replace many uses of \texttt{size} with \texttt{indices}


\item replace \texttt{1:length(A)} with \texttt{linearindices(A)}, and \texttt{length(A)} with \texttt{length(linearindices(A))}


\item replace explicit allocations like \texttt{Array\{Int\}(size(B))} with \texttt{similar(Array\{Int\}, indices(B))}

\end{itemize}


These are described in more detail below.



\hypertarget{5370755282098388224}{}


\subsubsection{Background}



Because unconventional indexing breaks deeply-held assumptions throughout the Julia ecosystem, early adopters running code that has not been updated are likely to experience errors.  The most frustrating bugs would be incorrect results or segfaults (total crashes of Julia).  For example, consider the following function:




\begin{minted}{julia}
function mycopy!(dest::AbstractVector, src::AbstractVector)
    length(dest) == length(src) || throw(DimensionMismatch("vectors must match"))
    # OK, now we're safe to use @inbounds, right? (not anymore!)
    for i = 1:length(src)
        @inbounds dest[i] = src[i]
    end
    dest
end
\end{minted}



This code implicitly assumes that vectors are indexed from 1. Previously that was a safe assumption, so this code was fine, but (depending on what types the user passes to this function) it may no longer be safe.  If this code continued to work when passed a vector with non-1 indices, it would either produce an incorrect answer or it would segfault.  (If you do get segfaults, to help locate the cause try running julia with the option \texttt{--check-bounds=yes}.)



To ensure that such errors are caught, in Julia 0.5 both \texttt{length} and \texttt{size}\textbf{should} throw an error when passed an array with non-1 indexing.  This is designed to force users of such arrays to check the code, and inspect it for whether it needs to be generalized.



\hypertarget{10703643701647439456}{}


\subsubsection{Using \texttt{indices} for bounds checks and loop iteration}



\texttt{indices(A)} (reminiscent of \texttt{size(A)}) returns a tuple of \texttt{AbstractUnitRange} objects, specifying the range of valid indices along each dimension of \texttt{A}.  When \texttt{A} has unconventional indexing, the ranges may not start at 1.  If you just want the range for a particular dimension \texttt{d}, there is \texttt{indices(A, d)}.



Base implements a custom range type, \texttt{OneTo}, where \texttt{OneTo(n)} means the same thing as \texttt{1:n} but in a form that guarantees (via the type system) that the lower index is 1. For any new \hyperlink{6514416309183787338}{\texttt{AbstractArray}} type, this is the default returned by \texttt{indices}, and it indicates that this array type uses {\textquotedbl}conventional{\textquotedbl} 1-based indexing.  Note that if you don{\textquotesingle}t want to be bothered supporting arrays with non-1 indexing, you can add the following line:




\begin{minted}{julia}
@assert all(x->isa(x, Base.OneTo), indices(A))
\end{minted}



at the top of any function.



For bounds checking, note that there are dedicated functions \texttt{checkbounds} and \texttt{checkindex} which can sometimes simplify such tests.



\hypertarget{16536792033838986020}{}


\subsubsection{Linear indexing (\texttt{linearindices})}



Some algorithms are most conveniently (or efficiently) written in terms of a single linear index, \texttt{A[i]} even if \texttt{A} is multi-dimensional.  In {\textquotedbl}true{\textquotedbl} linear indexing, the indices always range from \texttt{1:length(A)}. However, this raises an ambiguity for one-dimensional arrays (a.k.a., \texttt{AbstractVector}): does \texttt{v[i]} mean linear indexing, or Cartesian indexing with the array{\textquotesingle}s native indices?



For this reason, if you want to use linear indexing in an algorithm, your best option is to get the index range by calling \texttt{linearindices(A)}.  This will return \texttt{indices(A, 1)} if \texttt{A} is an \texttt{AbstractVector}, and the equivalent of \texttt{1:length(A)} otherwise.



In a sense, one can say that 1-dimensional arrays always use Cartesian indexing. To help enforce this, it{\textquotesingle}s worth noting that \texttt{sub2ind(shape, i...)} and \texttt{ind2sub(shape, ind)} will throw an error if \texttt{shape} indicates a 1-dimensional array with unconventional indexing (i.e., is a \texttt{Tuple\{UnitRange\}} rather than a tuple of \texttt{OneTo}).  For arrays with conventional indexing, these functions continue to work the same as always.



Using \texttt{indices} and \texttt{linearindices}, here is one way you could rewrite \texttt{mycopy!}:




\begin{minted}{julia}
function mycopy!(dest::AbstractVector, src::AbstractVector)
    indices(dest) == indices(src) || throw(DimensionMismatch("vectors must match"))
    for i in linearindices(src)
        @inbounds dest[i] = src[i]
    end
    dest
end
\end{minted}



\hypertarget{8664586686165592487}{}


\subsubsection{Allocating storage using generalizations of \texttt{similar}}



Storage is often allocated with \texttt{Array\{Int\}(dims)} or \texttt{similar(A, args...)}. When the result needs to match the indices of some other array, this may not always suffice. The generic replacement for such patterns is to use \texttt{similar(storagetype, shape)}.  \texttt{storagetype} indicates the kind of underlying {\textquotedbl}conventional{\textquotedbl} behavior you{\textquotesingle}d like, e.g., \texttt{Array\{Int\}} or \texttt{BitArray} or even \texttt{dims->zeros(Float32, dims)} (which would allocate an all-zeros array). \texttt{shape} is a tuple of \hyperlink{8469131683393450448}{\texttt{Integer}} or \texttt{AbstractUnitRange} values, specifying the indices that you want the result to use.



Let{\textquotesingle}s walk through a couple of explicit examples. First, if \texttt{A} has conventional indices, then \texttt{similar(Array\{Int\}, indices(A))} would end up calling \texttt{Array\{Int\}(size(A))}, and thus return an array.  If \texttt{A} is an \texttt{AbstractArray} type with unconventional indexing, then \texttt{similar(Array\{Int\}, indices(A))} should return something that {\textquotedbl}behaves like{\textquotedbl} an \texttt{Array\{Int\}} but with a shape (including indices) that matches \texttt{A}.  (The most obvious implementation is to allocate an \texttt{Array\{Int\}(size(A))} and then {\textquotedbl}wrap{\textquotedbl} it in a type that shifts the indices.)



Note also that \texttt{similar(Array\{Int\}, (indices(A, 2),))} would allocate an \texttt{AbstractVector\{Int\}} (i.e., 1-dimensional array) that matches the indices of the columns of \texttt{A}.



\hypertarget{4653517546914986819}{}


\subsubsection{Deprecations}



In generalizing Julia{\textquotesingle}s code base, at least one deprecation was unavoidable: earlier versions of Julia defined \texttt{first(::Colon) = 1}, meaning that the first index along a dimension indexed by \texttt{:} is 1. This definition can no longer be justified, so it was deprecated. There is no provided replacement, because the proper replacement depends on what you are doing and might need to know more about the array. However, it appears that many uses of \texttt{first(::Colon)} are really about computing an index offset; when that is the case, a candidate replacement is:




\begin{minted}{julia}
indexoffset(r::AbstractVector) = first(r) - 1
indexoffset(::Colon) = 0
\end{minted}



In other words, while \texttt{first(:)} does not itself make sense, in general you can say that the offset associated with a colon-index is zero.



\hypertarget{4699181205936675892}{}


\subsection{Writing custom array types with non-1 indexing}



Most of the methods you{\textquotesingle}ll need to define are standard for any \texttt{AbstractArray} type, see \hyperlink{522338241536202486}{Abstract Arrays}. This page focuses on the steps needed to define unconventional indexing.



\hypertarget{15721468421915743828}{}


\subsubsection{Do \textbf{not} implement \texttt{size} or \texttt{length}}



Perhaps the majority of pre-existing code that uses \texttt{size} will not work properly for arrays with non-1 indices.  For that reason, it is much better to avoid implementing these methods, and use the resulting \texttt{MethodError} to identify code that needs to be audited and perhaps generalized.



\hypertarget{14591227906888876157}{}


\subsubsection{Do \textbf{not} annotate bounds checks}



Julia 0.5 includes \texttt{@boundscheck} to annotate code that can be removed for callers that exploit \texttt{@inbounds}. Initially, it seems far preferable to run with bounds checking always enabled (i.e., omit the \texttt{@boundscheck} annotation so the check always runs).



\hypertarget{5924242856598341681}{}


\subsubsection{Custom \texttt{AbstractUnitRange} types}



If you{\textquotesingle}re writing a non-1 indexed array type, you will want to specialize \texttt{indices} so it returns a \texttt{UnitRange}, or (perhaps better) a custom \texttt{AbstractUnitRange}.  The advantage of a custom type is that it {\textquotedbl}signals{\textquotedbl} the allocation type for functions like \texttt{similar}. If we{\textquotesingle}re writing an array type for which indexing will start at 0, we likely want to begin by creating a new \texttt{AbstractUnitRange}, \texttt{ZeroRange}, where \texttt{ZeroRange(n)} is equivalent to \texttt{0:n-1}.



In general, you should probably \emph{not} export \texttt{ZeroRange} from your package: there may be other packages that implement their own \texttt{ZeroRange}, and having multiple distinct \texttt{ZeroRange} types is (perhaps counterintuitively) an advantage: \texttt{ModuleA.ZeroRange} indicates that \texttt{similar} should create a \texttt{ModuleA.ZeroArray}, whereas \texttt{ModuleB.ZeroRange} indicates a \texttt{ModuleB.ZeroArray} type.  This design allows peaceful coexistence among many different custom array types.



Note that the Julia package \href{https://github.com/JuliaArrays/CustomUnitRanges.jl}{CustomUnitRanges.jl} can sometimes be used to avoid the need to write your own \texttt{ZeroRange} type.



\hypertarget{4658403811041151465}{}


\subsubsection{Specializing \texttt{indices}}



Once you have your \texttt{AbstractUnitRange} type, then specialize \texttt{indices}:




\begin{minted}{julia}
Base.indices(A::ZeroArray) = map(n->ZeroRange(n), A.size)
\end{minted}



where here we imagine that \texttt{ZeroArray} has a field called \texttt{size} (there would be other ways to implement this).



In some cases, the fallback definition for \texttt{indices(A, d)}:




\begin{minted}{julia}
indices(A::AbstractArray{T,N}, d) where {T,N} = d <= N ? indices(A)[d] : OneTo(1)
\end{minted}



may not be what you want: you may need to specialize it to return something other than \texttt{OneTo(1)} when \texttt{d > ndims(A)}.  Likewise, in \texttt{Base} there is a dedicated function \texttt{indices1} which is equivalent to \texttt{indices(A, 1)} but which avoids checking (at runtime) whether \texttt{ndims(A) > 0}. (This is purely a performance optimization.)  It is defined as:




\begin{minted}{julia}
indices1(A::AbstractArray{T,0}) where {T} = OneTo(1)
indices1(A::AbstractArray) = indices(A)[1]
\end{minted}



If the first of these (the zero-dimensional case) is problematic for your custom array type, be sure to specialize it appropriately.



\hypertarget{5556461946249659648}{}


\subsubsection{Specializing \texttt{similar}}



Given your custom \texttt{ZeroRange} type, then you should also add the following two specializations for \texttt{similar}:




\begin{minted}{julia}
function Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})
    # body
end

function Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})
    # body
end
\end{minted}



Both of these should allocate your custom array type.



\hypertarget{16440701718956142132}{}


\subsubsection{Specializing \texttt{reshape}}



Optionally, define a method




\begin{lstlisting}
Base.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...
\end{lstlisting}



and you can \texttt{reshape} an array so that the result has custom indices.



\hypertarget{18141068032187944302}{}


\subsection{Summary}



Writing code that doesn{\textquotesingle}t make assumptions about indexing requires a few extra abstractions, but hopefully the necessary changes are relatively straightforward.



As a reminder, this support is still experimental. While much of Julia{\textquotesingle}s base code has been updated to support unconventional indexing, without a doubt there are many omissions that will be discovered only through usage.  Moreover, at the time of this writing, most packages do not support unconventional indexing.  As a consequence, early adopters should be prepared to identify and/or fix bugs.  On the other hand, only through practical usage will it become clear whether this experimental feature should be retained in future versions of Julia; consequently, interested parties are encouraged to accept some ownership for putting it through its paces.



\hypertarget{8108834884169454679}{}


\section{Base.LibGit2}



The LibGit2 module provides bindings to \href{https://libgit2.github.com/}{libgit2}, a portable C library that implements core functionality for the \href{https://git-scm.com/}{Git} version control system. These bindings are currently used to power Julia{\textquotesingle}s package manager. It is expected that this module will eventually be moved into a separate package.



\hypertarget{13716495418266911399}{}


\subsubsection{Functionality}



Some of this documentation assumes some prior knowledge of the libgit2 API. For more information on some of the objects and methods referenced here, consult the upstream \href{https://libgit2.github.com/libgit2/\#v0.25.1}{libgit2 API reference}.


\hypertarget{9931686680952686942}{} 
\hyperlink{9931686680952686942}{\texttt{Base.LibGit2.AbstractCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Abstract credentials payload



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L121}{\texttt{source}}


\end{adjustwidth}
\hypertarget{494380605532643136}{} 
\hyperlink{494380605532643136}{\texttt{Base.LibGit2.Buffer}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.Buffer
\end{lstlisting}

A data buffer for exporting data from libgit2. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_buf}{\texttt{git\_buf}} struct.

When fetching data from LibGit2, a typical usage would look like:


\begin{minted}{julia}
buf_ref = Ref(Buffer())
@check ccall(..., (Ptr{Buffer},), buf_ref)
# operation on buf_ref
free(buf_ref)
\end{minted}

In particular, note that \texttt{LibGit2.free} should be called afterward on the \texttt{Ref} object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L95-L109}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13238011814106976912}{} 
\hyperlink{13238011814106976912}{\texttt{Base.LibGit2.CachedCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Credentials that support caching



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L719}{\texttt{source}}


\end{adjustwidth}
\hypertarget{70406186196513527}{} 
\hyperlink{70406186196513527}{\texttt{Base.LibGit2.CheckoutOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.CheckoutOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_checkout\_options}{\texttt{git\_checkout\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15962357627830986499}{} 
\hyperlink{15962357627830986499}{\texttt{Base.LibGit2.CloneOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.CloneOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_clone\_options}{\texttt{git\_clone\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14078336658014776528}{} 
\hyperlink{14078336658014776528}{\texttt{Base.LibGit2.DiffDelta}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.DiffDelta
\end{lstlisting}

Description of changes to one entry. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_diff\_delta}{\texttt{git\_diff\_delta}} struct.

The fields represent:

\begin{itemize}
\item \texttt{status}: One of \texttt{Consts.DELTA\_STATUS}, indicating whether the file has been added/modified/deleted.


\item \texttt{flags}: Flags for the delta and the objects on each side. Determines whether to treat the file(s)  as binary/text, whether they exist on each side of the diff, and whether the object ids are known  to be correct.


\item \texttt{similarity}: Used to indicate if a file has been renamed or copied.


\item \texttt{nfiles}: The number of files in the delta (for instance, if the delta  was run on a submodule commit id, it may contain more than one file).


\item \texttt{old\_file}: A \hyperlink{10853323880399933744}{\texttt{DiffFile}} containing information about the file(s) before the changes.


\item \texttt{new\_file}: A \hyperlink{10853323880399933744}{\texttt{DiffFile}} containing information about the file(s) after the changes.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L297-L313}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10853323880399933744}{} 
\hyperlink{10853323880399933744}{\texttt{Base.LibGit2.DiffFile}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.DiffFile
\end{lstlisting}

Description of one side of a delta. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_diff\_file}{\texttt{git\_diff\_file}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L273-L278}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11159190153382889147}{} 
\hyperlink{11159190153382889147}{\texttt{Base.LibGit2.DiffOptionsStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.DiffOptionsStruct
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_diff\_options}{\texttt{git\_diff\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9452650946849889589}{} 
\hyperlink{9452650946849889589}{\texttt{Base.LibGit2.FetchHead}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.FetchHead
\end{lstlisting}

Contains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L468-L474}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15843746833940127147}{} 
\hyperlink{15843746833940127147}{\texttt{Base.LibGit2.FetchOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.FetchOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_fetch\_options}{\texttt{git\_fetch\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{501958583811403153}{} 
\hyperlink{501958583811403153}{\texttt{Base.LibGit2.GitBlob}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitBlob(repo::GitRepo, hash::AbstractGitHash)
GitBlob(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return a \texttt{GitBlob} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L102-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10902694404628649896}{} 
\hyperlink{10902694404628649896}{\texttt{Base.LibGit2.GitCommit}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitCommit(repo::GitRepo, hash::AbstractGitHash)
GitCommit(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return a \texttt{GitCommit} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L102-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11729713909743491089}{} 
\hyperlink{11729713909743491089}{\texttt{Base.LibGit2.GitHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitHash
\end{lstlisting}

A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a \texttt{GitObject} in a repository.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L12-L17}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12902667157232644392}{} 
\hyperlink{12902667157232644392}{\texttt{Base.LibGit2.GitObject}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitObject(repo::GitRepo, hash::AbstractGitHash)
GitObject(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return the specified object (\hyperlink{10902694404628649896}{\texttt{GitCommit}}, \hyperlink{501958583811403153}{\texttt{GitBlob}}, \hyperlink{15098307424713644345}{\texttt{GitTree}} or \hyperlink{16990398329245524657}{\texttt{GitTag}}) from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L91-L100}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4330007138212949924}{} 
\hyperlink{4330007138212949924}{\texttt{Base.LibGit2.GitRemote}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString) -> GitRemote
\end{lstlisting}

Look up a remote git repository using its name and URL. Uses the default fetch refspec.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
remote = LibGit2.GitRemote(repo, "upstream", repo_url)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L3-L14}{\texttt{source}}



\begin{lstlisting}
GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::AbstractString) -> GitRemote
\end{lstlisting}

Look up a remote git repository using the repository{\textquotesingle}s name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
refspec = "+refs/heads/mybranch:refs/remotes/origin/mybranch"
remote = LibGit2.GitRemote(repo, "upstream", repo_url, refspec)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L23-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5869419718818609673}{} 
\hyperlink{5869419718818609673}{\texttt{Base.LibGit2.GitRemoteAnon}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitRemoteAnon(repo::GitRepo, url::AbstractString) -> GitRemote
\end{lstlisting}

Look up a remote git repository using only its URL, not its name.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
remote = LibGit2.GitRemoteAnon(repo, repo_url)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L46-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4189069544748556340}{} 
\hyperlink{4189069544748556340}{\texttt{Base.LibGit2.GitRepo}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.GitRepo(path::AbstractString)
\end{lstlisting}

Opens a git repository at \texttt{path}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10671080275952077260}{} 
\hyperlink{10671080275952077260}{\texttt{Base.LibGit2.GitRepoExt}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.GitRepoExt(path::AbstractString, flags::Cuint = Cuint(Consts.REPOSITORY_OPEN_DEFAULT))
\end{lstlisting}

Opens a git repository at \texttt{path} with extended controls (for instance, if the current user must be a member of a special access group to read \texttt{path}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L15-L20}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3688304737210863680}{} 
\hyperlink{3688304737210863680}{\texttt{Base.LibGit2.GitShortHash}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitShortHash
\end{lstlisting}

This is a shortened form of \texttt{GitHash}, which can be used to identify a git object when it is unique.

Internally it is stored as two fields: a full-size \texttt{GitHash} (\texttt{hash}) and a length (\texttt{len}). Only the initial \texttt{len} hex digits of \texttt{hash} are used.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L24-L32}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6700778514719115049}{} 
\hyperlink{6700778514719115049}{\texttt{Base.LibGit2.GitSignature}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.GitSignature
\end{lstlisting}

This is a Julia wrapper around a pointer to a \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_signature}{\texttt{git\_signature}} object.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L574-L579}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11348324466028293798}{} 
\hyperlink{11348324466028293798}{\texttt{Base.LibGit2.GitStatus}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.GitStatus(repo::GitRepo; status_opts=StatusOptions())
\end{lstlisting}

Collect information about the status of each file in the git repository \texttt{repo} (e.g. is the file modified, staged, etc.). \texttt{status\_opts} can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/status.jl#L3-L11}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16990398329245524657}{} 
\hyperlink{16990398329245524657}{\texttt{Base.LibGit2.GitTag}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitTag(repo::GitRepo, hash::AbstractGitHash)
GitTag(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return a \texttt{GitTag} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L102-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15098307424713644345}{} 
\hyperlink{15098307424713644345}{\texttt{Base.LibGit2.GitTree}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
GitTree(repo::GitRepo, hash::AbstractGitHash)
GitTree(repo::GitRepo, spec::AbstractString)
\end{lstlisting}

Return a \texttt{GitTree} object from \texttt{repo} specified by \texttt{hash}/\texttt{spec}.

\begin{itemize}
\item \texttt{hash} is a full (\texttt{GitHash}) or partial (\texttt{GitShortHash}) hash.


\item \texttt{spec} is a textual specification: see \href{https://git-scm.com/docs/git-rev-parse.html\#\_specifying\_revisions}{the git docs} for a full list.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L102-L110}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18198409590045889476}{} 
\hyperlink{18198409590045889476}{\texttt{Base.LibGit2.IndexEntry}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.IndexEntry
\end{lstlisting}

In-memory representation of a file entry in the index. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_index\_entry}{\texttt{git\_index\_entry}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L379-L384}{\texttt{source}}


\end{adjustwidth}
\hypertarget{296553790669644349}{} 
\hyperlink{296553790669644349}{\texttt{Base.LibGit2.IndexTime}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.IndexTime
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_index\_time}{\texttt{git\_index\_time}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L369-L373}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2235243125158864104}{} 
\hyperlink{2235243125158864104}{\texttt{Base.LibGit2.MergeOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.MergeOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_merge\_options}{\texttt{git\_merge\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9333556612062755476}{} 
\hyperlink{9333556612062755476}{\texttt{Base.LibGit2.ProxyOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.ProxyOptions
\end{lstlisting}

Options for connecting through a proxy.

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_proxy\_options}{\texttt{git\_proxy\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L812}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17509129411927482709}{} 
\hyperlink{17509129411927482709}{\texttt{Base.LibGit2.PushOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.PushOptions
\end{lstlisting}

Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_push\_options}{\texttt{git\_push\_options}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16523024686410327521}{} 
\hyperlink{16523024686410327521}{\texttt{Base.LibGit2.RebaseOperation}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.RebaseOperation
\end{lstlisting}

Describes a single instruction/operation to be performed during the rebase. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_rebase\_operation\_t}{\texttt{git\_rebase\_operation}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L423-L428}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6353749624136519808}{} 
\hyperlink{6353749624136519808}{\texttt{Base.LibGit2.RebaseOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.RebaseOptions
\end{lstlisting}

Matches the \texttt{git\_rebase\_options} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L810}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2574901316547132732}{} 
\hyperlink{2574901316547132732}{\texttt{Base.LibGit2.RemoteCallbacks}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.RemoteCallbacks
\end{lstlisting}

Callback settings. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_remote\_callbacks}{\texttt{git\_remote\_callbacks}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L811}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10720534215214670880}{} 
\hyperlink{10720534215214670880}{\texttt{Base.LibGit2.SSHCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

SSH credentials type



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L688}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2816946505163653514}{} 
\hyperlink{2816946505163653514}{\texttt{Base.LibGit2.SignatureStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.SignatureStruct
\end{lstlisting}

An action signature (e.g. for committers, taggers, etc). Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_signature}{\texttt{git\_signature}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17790110826231416677}{} 
\hyperlink{17790110826231416677}{\texttt{Base.LibGit2.StatusEntry}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.StatusEntry
\end{lstlisting}

Providing the differences between the file as it exists in HEAD and the index, and providing the differences between the index and the working directory. Matches the \texttt{git\_status\_entry} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L455-L461}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15130089426107137330}{} 
\hyperlink{15130089426107137330}{\texttt{Base.LibGit2.StatusOptions}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.StatusOptions
\end{lstlisting}

Options to control how \texttt{git\_status\_foreach\_ext()} will issue callbacks. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_status\_opt\_t}{\texttt{git\_status\_opt\_t}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L806-L811}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7653839277371867286}{} 
\hyperlink{7653839277371867286}{\texttt{Base.LibGit2.StrArrayStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.StrArrayStruct
\end{lstlisting}

A LibGit2 representation of an array of strings. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_strarray}{\texttt{git\_strarray}} struct.

When fetching data from LibGit2, a typical usage would look like:


\begin{minted}{julia}
sa_ref = Ref(StrArrayStruct())
@check ccall(..., (Ptr{StrArrayStruct},), sa_ref)
res = convert(Vector{String}, sa_ref[])
free(sa_ref)
\end{minted}

In particular, note that \texttt{LibGit2.free} should be called afterward on the \texttt{Ref} object.

Conversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:


\begin{minted}{julia}
strs = String[...]
@check ccall(..., (Ptr{StrArrayStruct},), strs)
\end{minted}

Note that no call to \texttt{free} is required as the data is allocated by Julia.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L62-L84}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9560069530494563563}{} 
\hyperlink{9560069530494563563}{\texttt{Base.LibGit2.TimeStruct}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.TimeStruct
\end{lstlisting}

Time in a signature. Matches the \href{https://libgit2.github.com/libgit2/\#HEAD/type/git\_time}{\texttt{git\_time}} struct.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L39-L44}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3851413247267063300}{} 
\hyperlink{3851413247267063300}{\texttt{Base.LibGit2.UserPasswordCredentials}}  -- {Type.}

\begin{adjustwidth}{2em}{0pt}

Credentials that support only \texttt{user} and \texttt{password} parameters



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L663}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13623375014723191757}{} 
\hyperlink{13623375014723191757}{\texttt{Base.LibGit2.add\_fetch!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)
\end{lstlisting}

Add a \emph{fetch} refspec for the specified \texttt{rmt}. This refspec will contain information about which branch(es) to fetch from.

\textbf{Example}


\begin{minted}{jlcon}
julia> LibGit2.add_fetch!(repo, remote, "upstream");

julia> LibGit2.fetch_refspecs(remote)
String["+refs/heads/*:refs/remotes/upstream/*"]
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L165-L178}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3465864374577161747}{} 
\hyperlink{3465864374577161747}{\texttt{Base.LibGit2.add\_push!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)
\end{lstlisting}

Add a \emph{push} refspec for the specified \texttt{rmt}. This refspec will contain information about which branch(es) to push to.

\textbf{Example}


\begin{minted}{jlcon}
julia> LibGit2.add_push!(repo, remote, "refs/heads/master");

julia> remote = LibGit2.get(LibGit2.GitRemote, repo, branch);

julia> LibGit2.push_refspecs(remote)
String["refs/heads/master"]
\end{minted}

\begin{quote}
\textbf{Note}

You may need to \hyperlink{5331333469799487255}{\texttt{close}} and reopen the \texttt{GitRemote} in question after updating its push refspecs in order for the change to take effect and for calls to \hyperlink{10329292874321123591}{\texttt{push}} to work.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L185-L206}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8535948773099366335}{} 
\hyperlink{8535948773099366335}{\texttt{Base.LibGit2.addblob!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.addblob!(repo::GitRepo, path::AbstractString)
\end{lstlisting}

Reads the file at \texttt{path} and adds it to the object database of \texttt{repo} as a loose blob. Returns the \texttt{GitHash} of the resulting blob.

\textbf{Example}


\begin{minted}{julia}
hash_str = hex(commit_oid)
blob_file = joinpath(repo_path, ".git", "objects", hash_str[1:2], hash_str[3:end])
id = LibGit2.addblob!(repo, blob_file)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/blob.jl#L36-L49}{\texttt{source}}


\end{adjustwidth}
\hypertarget{4246691067496118320}{} 
\hyperlink{4246691067496118320}{\texttt{Base.LibGit2.authors}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
authors(repo::GitRepo) -> Vector{Signature}
\end{lstlisting}

Returns all authors of commits to the \texttt{repo} repository.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
repo_file = open(joinpath(repo_path, test_file), "a")

println(repo_file, commit_msg)
flush(repo_file)
LibGit2.add!(repo, test_file)
sig = LibGit2.Signature("TEST", "TEST@TEST.COM", round(time(), 0), 0)
commit_oid1 = LibGit2.commit(repo, "commit1"; author=sig, committer=sig)
println(repo_file, randstring(10))
flush(repo_file)
LibGit2.add!(repo, test_file)
commit_oid2 = LibGit2.commit(repo, "commit2"; author=sig, committer=sig)

# will be a Vector of [sig, sig]
auths = LibGit2.authors(repo)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L796-L820}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7529731371760227900}{} 
\hyperlink{7529731371760227900}{\texttt{Base.LibGit2.branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
branch(repo::GitRepo)
\end{lstlisting}

Equivalent to \texttt{git branch}. Create a new branch from the current HEAD.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L353-L358}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16490557174026522942}{} 
\hyperlink{16490557174026522942}{\texttt{Base.LibGit2.branch!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
branch!(repo::GitRepo, branch_name::AbstractString, commit::AbstractString=""; kwargs...)
\end{lstlisting}

Checkout a new git branch in the \texttt{repo} repository. \texttt{commit} is the \hyperlink{11729713909743491089}{\texttt{GitHash}}, in string form, which will be the start of the new branch. If \texttt{commit} is an empty string, the current HEAD will be used.

The keyword arguments are:

\begin{itemize}
\item \texttt{track::AbstractString={\textquotedbl}{\textquotedbl}}: the name of the remote branch this new branch should track, if any. If empty (the default), no remote branch will be tracked.


\item \texttt{force::Bool=false}: if \texttt{true}, branch creation will be forced.


\item \texttt{set\_head::Bool=true}: if \texttt{true}, after the branch creation finishes the branch head will be set as the HEAD of \texttt{repo}.

\end{itemize}
Equivalent to \texttt{git checkout [-b|-B] <branch\_name> [<commit>] [--track <track>]}.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.branch!(repo, "new_branch", set_head=false)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L368-L393}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5707429819745125730}{} 
\hyperlink{5707429819745125730}{\texttt{Base.LibGit2.checkout!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
checkout!(repo::GitRepo, commit::AbstractString=""; force::Bool=true)
\end{lstlisting}

Equivalent to \texttt{git checkout [-f] --detach <commit>}. Checkout the git commit \texttt{commit} (a \hyperlink{11729713909743491089}{\texttt{GitHash}} in string form) in \texttt{repo}. If \texttt{force} is \texttt{true}, force the checkout and discard any current changes. Note that this detaches the current HEAD.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.init(repo_path)
open(joinpath(LibGit2.path(repo), "file1"), "w") do f
    write(f, "111
")
end
LibGit2.add!(repo, "file1")
commit_oid = LibGit2.commit(repo, "add file1")
open(joinpath(LibGit2.path(repo), "file1"), "w") do f
    write(f, "112
")
end
# would fail without the force=true
# since there are modifications to the file
LibGit2.checkout!(repo, string(commit_oid), force=true)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L460-L486}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13717578412386871751}{} 
\hyperlink{13717578412386871751}{\texttt{Base.LibGit2.checkused!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Checks if credentials were used



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L124}{\texttt{source}}


Checks if credentials were used or failed authentication, see \texttt{LibGit2.credentials\_callback}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L726}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18159548566765472401}{} 
\hyperlink{18159548566765472401}{\texttt{Base.LibGit2.clone}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
clone(repo_url::AbstractString, repo_path::AbstractString; kwargs...)
\end{lstlisting}

Clone a remote repository located at \texttt{repo\_url} to the local filesystem location \texttt{repo\_path}.

The keyword arguments are:

\begin{itemize}
\item \texttt{branch::AbstractString={\textquotedbl}{\textquotedbl}}: which branch of the remote to clone, if not the default repository branch (usually \texttt{master}).


\item \texttt{isbare::Bool=false}: if \texttt{true}, clone the remote as a bare repository, which will make \texttt{repo\_path} itself the git directory instead of \texttt{repo\_path/.git}. This means that a working tree cannot be checked out. Plays the role of the git CLI argument \texttt{--bare}.


\item \texttt{remote\_cb::Ptr\{Void\}=C\_NULL}: a callback which will be used to create the remote before it is cloned. If \texttt{C\_NULL} (the default), no attempt will be made to create the remote - it will be assumed to already exist.


\item \texttt{payload::Nullable\{P<:AbstractCredentials\}=Nullable\{AbstractCredentials\}()}: provides credentials if necessary, for instance if the remote is a private repository.

\end{itemize}
Equivalent to \texttt{git clone [-b <branch>] [--bare] <repo\_url> <repo\_path>}.

\textbf{Examples}


\begin{minted}{julia}
repo_url = "https://github.com/JuliaLang/Example.jl"
repo1 = LibGit2.clone(repo_url, "test_path")
repo2 = LibGit2.clone(repo_url, "test_path", isbare=true)
julia_url = "https://github.com/JuliaLang/julia"
julia_repo = LibGit2.clone(julia_url, "julia_path", branch="release-0.6")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L516-L546}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8015520027139814727}{} 
\hyperlink{8015520027139814727}{\texttt{Base.LibGit2.commit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Wrapper around \texttt{git\_commit\_create} 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/commit.jl#L31}{\texttt{source}}


Commit changes to repository



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/commit.jl#L54}{\texttt{source}}



\begin{lstlisting}
LibGit2.commit(rb::GitRebase, sig::GitSignature)
\end{lstlisting}

Commits the current patch to the rebase \texttt{rb}, using \texttt{sig} as the committer. Is silent if the commit has already been applied.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/rebase.jl#L52-L57}{\texttt{source}}


\end{adjustwidth}
\hypertarget{90213436121178284}{} 
\hyperlink{90213436121178284}{\texttt{Base.LibGit2.create\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.create_branch(repo::GitRepo, bname::AbstractString, commit_obj::GitCommit; force::Bool=false)
\end{lstlisting}

Create a new branch in the repository \texttt{repo} with name \texttt{bname}, which points to commit \texttt{commit\_obj} (which has to be part of \texttt{repo}). If \texttt{force} is \texttt{true}, overwrite an existing branch named \texttt{bname} if it exists. If \texttt{force} is \texttt{false} and a branch already exists named \texttt{bname}, this function will throw an error.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L196-L204}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6849925087630414730}{} 
\hyperlink{6849925087630414730}{\texttt{Base.LibGit2.credentials\_callback}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Credentials callback function

Function provides different credential acquisition functionality w.r.t. a connection protocol. If a payload is provided then \texttt{payload\_ptr} should contain a \texttt{LibGit2.AbstractCredentials} object.

For \texttt{LibGit2.Consts.CREDTYPE\_USERPASS\_PLAINTEXT} type, if the payload contains fields: \texttt{user} \& \texttt{pass}, they are used to create authentication credentials. Empty \texttt{user} name and \texttt{pass}word trigger an authentication error.

For \texttt{LibGit2.Consts.CREDTYPE\_SSH\_KEY} type, if the payload contains fields: \texttt{user}, \texttt{prvkey}, \texttt{pubkey} \& \texttt{pass}, they are used to create authentication credentials. Empty \texttt{user} name triggers an authentication error.

Credentials are checked in the following order (if supported):

\begin{itemize}
\item ssh key pair (\texttt{ssh-agent} if specified in payload{\textquotesingle}s \texttt{usesshagent} field)


\item plain text

\end{itemize}
\textbf{Note}: Due to the specifics of the \texttt{libgit2} authentication procedure, when authentication fails, this function is called again without any indication whether authentication was successful or not. To avoid an infinite loop from repeatedly using the same faulty credentials, the \texttt{checkused!} function can be called. This function returns \texttt{true} if the credentials were used. Using credentials triggers a user prompt for (re)entering required information. \texttt{UserPasswordCredentials} and \texttt{CachedCredentials} are implemented using a call counting strategy that prevents repeated usage of faulty credentials.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L174-L200}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11853180090558191138}{} 
\hyperlink{11853180090558191138}{\texttt{Base.LibGit2.credentials\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{credentials\_callback}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L262}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18313327697666700414}{} 
\hyperlink{18313327697666700414}{\texttt{Base.LibGit2.default\_signature}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Return signature object. Free it after use.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/signature.jl#L45}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12407359090434445324}{} 
\hyperlink{12407359090434445324}{\texttt{Base.LibGit2.delete\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.delete_branch(branch::GitReference)
\end{lstlisting}

Delete the branch pointed to by \texttt{branch}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L216-L220}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9650551889728428786}{} 
\hyperlink{9650551889728428786}{\texttt{Base.LibGit2.diff\_files}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
diff_files(repo::GitRepo, branch1::AbstractString, branch2::AbstractString; kwarg...) -> Vector{AbstractString}
\end{lstlisting}

Show which files have changed in the git repository \texttt{repo} between branches \texttt{branch1} and \texttt{branch2}.

The keyword argument is:

\begin{itemize}
\item \texttt{filter::Set\{Consts.DELTA\_STATUS\}=Set([Consts.DELTA\_ADDED, Consts.DELTA\_MODIFIED, Consts.DELTA\_DELETED]))}, and it sets options for the diff. The default is to show files added, modified, or deleted.

\end{itemize}
Returns only the \emph{names} of the files which have changed, \emph{not} their contents.

\textbf{Example}


\begin{minted}{julia}
LibGit2.branch!(repo, "branch/a")
LibGit2.branch!(repo, "branch/b")
# add a file to repo
open(joinpath(LibGit2.path(repo),"file"),"w") do f
    write(f, "hello repo
")
end
LibGit2.add!(repo, "file")
LibGit2.commit(repo, "add file")
# returns ["file"]
filt = Set([LibGit2.Consts.DELTA_ADDED])
files = LibGit2.diff_files(repo, "branch/a", "branch/b", filter=filt)
# returns [] because existing files weren't modified
filt = Set([LibGit2.Consts.DELTA_MODIFIED])
files = LibGit2.diff_files(repo, "branch/a", "branch/b", filter=filt)
\end{minted}

Equivalent to \texttt{git diff --name-only --diff-filter=<filter> <branch1> <branch2>}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L158-L191}{\texttt{source}}


\end{adjustwidth}
\hypertarget{986549586834995629}{} 
\hyperlink{986549586834995629}{\texttt{Base.LibGit2.fetch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch(rmt::GitRemote, refspecs; options::FetchOptions=FetchOptions(), msg="")
\end{lstlisting}

Fetch from the specified \texttt{rmt} remote git repository, using \texttt{refspecs} to determine which remote branch(es) to fetch. The keyword arguments are:

\begin{itemize}
\item \texttt{options}: determines the options for the fetch, e.g. whether to prune afterwards.


\item \texttt{msg}: a message to insert into the reflogs.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L213-L221}{\texttt{source}}



\begin{lstlisting}
fetch(repo::GitRepo; kwargs...)
\end{lstlisting}

Fetches updates from an upstream of the repository \texttt{repo}.

The keyword arguments are:

\begin{itemize}
\item \texttt{remote::AbstractString={\textquotedbl}origin{\textquotedbl}}: which remote, specified by name, of \texttt{repo} to fetch from. If this is empty, the URL will be used to construct an anonymous remote.


\item \texttt{remoteurl::AbstractString={\textquotedbl}{\textquotedbl}}: the URL of \texttt{remote}. If not specified, will be assumed based on the given name of \texttt{remote}.


\item \texttt{refspecs=AbstractString[]}: determines properties of the fetch.


\item \texttt{payload=Nullable\{AbstractCredentials\}()}: provides credentials, if necessary, for instance if \texttt{remote} is a private repository.

\end{itemize}
Equivalent to \texttt{git fetch [<remoteurl>|<repo>] [<refspecs>]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L283-L299}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15757709840137244772}{} 
\hyperlink{15757709840137244772}{\texttt{Base.LibGit2.fetch\_refspecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
fetch_refspecs(rmt::GitRemote) -> Vector{String}
\end{lstlisting}

Get the \emph{fetch} refspecs for the specified \texttt{rmt}. These refspecs contain information about which branch(es) to fetch from.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L135-L140}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14408966997565353703}{} 
\hyperlink{14408966997565353703}{\texttt{Base.LibGit2.fetchhead\_foreach\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{fetchhead\_foreach\_callback}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L264}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13775282676052107168}{} 
\hyperlink{13775282676052107168}{\texttt{Base.LibGit2.ffmerge!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Fastforward merge changes into current head 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/merge.jl#L48}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2101614122740166538}{} 
\hyperlink{2101614122740166538}{\texttt{Base.LibGit2.fullname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.fullname(ref::GitReference)
\end{lstlisting}

Return the name of the reference pointed to by the symbolic reference \texttt{ref}. If \texttt{ref} is not a symbolic reference, returns an empty string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L82-L88}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15231887986622283392}{} 
\hyperlink{15231887986622283392}{\texttt{Base.LibGit2.get\_creds!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Obtain the cached credentials for the given host+protocol (credid), or return and store the default if not found



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L735}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16866457035365582078}{} 
\hyperlink{16866457035365582078}{\texttt{Base.LibGit2.gitdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.gitdir(repo::GitRepo)
\end{lstlisting}

Returns the location of the {\textquotedbl}git{\textquotedbl} files of \texttt{repo}:

\begin{itemize}
\item for normal repositories, this is the location of the \texttt{.git} folder.


\item for bare repositories, this is the location of the repository itself.

\end{itemize}
See also \hyperlink{10392492346200898016}{\texttt{workdir}}, \hyperlink{13913454255383065948}{\texttt{path}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L150-L159}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1596718389164397217}{} 
\hyperlink{1596718389164397217}{\texttt{Base.LibGit2.head}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.head(repo::GitRepo) -> GitReference
\end{lstlisting}

Returns a \texttt{GitReference} to the current HEAD of \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L33-L37}{\texttt{source}}



\begin{lstlisting}
head(pkg::AbstractString) -> String
\end{lstlisting}

Return current HEAD \hyperlink{11729713909743491089}{\texttt{GitHash}} of the \texttt{pkg} repo as a string.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L45-L50}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3725624338522540950}{} 
\hyperlink{3725624338522540950}{\texttt{Base.LibGit2.head!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.head!(repo::GitRepo, ref::GitReference) -> GitReference
\end{lstlisting}

Set the HEAD of \texttt{repo} to the object pointed to by \texttt{ref}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L225-L229}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5805768163693010277}{} 
\hyperlink{5805768163693010277}{\texttt{Base.LibGit2.head\_oid}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.head_oid(repo::GitRepo) -> GitHash
\end{lstlisting}

Lookup the object id of the current HEAD of git repository \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L50-L55}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16596027723028346855}{} 
\hyperlink{16596027723028346855}{\texttt{Base.LibGit2.headname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.headname(repo::GitRepo)
\end{lstlisting}

Lookup the name of the current HEAD of git repository \texttt{repo}. If \texttt{repo} is currently detached, returns the name of the HEAD it{\textquotesingle}s detached from.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L65-L72}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18237439440894670990}{} 
\hyperlink{18237439440894670990}{\texttt{Base.LibGit2.init}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.init(path::AbstractString, bare::Bool=false) -> GitRepo
\end{lstlisting}

Opens a new git repository at \texttt{path}. If \texttt{bare} is \texttt{false}, the working tree will be created in \texttt{path/.git}. If \texttt{bare} is \texttt{true}, no working directory will be created.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L36-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{647625840513024826}{} 
\hyperlink{647625840513024826}{\texttt{Base.LibGit2.is\_ancestor\_of}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
is_ancestor_of(a::AbstractString, b::AbstractString, repo::GitRepo) -> Bool
\end{lstlisting}

Returns \texttt{true} if \texttt{a}, a \hyperlink{11729713909743491089}{\texttt{GitHash}} in string form, is an ancestor of \texttt{b}, a \hyperlink{11729713909743491089}{\texttt{GitHash}} in string form.

\textbf{Example}


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file1);

julia> commit_oid1 = LibGit2.commit(repo, "commit1");

julia> LibGit2.add!(repo, test_file2);

julia> commit_oid2 = LibGit2.commit(repo, "commit2");

julia> LibGit2.is_ancestor_of(string(commit_oid1), string(commit_oid2), repo)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L215-L237}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5620297776309259546}{} 
\hyperlink{5620297776309259546}{\texttt{Base.LibGit2.isbinary}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Use a heuristic to guess if a file is binary: searching for NULL bytes and looking for a reasonable ratio of printable to non-printable characters among the first 8000 bytes.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/blob.jl#L26-L30}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2380274570565820861}{} 
\hyperlink{2380274570565820861}{\texttt{Base.LibGit2.iscommit}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
iscommit(id::AbstractString, repo::GitRepo) -> Bool
\end{lstlisting}

Checks if commit \texttt{id} (which is a \hyperlink{11729713909743491089}{\texttt{GitHash}} in string form) is in the repository.

\textbf{Example}


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file);

julia> commit_oid = LibGit2.commit(repo, "add test_file");

julia> LibGit2.iscommit(string(commit_oid), repo)
true
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L70-L88}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16959496514282254576}{} 
\hyperlink{16959496514282254576}{\texttt{Base.LibGit2.isdiff}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.isdiff(repo::GitRepo, treeish::AbstractString, pathspecs::AbstractString=""; cached::Bool=false)
\end{lstlisting}

Checks if there are any differences between the tree specified by \texttt{treeish} and the tracked files in the working tree (if \texttt{cached=false}) or the index (if \texttt{cached=true}). \texttt{pathspecs} are the specifications for options for the diff.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.isdiff(repo, "HEAD") # should be false
open(joinpath(repo_path, new_file), "a") do f
    println(f, "here's my cool new file")
end
LibGit2.isdiff(repo, "HEAD") # now true
\end{minted}

Equivalent to \texttt{git diff-index <treeish> [-- <pathspecs>]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L127-L145}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12235718469896960833}{} 
\hyperlink{12235718469896960833}{\texttt{Base.LibGit2.isdirty}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.isdirty(repo::GitRepo, pathspecs::AbstractString=""; cached::Bool=false) -> Bool
\end{lstlisting}

Checks if there have been any changes to tracked files in the working tree (if \texttt{cached=false}) or the index (if \texttt{cached=true}). \texttt{pathspecs} are the specifications for options for the diff.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
LibGit2.isdirty(repo) # should be false
open(joinpath(repo_path, new_file), "a") do f
    println(f, "here's my cool new file")
end
LibGit2.isdirty(repo) # now true
LibGit2.isdirty(repo, new_file) # now true
\end{minted}

Equivalent to \texttt{git diff-index HEAD [-- <pathspecs>]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L104-L123}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9719872750978870564}{} 
\hyperlink{9719872750978870564}{\texttt{Base.LibGit2.isorphan}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.isorphan(repo::GitRepo)
\end{lstlisting}

Checks if the current branch is an {\textquotedbl}orphan{\textquotedbl} branch, i.e. has no commits. The first commit to this branch will have no parents.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L21-L26}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10123552102874129630}{} 
\hyperlink{10123552102874129630}{\texttt{Base.LibGit2.lookup\_branch}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
lookup_branch(repo::GitRepo, branch_name::AbstractString, remote::Bool=false) -> Nullable{GitReference}
\end{lstlisting}

Determine if the branch specified by \texttt{branch\_name} exists in the repository \texttt{repo}. If \texttt{remote} is \texttt{true}, \texttt{repo} is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.

\texttt{lookup\_branch} returns a \hyperlink{2208920129454296646}{\texttt{Nullable}}, which will be null if the requested branch does not exist yet. If the branch does exist, the \texttt{Nullable} contains a \texttt{GitReference} to the branch.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L237-L247}{\texttt{source}}


\end{adjustwidth}
\hypertarget{5410497471460368983}{} 
\hyperlink{5410497471460368983}{\texttt{Base.LibGit2.mirror\_callback}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Mirror callback function

Function sets \texttt{+refs/*:refs/*} refspecs and \texttt{mirror} flag for remote reference.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11820499806800583259}{} 
\hyperlink{11820499806800583259}{\texttt{Base.LibGit2.mirror\_cb}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

C function pointer for \texttt{mirror\_callback}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/callbacks.jl#L260}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15918563895809262557}{} 
\hyperlink{15918563895809262557}{\texttt{Base.LibGit2.name}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.name(ref::GitReference)
\end{lstlisting}

Return the full name of \texttt{ref}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L97-L101}{\texttt{source}}



\begin{lstlisting}
name(rmt::GitRemote)
\end{lstlisting}

Get the name of a remote repository, for instance \texttt{{\textquotedbl}origin{\textquotedbl}}. If the remote is anonymous (see \hyperlink{5869419718818609673}{\texttt{GitRemoteAnon}}) the name will be an empty string \texttt{{\textquotedbl}{\textquotedbl}}.

\textbf{Example}


\begin{minted}{jlcon}
julia> repo_url = "https://github.com/JuliaLang/Example.jl";

julia> repo = LibGit2.clone(cache_repo, "test_directory");

julia> remote = LibGit2.GitRemote(repo, "origin", repo_url);

julia> name(remote)
"origin"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L109-L128}{\texttt{source}}



\begin{lstlisting}
LibGit2.name(tag::GitTag)
\end{lstlisting}

The name of \texttt{tag} (e.g. \texttt{{\textquotedbl}v0.5{\textquotedbl}}).



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L54-L58}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15134808631028226443}{} 
\hyperlink{15134808631028226443}{\texttt{Base.LibGit2.need\_update}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
need_update(repo::GitRepo)
\end{lstlisting}

Equivalent to \texttt{git update-index}. Returns \texttt{true} if \texttt{repo} needs updating.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L57-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3103116791152363577}{} 
\hyperlink{3103116791152363577}{\texttt{Base.LibGit2.objtype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
objtype(obj_type::Consts.OBJECT)
\end{lstlisting}

Returns the type corresponding to the enum value.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L640-L644}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13913454255383065948}{} 
\hyperlink{13913454255383065948}{\texttt{Base.LibGit2.path}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.path(repo::GitRepo)
\end{lstlisting}

The base file path of the repository \texttt{repo}.

\begin{itemize}
\item for normal repositories, this will typically be the parent directory of the {\textquotedbl}.git{\textquotedbl} directory (note: this may be different than the working directory, see \texttt{workdir} for more details).


\item for bare repositories, this is the location of the {\textquotedbl}git{\textquotedbl} files.

\end{itemize}
See also \hyperlink{16866457035365582078}{\texttt{gitdir}}, \hyperlink{10392492346200898016}{\texttt{workdir}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L186-L197}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12737959515263495066}{} 
\hyperlink{12737959515263495066}{\texttt{Base.LibGit2.peel}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
peel([T,] ref::GitReference)
\end{lstlisting}

Recursively peel \texttt{ref} until an object of type \texttt{T} is obtained. If no \texttt{T} is provided, then \texttt{ref} will be peeled until an object other than a \hyperlink{16990398329245524657}{\texttt{GitTag}} is obtained.

\begin{itemize}
\item A \texttt{GitTag} will be peeled to the object it references.


\item A \hyperlink{10902694404628649896}{\texttt{GitCommit}} will be peeled to a \hyperlink{15098307424713644345}{\texttt{GitTree}}.

\end{itemize}
\begin{quote}
\textbf{Note}

Only annotated tags can be peeled to \texttt{GitTag} objects. Lightweight tags (the default) are references under \texttt{refs/tags/} which point directly to \texttt{GitCommit} objects.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L161-L173}{\texttt{source}}



\begin{lstlisting}
peel([T,] obj::GitObject)
\end{lstlisting}

Recursively peel \texttt{obj} until an object of type \texttt{T} is obtained. If no \texttt{T} is provided, then \texttt{obj} will be peeled until the type changes.

\begin{itemize}
\item A \texttt{GitTag} will be peeled to the object it references.


\item A \texttt{GitCommit} will be peeled to a \texttt{GitTree}.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L211-L219}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11783394155628254030}{} 
\hyperlink{11783394155628254030}{\texttt{Base.LibGit2.posixpath}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.posixpath(path)
\end{lstlisting}

Standardise the path string \texttt{path} to use POSIX separators.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/utils.jl#L57-L61}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10329292874321123591}{} 
\hyperlink{10329292874321123591}{\texttt{Base.LibGit2.push}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
push(rmt::GitRemote, refspecs; force::Bool=false, options::PushOptions=PushOptions())
\end{lstlisting}

Push to the specified \texttt{rmt} remote git repository, using \texttt{refspecs} to determine which remote branch(es) to push to. The keyword arguments are:

\begin{itemize}
\item \texttt{force}: if \texttt{true}, a force-push will occur, disregarding conflicts.


\item \texttt{options}: determines the options for the push, e.g. which proxy headers to use.

\end{itemize}
\begin{quote}
\textbf{Note}

You can add information about the push refspecs in two other ways: by setting an option in the repository{\textquotesingle}s \texttt{GitConfig} (with \texttt{push.default} as the key) or by calling \hyperlink{3465864374577161747}{\texttt{add\_push!}}. Otherwise you will need to explicitly specify a push refspec in the call to \texttt{push} for it to have any effect, like so: \texttt{LibGit2.push(repo, refspecs=[{\textquotedbl}refs/heads/master{\textquotedbl}])}.

\end{quote}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L231-L246}{\texttt{source}}



\begin{lstlisting}
push(repo::GitRepo; kwargs...)
\end{lstlisting}

Pushes updates to an upstream of \texttt{repo}.

The keyword arguments are:

\begin{itemize}
\item \texttt{remote::AbstractString={\textquotedbl}origin{\textquotedbl}}: the name of the upstream remote to push to.


\item \texttt{remoteurl::AbstractString={\textquotedbl}{\textquotedbl}}: the URL of \texttt{remote}.


\item \texttt{refspecs=AbstractString[]}: determines properties of the push.


\item \texttt{force::Bool=false}: determines if the push will be a force push,  overwriting the remote branch.


\item \texttt{payload=Nullable\{AbstractCredentials\}()}: provides credentials, if necessary, for instance if \texttt{remote} is a private repository.

\end{itemize}
Equivalent to \texttt{git push [<remoteurl>|<repo>] [<refspecs>]}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L318-L333}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11244759000543317713}{} 
\hyperlink{11244759000543317713}{\texttt{Base.LibGit2.push\_refspecs}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
push_refspecs(rmt::GitRemote) -> Vector{String}
\end{lstlisting}

Get the \emph{push} refspecs for the specified \texttt{rmt}. These refspecs contain information about which branch(es) to push to.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L150-L155}{\texttt{source}}


\end{adjustwidth}
\hypertarget{8999395691087615315}{} 
\hyperlink{8999395691087615315}{\texttt{Base.LibGit2.read\_tree!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.read_tree!(idx::GitIndex, tree::GitTree)
LibGit2.read_tree!(idx::GitIndex, treehash::AbstractGitHash)
\end{lstlisting}

Read the tree \texttt{tree} (or the tree pointed to by \texttt{treehash} in the repository owned by \texttt{idx}) into the index \texttt{idx}. The current index contents will be replaced.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/index.jl#L35-L41}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15622902401322805260}{} 
\hyperlink{15622902401322805260}{\texttt{Base.LibGit2.rebase!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.rebase!(repo::GitRepo, upstream::AbstractString="", newbase::AbstractString="")
\end{lstlisting}

Attempt an automatic merge rebase of the current branch, from \texttt{upstream} if provided, or otherwise from the upstream tracking branch. \texttt{newbase} is the branch to rebase onto. By default this is \texttt{upstream}.

If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a \texttt{GitError}. This is roughly equivalent to the following command line statement:


\begin{lstlisting}
git rebase --merge [<upstream>]
if [ -d ".git/rebase-merge" ]; then
    git rebase --abort
fi
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L730-L746}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3201078861145586006}{} 
\hyperlink{3201078861145586006}{\texttt{Base.LibGit2.ref\_list}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.ref_list(repo::GitRepo) -> Vector{String}
\end{lstlisting}

Get a list of all reference names in the \texttt{repo} repository.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L182-L186}{\texttt{source}}


\end{adjustwidth}
\hypertarget{2955019549210743587}{} 
\hyperlink{2955019549210743587}{\texttt{Base.LibGit2.reftype}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.reftype(ref::GitReference) -> Cint
\end{lstlisting}

Returns a \texttt{Cint} corresponding to the type of \texttt{ref}:

\begin{itemize}
\item \texttt{0} if the reference is invalid


\item \texttt{1} if the reference is an object id


\item \texttt{2} if the reference is symbolic

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L70-L77}{\texttt{source}}


\end{adjustwidth}
\hypertarget{15080577271661897126}{} 
\hyperlink{15080577271661897126}{\texttt{Base.LibGit2.remotes}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.remotes(repo::GitRepo)
\end{lstlisting}

Returns a vector of the names of the remotes of \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L291-L295}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14091044399468968783}{} 
\hyperlink{14091044399468968783}{\texttt{Base.LibGit2.reset!}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Resets credentials for another use



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L127}{\texttt{source}}


Updates some entries, determined by the \texttt{pathspecs}, in the index from the target commit tree.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L253}{\texttt{source}}


Sets the current head to the specified commit oid and optionally resets the index and working tree to match.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L263}{\texttt{source}}


git reset [<committish>] [–] <pathspecs>... 



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L565}{\texttt{source}}



\begin{lstlisting}
reset!(repo::GitRepo, id::GitHash, mode::Cint = Consts.RESET_MIXED)
\end{lstlisting}

Reset the repository \texttt{repo} to its state at \texttt{id}, using one of three modes set by \texttt{mode}:

\begin{itemize}
\item[1. ] \texttt{Consts.RESET\_SOFT} - move HEAD to \texttt{id}.


\item[2. ] \texttt{Consts.RESET\_MIXED} - default, move HEAD to \texttt{id} and reset the index to \texttt{id}.


\item[3. ] \texttt{Consts.RESET\_HARD} - move HEAD to \texttt{id}, reset the index to \texttt{id}, and discard all working changes.

\end{itemize}
Equivalent to \texttt{git reset [--soft | --mixed | --hard] <id>}.

\textbf{Example}


\begin{minted}{julia}
repo = LibGit2.GitRepo(repo_path)
head_oid = LibGit2.head_oid(repo)
open(joinpath(repo_path, "file1"), "w") do f
    write(f, "111
")
end
LibGit2.add!(repo, "file1")
mode = LibGit2.Consts.RESET_HARD
# will discard the changes to file1
# and unstage it
new_head = LibGit2.reset!(repo, head_oid, mode)
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L572-L598}{\texttt{source}}


\end{adjustwidth}
\hypertarget{18295332994346533363}{} 
\hyperlink{18295332994346533363}{\texttt{Base.LibGit2.restore}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
restore(s::State, repo::GitRepo)
\end{lstlisting}

Return a repository \texttt{repo} to a previous \texttt{State} \texttt{s}, for example the HEAD of a branch before a merge attempt. \texttt{s} can be generated using the \hyperlink{3573482892097004589}{\texttt{snapshot}} function.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L859-L865}{\texttt{source}}


\end{adjustwidth}
\hypertarget{17483802022298804690}{} 
\hyperlink{17483802022298804690}{\texttt{Base.LibGit2.revcount}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.revcount(repo::GitRepo, commit1::AbstractString, commit2::AbstractString)
\end{lstlisting}

List the number of revisions between \texttt{commit1} and \texttt{commit2} (committish OIDs in string form). Since \texttt{commit1} and \texttt{commit2} may be on different branches, \texttt{revcount} performs a {\textquotedbl}left-right{\textquotedbl} revision list (and count), returning a tuple of \texttt{Int}s - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.

Equivalent to \texttt{git rev-list --left-right --count <commit1> <commit2>}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L601-L611}{\texttt{source}}


\end{adjustwidth}
\hypertarget{6474240678825000223}{} 
\hyperlink{6474240678825000223}{\texttt{Base.LibGit2.set\_remote\_url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
set_remote_url(repo::GitRepo, url::AbstractString; remote::AbstractString="origin")
\end{lstlisting}

Set the \texttt{url} for \texttt{remote} for the git repository \texttt{repo}. The default name of the remote is \texttt{{\textquotedbl}origin{\textquotedbl}}.

\textbf{Examples}


\begin{minted}{julia}
repo_path = joinpath("test_directory", "Example")
repo = LibGit2.init(repo_path)
url1 = "https://github.com/JuliaLang/Example.jl"
LibGit2.set_remote_url(repo, url1, remote="upstream")
url2 = "https://github.com/JuliaLang/Example2.jl"
LibGit2.set_remote_url(repo_path, url2, remote="upstream2")
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L243-L259}{\texttt{source}}



\begin{lstlisting}
set_remote_url(path::AbstractString, url::AbstractString; remote::AbstractString="origin")
\end{lstlisting}

Set the \texttt{url} for \texttt{remote} for the git repository located at \texttt{path}. The default name of the remote is \texttt{{\textquotedbl}origin{\textquotedbl}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L267-L272}{\texttt{source}}


\end{adjustwidth}
\hypertarget{1013553266138092396}{} 
\hyperlink{1013553266138092396}{\texttt{Base.LibGit2.shortname}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.shortname(ref::GitReference)
\end{lstlisting}

Returns a shortened version of the name of \texttt{ref} that{\textquotesingle}s {\textquotedbl}human-readable{\textquotedbl}.


\begin{minted}{jlcon}
julia> repo = LibGit2.GitRepo(path_to_repo);

julia> branch_ref = LibGit2.head(repo);

julia> LibGit2.name(branch_ref)
"refs/heads/master"

julia> LibGit2.shortname(branch_ref)
"master"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L45-L62}{\texttt{source}}


\end{adjustwidth}
\hypertarget{3573482892097004589}{} 
\hyperlink{3573482892097004589}{\texttt{Base.LibGit2.snapshot}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
snapshot(repo::GitRepo) -> State
\end{lstlisting}

Take a snapshot of the current state of the repository \texttt{repo}, storing the current HEAD, index, and any uncommitted work. The output \texttt{State} can be used later during a call to \hyperlink{18295332994346533363}{\texttt{restore}} to return the repository to the snapshotted state.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L830-L837}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7028519433729982831}{} 
\hyperlink{7028519433729982831}{\texttt{Base.LibGit2.status}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.status(repo::GitRepo, path::String)
\end{lstlisting}

Lookup the status of the file at \texttt{path} in the git repository \texttt{repo}. For instance, this can be used to check if the file at \texttt{path} has been modified and needs to be staged and committed.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/status.jl#L35-L42}{\texttt{source}}


\end{adjustwidth}
\hypertarget{94175727257767273}{} 
\hyperlink{94175727257767273}{\texttt{Base.LibGit2.tag\_create}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.tag_create(repo::GitRepo, tag::AbstractString, commit; kwargs...)
\end{lstlisting}

Create a new git tag \texttt{tag} (e.g. \texttt{{\textquotedbl}v0.5{\textquotedbl}}) in the repository \texttt{repo}, at the commit \texttt{commit}.

The keyword arguments are:

\begin{itemize}
\item \texttt{msg::AbstractString={\textquotedbl}{\textquotedbl}}: the message for the tag.


\item \texttt{force::Bool=false}: if \texttt{true}, existing references will be overwritten.


\item \texttt{sig::Signature=Signature(repo)}: the tagger{\textquotesingle}s signature.

\end{itemize}


\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L27-L37}{\texttt{source}}


\end{adjustwidth}
\hypertarget{14194677754403893948}{} 
\hyperlink{14194677754403893948}{\texttt{Base.LibGit2.tag\_delete}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.tag_delete(repo::GitRepo, tag::AbstractString)
\end{lstlisting}

Remove the git tag \texttt{tag} from the repository \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L17-L21}{\texttt{source}}


\end{adjustwidth}
\hypertarget{9177015962950322666}{} 
\hyperlink{9177015962950322666}{\texttt{Base.LibGit2.tag\_list}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.tag_list(repo::GitRepo) -> Vector{String}
\end{lstlisting}

Get a list of all tags in the git repository \texttt{repo}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L3-L7}{\texttt{source}}


\end{adjustwidth}
\hypertarget{12586651171771696639}{} 
\hyperlink{12586651171771696639}{\texttt{Base.LibGit2.target}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.target(tag::GitTag)
\end{lstlisting}

The \texttt{GitHash} of the target object of \texttt{tag}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tag.jl#L66-L70}{\texttt{source}}


\end{adjustwidth}
\hypertarget{13475696991682268787}{} 
\hyperlink{13475696991682268787}{\texttt{Base.LibGit2.treewalk}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Traverse the entries in a tree and its subtrees in post or pre order.

Function parameter should have following signature:


\begin{lstlisting}
(Cstring, Ptr{Void}, Ptr{Void}) -> Cint
\end{lstlisting}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/tree.jl#L3-L9}{\texttt{source}}


\end{adjustwidth}
\hypertarget{11657151798206740880}{} 
\hyperlink{11657151798206740880}{\texttt{Base.LibGit2.upstream}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
upstream(ref::GitReference) -> Nullable{GitReference}
\end{lstlisting}

Determine if the branch containing \texttt{ref} has a specified upstream branch.

\texttt{upstream} returns a \hyperlink{2208920129454296646}{\texttt{Nullable}}, which will be null if the requested branch does not have an upstream counterpart. If the upstream branch does exist, the \texttt{Nullable} contains a \texttt{GitReference} to the upstream branch.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/reference.jl#L268-L276}{\texttt{source}}


\end{adjustwidth}
\hypertarget{16448994131242205782}{} 
\hyperlink{16448994131242205782}{\texttt{Base.LibGit2.url}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
url(rmt::GitRemote)
\end{lstlisting}

Get the fetch URL of a remote git repository.

\textbf{Example}


\begin{minted}{jlcon}
julia> repo_url = "https://github.com/JuliaLang/Example.jl";

julia> repo = LibGit2.init(mktempdir());

julia> remote = LibGit2.GitRemote(repo, "origin", repo_url);

julia> LibGit2.url(remote)
"https://github.com/JuliaLang/Example.jl"
\end{minted}



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/remote.jl#L74-L91}{\texttt{source}}


\end{adjustwidth}
\hypertarget{7557388719652218483}{} 
\hyperlink{7557388719652218483}{\texttt{Base.LibGit2.with}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}

Resource management helper function



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/types.jl#L604-L606}{\texttt{source}}


\end{adjustwidth}
\hypertarget{10392492346200898016}{} 
\hyperlink{10392492346200898016}{\texttt{Base.LibGit2.workdir}}  -- {Function.}

\begin{adjustwidth}{2em}{0pt}


\begin{lstlisting}
LibGit2.workdir(repo::GitRepo)
\end{lstlisting}

The location of the working directory of \texttt{repo}. This will throw an error for bare repositories.

\begin{quote}
\textbf{Note}

This will typically be the parent directory of \texttt{gitdir(repo)}, but can be different in some cases: e.g. if either the \texttt{core.worktree} configuration variable or the \texttt{GIT\_WORK\_TREE} environment variable is set.

\end{quote}
See also \hyperlink{16866457035365582078}{\texttt{gitdir}}, \hyperlink{13913454255383065948}{\texttt{path}}.



\href{https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/repository.jl#L165-L178}{\texttt{source}}


\end{adjustwidth}

\hypertarget{4726389115529362401}{}


\section{Module loading}



\texttt{Base.require}[@ref] is responsible for loading modules and it also manages the precompilation cache. It is the implementation of the \texttt{import} statement.



\hypertarget{8895570116735182580}{}


\subsection{Experimental features}



The features below are experimental and not part of the stable Julia API. Before building upon them inform yourself about the current thinking and whether they might change soon.



\hypertarget{14149276766401458683}{}


\subsubsection{Module loading callbacks}



It is possible to listen to the modules loaded by \texttt{Base.require}, by registering a callback.




\begin{minted}{julia}
loaded_packages = Channel{Symbol}()
callback = (mod::Symbol) -> put!(loaded_packages, mod)
push!(Base.package_callbacks, callback)
\end{minted}



Please note that the symbol given to the callback is a non-unique identifier and it is the responsibility of the callback provider to walk the module chain to determine the fully qualified name of the loaded binding.



The callback below is an example of how to do that:




\begin{minted}{julia}
# Get the fully-qualified name of a module.
function module_fqn(name::Symbol)
    fqn = Symbol[name]
    mod = getfield(Main, name)
    parent = Base.module_parent(mod)
    while parent !== Main
        push!(fqn, Base.module_name(parent))
        parent = Base.module_parent(parent)
    end
    fqn = reverse!(fqn)
    return join(fqn, '.')
end
\end{minted}



\chapter{Developing/debugging Julia's C code}


\hypertarget{2099627245904836713}{}


\section{Reporting and analyzing crashes (segfaults)}



So you managed to break Julia.  Congratulations!  Collected here are some general procedures you can undergo for common symptoms encountered when something goes awry.  Including the information from these debugging steps can greatly help the maintainers when tracking down a segfault or trying to figure out why your script is running slower than expected.



If you{\textquotesingle}ve been directed to this page, find the symptom that best matches what you{\textquotesingle}re experiencing and follow the instructions to generate the debugging information requested.  Table of symptoms:



\begin{itemize}
\item \hyperlink{17793108856992155546}{Segfaults during bootstrap (\texttt{sysimg.jl})}


\item \hyperlink{12736555006642116842}{Segfaults when running a script}


\item \hyperlink{15330378602367016422}{Errors during Julia startup}

\end{itemize}


\hypertarget{13046485394122703550}{}


\subsection{Version/Environment info}



No matter the error, we will always need to know what version of Julia you are running. When Julia first starts up, a header is printed out with a version number and date.  If your version is \texttt{0.2.0} or higher, please include the output of \texttt{versioninfo()} in any report you create:




\begin{minted}{jlcon}
julia> versioninfo()
Julia Version 0.6.2
Commit d386e40* (2017-12-13 18:08 UTC)
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz
  WORD_SIZE: 64
  BLAS: libopenblas (NO_LAPACKE DYNAMIC_ARCH NO_AFFINITY Prescott)
  LAPACK: liblapack
  LIBM: libopenlibm
  LLVM: libLLVM-3.9.1 (ORCJIT, broadwell)
\end{minted}



\hypertarget{17793108856992155546}{}


\subsection{Segfaults during bootstrap (\texttt{sysimg.jl})}



Segfaults toward the end of the \texttt{make} process of building Julia are a common symptom of something going wrong while Julia is preparsing the corpus of code in the \texttt{base/} folder.  Many factors can contribute toward this process dying unexpectedly, however it is as often as not due to an error in the C-code portion of Julia, and as such must typically be debugged with a debug build inside of \texttt{gdb}.  Explicitly:



Create a debug build of Julia:




\begin{lstlisting}
$ cd <julia_root>
$ make debug
\end{lstlisting}



Note that this process will likely fail with the same error as a normal \texttt{make} incantation, however this will create a debug executable that will offer \texttt{gdb} the debugging symbols needed to get accurate backtraces.  Next, manually run the bootstrap process inside of \texttt{gdb}:




\begin{lstlisting}
$ cd base/
$ gdb -x ../contrib/debug_bootstrap.gdb
\end{lstlisting}



This will start \texttt{gdb}, attempt to run the bootstrap process using the debug build of Julia, and print out a backtrace if (when) it segfaults.  You may need to hit \texttt{<enter>} a few times to get the full backtrace.  Create a \href{https://gist.github.com}{gist} with the backtrace, the \hyperlink{13046485394122703550}{version info}, and any other pertinent information you can think of and open a new \href{https://github.com/JuliaLang/julia/issues?q=is\%3Aopen}{issue} on Github with a link to the gist.



\hypertarget{12736555006642116842}{}


\subsection{Segfaults when running a script}



The procedure is very similar to \hyperlink{17793108856992155546}{Segfaults during bootstrap (\texttt{sysimg.jl})}.  Create a debug build of Julia, and run your script inside of a debugged Julia process:




\begin{lstlisting}
$ cd <julia_root>
$ make debug
$ gdb --args usr/bin/julia-debug <path_to_your_script>
\end{lstlisting}



Note that \texttt{gdb} will sit there, waiting for instructions.  Type \texttt{r} to run the process, and \texttt{bt} to generate a backtrace once it segfaults:




\begin{lstlisting}
(gdb) r
Starting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl
...
(gdb) bt
\end{lstlisting}



Create a \href{https://gist.github.com}{gist} with the backtrace, the \hyperlink{13046485394122703550}{version info}, and any other pertinent information you can think of and open a new \href{https://github.com/JuliaLang/julia/issues?q=is\%3Aopen}{issue} on Github with a link to the gist.



\hypertarget{15330378602367016422}{}


\subsection{Errors during Julia startup}



Occasionally errors occur during Julia{\textquotesingle}s startup process (especially when using binary distributions, as opposed to compiling from source) such as the following:




\begin{minted}{julia}
$ julia
exec: error -5
\end{minted}



These errors typically indicate something is not getting loaded properly very early on in the bootup phase, and our best bet in determining what{\textquotesingle}s going wrong is to use external tools to audit the disk activity of the \texttt{julia} process:



\begin{itemize}
\item On Linux, use \texttt{strace}:


\begin{lstlisting}
$ strace julia
\end{lstlisting}


\item On OSX, use \texttt{dtruss}:


\begin{lstlisting}
$ dtruss -f julia
\end{lstlisting}

\end{itemize}


Create a \href{https://gist.github.com}{gist} with the \texttt{strace}/ \texttt{dtruss} ouput, the \hyperlink{13046485394122703550}{version info}, and any other pertinent information and open a new \href{https://github.com/JuliaLang/julia/issues?q=is\%3Aopen}{issue} on Github with a link to the gist.



\hypertarget{15861385441225766089}{}


\subsection{Glossary}



A few terms have been used as shorthand in this guide:



\begin{itemize}
\item \texttt{<julia\_root>} refers to the root directory of the Julia source tree; e.g. it should contain folders such as \texttt{base}, \texttt{deps}, \texttt{src}, \texttt{test}, etc.....

\end{itemize}


\hypertarget{10298426124440583682}{}


\section{gdb debugging tips}



\hypertarget{7470105576182008459}{}


\subsection{Displaying Julia variables}



Within \texttt{gdb}, any \texttt{jl\_value\_t*} object \texttt{obj} can be displayed using




\begin{lstlisting}
(gdb) call jl_(obj)
\end{lstlisting}



The object will be displayed in the \texttt{julia} session, not in the gdb session. This is a useful way to discover the types and values of objects being manipulated by Julia{\textquotesingle}s C code.



Similarly, if you{\textquotesingle}re debugging some of Julia{\textquotesingle}s internals (e.g., \texttt{inference.jl}), you can print \texttt{obj} using




\begin{minted}{julia}
ccall(:jl_, Void, (Any,), obj)
\end{minted}



This is a good way to circumvent problems that arise from the order in which julia{\textquotesingle}s output streams are initialized.



Julia{\textquotesingle}s flisp interpreter uses \texttt{value\_t} objects; these can be displayed with \texttt{call fl\_print(fl\_ctx, ios\_stdout, obj)}.



\hypertarget{13194055767125353293}{}


\subsection{Useful Julia variables for Inspecting}



While the addresses of many variables, like singletons, can be be useful to print for many failures, there are a number of additional variables (see \texttt{julia.h} for a complete list) that are even more useful.



\begin{itemize}
\item (when in \texttt{jl\_apply\_generic}) \texttt{mfunc} and \texttt{jl\_uncompress\_ast(mfunc->def, mfunc->code)} :: for figuring out a bit about the call-stack


\item \texttt{jl\_lineno} and \texttt{jl\_filename} :: for figuring out what line in a test to go start debugging from (or figure out how far into a file has been parsed)


\item \texttt{\$1} :: not really a variable, but still a useful shorthand for referring to the result of the last gdb command (such as \texttt{print})


\item \texttt{jl\_options} :: sometimes useful, since it lists all of the command line options that were successfully parsed


\item \texttt{jl\_uv\_stderr} :: because who doesn{\textquotesingle}t like to be able to interact with stdio

\end{itemize}


\hypertarget{7178558395386377758}{}


\subsection{Useful Julia functions for Inspecting those variables}



\begin{itemize}
\item \texttt{jl\_gdblookup(\$rip)} :: For looking up the current function and line. (use \texttt{\$eip} on i686 platforms)


\item \texttt{jlbacktrace()} :: For dumping the current Julia backtrace stack to stderr. Only usable after \texttt{record\_backtrace()} has been called.


\item \texttt{jl\_dump\_llvm\_value(Value*)} :: For invoking \texttt{Value->dump()} in gdb, where it doesn{\textquotesingle}t work natively. For example, \texttt{f->linfo->functionObject}, \texttt{f->linfo->specFunctionObject}, and \texttt{to\_function(f->linfo)}.


\item \texttt{Type->dump()} :: only works in lldb. Note: add something like \texttt{;1} to prevent lldb from printing its prompt over the output


\item \texttt{jl\_eval\_string({\textquotedbl}expr{\textquotedbl})} :: for invoking side-effects to modify the current state or to lookup symbols


\item \texttt{jl\_typeof(jl\_value\_t*)} :: for extracting the type tag of a Julia value (in gdb, call \texttt{macro define jl\_typeof jl\_typeof} first, or pick something short like \texttt{ty} for the first arg to define a shorthand)

\end{itemize}


\hypertarget{1392415358123037898}{}


\subsection{Inserting breakpoints for inspection from gdb}



In your \texttt{gdb} session, set a breakpoint in \texttt{jl\_breakpoint} like so:




\begin{lstlisting}
(gdb) break jl_breakpoint
\end{lstlisting}



Then within your Julia code, insert a call to \texttt{jl\_breakpoint} by adding




\begin{minted}{julia}
ccall(:jl_breakpoint, Void, (Any,), obj)
\end{minted}



where \texttt{obj} can be any variable or tuple you want to be accessible in the breakpoint.



It{\textquotesingle}s particularly helpful to back up to the \texttt{jl\_apply} frame, from which you can display the arguments to a function using, e.g.,




\begin{lstlisting}
(gdb) call jl_(args[0])
\end{lstlisting}



Another useful frame is \texttt{to\_function(jl\_method\_instance\_t *li, bool cstyle)}. The \texttt{jl\_method\_instance\_t*} argument is a struct with a reference to the final AST sent into the compiler. However, the AST at this point will usually be compressed; to view the AST, call \texttt{jl\_uncompress\_ast} and then pass the result to \texttt{jl\_}:




\begin{lstlisting}
#2  0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584
584          abort();
(gdb) p jl_(jl_uncompress_ast(li, li->ast))
\end{lstlisting}



\hypertarget{10952602490249170772}{}


\subsection{Inserting breakpoints upon certain conditions}



\hypertarget{796097711199942153}{}


\subsubsection{Loading a particular file}



Let{\textquotesingle}s say the file is \texttt{sysimg.jl}:




\begin{lstlisting}
(gdb) break jl_load if strcmp(fname, "sysimg.jl")==0
\end{lstlisting}



\hypertarget{11262037379695434792}{}


\subsubsection{Calling a particular method}




\begin{lstlisting}
(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), "method_to_break")==0
\end{lstlisting}



Since this function is used for every call, you will make everything 1000x slower if you do this.



\hypertarget{12553217263049394878}{}


\subsection{Dealing with signals}



Julia requires a few signal to function property. The profiler uses \texttt{SIGUSR2} for sampling and the garbage collector uses \texttt{SIGSEGV} for threads synchronization. If you are debugging some code that uses the profiler or multiple threads, you may want to let the debugger ignore these signals since they can be triggered very often during normal operations. The command to do this in GDB is (replace \texttt{SIGSEGV} with \texttt{SIGUSRS} or other signals you want to ignore):




\begin{lstlisting}
(gdb) handle SIGSEGV noprint nostop pass
\end{lstlisting}



The corresponding LLDB command is (after the process is started):




\begin{lstlisting}
(lldb) pro hand -p true -s false -n false SIGSEGV
\end{lstlisting}



If you are debugging a segfault with threaded code, you can set a breakpoint on \texttt{jl\_critical\_error} (\texttt{sigdie\_handler} should also work on Linux and BSD) in order to only catch the actual segfault rather than the GC synchronization points.



\hypertarget{8144212274800572894}{}


\subsection{Debugging during Julia{\textquotesingle}s build process (bootstrap)}



Errors that occur during \texttt{make} need special handling. Julia is built in two stages, constructing \texttt{sys0} and \texttt{sys.ji}. To see what commands are running at the time of failure, use \texttt{make VERBOSE=1}.



At the time of this writing, you can debug build errors during the \texttt{sys0} phase from the \texttt{base} directory using:




\begin{lstlisting}
julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jl
\end{lstlisting}



You might need to delete all the files in \texttt{usr/lib/julia/} to get this to work.



You can debug the \texttt{sys.ji} phase using:




\begin{lstlisting}
julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jl
\end{lstlisting}



By default, any errors will cause Julia to exit, even under gdb. To catch an error {\textquotedbl}in the act{\textquotedbl}, set a breakpoint in \texttt{jl\_error} (there are several other useful spots, for specific kinds of failures, including: \texttt{jl\_too\_few\_args}, \texttt{jl\_too\_many\_args}, and \texttt{jl\_throw}).



Once an error is caught, a useful technique is to walk up the stack and examine the function by inspecting the related call to \texttt{jl\_apply}. To take a real-world example:




\begin{lstlisting}
Breakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802
802 {
(gdb) p jl_(e)
ErrorException("auto_unbox: unable to determine argument type")
$2 = void
(gdb) bt 10
#0  jl_throw (e=0x7ffdf42de400) at task.c:802
#1  0x00007ffff65412fe in jl_error (str=0x7ffde56be000 <_j_str267> "auto_unbox:
   unable to determine argument type")
   at builtins.c:39
#2  0x00007ffde56bd01a in julia_convert_16886 ()
#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281
...
\end{lstlisting}



The most recent \texttt{jl\_apply} is at frame \#3, so we can go back there and look at the AST for the function \texttt{julia\_convert\_16886}. This is the uniqued name for some method of \texttt{convert}. \texttt{f} in this frame is a \texttt{jl\_function\_t*}, so we can look at the type signature, if any, from the \texttt{specTypes} field:




\begin{lstlisting}
(gdb) f 3
#3  0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281
1281            return f->fptr((jl_value_t*)f, args, nargs);
(gdb) p f->linfo->specTypes
$4 = (jl_tupletype_t *) 0x7ffdf39b1030
(gdb) p jl_( f->linfo->specTypes )
Tuple{Type{Float32}, Float64}           # <-- type signature for julia_convert_16886
\end{lstlisting}



Then, we can look at the AST for this function:




\begin{lstlisting}
(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )
Expr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any, 1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,
Expr(:line, 90, :float.jl)::Any,
Expr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any)::Any
\end{lstlisting}



Finally, and perhaps most usefully, we can force the function to be recompiled in order to step through the codegen process. To do this, clear the cached \texttt{functionObject} from the \texttt{jl\_lamdbda\_info\_t*}:




\begin{lstlisting}
(gdb) p f->linfo->functionObject
$8 = (void *) 0x1289d070
(gdb) set f->linfo->functionObject = NULL
\end{lstlisting}



Then, set a breakpoint somewhere useful (e.g. \texttt{emit\_function}, \texttt{emit\_expr}, \texttt{emit\_call}, etc.), and run codegen:




\begin{lstlisting}
(gdb) p jl_compile(f)
... # your breakpoint here
\end{lstlisting}



\hypertarget{15283936980874101721}{}


\subsection{Debugging precompilation errors}



Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint or catching failures in a precompile worker requires attaching a debugger to the worker. The easiest approach is to set the debugger watch for new process launches matching a given name. For example:




\begin{lstlisting}
(gdb) attach -w -n julia-debug
\end{lstlisting}



or:




\begin{lstlisting}
(lldb) process attach -w -n julia-debug
\end{lstlisting}



Then run a script/command to start precompilation. As described earlier, use conditional breakpoints in the parent process to catch specific file-loading events and narrow the debugging window. (some operating systems may require alternative approaches, such as following each \texttt{fork} from the parent process)



\hypertarget{2874239207045478266}{}


\subsection{Mozilla{\textquotesingle}s Record and Replay Framework (rr)}



Julia now works out of the box with \href{http://rr-project.org/}{rr}, the lightweight recording and deterministic debugging framework from Mozilla. This allows you to replay the trace of an execution deterministically.  The replayed execution{\textquotesingle}s address spaces, register contents, syscall data etc are exactly the same in every run.



A recent version of rr (3.1.0 or higher) is required.



\hypertarget{13430054895263354316}{}


\section{Usando Valgrind con Julia}



\href{http://valgrind.org/}{Valgrind} es una herramienta para deputación de memoria, deteccin de fallos de página y creación de perfiles. Esta sección describe cosas a tner en cuenta cuando se usa Valgrind para depurar cuestiones de memoria con Julia.



\hypertarget{11180677432667553519}{}


\subsection{Consideraciones Generales}



Por defecto, Valgrind asume que no hay código automodificador en el programa que está ejecutando. Esta suposición trabaja bien en la mayoría de las instancias, pero falla miserablemente para un compilador JIT como \texttt{julia}. Por esta razón es crucial pasar \texttt{--smc-check=all-non-file} a \texttt{valgrind}, si no el código puede bloquearse o comportarse de forma inesperada (frecuentemente de una forma sutil).



En algunos casos, para detectar mejor errores de memoria usando Valgrind puede ayudar compilar \texttt{julia} con los \emph{pools} de memoria dehabilitados. El flag de tiempo de compilación \texttt{MEMDEBUG} desabilita los \emph{pools} de memoria en Julia y el flag \texttt{MEMDEBUG2} deshabilita los pools de memoria en FemtoLisp. Para construir \texttt{julia} con ambos flags, añada la siguiente línea a \texttt{Make.user}:




\begin{minted}{julia}
CFLAGS = -DMEMDEBUG -DMEMDEBUG2
\end{minted}



Otra cosa a notar: si nuestros programa usa múltiples procesos workers, es probable que queramos que todos esos procesos worker se ejecuten bajo Valgrind, no sólo bajo el proceso padre. Para hacer esto, pasaremos \texttt{--trace-children=yes} a \texttt{valgrind}.



\hypertarget{13140039522330031277}{}


\subsection{Supresiones}



Valgrind tipicamente mostrará avisos falsos mientras se ejecuta. Para reducir el número de tales avisos, ayuda proporcionar un \href{http://valgrind.org/docs/manual/manual-core.html\#manual-core.suppress}{fichero supresiones} a Valgrind. Un fichero supresiones de ejemplo se incluye en la distribución fuente de Julia en \texttt{contrib/valgrind-julia.supp}.



El fichero de supresiones puede ser usado desde el directorio fuente \texttt{julia/} de la siguiente manera:




\begin{lstlisting}
$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jl
\end{lstlisting}



Any memory errors that are displayed should either be reported as bugs or contributed as additional suppressions.  Note that some versions of Valgrind are \href{https://github.com/JuliaLang/julia/issues/8314\#issuecomment-55766210}{shipped with insufficient default suppressions}, so that may be one thing to consider before submitting any bugs.



\hypertarget{10173787738831416739}{}


\subsection{Running the Julia test suite under Valgrind}



It is possible to run the entire Julia test suite under Valgrind, but it does take quite some time (typically several hours).  To do so, run the following command from the \texttt{julia/test/} directory:




\begin{lstlisting}
valgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia.supp ../julia runtests.jl all
\end{lstlisting}



If you would like to see a report of {\textquotedbl}definite{\textquotedbl} memory leaks, pass the flags \texttt{--leak-check=full --show-leak-kinds=definite} to \texttt{valgrind} as well.



\hypertarget{11463604234155946056}{}


\subsection{Caveats}



Valgrind currently \href{https://bugs.kde.org/show\_bug.cgi?id=136779}{does not support multiple rounding modes}, so code that adjusts the rounding mode will behave differently when run under Valgrind.



In general, if after setting \texttt{--smc-check=all-non-file} you find that your program behaves differently when run under Valgrind, it may help to pass \texttt{--tool=none} to \texttt{valgrind} as you investigate further.  This will enable the minimal Valgrind machinery but will also run much faster than when the full memory checker is enabled.



\hypertarget{7492492303482218484}{}


\section{Sanitizer support}



\hypertarget{527857279218691176}{}


\subsection{General considerations}



Using Clang{\textquotesingle}s sanitizers obviously require you to use Clang (\texttt{USECLANG=1}), but there{\textquotesingle}s another catch: most sanitizers require a run-time library, provided by the host compiler, while the instrumented code generated by Julia{\textquotesingle}s JIT relies on functionality from that library. This implies that the LLVM version of your host compiler matches that of the LLVM library used within Julia.



An easy solution is to have an dedicated build folder for providing a matching toolchain, by building with \texttt{BUILD\_LLVM\_CLANG=1} and overriding \texttt{LLVM\_USE\_CMAKE=1} (Autotool-based builds are incompatible with ASAN). You can then refer to this toolchain from another build folder by specifying \texttt{USECLANG=1} while overriding the \texttt{CC} and \texttt{CXX} variables.



\hypertarget{1061650975116506198}{}


\subsection{Address Sanitizer (ASAN)}



For detecting or debugging memory bugs, you can use Clang{\textquotesingle}s \href{http://clang.llvm.org/docs/AddressSanitizer.html}{address sanitizer (ASAN)}. By compiling with \texttt{SANITIZE=1} you enable ASAN for the Julia compiler and its generated code. In addition, you can specify \texttt{LLVM\_SANITIZE=1} to sanitize the LLVM library as well. Note that these options incur a high performance and memory cost. For example, using ASAN for Julia and LLVM makes \texttt{testall1} takes 8-10 times as long while using 20 times as much memory (this can be reduced to respectively a factor of 3 and 4 by using the options described below).



By default, Julia sets the \texttt{allow\_user\_segv\_handler=1} ASAN flag, which is required for signal delivery to work properly. You can define other options using the \texttt{ASAN\_OPTIONS} environment flag, in which case you{\textquotesingle}ll need to repeat the default option mentioned before. For example, memory usage can be reduced by specifying \texttt{fast\_unwind\_on\_malloc=0} and \texttt{malloc\_context\_size=2}, at the cost of backtrace accuracy. For now, Julia also sets \texttt{detect\_leaks=0}, but this should be removed in the future.



\hypertarget{11752764117060042950}{}


\subsection{Memory Sanitizer (MSAN)}



For detecting use of uninitialized memory, you can use Clang{\textquotesingle}s \href{http://clang.llvm.org/docs/MemorySanitizer.html}{memory sanitizer (MSAN)} by compiling with \texttt{SANITIZE\_MEMORY=1}.



\end{document}
