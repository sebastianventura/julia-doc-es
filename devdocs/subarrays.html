<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SubArrays · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/introduction.html">Introducción</a></li><li><a class="toctext" href="../manual/getting-started.html">Empezando</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/functions.html">Funciones</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="../manual/types.html">Tipos</a></li><li><a class="toctext" href="../manual/methods.html">Métodos</a></li><li><a class="toctext" href="../manual/constructors.html">Constructores</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversión and Promoción</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">Módulos</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="../manual/arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="../manual/environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/packages.html">Paquetes</a></li><li><a class="toctext" href="../manual/profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="../manual/stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="../manual/unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="ast.html">Julia ASTs</a></li><li><a class="toctext" href="types.html">Más sobre tipos</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li><a class="toctext" href="compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="functions.html">Julia Functions</a></li><li><a class="toctext" href="cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li class="current"><a class="toctext" href="subarrays.html">SubArrays</a><ul class="internal"><li><a class="toctext" href="#Indexación:-indexación-cartesiana-vs.-lineal-1">Indexación: indexación cartesiana vs. lineal</a></li><li><a class="toctext" href="#Reemplazo-de-Índices-1">Reemplazo de Índices</a></li><li><a class="toctext" href="#Diseño-de-SubArray&#39;s-1">Diseño de SubArray&#39;s</a></li></ul></li><li><a class="toctext" href="sysimg.html">System Image Building</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li>Documentation of Julia&#39;s Internals</li><li><a href="subarrays.html">SubArrays</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/devdocs/subarrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>SubArrays</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="subarrays-1" href="#subarrays-1">SubArrays</a></h1><p>El tipo <code>SubArray</code> de Julia es un contenedor que codifica una &quot;vista&quot; de un <a href="../stdlib/arrays.html#Core.AbstractArray"><code>AbstractArray</code></a> padre.  Esta pagina documenta algunos de los principios de diseño e implementación de <code>SubArray</code>.</p><h2><a class="nav-anchor" id="Indexación:-indexación-cartesiana-vs.-lineal-1" href="#Indexación:-indexación-cartesiana-vs.-lineal-1">Indexación: indexación cartesiana vs. lineal</a></h2><p>Ampliamente hablando, hay dos formas principales de acceder a los datos en un array. La primera, frecuentemente llamada indexación cartesiana, usa <code>N</code> índices para un <code>AbstractArray</code> <code>N</code> -dimensional. Por ejemlo, una matriz <code>A</code> (bidimensional) puede ser indexada en estilo cartesiano como <code>A[i,j]</code>. El segundo método de indexación, denominado indexación lineal, usa un solo índice incluso para objetos de mayor dimensión. Por ejemplo si <code>A = reshape(1:12, 3, 4)</code>, la expresión <code>A[5]</code> devuelve el valor 5. Julia nos permite combinar estos estilos de indexación: por ejemplo, un array 3d <code>A3</code> puede ser indexado como <code>A3[i,j]</code>, en cuyo caso <code>i</code> es interpretado como un índice cartesiano para la primera dimensión, y <code>j</code> es un índice lineal sobre las dimensiones 2 y 3.</p><p>Para los <code>Array</code>s, la indexación lineal apela al formato subyacente de almacenamiento: un array se presenta como un bloque contiguo de memoria, y por tanto el índice lineal es justo el desplazamiento (+1) de la correspondiente entrada relativa al principio del array. Sin embargo, esto no es cierto para muchos otros tipos <code>AbstractArray</code>: ejemplos de ello incluyen <a href="../stdlib/arrays.html#Base.SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>, unos arrays que requieren alguna clase de cálculo (tal como interpolación), y el tipo bajo discusión aquí, <code>SubArray</code>. Para estos tipos, la información subyacente es descrita más naturalmente en términos de índices cartesianos. </p><p>Uno puede convertir manualmente un índice cartesiano a uno lineal con <code>sub2ind</code>, y viceversa usando ìnd2sub<code>. Las funciones</code>getindex<code>and</code>setindex!<code>de los tipos</code>AbstractArray` puden incluir operaciones similares.</p><p>Aunque convertir de un índice cartesiano a uno lineal es rápido (es justo una multiplicación y una suma), convertir de un índice lineal a uno cartesiano es muy lento: se basa en la operación <code>div</code>, que es una de las operacions de bajo nivel más lentas que uno puede realizar con una CPU. Por esta razón, cualquier código que trate con tipos <code>AbstractArray</code> está mejor diseñado en términos de indexación cartesiana en lugar de lineal.</p><h2><a class="nav-anchor" id="Reemplazo-de-Índices-1" href="#Reemplazo-de-Índices-1">Reemplazo de Índices</a></h2><p>Considere hacer rebanadas bidimensionales de un array tridimensional:</p><pre><code class="language-julia">S1 = view(A, :, 5, 2:6)
S2 = view(A, 5, :, 2:6)</code></pre><p><code>view</code> elimina las dimensiones &quot;singleton&quot; (las que están especificadas por un <code>Int</code>), por lo que tanto <code>S1</code> como <code>S2</code> son <code>SubArray</code>s bidimensionales. En consecuencia, el camino natural para indexar esto es con <code>S1[i,j]</code>. Para extraer el valor del array padre <code>A</code>, el enfoque natural es reemplazar <code>S1[i,j]</code> con <code>A[i,5,(2:6)[j]]</code> y <code>S2[i,j]</code> con <code>A[5,i,(2:6)[j]]</code>.</p><p>La característica clave del diseño de SubArrays es que este reemplazo de índices puede realizarse sin ninguna sobrecarga en tiempo de ejecución.</p><h2><a class="nav-anchor" id="Diseño-de-SubArray&#39;s-1" href="#Diseño-de-SubArray&#39;s-1">Diseño de SubArray&#39;s</a></h2><h3><a class="nav-anchor" id="Parámetros-de-Tipo-y-Campos-1" href="#Parámetros-de-Tipo-y-Campos-1">Parámetros de Tipo y Campos</a></h3><p>La estrategia adoptada está expresada en la definición del tipo:</p><pre><code class="language-julia">struct SubArray{T,N,P,I,L} &lt;: AbstractArray{T,N}
    parent::P
    indexes::I
    offset1::Int       # for linear indexing and pointer, only valid when L==true
    stride1::Int       # used only for linear indexing
    ...
end</code></pre><p><code>SubArray</code> tiene cinco parámetros de tipo. Los dos primeros son el tipo de elemento estándar y la dimensionalidad. La siguiente es el tipo del <code>AbstractArray</code> padre. El usado más intensamente es el cuarto parámetro, una <code>Tuple</code> de los tipos de los índices para cada dimensión. El final, <code>L</code>,  es sólo proporcionado como una conveniencia para el despacho; es un valor booleano que representa si los tipos del índice soportan indexacion lineal rápida. Más sobre este tema después.  </p><p>Si en nuestro ejemplo de arriba <code>A</code> es un <code>Array{Float64, 3}</code>, nuestro caso <code>S1</code> sería un  <code>SubArray{Int64,2,Array{Int64,3},Tuple{Colon,Int64,UnitRange{Int64}},false}</code>. Note en particular el parámetro tupla, que almacena los tipos de los índices usados para crear <code>S1</code>.  Igualmente,</p><pre><code class="language-julia-repl">julia&gt; S1.indexes
(Colon(),5,2:6)</code></pre><p>Almacenar estos valores permite el reemplzao de índices, y tener los tipos codificados como parámetros permite a uno despachar a eficientes algoritmos.</p><h3><a class="nav-anchor" id="Traducción-de-Índices-1" href="#Traducción-de-Índices-1">Traducción de Índices</a></h3><p>Realizar la traducción de índices requiere que uno haga diferentes cosas para diferentes tipos concretos de <code>SubArray</code>. Por ejemplo, para <code>S1</code> uno necesita aplicar los índices <code>i,j</code> a las dimensiones primera y tercera del array padre, mientras que para <code>S2</code> uno necesita aplicarlas a la segunda y la tercera. El enfoque más sencillo a indexar sería hacer el análisis de tipos en tiempo de ejecución:</p><pre><code class="language-julia">parentindexes = Array{Any}(0)
for thisindex in S.indexes
    ...
    if isa(thisindex, Int)
        # Don&#39;t consume one of the input indexes
        push!(parentindexes, thisindex)
    elseif isa(thisindex, AbstractVector)
        # Consume an input index
        push!(parentindexes, thisindex[inputindex[j]])
        j += 1
    elseif isa(thisindex, AbstractMatrix)
        # Consume two input indices
        push!(parentindexes, thisindex[inputindex[j], inputindex[j+1]])
        j += 2
    elseif ...
end
S.parent[parentindexes...]</code></pre><p>Desgraciadamente, esto sería desastroso en términos de rendimiento: cada acceso a elemento asignaría memoria, e implicaría la ejecución de un montón de código pobremente tipado.</p><p>El mejor enfoque es despachar a métodos específicos para manejar cada tipo de índice almacenado. Esto es lo que hace <code>reindex</code>: él despacha sobre el tipo del primer índice almacenado y consume el número apropiado de índices de entrada, y entonces recurre sobre los índices restantes. En el caso de <code>S1</code>, esto expande a</p><pre><code class="language-julia">Base.reindex(S1, S1.indexes, (i, j)) == (i, S1.indexes[2], S1.indexes[3][j])</code></pre><p>para cualquier par de índices <code>(i,j)</code> (excepto <code>CartesianIndex</code>s and arrays de este tipo, ver abajo).</p><p>Este es el núcleo de un <code>SubArray</code>; los métodos de indexación se basan en <code>reindex</code> para hacer esta traducción de índices. Sin embargo, algunas veces, podemos evitar la indirección y hacerlo incluso más rápido.</p><h3><a class="nav-anchor" id="Indexación-Lineal-1" href="#Indexación-Lineal-1">Indexación Lineal</a></h3><p>La indexación lineal puede implementarse de forma eficiente cuando el array completo tiene un solo paso que separe elementos sucesivos, empezando desde cierto desplazamiento. Esto significa que nosotros pre-computamos estos valores y representamos la indexación lineal simplemente como una adición y multiplicación, evitando la indirección de <code>reindex</code> y (lo que es más importante) la computación lenta de las coordenadas cartesianas por completo.</p><p>Para los tipos <code>SubArray</code>, la disponibilidad de una indexación lineal eficiente está basada puramente en los tipos de los índices, y no depende de valores como el tamaño de array padre. Uno puede preguntar si un cnjunto de índices dado soporta indexación lineal rápida con la función interna <code>Base.viewindexing</code>:</p><pre><code class="language-julia-repl">julia&gt; Base.viewindexing(S1.indexes)
IndexCartesian()

julia&gt; Base.viewindexing(S2.indexes)
IndexLinear()</code></pre><p>Esto se calcula durante la construcción del <code>SubArray</code> y se almacena en el parámetro de tipo <code>L</code> como un boolean que codifica soporte de indexación lineal rápido. Aunque n oes estrictamente necesario, esto significa qeu podemos definir despacho directamente sobre <code>SubArray{T,N,A,I,true}</code> sin intermediarios.</p><p>Como esta computación no depende de valores en tiempo de ejecución, puede perder algunos casos en los que el paso sea uniforme:</p><pre><code class="language-julia-repl">julia&gt; A = reshape(1:4*2, 4, 2)
4×2 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1  5
 2  6
 3  7
 4  8

julia&gt; diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 2
 2</code></pre><p>Una vista construída como <code>view(A, 2:2:4, :)</code> tiene un paso uniforme y, por tanto la indexación lineal podría llevarse a cabo eficientemente. Sin embargo, el éxito en este caso depende del tamaño del array: Si, a diferencia del caso anterior, la primera dimensión fuera impar,</p><pre><code class="language-julia-repl">julia&gt; A = reshape(1:5*2, 5, 2)
5×2 Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}}:
 1   6
 2   7
 3   8
 4   9
 5  10

julia&gt; diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 3
 2</code></pre><p>entonces <code>A[2:2:4,:]</code> no tiene un paso uniforme, por lo que no podemos garantizar indexación lineal eficiente. Como tenemos que basar esta decisión puramente en los tipos codificados en los parámetros del <code>SubArray</code>, <code>S = view(A, 2:2:4, :)</code> no puede implementar una indexación lienal eficiente.</p><h3><a class="nav-anchor" id="Unos-pocos-detalles-1" href="#Unos-pocos-detalles-1">Unos pocos detalles</a></h3><ul><li><p>Note que la función <code>Base.reindex</code> es agnóstica a los tipos de los índices de entrada; ella simplemente determina como y donde deberían reindexarse los indices almacenados. Ella no solo soporta indices enteros,</p></li></ul><p> sino que también soporta indexación no escalar. Esto significa que las vistas de vistas no necesitan dos    niveles de indirección; ellas pueden simplemente recomputar los índices en el array padre original.  </p><ul><li><p>Es de esperar que a estas alturas esté bastante claro que soportar rebanadas en arrays significa que la dimensionalidad, dada por el parámetro <code>N</code>, no es necesariamente igual a la dimensionalidad del array padre o la longitud de la tupla <code>indexes</code>. Tampoco los índices proporcionados por el usuario se alinean necesariamente con las entradas en la tupla <code>indexes</code> (por ejemplo, el segundo índice proporcionado por el usuario puede corresponder a la tercera dimensión de la matriz padre, y el tercer elemento en la tupla <code>indexes</code>).</p><p>Lo que podría ser menos obvio es que la dimensionalidad del array padre almacenado sea igual al número de  índices efectivos en la tupla <code>indexes</code>. Algunos ejemplos:</p><pre><code class="language-julia">A = reshape(1:35, 5, 7) # A 2d parent Array
S = view(A, 2:7)         # A 1d view created by linear indexing
S = view(A, :, :, 1:1)   # Appending extra indices is supported</code></pre><p>Ingenuamente, uno pensaría que podría simplemente establecer <code>S.parent = A</code> y<code>S.indexes = (:,:, 1: 1)</code>,  pero el hecho de soportar esto complica dramáticamente el proceso de reindexación, especialmente para  vistas de vistas. No solo se necesita despachar los tipos de los índices almacenados, sino que se debe  examinar si un índice dado es el último y &quot;fusionar&quot; los índices almacenados restantes. Esto no es una  tarea fácil, y aún peor: es lenta ya que depende implícitamente de la indexación lineal.</p><p>Afortunadamente, este es precisamente el cálculo que &#39;ReshapedArray&#39; realiza, y lo hace linealmente si es posible. En consecuencia, <code>view</code> asegura que el array padre es la dimensionalidad adecuada para los  índices dados mediante reformateo (<em>reshaping</em>) si es necesario. El constructor interno <code>SubArray</code>  asegura que este invariante esté satisfecha.</p></li><li><p><code>CartesianIndex</code> y sus matrices retuercen de una forma desagradable el esquema <code>reindex</code>. Recuerde  que <code>reindex</code> simplemente despacha sobre el tipo de índices almacenados para determinar cuántos  índices pasados deberían usarse y a dónde deberían ir. Pero con <code>CartesianIndex</code>, ya no hay una  correspondencia uno a uno entre la cantidad de argumentos pasados y la cantidad de dimensiones en  las que indexan. Si volvemos al ejemplo anterior de <code>Base.reindex(S1, S1.indexes, (i, j))</code>, puede  ver que la expansión es incorrecta para <code>i, j = CartesianIndex (), CartesianIndex (2,1 )</code>. Él  debería <em>salta</em> el <code>CartesianIndex()</code> por completo y devolver:</p><pre><code class="language-julia">(CartesianIndex(2,1)[1], S1.indexes[2], S1.indexes[3][CartesianIndex(2,1)[2]])</code></pre><p>Y si embargo, lo que devuelve es:</p><pre><code class="language-julia">(CartesianIndex(), S1.indexes[2], S1.indexes[3][CartesianIndex(2,1)])</code></pre><p>Hacer esto correctamente requeriría el envío <em>combinado</em> en los índices almacenados y pasados en  todas las combinaciones de dimensionalidades de una manera intratable. Como tal, <code>reindex</code> nunca  debe invocarse con índices <code>CartesianIndex</code>. Afortunadamente, el caso escalar se maneja fácilmente  aplanando primero los argumentos <code>CartesianIndex</code> a enteros simples. Sin embargo, las matrices de  <code>CartesianIndex</code> no se pueden dividir en piezas ortogonales tan fácilmente. Antes de intentar usar  <code>reindex</code>,<code>view</code> debe garantizar que no haya matrices de <code>CartesianIndex</code> en la lista de argumentos.  Si los hay, simplemente puede &quot;puntualizar&quot; evitando por completo el cálculo de &#39;reindex&#39;, construyendo  un <code>SubArray</code> anidado con dos niveles de indirección en su lugar.</p></li></ul><footer><hr/><a class="previous" href="meta.html"><span class="direction">Previous</span><span class="title">Talking to the compiler (the <code>:meta</code> mechanism)</span></a><a class="next" href="sysimg.html"><span class="direction">Next</span><span class="title">System Image Building</span></a></footer></article></body></html>
