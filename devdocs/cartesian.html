<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Base.Cartesian · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/introduction.html">Introducción</a></li><li><a class="toctext" href="../manual/getting-started.html">Empezando</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/functions.html">Funciones</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="../manual/types.html">Tipos</a></li><li><a class="toctext" href="../manual/methods.html">Métodos</a></li><li><a class="toctext" href="../manual/constructors.html">Constructores</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversión y Promoción</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">Módulos</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="../manual/arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="../manual/environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/packages.html">Paquetes</a></li><li><a class="toctext" href="../manual/profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="../manual/stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="../manual/unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="../stdlib/math.html">Matemáticas</a></li><li><a class="toctext" href="../stdlib/numbers.html">Números</a></li><li><a class="toctext" href="../stdlib/strings.html">Cadenas</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="../stdlib/linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="../stdlib/constants.html">Constantes</a></li><li><a class="toctext" href="../stdlib/file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="../stdlib/io-network.html">E/S y Redes</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Puntuación</a></li><li><a class="toctext" href="../stdlib/sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="../stdlib/pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="../stdlib/dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="../stdlib/iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="../stdlib/test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="../stdlib/c.html">Interfaz C</a></li><li><a class="toctext" href="../stdlib/libc.html">Librería Estándar C</a></li><li><a class="toctext" href="../stdlib/libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="../stdlib/simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="ast.html">Julia ASTs</a></li><li><a class="toctext" href="types.html">Más sobre tipos</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li><a class="toctext" href="compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="functions.html">Julia Functions</a></li><li class="current"><a class="toctext" href="cartesian.html">Base.Cartesian</a><ul class="internal"><li><a class="toctext" href="#Principios-de-uso-1">Principios de uso</a></li><li><a class="toctext" href="#Sintaxis-Básica-1">Sintaxis Básica</a></li></ul></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="subarrays.html">SubArrays</a></li><li><a class="toctext" href="sysimg.html">System Image Building</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="boundscheck.html">Comprobación de Límites</a></li><li><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li>Documentation of Julia&#39;s Internals</li><li><a href="cartesian.html">Base.Cartesian</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/devdocs/cartesian.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Base.Cartesian</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="cartesian-1" href="#cartesian-1">Base.Cartesian</a></h1><p>El módulo <code>Cartesian</code> (no exportado) proporciona macros que facilitan escribir algoritmos multidimensionales. Es deseable que, a largo plazo, este módulo <code>Cartesian</code> no sea necesario; sin embargo, en la actualidad es una de las pocas formas de escribir código multidimensional compacto y con rendimiento.</p><h2><a class="nav-anchor" id="Principios-de-uso-1" href="#Principios-de-uso-1">Principios de uso</a></h2><p>Un ejemplo de uso simple podría ser:</p><pre><code class="language-julia">@nloops 3 i A begin
    s += @nref 3 A i
end</code></pre><p>que genera el siguiente código:</p><pre><code class="language-julia">for i_3 = 1:size(A,3)
    for i_2 = 1:size(A,2)
        for i_1 = 1:size(A,1)
            s += A[i_1,i_2,i_3]
        end
    end
end</code></pre><p>En general, <code>Cartesian</code> permitirá escribir código que contiene elementos repetitivos, como los bucles anidados de este ejemplo. Otras aplicaciones incluyen expresiones repetidas (por ejemplo, desenrollado de bucles) o crear llamadas a función con números variables de argumentos sin usar la construcción &quot;<em>splat</em>&quot; (<code>i...</code>).</p><h2><a class="nav-anchor" id="Sintaxis-Básica-1" href="#Sintaxis-Básica-1">Sintaxis Básica</a></h2><p>La sintaxis básica de <code>@nloops</code> es la siguiente:</p><p> * El primer argumento debe ser un entero (<em>no</em> una variable) que especifica el número de bucles.   * El segundo argumento es el prefijo simbólico que se utilizará para la variable iteradora. De este modo, en el ejemplo anterior usamos <code>i</code>, y se generaron las variables  <code>i_1, i_2, i_3</code>.   * El tercer argumento especifica el rango para cada variable iteradora. Si se usa una variable (símbolo) aquí, es considerado como <code>1:size(A,dim)</code>. De forma más flexible, se puede usar la sintaxis de expresiones basadas en funciones anónimas que se decribe más adelante.   * El último argumento es el cuerpo del bucle. En el ejemplo anterior, lo que aparece entre <code>begin...end</code>.</p><p>Hay otras características adicionales de <code>@nloops</code> descritas en la <a href="cartesian.html#dev-cartesian-reference-1">sección de referencia</a>.</p><p><code>@nref</code> sigue un patrn similar, generando <code>A[i_1,i_2,i_3]</code> a partir de <code>@nref 3 A i</code>. La práctica general es leer de izquierda a derecha, por lo que <code>@nloops</code> es <code>@nloops 3 i A expr</code> (como en el bucle <code>for i_2 = 1:size(A,2)</code>, donde <code>i_2</code> está a la izquierda y el rango a la derecha) mientras que <code>@nref</code> es <code>@nref 3 A i</code> (como en <code>A[i_1,i_2,i_3]</code>, donde el array va primero).</p><p>Si ests desarrollando código con Cartesian, puedes encontrar que depurar es más sencillo cuando examinas el código generado, usando <code>macroexpand</code>:</p><pre><code class="language-julia-repl">julia&gt; macroexpand(:(@nref 2 A i))
:(A[i_1, i_2])</code></pre><h3><a class="nav-anchor" id="Proporcionando-el-número-de-expresiones-1" href="#Proporcionando-el-número-de-expresiones-1">Proporcionando el número de expresiones</a></h3><p>El primer argumentos de estas dos macros es el número de expresiones, que debe ser un entero. Cuando estás escribiendo una funcin que pretendes que trabaje en múltiples dimensiones, esto puede no ser algo que desees codificar. Si estás escribiendo código que necesitas que trabaje con versiones antiguas de Julia, deberías usar la macro <code>@ngenerate</code> descrita en <a href="https://docs.julialang.org/en/release-0.3/devdocs/cartesian/#supplying-the-number-of-expressions">una versión más antigua de esta documentación</a>.</p><p>Empezando en Julia 0.4-pre, el enfoque recomendado es usar una <code>@generated function</code>.  He aquí un ejemplo:</p><pre><code class="language-julia">@generated function mysum(A::Array{T,N}) where {T,N}
    quote
        s = zero(T)
        @nloops $N i A begin
            s += @nref $N A i
        end
        s
    end
end</code></pre><p>Naturalmente, también podemos preparar expresiones o realizar cálculos antes del bloque <code>quote</code>.</p><h3><a class="nav-anchor" id="Expresiones-función-anónima-como-argumentos-de-macros-1" href="#Expresiones-función-anónima-como-argumentos-de-macros-1">Expresiones función anónima como argumentos de macros</a></h3><p>Quizás la característica más potente de <code>Cartesian</code> es la capacidad de proporcionar expresiones función-anónima que son evaluadas en tiempo de análisis sintáctico. Consideremos un ejemplo sencillo:</p><pre><code class="language-julia">@nexprs 2 j-&gt;(i_j = 1)</code></pre><p><code>@nexprs</code> genera <code>n</code> expresiones que siguen un patrón. Este código generaría las siguientes instrucciones:</p><pre><code class="language-julia">i_1 = 1
i_2 = 1</code></pre><p>En cada instrucción generada un <code>j</code> aislado (la variable de la función anónima) es reemplazada por valores en el rango <code>1:2</code>. Hablando de forma general, Cartesian emplea una sintaxis parecida a LaTeX. Esto te permite hacer operaciones sobre el índice <code>j</code>.  He aquí un ejemplo que calcula los pasos de un array:</p><pre><code class="language-julia">s_1 = 1
@nexprs 3 j-&gt;(s_{j+1} = s_j * size(A, j))</code></pre><p>generará las expresiones</p><pre><code class="language-julia">s_1 = 1
s_2 = s_1 * size(A, 1)
s_3 = s_2 * size(A, 2)
s_4 = s_3 * size(A, 3)</code></pre><p>Las expresiones función anónima tienen muchos usos en la práctica.</p><h4><a class="nav-anchor" id="dev-cartesian-reference-1" href="#dev-cartesian-reference-1">Referencia de las Macros</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cartesian.@nloops" href="#Base.Cartesian.@nloops"><code>Base.Cartesian.@nloops</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@nloops N itersym rangeexpr bodyexpr
@nloops N itersym rangeexpr preexpr bodyexpr
@nloops N itersym rangeexpr preexpr postexpr bodyexpr</code></pre><p>Generate <code>N</code> nested loops, using <code>itersym</code> as the prefix for the iteration variables. <code>rangeexpr</code> may be an anonymous-function expression, or a simple symbol <code>var</code> in which case the range is <code>indices(var, d)</code> for dimension <code>d</code>.</p><p>Optionally, you can provide &quot;pre&quot; and &quot;post&quot; expressions. These get executed first and last, respectively, in the body of each loop. For example:</p><pre><code class="language-none">@nloops 2 i A d -&gt; j_d = min(i_d, 5) begin
    s += @nref 2 A j
end</code></pre><p>would generate:</p><pre><code class="language-none">for i_2 = indices(A, 2)
    j_2 = min(i_2, 5)
    for i_1 = indices(A, 1)
        j_1 = min(i_1, 5)
        s += A[j_1, j_2]
    end
end</code></pre><p>If you want just a post-expression, supply <code>nothing</code> for the pre-expression. Using parentheses and semicolons, you can supply multi-statement expressions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L9-L37">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cartesian.@nref" href="#Base.Cartesian.@nref"><code>Base.Cartesian.@nref</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@nref N A indexexpr</code></pre><p>Generate expressions like <code>A[i_1, i_2, ...]</code>. <code>indexexpr</code> can either be an iteration-symbol prefix, or an anonymous-function expression.</p><pre><code class="language-julia-repl">julia&gt; @macroexpand Base.Cartesian.@nref 3 A i
:(A[i_1, i_2, i_3])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L72-L82">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cartesian.@nextract" href="#Base.Cartesian.@nextract"><code>Base.Cartesian.@nextract</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@nextract N esym isym</code></pre><p>Generate <code>N</code> variables <code>esym_1</code>, <code>esym_2</code>, ..., <code>esym_N</code> to extract values from <code>isym</code>. <code>isym</code> can be either a <code>Symbol</code> or anonymous-function expression.</p><p><code>@nextract 2 x y</code> would generate</p><pre><code class="language-none">x_1 = y[1]
x_2 = y[2]</code></pre><p>while <code>@nextract 3 x d-&gt;y[2d-1]</code> yields</p><pre><code class="language-none">x_1 = y[1]
x_2 = y[3]
x_3 = y[5]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L142-L159">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cartesian.@nexprs" href="#Base.Cartesian.@nexprs"><code>Base.Cartesian.@nexprs</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@nexprs N expr</code></pre><p>Generate <code>N</code> expressions. <code>expr</code> should be an anonymous-function expression.</p><pre><code class="language-julia-repl">julia&gt; @macroexpand Base.Cartesian.@nexprs 4 i -&gt; y[i] = A[i+j]
quote
    y[1] = A[1 + j]
    y[2] = A[2 + j]
    y[3] = A[3 + j]
    y[4] = A[4 + j]
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L118-L132">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cartesian.@ncall" href="#Base.Cartesian.@ncall"><code>Base.Cartesian.@ncall</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@ncall N f sym...</code></pre><p>Generate a function call expression. <code>sym</code> represents any number of function arguments, the last of which may be an anonymous-function expression and is expanded into <code>N</code> arguments.</p><p>For example <code>@ncall 3 func a</code> generates</p><pre><code class="language-none">func(a_1, a_2, a_3)</code></pre><p>while <code>@ncall 2 func a b i-&gt;c[i]</code> yields</p><pre><code class="language-none">func(a, b, c[1], c[2])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L92-L106">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cartesian.@ntuple" href="#Base.Cartesian.@ntuple"><code>Base.Cartesian.@ntuple</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@ntuple N expr</code></pre><p>Generates an <code>N</code>-tuple. <code>@ntuple 2 i</code> would generate <code>(i_1, i_2)</code>, and <code>@ntuple 2 k-&gt;k+1</code> would generate <code>(2,3)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L215-L220">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cartesian.@nall" href="#Base.Cartesian.@nall"><code>Base.Cartesian.@nall</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@nall N expr</code></pre><p>Check whether all of the expressions generated by the anonymous-function expression <code>expr</code> evaluate to <code>true</code>.</p><p><code>@nall 3 d-&gt;(i_d &gt; 1)</code> would generate the expression <code>(i_1 &gt; 1 &amp;&amp; i_2 &gt; 1 &amp;&amp; i_3 &gt; 1)</code>. This can be convenient for bounds-checking.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L174-L182">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cartesian.@nany" href="#Base.Cartesian.@nany"><code>Base.Cartesian.@nany</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@nany N expr</code></pre><p>Check whether any of the expressions generated by the anonymous-function expression <code>expr</code> evaluate to <code>true</code>.</p><p><code>@nany 3 d-&gt;(i_d &gt; 1)</code> would generate the expression <code>(i_1 &gt; 1 || i_2 &gt; 1 || i_3 &gt; 1)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L195-L202">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Cartesian.@nif" href="#Base.Cartesian.@nif"><code>Base.Cartesian.@nif</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@nif N conditionexpr expr
@nif N conditionexpr expr elseexpr</code></pre><p>Generates a sequence of <code>if ... elseif ... else ... end</code> statements. For example:</p><pre><code class="language-none">@nif 3 d-&gt;(i_d &gt;= size(A,d)) d-&gt;(error(&quot;Dimension &quot;, d, &quot; too big&quot;)) d-&gt;println(&quot;All OK&quot;)</code></pre><p>would generate:</p><pre><code class="language-none">if i_1 &gt; size(A, 1)
    error(&quot;Dimension &quot;, 1, &quot; too big&quot;)
elseif i_2 &gt; size(A, 2)
    error(&quot;Dimension &quot;, 2, &quot; too big&quot;)
else
    println(&quot;All OK&quot;)
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/cartesian.jl#L230-L247">source</a><br/></section><footer><hr/><a class="previous" href="functions.html"><span class="direction">Previous</span><span class="title">Julia Functions</span></a><a class="next" href="meta.html"><span class="direction">Next</span><span class="title">Talking to the compiler (the <code>:meta</code> mechanism)</span></a></footer></article></body></html>
