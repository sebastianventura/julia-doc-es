<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ordenación y Funciones Relacionadas · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/introduction.html">Introducción</a></li><li><a class="toctext" href="../manual/getting-started.html">Empezando</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="base.html">Essentials</a></li><li><a class="toctext" href="collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="math.html">Mathematics</a></li><li><a class="toctext" href="numbers.html">Números</a></li><li><a class="toctext" href="strings.html">Cadenas</a></li><li><a class="toctext" href="arrays.html">Arrays</a></li><li><a class="toctext" href="parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="constants.html">Constantes</a></li><li><a class="toctext" href="file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="io-network.html">E/S y Redes</a></li><li><a class="toctext" href="punctuation.html">Puntuación</a></li><li class="current"><a class="toctext" href="sort.html">Ordenación y Funciones Relacionadas</a><ul class="internal"><li><a class="toctext" href="#Funciones-de-Ordenación-1">Funciones de Ordenación</a></li><li><a class="toctext" href="#Funciones-relacionadas-con-Orden-1">Funciones relacionadas con Orden</a></li><li><a class="toctext" href="#Algoritmos-de-Ordenación-1">Algoritmos de Ordenación</a></li></ul></li><li><a class="toctext" href="pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="iterators.html">Utilidades para Iteración</a></li><li><a class="toctext" href="test.html">Haciendo Pruebas Unitarias</a></li><li><a class="toctext" href="c.html">Interfaz C</a></li><li><a class="toctext" href="libc.html">Librería Estándar C</a></li><li><a class="toctext" href="libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href="sort.html">Ordenación y Funciones Relacionadas</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/stdlib/sort.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Ordenación y Funciones Relacionadas</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="sort-1" href="#sort-1">Ordenación y Funciones Relacionadas</a></h1><p>Julia tiene una API amplia y flexible para ordenar e interactuar con matrices de valores ya ordenados. Por defecto, Julia selecciona algoritmos y ordenaciones razonables en orden ascendente estándar:</p><pre><code class="language-julia-repl">julia&gt; sort([2,3,1])
3-element Array{Int64,1}:
 1
 2
 3</code></pre><p>Uno también puede ordenar en orden inverso:</p><pre><code class="language-julia-repl">julia&gt; sort([2,3,1], rev=true)
3-element Array{Int64,1}:
 3
 2
 1</code></pre><p>Para ordenar un array en el lugar, use la versión con admiración de la función de ordenación:</p><pre><code class="language-julia-repl">julia&gt; a = [2,3,1];

julia&gt; sort!(a);

julia&gt; a
3-element Array{Int64,1}:
 1
 2
 3</code></pre><p>En lugar de ordenar un array directamente, podemos computar una preemutación de los índices del array que ponen el array en un orden determinado:</p><pre><code class="language-julia-repl">julia&gt; v = randn(5)
5-element Array{Float64,1}:
  0.297288
  0.382396
 -0.597634
 -0.0104452
 -0.839027

julia&gt; p = sortperm(v)
5-element Array{Int64,1}:
 5
 3
 4
 1
 2

julia&gt; v[p]
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</code></pre><p>Los arrays pueden ser ordenados fácilmente de acuerdo a una transformacin arbitraria de sus valores:</p><pre><code class="language-julia-repl">julia&gt; sort(v, by=abs)
5-element Array{Float64,1}:
 -0.0104452
  0.297288
  0.382396
 -0.597634
 -0.839027</code></pre><p>O en orden reverso mediante una transformación</p><pre><code class="language-julia-repl">julia&gt; sort(v, by=abs, rev=true)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
  0.382396
  0.297288
 -0.0104452</code></pre><p>Si es necesario, puede elegirse el algoritmo de ordenación:</p><pre><code class="language-julia-repl">julia&gt; sort(v, alg=InsertionSort)
5-element Array{Float64,1}:
 -0.839027
 -0.597634
 -0.0104452
  0.297288
  0.382396</code></pre><p>Todas las funciones de ordenación y relacionadas con orden se basan en una relación &quot;menor que&quot; que define un orden total sobre los valores que van a manipularse. La función <code>isless</code> es la invocada por defecto, pero la relación puede ser especificada mediante la palabra clave <code>lt</code>.</p><h2><a class="nav-anchor" id="Funciones-de-Ordenación-1" href="#Funciones-de-Ordenación-1">Funciones de Ordenación</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort!" href="#Base.sort!"><code>Base.sort!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort the vector <code>v</code> in place. <code>QuickSort</code> is used by default for numeric arrays while <code>MergeSort</code> is used for other arrays. You can specify an algorithm to use via the <code>alg</code> keyword (see Sorting Algorithms for available algorithms). The <code>by</code> keyword lets you provide a function that will be applied to each element before comparison; the <code>lt</code> keyword allows providing a custom &quot;less than&quot; function; use <code>rev=true</code> to reverse the sorting order. These options are independent and can be used together in all possible combinations: if both <code>by</code> and <code>lt</code> are specified, the <code>lt</code> function is applied to the result of the <code>by</code> function; <code>rev=true</code> reverses whatever ordering specified via the <code>by</code> and <code>lt</code> keywords.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2]; sort!(v); v
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; v = [3, 1, 2]; sort!(v, rev = true); v
3-element Array{Int64,1}:
 3
 2
 1

julia&gt; v = [(1, &quot;c&quot;), (3, &quot;a&quot;), (2, &quot;b&quot;)]; sort!(v, by = x -&gt; x[1]); v
3-element Array{Tuple{Int64,String},1}:
 (1, &quot;c&quot;)
 (2, &quot;b&quot;)
 (3, &quot;a&quot;)

julia&gt; v = [(1, &quot;c&quot;), (3, &quot;a&quot;), (2, &quot;b&quot;)]; sort!(v, by = x -&gt; x[2]); v
3-element Array{Tuple{Int64,String},1}:
 (3, &quot;a&quot;)
 (2, &quot;b&quot;)
 (1, &quot;c&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L439-L478">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Variant of <a href="sort.html#Base.sort!"><code>sort!</code></a> that returns a sorted copy of <code>v</code> leaving <code>v</code> itself unmodified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2];

julia&gt; sort(v)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; v
3-element Array{Int64,1}:
 3
 1
 2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L523-L545">source</a><br/><div><pre><code class="language-none">sort(A, dim::Integer; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)</code></pre><p>Sort a multidimensional array <code>A</code> along the given dimension. See <a href="sort.html#Base.sort!"><code>sort!</code></a> for a description of possible keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4 3; 1 2]
2×2 Array{Int64,2}:
 4  3
 1  2

julia&gt; sort(A, 1)
2×2 Array{Int64,2}:
 1  2
 4  3

julia&gt; sort(A, 2)
2×2 Array{Int64,2}:
 3  4
 1  2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L696-L721">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sortperm" href="#Base.sortperm"><code>Base.sortperm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Return a permutation vector of indices of <code>v</code> that puts it in sorted order. Specify <code>alg</code> to choose a particular sorting algorithm (see Sorting Algorithms). <code>MergeSort</code> is used by default, and since it is stable, the resulting permutation will be the lexicographically first one that puts the input array into sorted order – i.e. indices of equal elements appear in ascending order. If you choose a non-stable sorting algorithm such as <code>QuickSort</code>, a different permutation that puts the array into order may be returned. The order is specified using the same keywords as <code>sort!</code>.</p><p>See also <a href="sort.html#Base.Sort.sortperm!"><code>sortperm!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2];

julia&gt; p = sortperm(v)
3-element Array{Int64,1}:
 2
 3
 1

julia&gt; v[p]
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L573-L603">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.sortperm!" href="#Base.Sort.sortperm!"><code>Base.Sort.sortperm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward, initialized::Bool=false)</code></pre><p>Like <a href="sort.html#Base.sortperm"><code>sortperm</code></a>, but accepts a preallocated index vector <code>ix</code>.  If <code>initialized</code> is <code>false</code> (the default), <code>ix</code> is initialized to contain the values <code>1:length(v)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = [3, 1, 2]; p = zeros(Int, 3);

julia&gt; sortperm!(p, v); p
3-element Array{Int64,1}:
 2
 3
 1

julia&gt; v[p]
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L630-L653">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.sortrows" href="#Base.Sort.sortrows"><code>Base.Sort.sortrows</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sortrows(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort the rows of matrix <code>A</code> lexicographically. See <a href="sort.html#Base.sort!"><code>sort!</code></a> for a description of possible keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sortrows([7 3 5; -1 6 4; 9 -2 8])
3×3 Array{Int64,2}:
 -1   6  4
  7   3  5
  9  -2  8

julia&gt; sortrows([7 3 5; -1 6 4; 9 -2 8], lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4

julia&gt; sortrows([7 3 5; -1 6 4; 9 -2 8], rev=true)
3×3 Array{Int64,2}:
  9  -2  8
  7   3  5
 -1   6  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L753-L781">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.sortcols" href="#Base.Sort.sortcols"><code>Base.Sort.sortcols</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sortcols(A; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort the columns of matrix <code>A</code> lexicographically. See <a href="sort.html#Base.sort!"><code>sort!</code></a> for a description of possible keyword arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sortcols([7 3 5; 6 -1 -4; 9 -2 8])
3×3 Array{Int64,2}:
  3   5  7
 -1  -4  6
 -2   8  9

julia&gt; sortcols([7 3 5; 6 -1 -4; 9 -2 8], alg=InsertionSort, lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Array{Int64,2}:
  5   3  7
 -4  -1  6
  8  -2  9

julia&gt; sortcols([7 3 5; 6 -1 -4; 9 -2 8], rev=true)
3×3 Array{Int64,2}:
 7   5   3
 6  -4  -1
 9   8  -2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L793-L821">source</a><br/></section><h2><a class="nav-anchor" id="Funciones-relacionadas-con-Orden-1" href="#Funciones-relacionadas-con-Orden-1">Funciones relacionadas con Orden</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.issorted" href="#Base.issorted"><code>Base.issorted</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">issorted(v, lt=isless, by=identity, rev:Bool=false, order::Ordering=Forward)</code></pre><p>Test whether a vector is in sorted order. The <code>lt</code>, <code>by</code> and <code>rev</code> keywords modify what order is considered to be sorted just as they do for <a href="sort.html#Base.sort"><code>sort</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; issorted([1, 2, 3])
true

julia&gt; issorted([(1, &quot;b&quot;), (2, &quot;a&quot;)], by = x -&gt; x[1])
true

julia&gt; issorted([(1, &quot;b&quot;), (2, &quot;a&quot;)], by = x -&gt; x[2])
false

julia&gt; issorted([(1, &quot;b&quot;), (2, &quot;a&quot;)], by = x -&gt; x[2], rev=true)
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/sort.jl#L60-L80">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.searchsorted" href="#Base.Sort.searchsorted"><code>Base.Sort.searchsorted</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">searchsorted(a, x, [by=&lt;transform&gt;,] [lt=&lt;comparison&gt;,] [rev=false])</code></pre><p>Returns the range of indices of <code>a</code> which compare as equal to <code>x</code> (using binary search) according to the order specified by the <code>by</code>, <code>lt</code> and <code>rev</code> keywords, assuming that <code>a</code> is already sorted in that order. Returns an empty range located at the insertion point if <code>a</code> does not contain values equal to <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [4, 3, 2, 1]
4-element Array{Int64,1}:
 4
 3
 2
 1

julia&gt; searchsorted(a, 4)
5:4

julia&gt; searchsorted(a, 4, rev=true)
1:1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L495-L519">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.searchsortedfirst" href="#Base.Sort.searchsortedfirst"><code>Base.Sort.searchsortedfirst</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">searchsortedfirst(a, x, [by=&lt;transform&gt;,] [lt=&lt;comparison&gt;,] [rev=false])</code></pre><p>Returns the index of the first value in <code>a</code> greater than or equal to <code>x</code>, according to the specified order. Returns <code>length(a)+1</code> if <code>x</code> is greater than all values in <code>a</code>. <code>a</code> is assumed to be sorted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; searchsortedfirst([1, 2, 4, 5, 14], 4)
3

julia&gt; searchsortedfirst([1, 2, 4, 5, 14], 4, rev=true)
1

julia&gt; searchsortedfirst([1, 2, 4, 5, 14], 15)
6</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1351-L1370">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.searchsortedlast" href="#Base.Sort.searchsortedlast"><code>Base.Sort.searchsortedlast</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">searchsortedlast(a, x, [by=&lt;transform&gt;,] [lt=&lt;comparison&gt;,] [rev=false])</code></pre><p>Returns the index of the last value in <code>a</code> less than or equal to <code>x</code>, according to the specified order. Returns <code>0</code> if <code>x</code> is less than all values in <code>a</code>. <code>a</code> is assumed to be sorted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; searchsortedlast([1, 2, 4, 5, 14], 4)
3

julia&gt; searchsortedlast([1, 2, 4, 5, 14], 4, rev=true)
5

julia&gt; searchsortedlast([1, 2, 4, 5, 14], -1)
0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2026-L2045">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.select!" href="#Base.Sort.select!"><code>Base.Sort.select!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">select!(v, k, [by=&lt;transform&gt;,] [lt=&lt;comparison&gt;,] [rev=false])</code></pre><p>Partially sort the vector <code>v</code> in place, according to the order specified by <code>by</code>, <code>lt</code> and <code>rev</code> so that the value at index <code>k</code> (or range of adjacent values if <code>k</code> is a range) occurs at the position where it would appear if the array were fully sorted via a non-stable algorithm. If <code>k</code> is a single index, that value is returned; if <code>k</code> is a range, an array of values at those indices is returned. Note that <code>select!</code> does not fully sort the input array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia&gt; select!(a, 4)
4

julia&gt; a
5-element Array{Int64,1}:
 1
 2
 3
 4
 4

julia&gt; a = [1, 2, 4, 3, 4]
5-element Array{Int64,1}:
 1
 2
 4
 3
 4

julia&gt; select!(a, 4, rev=true)
2

julia&gt; a
5-element Array{Int64,1}:
 4
 4
 3
 2
 1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L853-L904">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.select" href="#Base.Sort.select"><code>Base.Sort.select</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">select(v, k, [by=&lt;transform&gt;,] [lt=&lt;comparison&gt;,] [rev=false])</code></pre><p>Variant of <a href="sort.html#Base.Sort.select!"><code>select!</code></a> which copies <code>v</code> before partially sorting it, thereby returning the same thing as <code>select!</code> but leaving <code>v</code> unmodified.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L655-L660">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.selectperm" href="#Base.Sort.selectperm"><code>Base.Sort.selectperm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">selectperm(v, k, [alg=&lt;algorithm&gt;,] [by=&lt;transform&gt;,] [lt=&lt;comparison&gt;,] [rev=false])</code></pre><p>Return a partial permutation of the vector <code>v</code>, according to the order specified by <code>by</code>, <code>lt</code> and <code>rev</code>, so that <code>v[output]</code> returns the first <code>k</code> (or range of adjacent values if <code>k</code> is a range) values of a fully sorted version of <code>v</code>. If <code>k</code> is a single index (Integer), an array of the first <code>k</code> indices is returned; if <code>k</code> is a range, an array of those indices is returned. Note that the handling of integer values for <code>k</code> is different from <a href="sort.html#Base.Sort.select"><code>select</code></a> in that it returns a vector of <code>k</code> elements instead of just the <code>k</code> th element. Also note that this is equivalent to, but more efficient than, calling <code>sortperm(...)[k]</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1231-L1242">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.selectperm!" href="#Base.Sort.selectperm!"><code>Base.Sort.selectperm!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">selectperm!(ix, v, k, [alg=&lt;algorithm&gt;,] [by=&lt;transform&gt;,] [lt=&lt;comparison&gt;,] [rev=false,] [initialized=false])</code></pre><p>Like <a href="sort.html#Base.Sort.selectperm"><code>selectperm</code></a>, but accepts a preallocated index vector <code>ix</code>. If <code>initialized</code> is <code>false</code> (the default), ix is initialized to contain the values <code>1:length(ix)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1396-L1401">source</a><br/></section><h2><a class="nav-anchor" id="Algoritmos-de-Ordenación-1" href="#Algoritmos-de-Ordenación-1">Algoritmos de Ordenación</a></h2><p>Actualmente hay cuatro algoritmos de ordenación disponibles en Julia base:</p><ul><li><p><code>InsertionSort</code></p></li><li><p><code>QuickSort</code></p></li><li><p><code>PartialQuickSort(k)</code></p></li><li><p><code>MergeSort</code></p></li></ul><p><code>InsertionSort</code> es un algoritmo de ordenación estable cuyo coste es O(n^2). Es eficiente para <code>n</code> muy pequeños, y es usado internamente por <code>QuickSort</code>.</p><p><code>QuickSort</code> es un algoritmo de ordenación que es <em>in-place</em> muy rápido pero no estable (es decir, los elementos que son considerados iguales no permanecerán en el mismo orden en que se encontraban originalmente en el array antes de ser ordenados. Su coste computacional es O(n log n). <code>QuickSort</code> es el algoritmo por defecto para valores numéricos, incluyendo enteros y punto flotante.</p><p><code>PartialQuickSort(k)</code> es similar a <code>QuickSort</code>, pero el array de salida es sólo ordenado hasta el índice  <code>k</code> si <code>k</code> es un entero, o en el rango de <code>k</code> si <code>k</code> es un <code>OrdinalRange</code>. Por ejemplo:</p><pre><code class="language-julia">x = rand(1:500, 100)
k = 50
k2 = 50:100
s = sort(x; alg=QuickSort)
ps = sort(x; alg=PartialQuickSort(k))
qs = sort(x; alg=PartialQuickSort(k2))
map(issorted, (s, ps, qs))             # =&gt; (true, false, false)
map(x-&gt;issorted(x[1:k]), (s, ps, qs))  # =&gt; (true, true, false)
map(x-&gt;issorted(x[k2]), (s, ps, qs))   # =&gt; (true, false, true)
s[1:k] == ps[1:k]                      # =&gt; true
s[k2] == qs[k2]                        # =&gt; true</code></pre><p><code>MergeSort</code> es un algoritmo de ordenación estable, pero no <em>in-place</em> (requiere un array temporal de la mitad del tamaño del array de entrada), de coste O(n log n) y no suele ser tan rapido como <code>QuickSort</code>. Es el algoritmo por defecto para datos no numéricos.</p><p>Los algoritmos de clasificación por defecto se eligen sobre la base de que son rápidos y estables, o <em>parezcan</em> serlo. Para los tipos numéricos, de hecho, se selecciona <code>QuickSort</code> ya que es más rápido e indistinguible en este caso de un tipo estable (a menos que la matriz registre sus mutaciones de alguna manera). La propiedad de estabilidad tiene un costo no despreciable, por lo que si no la necesita, puede especificar explícitamente su algoritmo preferido, p. <code>sort!(v, alg=QuickSort)</code>.</p><p>El mecanismo por el cual Julia selecciona los algoritmos de clasificación predeterminados se implementa a través de la función <code>Base.Sort.defalg</code>. Permite que un algoritmo particular se registre como el predeterminado en todas las funciones de ordenación para arrays específicos. Por ejemplo, aquí están los dos métodos predeterminados de <a href="https://github.com/JuliaLang/julia/blob/master/base/sort.jl"><code>sort.jl</code></a>:</p><pre><code class="language-julia">defalg(v::AbstractArray) = MergeSort
defalg{T&lt;:Number}(v::AbstractArray{T}) = QuickSort</code></pre><p>En cuanto a los arrays numéricos, la elección de un algoritmo predeterminado no estable para los tipos de array para los cuales la noción de ordenación estable no tiene sentido (es decir, cuando dos valores que comparan iguales no se pueden distinguir) puede tener sentido.</p><footer><hr/><a class="previous" href="punctuation.html"><span class="direction">Previous</span><span class="title">Puntuación</span></a><a class="next" href="pkg.html"><span class="direction">Next</span><span class="title">Funciones del Administrador de Paquetes</span></a></footer></article></body></html>
