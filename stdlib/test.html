<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Haciendo Pruebas Unitarias · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/introduction.html">Introducción</a></li><li><a class="toctext" href="../manual/getting-started.html">Empezando</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Números enteros y en punto flotante</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Números Racionales y Complejos</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/functions.html">Funciones</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Ámbito de las variables</a></li><li><a class="toctext" href="../manual/types.html">Tipos</a></li><li><a class="toctext" href="../manual/methods.html">Métodos</a></li><li><a class="toctext" href="../manual/constructors.html">Constructores</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversión and Promoción</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">Módulos</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramación</a></li><li><a class="toctext" href="../manual/arrays.html">Arrays Multi-dimensionales</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Álgebra Lineal</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Redes y Flujos</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Computación Paralela</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interactuando con Julia</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Ejecutando programas externos</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Llamando a código C y Fortran</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Manejando variaciones en el Sistema Operativo</a></li><li><a class="toctext" href="../manual/environment-variables.html">Variables de Entorno</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/packages.html">Paquetes</a></li><li><a class="toctext" href="../manual/profile.html">Elaboración de Perfiles (<em>Profiling</em>)</a></li><li><a class="toctext" href="../manual/stacktraces.html">Trazas de Pila</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">Guía de Estilo</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Diferencias notables con otros idiomas</a></li><li><a class="toctext" href="../manual/unicode-input.html">Entrada Unicode</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="base.html">Essentials</a></li><li><a class="toctext" href="collections.html">Colecciones y Estructuras de Datos</a></li><li><a class="toctext" href="math.html">Mathematics</a></li><li><a class="toctext" href="numbers.html">Números</a></li><li><a class="toctext" href="strings.html">Cadenas</a></li><li><a class="toctext" href="arrays.html">Arrays</a></li><li><a class="toctext" href="parallel.html">Tareas y Computación Paralela</a></li><li><a class="toctext" href="linalg.html">Álgebra Lineal</a></li><li><a class="toctext" href="constants.html">Constantes</a></li><li><a class="toctext" href="file.html">Sistema de Ficheros</a></li><li><a class="toctext" href="io-network.html">E/S y Redes</a></li><li><a class="toctext" href="punctuation.html">Puntuación</a></li><li><a class="toctext" href="sort.html">Ordenación y Funciones Relacionadas</a></li><li><a class="toctext" href="pkg.html">Funciones del Administrador de Paquetes</a></li><li><a class="toctext" href="dates.html">Fechas y  Tiempo</a></li><li><a class="toctext" href="iterators.html">Utilidades para Iteración</a></li><li class="current"><a class="toctext" href="test.html">Haciendo Pruebas Unitarias</a><ul class="internal"><li><a class="toctext" href="#Probando-Julia-Base-1">Probando Julia Base</a></li><li><a class="toctext" href="#Pruebas-Unitarias-Básicas-1">Pruebas Unitarias Básicas</a></li><li><a class="toctext" href="#Trabajando-con-Conjuntos-de-Test-1">Trabajando con Conjuntos de Test</a></li><li><a class="toctext" href="#Otras-Macros-para-Tests-1">Otras Macros para Tests</a></li><li><a class="toctext" href="#Tests-Rotos-1">Tests Rotos</a></li><li><a class="toctext" href="#Creando-Tipos-AbstractTestSet-Personalizados-1">Creando Tipos <code>AbstractTestSet</code> Personalizados</a></li></ul></li><li><a class="toctext" href="c.html">Interfaz C</a></li><li><a class="toctext" href="libc.html">Librería Estándar C</a></li><li><a class="toctext" href="libdl.html">Enlazador Dinámico</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html"><em>StackTraces</em></a></li><li><a class="toctext" href="simd-types.html">Soporte SIMD</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">Más sobre tipos</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Usando Valgrind con Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Library</li><li><a href="test.html">Haciendo Pruebas Unitarias</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/stdlib/test.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Haciendo Pruebas Unitarias</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="test-1" href="#test-1">Haciendo Pruebas Unitarias</a></h1><h2><a class="nav-anchor" id="Probando-Julia-Base-1" href="#Probando-Julia-Base-1">Probando Julia Base</a></h2><p>Julia está en rápido desarrollo y cuenta con un amplio conjunto de pruebas para verificar su funcionalidad en múltiples plataformas. Si compila Julia desde el origen, puede ejecutar este conjunto de pruebas con <code>make test</code>. En una instalación binaria, puede ejecutar el conjunto de pruebas utilizando <code>Base.runtests()</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.runtests" href="#Base.runtests"><code>Base.runtests</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">runtests([tests=[&quot;all&quot;] [, numcores=ceil(Int, Sys.CPU_CORES / 2) ]])</code></pre><p>Run the Julia unit tests listed in <code>tests</code>, which can be either a string or an array of strings, using <code>numcores</code> processors. (not exported)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/interactiveutil.jl#L673-L678">source</a><br/></section><h2><a class="nav-anchor" id="Pruebas-Unitarias-Básicas-1" href="#Pruebas-Unitarias-Básicas-1">Pruebas Unitarias Básicas</a></h2><p>El módulo <code>Base.Test</code> proporciona una funcionalidad simple de <em>realización de pruebas unitarias</em>. Las pruebas unitarias son una forma de ver si su código es correcto al verificar que los resultados sean los esperados. Puede ser útil asegurarse de que su código aún funcione después de realizar los cambios, y se puede usar al desarrollarlo como una forma de especificar los comportamientos que su código debería tener cuando se complete.</p><p>Se pueden realizar pruebas unitarias simples con las macros <code>@test ()</code> y <code>@test_throws ()</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test" href="#Base.Test.@test"><code>Base.Test.@test</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test ex
@test f(args...) key=val ...</code></pre><p>Tests that the expression <code>ex</code> evaluates to <code>true</code>. Returns a <code>Pass</code> <code>Result</code> if it does, a <code>Fail</code> <code>Result</code> if it is <code>false</code>, and an <code>Error</code> <code>Result</code> if it could not be evaluated.</p><p>The <code>@test f(args...) key=val...</code> form is equivalent to writing <code>@test f(args..., key=val...)</code> which can be useful when the expression is a call using infix syntax such as approximate comparisons:</p><pre><code class="language-none">@test a ≈ b atol=ε</code></pre><p>This is equivalent to the uglier test <code>@test ≈(a, b, atol=ε)</code>. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (<code>k=v</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L230-L247">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_throws" href="#Base.Test.@test_throws"><code>Base.Test.@test_throws</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_throws extype ex</code></pre><p>Tests that the expression <code>ex</code> throws an exception of type <code>extype</code>. Note that <code>@test_throws</code> does not support a trailing keyword form.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L369-L374">source</a><br/></section><p>Por ejemplo, supongamos que queremos comprobar que nuestra nueva función <code>foo(x)</code> funciona como se esperaba:</p><pre><code class="language-jldoctest">julia&gt; using Base.Test

julia&gt; foo(x) = length(x)^2
foo (generic function with 1 method)</code></pre><p>Si la condición es cierta, se devuelve un <code>Pass</code>:</p><pre><code class="language-jldoctest">julia&gt; @test foo(&quot;bar&quot;) == 9
Test Passed

julia&gt; @test foo(&quot;fizz&quot;) &gt;= 10
Test Passed</code></pre><p>Si la condición es falsa, se devuelve un <code>Fail</code> y se lanza una excepción:</p><pre><code class="language-jldoctest">julia&gt; @test foo(&quot;f&quot;) == 20
Test Failed
  Expression: foo(&quot;f&quot;) == 20
   Evaluated: 1 == 20
ERROR: There was an error during testing</code></pre><p>Si la condición no pudo ser evaluada porque se lanzó una excepción, lo que ocurre en este caso porque <code>length()</code> no está definido para símbolos, se devuelve un objeto <code>Error</code> y se lanza una excepción:</p><pre><code class="language-julia-repl">julia&gt; @test foo(:cat) == 1
Error During Test
  Test threw an exception of type MethodError
  Expression: foo(:cat) == 1
  MethodError: no method matching length(::Symbol)
  Closest candidates are:
    length(::SimpleVector) at essentials.jl:256
    length(::Base.MethodList) at reflection.jl:521
    length(::MethodTable) at reflection.jl:597
    ...
  Stacktrace:
   [...]
ERROR: There was an error during testing</code></pre><p>Si esperamos que al evaluar una expresión <em>deberían</em> lanzarse una excepción, entonces podemos usar <code>@test_throws()</code> para comprobar que esto es lo que ocurre:</p><pre><code class="language-jldoctest">julia&gt; @test_throws MethodError foo(:cat)
Test Passed
      Thrown: MethodError</code></pre><h2><a class="nav-anchor" id="Trabajando-con-Conjuntos-de-Test-1" href="#Trabajando-con-Conjuntos-de-Test-1">Trabajando con Conjuntos de Test</a></h2><p>Normalmente, se utiliza una gran cantidad de pruebas para garantizar que las funciones trabajan correctamente sobre distintas entradas. En el caso de que una prueba falle, el comportamiento predeterminado es lanzar una excepción de inmediato. Sin embargo, normalmente es preferible ejecutar el resto de las pruebas primero para obtener una mejor idea de cuántos errores hay en el código que se prueba.</p><p>La macro <code>@testset()</code> se puede usar para agrupar las pruebas en <em>conjuntos</em>. En un conjunto de pruebas, se ejecutarán variasy al final de su realización se imprimirá un resumen. Si alguna de las pruebas falla o no se puede evaluar debido a un error, el conjunto de prueba arrojará una <code>TestSetException</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@testset" href="#Base.Test.@testset"><code>Base.Test.@testset</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@testset [CustomTestSet] [option=val  ...] [&quot;description&quot;] begin ... end
@testset [CustomTestSet] [option=val  ...] [&quot;description $v&quot;] for v in (...) ... end
@testset [CustomTestSet] [option=val  ...] [&quot;description $v, $w&quot;] for v in (...), w in (...) ... end</code></pre><p>Starts a new test set, or multiple test sets if a <code>for</code> loop is provided.</p><p>If no custom testset type is given it defaults to creating a <code>DefaultTestSet</code>. <code>DefaultTestSet</code> records all the results and, if there are any <code>Fail</code>s or <code>Error</code>s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</p><p>Any custom testset type (subtype of <code>AbstractTestSet</code>) can be given and it will also be used for any nested <code>@testset</code> invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</p><p>The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.</p><p>By default the <code>@testset</code> macro will return the testset object itself, though this behavior can be customized in other testset types. If a <code>for</code> loop is used then the macro collects and returns a list of the return values of the <code>finish</code> method, which by default will return a list of the testset objects used in each iteration.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L792-L817">source</a><br/></section><p>Podemos poner nuestros tests para la función <code>foo(x)</code> en un conjuntos de tests:</p><pre><code class="language-jldoctest">julia&gt; @testset &quot;Foo Tests&quot; begin
           @test foo(&quot;a&quot;)   == 1
           @test foo(&quot;ab&quot;)  == 4
           @test foo(&quot;abc&quot;) == 9
       end;
Test Summary: | Pass  Total
Foo Tests     |    3      3</code></pre><p>Los conjuntos de pruebas pueden también anidarse:</p><pre><code class="language-jldoctest">julia&gt; @testset &quot;Foo Tests&quot; begin
           @testset &quot;Animals&quot; begin
               @test foo(&quot;cat&quot;) == 9
               @test foo(&quot;dog&quot;) == foo(&quot;cat&quot;)
           end
           @testset &quot;Arrays $i&quot; for i in 1:3
               @test foo(zeros(i)) == i^2
               @test foo(ones(i)) == i^2
           end
       end;
Test Summary: | Pass  Total
Foo Tests     |    8      8</code></pre><p>En el caso de que un conjunto de pruebas anidado no tenga fallos, como pasa aquí, ello se ocultará en el resumen. Si tenemos un test que falle, sólo se mostrarán los detalles para este conjunto de tests que ha fallado:</p><pre><code class="language-julia-repl">julia&gt; @testset &quot;Foo Tests&quot; begin
           @testset &quot;Animals&quot; begin
               @testset &quot;Felines&quot; begin
                   @test foo(&quot;cat&quot;) == 9
               end
               @testset &quot;Canines&quot; begin
                   @test foo(&quot;dog&quot;) == 9
               end
           end
           @testset &quot;Arrays&quot; begin
               @test foo(zeros(2)) == 4
               @test foo(ones(4)) == 15
           end
       end

Arrays: Test Failed
  Expression: foo(ones(4)) == 15
   Evaluated: 16 == 15
Stacktrace:
    [...]
Test Summary: | Pass  Fail  Total
Foo Tests     |    3     1      4
  Animals     |    2            2
  Arrays      |    1     1      2
ERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.</code></pre><h2><a class="nav-anchor" id="Otras-Macros-para-Tests-1" href="#Otras-Macros-para-Tests-1">Otras Macros para Tests</a></h2><p>Como los cálculos sobre valores en punto flotane pueden ser imprecisos, podemos realizar comprobaciones de igualdad aproximada usando <code>@test a ≈ b</code> (donde <code>≈</code>, se obtiene mediante terminación con tabulador de <code>\approx</code>, es la función <a href="math.html#Base.isapprox"><code>isapprox()</code></a>) o usar directamente <a href="math.html#Base.isapprox"><code>isapprox()</code></a>.</p><pre><code class="language-julia-repl">julia&gt; @test 1 ≈ 0.999999999
Test Passed

julia&gt; @test 1 ≈ 0.999999
Test Failed
  Expression: 1 ≈ 0.999999
   Evaluated: 1 ≈ 0.999999
ERROR: There was an error during testing</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@inferred" href="#Base.Test.@inferred"><code>Base.Test.@inferred</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@inferred f(x)</code></pre><p>Tests that the call expression <code>f(x)</code> returns a value of the same type inferred by the compiler. It is useful to check for type stability.</p><p><code>f(x)</code> can be any call expression. Returns the result of <code>f(x)</code> if the types match, and an <code>Error</code> <code>Result</code> if it finds different types.</p><pre><code class="language-julia-repl">julia&gt; using Base.Test

julia&gt; f(a,b,c) = b &gt; 1 ? 1 : 1.0
f (generic function with 1 method)

julia&gt; typeof(f(1,2,3))
Int64

julia&gt; @code_warntype f(1,2,3)
Variables:
  #self# &lt;optimized out&gt;
  a &lt;optimized out&gt;
  b::Int64
  c &lt;optimized out&gt;

Body:
  begin
      unless (Base.slt_int)(1, b::Int64)::Bool goto 3
      return 1
      3:
      return 1.0
  end::UNION{FLOAT64, INT64}

julia&gt; @inferred f(1,2,3)
ERROR: return type Int64 does not match inferred return type Union{Float64, Int64}
Stacktrace:
 [1] error(::String) at ./error.jl:21

julia&gt; @inferred max(1,2)
2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L1023-L1065">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_warn" href="#Base.Test.@test_warn"><code>Base.Test.@test_warn</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_warn msg expr</code></pre><p>Test whether evaluating <code>expr</code> results in <a href="io-network.html#Base.STDERR"><code>STDERR</code></a> output that contains the <code>msg</code> string or matches the <code>msg</code> regular expression.  If <code>msg</code> is a boolean function, tests whether <code>msg(output)</code> returns <code>true</code>.  If <code>msg</code> is a tuple or array, checks that the error output contains/matches each item in <code>msg</code>. Returns the result of evaluating <code>expr</code>.</p><p>See also <a href="test.html#Base.Test.@test_nowarn"><code>@test_nowarn</code></a> to check for the absence of error output.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L412-L422">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_nowarn" href="#Base.Test.@test_nowarn"><code>Base.Test.@test_nowarn</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_nowarn expr</code></pre><p>Test whether evaluating <code>expr</code> results in empty <a href="io-network.html#Base.STDERR"><code>STDERR</code></a> output (no warnings or other messages).  Returns the result of evaluating <code>expr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L443-L448">source</a><br/></section><h2><a class="nav-anchor" id="Tests-Rotos-1" href="#Tests-Rotos-1">Tests Rotos</a></h2><p>Si un test falla consistentemente puede ser cambiado para utilizar la macro <code>@test_broken()</code>. Esto denotará el test como Roto  (<code>Broken</code>) si el test continua fallando y alterta al usuaria a traves de un <code>Error</code> si el test tiene éxito.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_broken" href="#Base.Test.@test_broken"><code>Base.Test.@test_broken</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_broken ex
@test_broken f(args...) key=val ...</code></pre><p>Indicates a test that should pass but currently consistently fails. Tests that the expression <code>ex</code> evaluates to <code>false</code> or causes an exception. Returns a <code>Broken</code> <code>Result</code> if it does, or an <code>Error</code> <code>Result</code> if the expression evaluates to <code>true</code>.</p><p>The <code>@test_broken f(args...) key=val...</code> form works as for the <code>@test</code> macro.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L255-L265">source</a><br/></section><p><code>@test_skip()</code> está también disponible para saltar un test sin evaluación, pero contando el test que se ha saltado en el informe del conjunto de tests. El test no se ejecutará pero da un <code>Broken</code> <code>Result</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_skip" href="#Base.Test.@test_skip"><code>Base.Test.@test_skip</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_skip ex
@test_skip f(args...) key=val ...</code></pre><p>Marks a test that should not be executed but should be included in test summary reporting as <code>Broken</code>. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.</p><p>The <code>@test_skip f(args...) key=val...</code> form works as for the <code>@test</code> macro.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L274-L283">source</a><br/></section><h2><a class="nav-anchor" id="Creando-Tipos-AbstractTestSet-Personalizados-1" href="#Creando-Tipos-AbstractTestSet-Personalizados-1">Creando Tipos <code>AbstractTestSet</code> Personalizados</a></h2><p>Los paquetes pueden crear sus propios subtipos <code>AbstractTestSet</code> implementando los métodos <code>record</code> y <code>finish</code>. El subtipo debe tener un constructor de un argumento que tome una cadena de descripción, con todas las opciones pasadas como argumentos  palabra clave.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.record" href="#Base.Test.record"><code>Base.Test.record</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">record(ts::AbstractTestSet, res::Result)</code></pre><p>Record a result to a testset. This function is called by the <code>@testset</code> infrastructure each time a contained <code>@test</code> macro completes, and is given the test result (which could be an <code>Error</code>). This will also be called with an <code>Error</code> if an exception is thrown inside the test block but outside of a <code>@test</code> context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L464-L471">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.finish" href="#Base.Test.finish"><code>Base.Test.finish</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">finish(ts::AbstractTestSet)</code></pre><p>Do any final processing necessary for the given testset. This is called by the <code>@testset</code> infrastructure after a test block executes. One common use for this function is to record the testset to the parent&#39;s results list, using <code>get_testset</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L474-L481">source</a><br/></section><p><code>Base.Test</code> asume la responsabilidad de mantener una pila de conjuntos de pruebas anidados a medida que se ejecutan, pero cualquier acumulación de resultados es responsabilidad del subtipo<code>AbstractTestSet</code>. Puede acceder a esta pila con los métodos <code>get_testset</code> y<code>get_testset_depth</code>. Tenga en cuenta que estas funciones no se exportan.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.get_testset" href="#Base.Test.get_testset"><code>Base.Test.get_testset</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get_testset()</code></pre><p>Retrieve the active test set from the task&#39;s local storage. If no test set is active, use the fallback default test set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L977-L982">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.get_testset_depth" href="#Base.Test.get_testset_depth"><code>Base.Test.get_testset_depth</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get_testset_depth()</code></pre><p>Returns the number of active test sets, not including the defaut test set</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/test.jl#L1012-L1016">source</a><br/></section><p><code>Base.Test</code> también se asegura de que las invocaciones <code>@testset</code> anidadas utilicen el mismo subtipo <code>AbstractTestSet</code> que sus padres a menos que se establezca explícitamente. Él no propaga ninguna propiedad del conjunto de pruebas. El comportamiento de herencia de opciones se puede implementar mediante paquetes que usan la infraestructura de pila que proporciona <code>Base.Test</code>.</p><p>La definición de un subtipo básico de &#39;AbstractTestSet` podría verse así:</p><pre><code class="language-julia">import Base.Test: record, finish
using Base.Test: AbstractTestSet, Result, Pass, Fail, Error
using Base.Test: get_testset_depth, get_testset
struct CustomTestSet &lt;: Base.Test.AbstractTestSet
    description::AbstractString
    foo::Int
    results::Vector
    # constructor takes a description string and options keyword arguments
    CustomTestSet(desc; foo=1) = new(desc, foo, [])
end

record(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)
record(ts::CustomTestSet, res::Result) = push!(ts.results, res)
function finish(ts::CustomTestSet)
    # just record if we&#39;re not the top-level parent
    if get_testset_depth() &gt; 0
        record(get_testset(), ts)
    end
    ts
end</code></pre><p>Y usar este conjunto de test tiene el siguiente aspecto:</p><pre><code class="language-julia">@testset CustomTestSet foo=4 &quot;custom testset inner 2&quot; begin
    # this testset should inherit the type, but not the argument.
    @testset &quot;custom testset inner&quot; begin
        @test true
    end
end</code></pre><footer><hr/><a class="previous" href="iterators.html"><span class="direction">Previous</span><span class="title">Utilidades para Iteración</span></a><a class="next" href="c.html"><span class="direction">Next</span><span class="title">Interfaz C</span></a></footer></article></body></html>
